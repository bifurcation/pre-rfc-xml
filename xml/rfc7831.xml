<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC1964 SYSTEM "reference.RFC.1964.xml">
<!ENTITY RFC2138 SYSTEM "reference.RFC.2138.xml">
<!ENTITY RFC7530 SYSTEM "reference.RFC.7530.xml">
<!ENTITY RFC2743 SYSTEM "reference.RFC.2743.xml">
<!ENTITY RFC2865 SYSTEM "reference.RFC.2865.xml">
<!ENTITY RFC2903 SYSTEM "reference.RFC.2903.xml">
<!ENTITY RFC2904 SYSTEM "reference.RFC.2904.xml">
<!ENTITY RFC3579 SYSTEM "reference.RFC.3579.xml">
<!ENTITY RFC6733 SYSTEM "reference.RFC.6733.xml">
<!ENTITY RFC3645 SYSTEM "reference.RFC.3645.xml">
<!ENTITY RFC3748 SYSTEM "reference.RFC.3748.xml">
<!ENTITY RFC4017 SYSTEM "reference.RFC.4017.xml">
<!ENTITY RFC4072 SYSTEM "reference.RFC.4072.xml">
<!ENTITY RFC4422 SYSTEM "reference.RFC.4422.xml">
<!ENTITY RFC4462 SYSTEM "reference.RFC.4462.xml">
<!ENTITY RFC5056 SYSTEM "reference.RFC.5056.xml">
<!ENTITY RFC5080 SYSTEM "reference.RFC.5080.xml">
<!ENTITY RFC5106 SYSTEM "reference.RFC.5106.xml">
<!ENTITY RFC5705 SYSTEM "reference.RFC.5705.xml">
<!ENTITY RFC5801 SYSTEM "reference.RFC.5801.xml">
<!ENTITY RFC6749 SYSTEM "reference.RFC.6749.xml">
<!ENTITY RFC6614 SYSTEM "reference.RFC.6614.xml">
<!ENTITY RFC6677 SYSTEM "reference.RFC.6677.xml">
<!ENTITY RFC6749 SYSTEM "reference.RFC.6749.xml">
<!ENTITY RFC6973 SYSTEM "reference.RFC.6973.xml">
<!ENTITY RFC7055 SYSTEM "reference.RFC.7055.xml">
<!ENTITY RFC5246 SYSTEM "reference.RFC.5246.xml">
<!ENTITY RFC2782 SYSTEM "reference.RFC.2782.xml">
<!ENTITY RFC4033 SYSTEM "reference.RFC.4033.xml">
<!ENTITY RFC3401 SYSTEM "reference.RFC.3401.xml">
<!ENTITY RFC6066 SYSTEM "reference.RFC.6066.xml">
<!ENTITY RFC7029 SYSTEM "reference.RFC.7029.xml">
<!ENTITY RFC7170 SYSTEM "reference.RFC.7170.xml">
<!ENTITY RFC7360 SYSTEM "reference.RFC.7360.xml">
<!ENTITY RFC7499 SYSTEM "reference.RFC.7499.xml">
<!ENTITY RFC7542 SYSTEM "reference.RFC.7542.xml">
<!ENTITY RFC7585 SYSTEM "reference.RFC.7585.xml">
]>

<rfc category="info" number="7831" ipr="trust200902" submissionType="IETF"
     consensus="yes">

  <front>
    <title abbrev="ABFAB Architecture">Application Bridging for Federated Access Beyond Web (ABFAB) Architecture</title>

    <author initials="J." surname="Howlett" fullname="Josh Howlett">
      <organization>Jisc</organization>
      <address>
        <postal>
          <street>Lumen House, Library Avenue, Harwell</street>
          <city>Oxford</city>
          <code>OX11 0SG</code>
          <country>United Kingdom</country>
        </postal>
        <phone>+44 1235 822363</phone>
        <email>Josh.Howlett@ja.net</email>
      </address>
    </author>

    <author initials="S." surname="Hartman" fullname="Sam Hartman">
      <organization>Painless Security</organization>
      <address>
        <postal>
          <street> </street>
          <city> </city>
          <code> </code>
          <country> </country>
        </postal>
        <phone> </phone>
        <email>hartmans-ietf@mit.edu</email>
      </address>
    </author>

    <author initials="H.T." surname="Tschofenig" fullname="Hannes Tschofenig ">
      <organization>ARM Ltd.</organization>
      <address>
        <postal>
          <street>110 Fulbourn Road</street>
          <city>Cambridge</city>
          <code> CB1 9NJ </code>
          <country>United Kingdom</country>
        </postal>
        <email>Hannes.tschofenig@gmx.net </email>
        <uri>http://www.tschofenig.priv.at</uri>
      </address>
    </author>

    <author fullname="Jim Schaad" initials="J." surname="Schaad">
      <organization>August Cellars</organization>
      <address>
        <email>ietf@augustcellars.com</email>
      </address>
    </author>

    <date month="May" year="2016"/>

    <keyword>Federated Authentication</keyword>
    <keyword>AAA</keyword>
    <keyword>RADIUS</keyword>
    <keyword>Diameter</keyword>
    <keyword>GSS-API</keyword>
    <keyword>EAP</keyword>
    <keyword>SAML</keyword>

    <abstract>
      <t>
        Over the last decade, a substantial amount of work has occurred in the
        space of federated access management. Most of this effort has
        focused on two use cases: network access and web-based access.
        However, the solutions to these use cases that have been proposed and
        deployed tend to have few building blocks in common.
      </t>
      <t>
        This memo describes an architecture that makes use of extensions to
        the commonly used security mechanisms for both federated and
        non-federated access management, including the Remote Authentication
        Dial-In User Service (RADIUS), the Generic Security Service
        Application Program Interface (GSS-API), the Extensible Authentication
        Protocol (EAP), and the Security Assertion Markup Language (SAML). The
        architecture addresses the problem of federated access management
        to primarily non-web-based services, in a manner that will scale
        to large numbers of Identity Providers, Relying Parties, and 
        federations.
      </t>
    </abstract>
  </front>

  <middle>

    <section anchor="introduction" title="Introduction">
      <t>
        Numerous security mechanisms have been deployed on the Internet to
        manage access to various resources.
        These mechanisms have been generalized and scaled over the last decade
        through mechanisms such as <xref target="RFC5801">the Simple
        Authentication and Security Layer (SASL) with the Generic Security
        Server Application Program Interface (GSS&nbhy;API) (known as the GS2
        family)</xref>; <xref target="OASIS.saml-core-2.0-os">the Security
        Assertion Markup Language (SAML)</xref>; and the Authentication,
        Authorization, and Accounting (AAA) architecture as embodied
        in <xref target="RFC2865">RADIUS</xref> and
        <xref target="RFC6733">Diameter</xref>.
      </t>

      <t>
        A Relying Party (RP) is the entity that manages access to some
        resource. The entity that is requesting access to that resource
        is often described as the client. Many security mechanisms are
        manifested as an exchange of information between these entities.
        The&nbsp;RP is therefore able to decide whether the client is
        authorized or&nbsp;not.
      </t>

      <t>
        Some security mechanisms allow the RP to delegate aspects of the
        access management decision to an entity called the Identity Provider
        (IdP). This delegation requires technical signaling, trust, and a
        common understanding of semantics between the RP and IdP.
        These aspects are generally managed within a relationship known as a
        "federation". This style of access management is accordingly
        described as "federated access management".
      </t>

      <t>
        Federated access management has evolved over
        the last decade through specifications like SAML <xref
        target="OASIS.saml-core-2.0-os"/>, OpenID
        (http://www.openid.net), OAuth <xref target="RFC6749"/>,
        and WS&nbhy;Trust <xref target="WS-TRUST"/>.
        The benefits of federated access management include:

        <list style="hanging">
          <t hangText="Single or simplified sign-on:"> 
            <vspace blankLines="1"/>
            An Internet service can delegate access management, 
            and the associated responsibilities such as identity management
            and credentialing,
            to an organization that already has a long-term relationship with
            the client.
            This is often attractive, as RPs frequently do not
            want these responsibilities.
            The client also requires fewer credentials, which is also
            desirable.
          </t>

          <t hangText="Data minimization and user participation:">
            <vspace blankLines="1"/> 
            Often, an RP does not need to know the identity of a client
            to reach an access management decision.
            It is frequently only necessary for the RP to know
            specific attributes about the client -- for example, that the
            client is affiliated with a particular organization or has a
            certain role or entitlement. Sometimes, the RP only needs to
            know a pseudonym of the client.

            <vspace blankLines="1"/>
            Prior to the release of attributes to the RP from the IdP, the IdP
            will check configuration and policy to determine if the attributes
            are to be released. There is currently no direct client
            participation in this decision.
          </t>

          <t hangText="Provisioning:">
            <vspace blankLines="1"/>
            Sometimes, an RP needs, or would like, to know more
            about a client than an affiliation or a pseudonym.
            For example, an RP may want the client's email address
            or name. Some federated access management technologies
            provide the ability for the IdP to supply this information,
            either on request by the RP or unsolicited.
          </t>
        </list>
      </t>

      <t>
        This memo describes the Application Bridging for Federated Access
        Beyond web (ABFAB) architecture. This architecture addresses the
        problem of federated access management primarily for
        non&nbhy;web-based services.  This architecture makes use of
        extensions to the commonly used security mechanisms for both federated
        and non&nbhy;federated access management, including RADIUS, the Generic
        Security Service (GSS), the Extensible Authentication Protocol (EAP),
        and SAML. The architecture should be extended to use Diameter in
        the future. It does so in a manner that is designed to scale to
        large numbers of IdPs, RPs, and federations.
      </t>

      <section anchor="terminology" title="Terminology">

        <t>
          This document uses identity management and privacy terminology from
          <xref target="RFC6973"/>.  In particular, this document uses the
          terms "identity&nbsp;provider", "relying party", "identifier",
          "pseudonymity", "unlinkability", and "anonymity".
        </t> 

        <t>
          In this architecture, the IdP consists of the following components:
          an EAP server, a RADIUS server, and, optionally, a SAML Assertion
          service.  
        </t>
        
        <t>
          This document uses the term "Network Access Identifier" (NAI)
          as defined in <xref target="RFC7542"/>. An NAI consists of a
          realm identifier, which is associated with a AAA server, and
          thus an IdP and a username, that are associated with a
          specific client of the IdP.
        </t> 

        <t>
          One of the problems some people have found with reading this
          document is that the terminology sometimes appears to be
          inconsistent. This is because the various standards that we
          refer to use different terms for the same concept. In general,
          this document uses either the ABFAB term or the term
          associated with the standard under discussion, as appropriate.
          For reference, we include <xref target="table1"/> below, which
          provides a mapping for these different terms. (Note that items
          marked "N/A" (not applicable) indicate that there is no name
          that represents the entity.)
        </t>

    <?rfc compact="no" ?>
        <texttable anchor="table1" title="Terminology">
          <ttcol align='left'>Protocol</ttcol>  <ttcol align='left'>Client</ttcol> <ttcol align='left'>Relying Party</ttcol> <ttcol align='left'>Identity Provider</ttcol>
          <c>ABFAB</c>                    <c>N/A</c>                  <c>Relying Party (RP)</c>            <c>Identity Provider (IdP)</c>
          <c></c>                         <c>Initiator</c>                <c>Acceptor</c>                              <c>N/A</c>
          <c></c>                        <c>Client</c>                                <c>Server</c>                                <c>N/A</c>
          <c>SAML</c>                     <c>Subject</c>                  <c>Service provider</c>              <c>Issuer</c>
          <c>GSS-API</c>                  <c>Initiator</c>                  <c>Acceptor</c>            <c>N/A</c>
          <c>EAP</c>                      <c>EAP peer</c>                <c>EAP authenticator</c>                                <c>EAP server</c>
          <c>AAA</c>                      <c>N/A</c>                         <c>AAA client</c>                       <c>AAA server</c>
          <c>RADIUS</c>                   <c>user</c>                   <c>NAS</c>                              <c>N/A</c>
          <c></c>                         <c>N/A</c>
          <c>RADIUS client</c>                   <c>RADIUS server</c>
        </texttable>
<?rfc compact="yes" ?>

        <section title="Channel Binding" anchor="channel_bind">
          <t>
            This document uses the term "channel binding" in two different
            contexts; this term has a different meaning in each of
            these contexts.
          </t>

          <t>
            EAP channel binding is used to implement GSS-API naming semantics.
            EAP channel binding sends a set of attributes from the peer to the
            EAP server either as part of the EAP conversation or as part of a
            secure association protocol.
            In addition, attributes are sent in the back&nbhy;end protocol
            from the EAP authenticator to the EAP server.
            The EAP server confirms the consistency of these attributes and
            provides the confirmation back to the peer.
            In this document, channel binding without qualification refers to
            EAP channel binding.
          </t>
          <t>
            GSS-API channel binding provides protection against
            man-in-the-middle attacks when GSS&nbhy;API is used for
            authentication inside of some tunnel;  it is similar to a facility
            called "cryptographic binding" in EAP.
            The binding works by each side deriving a cryptographic value from
            the tunnel itself and then using that cryptographic value to prove
            to the other side that it knows the value.
          </t>

          <t>
            See <xref target="RFC5056"/> for a discussion of the differences
            between these two facilities.  These differences can be
            summarized as follows:</t>
            <t><list style="symbols">
              <t>GSS&nbhy;API channel binding specifies that there is
              nobody between the client and the EAP authenticator.</t>
              <t>EAP channel binding allows the client to have knowledge of
              such EAP authenticator attributes as the EAP authenticator's
              name.</t>
            </list></t>

          <t>
            Typically, when considering both EAP and GSS&nbhy;API channel
            binding, people think of channel binding in combination with
            mutual authentication. This is sufficiently common that, without
            additional qualification, channel binding should be assumed
            to imply mutual authentication. In GSS&nbhy;API, without mutual
            authentication, only the acceptor has authenticated the initiator.
            Similarly, in EAP, only the EAP server has authenticated the
            peer. Sometimes, one&nbhy;way authentication is useful.
            Consider, for example, a user who wishes to access a protected
            resource for a shared whiteboard in a conference room.
            The whiteboard is the acceptor; it knows that the initiator is
            authorized to give it a presentation, and the user can validate
            that the whiteboard got the correct presentation by visual means.
            (The presentation should not be confidential in this case.)
            If channel binding is used without mutual authentication, it is
            effectively a request to disclose the resource in the context of a
            particular channel. Such an authentication would be similar in
            concept to a holder-of-key SAML Assertion.
            However, note also that although it is not happening in the
            protocol, mutual authentication is happening in the overall
            system: the user is able to visually authenticate the content.
            This is consistent with all uses of channel binding without
            protocol-level mutual authentication found so far.
          </t>
        </section>

      </section>

      <section title="An Overview of Federation">
        <t>
          In the previous section, we introduced the following entities:
          <list style="symbols">
            <t>the client,</t>
            <t>the IdP, and </t>
            <t>the RP.</t>
          </list>

          The final entity that needs to be introduced is the Individual.
          An Individual is a human being that is using the client.
          In any given situation, an Individual may or may not exist.
          Clients can act as front&nbsp;ends for Individuals, or clients
          may be independent entities that are set&nbsp;up and allowed to
          run autonomously. An example of such an independent entity can
          be found in the Trust Router Protocol
          (https://www.ietf.org/proceedings/86/slides/slides-86-rtgarea-0.pdf),
          where the routers use ABFAB to authenticate to each other.
        </t>

        <t>
          These entities and their relationships are illustrated graphically
          in <xref target="framework"/>.
        </t>

          <figure title="Entities and Their Relationships" anchor="framework">
            <artwork><![CDATA[
          ,----------\                        ,---------\
          | Identity |       Federation       | Relying |
          | Provider + <--------------------> + Party   |
          `----------'                        '---------'
                 <
                  \
                   \ Authentication
                    \
                     \
                      \
                       \
                        \  +---------+
                         \ |         |  O
                          v| Client  | \|/ Individual
                           |         |  |
                           +---------+ / \
            ]]></artwork>
          </figure>

        <t>
          The relationships between the entities in <xref target="framework"/>
          are as follows:

          <list style="hanging">
            <t hangText="Federation">
              <vspace blankLines="1"/>
              The IdP and the RPs are part of a
              federation. The relationship may be direct (they have an
              explicit trust relationship) or transitive (the trust
              relationship is mediated by one or more entities).
              The federation relationship is governed by a federation
              agreement. Within a single federation, there may be
              multiple IdPs as well as multiple RPs.

            </t>

            <t hangText="Authentication">
              <vspace blankLines="1"/>
              There is a direct relationship between the client and the
              IdP. This relationship provides the means by which they
              trust each other and can securely authenticate each other.
            </t>
          </list>
        </t>
        
        <t>
          A federation agreement typically encompasses operational
          specifications and legal rules:
        </t>
        
        <t>
          <list style="hanging">
            <t hangText="Operational Specifications:">
              <vspace blankLines="1"/>
              The goal of operational specifications is to
              provide enough definition that the system works
              and interoperability is possible.  These include
              the technical specifications (e.g., protocols used
              to communicate between the three parties),
              process standards, policies, identity proofing, credential and
              authentication algorithm requirements, performance requirements,
              assessment and audit criteria, etc.
            </t>

            <t hangText="Legal Rules:">
              <vspace blankLines="1"/>
              The legal rules take the legal framework into consideration and
              provide contractual obligations for each entity.  The rules
              define the responsibilities of each party and provide further
              clarification of the operational specifications.
              These legal rules regulate the operational specifications, make
              operational specifications legally binding to the participants,
              and define and govern the rights and responsibilities of the
              participants. The legal rules may, for example, describe
              liability for losses, termination rights, enforcement
              mechanisms, measures of damage, dispute resolution,
              warranties, etc.
            </t>
          </list>
        </t>
        
        <t>
          The operational specifications can demand the usage of a specific
          technical infrastructure, including requirements on the message
          routing intermediaries, to offer the required technical
          functionality. In other environments, the operational
          specifications require fewer technical components in order to
          meet the required technical functionality.
        </t>

        <t>
          The legal rules include many non&nbhy;technical aspects of
          federation, such as business practices and legal arrangements,
          which are outside the scope of the IETF. The legal rules can
          still have an impact on the architectural setup or on how to
          ensure the dynamic establishment of trust.
        </t>

        <t>
          While a federation agreement is often discussed within the context
          of formal relationships, such as between an enterprise and an
          employee or between a government and a citizen, a
          federation agreement does not have to require any particular
          level of formality. For an IdP and a client, it is sufficient
          for a relationship to be established by something as simple
          as using a web form and confirmation email. For an IdP and
          an RP, it is sufficient for the IdP to publish contact
          information along with a public key and for the RP to use
          that data. Within the framework of ABFAB, it will generally
          be required that a mechanism exist for the IdP to be able to
          trust the identity of the RP; if this is not present, then
          the IdP cannot provide the assurances to the client that the
          identity of the RP has been established.
        </t>

        <t>
          The nature of federation dictates that there exists some form of
          relationship between the IdP and the RP.
          This is particularly important when the RP wants to use
          information obtained from the IdP for access
          management decisions and when the IdP does not want to
          release information to every RP (or only under certain
          conditions).
        </t>
        
        <t>
          While it is possible to have a bilateral agreement between every IdP
          and every RP, on an Internet scale, this setup requires the
          introduction of the multilateral federation concept, as the
          management of such pair-wise relationships would otherwise prove
          burdensome.
        </t>
        
        <t>
          The IdP will typically have a long-term relationship with the client.
          This relationship typically involves the IdP positively identifying
          and credentialing the client (for example, at the time of employment
          within an organization). When dealing with Individuals, this process
          is called "identity proofing"
          <xref target="NIST-SP.800-63-2"/>.
          The relationship will often be instantiated within an agreement
          between the IdP and the client (for example, within an employment
          contract or terms of use that stipulate the appropriate use of
          credentials and so forth).
        </t>
        
        <t>
          The nature and quality of the relationship between the client and
          the IdP are important contributors to the level of trust that an
          RP may assign to an assertion describing a client made by an
          IdP. This is sometimes described as the level of assurance <xref
          target="NIST-SP.800-63-2"/>.
        </t>
        
        <t>
          Federation does not require an a priori relationship or a long-term
          relationship between the RP and the client; it is this property of
          federation that yields many of its benefits. However, federation
          does not preclude the possibility of a pre&nbhy;existing
          relationship between the RP and the client or the possibility
          that the RP and client may use the introduction to create a
          new long&nbhy;term relationship independent of the federation.
        </t>

        <t>
          Finally, it is important to reiterate that in some scenarios there
          might indeed be an Individual behind the client and in other cases
          the client may be autonomous.
        </t>
      </section>


      
      <section title="Challenges for Contemporary Federation">
        <t>
          As federated IdPs and RPs (services) proliferate, the
          role of an Individual can become ambiguous in certain
          circumstances. For example, a school might provide online access
          for a student's grades to their parents for review and to the
          student's teacher for modification. A teacher who is also a
          parent must clearly distinguish their role upon access.
        </t>
        
        <t>
          Similarly, as federations proliferate, it becomes increasingly
          difficult to discover which IdP(s) a user is
          associated with. This is true for both the web and non&nbhy;web
          case but is particularly acute for the latter, as many
          non&nbhy;web authentication systems are not semantically
          rich enough on their own to allow for such ambiguities.
          For instance, in the case of an email provider, SMTP and IMAP
          do not have the ability for the server to request information
          from the client, beyond the client NAI, that the server
          would then use to decide between the multiple federations it is
          associated with. However, the building blocks do exist to add
          this functionality.
        </t>
      </section>

      <section title="An Overview of ABFAB-Based Federation">
        <t>
          The previous section described the general model of federation and
          the application of access management within the federation.
          This section provides a brief overview of ABFAB in the context of
          this model.
        </t>
        
        <t>
          In this example, a client is attempting to connect to a server in
          order to either get access to some data or perform some type of
          transaction.
          In order for the client to mutually authenticate with the server,
          the following steps are taken in an ABFAB architecture (a graphical
          view of the steps can be found in <xref target="auth_flow"/>):
        </t>
        
        <t>
          <list style="numbers">
            <t>
              Client configuration:
              The client is configured with an NAI assigned by the
              IdP.  It is also configured with any keys, certificates,
              passwords, or other secret and public information needed to run
              the EAP protocols between it and the&nbsp;IdP.
            </t>
            
            <t>
              Authentication mechanism selection:
              The client is configured to use the GSS&nbhy;EAP
              GSS&nbhy;API mechanism for authentication/authorization.
            </t>
            
            <t>
              Client provides an NAI to RP:
              The client sets up a transport to the RP and begins
              GSS&nbhy;EAP authentication. In response, the RP sends an
              EAP request message (nested in GSS&nbhy;EAP) asking for the
              client's name. The client sends an EAP response with an
              NAI name form that, at a minimum, contains the realm portion
              of its full NAI.
            </t>
            
            <t>
              Discovery of federated IdP:
              The RP uses preconfigured information or a federation proxy to
              determine what IdP to use, based on policy and the realm
              portion of the provided client NAI.
              This is discussed in detail below (<xref target="discovery"/>).
            </t>
            
            <t>
              Request from RP to IdP:
              Once the RP knows who the IdP is, it (or its agent) will send a
              RADIUS request to the IdP.
              The RADIUS Access&nbhy;Request encapsulates the EAP response.
              At this stage, the RP will likely  have no idea who the client
              is. The RP sends its identity to the IdP in AAA attributes, and
              it may send a SAML request in a AAA attribute. The
              AAA network checks to see that the identity claimed by
              the RP is valid.
            </t>
            
            <t>
              IdP begins EAP with the client:
              The IdP sends an EAP message to the client with an EAP method to
              be used. The IdP should not re&nbhy;request the client's name
              in this message, but clients need to be able to handle it.
              In this case, the IdP must accept a realm only in order to
              protect the client's name from the RP. The available and
              appropriate methods are discussed below
              (<xref target="Client_Eap"/>).
            </t>

            <t>
              EAP is run:
              A bunch of EAP messages are passed between the client (EAP peer)
              and the IdP (EAP server), until the result of the authentication
              protocol is determined.
              The number and content of those messages depend on the EAP
              method selected.
              If the IdP is unable to authenticate the client, the IdP sends
              an EAP failure message to the RP.
              As part of the EAP method, the client sends an EAP
              channel&nbhy;binding message to the IdP
              (<xref target="client_channel_binding"/>).
              In the channel&nbhy;binding message, the client identifies,
              among other things, the RP to which it is attempting to
              authenticate. The IdP checks the channel&nbhy;binding data from
              the client against the data provided by the RP via the
              AAA protocol. If the bindings do not match, the IdP sends
              an EAP failure message to the RP.
            </t>
            
            <t>
              Successful EAP authentication:
              At this point, the IdP (EAP server) and client (EAP peer) have
              mutually authenticated each other.
              As a result, the client and the IdP hold two cryptographic keys:
              a Master Session Key (MSK) and an Extended MSK (EMSK).
              At this point, the client has a level of assurance regarding
              the identity of the RP, based on the name checking the IdP has
              done, using the RP naming information from the AAA framework
              and from the client (by the channel&nbhy;binding data).
            </t>
            
            <t> 
              Local IdP policy check:
              At this stage, the IdP checks local policy to determine whether
              the RP and client are authorized for a given 
              transaction/service and, if so, what attributes, if any,
              will be released to the RP. If the IdP gets a policy
              failure, it sends an EAP failure message to the RP and client.
              (The RP will have done its policy checks during the discovery
              process.)
            </t>

            <t>
              IdP provides the RP with the MSK:
              The IdP sends a success result EAP to the RP, along with an
              optional set of AAA attributes associated with the client
              (usually as one or more SAML Assertions).
              In addition, the EAP MSK is returned to the&nbsp;RP.
            </t>

            <t>
              RP processes results:
              When the RP receives the result from the IdP, it should have
              enough information to either grant or refuse a resource
              Access&nbhy;Request.
              It may have information that associates the client with specific
              authorization identities.
              If additional attributes are needed from the IdP, the RP may
              make a new SAML request to the IdP.
              It will apply these results in an application-specific way.
            </t>
            
            <t>
              RP returns results to client: Once the RP has a response,
              it must inform the client of the result. If
              all has gone well, all are authenticated, and the application
              proceeds with appropriate authorization levels. The client
              can now complete the authentication of the RP by using the
              EAP MSK value.
            </t>
            
          </list>
        </t>
        <figure title="ABFAB Authentication Steps" anchor="auth_flow">
          <artwork><![CDATA[
     Relying         Client         Identity
     Party                          Provider
     
     |              (1)             | Client configuration
     |               |              |
     |<-----(2)----->|              | Mechanism selection
     |               |              |
     |<-----(3)-----<|              | NAI transmitted to RP
     |               |              |
     |<=====(4)====================>| IdP Discovery
     |               |              |
     |>=====(5)====================>| Access-Request from RP to IdP
     |               |              |
     |               |< - - (6) - -<| EAP method to client
     |               |              |
     |               |< - - (7) - ->| EAP exchange to authenticate
     |               |              | client
     |               |              |
     |               |           (8 & 9) Local policy check
     |               |              |
     |<====(10)====================<| Results to RP
     |               |              |
   (11)              |              | RP processes results
     |               |              |
     |>----(12)----->|              | Results to client

     Legend:

       -----: Between client and RP
       =====: Between RP and IdP
       - - -: Between client and IdP (via RP)]]>
   </artwork>  </figure>

      </section>

      <section title="Design Goals">
        <t>Our key design goals are as follows:</t>
        <t>
          <list style="symbols">
            <t>
              Each party in a transaction will be authenticated, although
              perhaps not identified, and the client will be authorized for
              access to a specific resource.
            </t>

            <t>
              The means of authentication is decoupled from the application
              protocol so as to allow for multiple authentication methods with
              minimal changes to the application.
            </t>

            <t>
              The architecture requires no sharing of long&nbhy;term private
              keys between clients and RPs.
            </t>
            <t>
              The system will scale to large numbers of IdPs, RPs, and users.
            </t>
            <t>
              The system will be designed primarily for
              non&nbhy;web&nbhy;based authentication.
            </t>
            <t>
              The system will build upon existing standards, components, and
              operational practices.
            </t>
          </list>
        </t>
        
        <t>
          Designing new three-party authentication and authorization
          protocols is difficult and fraught with the risk of
          cryptographic flaws. Achieving widespread deployment is even
          more difficult. A lot of attention on federated access has
          been devoted to the web. This document instead focuses on a
          non&nbhy;web&nbhy;based environment and focuses on those
          protocols where HTTP is not used. Despite the growing trend
          to layer every protocol on top of HTTP, there are still a
          number of protocols available that do not use HTTP&nbhy;based
          transports. Many of these protocols are lacking a native
          authentication and authorization framework of the style shown
          in <xref target="framework"/>.
        </t>
      </section>

    </section>
    <section title="Architecture">
      <t>
        We have already introduced the federated access architecture,
        with the illustration of the different actors that need to interact.
        This section expands on the specifics of providing support for
        non&nbhy;web&nbhy;based applications and provides motivations for
        design decisions. The main theme of the work described in this
        document is focused on reusing existing building blocks that
        have been deployed already and to rearrange them in a novel way.
      </t>

      <t>
        Although this architecture assumes updates to the RP, the
        client, and the IdP, those changes are kept at a minimum.
        A mechanism that can demonstrate deployment benefits (based on ease of
        updates to existing software, low implementation effort, etc.) is
        preferred, and there may be a need to specify multiple mechanisms to
        support the range of different deployment scenarios.
      </t>

      <t>
        There are a number of ways to encapsulate EAP into an application
        protocol. For ease of integration with a wide range of
        non&nbhy;web&nbhy;based application protocols, GSS&nbhy;API was
        chosen. The technical specification of GSS&nbhy;EAP can be
        found in <xref target="RFC7055"/>.

      </t>
      
      <t>
        The architecture consists of several building blocks, as shown
        graphically in <xref target="abfab-arch"/>. 
        In the following sections, we discuss the data flow between each of
        the entities, the protocols used for that data flow, and some of the
        trade&nbhy;offs made in choosing the protocols.
      </t>

      <t><figure title="ABFAB Protocol Instantiation" anchor="abfab-arch">
        <artwork><![CDATA[
                                 +--------------+
                                 |   Identity   |
                                 |   Provider   |
                                 |    (IdP)     |
                                 +-^----------^-+
                                   * EAP      o RADIUS
                                   *          o 
                                 --v----------v--
                              ///                \\\
                            //                      \\     
                           |        Federation        | 
                           |        Substrate         | 
                            \\                      //  
                              \\\                ///
                                 --^----------^--
                                   * EAP      o RADIUS
                                   *          o 
+-------------+                  +-v----------v--+
|             |                  |               |
| Client      |  EAP/EAP Method  | Relying Party |
| Application |<****************>|     (RP)      |
|             |  GSS-API         |               |
|             |<---------------->|               |
|             |  Application     |               |
|             |  Protocol        |               |
|             |<================>|               |
+-------------+                  +---------------+

Legend:

  <****>: Client-to-IdP Exchange
  <---->: Client-to-RP Exchange
  <oooo>: RP-to-IdP Exchange 
  <====>: Protocol through which GSS-API/GS2 exchanges are tunneled
 ]]></artwork>
      </figure>
      </t>
      
      <section title="Relying Party to Identity Provider">
        <t>
          Communication between the RP and the IdP
          is done by the Federation Substrate. This communication channel
          is responsible for:
          <list style="symbols">
            <t>Establishing the trust relationship between the RP and the
            IdP.</t>
            <t>Determining the rules governing the relationship.</t>
            <t>Conveying authentication packets from the client to the IdP and
            back.</t>
            <t>Providing the means of establishing a trust relationship
            between the RP and the client.</t>
            <t>Providing a means for the RP to obtain attributes about the
            client from the IdP.</t>
          </list>
        </t>

        <t>
          
          The ABFAB working group has chosen the AAA framework for the
          messages transported between the RP and IdP. The AAA framework
          supports the requirements stated above, as follows:

          <list style="symbols">
            <t>The AAA backbone supplies the trust relationship between the RP
            and the IdP.</t>
            <t>The agreements governing a specific AAA backbone contain the
            rules governing the relationships within the AAA federation.</t>
            <t>A method exists for carrying EAP packets within RADIUS <xref
            target="RFC3579"/> and Diameter <xref target="RFC4072"/>.</t>
            <t>The use of EAP channel binding <xref target="RFC6677"/> along
            with the core ABFAB protocol provide the pieces necessary to
            establish the identities of the RP and the client, while EAP
            provides the cryptographic methods for the RP and the client to
            validate that they are talking to each other.</t>
            <t>A method exists for carrying SAML packets within RADIUS <xref
            target="RFC7833"/>; this method allows the RP to query
            attributes about the client from the&nbsp;IdP.</t>
          </list>
        </t>

        <t>
          Protocols that support the same framework but do different routing
          are expected to be defined and used in the future. One such
          effort, called the Trust Router, is to set up a framework that
          creates a trusted point-to-point channel on the fly
          (https://www.ietf.org/proceedings/86/slides/slides-86-rtgarea-0.pdf).
        </t>

        <section title="AAA, RADIUS, and Diameter">

          <t>
            The usage of the AAA framework with RADIUS <xref
            target="RFC2865"/> and Diameter <xref target="RFC6733"/> for
            network access authentication has been successful from a
            deployment point of view. To map the terminology used
            in <xref target="framework"/> to the AAA framework, the
            IdP corresponds to the AAA server; the RP corresponds to the
            AAA client; and the technical building blocks of a
            federation are AAA proxies, relays, and redirect agents
            (particularly if they are operated by third parties, such as
            AAA brokers and clearinghouses).  In the case of network
            access authentication, the front&nbsp;end, i.e., the
            communication path between the end host and the AAA client,
            is offered by link&nbhy;layer protocols that forward
            authentication protocol exchanges back and forth. An example
            of a large-scale RADIUS-based federation is
            eduroam (https://www.eduroam.org).
          </t>

          <t>
            By using the AAA framework, ABFAB can be built on the federation
            agreements that already exist; the agreements can then merely be
            expanded to cover the ABFAB architecture. The AAA framework has
            already addressed some of the problems outlined above.
            For example,
            <list style="symbols">
              <t>It already has a method for routing requests based on a
              domain.</t>
              <t>It already has an extensible architecture allowing for new
              attributes to be defined and transported.</t>
              <t>Pre-existing relationships can be reused.</t>
            </list>
          </t>

          <t>
            The astute reader will notice that RADIUS and Diameter have
            substantially similar characteristics. Why not pick one?
            RADIUS and Diameter are deployed in different environments.
            RADIUS can often be found in enterprise and university networks;
            RADIUS is also used by operators of fixed networks.
            Diameter, on the other hand, is deployed by operators of
            mobile networks. Another key difference is that today RADIUS
            is largely transported over UDP. The decision regarding
            which protocol will be appropriate to deploy is left to
            implementers. The protocol defines all the necessary new
            AAA attributes as RADIUS attributes. A future document could
            define the same AAA attributes for a Diameter environment.
            We also note that there exist proxies that convert from RADIUS
            to Diameter and back. This makes it possible for both to be
            deployed in a single Federation Substrate.
          </t>
          
          <t>
            Through the integrity-protection mechanisms in the AAA framework,
            the IdP can establish technical trust that messages
            are being sent by the appropriate RP. Any given
            interaction will be associated with one federation at the
            policy level. The legal or business relationship defines what
            statements the IdP is trusted to make and how
            these statements are interpreted by the RP.
            The AAA framework also permits the RP or elements
            between the RP and IdP to make statements
            about the RP.
          </t>

          <t>
            The AAA framework provides transport for attributes.
            Statements made about the client by the IdP,
            statements made about the RP, and other information
            are transported as attributes.
          </t>

          <t>
            One demand that the AAA substrate makes of the upper layers is
            that they must properly identify the endpoints of the
            communication. It must be possible for the AAA client at the
            RP to determine where to send each RADIUS or Diameter message.
            Without this requirement, it would be  the RP's responsibility to
            determine the identity of the client on its own, without the
            assistance of an IdP. This architecture makes use of the
            Network Access Identifier (NAI), where the IdP is indicated
            by the realm component <xref target="RFC7542"/>. The NAI is
            represented and consumed by the GSS&nbhy;API layer as
            GSS_C_NT_USER_NAME, as specified in <xref target="RFC2743"/>.
            The GSS&nbhy;API EAP mechanism includes the NAI in the EAP
            Response/Identity message.
          </t>

          <t>
            At the time of this writing, no profiles for the use of
            Diameter have been created.
          </t>
          
        </section>

        <section title="Discovery and Rules Determination" anchor="discovery">

          <t>
            While we are using the AAA protocols to communicate with the IdP,
            the RP may have multiple Federation Substrates to select from.
            The RP has a number of criteria that it will use in selecting
            which of the different federations to use. The federation selected
            must
            <list style="symbols">
              <t>be able to communicate with the IdP.</t>
              <t>match the business rules and technical policies required for
              the RP security requirements.</t>
            </list>
          </t>

          <t>
            The RP needs to discover which federation will be used to contact
            the IdP. The first selection criterion used during discovery
            is going to be the name of the IdP to be contacted. The second
            selection criterion used during discovery is going to be
            the set of business rules and technical policies governing the
            relationship; this is called "rules determination". The RP
            also needs to establish technical trust in the communications
            with the IdP.
          </t>
          
          <t>
            Rules determination covers a broad range of decisions about the
            exchange. One of these is whether the given RP is permitted
            to talk to the IdP using a given federation at all, so rules
            determination encompasses the basic authorization decision.
            Other factors are included, such as what policies govern release
            of information about the client to the RP and what policies govern
            the RP's use of this information.
            While rules determination is ultimately a business function, it
            has a significant impact on the technical exchanges.
            The protocols need to communicate the result of authorization.
            When multiple sets of rules are possible, the protocol must
            disambiguate which set of rules are in play.
            Some rules have technical enforcement mechanisms; for example,
            in some federations, intermediaries validate information that
            is being communicated within the federation.
          </t>

          <t>
            At the time of this writing, no protocol mechanism has been
            specified to allow a AAA client to determine whether a
            AAA proxy will indeed be able to route AAA requests to a
            specific IdP. The AAA routing is impacted by business rules
            and technical policies that may be quite complex; at the
            present time, the route selection is based on manual
            configuration.
          </t>

        </section>

        <section title="Routing and Technical Trust">
          <t>
            Several approaches to having messages routed through the
            Federation Substrate are possible.
            These routing methods can most easily be classified based on the
            mechanism for technical trust that is used.
            The choice of technical trust mechanism constrains how rules
            determination is implemented.
            Regardless of what deployment strategy is chosen, it is important
            that the technical trust mechanism be able to validate the
            identities of both parties to the exchange.
            The trust mechanism must ensure that the entity acting as the
            IdP for a given NAI is permitted to be the IdP for that realm
            and that any service name claimed by the RP is permitted to
            be claimed by that entity. Here are the categories of
            technical trust determination:
            <list style="hanging">
              <t hangText="AAA Proxy:"><vspace/>
              The simplest model is that an RP is a AAA client and can send
              the request directly to a AAA proxy. The hop-by-hop
              integrity protection of the AAA fabric provides technical trust.
              An RP can submit a request directly to the correct federation.
              Alternatively, a federation disambiguation fabric can be used.
              Such a fabric takes information about what federations the RP is
              part of and what federations the IdP is part of, and it routes
              a message to the appropriate federation.
              The routing of messages across the fabric, plus attributes added
              to requests and responses, together provide rules determination.
              For example, when a disambiguation fabric routes a message to a
              given federation, that federation's rules are chosen.
              Name validation is enforced as messages travel across the fabric.
              The entities near the RP confirm its identity and validate names
              it claims. The fabric routes the message towards the
              appropriate IdP, validating the name of the IdP in the process.
              The routing can be statically configured.
              Alternatively, a routing protocol could be developed to exchange
              reachability information about a given IdP and to apply policy
              across the AAA fabric.
              Such a routing protocol could flood naming constraints to the
              appropriate points in the fabric.
              </t>
              <t hangText="Trust Broker:"><vspace/>
              Instead of routing messages through AAA proxies, some trust
              broker could establish keys between entities near the RP and
              entities near the IdP. The advantage of this approach is
              efficiency of message handling. Fewer entities are needed
              to be involved for each message. Security may be improved
              by sending individual messages over fewer hops. Rules
              determination involves decisions made by trust brokers
              about what keys to grant. Also, associated with each
              credential is context about rules and about other aspects
              of technical trust, including names that may be claimed.
              A routing protocol similar to the one for AAA proxies is
              likely to be useful to trust brokers in flooding rules
              and naming constraints.
              </t>
              <t hangText="Global Credential:"><vspace/>
              A global credential such as a public key and certificate in a
              public key infrastructure can be used to establish technical
              trust. A directory or distributed database such as the
              Domain Name System is used by the RP to discover the
              endpoint to contact for a given NAI. Either the database
              or certificates can provide a place to store information
              about rules determination and naming constraints. Provided
              that no intermediates are required (or appear to be required)
              and that the RP and IdP are sufficient to enforce and
              determine rules, rules determination is reasonably simple.
              However, applying certain rules is likely to be quite complex.
              For example, if multiple sets of rules are possible between an
              IdP and RP, confirming that the correct set is used may be
              difficult. This is particularly true if intermediates are
              involved in making the decision. Also, to the extent that
              directory information needs to be trusted, rules determination
              may be more complex.
              </t>
            </list>
          </t>
          <t>
            Real-world deployments are likely to be mixtures of these basic
            approaches. For example, it will be quite common for an RP to
            route traffic to a AAA proxy within an organization. That
            proxy could then use any of the above three methods to get
            closer to the IdP. It is also likely that, rather than being
            directly reachable, the IdP may have a proxy on the edge of its
            organization. Federations will likely provide a traditional
            AAA proxy interface even if they also provide another
            mechanism for increased efficiency or security.
          </t>
        </section>

        <section title="AAA Security">
          <t>
            For the AAA framework, there are two different places where
            security needs to be examined. The first is the security
            that is in place for the links in the AAA backbone being used.
            The second are the nodes that form the AAA backbone.
          </t>

          <t>
            The default link security for RADIUS is showing its age, as it
            uses MD5 and a shared secret to both obfuscate passwords and
            provide integrity on the RADIUS messages.
            While some EAP methods include the ability to protect the client
            authentication credentials, the MSK returned from the IdP to the
            RP is protected only by RADIUS security.
            In many environments, this is considered to be insufficient,
            especially as not all attributes are obfuscated and can thus leak
            information to a passive eavesdropper. The use of RADIUS
            with Transport Layer Security (TLS) <xref target="RFC6614"/>
            and/or Datagram Transport Layer Security (DTLS)
            <xref target="RFC7360"/> addresses these attacks.
            The same level of security is included in the base Diameter
            specifications.
          </t>
        </section>

        <section title="SAML Assertions">
          <t>
            For the traditional use of AAA frameworks, i.e., granting access
            to a network, an affirmative response from the IdP is sufficient.
            In the ABFAB world, the RP may need to get significantly more
            additional information about the client before granting access.
            ABFAB therefore has a requirement that it can transport an
            arbitrary set of attributes about the client from the IdP to
            the RP.
          </t>
          
          <t>
            The Security Assertion Markup Language (SAML) <xref
            target="OASIS.saml-core-2.0-os"/> was designed in order to carry
            an extensible set of attributes about a subject.
            Since SAML is extensible in the attribute space, ABFAB has no
            immediate needs to update the core SAML specifications for our
            work. It will be necessary to update IdPs that need to return
            SAML Assertions to RPs and for both the IdP and the RP to
            implement a new SAML profile designed to carry SAML Assertions
            in AAA. The new profile can be found in <xref target="RFC7833"/>.
            As SAML statements will frequently be large, RADIUS servers and
            clients that deal with SAML statements will need to implement
            <xref target="RFC7499"/>.
          </t>

          <t>
            There are several issues that need to be highlighted:  

            <list style="symbols">
              <t>The security of SAML Assertions.</t>
              <t>Namespaces and mapping of SAML attributes.</t>
              <t>Subject naming of entities.</t>
              <t>Making multiple queries about the subject(s).</t>
              <t>Level of assurance for authentication.</t>
            </list>
          </t>
          
          <t>
            SAML Assertions have an optional signature that can be used to
            protect and provide the origination of the assertion.
            These signatures are normally based on asymmetric key operations
            and require that the verifier be able to check not only the
            cryptographic operation but also the binding of the originator's
            name and the public key. In a federated environment, it will
            not always be possible for the RP to validate the binding;
            for this reason, the technical trust established in the
            federation is used as an alternate method of validating the
            origination and integrity of the SAML Assertion.
          </t>
          
          <t>
            Attributes in a SAML Assertion are identified by a name string.
            The name string is either assigned by the SAML issuer context or
            scoped by a namespace (for example, a URI or object identifier
            (OID)). This means that the same attribute can have
            different name strings used to identify it. In many cases,
            but not all, the federation agreements will determine what
            attributes and names can be used in a SAML statement.
            This means that the RP needs to map from the SAML issuer or
            federation name, type, and semantic to the name, type, and
            semantics that the policies of the RP are written in.
            In other cases, the Federation Substrate, in the form of proxies,
            will modify the SAML Assertions in transit to do the necessary
            name, type, and value mappings as the assertion crosses boundaries
            in the federation. If the proxies are modifying the
            SAML Assertion, then they will remove any signatures on
            the SAML Assertion, as changing the content of the
            SAML Assertion would invalidate the signature.
            In this case, the technical trust is the required mechanism for
            validating the integrity of the assertion.
            (The proxy could re&nbhy;sign the SAML Assertion, but the same
            issues of establishing trust in the proxy would still exist.)
            Finally, the attributes may still be in the namespace of the
            originating IdP. When this occurs, the RP will need to get
            the required mapping operations from the federation agreements
            and do the appropriate mappings itself.
          </t>

          <t>
            <xref target="RFC7833"/> has defined a new SAML name format that
            corresponds to the NAI name form defined by
            <xref target="RFC7542"/>. This allows for easy name matching
            in many cases, as the name form in the SAML statement and
            the name form used in RADIUS or Diameter will be the same.
            In addition to the NAI name form, <xref target="RFC7833"/>
            also defines a pair of implicit name forms corresponding
            to the client and the client's machine. 
            These implicit name forms are based on the Identity&nbhy;Type
            enumeration defined in the Tunnel Extensible Authentication
            Protocol (TEAP) specification <xref target="RFC7170"/>.
            If the name form returned in a SAML statement is not based on the
            NAI, then it is a requirement on the EAP server that it validate
            that the subject of the SAML Assertion, if any, is equivalent to
            the subject identified by the NAI used in the RADIUS or Diameter
            session.
          </t>

          <t>
            RADIUS has the ability to deal with multiple SAML queries for
            those EAP servers that follow <xref target="RFC5080"/>.
            In this case, a State attribute will always be returned with the
            Access&nbhy;Accept.  The EAP client can then send a new
            Access&nbhy;Request with the State attribute and the new
            SAML request. Multiple SAML queries can then be done by making a
            new Access&nbhy;Request, using the State attribute returned in
            the last Access&nbhy;Accept to link together the different
            RADIUS sessions.
          </t>

          <t>
            Some RPs need to ensure that specific criteria are met during the
            authentication process. This need is met by using levels of
            assurance. A level of assurance is communicated to the RP from
            the EAP server by using a SAML Authentication Request, using
            the Authentication Profile described in <xref target="RFC7833"/>.
            When crossing boundaries between different federations,
            (1)&nbsp;the policy specified will need to be shared between
            the two federations, (2)&nbsp;the policy will need to be
            mapped by the proxy server on the boundary, or (3)&nbsp;the
            proxy server on the boundary will need to supply information
            to the EAP server so that the EAP server can do the required
            mapping. If this mapping is not done, then the EAP server
            will not be able to enforce the desired level of assurance,
            as it will not understand the policy requirements.
          </t>
        </section>

      </section>

      
      <section title="Client to Identity Provider">
        <t>
          Looking at the communications between the client and the IdP, the
          following items need to be dealt with:
          <list style="symbols">
            <t>The client and the IdP need to mutually authenticate each
            other.</t>
            <t>The client and the IdP need to mutually agree on the identity
            of the RP.</t>
          </list>
        </t>

        <t>
          ABFAB selected EAP for the purposes of mutual authentication and
          assisted in creating some new EAP channel&nbhy;binding documents for
          dealing with determining the identity of the RP. A framework
          for the channel&nbhy;binding mechanism has been defined
          in <xref target="RFC6677"/> that allows the IdP to check the
          identity of the RP provided by the AAA framework against the
          identity provided by the client.
        </t>

        <section title="Extensible Authentication Protocol (EAP)" anchor="Client_Eap">
          <t>
            Traditional web federation does not describe how a client
            interacts with an IdP for authentication.
            As a result, this communication is not standardized.
            There are several disadvantages to this approach.
            Since the communication is not standardized, it is difficult for
            machines to recognize which entity is going to do the
            authentication, and thus which credentials to use and where in the
            authentication form the credentials are to be entered. It is
            much easier for humans to correctly deal with these problems.
            The use of browsers for authentication restricts the deployment of
            more secure forms of authentication beyond plaintext usernames
            and passwords known by the server. In a number of cases, the
            authentication interface may be presented before the client
            has adequately validated that they are talking to the
            intended server. By giving control of the authentication
            interface to a potential attacker, the security of the system
            may be reduced, and opportunities for phishing may be
            introduced.
          </t>

          <t>
            As a result, it is desirable to choose some standardized approach
            for communication between the client's end&nbsp;host and the
            IdP. There are a number of requirements this
            approach must meet, as noted below.
          </t>

          <t>
            Experience has taught us one key security and scalability
            requirement: it is important that the RP not get
            possession of the long-term secret of the client.
            Aside from a valuable secret being exposed, a synchronization
            problem can develop when the client changes keys with the IdP.
          </t>

          <t>
            Since there is no single authentication mechanism that will be
            used everywhere, another associated requirement is that the
            authentication framework must allow for the flexible
            integration of authentication mechanisms. For instance, some
            IdPs require hardware tokens, while others use passwords.
            A service provider wants to provide support for both
            authentication methods and also for other methods from IdPs
            not yet seen.
          </t>

          <t>
            These requirements can be met by utilizing standardized and
            successfully deployed technology, namely the EAP framework
            <xref target="RFC3748"/>. <xref target="abfab-arch"/>
            illustrates the integration graphically.
          </t>

          <t>
            EAP is an end-to-end framework; it provides for two-way
            communication between a peer (i.e., client or Individual) through
            the EAP authenticator (i.e., RP) to the back&nbsp;end
            (i.e., IdP). This is precisely -- and
            conveniently -- the communication path that is needed for
            federated identity. Although EAP support is already integrated
            in AAA systems (see <xref target="RFC3579"/> and
            <xref target="RFC4072"/>), several challenges remain:
            <list style="symbols">
              <t>The first is how to carry EAP payloads from the end host to
              the&nbsp;RP.</t>
              <t>Another is to verify statements the RP has made to
              the client, confirm that these statements are consistent with
              statements made to the IdP, and confirm that all
              of the above are consistent with the federation and any
              federation-specific policy or configuration.</t>
              <t>Another challenge is choosing which IdP to use
              for which service.</t>
            </list>
          </t>

          <t>
            The EAP method used for ABFAB needs to meet the following
            requirements:
            <list style="symbols">
              <t>It needs to provide mutual authentication of the client and
              IdP.</t>
              <t>It needs to support channel binding.</t>
            </list>
            As of this writing, the only EAP method that meets these criteria
            is TEAP <xref target="RFC7170"/>, either alone (if client
            certificates are used) or with an inner EAP method that does
            mutual authentication.
          </t>
        </section>

        <section title="EAP Channel Binding" anchor="client_channel_binding">
          <t>
            EAP channel binding is easily confused with a facility in
            GSS&nbhy;API that is also called "channel binding".
            GSS&nbhy;API channel binding provides protection against
            man-in-the-middle attacks when GSS&nbhy;API is used for
            authentication inside of some tunnel; it is similar to a
            facility called "cryptographic binding" in EAP.
            See <xref target="RFC5056"/> for a discussion of the differences
            between these two facilities.
          </t>

          <t>
            The client knows, in theory, the name of the RP that it attempted
            to connect to; however, in the event that an attacker has
            intercepted the protocol, the client and the IdP need to be able
            to detect this situation.  A general overview of the problem,
            along with a recommended way to deal with the channel&nbhy;binding
            issues, can be found in <xref target="RFC6677"/>.
          </t>

          <t>
            Since the time that <xref target="RFC6677"/> was published, a
            number of possible attacks were found. Methods to address
            these attacks have been outlined in <xref target="RFC7029"/>.
          </t>

        </section>

      </section>

      <section title="Client to Relying Party">
        <t>
          The final set of interactions between the parties to consider are
          those between the client and the RP. In some ways, this is
          the most complex set, since at least part of it is outside
          the scope of the ABFAB work.  The interactions between these
          parties include:
          <list style="symbols">
            <t>Running the protocol that implements the service that is
            provided by the RP and desired by the client.</t>
            <t>Authenticating the client to the RP and the RP to the
            client.</t>
            <t>Providing the necessary security services to the service
            protocol that it needs, beyond authentication.</t>
            <t>Dealing with client re-authentication where desired.</t>
          </list>
        </t>

        <section title="GSS-API">
          <t>
            One of the remaining layers is responsible for integration
            of federated authentication with the application.
            Applications have adopted a number of approaches for
            providing security, so multiple strategies for integration
            of federated authentication with applications may be needed.
            To this end, we start with a strategy that provides
            integration with a large number of application protocols.
          </t>

          <t>
            Many applications, such as Secure Shell (SSH)
            <xref target="RFC4462"/>, NFS <xref target="RFC7530"/>,
            DNS <xref target="RFC3645"/>, and several non&nbhy;IETF
            applications, support GSS&nbhy;API <xref target="RFC2743"/>.
            Many applications, such as IMAP, SMTP,
            the Extensible Messaging and Presence Protocol (XMPP), 
            and the Lightweight Directory Access Protocol (LDAP),
            support the Simple Authentication and Security Layer
            (SASL) <xref target="RFC4422"/> framework.
            These two approaches work together nicely: by creating a
            GSS&nbhy;API mechanism, SASL integration is also addressed.
            In effect, using a GSS&nbhy;API mechanism with SASL simply
            requires placing some headers before the mechanism's
            messages and constraining certain GSS&nbhy;API options.
          </t>

          <t>
            GSS-API is specified in terms of an abstract set of operations
            that can be mapped into a programming language to form an API.
            When people are first introduced to GSS&nbhy;API, they focus
            on it as an API. However, from the perspective of
            authentication for non&nbhy;web applications, GSS&nbhy;API
            should be thought of as a protocol as well as an API.
            When looked at as a protocol, it consists of abstract operations
            such as the initial context exchange, which includes two
            sub&nbhy;operations (GSS_Init_sec_context and
            GSS_Accept_sec_context) <xref target="RFC2743"/>. An
            application defines which abstract operations it is going to
            use and where messages produced by these operations fit
            into the application architecture. A GSS&nbhy;API mechanism
            will define what actual protocol messages result from that
            abstract message for a given abstract operation. So, since
            this work is focusing on a particular GSS&nbhy;API mechanism,
            we generally focus on protocol elements rather than the
            API view of GSS&nbhy;API.
          </t>
          <t>
            The API view of GSS-API does have significant value as well;
            since the abstract operations are well defined, the information
            that a mechanism gets from the application is well defined.
            Also, the set of assumptions the application is permitted to make
            is generally well defined. As a result, an application
            protocol that supports GSS&nbhy;API or SASL is very likely
            to be usable with a new approach to authentication,
            including the authentication mechanism defined in this document,
            with no required modifications. In some cases, support for a
            new authentication mechanism has been added using plugin
            interfaces to applications without the application being
            modified at all. Even when modifications are required,
            they can often be limited to supporting a new naming and
            authorization model. For example, this work focuses on
            privacy; an application that assumes that it will always
            obtain an identifier for the client will need to be modified
            to support anonymity, unlinkability, or pseudonymity.
          </t>
          <t>
            So, we use GSS-API and SASL because a number of the application
            protocols we wish to federate support these strategies for
            security integration. What does this mean from a protocol
            standpoint, and how does this relate to other layers? This
            means that we need to design a concrete GSS&nbhy;API mechanism.
            We have chosen to use a GSS&nbhy;API mechanism that encapsulates
            EAP authentication. So, GSS&nbhy;API (and SASL) encapsulates
            EAP between the end&nbsp;host and the service. The AAA
            framework encapsulates EAP between the RP and the
            IdP. The GSS&nbhy;API mechanism includes rules
            about how initiators and services are named as well as
            per&nbhy;message security and other facilities required
            by the applications we wish to support.
          </t>
        </section>

        <section title="Protocol Transport">
          <t>The transport of data between the client and the RP is
          not provided by GSS&nbhy;API.  GSS&nbhy;API creates and consumes
          messages, but it does not provide the transport itself; instead,
          the protocol using GSS&nbhy;API needs to provide the transport.
          In many cases, HTTP or HTTPS is used for this transport, but
          other transports are perfectly acceptable.  The core
          GSS&nbhy;API document <xref target="RFC2743"/> provides some
          details on what requirements exist.</t>
          <t>
            In addition, we highlight the following:
            <list style="symbols">
              <t>
                The transport does not need to provide either
                confidentiality or integrity. After GSS&nbhy;EAP has
                finished negotiation, GSS&nbhy;API can be used to
                provide both services. If the negotiation process
                itself needs protection from eavesdroppers, then the
                transport would need to provide the necessary services.
              </t>
              <t>The transport needs to provide reliable transport of the
              messages.</t>
              <t>The transport needs to ensure that tokens are delivered in
              order during the negotiation process.</t>
              <t>GSS-API messages need to be delivered atomically.  If the
              transport breaks up a message, it must also reassemble the
              message before delivery.</t>
            </list>
          </t>
        </section>

        <section title="Re-authentication">
          <t>
            There are circumstances where the RP will want to have the
            client re&nbhy;authenticate itself. These include very long
            sessions, where the original authentication is time limited
            or cases where in order to complete an operation a
            different authentication is required. GSS&nbhy;EAP does not
            have any mechanism for the server to initiate a
            re&nbhy;authentication, as all authentication operations
            start from the client. If a protocol using
            GSS&nbhy;EAP needs to support re&nbhy;authentication that
            is initiated by the server, then a request from the
            server to the client for the re&nbhy;authentication to
            start needs to be placed in the protocol.
          </t>
          <t>
            Clients can reuse the existing secure connection established
            by GSS&nbhy;API, and run the new authentication in that
            connection, by calling GSS_Init_sec_context. At this point,
            a full re&nbhy;authentication will be done.
          </t>
        </section>
      </section>
             
    </section>

    <section title="Application Security Services">
      <t>
        One of the key goals is to integrate federated authentication with
        existing application protocols and, where possible, existing
        implementations of these protocols. Another goal is to perform
        this integration while meeting the best security practices of
        the technologies used to perform the integration. This section
        describes security services and properties required by
        the EAP GSS&nbhy;API mechanism in order to meet these goals.
        This information could be viewed as specific to that mechanism.
        However, other future application integration strategies are very
        likely to need similar services. So, it is likely that these
        services will be expanded across application integration
        strategies if new application integration strategies are adopted.
      </t>
      
      <section title="Authentication">
        <t>
          GSS-API provides an optional security service called "mutual
          authentication". This service means that in addition to the
          initiator providing (potentially anonymous or pseudonymous)
          identity to the acceptor, the acceptor confirms its identity
          to the initiator. In the context of ABFAB in particular, the
          naming of this service is confusing. We still say that
          mutual authentication is provided when the identity of an
          acceptor is strongly authenticated to an anonymous initiator.
        </t>

        <t>
          Unfortunately, <xref target="RFC2743"/> does not explicitly
          talk about what mutual authentication means. Within this
          document, we therefore define mutual authentication as follows:
          <list style="symbols">
            <t>
              If a target name is configured for the initiator, then the
              initiator trusts that the supplied target name describes the
              acceptor. This implies that (1)&nbsp;appropriate
              cryptographic exchanges took place for the initiator to
              make such a trust decision and (2)&nbsp;after evaluating
              the results of these exchanges, the initiator's policy
              trusts that the target name is accurate.
            </t>
            <t>
              If no target name is configured for the initiator, then the
              initiator trusts that the acceptor name, supplied by the
              acceptor, correctly names the entity it is communicating with.
            </t>
            <t>
              Both the initiator and acceptor have the same key material for
              per&nbhy;message keys, and both parties have confirmed that
              they actually have the key material. In EAP terms, there is
              a protected indication of success.
            </t>
          </list>
        </t>
        
        <t>
          Mutual authentication is an important defense against certain
          aspects of phishing. Intuitively, clients would like to assume
          that if some party asks for their credentials as part of
          authentication, successfully gaining access to the resource
          means that they are talking to the expected party. Without
          mutual authentication, the server could "grant access"
          regardless of what credentials are supplied. Mutual
          authentication better matches this user intuition.
        </t>
        
        <t>
          It is important, therefore, that the GSS&nbhy;EAP mechanism
          implement mutual authentication. That is, an initiator needs
          to be able to request mutual authentication. When
          mutual authentication is requested, only EAP methods capable of
          providing the necessary service can be used, and appropriate
          steps need to be taken to provide mutual authentication.
          While a broader set of EAP methods could be supported by not
          requiring mutual authentication, it was decided that the client
          needs to always have the ability to request it. In some cases,
          the IdP and the RP will not support mutual authentication;
          however, the client will always be able to detect this and
          make an appropriate security decision.
        </t>
        
        <t>
          The AAA infrastructure may hide the initiator's identity from
          the GSS&nbhy;API acceptor, providing anonymity between the
          initiator and the acceptor. At this time, whether the identity
          is disclosed is determined by EAP server policy rather than
          by an indication from the initiator. Also, initiators are
          unlikely to be able to determine whether anonymous
          communication will be provided. For this reason, initiators
          are unlikely to set the anonymous return flag from
          GSS_Init_sec_context (Section 2.2.1 of <xref target="RFC2743"/>).
        </t>
      </section>
                      
      <section title="GSS-API Channel Binding">
        <t>
          <xref target="RFC5056"/> defines a concept of channel binding
          that is used to prevent man-in-the-middle attacks. This type
          of channel binding works by taking a cryptographic value from
          the transport security layer and checks to see that both sides
          of the GSS&nbhy;API conversation know this value. Transport Layer
          Security (TLS) <xref target="RFC5246"/> is the most common
          transport security layer used for this purpose.
        </t>

        <t>
          It needs to be stressed that channel binding as described in
          <xref target="RFC5056"/> (also called "GSS&nbhy;API channel
          binding" when GSS&nbhy;API is involved) is not the same thing
          as EAP channel binding. GSS&nbhy;API channel binding is used
          for detecting man-in-the-middle attacks. EAP channel binding
          is used for mutual authentication and acceptor naming checks.
          See <xref target="RFC7055"/> for details. A more detailed
          description of the differences between the facilities can be
          found in <xref target="RFC5056"/>.
        </t>

        <t>
          The use of TLS can provide both encryption and integrity on the
          channel. It is common to provide SASL and GSS&nbhy;API with
          these other security services.
        </t>

        <t>
          One of the benefits that the use of TLS provides is that a
          client has the ability to validate the name of the server.
          However, this validation is predicated on a couple of things.
          The TLS session needs to be using certificates and not be an
          anonymous session. The client and the TLS server need to share
          a common trust point for the certificate used in validating
          the server. TLS provides its own server authentication.
          However, there are a variety of situations where, for policy or
          usability reasons, this authentication is not checked. When
          the TLS authentication is checked, if the trust infrastructure
          behind the TLS authentication is different from the trust
          infrastructure behind the GSS&nbhy;API mutual authentication,
          then confirming the endpoints using both trust infrastructures
          is likely to enhance security. If the endpoints of the
          GSS&nbhy;API authentication are different than the endpoints
          of the lower layer, this is a strong indication of a problem,
          such as a man-in-the-middle attack. Channel binding provides
          a facility to determine whether these endpoints are the same.
        </t>
        
        <t>
          The GSS-EAP mechanism needs to support channel binding. When an
          application provides channel&nbhy;binding data, the mechanism
          needs to confirm that this is the same on both sides,
          consistent with the GSS&nbhy;API specification.
        </t>
        
      </section>


      <section title="Host-Based Service Names">
        <t>
          IETF security mechanisms typically take a host name and perhaps a
          service, entered by a user, and make some trust decision about
          whether the remote party in the interaction is the intended party.
          This decision can be made via the use of certificates,
          preconfigured key information, or a previous leap of trust.
          GSS&nbhy;API has defined a relatively flexible naming convention;
          however, most of the IETF applications that use GSS&nbhy;API
          (including SSH, NFS, IMAP, LDAP, and XMPP) have chosen to use a
          more restricted naming convention based on the host name. The
          GSS&nbhy;EAP mechanism needs to support host&nbhy;based
          service names in order to work with existing IETF protocols.
        </t>
        
        <t>
          The use of host-based service names leads to a challenging trust
          delegation problem. Who is allowed to decide whether a
          particular host name maps to a specific entity? Possible
          solutions to this problem have been looked at.
          <list style="symbols">
            <t>
              The Public Key Infrastructure (PKI) used by the web has
              chosen to have a number of trust anchors (root
              certificate authorities), each of which can map any
              host name to a public key.
            </t>
            <t>
              A number of GSS-API mechanisms, such as Kerberos <xref
              target="RFC1964"/>, have split the problem into two parts.
              <xref target="RFC1964"/> introduced a new concept called
              a realm; the realm is responsible for host mapping within
              itself. The mechanism then decides what realm is
              responsible for a given name. This is the approach adopted
              by ABFAB.
            </t>
          </list>
        </t>

        <t>
          GSS-EAP defines a host naming convention that takes into account
          the host name, the realm, the service, and the service
          parameters. An example of a GSS&nbhy;API service name
          is "xmpp/foo@example.com". This identifies the XMPP service
          on the host foo in the realm example.com. Any of the
          components, except for the service name, may be omitted
          from a name. When omitted, a local default would be used for
          that component of the name.
        </t>

        <t>
          While there is no requirement that realm names map to Fully
          Qualified Domain Names (FQDNs) within DNS, in practice this is
          normally true. Doing so allows the realm portion of
          service names and the portion of NAIs to be the same. It also
          allows for the use of DNS in locating the host of a service
          while establishing the transport channel between the client and
          the RP.
        </t>

        <t>
          It is the responsibility of the application to determine the server
          that it is going to communicate with; GSS&nbhy;API has the ability
          to help confirm that the server is the desired server but not to
          determine the name of the server to use. It is also the
          responsibility of the application to determine how much of the
          information identifying the service needs to be validated by the
          ABFAB system. The information that needs to be validated is used
          to construct the service name passed into the GSS&nbhy;EAP
          mechanism. What information is to be validated will depend on
          (1)&nbsp;what information was provided by the client and
          (2)&nbsp;what information is considered significant. If the
          client only cares about getting a specific service, then it
          does not need to validate the host and realm that provides
          the service.
        </t>

        <t>
          Applications may retrieve information about providers of services
          from DNS. Service Records (SRVs) <xref target="RFC2782"/> and
          Naming Authority Pointer (NAPTR) <xref target="RFC3401"/> records
          are used to help find a host that provides a service; however,
          the necessity of having DNSSEC on the queries depends on how
          the information is going to be used. If the host name returned
          is not going to be validated by EAP channel binding because
          only the service is being validated, then DNSSEC
          <xref target="RFC4033"/> is not required. However, if
          the host name is going to be validated by EAP channel binding,
          then DNSSEC needs to be used to ensure that the correct
          host name is validated. In general, if the information that is
          returned from the DNS query is to be validated, then it needs
          to be obtained in a secure manner.
        </t>

        <t>
          Another issue that needs to be addressed for host-based service
          names is that they do not work ideally when different instances
          of a service are running on different ports. If the services
          are equivalent, then it does not matter. However, if there are
          substantial differences in the quality of the service, that
          information needs to be part of the validation process. If one
          has just a host name and not a port in the information being
          validated, then this is not going to be a successful strategy.
        </t>
      </section>

      <section title="Additional GSS-API Services">
        <t>
          GSS-API provides per-message security services that can provide
          confidentiality and/or integrity. Some IETF protocols, such as
          NFS and SSH, take advantage of these services. As a result,
          GSS&nbhy;EAP needs to support these services. As with
          mutual authentication, per&nbhy;message security services will
          limit the set of EAP methods that can be used to those that
          generate a Master Session Key (MSK). Any EAP method that
          produces an MSK is able to support per&nbhy;message
          security services as described in <xref target="RFC2743"/>.
        </t>
        
        <t>
          GSS-API provides a pseudorandom function. This function
          generates a pseudorandom sequence using the shared session
          key as the seed for the bytes generated. This provides an
          algorithm that both the initiator and acceptor can run in
          order to arrive at the same key value. The use of this
          feature allows an application to generate keys or other
          shared secrets for use in other places in the protocol.
          In this regard, it is similar in concept to the mechanism
          (formerly known as "TLS Extractors") described in
          <xref target="RFC5705"/>. While no current IETF protocols
          require this feature, non&nbhy;IETF protocols are expected to
          take advantage of it in the near future. Additionally, a number
          of protocols have found the mechanism described in
          <xref target="RFC5705"/> to be useful in this regard, so it
          is highly probable that IETF protocols may also start using
          this feature.
        </t>
      </section>
    </section>


    <section anchor="privacyconsiderations" title="Privacy Considerations">
      <t>
        As an architecture designed to enable federated authentication
        and allow for the secure transmission of identity information
        between entities, ABFAB obviously requires careful consideration
        regarding privacy and the potential for privacy violations.
      </t>

      <t>
        This section examines the privacy-related information presented in
        this document, summarizing the entities that are involved in ABFAB
        communications and what exposure they have to identity information.
        In discussing these privacy considerations in this section, we use
        terminology and ideas from <xref target="RFC6973"/>.
      </t>

      <t>
        Note that the ABFAB architecture uses at its core several existing
        technologies and protocols; detailed privacy discussion regarding
        these topics is not examined. This section instead focuses on
        privacy considerations specifically related to the overall
        architecture and usage of ABFAB.
      </t>

      <t>
        <figure title="Entities and Data Flow" anchor="dataflow">
          <artwork><![CDATA[
   +--------+       +---------------+       +--------------+
   | Client | <---> |      RP       | <---> | AAA Client   |
   +--------+       +---------------+       +--------------+
                                                  ^
                                                  |
                                                  v
                    +---------------+       +----------------+
                    | SAML Server   |       | AAA Proxy      |
                    +---------------+       | (or Proxies)   |
                             ^              +----------------+
                             |                       ^
                             |                       |
                             v                       v
   +------------+       +---------------+       +--------------+
   | EAP Server | <---> |   IdP         | <---> | AAA Server   |
   +------------+       +---------------+       +--------------+
            ]]></artwork>
          </figure>
        </t>

      <section title="Entities and Their Roles">

          <t>
            Categorizing the ABFAB entities shown in <xref
            target="dataflow"/> according to the taxonomy of terms from <xref
            target="RFC6973"/> is somewhat complicated, as the roles of
            each entity will change during the various phases of ABFAB
            communications. The three main phases of relevance are the
            client&nbhy;to&nbhy;RP communication phase, the
            client&nbhy;to&nbhy;IdP (via the Federation Substrate)
            communication phase, and the IdP&nbhy;to&nbhy;RP (via the
            Federation Substrate) communication phase.
          </t>

          <t>
              In the client-to-RP communication phase, we have:
              <list style="hanging">
                <t hangText="Initiator:">Client.</t>
                <t hangText="Observers:">Client, RP.</t>
                <t hangText="Recipient:">RP.</t>
              </list>
          </t>
          <t>
              In the client-to-IdP (via the Federation Substrate)
              communication phase, we have:
              <list style="hanging">
                  <t hangText="Initiator:">Client.</t>
                  <t hangText="Observers:">Client, RP, AAA Client,
                  AAA Proxy (or Proxies), AAA Server, IdP.</t>
                  <t hangText="Recipient:">IdP</t>
              </list>
          </t>
          <t>
              In the IdP-to-RP (via the Federation Substrate) communication
              phase, we have:
              <list style="hanging">
                  <t hangText="Initiator:">RP.</t>
                  <t hangText="Observers:">IdP, AAA Server, AAA Proxy (or Proxies),
                  AAA Client, RP.</t>
                  <t hangText="Recipient:">IdP</t>
              </list>
          </t>
        <t>
          Eavesdroppers and attackers can reside on any or all communication
          links between the entities shown in <xref target="dataflow"/>.
        </t>

        <t>
          The various entities in the system might also collude or be coerced
          into colluding. Some of the significant collusions to look at
          are as follows:
          <list style="symbols">
            <t>
              If two RPs are colluding, they have the information available
              to both nodes. This can be analyzed as if a single RP were
              offering multiple services.
            </t>
            <t>
              If an RP and a AAA proxy are colluding, then the trust of the
              system is broken, as the RP would be able to lie about its own
              identity to the IdP.  There is no known way to deal with this
              situation.
            </t>
            <t>
              If multiple AAA proxies are colluding, they can be treated as a
              single node for analysis.
            </t>
          </list>
        </t>

        <t>
          The Federation Substrate consists of all of the AAA entities.
          In some cases, the AAA proxies may not exist, as the
          AAA client can talk directly to the AAA server.
          Specifications such as the Trust Router Protocol
          (https://www.ietf.org/proceedings/86/slides/slides&nbhy;86&nbhy;rtgarea&nbhy;0.pdf)
          and RADIUS dynamic discovery <xref target="RFC7585"/> can be
          used to shorten the path between the AAA client and the AAA server
          (and thus stop these AAA proxies from being observers); however,
          even in these circumstances, there may be AAA proxies in the path.
        </t>

        <t>
          In <xref target="dataflow"/>, the IdP has been divided into
          multiple logical pieces; in actual implementations, these
          pieces will frequently be tightly coupled. The links between
          these pieces provide the greatest opportunity for attackers
          and eavesdroppers to acquire information; however, as they
          are all under the control of a single entity, they are also
          the easiest to have tightly secured.
        </t>
      </section>
        
        <section title="Privacy Aspects of ABFAB Communication Flows">
            
            <t>
              In the ABFAB architecture, there are a few different types of
              data and identifiers in use. The best way to understand them,
              and their potential privacy impacts, is to look at each
              phase of communication in ABFAB.
            </t>
            
            <section title="Client to RP">
                <t>
                  The flow of data between the client and the RP is divided
                  into two parts. The first part consists of all of the data
                  exchanged as part of the ABFAB authentication process.
                  The second part consists of all of the data exchanged
                  after the authentication process has been finished.
                </t>
                
                <t>
                  During the initial communication phase, the client sends
                  an NAI (see <xref target="RFC7542"/>) to the RP. Many
                  EAP methods (but not all) allow the client to disclose
                  an NAI to the RP in a form that includes only a realm
                  component during this communication phase. This is the
                  minimum amount of identity information necessary for
                  ABFAB to work -- it indicates an IdP that the principal
                  has a relationship with. EAP methods that do not allow
                  this will necessarily also reveal an identifier for the
                  principal in the IdP realm (e.g., a username).
                </t>

                <t>
                  The data shared during the initial communication phase may
                  be protected by a channel protocol such as TLS. This
                  will prevent the leakage of information to passive
                  eavesdroppers; however, an active attacker may still be
                  able to set itself up as a man-in-the-middle. The
                  client may not be able to validate the certificates (if
                  any) provided by the service, deferring the check of the
                  identity of the RP until the completion of the ABFAB
                  authentication protocol (using EAP channel binding
                  rather than certificates).
                </t>

                <t>
                  The data exchanged after the authentication process can have
                  privacy and authentication using the GSS&nbhy;API services.
                  If the overall application protocol allows for the process
                  of re&nbhy;authentication, then the same privacy
                  implications as those discussed in previous paragraphs apply.
                </t>
            </section>
            
            <section title="Client to IdP (via Federation Substrate)">
                <t>
                  This phase includes a secure TLS tunnel set up between
                  the client and the IdP via the RP and Federation Substrate.
                  The process is initiated by the RP using the realm
                  information given to it by the client.
                  Once set up, the tunnel is used to send credentials to
                  the IdP to authenticate.
                </t>
                <t>
                    Various operational information is transported between
                    the RP and the IdP over the AAA infrastructure -- for
                    example, using RADIUS headers. As no end&nbhy;to&nbhy;end
                    security is provided by AAA, all AAA entities on the
                    path between the RP and IdP have the ability to
                    eavesdrop on this information. Some of this information
                    may form identifiers or explicit identity information:
                    <list style="symbols">
                        <t>
                            The RP knows the IP address of the
                            client. It is possible that the RP
                            could choose to expose this IP address by
                            including it in a RADIUS header (e.g., using
                            the Calling&nbhy;Station&nbhy;Id). This is a
                            privacy consideration to take into account
                            for the application protocol.
                        </t>

                        <t>
                            The EAP MSK is transported between the IdP and the
                            RP over the AAA infrastructure -- for example,
                            through RADIUS headers. This is a particularly
                            important privacy consideration, as any AAA proxy
                            that has access to the EAP MSK is able to decrypt
                            and eavesdrop on any traffic encrypted using that
                            EAP MSK (i.e., all communications between the
                            client and RP). This problem can be mitigated
                            if the application protocol sets up a secure
                            tunnel between the client and the RP and
                            performs a cryptographic binding between the
                            tunnel and EAP MSK.
                        </t>
                        <t>
                            Related to the bullet point above, the
                            AAA server has access to the material necessary
                            to derive the session key; thus, the AAA server
                            can observe any traffic encrypted between the
                            client and RP. This "feature" was chosen as a
                            simplification and to make performance faster;
                            if it was decided that this trade&nbhy;off was
                            not desirable for privacy and security reasons,
                            then extensions to ABFAB that make use of
                            techniques such as Diffie&nbhy;Hellman key
                            exchange would mitigate this.
                        </t>

                    </list>
                </t>
                <t>
                    The choice of EAP method used has other potential privacy
                    implications. For example, if the EAP method in use does
                    not support&nbsp;mutual authentication, then there are no
                    guarantees that the IdP is who it claims to be, and thus
                    the full NAI, including a username and a realm, might be
                    sent to any entity masquerading as a particular IdP.
                </t>
                <t>
                    Note that ABFAB has not specified any AAA accounting
                    requirements. Implementations that use the
                    accounting portion of AAA should consider privacy
                    appropriately when designing this aspect.
                </t>
            </section>
            
            <section title="IdP to RP (via Federation Substrate)">
                <t>
                    In this phase, the IdP communicates with the RP, informing
                    it as to the success or failure of authentication of the
                    user and, optionally, the sending of identity information
                    about the principal.
                </t>
                <t>
                    As in the previous flow (client to IdP), various operation
                    information is transported between the IdP and RP over
                    the AAA infrastructure, and the same privacy
                    considerations apply. However, in this flow, explicit
                    identity information about the authenticated principal
                    can be sent from the IdP to the RP. This information
                    can be sent through RADIUS headers, or using
                    SAML <xref target="RFC7833"/>. This can include
                    protocol-specific identifiers, such as SAML NameIDs,
                    as well as arbitrary attribute information about the
                    principal. What information will be released is
                    controlled by policy on the IdP. As before, when
                    sending this information through RADIUS headers, all
                    AAA entities on the path between the RP and IdP have
                    the ability to eavesdrop, unless additional security
                    measures are taken (such as the use of TLS for
                    RADIUS <xref target="RFC6614"/>). However, when
                    sending this information using SAML as specified
                    in <xref target="RFC7833"/>, confidentiality of the
                    information should be guaranteed, as
                    <xref target="RFC7833"/> requires the use of
                    TLS for RADIUS.
                </t>
            </section>
            
        </section>

        <section title="Relationship between User and Entities">
            <t>
                <list style="symbols">
                    <t>
                        Between user and IdP - The IdP is an entity the user
                        will have a direct relationship with, created when the
                        organization that operates the entity provisioned and
                        exchanged the user's credentials. Privacy and
                        data protection guarantees may form a part of this
                        relationship.
                    </t>
                    <t>
                        Between user and RP - The RP is an entity the user may
                        or may not have a direct relationship with, depending
                        on the service in question. Some services may only
                        be offered to those users where such a direct
                        relationship exists (for particularly sensitive
                        services, for example), while some may not require
                        this and would instead be satisfied with basic
                        federation trust guarantees between themselves and the
                        IdP. This may well include the option that the
                        user stays anonymous with respect to the RP (though,
                        obviously, never anonymous to the IdP). If
                        attempting to preserve privacy via
                        data minimization (<xref target="introduction"/>),
                        then the only attribute information about
                        Individuals exposed to the RP should be
                        attribute information that is strictly necessary
                        for the operation of the service.
                    </t>
                    <t>
                        Between user and Federation Substrate - The user is
                        highly likely to have no knowledge of, or relationship
                        with, any entities involved with the
                        Federation Substrate (not that the IdP and/or RP
                        may, however). Knowledge of attribute information
                        about Individuals for these entities is not
                        necessary, and thus such information should be
                        protected in such a way as to prevent the
                        possibility of access to this information.
                    </t>
                </list>
            </t>
        </section>
        
        <section title="Accounting Information">
          <t>
            Alongside the core authentication and authorization that occur in
            AAA communications, accounting information about resource
            consumption may be delivered as part of the accounting exchange
            during the lifetime of the granted application session.
          </t>
        </section>

        <section title="Collection and Retention of Data and Identifiers">
          <t>
            In cases where RPs are not required to identify a
            particular Individual when an Individual wishes to make use of
            their service, the ABFAB architecture enables anonymous or
            pseudonymous access. Thus, data and identifiers other than
            pseudonyms and unlinkable attribute information need not be
            stored and retained.
          </t>
          <t>
            However, in cases where RPs require the ability to
            identify a particular Individual (e.g., so they can link this
            identity information to a particular account in their service, or
            where identity information is required for audit purposes), the
            service will need to collect and store such information, and to
            retain it for as long as they require. The de&nbhy;provisioning
            of such accounts and information is out of scope for ABFAB,
            but for privacy protection, it is obvious that any identifiers
            collected should be deleted when they are no longer needed.
          </t>
        </section>

        <section title="User Participation">
            <t>
                In the ABFAB architecture, by its very nature users are active
                participants in the sharing of their identifiers, as they
                initiate the communications exchange every time they wish to
                access a server. They are, however, not involved in the
                control of information related to them that is transmitted
                from the IdP to the RP for authorization purposes; rather,
                this is under the control of policy on the IdP. Due to the
                nature of the AAA communication flows, with the current
                ABFAB architecture there is no place for a process of
                gaining user consent for the information to be released
                from the IdP to the RP.
            </t>
        </section>

    </section>

    <section anchor="sec-cons" title="Security Considerations">

      <t>
        This document describes the architecture for Application Bridging
        for Federated Access Beyond web (ABFAB), and security is
        therefore the main focus. Many of the items that are security
        considerations have already been discussed
        in <xref target="privacyconsiderations"/> ("Privacy Considerations").
        Readers should be sure to read that section as well.
      </t>

      <t>
        There are many places in this document where TLS is used. While
        in some places (e.g., client to RP) anonymous connections can be
        used, it is very important that TLS connections within the AAA
        infrastructure and between the client and the IdP be fully
        authenticated and, if using certificates, that revocation be checked
        as well. When using anonymous connections between the client and
        the RP, all messages and data exchanged between those two
        entities will be visible to an active attacker. In situations
        where the client is not yet on the network, the
        status_request extension <xref target="RFC6066"/> can be used to
        obtain revocation-checking data inside of the TLS protocol.
        Clients also need to get the trust anchor for the IdP configured
        correctly in order to prevent attacks; this is a difficult problem
        in general and is going to be even more difficult for kiosk
        environments.
      </t>

      <t>
        Selection of the EAP methods to be permitted by clients and IdPs is
        important. The use of a tunneling method such as
        TEAP <xref target="RFC7170"/> allows other EAP methods to be used
        while hiding the contents of those EAP exchanges from the RP and
        the AAA framework. When considering inner EAP methods, the
        considerations outlined in <xref target="RFC7029"/> about binding
        the inner and outer EAP methods need to be taken into account.
        Finally, one wants to have the ability to support channel binding
        in those cases where the client needs to validate that it is
        talking to the correct RP.
      </t>

      <t>
        In those places where SAML statements are used, RPs will generally be
        unable to validate signatures on the SAML statement, either because
        the signature has been stripped off by the IdP or because the RP
        is unable to validate the binding between the signer, the key
        used to sign, and the realm represented by the IdP. For these
        reasons, it is required that IdPs do the necessary trust checking
        on the SAML statements and that RPs can trust the AAA infrastructure
        to keep the SAML statements valid.
      </t>

      <t>
        When a pseudonym is generated as a unique long&nbhy;term identifier
        for a client by an IdP, care must be taken in the algorithm that it
        cannot easily be reverse-engineered by the service provider. If it
        can be reverse-engineered, then the service provider can consult
        an oracle to determine if a given unique long&nbhy;term identifier
        is associated with a different known identifier.
      </t>
    </section>

  </middle>

  <back>

    <references title="Normative References">
      &RFC2743;
      &RFC2865;
      &RFC3748;
      &RFC3579;
      &RFC4072;
      &RFC7055;

<!-- draft-abfab-aaa-saml (RFC 7833) -->
<reference anchor="RFC7833" target="http://www.rfc-editor.org/info/rfc7833">
<front>
<title>A RADIUS Attribute, Binding, Profiles, Name Identifier Format, and
Confirmation Methods for the Security Assertion Markup Language (SAML)</title>
<author initials='J' surname='Howlett' fullname='Josh Howlett'>
    <organization />
</author>
<author initials='S' surname='Hartman' fullname='Sam Hartman'>
    <organization />
</author>
<author initials='A' surname='Perez-Mendez' fullname='Alejandro Perez-Mendez' role="editor">
    <organization />
</author>
<date month='May' year='2016' />
</front>
<seriesInfo name='RFC' value='7833' />
<seriesInfo name="DOI" value="10.17487/RFC7833"/>
</reference>

<!-- RFC 7542 (formerly draft-ietf-radext-nai; published) -->
      &RFC7542;
      &RFC6677;

    </references>

    <references title="Informative References">
      &RFC6733;
      &RFC6749;
      &RFC6973;

<!-- RFC 7499 (draft-ietf-radext-radius-fragmentation; published) -->
      &RFC7499;
      &RFC1964;
      &RFC7530;
      &RFC3645;
      &RFC4462;
      &RFC4422;
      &RFC5056;
      &RFC5080;
      &RFC5705;
      &RFC5801; 
      &RFC6614;

<reference
    target="http://docs.oasis&nbhy;open.org/security/saml/v2.0/saml-core-2.0-os.pdf" anchor="OASIS.saml-core-2.0-os">
  <front><title>Assertions and Protocols for the OASIS Security Assertion
  Markup Language (SAML) V2.0</title>
  <author fullname="Scott Cantor" initials="S." surname="Cantor">
    <organization>Internet2</organization>
    <address><email>cantor.2@osu.edu</email></address></author>
  <author fullname="John Kemp" initials="J."
    surname="Kemp"><organization>Nokia</organization>
    <address><email>John.Kemp@nokia.com</email></address></author>
  <author fullname="Rob Philpott" initials="R." surname="Philpott">
    <organization>RSA Security</organization>
    <address><email>rphilpott@rsasecurity.com</email></address></author>
  <author fullname="Eve Maler" initials="E." surname="Maler">
    <organization>Sun Microsystems</organization>
    <address><email>eve.maler@sun.com</email></address></author>
  <date year="2005" month="March"/></front>
  <seriesInfo name="OASIS Standard" value="saml-core-2.0-os"/>
</reference>

      &RFC7029;

<!-- RFC 7170 (formerly draft-ietf-emu-eap-tunnel-method; published) -->
      &RFC7170;

<!-- RFC 7360 (formerly draft-ietf-radext-dtls; published) -->
      &RFC7360;

<!-- RFC 7585 (formerly draft-ietf-radext-dynamic-discovery; published) -->
      &RFC7585;

      <reference anchor="WS-TRUST" target="http://docs.oasis-open.org/ws-sx/ws-trust/v1.4/ws-trust.html">
        <front>
          <title>WS-Trust 1.4</title>
          <author initials="K" surname="Lawrence"/>
          <author initials="C" surname="Kaler"/>
          <author initials="A" surname="Nadalin"/>
          <author initials="M" surname="Goodner"/>
          <author initials="M" surname="Gudgin"/>
          <author initials="D" surname="Turner"/>
          <author initials="A" surname="Barbir"/>
          <author initials="H" surname="Granqvist"/>
          <date month="April" year="2012"/>
        </front>
        <seriesInfo name="OASIS Standard" value="ws-trust-2012-04"/>
        <format type="HTML" target="http://docs.oasis-open.org/ws-sx/ws-trust/v1.4/ws-trust.html"/>
      </reference>

      <reference anchor="NIST-SP.800-63-2" target="http://dx.doi.org/10.6028/NIST.SP.800-63-2">
        <front>
          <title>Electronic Authentication Guideline</title>
          <author initials="W" surname="Burr"/>
          <author initials="D" surname="Dodson"/>
          <author initials="E" surname="Newton"/>
          <author initials="R" surname="Perlner"/>
          <author initials="W" surname="Polk"/>
          <author initials="S" surname="Gupta"/>
          <author initials="E" surname="Nabbus"/>
          <date month="August" year="2013"/>
        </front>
        <seriesInfo name="NIST Special Publication" value="800-63-2"/>
      </reference>

      &RFC5246;
      &RFC2782;
      &RFC3401;
      &RFC4033;
      &RFC6066;
    </references>

    <section title="Acknowledgments" numbered="no">
      <t>We would like to thank Mayutan Arumaithurai, Klaas Wierenga, and
      Rhys Smith for their feedback. Additionally, we would like to
      thank Eve Maler, Nicolas Williams, Bob Morgan, Scott Cantor, Jim Fenton,
      Paul Leach, and Luke Howard for their feedback on the
      federation terminology question.</t>

      <t>Furthermore, we would like to thank Klaas Wierenga for his review of
      the first draft version of this document. We also thank Eliot Lear
      for his work on early draft versions of this document.</t>
    </section>
  </back>
</rfc>
