<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY RFC1122 SYSTEM "reference.RFC.1122.xml">
<!ENTITY RFC2119 SYSTEM "reference.RFC.2119.xml">
<!ENTITY RFC2817 SYSTEM "reference.RFC.2817.xml">
<!ENTITY RFC3168 SYSTEM "reference.RFC.3168.xml">
<!ENTITY RFC3948 SYSTEM "reference.RFC.3948.xml">
<!ENTITY RFC4303 SYSTEM "reference.RFC.4303.xml">
<!ENTITY RFC4555 SYSTEM "reference.RFC.4555.xml">
<!ENTITY RFC5246 SYSTEM "reference.RFC.5246.xml">
<!ENTITY RFC6040 SYSTEM "reference.RFC.6040.xml">
<!ENTITY RFC6520 SYSTEM "reference.RFC.6520.xml">
<!ENTITY RFC7296 SYSTEM "reference.RFC.7296.xml">
<!ENTITY RFC7383 SYSTEM "reference.RFC.7383.xml">
<!ENTITY RFC8174 SYSTEM "reference.RFC.8174.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt'?>

<?rfc strict="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc ipr="trust200902" category="std" number="8229" submissionType="IETF" consensus="yes">

  <front>

    <title abbrev="TCP Encapsulation of IKE and IPsec Packets">TCP
    Encapsulation of IKE and&nbsp;IPsec&nbsp;Packets</title>

    <author fullname="Tommy Pauly" initials="T." surname="Pauly">
      <organization>Apple Inc.</organization>
      <address>
        <postal>
          <street>1 Infinite Loop</street>
          <city>Cupertino</city>
          <region>California</region>
          <code>95014</code>
          <country>United States of America</country>
        </postal>
        <email>tpauly@apple.com</email>
      </address>
    </author>

  <author fullname="Samy Touati" initials="S." surname="Touati">
    <organization>Ericsson</organization>
    <address>
        <postal>
            <street>2755 Augustine</street>
            <city>Santa Clara</city>
            <region>California</region>
            <code>95054</code>
            <country>United States of America</country>
        </postal>
        <email>samy.touati@ericsson.com</email>
    </address>
  </author>

  <author fullname="Ravi Mantha" initials="R." surname="Mantha">
    <organization>Cisco Systems</organization>
    <address>
        <postal>
            <street>SEZ, Embassy Tech Village</street>
            <city>Panathur</city>
            <region>Bangalore</region>
            <code>560 037</code>
            <country>India</country>
        </postal>
        <email>ramantha@cisco.com</email>
    </address>
  </author>

    <date month="August" year="2017"/>

    <keyword>IKE</keyword>
    <keyword>IKEv2</keyword>
    <keyword>IPsec</keyword>
    <keyword>TCP</keyword>

    <abstract>
      <t>This document describes a method to transport Internet Key Exchange
      Protocol (IKE) and IPsec packets over a TCP connection for traversing
      network middleboxes that may block IKE negotiation over UDP. This
      method, referred to as "TCP encapsulation", involves sending both
      IKE packets for Security Association establishment and Encapsulating
      Security Payload (ESP) packets over a TCP connection. This method is
      intended to be used as a fallback option when IKE cannot be negotiated
      over UDP.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>The Internet Key Exchange Protocol version 2 (IKEv2)
      <xref target="RFC7296"/> is a protocol for establishing IPsec
      Security Associations (SAs), using IKE messages over UDP for control
      traffic, and using Encapsulating Security Payload (ESP) 
      <xref target="RFC4303"/> messages for encrypted data traffic. Many
      network middleboxes that filter traffic on public hotspots block all UDP
      traffic, including IKE and IPsec, but allow TCP connections through
      because they appear to be web traffic. Devices on these networks that
      need to use IPsec (to access private enterprise networks, to route Voice
      over IP calls to carrier networks, or because of security policies) are
      unable to establish IPsec SAs. This document defines a method for
      encapsulating IKE control messages as well as IPsec data messages within
      a TCP connection.</t>

      <t>Using TCP as a transport for IPsec packets adds a third option to
      the list of traditional IPsec transports:

      <list style="numbers">
        <t>Direct. Currently, IKE negotiations begin over UDP port&nbsp;500.
        If no Network Address Translation (NAT) device is detected
        between the Initiator and the Responder, then subsequent IKE packets
        are sent over UDP port&nbsp;500, and IPsec data packets are sent
        using&nbsp;ESP.</t>

        <t>UDP Encapsulation <xref target="RFC3948"/>. If a
        NAT is detected between the Initiator and the Responder, then
        subsequent IKE packets are sent over UDP port 4500 with four bytes
        of zero at the start of the UDP payload, and ESP packets are sent out
        over UDP port&nbsp;4500. Some peers default to using UDP encapsulation
        even when no NAT is detected on the path, as some middleboxes do not
        support IP protocols other than TCP and UDP.</t>

        <t>TCP Encapsulation. If the other two methods are not available
        or appropriate, IKE negotiation packets as well as ESP packets
        can be sent over a single TCP connection to the peer.</t>
      </list></t>

      <t>Direct use of ESP or UDP encapsulation should be preferred by
      IKE&nbsp;implementations due to performance concerns when using
      TCP&nbsp;encapsulation (<xref target="performance"/>). Most
      implementations should use TCP&nbsp;encapsulation only on networks
      where negotiation over UDP has been attempted without receiving
      responses from the peer or if a network is known to not support UDP.</t>

      <section title="Prior Work and Motivation">
        <t>Encapsulating IKE connections within TCP streams is a common
        approach to solve the problem of UDP packets being blocked by
        network middleboxes. The specific goals of this document are as follows:</t>

        <t><list style="symbols">
            <t>To promote interoperability by defining a standard method
                of framing IKE and ESP messages within TCP streams.</t>
            <t>To be compatible with the current IKEv2 standard without
                requiring modifications or extensions.</t>
            <t>To use IKE over UDP by default to avoid the overhead of
                other alternatives that always rely on TCP or Transport
                Layer Security (TLS) <xref target="RFC5246"/>.</t>
        </list></t>

        <t>Some previous alternatives include:</t>
        <t><list style="hanging">
            <t hangText="Cellular Network Access"><vspace/>
            Interworking Wireless LAN (IWLAN) uses IKEv2 to create
            secure connections to cellular carrier networks for making
            voice calls and accessing other network services over
            Wi-Fi networks. 3GPP has recommended that IKEv2 and ESP packets
            be sent within a TLS connection to be able to
            establish connections on restrictive networks.</t>
            <t hangText="ISAKMP over TCP"><vspace/>
            Various non-standard extensions to the Internet Security
            Association and Key Management Protocol (ISAKMP) have been
            deployed that send IPsec traffic over TCP or TCP-like packets.</t>
            <t hangText="Secure Sockets Layer (SSL) VPNs"><vspace/>
            Many proprietary VPN solutions use a combination of TLS and
            IPsec in order to provide reliability. These often run on
            TCP port 443.</t>
            <t hangText="IKEv2 over TCP"><vspace/>
            IKEv2 over TCP as described in <xref target="IKE-over-TCP"/>
            is used to avoid UDP fragmentation.</t>
        </list></t>

      </section>

      <section title="Terminology and Notation">
      <t>This document distinguishes between the IKE peer that initiates TCP
      connections to be used for TCP encapsulation and the roles of
      Initiator and Responder for particular IKE messages. During the course
      of IKE exchanges, the role of IKE Initiator and Responder may swap for
      a given SA (as with IKE SA rekeys), while the Initiator of the TCP
      connection is still responsible for tearing down the TCP connection
      and re-establishing it if necessary. For this reason, this document
      will use the term "TCP Originator" to indicate the IKE peer that
      initiates TCP connections. The peer that receives TCP connections will
      be referred to as the "TCP Responder". If an IKE SA is rekeyed one or
      more times, the TCP Originator MUST remain the peer that originally
      initiated the first IKE SA.</t>

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
      "SHALL&nbsp;NOT", "SHOULD", "SHOULD&nbsp;NOT", "RECOMMENDED",
      "NOT&nbsp;RECOMMENDED", "MAY", and "OPTIONAL" in this document
      are to be interpreted as described in BCP&nbsp;14
      <xref format="default" pageno="false" target="RFC2119"/>
      <xref format="default" pageno="false" target="RFC8174"/> when,
      and only when, they appear in all capitals, as shown here.</t>

      </section>
    </section>

    <section title="Configuration">
      <t>One of the main reasons to use TCP encapsulation is that UDP
      traffic may be entirely blocked on a network. Because of this, support
      for TCP encapsulation is not specifically negotiated in the IKE
      exchange. Instead, support for TCP encapsulation must be
      pre-configured on both the TCP Originator and the TCP Responder.</t>

      <t>Implementations MUST support TCP encapsulation on TCP port 4500,
      which is reserved for IPsec NAT traversal.</t>

      <t>Beyond a flag indicating support for TCP encapsulation, the
      configuration for each peer can include the following optional
      parameters:</t>

      <t><list style="symbols">
          <t>Alternate TCP ports on which the specific TCP Responder listens
          for incoming connections.  Note that the TCP Originator may
          initiate TCP connections to the TCP Responder from any local
          port.</t>

          <t>An extra framing protocol to use on top of TCP to further
          encapsulate the stream of IKE and IPsec packets. See <xref
          target="tls_appendix"/> for a detailed discussion.</t>
      </list></t>

      <t>Since TCP encapsulation of IKE and IPsec packets adds overhead
      and has potential performance trade-offs compared to direct or
      UDP&nbhy;encapsulated SAs (as described in
      <xref target="performance"/>), implementations SHOULD prefer ESP
      direct or UDP&nbhy;encapsulated SAs over TCP&nbhy;encapsulated SAs
      when possible.</t>

    </section>

    <section title="TCP-Encapsulated Header Formats">
      <t>Like UDP encapsulation, TCP encapsulation uses the first four bytes
      of a message to differentiate IKE and ESP messages. TCP encapsulation
      also adds a Length field to define the boundaries of messages within a
      stream. The message length is sent in a 16-bit field that precedes
      every message. If the first 32&nbsp;bits of the message are zeros (a
      non-ESP marker), then the contents comprise an IKE message. Otherwise,
      the contents comprise an ESP message. Authentication Header (AH)
      messages are not supported for TCP encapsulation.</t>

      <t>Although a TCP stream may be able to send very long messages,
      implementations SHOULD limit message lengths to typical UDP datagram
      ESP payload lengths. The maximum message length is used as the
      effective MTU for connections that are being encrypted using ESP, so
      the maximum message length will influence characteristics of inner
      connections, such as the TCP Maximum Segment Size (MSS).</t>

      <t>Note that this method of encapsulation will also work for placing
      IKE and ESP messages within any protocol that presents a stream
      abstraction, beyond TCP.</t>

    <section title="TCP-Encapsulated IKE Header Format">
        <figure align="center" anchor="ike_tcp_header">
            <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Non-ESP Marker                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
~                      IKE header [RFC7296]                     ~
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>

      <t>The IKE header is preceded by a 16-bit Length field in network byte
      order that specifies the length of the IKE message (including the
      non-ESP marker) within the TCP stream. As with IKE over UDP
      port&nbsp;4500, a zeroed 32-bit non-ESP marker is inserted before
      the start of the IKE header in order to differentiate the traffic
      from ESP traffic between the same addresses and ports.</t>

      <t><list style="symbols">
          <t>Length (2 octets, unsigned integer) - Length of the IKE packet,
          including the Length field and non-ESP marker.</t>
      </list></t>
      </section>

      <section title="TCP-Encapsulated ESP Header Format">

<figure align="center" anchor="esp_tcp_header">
    <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
~                     ESP header [RFC4303]                      ~
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
</figure>

    <t>The ESP header is preceded by a 16-bit Length field in network byte
    order that specifies the length of the ESP packet within the TCP
    stream.</t>

    <t>The Security Parameter Index (SPI) field <xref target="RFC7296"/>
    in the ESP header MUST NOT be a zero value.</t>

    <t><list style="symbols">
      <t>Length (2 octets, unsigned integer) - Length of the ESP packet,
      including the Length field.</t>
    </list></t>

      </section>
      </section>

    <section title="TCP-Encapsulated Stream Prefix" anchor="prefix_format">
      <t>Each stream of bytes used for IKE and IPsec encapsulation MUST
      begin with a fixed sequence of six bytes as a magic value, containing
      the characters "IKETCP" as ASCII values. This value is intended to
      identify and validate that the TCP connection is being used for TCP
      encapsulation as defined in this document, to avoid conflicts with the
      prevalence of previous non-standard protocols that used TCP
      port&nbsp;4500. This value is only sent once, by the TCP Originator
      only, at the beginning of any stream of IKE and ESP messages.</t>

      <t>If other framing protocols are used within TCP to further
      encapsulate or encrypt the stream of IKE and ESP messages, the stream
      prefix must be at the start of the TCP Originator's IKE and ESP
      message stream within the added protocol layer (<xref
      target="tls_appendix"/>). Although some framing protocols do support
      negotiating inner protocols, the stream prefix should always be used
      in order for implementations to be as generic as possible and not rely
      on other framing protocols on top of TCP.</t>

      <figure align="center" anchor="magic">
          <artwork align="left"><![CDATA[
             0      1      2      3      4      5
            +------+------+------+------+------+------+
            | 0x49 | 0x4b | 0x45 | 0x54 | 0x43 | 0x50 |
            +------+------+------+------+------+------+
]]></artwork>
      </figure>
    </section>

    <section title="Applicability">
      <t>TCP encapsulation is applicable only when it has been configured to
      be used with specific IKE peers. If a Responder is configured to use
      TCP encapsulation, it MUST listen on the configured port(s) in case
      any peers will initiate new IKE sessions. Initiators MAY use TCP
      encapsulation for any IKE session to a peer that is configured to
      support TCP encapsulation, although it is recommended that Initiators
      should only use TCP encapsulation when traffic over UDP is
      blocked.</t>

      <t>Since the support of TCP encapsulation is a configured property,
      not a negotiated one, it is recommended that if there are multiple IKE
      endpoints representing a single peer (such as multiple machines with
      different IP addresses when connecting by Fully Qualified Domain Name,
      or endpoints used with IKE redirection), all of the endpoints equally
      support TCP encapsulation.</t>

      <t>If TCP encapsulation is being used for a specific IKE SA, all
      messages for that IKE SA and its Child SAs MUST be sent over a TCP
      connection until the SA is deleted or IKEv2 Mobility and Multihoming
      (MOBIKE) is used to change the SA endpoints and/or the
      encapsulation protocol. See <xref target="mobike"/> for more details
      on using MOBIKE to transition between encapsulation modes.</t>

      <section title="Recommended Fallback from UDP">
          <t>Since UDP is the preferred method of transport for IKE
          messages, implementations that use TCP encapsulation should have
          an algorithm for deciding when to use TCP after determining that
          UDP is unusable. If an Initiator implementation has no prior
          knowledge about the network it is on and the status of UDP on that
          network, it SHOULD always attempt to negotiate IKE over UDP
          first. IKEv2 defines how to use retransmission timers with
          IKE messages and, specifically, IKE_SA_INIT messages <xref
          target="RFC7296"/>. Generally, this means that the implementation
          will define a frequency of retransmission and the maximum number
          of retransmissions allowed before marking the IKE SA as failed. An
          implementation can attempt negotiation over TCP once it has hit
          the maximum retransmissions over UDP, or slightly before to reduce
          connection setup delays. It is recommended that the initial
          message over UDP be retransmitted at least once before falling
          back to TCP, unless the Initiator knows beforehand that the
          network is likely to block UDP.</t>
      </section>
    </section>

    <section title="Connection Establishment and Teardown">
    <t>When the IKE Initiator uses TCP encapsulation, it will initiate a TCP
    connection to the Responder using the configured TCP port. The first bytes
    sent on the stream MUST be the stream prefix value (<xref
    target="prefix_format"/>). After this prefix, encapsulated IKE messages
    will negotiate the IKE SA and initial Child SA <xref
    target="RFC7296"/>. After this point, both encapsulated IKE (<xref
    target="ike_tcp_header"/>) and ESP (<xref target="esp_tcp_header"/>)
    messages will be sent over the TCP connection. The TCP Responder MUST wait
    for the entire stream prefix to be received on the stream before trying to
    parse out any IKE or ESP messages. The stream prefix is sent only once,
    and only by the TCP Originator.</t>

    <t>In order to close an IKE session, either the Initiator or Responder
    SHOULD gracefully tear down IKE SAs with DELETE payloads.  Once the SA has
    been deleted, the TCP Originator SHOULD close the TCP connection if it
    does not intend to use the connection for another IKE session to the TCP
    Responder. If the connection is left idle and the TCP Responder needs to
    clean up resources, the TCP Responder MAY close the TCP connection.</t>

    <t>An unexpected FIN or a TCP Reset on the TCP connection may indicate a
    loss of connectivity, an attack, or some other error. If a DELETE payload
    has not been sent, both sides SHOULD maintain the state for their SAs for
    the standard lifetime or timeout period. The TCP Originator is
    responsible for re-establishing the TCP connection if it is torn down for
    any unexpected reason. Since new TCP connections may use different ports
    due to NAT mappings or local port allocations changing, the TCP Responder
    MUST allow packets for existing SAs to be received from new source
    ports.</t>

    <t>A peer MUST discard a partially received message due to a broken
    connection.</t>

    <t>Whenever the TCP Originator opens a new TCP connection to be used for
    an existing IKE SA, it MUST send the stream prefix first, before any IKE
    or ESP messages. This follows the same behavior as the initial TCP
    connection.</t>

    <t>If a TCP connection is being used to resume a previous IKE session,
    the TCP Responder can recognize the session using either the IKE SPI
    from an encapsulated IKE message or the ESP SPI from an encapsulated
    ESP message. If the session had been fully established previously, it
    is suggested that the TCP Originator send an UPDATE_SA_ADDRESSES
    message if MOBIKE is supported, or an informational message (a
    keep&nbhy;alive) otherwise.</t>

    <t>The TCP Responder MUST NOT accept any messages for the existing IKE
    session on a new incoming connection, unless that connection begins
    with the stream prefix. If either the TCP Originator or TCP Responder
    detects corruption on a connection that was started with a valid
    stream prefix, it SHOULD close the TCP connection. The connection
    can be determined to be corrupted if there are too many subsequent
    messages that cannot be parsed as valid IKE messages or ESP messages with
    known SPIs, or if the authentication check for an ESP message with a
    known SPI fails. Implementations SHOULD NOT tear&nbsp;down a connection
    if only a single ESP message has an unknown SPI, since the
    SPI databases may be momentarily out of sync. If there is instead
    a syntax issue within an IKE message, an implementation MUST send
    the INVALID_SYNTAX notify payload and tear&nbsp;down the IKE SA
    as usual, rather than tearing down the TCP connection directly.</t>

    <t>A TCP Originator SHOULD only open one TCP connection per IKE SA, over
    which it sends all of the corresponding IKE and ESP messages. This helps
    ensure that any firewall or NAT mappings allocated for the TCP connection
    apply to all of the traffic associated with the IKE SA equally.</t>

    <t>Similarly, a TCP Responder SHOULD at any given time send packets for an
    IKE SA and its Child SAs over only one TCP connection. It SHOULD choose
    the TCP connection on which it last received a valid and decryptable IKE
    or ESP message. In order to be considered valid for choosing a TCP
    connection, an IKE message must be successfully decrypted and
    authenticated, not be a retransmission of a previously received message,
    and be within the expected window for IKE message&nbsp;IDs. Similarly,
    an ESP message must pass authentication checks and be decrypted,
    and must not be a replay of a previous message.</t>

    <t>Since a connection may be broken and a new connection re-established by
    the TCP Originator without the TCP Responder being aware, a TCP Responder
    SHOULD accept receiving IKE and ESP messages on both old and new
    connections until the old connection is closed by the TCP Originator. A
    TCP Responder MAY close a TCP connection that it perceives as idle and
    extraneous (one previously used for IKE and ESP messages that has been
    replaced by a new connection).</t>

    <t>Multiple IKE SAs MUST NOT share a single TCP connection, unless one is
    a rekey of an existing IKE SA, in which case there will temporarily be two
    IKE SAs on the same TCP connection.</t>

    </section>

    <section title="Interaction with NAT Detection Payloads">
    <t>When negotiating over UDP port 500, IKE_SA_INIT packets include
    NAT_DETECTION_SOURCE_IP and NAT_DETECTION_DESTINATION_IP payloads to
    determine if UDP encapsulation of IPsec packets should be used. These
    payloads contain SHA-1 digests of the SPIs, IP addresses, and ports as
    defined in <xref target="RFC7296"/>. IKE_SA_INIT packets sent on a TCP
    connection SHOULD include these payloads with the same content as when
    sending over UDP and SHOULD use the applicable TCP ports when creating
    and checking the SHA-1 digests.</t>

    <t>If a NAT is detected due to the SHA-1 digests not matching the expected
    values, no change should be made for encapsulation of subsequent IKE or
    ESP packets, since TCP encapsulation inherently supports NAT
    traversal. Implementations MAY use the information that a NAT is present
    to influence keep&nbhy;alive timer values.</t>

    <t>If a NAT is detected, implementations need to handle transport mode TCP
    and UDP packet checksum fixup as defined for UDP encapsulation in <xref
    target="RFC3948"/>.</t>

    </section>

<section title="Using MOBIKE with TCP Encapsulation" anchor="mobike">

    <t>When an IKE session that has negotiated MOBIKE <xref target="RFC4555"/>
    is transitioning between networks, the Initiator of the transition may
    switch between using TCP encapsulation, UDP encapsulation, or no
    encapsulation. Implementations that implement both MOBIKE and TCP
    encapsulation MUST support dynamically enabling and disabling TCP
    encapsulation as interfaces change.</t>

    <t>When a MOBIKE-enabled Initiator changes networks, the
    UPDATE_SA_ADDRESSES notification SHOULD be sent out first over UDP before
    attempting over TCP. If there is a response to the UPDATE_SA_ADDRESSES
    notification sent over UDP, then the ESP packets should be sent directly
    over IP or over UDP port 4500 (depending on if a NAT was detected),
    regardless of if a connection on a previous network was using TCP
    encapsulation. Similarly, if the Responder only responds to the
    UPDATE_SA_ADDRESSES notification over TCP, then the ESP packets should be
    sent over the TCP connection, regardless of if a connection on a previous
    network did not use TCP encapsulation.</t>

</section>

<section title="Using IKE Message Fragmentation with TCP Encapsulation" anchor="fragmentation">

    <t>IKE message fragmentation <xref target="RFC7383"/> is not required
    when using TCP encapsulation, since a TCP stream already handles the
    fragmentation of its contents across packets. Since fragmentation is
    redundant in this case, implementations might choose to not negotiate IKE
    fragmentation. Even if fragmentation is negotiated, an implementation
    SHOULD NOT send fragments when going over a TCP connection, although it
    MUST support receiving fragments.</t>

    <t>If an implementation supports both MOBIKE and IKE fragmentation, it
    SHOULD negotiate IKE fragmentation over a TCP&nbhy;encapsulated session
    in case the session switches to UDP encapsulation on another network.</t>

</section>

    <section title="Considerations for Keep-Alives and Dead Peer Detection">
    <t>Encapsulating IKE and IPsec inside of a TCP connection can impact the
    strategy that implementations use to detect peer liveness and to maintain
    middlebox port mappings. Peer liveness should be checked using
    IKE informational packets <xref target="RFC7296"/>.</t>

    <t>In general, TCP port mappings are maintained by NATs longer than UDP
    port mappings, so IPsec ESP NAT keep&nbhy;alives <xref target="RFC3948"/>
    SHOULD NOT be sent when using TCP encapsulation. Any implementation using
    TCP encapsulation MUST silently drop incoming NAT keep&nbhy;alive packets
    and&nbsp;not treat them as errors. NAT keep&nbhy;alive packets over a
    TCP&nbhy;encapsulated IPsec connection will be sent as an ESP message
    with a one-octet-long payload with the value 0xFF.</t>

    <t>Note that, depending on the configuration of TCP and TLS on the
    connection, TCP keep&nbhy;alives <xref target="RFC1122"/> and
    TLS keep&nbhy;alives <xref target="RFC6520"/> may be used. These
    MUST&nbsp;NOT be used as indications of IKE peer liveness.</t>

    </section>

<section title="Middlebox Considerations">
    <t>Many security networking devices, such as firewalls or intrusion
    prevention systems, network optimization/acceleration devices, and
    NAT devices, keep the state of sessions that traverse through them.</t>

    <t>These devices commonly track the transport-layer and/or
    application-layer data to drop traffic that is anomalous or malicious
    in nature. While many of these devices will be more likely to pass
    TCP&nbhy;encapsulated traffic as opposed to UDP&nbhy;encapsulated
    traffic, some may still block or interfere with TCP&nbhy;encapsulated
    IKE and IPsec traffic.</t>

    <t>A network device that monitors the transport layer will track the state
    of TCP sessions, such as TCP sequence numbers. TCP encapsulation of IKE
    should therefore use standard TCP behaviors to avoid being dropped by
    middleboxes.</t>

</section>

<section title="Performance Considerations" anchor="performance">
    <t>Several aspects of TCP encapsulation for IKE and IPsec packets may
    negatively impact the performance of connections within a tunnel-mode
    IPsec SA. Implementations should be aware of these performance impacts and
    take these into consideration when determining when to use TCP
    encapsulation. Implementations SHOULD favor using direct ESP or UDP
    encapsulation over TCP encapsulation whenever possible.</t>

<section title="TCP-in-TCP">
    <t>If the outer connection between IKE peers is over TCP, inner TCP
    connections may suffer negative effects from using TCP within TCP.
    Running TCP within TCP is discouraged, since the TCP algorithms generally
    assume that they are running over an unreliable datagram layer.</t>

    <t>If the outer (tunnel) TCP connection experiences packet loss, this loss
    will be hidden from any inner TCP connections, since the outer connection
    will retransmit to account for the losses. Since the outer TCP connection
    will deliver the inner messages in order, any messages after a lost packet
    may have to wait until the loss is recovered. This means that loss on the
    outer connection will be interpreted only as delay by inner
    connections. The burstiness of inner traffic can increase, since a large
    number of inner packets may be delivered across the tunnel at once. The
    inner TCP connection may interpret a long period of delay as a
    transmission problem, triggering a retransmission timeout, which will
    cause spurious retransmissions. The sending rate of the inner connection
    may be unnecessarily reduced if the retransmissions are not detected as
    spurious in time.</t>

    <t>The inner TCP connection's round-trip-time estimation will be affected
    by the burstiness of the outer TCP connection if there are long delays
    when packets are retransmitted by the outer TCP connection. This will make
    the congestion control loop of the inner TCP traffic less reactive,
    potentially permanently leading to a lower sending rate than the outer TCP
    would allow for.</t>

    <t>TCP-in-TCP can also lead to increased buffering, or bufferbloat. This
    can occur when the window size of the outer TCP connection is reduced and
    becomes smaller than the window sizes of the inner TCP connections. This
    can lead to packets backing up in the outer TCP connection's send
    buffers. In order to limit this effect, the outer TCP connection should
    have limits on its send buffer size and on the rate at which it reduces
    its window size.</t>

    <t>Note that any negative effects will be shared between all flows going
    through the outer TCP connection. This is of particular concern for any
    latency-sensitive or real-time applications using the tunnel. If such
    traffic is using a TCP&nbhy;encapsulated IPsec connection, it is
    recommended that the number of inner connections sharing the tunnel be
    limited as much as possible.</t>

</section>

<section title="Added Reliability for Unreliable Protocols">
    <t>Since ESP is an unreliable protocol, transmitting ESP packets over a
    TCP connection will change the fundamental behavior of the packets. Some
    application-level protocols that prefer packet loss to delay (such as
    Voice over IP or other real-time protocols) may be negatively impacted if
    their packets are retransmitted by the TCP connection due to packet
    loss.</t>
</section>

<section title="Quality-of-Service Markings">
    <t>Quality-of-Service (QoS) markings, such as the Differentiated
    Services Code Point (DSCP) and Traffic Class, should be used with care
    on TCP connections used for encapsulation. Individual packets
    SHOULD&nbsp;NOT use different markings than the rest of the connection,
    since packets with different priorities may be routed differently and
    cause unnecessary delays in the connection.</t>
</section>

<section title="Maximum Segment Size">
    <t>A TCP connection used for IKE encapsulation SHOULD negotiate its MSS
    in order to avoid unnecessary fragmentation of packets.</t>
</section>

<section title="Tunneling ECN in TCP">
    <t>Since there is not a one-to-one relationship between outer IP packets
    and inner ESP/IP messages when using TCP encapsulation, the markings for
    Explicit Congestion Notification (ECN) <xref target="RFC3168"/> cannot be
    simply mapped. However, any ECN Congestion Experienced (CE) marking on
    inner headers should be preserved through the tunnel.</t>

    <t>Implementations SHOULD follow the ECN compatibility mode for tunnel
    ingress as described in <xref target="RFC6040"/>. In compatibility mode,
    the outer tunnel TCP connection marks its packet headers as not ECN-capable.
    If upon egress, the arriving outer header is marked with CE, the
    implementation will drop the inner packet, since
    there is not a distinct inner packet header onto which to translate
    the ECN markings.</t>

</section>
</section>

<section anchor="Security" title="Security Considerations">
    <t>IKE Responders that support TCP encapsulation may become vulnerable to
    new Denial-of-Service (DoS) attacks that are specific to TCP, such as
    SYN-flooding attacks. TCP Responders should be aware of this additional
    attack&nbsp;surface.</t>

    <t>TCP Responders should be careful to ensure that (1) the stream
    prefix "IKETCP" uniquely identifies incoming streams as streams that
    use the TCP encapsulation protocol and (2) they are not running any
    other protocols on the same listening port (to avoid potential
    conflicts).</t>

    <t>Attackers may be able to disrupt the TCP connection by sending spurious
    TCP Reset packets. Therefore, implementations SHOULD make sure that IKE
    session state persists even if the underlying TCP connection is torn
    down.</t>

    <t>If MOBIKE is being used, all of the security considerations outlined
    for MOBIKE apply <xref target="RFC4555"/>.</t>

    <t>Similarly to MOBIKE, TCP encapsulation requires a TCP Responder to
    handle changes to source address and port due to network or connection
    disruption. The successful delivery of valid IKE or ESP messages over a
    new TCP connection is used by the TCP Responder to determine where to send
    subsequent responses. If an attacker is able to send packets on a new TCP
    connection that pass the validation checks of the TCP Responder, it can
    influence which path future packets will take. For this reason, the
    validation of messages on the TCP Responder must include decryption,
    authentication, and replay checks.</t>

    <t>Since TCP provides reliable, in-order delivery of ESP messages, the
    ESP anti-replay window size SHOULD be set to 1. See <xref
    target="RFC4303"/> for a complete description of the ESP anti-replay
    window. This increases the protection of implementations against replay
    attacks.</t>

</section>

    <section anchor="IANA" title="IANA Considerations">
      <t>TCP port 4500 is already allocated to IPsec for NAT traversal. This
      port SHOULD be used for TCP&nbhy;encapsulated IKE and ESP as described
      in this document.</t>

      <t>This document updates the reference for TCP port 4500:</t>

    <figure align="center" anchor="iana_update">
      <artwork align="left"><![CDATA[
      Keyword       Decimal    Description           Reference
      -----------   --------   -------------------   ---------
      ipsec-nat-t   4500/tcp   IPsec NAT-Traversal   RFC 8229
        ]]></artwork>
    </figure>
    </section>

  </middle>

  <back>

    <references title="Normative References">

      &RFC2119;
      &RFC3948;
      &RFC4303;
      &RFC6040;
      &RFC7296;
      &RFC8174;

    </references>

    <references title="Informative References">

      &RFC1122;
      &RFC2817;
      &RFC3168;
      &RFC4555;
      &RFC5246;
      &RFC6520;
      &RFC7383;

<!-- draft-nir-ipsecme-ike-tcp
     (replaced by draft-ietf-ipsecme-ike-tcp (Expired)) -->
  <reference anchor='IKE-over-TCP'>
   <front>
   <title>A TCP transport for the Internet Key Exchange</title>
   <author initials='Y' surname='Nir' fullname='Yoav Nir'>
       <organization />
   </author>
   <date month='December' year='2012' />
   </front>
   <seriesInfo name='Work in Progress,' value='draft-ietf-ipsecme-ike-tcp-01'/>
  </reference>

    </references>
    
    <section title="Using TCP Encapsulation with TLS" anchor="tls_appendix">
    
    <t>This section provides recommendations on how to use TLS in addition to
    TCP encapsulation.</t>

    <t>When using TCP encapsulation, implementations may choose to use TLS
    <xref target="RFC5246"/> on the TCP connection to be able to traverse
    middleboxes, which may otherwise block the traffic.</t>

    <t>If a web proxy is applied to the ports used for the TCP connection and
    TLS is being used, the TCP Originator can send an HTTP CONNECT message to
    establish an SA through the proxy <xref target="RFC2817"/>.</t>

    <t>The use of TLS should be configurable on the peers, and may be used as
    the default when using TCP encapsulation or may be used as a fallback
    when basic TCP encapsulation fails.  The TCP Responder may expect to read
    encapsulated IKE and ESP packets directly from the TCP connection, or it
    may expect to read them from a stream of TLS data packets. The TCP Originator
    should be pre-configured to use TLS or&nbsp;not when communicating with a
    given port on the TCP Responder.</t>

    <t>When new TCP connections are re-established due to a broken connection,
    TLS must be renegotiated. TLS session resumption is recommended to
    improve efficiency in this case.</t> 

    <t>The security of the IKE session is entirely derived from the IKE
    negotiation and key establishment and not from the TLS session (which
    in this context is only used for encapsulation purposes); therefore, when
    TLS is used on the TCP connection, both the TCP Originator and the TCP
    Responder SHOULD allow the NULL cipher to be selected for performance
    reasons.</t>

    <t>Implementations should be aware that the use of TLS introduces another
    layer of overhead requiring more bytes to transmit a given IKE and IPsec
    packet. For this reason, direct ESP, UDP encapsulation, or TCP
    encapsulation without TLS should be preferred in situations in which TLS
    is not required in order to traverse middleboxes.</t>
    
    </section> 
    
    <section title="Example Exchanges of TCP Encapsulation with TLS">

      <section title="Establishing an IKE Session">
        <figure align="center" anchor="ike_establishment_example">
            <artwork align="left"><![CDATA[
                Client                              Server
              ----------                          ----------
  1)  --------------------  TCP Connection  -------------------
      (IP_I:Port_I  -> IP_R:Port_R)
      TcpSyn                    ---------->
                                <----------          TcpSyn,Ack
      TcpAck                    ---------->

  2)  ---------------------  TLS Session  ---------------------
      ClientHello               ---------->
                                                    ServerHello
                                                   Certificate*
                                             ServerKeyExchange*
                                <----------     ServerHelloDone
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                  ---------->
                                             [ChangeCipherSpec]
                                <----------            Finished

  3)  ---------------------- Stream Prefix --------------------
      "IKETCP"                  ---------->
  4)  ----------------------- IKE Session ---------------------
      Length + Non-ESP Marker   ---------->
      IKE_SA_INIT
      HDR, SAi1, KEi, Ni,
      [N(NAT_DETECTION_*_IP)]
                                <------ Length + Non-ESP Marker
                                                    IKE_SA_INIT
                                            HDR, SAr1, KEr, Nr,
                                        [N(NAT_DETECTION_*_IP)]
      Length + Non-ESP Marker   ---------->
      first IKE_AUTH
      HDR, SK {IDi, [CERTREQ]
      CP(CFG_REQUEST), IDr,
      SAi2, TSi, TSr, ...}
                                <------ Length + Non-ESP Marker
                                                 first IKE_AUTH
                                    HDR, SK {IDr, [CERT], AUTH,
                                           EAP, SAr2, TSi, TSr}
      Length + Non-ESP Marker   ---------->
      IKE_AUTH + EAP
      repeat 1..N times
                                <------ Length + Non-ESP Marker
                                                 IKE_AUTH + EAP
      Length + Non-ESP Marker   ---------->
      final IKE_AUTH
      HDR, SK {AUTH}
                                <------ Length + Non-ESP Marker
                                                 final IKE_AUTH
                                  HDR, SK {AUTH, CP(CFG_REPLY),
                                             SA, TSi, TSr, ...}
      -------------- IKE and IPsec SAs Established ------------
      Length + ESP Frame        ---------->
                ]]></artwork>
           </figure>


<t><list style="numbers">
    <t>The client establishes a TCP connection with the server on
    port&nbsp;4500 or on an alternate pre-configured port that the server
    is listening&nbsp;on.</t>

    <t>If configured to use TLS, the client initiates a TLS handshake.
    During the TLS handshake, the server SHOULD NOT request the
    client's certificate, since authentication is handled as part of IKE
    negotiation.</t>

    <t>The client sends the stream prefix for TCP&nbhy;encapsulated IKE
    (<xref target="prefix_format"/>) traffic to signal the beginning of
    IKE negotiation.</t>

    <t>The client and server establish an IKE connection. This example
    shows EAP-based authentication, although any authentication type
    may be used.</t>
</list></t>
    </section>

      <section title="Deleting an IKE Session">
          <figure align="center" anchor="ike_deletion_example">
              <artwork align="left"><![CDATA[
                Client                              Server
              ----------                          ----------
  1)  ----------------------- IKE Session ---------------------
      Length + Non-ESP Marker   ---------->
      INFORMATIONAL
      HDR, SK {[N,] [D,]
             [CP,] ...}
                                <------ Length + Non-ESP Marker
                                                  INFORMATIONAL
                                             HDR, SK {[N,] [D,]
                                                     [CP], ...}

  2)  ---------------------  TLS Session  ---------------------
      close_notify              ---------->
                                <----------        close_notify
  3)  --------------------  TCP Connection  -------------------
      TcpFin                    ---------->
                                <----------                 Ack
                                <----------              TcpFin
      Ack                       ---------->
      --------------------  IKE SA Deleted  -------------------
              ]]></artwork>
    </figure>

<t><list style="numbers">
    <t>The client and server exchange informational messages to
    notify IKE SA deletion.</t>

    <t>The client and server negotiate TLS session deletion using
    TLS CLOSE_NOTIFY.</t>

    <t>The TCP connection is torn down.</t>
</list></t>

    <t>The deletion of the IKE SA should lead to the disposal of the
    underlying TLS and TCP state.</t>

      </section>

    <section title="Re-establishing an IKE Session">
          <figure align="center" anchor="ike_reestablishment_example">
              <artwork align="left"><![CDATA[
                Client                              Server
              ----------                          ----------
  1)  --------------------  TCP Connection  -------------------
      (IP_I:Port_I  -> IP_R:Port_R)
      TcpSyn                    ---------->
                                <----------          TcpSyn,Ack
      TcpAck                    ---------->
  2)  ---------------------  TLS Session  ---------------------
      ClientHello               ---------->
                                <----------         ServerHello
                                             [ChangeCipherSpec]
                                                       Finished
      [ChangeCipherSpec]        ---------->
      Finished
  3)  ---------------------- Stream Prefix --------------------
      "IKETCP"                  ---------->
  4)  <---------------------> IKE/ESP Flow <------------------>
      Length + ESP Frame        ---------->
    ]]></artwork>
    </figure>

<t><list style="numbers">
    <t>If a previous TCP connection was broken (for example, due
    to a TCP Reset), the client is responsible for re-initiating the TCP
    connection. The TCP Originator's address and port (IP_I and Port_I)
    may be different from the previous connection's address and port.</t>

    <t>In the ClientHello TLS message, the client SHOULD send the
    session&nbsp;ID it received in the previous TLS handshake if available.
    It is up to the server to perform either an abbreviated handshake or
    a full handshake based on the session ID match.</t>

    <t>After TCP and TLS are complete, the client sends the stream prefix
    for TCP&nbhy;encapsulated IKE traffic (<xref target="prefix_format"/>).</t>

    <t>The IKE and ESP packet flow can resume. If MOBIKE is being used,
    the Initiator SHOULD send an UPDATE_SA_ADDRESSES message.</t>
</list></t>

    </section>


      <section title="Using MOBIKE between UDP and TCP Encapsulation">
            <figure align="center" anchor="ike_mobike_example">
                <artwork align="left"><![CDATA[
                  Client                              Server
                ----------                          ----------
      (IP_I1:UDP500 -> IP_R:UDP500)
  1)  ----------------- IKE_SA_INIT Exchange -----------------
      (IP_I1:UDP4500 -> IP_R:UDP4500)
      Non-ESP Marker           ----------->
      Initial IKE_AUTH
      HDR, SK { IDi, CERT, AUTH,
      CP(CFG_REQUEST),
      SAi2, TSi, TSr,
      N(MOBIKE_SUPPORTED) }
                               <-----------      Non-ESP Marker
                                               Initial IKE_AUTH
                                     HDR, SK { IDr, CERT, AUTH,
                                           EAP, SAr2, TSi, TSr,
                                          N(MOBIKE_SUPPORTED) }
      <------------------ IKE SA Establishment --------------->

  2)  ------------ MOBIKE Attempt on New Network --------------
      (IP_I2:UDP4500 -> IP_R:UDP4500)
      Non-ESP Marker           ----------->
      INFORMATIONAL
      HDR, SK { N(UPDATE_SA_ADDRESSES),
      N(NAT_DETECTION_SOURCE_IP),
      N(NAT_DETECTION_DESTINATION_IP) }


  3)  --------------------  TCP Connection  -------------------
      (IP_I2:Port_I -> IP_R:Port_R)
      TcpSyn                   ----------->
                               <-----------          TcpSyn,Ack
      TcpAck                   ----------->

  4)  ---------------------  TLS Session  ---------------------
      ClientHello              ----------->
                                                    ServerHello
                                                   Certificate*
                                             ServerKeyExchange*
                               <-----------     ServerHelloDone
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                 ----------->
                                             [ChangeCipherSpec]
                               <-----------            Finished
  5)  ---------------------- Stream Prefix --------------------
      "IKETCP"                  ---------->

  6)  ----------------------- IKE Session ---------------------
      Length + Non-ESP Marker  ----------->
      INFORMATIONAL (Same as step 2)
      HDR, SK { N(UPDATE_SA_ADDRESSES),
      N(NAT_DETECTION_SOURCE_IP),
      N(NAT_DETECTION_DESTINATION_IP) }

                               <------- Length + Non-ESP Marker
                          HDR, SK { N(NAT_DETECTION_SOURCE_IP),
                              N(NAT_DETECTION_DESTINATION_IP) }
  7)  <----------------- IKE/ESP Data Flow ------------------->
                ]]></artwork>
    </figure>


<t><list style="numbers">
    <t>During the IKE_SA_INIT exchange, the client and server
    exchange MOBIKE_SUPPORTED notify payloads to indicate support for
    MOBIKE.</t>

    <t>The client changes its point of attachment to the network and
    receives a new IP address. The client attempts to re-establish the
    IKE session using the UPDATE_SA_ADDRESSES notify payload,
    but the server does not respond because the network blocks UDP
    traffic.</t>

    <t>The client brings up a TCP connection to the server in
    order to use TCP encapsulation.</t>

    <t>The client initiates a TLS handshake with the server.</t>

    <t>The client sends the stream prefix for
    TCP&nbhy;encapsulated IKE traffic (<xref target="prefix_format"/>).</t>

    <t>The client sends the UPDATE_SA_ADDRESSES notify payload
    on the TCP&nbhy;encapsulated connection. Note that this IKE message is
    the same as the one sent over UDP in step 2; it should have the same
    message ID and contents.</t>

    <t>The IKE and ESP packet flow can resume.</t>
</list></t>
      </section>


    </section>

<section anchor="acknowledgments" title="Acknowledgments" numbered="no">
    <t>The authors would like to acknowledge the input and advice of Stuart
    Cheshire, Delziel Fernandes, Yoav Nir, Christoph Paasch, Yaron Sheffer,
    David Schinazi, Graham Bartlett, Byju Pularikkal, March Wu, Kingwel Xie,
    Valery Smyslov, Jun Hu, and Tero Kivinen. Special thanks to Eric Kinnear
    for his implementation work.</t>
</section>

  </back>

</rfc>
