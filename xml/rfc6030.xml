<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
	<!ENTITY rfc2119 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
    <!ENTITY I-D.housley-aes-key-wrap-with-pad PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.housley-aes-key-wrap-with-pad.xml'>
]>

<!--[rfced] Please note that after you have approved the document,
post-xml2rfc changes will be made to update the header and
boilerplate as described in RFC 5741.
-->

<rfc number="6030" category="std" ipr="trust200902" >
	<?rfc toc="yes" ?>
	<?rfc symrefs="yes" ?>
	<?rfc sortrefs="yes"?>
        <?rfc rfcedstyle="yes" ?>
        <?rfc subcompact="no" ?>
	<front>
		<title>Portable Symmetric Key Container (PSKC)</title>
		<author initials="P." surname="Hoyer" fullname="Philip Hoyer">
			<organization abbrev="ActivIdentity"> ActivIdentity, Inc. </organization>
			<address>
				<postal>
					<street>117 Waterloo Road</street>
					<city>London</city>
					<region>SE1</region>
					<code>8UL</code>
					<country>UK</country>
				</postal>
				<phone>+44 (0) 20 7960 0220</phone>
				<email>phoyer@actividentity.com</email>
			</address>
		</author>
		<author initials="M." surname="Pei" fullname="Mingliang Pei">
			<organization abbrev="VeriSign"> VeriSign, Inc. </organization>
			<address>
				<postal>
					<street>487 E. Middlefield Road</street>
					<city>Mountain View</city>
					<region>CA</region>
					<code>94043</code>
					<country>USA</country>
				</postal>
				<phone>+1 650 426 5173</phone>
				<email>mpei@verisign.com</email>
			</address>
		</author>
		<author initials="S." surname="Machani" fullname="Salah Machani">
			<organization abbrev="Diversinet"> Diversinet, Inc. </organization>
			<address>
				<postal>
					<street>2225 Sheppard Avenue East</street>
					<street>Suite 1801</street>
					<city>Toronto</city>
					<region>Ontario</region>
					<code>M2J 5C2</code>
					<country>Canada</country>
				</postal>
				<phone>+1 416 756 2324 Ext. 321</phone>
				<email>smachani@diversinet.com</email>
			</address>
		</author>
		<date month="October" year="2010"/>
		<workgroup>keyprov</workgroup>

<!-- [rfced] Please insert any keywords (beyond those that appear in
the title) for use on http://www.rfc-editor.org/rfcsearch.html. -->

<keyword>example</keyword>

		<abstract>
			<t>This document specifies a symmetric key format for the transport and provisioning of
				symmetric keys to different types of crypto modules. For example, One-Time Password (OTP) shared secrets or symmetric
				cryptographic keys to strong authentication devices. A standard key transport format enables enterprises to
				deploy best-of-breed solutions combining components from different vendors into the
				same infrastructure. </t>
		</abstract>
	</front>
	<middle>
		<section title="Introduction">
			<t>With the increasing use of symmetric-key-based systems, such as encryption of data at rest or systems used for strong authentication, such as those
				based on One-Time Password (OTP) and Challenge/Response (CR) mechanisms, there is a need for
				vendor interoperability and a standard format for importing and exporting
				(provisioning) symmetric keys. For instance, traditionally, vendors of authentication servers and
				service providers have used proprietary formats for importing and exporting these
				keys into their systems, thus making it hard to use tokens from two different vendors.</t>
			<t>This document defines a standardized XML-based key container, called Portable
				Symmetric Key Container (PSKC), for
transporting symmetric keys and key-related metadata. The document also
specifies the information elements that are required when the symmetric key is
utilized for specific purposes, such as the initial counter in the HMAC-Based
One-Time Password (HOTP)  <xref target="HOTP"/> algorithm. It also creates an IANA registry for algorithm profiles where algorithms, their metadata and PSKC transmission profile can be recorded for a centralized, standardized reference. </t>
				
				
				<section title="Key Words">
					<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
						NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
						described in <xref target="RFC2119"/>.</t>
				</section>				
				
				<section title="Version Support" anchor="VersionSupport">
					<t>There is a provision made in the syntax for an explicit version
   number.  Only version "1.0" is currently specified.</t>
				   <t>   The numbering scheme for PSKC versions is
   "&lt;major&gt;.&lt;minor&gt;". The major and minor numbers MUST be treated as
   separate integers and each number MAY be incremented higher than a
   single digit. Thus, "PSKC 2.4" would be a lower version than "PSKC
   2.13", which in turn would be lower than "PSKC 12.3".  Leading zeros
   (e.g., "PSKC 6.01") MUST be ignored by recipients and MUST NOT be
   sent.
				   </t>
				   <t>The major version number should be incremented only if the message 
   format (e.g., element structure)  has changed so dramatically that
   an older version implementation would not be able to interoperate with a
   newer version.  The minor version number indicates new capabilities,
   and it MUST be ignored by an entity with a smaller minor version number
   but used for informational purposes by the entity with the larger
   minor version number.
				   </t>
				</section>				

				<section title="Namespace Identifiers">
					<t>This document uses Uniform Resource Identifiers (URIs) <xref target="RFC3986"/> to identify
   resources, algorithms, and semantics.</t>

				<section title="Defined Identifiers">
					<t>   The XML namespace <xref target="XMLNS" /> URI for Version 1.0 of PSKC is:</t>
					<t>"urn:ietf:params:xml:ns:keyprov:pskc"</t>
				   <t> References to qualified elements in the PSKC schema defined in this specification and used in the example use the prefix "pskc" (defined as xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc"). It is RECOMMENDED to use this namespace in implementations.</t>
				</section>				   
				
				<section title="Referenced Identifiers">
					<t>The PSKC syntax presented in this document relies on
   algorithm identifiers and elements defined in the XML Signature <xref target="XMLDSIG"/>
   namespace:</t>
					<t>xmlns:ds="http://www.w3.org/2000/09/xmldsig#"</t>
				   <t> References to the XML Signature namespace
   are represented by the prefix "ds".</t>
   
					<t>PSKC also relies on
   algorithm identifiers and elements defined in the XML Encryption <xref target="XMLENC"/>
   namespace:</t>
					<t>xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"</t>
				   <t> References to the XML Encryption namespace
   are represented by the prefix "xenc".</t>
   
					<t>When protecting keys in transport with passphrase-based keys, PSKC also relies on
   the derived key element defined in the XML Encryption Version 1.1 <xref target="XMLENC11"/>
   namespace:</t>
					<t>xmlns:xenc11="http://www.w3.org/2009/xmlenc11#"</t>
				   <t> References to the XML Encryption Version 1.1 namespace
   are represented by the prefix "xenc11".</t>
					<t>When protecting keys in transport with passphrase-based keys, PSKC also relies on
   algorithm identifiers and elements defined in the PKCS #5 <xref target="PKCS5"/>
   namespace:</t>
					<t>xmlns:pkcs5= "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#"</t>
				   <t> References to the PKCS #5 namespace
   are represented by the prefix "pkcs5".</t>
   
				</section>				   
	
				</section>				
				
		</section>

		<!-- ****************************************************************************************** -->

		<section title="Terminology">

			<t>NOTE: In subsequent sections of the document, we highlight **mandatory** XML elements
				and attributes. Optional elements and attributes are not explicitly indicated, i.e.,
				if it does not say mandatory, it is optional. </t>
		</section>

		<!-- ****************************************************************************************** -->


		<section title="Portable Key Container Entities Overview and Relationships">
			<t>The portable key container is based on an XML schema definition and contains the
				following main conceptual entities: <list style="numbers">
					<t>KeyContainer entity - representing the container that carries a number of KeyPackage entities. A valid container MUST carry at least one KeyPackage entity.</t>

					<t>KeyPackage entity - representing the package of at most one key and its related provisioning endpoint or current usage endpoint, such as a physical or virtual device and a specific CryptoModule.</t>
					<t>DeviceInfo entity - representing the information about the device and
						criteria to identify uniquely the device.</t>
					<t>CryptoModuleInfo entity - representing the information about the CryptoModule where the keys reside or to which they are provisioned.</t>
					<t>Key entity - representing the key transported or provisioned.</t>
					<t>Data entity - representing a list of metadata related to the key, where the element name is the name of the metadata and its associated value is either  in encrypted  (for example, for &lt;Data&gt; element &lt;Secret&gt;) or plaintext (for example, the &lt;Data&gt; element &lt;Counter&gt;) form.

</t>
				</list>
			</t>
			<t><xref target="er"/> shows the high-level structure of the PSKC data elements. <figure
					anchor="er" title="PSKC Data Elements Relationship Diagram">
					<artwork>
						<![CDATA[  
   -----------------    
   | KeyContainer  |   
   |---------------|
   | EncryptionKey |
   | Signature	   |
   | ...           |
   -----------------	   
           |                     
           |                      
          /|\ 1..n                 
   ----------------        ----------------
   | KeyPackage   |    0..1| DeviceInfo   |
   |--------------|--------|--------------|
   |              |--      | SerialNumber |
   ----------------  |     | Manufacturer |
           |         |     | ....         |
           |         |     ----------------
          /|\ 0..1   |              
   ----------------  |     --------------------  
   | Key          |  | 0..1| CryptoModuleInfo |
   |--------------|   -----|------------------|
   | Id           |        | Id               |
   | Algorithm    |        |....              |
   | UserId       |        --------------------
   | Policy       |
   | ....         |
   ----------------
           |
           |            
          /|\ 0..n     
       --------------------------------------- -  -
       |                     |              |
   ------------------  ----------------  -------- - -
   | Data:Secret    |  | Data:Counter |  | Data:other
   |----------------|  |--------------|  |-- - -
   | EncryptedValue |  | PlainValue   |
   | ValueMAC       |  ----------------
   ------------------ 

]]>
					</artwork>
				</figure> The following sections describe in detail all the entities and related XML
				schema elements and attributes.</t>
		</section>

		<section anchor="basics" title="&lt;KeyContainer&gt; Element: The Basics">
			<t>In its most basic form, a PSKC document uses the top-level element
				&lt;KeyContainer&gt; and a single &lt;KeyPackage&gt; element to
				carry key information.</t>
			<t>The following example shows a simple PSKC document. We will use it to describe
				the structure of the &lt;KeyContainer&gt; element and its child elements.
					<figure anchor="example-simple" title="Basic PSKC Key Container Example">
					<artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<KeyContainer Version="1.0" 
    Id="exampleID1" 
    xmlns="urn:ietf:params:xml:ns:keyprov:pskc">
    <KeyPackage>
        <Key Id="12345678" 
            Algorithm="urn:ietf:params:xml:ns:keyprov:pskc:hotp">
            <Issuer>Issuer-A</Issuer>
            <Data>
                <Secret>
                    <PlainValue>MTIzNA==
                    </PlainValue>
                </Secret>
            </Data>
        </Key>
    </KeyPackage>
</KeyContainer>
						]]></artwork>
				</figure>
			</t>

			<t>The attributes of the &lt;KeyContainer&gt; element have the following
				semantics: <list style="hanging">
					<t hangText="'Version':">The 'Version' attribute is used to identify the version
						of the PSKC schema version. This specification defines the initial version
						("1.0") of the PSKC schema. This attribute MUST be included.</t>
					<t hangText="'Id':">The 'Id' attribute carries a unique identifier for the
						container. As such, it helps to identify a specific key container in cases in which multiple containers are embedded in larger XML documents. </t>
				</list>
			</t>

			<section anchor="KeyElement"
				title="&lt;Key&gt;: Embedding Keying Material and Key-Related Information">
				<t>The following attributes of the &lt;Key&gt; element MUST be included at a
					minimum: <list style="hanging">
						<t hangText="'Id':">This attribute carries a unique identifier
							for the symmetric key in the context of key provisioning exchanges between two parties. This means that if PSKC is used in multiple interactions between a sending and receiving party, using different containers referencing the same keys, the 'Id' attribute of &lt;Key&gt; MUST use the same value (e.g., after initial provisioning, if a system wants to update key metadata values in the other system, the value of the 'Id' attribute of the &lt;Key&gt; where the metadata is to be updated MUST be the same of the original 'Id' attribute value provisioned).
The identifier is defined as a string of
							alphanumeric characters. </t>
						<t hangText="'Algorithm':">This attribute contains a unique identifier
							for the PSKC algorithm profile. This profile associates specific
							semantics to the elements and attributes contained in the
							&lt;Key&gt; element. This document describes profiles for open standards algorithms in <xref target="profiles"/>.  Additional profiles are defined in the following informative document: <xref target="PSKC-ALGORITHM-PROFILES"/>.</t>
					</list>
				</t>

				<t>The &lt;Key&gt; element has a number of optional child elements. An
					initial set is described below: <list style="hanging">
						<t hangText="&lt;Issuer&gt;:">This element represents the name of
							the party that issued the key. For example, a bank "Foobar Bank, Inc."
							issuing hardware tokens to their retail banking users may set this
							element to 'Foobar Bank, Inc.'.</t>
						<t hangText="&lt;FriendlyName&gt;:"> A human-readable name for the
							secret key for easier reference. This element serves informational
							purposes only. This
element is a language-dependent string; hence, it SHOULD have an attribute
xml:lang="xx" where xx is the language identifier as specified in <xref
target="RFC5646"/>. 

<!-- [rfced] Please note that since RFC 4646 has been obsoleted by RFC 5646, 
this citation was updated accordingly. Please let us know if you prefer 
to intentionally cite the obsoleted RFC.
-->

If no xml:lang attribute is present, implementations MUST assume the language to be English as defined by setting the attribute value to 'en' (e.g., xml:lang="en").</t>
						<t hangText="&lt;AlgorithmParameters&gt;:"> This element carries parameters that influence the result of the algorithmic computation, for example, response truncation and format in OTP and CR algorithms. A more detailed
							discussion of the element can be found in <xref target="AlgorithmParametersElement"/>. </t>
						<t hangText="&lt;Data&gt;:">This element carries data about and
							related to the key. The following child elements are defined for the
							&lt;Data&gt; element: <vspace blankLines="1"/>
							<list style="hanging">
								<t hangText="&lt;Secret&gt;:">This element carries the value
									of the key itself in a binary representation.  Please see <xref target="keyEncoding"/> for more details on Key Value Encoding.</t>
								<t hangText="&lt;Counter&gt;:">This element contains the
									event counter for event-based OTP algorithms.</t>
								<t hangText="&lt;Time&gt;:">This element contains the time
									for time-based OTP algorithms. (If time intervals are used, this
									element carries the number of time intervals passed from a
									specific start point, normally it is algorithm dependent).</t>
								<t hangText="&lt;TimeInterval&gt;:">This element carries the
									time interval value for time-based OTP algorithms in seconds (a typical value for this would be 30, indicating a time interval of 30 seconds).</t>
								<t hangText="&lt;TimeDrift&gt;:">This element contains the
									device clock drift value for time-based OTP algorithms. The
									integer value (positive or negative drift) that indicates the number of time intervals that a validation server has established the device clock drifted after the last successful authentication. So, for example, if the last successful authentication established a device time value of 8 intervals from a specific start date but the validation server determines the time value at 9 intervals, the server SHOULD record the drift as -1.</t>
							</list> All the elements listed above (and those defined in the
							future) obey a simple structure in that they MUST support child elements
							to convey the data value in either plaintext or encrypted format: <list
								style="hanging">
								<t hangText="Plaintext:">The &lt;PlainValue> element carries
									a plaintext value that is typed, for example, to xs:integer.</t>
								<t hangText="Encrypted:">The &lt;EncryptedValue> element
									carries an encrypted value.</t>
								<t hangText="ValueMAC:">The &lt;ValueMAC> element
									is populated with a Message Authentication Code (MAC) generated from the encrypted
							value in case the encryption algorithm does not support integrity
							checks. The example shown in <xref
								target="example-simple"/> illustrates the usage of the
							&lt;Data&gt; element with two child elements, namely
							&lt;Secret&gt; and &lt;Counter&gt;. Both elements carry
							a plaintext value within the &lt;PlainValue> child element. </t>
							</list>  </t>
					</list>
				</t>
			</section>
			
			<section title="Key Value Encoding" anchor="keyEncoding">
				<t>Two parties receiving the same key value OCTET STRING, resulting in decoding the xs:base64Binary, inside the &lt;PlainValue&gt; or &lt;EncryptedValue&gt; elements, must make use of the key in exactly the same way in order to interoperate.  To ensure that, it is necessary to define a correspondence between the OCTET STRING and the notation in the standard algorithm description that defines how the key is used. 
The next sections establish that correspondence for the AES algorithm <xref target="FIPS197"/> and the Triple Data Encryption Algorithm (TDEA or Triple DES) <xref target="SP800-67"/>. Unless otherwise specified for a specific algorithm, the OCTET STRING encoding MUST follow the AES Key Value Encoding.
				</t>
				<section title="AES Key Value Encoding">
				<t><xref target="FIPS197"/>, Section 5.2, titled "Key Expansion", uses the input key as an array of bytes indexed starting at 0.  The first octet of the OCTET STRING SHALL become the key byte in the AES, labeled index 0 in <xref target="FIPS197"/>; the succeeding octets of the OCTET STRING SHALL become key bytes in AES, in increasing index order.
				</t>
				<t>Proper parsing and key load of the contents of the OCTET STRING for AES SHALL be determined by using the following value for the &lt;PlainValue&gt; element (binaryBase64-encoded) to generate and match the key expansion test vectors in <xref target="FIPS197"/>, Appendix A, for AES
</t>
<t> Cipher Key: 2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c
				</t>
				<t>
					<figure>
					<artwork><![CDATA[
...
 <PlainValue>K34VFiiu0qar9xWICc9PPA==</PlainValue>
...
						]]></artwork>			
					 </figure>		
				</t>
				</section>
			<section title="Triple-DES Key Value Encoding">
				<t>A Triple-DES key consists of three keys for the cryptographic engine (Key1, Key2, and Key3) that are each 64 bits (56 key bits and 8 parity bits); the three keys are also collectively referred to as a key bundle <xref target="SP800-67"/>.  A key bundle may employ either two or three independent keys.  When only two independent keys are employed (called  two-key Triple DES), the same value is used for Key1 and Key3.
				</t>
				<t>Each key in a Triple-DES key bundle is expanded into a key schedule according to a procedure defined in  <xref target="SP800-67"/>, Appendix A.  That procedure numbers the bits in the key from 1 to 64, with number 1  being the leftmost, or most significant bit (MSB).  The first octet of the OCTET STRING SHALL be bits 1 through 8 of Key1 with bit 1 being the MSB. The second octet of the OCTET STRING SHALL be bits 9 through 16 of Key1, and so forth, so that the trailing octet of the OCTET STRING SHALL be bits 57 through 64 of Key3 (or Key2 for two-key Triple DES).
				</t>
				<t>Proper parsing and key load of the contents of the OCTET STRING for Triple DES  SHALL be determined by using the following &lt;PlainValue&gt; element (binaryBase64-encoded)  to generate and match the key expansion test vectors in <xref target="SP800-67"/>, Appendix B, for the key bundle:
</t>
<t>Key1 = 0123456789ABCDEF</t>
<t>Key2 = 23456789ABCDEF01</t>
<t>Key3 = 456789ABCDEF0123</t>

				<t>
					<figure>
						
					
					<artwork><![CDATA[
...
 <PlainValue>ASNFZ4mrze8jRWeJq83vAUVniavN7wEj</PlainValue>
...
						]]></artwork>				
					</figure>						
				</t>
				</section>				
				
			</section>

			<section title="Transmission of Supplementary Information">
			
				<t>A PSKC document can contain a number of additional information regarding device
					identification, cryptographic module identification, user identification, and parameters for usage with
					OTP and CR algorithms. The following example, see <xref target="example-suppl"
					/>, is used as a reference for the subsequent sub-sections. <figure
						anchor="example-suppl"
						title="PSKC Key Container Example with Supplementary Data">
						<artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<KeyContainer Version="1.0" 
    Id="exampleID1" 
    xmlns="urn:ietf:params:xml:ns:keyprov:pskc">
    <KeyPackage>
        <DeviceInfo>
            <Manufacturer>Manufacturer</Manufacturer>
            <SerialNo>987654321</SerialNo>
            <UserId>DC=example-bank,DC=net</UserId>
        </DeviceInfo>
        <CryptoModuleInfo>
            <Id>CM_ID_001</Id>
        </CryptoModuleInfo>
        <Key Id="12345678" 
            Algorithm="urn:ietf:params:xml:ns:keyprov:pskc:hotp">
            <Issuer>Issuer</Issuer>
            <AlgorithmParameters>
                <ResponseFormat Length="8" Encoding="DECIMAL"/>
            </AlgorithmParameters>
            <Data>
                <Secret>
                    <PlainValue>MTIzNDU2Nzg5MDEyMzQ1Njc4OTA=
                    </PlainValue>
                </Secret>
                <Counter>
                    <PlainValue>0</PlainValue>
                </Counter>
            </Data>
            <UserId>UID=jsmith,DC=example-bank,DC=net</UserId>
        </Key>
    </KeyPackage>
</KeyContainer>						
]]></artwork>
					</figure>
				</t>

				<section anchor="DeviceInfoElement"
					title="&lt;DeviceInfo&gt; Element: Unique Device Identification">
					<t>The &lt;DeviceInfo&gt; element uniquely identifies the device to which the
						&lt;KeyPackage&gt; is provisioned. Since devices can come in different
						form factors, such as hardware tokens, smart-cards, soft tokens in a mobile
						phone, or as a PC, this element allows different child element combinations to be used.
						When combined, the values of the child elements MUST uniquely identify the device. For example,
						for hardware tokens, the combination of &lt;SerialNo&gt; and
						&lt;Manufacturer&gt; elements uniquely identifies a device, but the
						&lt;SerialNo&gt; element alone is insufficient since two different
						token manufacturers might issue devices with the same serial number (similar
						to the Issuer Distinguished Name and serial number of a certificate). </t>

					<t>The &lt;DeviceInfo&gt; element has the following child elements:
							<list style="hanging">
							<t hangText="&lt;Manufacturer&gt;:">This element indicates the
								manufacturer of the device. Values for the &lt;Manufacturer&gt; element MUST be taken from either <xref target="OATHMAN"/>  prefixes (i.e., the left column) or from the IANA Private Enterprise Number Registry <xref target="IANAPENREG"/>, using the Organization value. When the value is taken from  <xref target="OATHMAN"/>, "oath." MUST be prepended to the value (e.g., "oath.&lt;prefix value from <xref target="OATHMAN"/>&gt;"). When the value is taken from <xref target="IANAPENREG"/>, "iana." MUST be prepended to the value (e.g., "iana.&lt;Organization value from <xref target="IANAPENREG"/>&gt;").</t>
							<t hangText="&lt;SerialNo&gt;:">This element contains the serial
								number of the device.</t>
							<t hangText="&lt;Model&gt;:">This element describes the model of
								the device (e.g., one-button-HOTP-token-V1).</t>
							<t hangText="&lt;IssueNo&gt;:">This element contains the issue
								number in case there are devices with the same serial number so that they can be
								distinguished by different issue numbers.</t>
							<t hangText="&lt;DeviceBinding&gt;:">This element allows a provisioning server to ensure that the key is
    going to be loaded into the device for which the key provisioning
    request was approved. The device is bound to the request using a device
    identifier, e.g., an International Mobile Equipment Identity (IMEI) for the phone, or an identifier for a class of
    identifiers, e.g., those for which the keys are protected by a  Trusted Platform Module (TPM).
</t>
							<t hangText="&lt;StartDate&gt; and &lt;ExpiryDate&gt;:"
								>These two elements indicate the start and end date of a device
								(such as the one on a payment card, used when issue numbers are not
								printed on cards). The date MUST be expressed as a dateTime value in "canonical representation" <xref target="W3C.REC-xmlschema-2-20041028"/>. Implementations SHOULD NOT rely on time
								resolution finer than milliseconds and MUST NOT generate time
								instants that specify leap seconds. Keys that reside on the device SHOULD only be used when the current date is after the &lt;StartDate&gt; and before the &lt;ExpiryDate&gt;. Note that usage enforcement of the keys with respect to the dates MAY only happen on the validation server, as some devices such as smart cards do not have an internal clock. Systems thus SHOULD NOT rely upon the device to enforce key usage date restrictions.</t>
						</list> Depending on the device type, certain child elements of the
						&lt;DeviceInfo&gt; element MUST be included in order to
						uniquely identify a device. This document does not enumerate the different
						device types and therefore does not list the elements that are mandatory for
						each type of device. </t>
				</section>


				<section anchor="CryptoModuleInfoElement"
					title="&lt;CryptoModuleInfo&gt; Element: CryptoModule Identification">
					<t>The &lt;CryptoModuleInfo&gt; element identifies the cryptographic module to which the
       symmetric keys are or have been provisioned. This allows the identification of the specific cases where a device MAY contain more than one crypto module (e.g., a PC hosting a TPM and a connected token).</t>
    				<t>The &lt;CryptoModuleInfo&gt; element has a single child element that MUST be included: <list style="hanging">
						<t hangText="&lt;Id&gt;:"> This element carries a unique identifier for the
						CryptoModule and is implementation specific. As such, it helps to identify a specific CryptoModule to which the key is being or was provisioned.</t>
							</list> 
					</t>   
				</section>

				<section anchor="UserIdElement"
					title="&lt;UserId&gt; Element: User Identification">
					<t>The &lt;UserId&gt; element identifies the user of a distinguished
						name, as defined in <xref target="RFC4514"/>, for example,
						UID=jsmith,DC=example,DC=net.</t>

					<t>Although the syntax of the user identifier is defined, there are no semantics
						associated with this element, i.e., there are no checks enforcing that only
						a specific user can use this key. As such, this element is for informational
						purposes only.</t>

					<t>This element may appear in two places, namely as a child element of the
						&lt;Key&gt; element, where it indicates the user with whom the key is
						associated, and as a child element of the &lt;DeviceInfo&gt;
						element, where it indicates the user with whom the device is associated. </t>

				</section>

				<section anchor="AlgorithmParametersElement"
					title="&lt;AlgorithmParameters&gt; Element: Supplementary Information for OTP and CR Algorithms">
					<t>The &lt;AlgorithmParameters&gt; element is a child element of the
						&lt;Key&gt; element, and this document defines three child elements: &lt;Suite&gt;,
						&lt;ChallengeFormat&gt;, and &lt;ResponseFormat&gt;.</t>
					<t>
						<list style="hanging">
							<t hangText="&lt;Suite&gt;:">
								<vspace blankLines="1"/> The optional &lt;Suite&gt; element
								defines additional characteristics of the algorithm used, which are algorithm specific. For example, in an HMAC-based (Hashed MAC) OTP algorithm, it could designate the strength of the hash algorithm used (SHA1, SHA256, etc.). Please refer to the algorithm profile section, <xref target="profiles"/>, for the exact semantics of the value for each algorithm profile. 
							</t>						 
							<t hangText="&lt;ChallengeFormat&gt;:"><vspace blankLines="1"/>
								The &lt;ChallengeFormat&gt; element defines the
								characteristics of the challenge in a CR usage scenario whereby the
								following attributes are defined: <list style="hanging">
									<t hangText="'Encoding':"> This attribute, which MUST be included, defines the
										encoding of the challenge accepted by the device and MUST be
										one of the following values: <list style="hanging">
											<t hangText="DECIMAL:"> Only numerical digits</t>
											<t hangText="HEXADECIMAL:">Hexadecimal response</t>
											<t hangText="ALPHANUMERIC:">All letters and numbers (case
												sensitive)</t>
											<t hangText="BASE64:">Base-64 encoded, as defined in Section 4 of <xref target="RFC4648"/></t>
											<t hangText="BINARY:">Binary data</t>
										</list>
									</t>
									<t hangText="'CheckDigit':"> This attribute indicates
										whether a device needs to check the appended Luhn check
										digit, as defined in <xref target="ISOIEC7812"/>, contained in a
										challenge. This is only valid if the 'Encoding'
										attribute is set to 'DECIMAL'. A value of TRUE indicates that the
										device will check the appended Luhn check digit in a
										provided challenge. A value of FALSE indicates that the device
										will not check the appended Luhn check digit in the challenge.</t>
									<t hangText="'Min':"> This attribute defines the
										minimum size of the challenge accepted by the device for CR
										mode and MUST be included. If the 'Encoding' attribute is set to 'DECIMAL',
										'HEXADECIMAL', or 'ALPHANUMERIC', this value indicates the
										minimum number of digits/characters. If the 'Encoding'
										attribute is set to 'BASE64' or 'BINARY', this value indicates the
										minimum number of bytes of the unencoded value.</t>
									<t hangText="'Max':">This attribute defines the
										maximum size of the challenge accepted by the device for CR
										mode and MUST be included. If the 'Encoding' attribute is set to 'DECIMAL',
										'HEXADECIMAL', or 'ALPHANUMERIC', this value indicates the
										maximum number of digits/characters. If the 'Encoding'
										attribute is set to 'BASE64' or 'BINARY', this value indicates the
										maximum number of bytes of the unencoded value.</t>
								</list>
							</t>
							<t hangText="&lt;ResponseFormat&gt;:">
								<vspace blankLines="1"/> The &lt;ResponseFormat&gt; element
								defines the characteristics of the result of a computation and
								defines the format of the OTP or the response to a challenge. For
								cases in which the key is a PIN value, this element contains the format
								of the PIN itself (e.g., DECIMAL, length 4 for a 4-digit PIN). The
								following attributes are defined: <list style="hanging">
									<t hangText="'Encoding':">This attribute defines the
										encoding of the response generated by the device, it MUST be included and MUST be
										one of the following values: DECIMAL, HEXADECIMAL,
										ALPHANUMERIC, BASE64, or BINARY.</t>
									<t hangText="'CheckDigit':">This attribute indicates
										whether the device needs to append a Luhn check digit, as
										defined in <xref target="ISOIEC7812"/>, to the response. This is
										only valid if the 'Encoding' attribute is set to 'DECIMAL'. If the
										value is TRUE, then the device will append a Luhn check digit
										to the response. If the value is FALSE, then the device will
										not append a Luhn check digit to the response.</t>
									<t hangText="'Length':">This attribute defines the
										length of the response generated by the device and MUST be included. If the
										'Encoding' attribute is set to 'DECIMAL', 'HEXADECIMAL', or
										ALPHANUMERIC, this value indicates the number of
										digits/characters. If the 'Encoding' attribute is set to 'BASE64'
										or 'BINARY', this value indicates the number of bytes of the
										unencoded value.</t>
								</list>
							</t>
						</list>
					</t>
				</section>
			</section>
			<section title="Transmission of Key Derivation Values">
				<t>&lt;KeyProfileId> element, which is a child element of the
					&lt;Key&gt; element, carries a unique identifier used between the
					sending and receiving parties to establish a set of key attribute values that are
					not transmitted within the container but are agreed upon between the two parties out of
					band. This element will then represent the unique reference to a set of
					key attribute values. (For example, a smart card application personalization profile
					id related to specific attribute values present on a smart card application that have influence
					when computing a response).</t>
				<t>For example, in the case of MasterCard's Chip Authentication Program 
						<xref target="CAP"/>, the sending and the receiving party would agree that KeyProfileId='1' represents a certain set of values (e.g., Internet Authentication Flag (IAF) set to a specific value). 

During transmission of the &lt;KeyContainer>, these values would not be transmitted as key
					attributes but would only be referred to via the &lt;KeyProfileId&gt; element set
					to the specific agreed-upon profile (in this case '1'). The receiving party
					can then associate all relevant key attributes contained in
					the profile that was agreed upon out of band with the imported keys. Often, this methodology is
					used between a manufacturing service, run by company A, and the validation service, run by company B, to avoid repeated transmission
					of the same set of key attribute values.</t>
				<t>The &lt;KeyReference> element contains a reference to an external key to be
used with a key derivation scheme. In this case, the parent &lt;Key> element
will not contain the &lt;Secret> subelement of &lt;Data>, in which the key
value
(secret) is transported; only the reference to the external master
key is transported (e.g., a PKCS #11 key label).
</t>
				<t>
					<figure anchor="example-key-derivation-values"
						title="Example of a PSKC Document Transmitting an HOTP Key via Key Derivation Values">
						<artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<KeyContainer Version="1.0" Id="exampleID1" 
     xmlns="urn:ietf:params:xml:ns:keyprov:pskc">
    <KeyPackage>
        <DeviceInfo>
            <Manufacturer>Manufacturer</Manufacturer>
            <SerialNo>987654321</SerialNo>
        </DeviceInfo>
        <CryptoModuleInfo>
            <Id>CM_ID_001</Id>
        </CryptoModuleInfo>
        <Key Id="12345678" 
         Algorithm="urn:ietf:params:xml:ns:keyprov:pskc:hotp">
            <Issuer>Issuer</Issuer>
            <AlgorithmParameters>
                <ResponseFormat Length="8" Encoding="DECIMAL"/>
            </AlgorithmParameters>
            <KeyProfileId>keyProfile1</KeyProfileId>
            <KeyReference>MasterKeyLabel
            </KeyReference>
            <Data>
                <Counter>
                    <PlainValue>0</PlainValue>
                </Counter>
            </Data>
            <Policy>
                <KeyUsage>OTP</KeyUsage>
            </Policy>
        </Key>
    </KeyPackage>
</KeyContainer>
							]]></artwork>

					</figure> The key value will be derived using the value of the
					&lt;SerialNo&gt; element, values agreed upon between the sending and the receiving parties and identified by the &lt;KeyProfile&gt; 'keyProfile1', and an externally agreed-upon key referenced by the label
					'MasterKeyLabel'.
</t>
			</section>
		
		</section>

		<!-- ****************************************************************************************** -->

		<section anchor="policy" title="Key Policy">
			<t>This section illustrates the functionality of the &lt;Policy&gt; element
				within PSKC, which allows a key usage and key PIN protection policy to be attached to a specific key and its related metadata. This
				element is a child element of the &lt;Key&gt; element.</t>

			<t>If the &lt;Policy&gt; element contains child elements or values within
				elements/attributes that are not understood by the recipient of the PSKC document,
				then the recipient MUST assume that key usage is not permitted. This statement
				ensures that the lack of understanding of certain extensions does not lead to
				unintended key usage. </t>
			<t>We will start our description with an example that expands the example shown in <xref
					target="example-suppl"/>. <figure anchor="example-pin"
					title="Non-Encrypted HOTP Secret Key Protected by PIN">
					<artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<KeyContainer 
    Version="1.0" Id="exampleID1" 
    xmlns="urn:ietf:params:xml:ns:keyprov:pskc">
    <KeyPackage>
        <DeviceInfo>
            <Manufacturer>Manufacturer</Manufacturer>
            <SerialNo>987654321</SerialNo>
        </DeviceInfo>
        <CryptoModuleInfo>
            <Id>CM_ID_001</Id>
        </CryptoModuleInfo>
        <Key Id="12345678" 
            Algorithm="urn:ietf:params:xml:ns:keyprov:pskc:hotp">
            <Issuer>Issuer</Issuer>
            <AlgorithmParameters>
                <ResponseFormat Length="8" Encoding="DECIMAL"/>
            </AlgorithmParameters>
            <Data>
                <Secret>
                    <PlainValue>MTIzNDU2Nzg5MDEyMzQ1Njc4OTA=
                    </PlainValue>
                </Secret>
                <Counter>
                    <PlainValue>0</PlainValue>
                </Counter>
            </Data>
            <Policy>
                <PINPolicy MinLength="4" MaxLength="4" 
                    PINKeyId="123456781" PINEncoding="DECIMAL" 
                    PINUsageMode="Local"/>
                <KeyUsage>OTP</KeyUsage>
            </Policy>
        </Key>
    </KeyPackage>
    <KeyPackage>
        <DeviceInfo>
            <Manufacturer>Manufacturer</Manufacturer>
            <SerialNo>987654321</SerialNo>
        </DeviceInfo>
        <CryptoModuleInfo>
            <Id>CM_ID_001</Id>
        </CryptoModuleInfo>
        <Key Id="123456781" 
            Algorithm="urn:ietf:params:xml:ns:keyprov:pskc:pin">
            <Issuer>Issuer</Issuer>
            <AlgorithmParameters>
                <ResponseFormat Length="4" Encoding="DECIMAL"/>
            </AlgorithmParameters>
            <Data>
                <Secret>
                    <PlainValue>MTIzNA==</PlainValue>
                </Secret>
            </Data>
        </Key>
    </KeyPackage>
</KeyContainer>
						]]></artwork>
				</figure>
			</t>
			<t>This document defines the following &lt;Policy&gt; child elements: <list style="hanging">
					<t hangText="&lt;StartDate&gt; and &lt;ExpiryDate&gt;:">These
						two elements denote the validity period of a key. It MUST be ensured that
						the key is only used between the start and the end date (inclusive). The date MUST be expressed as a dateTime value in "canonical representation" <xref target="W3C.REC-xmlschema-2-20041028"/>.
						Implementations SHOULD NOT rely on time resolution finer than milliseconds
						and MUST NOT generate time instants that specify leap seconds. When this
						element is absent, the current time is assumed as the start time.</t>
					<t hangText="&lt;NumberOfTransactions&gt;:">The value in this element
						indicates the maximum number of times a key carried within
						the PSKC document can be used by an application after having received it. When this element is omitted, there is
						no restriction regarding the number of times a key can be used. </t>
					<t hangText="&lt;KeyUsage&gt;:"> The &lt;KeyUsage&gt; element
						puts constraints on the intended usage of the key. The recipient of the PSKC
						document MUST enforce the key usage. Currently, the following tokens are
						registered by this document: <list style="hanging">
							<t hangText="OTP:"> The key MUST only be used for OTP generation.</t>
							<t hangText="CR:"> The key MUST only be used for Challenge/Response
								purposes.</t>

							<t hangText="Encrypt:">The key MUST only be used for data encryption
								purposes.</t>
							<t hangText="Integrity:">The key MUST only be used to generate a keyed
								message digest for data integrity or authentication purposes.</t>
							<t hangText="Verify:">The key MUST only be used to verify a keyed message
        digest for data integrity or authentication purposes (this is
        the opposite key usage of 'Integrity').</t>



							<t hangText="Unlock:"> The key MUST only be used for an inverse
								Challenge/Response in the case where a user has locked the device by
								entering a wrong PIN too many times (for devices with PIN-input
								capability).</t>
							<t hangText="Decrypt:">The key MUST only be used for data decryption
								purposes.</t>
							<t hangText="KeyWrap:">The key MUST only be used for key wrap purposes.</t>
							<t hangText="Unwrap:">The key MUST only be used for key unwrap purposes.</t>
							<t hangText="Derive:">The key MUST only be used with a key derivation
								function to derive a new key (see also Section 8.2.4 of <xref
									target="NIST800-57"/>).</t>
							<t hangText="Generate:">The key MUST only be used to generate a new key
								based on a random number and the previous value of the key (see also
								Section 8.1.5.2.1 of <xref target="NIST800-57"/>).</t>
						</list> The element MAY also be repeated to allow several key usages to be
						expressed. When this element is absent, no key usage constraint is
						assumed, i.e., the key MAY be utilized for every usage. </t>
					<t hangText="&lt;PINPolicy&gt;:"> The &lt;PINPolicy&gt; element
						allows policy about the PIN usage to be associated with the key. The
						following attributes are specified: <list style="hanging">
							<t hangText="'PINKeyId':">This attribute carries the unique 'Id' attribute vale of the &lt;Key&gt; element held within this &lt;KeyContainer&gt; that contains the value of the
								PIN that protects the key.

</t>
							<t hangText="'PINUsageMode':">This mandatory attribute indicates the way
								the PIN is used during the usage of the key. The following values
								are defined: <list style="hanging">
									<t hangText="Local:">This value indicates that the PIN is
										checked locally on the device before allowing the key to be
										used in executing the algorithm.</t>
									<t hangText="Prepend:">This value indicates that the PIN is
										prepended to the algorithm response; hence, it MUST be checked by
										the party validating the response.</t>
									<t hangText="Append:">This value indicates that the PIN is
										appended to the algorithm response; hence, it MUST be checked by
										the party validating the response.</t>
									<t hangText="Algorithmic:">This value indicates that the PIN is
										used as part of the algorithm computation.</t>
								</list>
							</t>
							<t hangText="'MaxFailedAttempts':"> This attribute indicates the maximum
								number of times the PIN may be entered wrongly before it MUST NOT be
								possible to use the key anymore (typical reasonable values are in the positive integer range of at least 2 and no more than 10).</t>
							<t hangText="'MinLength':"> This attribute indicates the minimum length
								of a PIN that can be set to protect the associated key. It MUST NOT be
								possible to set a PIN shorter than this value. If the 'PINFormat'
								attribute is set to 'DECIMAL', 'HEXADECIMAL', or 'ALPHANUMERIC', this value
								indicates the number of digits/characters. If the 'PINFormat'
								attribute is set to 'BASE64' or 'BINARY', this value indicates the number
								of bytes of the unencoded value.</t>
							<t hangText="'MaxLength':"> This attribute indicates the maximum length
								of a PIN that can be set to protect this key. It MUST NOT be
								possible to set a PIN longer than this value. If the 'PINFormat'
								attribute is set to 'DECIMAL', 'HEXADECIMAL', or 'ALPHANUMERIC', this value
								indicates the number of digits/characters. If the 'PINFormat'
								attribute is set to 'BASE64' or 'BINARY', this value indicates the number
								of bytes of the unencoded value. </t>
							<t hangText="'PINEncoding':">This attribute indicates the encoding of
								the PIN and MUST be one of the values: DECIMAL, HEXADECIMAL,
								ALPHANUMERIC, BASE64, or BINARY.</t>
						</list> If the 'PinUsageMode' attribute is set to 'Local', then the device
						MUST enforce the restriction indicated in the 'MaxFailedAttempts',
						'MinLength', 'MaxLength', and 'PINEncoding' attributes; otherwise, it MUST be
						enforced on the server side. </t>
				</list>
			</t>
			<section anchor="pinAlgorithm" title="PIN Algorithm Definition">
				<t>The PIN algorithm is defined as:
				</t>
				<t> boolean = comparePIN(K,P) 
				</t>
				<t>Where: <list style="empty">
					<t>'K' is the stored symmetric credential (PIN) in binary format.</t>
					<t>'P' is the proposed PIN to be compared in binary format.</t>
					 </list>
				</t>
				<t> The function comparePIN is a straight octet comparison of K and P. Such a comparison MUST yield a value of TRUE (credentials matched) when the octet length of K is the same as the octet length of P and all octets comprising K are the same as the octets comprising P.
				</t>
			</section>
		</section>

		<!-- ****************************************************************************************** -->

		<section anchor="EncryptionKeyDescription" title="Key Protection Methods">
			<t>With the functionality described in the previous sections, information related to keys
				had to be transmitted in cleartext. With the help of the
				&lt;EncryptionKey&gt; element, which is a child element of the
				&lt;KeyContainer&gt; element, it is possible to encrypt keys and associated
				information. The level of encryption is applied to the value of individual elements
				and the applied encryption algorithm MUST be the same for all encrypted elements. Keys are protected using the following methods: pre-shared keys, passphrase-based
				keys, and asymmetric keys. When encryption algorithms are used that make use of Initialization Vectors (IVs), for example, AES-128-CBC, a random IV value MUST be generated for each value to be encrypted and it MUST be prepended to the resulting encrypted value as specified in <xref target="XMLENC"/>.</t>
				

			<section anchor="SymmetricKeyProtectionDescription"
				title="Encryption Based on Pre-Shared Keys">
				<t><xref target="example-encr-psk"/> shows an example that illustrates the
					encryption of the content of the &lt;Secret&gt; element using
					AES-128-CBC and PKCS #5 Padding. The plaintext value of &lt;Secret&gt; is
					'3132333435363738393031323334353637383930'. The name of the pre-shared secret is
					"Pre-shared-key", as set in the &lt;KeyName&gt; element (which is a child
					element of the &lt;EncryptionKey&gt; element). The value of the encryption key used
					is '12345678901234567890123456789012'.</t>
					<t> The IV for the MAC key is '11223344556677889900112233445566', and the IV for the HOTP key is '000102030405060708090a0b0c0d0e0f'.
					</t>  
					<t>As AES-128-CBC does not provide
					integrity checks, a keyed MAC is applied to the encrypted value using a MAC key and a MAC
					algorithm as declared in the &lt;MACMethod&gt; element (in our example,
					"http://www.w3.org/2000/09/xmldsig#hmac-sha1" is used as the algorithm and the value of the MAC key is randomly generated, in our case '1122334455667788990011223344556677889900', and encrypted with the above encryption key). The result of the keyed-MAC computation is placed in the &lt;ValueMAC&gt; child element of &lt;Secret&gt;. </t>
				<t>
					<figure anchor="example-encr-psk"
						title="AES-128-CBC Encrypted Pre-Shared Secret Key with HMAC-SHA1">
						<artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<KeyContainer Version="1.0" 
    xmlns="urn:ietf:params:xml:ns:keyprov:pskc" 
    xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
    xmlns:xenc="http://www.w3.org/2001/04/xmlenc#">
    <EncryptionKey>
        <ds:KeyName>Pre-shared-key</ds:KeyName>
    </EncryptionKey>
    <MACMethod Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1">
        <MACKey>
            <xenc:EncryptionMethod 
            Algorithm="http://www.w3.org/2001/04/xmlenc#aes128-cbc"/>
            <xenc:CipherData>
                <xenc:CipherValue>
    ESIzRFVmd4iZABEiM0RVZgKn6WjLaTC1sbeBMSvIhRejN9vJa2BOlSaMrR7I5wSX
                </xenc:CipherValue>
            </xenc:CipherData>
        </MACKey>
    </MACMethod>
    <KeyPackage>
        <DeviceInfo>
            <Manufacturer>Manufacturer</Manufacturer>
            <SerialNo>987654321</SerialNo>
        </DeviceInfo>
        <CryptoModuleInfo>
            <Id>CM_ID_001</Id>
        </CryptoModuleInfo>
        <Key Id="12345678" 
            Algorithm="urn:ietf:params:xml:ns:keyprov:pskc:hotp">
            <Issuer>Issuer</Issuer>
            <AlgorithmParameters>
                <ResponseFormat Length="8" Encoding="DECIMAL"/>
            </AlgorithmParameters>
            <Data>
                <Secret>
                    <EncryptedValue>
                        <xenc:EncryptionMethod 
            Algorithm="http://www.w3.org/2001/04/xmlenc#aes128-cbc"/>
                        <xenc:CipherData>
                            <xenc:CipherValue>
    AAECAwQFBgcICQoLDA0OD+cIHItlB3Wra1DUpxVvOx2lef1VmNPCMl8jwZqIUqGv
                            </xenc:CipherValue>
                        </xenc:CipherData>
                    </EncryptedValue>
                    <ValueMAC>Su+NvtQfmvfJzF6bmQiJqoLRExc=                    
                    </ValueMAC>
                </Secret>
                <Counter>
                    <PlainValue>0</PlainValue>
                </Counter>
            </Data>
        </Key>
    </KeyPackage>
</KeyContainer>
							]]></artwork>
					</figure>
				</t>
				<t>When protecting the payload with pre-shared keys, implementations MUST set the
					name of the specific pre-shared key in the &lt;KeyName&gt; element
					inside the &lt;EncryptionKey&gt; element. When the encryption method uses 
					a CBC mode that requires an explicit initialization vector (IV), the IV MUST be passed by
					prepending it to the encrypted value.</t>
				<t>For systems implementing PSKC, it is RECOMMENDED to support AES&nbhy;128&nbhy;CBC (with the
					URI of http://www.w3.org/2001/04/xmlenc#aes128-cbc) and KW&nbhy;AES128 (with the URI
					of http://www.w3.org/2001/04/xmlenc#kw-aes128). Please note that KW&nbhy;AES128
					requires that the key to be protected must be a multiple of 8 bytes in length. Hence, if
					keys of a different length have to be protected, then the usage of the key-wrap
					algorithm with padding, as described in <xref target="RFC5649"/> is RECOMMENDED. Some of the encryption algorithms that can optionally be implemented are:</t>
				<t>
					<figure>
						<artwork><![CDATA[
Algorithm      | Uniform Resource Locator (URL)
---------------+-------------------------------------------------------
AES192-CBC     | http://www.w3.org/2001/04/xmlenc#aes192-cbc
AES256-CBC     | http://www.w3.org/2001/04/xmlenc#aes256-cbc
TripleDES-CBC  | http://www.w3.org/2001/04/xmlenc#tripledes-cbc
Camellia128    | http://www.w3.org/2001/04/xmldsig-more#camellia128
Camellia192    | http://www.w3.org/2001/04/xmldsig-more#camellia192
Camellia256    | http://www.w3.org/2001/04/xmldsig-more#camellia256
KW-AES128      | http://www.w3.org/2001/04/xmlenc#kw-aes128
KW-AES192      | http://www.w3.org/2001/04/xmlenc#kw-aes192
KW-AES256      | http://www.w3.org/2001/04/xmlenc#kw-aes256
KW-TripleDES   | http://www.w3.org/2001/04/xmlenc#kw-tripledes
KW-Camellia128 | http://www.w3.org/2001/04/xmldsig-more#kw-camellia128
KW-Camellia192 | http://www.w3.org/2001/04/xmldsig-more#kw-camellia192
KW-Camellia256 | http://www.w3.org/2001/04/xmldsig-more#kw-camellia256
					]]></artwork>
					</figure>
				</t>
				<section anchor="MACMethodDescription" title="MAC Method">
				   <t> When algorithms without integrity checks are used, such as AES-128-CBC, a keyed-MAC value MUST be placed in the &lt;ValueMAC&gt; element of the &lt;Data&gt; element. In this
					case, the MAC algorithm type MUST be set in the &lt;MACMethod&gt;
					element of the &lt;KeyContainer&gt; element. The MAC key MUST be a randomly generated key
					by the sender, be pre-agreed upon between the receiver and the sender, or be set by the application
					protocol that carries the PSKC document. It is RECOMMENDED that the sender generate a random MAC key.
					When the sender generates such a random MAC key, the MAC key material MUST be encrypted 
					with the same encryption key specified in &lt;EncryptionKey&gt; element of the key container. The 
					encryption method and encrypted value MUST be set in the &lt;EncryptionMethod&gt; element
					and the &lt;CipherData&gt; element, respectively, of the &lt;MACKey&gt; element in the &lt;MACMethod&gt; element. 
					The &lt;MACKeyReference&gt; element of the &lt;MACMethod&gt; element MAY be used to indicate 
					a pre-shared MAC key or a provisioning protocol derived MAC key.

					For systems implementing PSKC, it is RECOMMENDED to implement the HMAC-SHA1 (with the URI of
					'http://www.w3.org/2000/09/xmldsig#hmac-sha1'). Some of the MAC algorithms that can optionally be implemented are:</t>
				<t>
					<figure>
						<artwork><![CDATA[
Algorithm      | Uniform Resource Locator (URL)
---------------+-----------------------------------------------------
HMAC-SHA224    | http://www.w3.org/2001/04/xmldsig-more#hmac-sha224
HMAC-SHA256    | http://www.w3.org/2001/04/xmldsig-more#hmac-sha256
HMAC-SHA384    | http://www.w3.org/2001/04/xmldsig-more#hmac-sha384
HMAC-SHA512    | http://www.w3.org/2001/04/xmldsig-more#hmac-sha512
					]]></artwork>
					</figure>
				</t>
				</section>
			</section>

			<section title="Encryption Based on Passphrase-Based Keys" anchor="PBEbasedEncryption">
				<t><xref target="example-encr-passwd"/> shows an example that illustrates the
					encryption of the content of the &lt;Secret&gt; element using
					passphrase-based key derivation (PBKDF2) to derive the encryption key as defined in <xref target="PKCS5"/>. When using passphrase-based key derivation, the &lt;DerivedKey&gt; element defined in XML Encryption Version 1.1 <xref target="XMLENC11"/> MUST be used to specify the passphrased-based 
				key. A &lt;DerivedKey&gt; element is set as the child element of &lt;EncryptionKey&gt; element of the key container.</t>
				<t>
				The &lt;DerivedKey&gt; element is used to specify the key derivation function and related parameters. 
				The encryption algorithm, in this example, AES-128-CBC (URI 'http://www.w3.org/2001/04/xmlenc#aes128-cbc'),  MUST be set in the 'Algorithm' attribute of &lt;EncryptionMethod&gt; element used inside the encrypted data elements.</t>
				
			   <t>When PBKDF2 is used, the  'Algorithm' attribute of the &lt;xenc11:KeyDerivationMethod&gt; element MUST be set to the URI 'http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2'. The  
			   &lt;xenc11:KeyDerivationMethod&gt; element MUST include the &lt;PBKDF2-params> child element to indicate the 
			   PBKDF2 parameters, such as salt and iteration count.</t>
			

              <t>When the encryption method uses a CBC mode that uses an explicit initialization vector (IV) other than a
              derived one, the IV MUST be passed by prepending it to the encrypted value.</t>
					
				<t>In the example below, the following data is used. <list style="hanging">
						<t hangText="Password:       ">qwerty</t>
						<t hangText="Salt:                 ">0x123eff3c4a72129c</t>
						<t hangText="Iteration Count:">1000</t>
						<t hangText="MAC Key:        ">0xbdaab8d648e850d25a3289364f7d7eaaf53ce581</t>
						<t hangText="OTP Secret:     ">12345678901234567890</t>
					</list> The derived encryption key is "0x651e63cd57008476af1ff6422cd02e41". The initialization
					vector (IV) is "0xa13be8f92db69ec992d99fd1b5ca05f0". This key is also used to encrypt the randomly 
					chosen MAC key. A different IV can be used, say "0xd864d39cbc0cdc8e1ee483b9164b9fa0", in the example. 
					The encryption with algorithm "AES-128-CBC" follows the specification defined in <xref target="XMLENC"/>. </t>
				<t>
					<figure anchor="example-encr-passwd"
						title="Example of a PSKC Document Using Encryption Based on Passphrase-Based Keys">
						<artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<pskc:KeyContainer 
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc" 
  xmlns:xenc11="http://www.w3.org/2009/xmlenc11#" 
  xmlns:pkcs5=
  "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#"
  xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" Version="1.0">
    <pskc:EncryptionKey>
        <xenc11:DerivedKey>
            <xenc11:KeyDerivationMethod 
              Algorithm=
 "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#pbkdf2">
                <pkcs5:PBKDF2-params>
                    <Salt>
                        <Specified>Ej7/PEpyEpw=</Specified>
                    </Salt>
                    <IterationCount>1000</IterationCount>
                    <KeyLength>16</KeyLength>
                    <PRF/>
                </pkcs5:PBKDF2-params>
            </xenc11:KeyDerivationMethod>
            <xenc:ReferenceList>
                <xenc:DataReference URI="#ED"/>
            </xenc:ReferenceList>
            <xenc11:MasterKeyName>My Password 1</xenc11:MasterKeyName>
        </xenc11:DerivedKey>
    </pskc:EncryptionKey>
    <pskc:MACMethod 
        Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1">
        <pskc:MACKey>
            <xenc:EncryptionMethod 
            Algorithm="http://www.w3.org/2001/04/xmlenc#aes128-cbc"/>
            <xenc:CipherData>
                <xenc:CipherValue>
2GTTnLwM3I4e5IO5FkufoOEiOhNj91fhKRQBtBJYluUDsPOLTfUvoU2dStyOwYZx
                </xenc:CipherValue>
            </xenc:CipherData>
        </pskc:MACKey>
    </pskc:MACMethod>
    <pskc:KeyPackage>
        <pskc:DeviceInfo>
            <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer>
            <pskc:SerialNo>987654321</pskc:SerialNo>
        </pskc:DeviceInfo>
        <pskc:CryptoModuleInfo>
            <pskc:Id>CM_ID_001</pskc:Id>
        </pskc:CryptoModuleInfo>
        <pskc:Key Algorithm=
        "urn:ietf:params:xml:ns:keyprov:pskc:hotp" Id="123456">
            <pskc:Issuer>Example-Issuer</pskc:Issuer>
            <pskc:AlgorithmParameters>
                <pskc:ResponseFormat Length="8" Encoding="DECIMAL"/>
            </pskc:AlgorithmParameters>
            <pskc:Data>
                <pskc:Secret>
                <pskc:EncryptedValue Id="ED">
                    <xenc:EncryptionMethod 
                        Algorithm=
"http://www.w3.org/2001/04/xmlenc#aes128-cbc"/>
                        <xenc:CipherData>
                            <xenc:CipherValue>
      oTvo+S22nsmS2Z/RtcoF8Hfh+jzMe0RkiafpoDpnoZTjPYZu6V+A4aEn032yCr4f
                        </xenc:CipherValue>
                    </xenc:CipherData>
                    </pskc:EncryptedValue>
                    <pskc:ValueMAC>LP6xMvjtypbfT9PdkJhBZ+D6O4w=
                    </pskc:ValueMAC>
                </pskc:Secret>
            </pskc:Data>
        </pskc:Key>
    </pskc:KeyPackage>
</pskc:KeyContainer>
]]></artwork>
					</figure>
				</t>
			</section>
			<section anchor="AsymmetricKeyProtectionDescription" title="Encryption Based on Asymmetric Keys">
				<t>When using asymmetric keys to encrypt child elements of the &lt;Data&gt;
					element, information about the certificate being used MUST be stated in the
					&lt;X509Data&gt; element, which is a child element of the
					&lt;EncryptionKey&gt; element. The encryption algorithm MUST be
					indicated in the 'Algorithm' attribute of the &lt;EncryptionMethod&gt;
					element. In the example shown in <xref target="example-encr-asymm"/>, the
					algorithm is set to 'http://www.w3.org/2001/04/xmlenc#rsa_1_5'.</t>
				<t>
					<figure anchor="example-encr-asymm"
						title="Example of a PSKC Document Using Encryption Based on Asymmetric Keys">
						<artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8" ?>
<KeyContainer 
    xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
    xmlns="urn:ietf:params:xml:ns:keyprov:pskc" 
    xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
    id="KC0001" 
    Version="1.0">
    <EncryptionKey>
        <ds:X509Data>
<ds:X509Certificate>MIIB5zCCAVCgAwIBAgIESZp/vDANBgkqhkiG9w0BAQUFADA4M
Q0wCwYDVQQKEwRJRVRGMRMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIF
Rlc3QwHhcNMDkwMjE3MDkxMzMyWhcNMTEwMjE3MDkxMzMyWjA4MQ0wCwYDVQQKEwRJRVR
GMRMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwgZ8wDQYJKoZI
hvcNAQEBBQADgY0AMIGJAoGBALCWLDa2ItYJ6su80hd1gL4cggQYdyyKK17btt/aS6Q/e
DsKjsPyFIODsxeKVV/uA3wLT4jQJM5euKJXkDajzGGOy92+ypfzTX4zDJMkh61SZwlHNJ
xBKilAM5aW7C+BQ0RvCxvdYtzx2LTdB+X/KMEBA7uIYxLfXH2Mnub3WIh1AgMBAAEwDQY
JKoZIhvcNAQEFBQADgYEAe875m84sYUJ8qPeZ+NG7REgTvlHTmoCdoByU0LBBLotUKuqf
rnRuXJRMeZXaaEGmzY1kLonVjQGzjAkU4dJ+RPmiDlYuHLZS41Pg6VMwY+03lhk6I5A/w
4rnqdkmwZX/NgXg06alnc2pBsXWhL4O7nk0S2ZrLMsQZ6HcsXgdmHo=
</ds:X509Certificate>
        </ds:X509Data>
    </EncryptionKey>
    <KeyPackage>
        <DeviceInfo>
            <Manufacturer>TokenVendorAcme</Manufacturer>
            <SerialNo>987654321</SerialNo>
        </DeviceInfo>
        <Key 
            Id="MBK000000001" 
            Algorithm="urn:ietf:params:xml:ns:keyprov:pskc:hotp">
            <Issuer>Example-Issuer</Issuer>
            <AlgorithmParameters>
                <ResponseFormat Length="6" Encoding="DECIMAL"/>
            </AlgorithmParameters>
            <Data>
                <Secret>
                    <EncryptedValue>
                        <xenc:EncryptionMethod 
             Algorithm="http://www.w3.org/2001/04/xmlenc#rsa_1_5"/>
                        <xenc:CipherData>
<xenc:CipherValue>hJ+fvpoMPMO9BYpK2rdyQYGIxiATYHTHC7e/sPLKYo5/r1v+4
xTYG3gJolCWuVMydJ7Ta0GaiBPHcWa8ctCVYmHKfSz5fdeV5nqbZApe6dofTqhRwZK6
Yx4ufevi91cjN2vBpSxYafvN3c3+xIgk0EnTV4iVPRCR0rBwyfFrPc4=
</xenc:CipherValue>
                        </xenc:CipherData>
                    </EncryptedValue>
                </Secret>
                <Counter>
                    <PlainValue>0</PlainValue>
                </Counter>
            </Data>
        </Key>
    </KeyPackage>
</KeyContainer>
							]]></artwork>
					</figure>
				</t>
				<t>For systems implementing PSKC, it is RECOMMENDED to implement the RSA-1.5 algorithm, identified by the URI 'http://www.w3.org/2001/04/xmlenc#rsa-1_5'.</t>
				<t>Some of the asymmetric encryption algorithms that can optionally be implemented are:</t>
				<t>
					<figure>
						<artwork><![CDATA[
Algorithm         | Uniform Resource Locator (URL)
------------------+-------------------------------------------------
RSA-OAEP-MGF1P    | http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p 
					]]></artwork>
					</figure>
				</t>
			</section>

			<section title="Padding of Encrypted Values for Non-Padded Encryption Algorithms">
					<t>Padding of encrypted values (for example, the key secret value) is required when key protection algorithms are used that do not support embedded padding and the value to be encrypted is not a multiple of the encryption algorithm cipher block length.</t>
					<t>For example, when transmitting an HOTP key (20 bytes long) protected with the AES algorithm in CBC mode (8-byte block cipher), padding is required since its length is not a multiple of the 8-byte block length.</t>
					<t>In these cases, for systems implementing PSKC, it is RECOMMENDED to pad the value before encryption using PKCS #5 padding as described in <xref target="PKCS5"/>.
					</t>
			</section>
		</section>

		<!-- ****************************************************************************************** -->

		<section title="Digital Signature">
			<t>PSKC allows a digital signature to be added to the XML document, as a child element
				of the &lt;KeyContainer&gt; element. The description of the XML digital
				signature can be found in <xref target="XMLDSIG"/>.</t>
			<t>
				<figure anchor="example-dsig" title="Digital Signature Example">
					<artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<KeyContainer 
    xmlns="urn:ietf:params:xml:ns:keyprov:pskc"
    xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
    xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
    Version="1.0">
    <KeyPackage>
        <DeviceInfo>
            <Manufacturer>TokenVendorAcme</Manufacturer>
            <SerialNo>0755225266</SerialNo>
        </DeviceInfo>
        <Key Id="123" 
        Algorithm="urn:ietf:params:xml:ns:keyprov:pskc:hotp">
            <Issuer>Example-Issuer</Issuer>
            <AlgorithmParameters>
                <ResponseFormat Length="6" Encoding="DECIMAL"/>
            </AlgorithmParameters>
            <Data>
                <Secret>
                    <PlainValue> 
                        MTIzNDU2Nzg5MDEyMzQ1Njc4OTA=
                    </PlainValue>
                </Secret>
                <Counter>
                    <PlainValue>0</PlainValue>
                </Counter>
            </Data>
        </Key>
    </KeyPackage>
    <Signature>
        <ds:SignedInfo>
            <ds:CanonicalizationMethod 
             Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
            <ds:SignatureMethod 
             Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1"/>
            <ds:Reference URI="#Device">
                <ds:DigestMethod 
             Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
                <ds:DigestValue>
                    j6lwx3rvEPO0vKtMup4NbeVu8nk=
                </ds:DigestValue>
            </ds:Reference>            
        </ds:SignedInfo>        
        <ds:SignatureValue>
            j6lwx3rvEPO0vKtMup4NbeVu8nk=
        </ds:SignatureValue>
        <ds:KeyInfo>
            <ds:X509Data>
                <ds:X509IssuerSerial>
                    <ds:X509IssuerName>
                        CN=Example.com,C=US
                    </ds:X509IssuerName>
                    <ds:X509SerialNumber>
                        12345678
                    </ds:X509SerialNumber>
                </ds:X509IssuerSerial>
            </ds:X509Data>
        </ds:KeyInfo>
    </Signature>
</KeyContainer>
		]]></artwork>
				</figure>
			</t>
		</section>

		<!-- ****************************************************************************************** -->

		<section anchor="bulk" title="Bulk Provisioning">
			<t>The functionality of bulk provisioning can be accomplished by repeating the
				&lt;KeyPackage&gt; element multiple times within the
				&lt;KeyContainer&gt; element, indicating that multiple keys are provided to
				different devices or cryptographic modules. The &lt;EncryptionKey&gt; element then applies to all
				&lt;KeyPackage&gt; elements. When provisioning multiple keys to the same device, the &lt;KeyPackage&gt; element is repeated, but the enclosed &lt;DeviceInfo&gt; element will contain the same sub-elements that uniquely identify the single device (for example, the keys for the device identified by SerialNo='9999999' in the example below).</t>

			<t><xref target="example-bulk"/> shows an example utilizing these capabilities.</t>

			<t>
				<figure anchor="example-bulk" title="Bulk Provisioning Example">
					<artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<KeyContainer Version="1.0"  
    xmlns="urn:ietf:params:xml:ns:keyprov:pskc">
    <KeyPackage>
        <DeviceInfo>
            <Manufacturer>TokenVendorAcme</Manufacturer>
            <SerialNo>654321</SerialNo>
        </DeviceInfo>
        <Key Id="1" 
        Algorithm="urn:ietf:params:xml:ns:keyprov:pskc:hotp">
            <Issuer>Issuer</Issuer>
            <AlgorithmParameters>
                <ResponseFormat Length="8" Encoding="DECIMAL"/>
            </AlgorithmParameters>
            <Data>
                <Secret>
                    <PlainValue>
                        MTIzNDU2Nzg5MDEyMzQ1Njc4OTA=
                    </PlainValue>
                </Secret>
                <Counter>
                    <PlainValue>0</PlainValue>
                </Counter>
            </Data>
            <Policy>
                <StartDate>2006-05-01T00:00:00Z</StartDate>
                <ExpiryDate>2006-05-31T00:00:00Z</ExpiryDate>
            </Policy>
        </Key>
    </KeyPackage>
    <KeyPackage>
        <DeviceInfo>
            <Manufacturer>TokenVendorAcme</Manufacturer>
            <SerialNo>123456</SerialNo>
        </DeviceInfo>
        <Key Id="2" 
        Algorithm="urn:ietf:params:xml:ns:keyprov:pskc:hotp">
            <Issuer>Issuer</Issuer>
            <AlgorithmParameters>
                <ResponseFormat Length="8" Encoding="DECIMAL"/>
            </AlgorithmParameters>
            <Data>
                <Secret>
                    <PlainValue>
                        MTIzNDU2Nzg5MDEyMzQ1Njc4OTA=
                    </PlainValue>
                </Secret>
                <Counter>
                    <PlainValue>0</PlainValue>
                </Counter>
            </Data>
            <Policy>
                <StartDate>2006-05-01T00:00:00Z</StartDate>
                <ExpiryDate>2006-05-31T00:00:00Z</ExpiryDate>
            </Policy>
        </Key>
    </KeyPackage>
    <KeyPackage>
        <DeviceInfo>
            <Manufacturer>TokenVendorAcme</Manufacturer>
            <SerialNo>9999999</SerialNo>
        </DeviceInfo>
        <Key Id="3"
        Algorithm="urn:ietf:params:xml:ns:keyprov:pskc:hotp">
            <Issuer>Issuer</Issuer>
            <AlgorithmParameters>
                <ResponseFormat Length="8" Encoding="DECIMAL"/>
            </AlgorithmParameters>
            <Data>
                <Secret>
                    <PlainValue>
                        MTIzNDU2Nzg5MDEyMzQ1Njc4OTA=
                    </PlainValue>
                </Secret>
                <Counter>
                    <PlainValue>0</PlainValue>
                </Counter>
            </Data>
            <Policy>
                <StartDate>2006-03-01T00:00:00Z</StartDate>
                <ExpiryDate>2006-03-31T00:00:00Z</ExpiryDate>
            </Policy>
        </Key>
    </KeyPackage>
    <KeyPackage>
        <DeviceInfo>
            <Manufacturer>TokenVendorAcme</Manufacturer>
            <SerialNo>9999999</SerialNo>
        </DeviceInfo>
        <Key Id="4" 
        Algorithm="urn:ietf:params:xml:ns:keyprov:pskc:hotp">
            <Issuer>Issuer</Issuer>
            <AlgorithmParameters>
                <ResponseFormat Length="8" Encoding="DECIMAL"/>
            </AlgorithmParameters>
            <Data>
                <Secret>
                    <PlainValue>
                        MTIzNDU2Nzg5MDEyMzQ1Njc4OTA=
                    </PlainValue>
                </Secret>
                <Counter>
                    <PlainValue>0</PlainValue>
                </Counter>
            </Data>
            <Policy>
                <StartDate>2006-04-01T00:00:00Z</StartDate>
                <ExpiryDate>2006-04-30T00:00:00Z</ExpiryDate>
            </Policy>
        </Key>
    </KeyPackage>
</KeyContainer>
]]></artwork>
				</figure>
			</t>
		</section>

		<!-- ****************************************************************************************** -->

		<section title="Extensibility">
			<t>This section lists a few common extension points provided by PSKC: </t>
			<t>
				<list style="hanging">
					<t hangText="New PSKC Version:">Whenever it is necessary to define a new version
						of this document, a new version number has to be allocated to refer to
						the new specification. The version number is carried inside the
						'Version' attribute, as described in <xref target="basics"/>, the numbering scheme MUST follow <xref target="VersionSupport"/>, and rules
						for extensibility are defined in <xref target="iana"/>.</t>
					<t hangText="New XML Elements:">The usage of the XML schema and the available
						extension points allows new XML elements to be added. Depending on the type of
						XML element, different ways for extensibility are offered. In some places,
						the &lt;Extensions&gt; element can be used and elsewhere the
						"&lt;xs:any namespace="##other" processContents="lax" minOccurs="0"
						maxOccurs="unbounded"/&gt;" XML extension point is utilized.</t>
					<t hangText="New XML Attributes:">The XML schema allows new XML attributes to be
						added where XML extension points have been defined (see
						"&lt;xs:anyAttribute namespace="##other"/&gt;" in <xref
							target="schema"/>).</t>
					<t hangText="New PSKC Algorithm Profiles:">This document defines two PSKC
						algorithm profiles, see <xref target="profiles"/>. The following informational document describes additional profiles <xref target="PSKC-ALGORITHM-PROFILES"/>.  Further PSKC algorithm
						profiles can be registered as described in <xref
							target="SymmetricKeyAlgorithmIdentifierRegistry"/>.</t>
					<t hangText="Algorithm URIs:">
						<xref target="EncryptionKeyDescription"/> defines how keys and related data
						can be protected. A number of algorithms can be used. New
						algorithms can be used by pointing to a new algorithm URI.
 </t>
					<t hangText="Policy:">
						<xref target="policy"/> defines policies that can be attached to a key and
						keying-related data. The &lt;Policy&gt; element is one such item
						that allows implementers to restrict the use of the key to certain functions, such as
						"OTP usage only". Further values may be registered as described in <xref
							target="iana"/>. </t>
				</list>
			</t>
		</section>

		<!-- ****************************************************************************************** -->

		<section anchor="profiles" title="PSKC Algorithm Profile">

			<section title="HOTP" anchor="hotp">
				<t>
					<list style="hanging">
						<t hangText="Common Name:"> HOTP </t>
						<t hangText="Class:"> OTP </t>
						<t hangText="URI:">urn:ietf:params:xml:ns:keyprov:pskc:hotp</t>
						<t hangText="Algorithm Definition:"> <xref target="HOTP"/> </t>
						<t hangText="Identifier Definition:"> (this RFC) </t>
						<t hangText="Registrant Contact:"> IESG </t>
						<t hangText="Deprecated:">FALSE</t>
						<t hangText="Profiling:">
							<list style="empty">
								<t>The &lt;KeyPackage> element MUST be present and the
									&lt;ResponseFormat> element, which is a child element of the
									&lt;AlgorithmParameters&gt; element, MUST be used to
									indicate the OTP length and the value format.</t>
								<t>The &lt;Counter&gt; element (see <xref
										target="KeyElement"/>) MUST be provided as metadata for the
									key. </t>
								<t>The following additional constraints apply: <list style="symbols">
										<t>The value of the &lt;Secret> element MUST contain key
											material with a length of at least 16 octets (128 bits),
											if it is present.</t>
										<t>The &lt;ResponseFormat> element MUST have the
											'Format' attribute set to "DECIMAL", and the 'Length'
											attribute MUST indicate a length value between 6 and 9 (inclusive).</t>
										<t>The &lt;PINPolicy> element MAY be present, but the
											'PINUsageMode' attribute cannot be set to "Algorithmic".
										</t>
									</list>
								</t>
								<t>An example can be found in <xref target="example-suppl"/>. </t>
							</list>
						</t>
					</list>
				</t>
			</section>

			<section title="PIN" anchor="pin">
				<t>
					<list style="hanging">
						<t hangText="Common Name:">PIN</t>
						<t hangText="Class:"> Symmetric static credential comparison </t>
						<t hangText="URI:">urn:ietf:params:xml:ns:keyprov:pskc:pin</t>
						<t hangText="Algorithm Definition:"> (this RFC) <xref target="pinAlgorithm"/> </t>
						<t hangText="Identifier Definition"> (this RFC) </t>
						<t hangText="Registrant Contact:"> IESG </t>
						<t hangText="Deprecated:">FALSE</t>						
						<t hangText="Profiling:">
							<list style="empty">
								<t>The &lt;Usage> element MAY be present, but no attribute of the
									&lt;Usage> element is required. The &lt;ResponseFormat>
									element MAY be used to indicate the PIN value format.</t>
								<t>The &lt;Secret&gt; element (see <xref target="KeyElement"
									/>) MUST be provided. </t>
								<t>See the example in <xref target="example-pin"/>
								</t>
							</list>
						</t>
					</list>
				</t>
			</section>

		</section>

		<!-- ****************************************************************************************** -->

		<section anchor="schema" title="XML Schema">
			<t>This section defines the XML schema for PSKC. </t>
			<t>
				<figure>
					<artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc" 
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
     targetNamespace="urn:ietf:params:xml:ns:keyprov:pskc" 
     elementFormDefault="qualified"
     attributeFormDefault="unqualified">
     <xs:import namespace="http://www.w3.org/2000/09/xmldsig#"
          schemaLocation=
"http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/
          xmldsig-core-schema.xsd"/>
     <xs:import namespace="http://www.w3.org/2001/04/xmlenc#"
          schemaLocation=
"http://www.w3.org/TR/2002/REC-xmlenc-core-20021210/xenc-schema.xsd"/>
     <xs:import namespace="http://www.w3.org/XML/1998/namespace"/>
     <xs:complexType name="KeyContainerType">
          <xs:sequence>
               <xs:element name="EncryptionKey" 
                    type="ds:KeyInfoType" minOccurs="0"/>
               <xs:element name="MACMethod" 
                    type="pskc:MACMethodType" minOccurs="0"/>
               <xs:element name="KeyPackage" 
                    type="pskc:KeyPackageType" maxOccurs="unbounded"/>
               <xs:element name="Signature" 
                    type="ds:SignatureType" minOccurs="0"/>
               <xs:element name="Extensions" 
                    type="pskc:ExtensionsType" 
                    minOccurs="0" maxOccurs="unbounded"/>
          </xs:sequence>
          <xs:attribute name="Version" 
               type="pskc:VersionType" use="required"/>
          <xs:attribute name="Id" 
               type="xs:ID" use="optional"/>
     </xs:complexType>
     <xs:simpleType name="VersionType" final="restriction">
          <xs:restriction base="xs:string">
               <xs:pattern value="\d{1,2}\.\d{1,3}"/>
          </xs:restriction>
     </xs:simpleType>
     <xs:complexType name="KeyType">
          <xs:sequence>
               <xs:element name="Issuer" 
                    type="xs:string" minOccurs="0"/>
               <xs:element name="AlgorithmParameters" 
                    type="pskc:AlgorithmParametersType" 
                    minOccurs="0"/>
               <xs:element name="KeyProfileId" 
                    type="xs:string" minOccurs="0"/>
               <xs:element name="KeyReference" 
                    type="xs:string" minOccurs="0"/>
               <xs:element name="FriendlyName" 
                    type="xs:string" minOccurs="0"/>
               <xs:element name="Data" 
                    type="pskc:KeyDataType" minOccurs="0"/>
               <xs:element name="UserId" 
                    type="xs:string" minOccurs="0"/>
               <xs:element name="Policy" 
                    type="pskc:PolicyType" minOccurs="0"/>
               <xs:element name="Extensions" 
                    type="pskc:ExtensionsType" minOccurs="0"
                    maxOccurs="unbounded"/>
          </xs:sequence>
          <xs:attribute name="Id" 
               type="xs:string" use="required"/>
          <xs:attribute name="Algorithm" 
               type="pskc:KeyAlgorithmType" use="optional"/>
     </xs:complexType>
     <xs:complexType name="PolicyType">
          <xs:sequence>
               <xs:element name="StartDate" 
                    type="xs:dateTime" minOccurs="0"/>
               <xs:element name="ExpiryDate" 
                    type="xs:dateTime" minOccurs="0"/>
               <xs:element name="PINPolicy" 
                    type="pskc:PINPolicyType" minOccurs="0"/>
               <xs:element name="KeyUsage" 
                    type="pskc:KeyUsageType" 
                    minOccurs="0" maxOccurs="unbounded"/>
               <xs:element name="NumberOfTransactions" 
                    type="xs:nonNegativeInteger" minOccurs="0"/>
               <xs:any namespace="##other" 
                    minOccurs="0" maxOccurs="unbounded"/>
          </xs:sequence>
     </xs:complexType>
     <xs:complexType name="KeyDataType">
          <xs:sequence>
               <xs:element name="Secret" 
                    type="pskc:binaryDataType" minOccurs="0"/>
               <xs:element name="Counter" 
                    type="pskc:longDataType" minOccurs="0"/>
               <xs:element name="Time" 
                    type="pskc:intDataType" minOccurs="0"/>
               <xs:element name="TimeInterval" 
                    type="pskc:intDataType" minOccurs="0"/>
               <xs:element name="TimeDrift" 
                    type="pskc:intDataType" minOccurs="0"/>
               <xs:any namespace="##other" 
                    processContents="lax" 
                    minOccurs="0" maxOccurs="unbounded"/>
          </xs:sequence>
     </xs:complexType>
     <xs:complexType name="binaryDataType">
          <xs:sequence>
               <xs:choice>
                    <xs:element name="PlainValue" 
                         type="xs:base64Binary"/>
                    <xs:element name="EncryptedValue" 
                         type="xenc:EncryptedDataType"/>
               </xs:choice>
               <xs:element name="ValueMAC" 
                    type="xs:base64Binary" minOccurs="0"/>
          </xs:sequence>
     </xs:complexType>
     <xs:complexType name="intDataType">
          <xs:sequence>
               <xs:choice>
                    <xs:element name="PlainValue" type="xs:int"/>
                    <xs:element name="EncryptedValue" 
                         type="xenc:EncryptedDataType"/>
               </xs:choice>
               <xs:element name="ValueMAC" 
                    type="xs:base64Binary" minOccurs="0"/>
          </xs:sequence>
     </xs:complexType>
     <xs:complexType name="stringDataType">
          <xs:sequence>
               <xs:choice>
                    <xs:element name="PlainValue" type="xs:string"/>
                    <xs:element name="EncryptedValue" 
                         type="xenc:EncryptedDataType"/>
               </xs:choice>
               <xs:element name="ValueMAC" 
                    type="xs:base64Binary" minOccurs="0"/>
          </xs:sequence>
     </xs:complexType>
     <xs:complexType name="longDataType">
          <xs:sequence>
               <xs:choice>
                    <xs:element name="PlainValue" type="xs:long"/>
                    <xs:element name="EncryptedValue" 
                         type="xenc:EncryptedDataType"/>
               </xs:choice>
               <xs:element name="ValueMAC" 
                    type="xs:base64Binary" minOccurs="0"/>
          </xs:sequence>
     </xs:complexType>
     <xs:complexType name="PINPolicyType">
          <xs:attribute name="PINKeyId" 
               type="xs:string" use="optional"/>
          <xs:attribute name="PINUsageMode" 
               type="pskc:PINUsageModeType"/>
          <xs:attribute name="MaxFailedAttempts" 
               type="xs:unsignedInt" use="optional"/>
          <xs:attribute name="MinLength" 
               type="xs:unsignedInt" use="optional"/>
          <xs:attribute name="MaxLength" 
               type="xs:unsignedInt" use="optional"/>
          <xs:attribute name="PINEncoding" 
               type="pskc:ValueFormatType" use="optional"/>
          <xs:anyAttribute namespace="##other"/>
     </xs:complexType>
     <xs:simpleType name="PINUsageModeType">
          <xs:restriction base="xs:string">
               <xs:enumeration value="Local"/>
               <xs:enumeration value="Prepend"/>
               <xs:enumeration value="Append"/>
               <xs:enumeration value="Algorithmic"/>
          </xs:restriction>
     </xs:simpleType>
     <xs:simpleType name="KeyUsageType">
          <xs:restriction base="xs:string">
               <xs:enumeration value="OTP"/>
               <xs:enumeration value="CR"/>
               <xs:enumeration value="Encrypt"/>
               <xs:enumeration value="Integrity"/>
               <xs:enumeration value="Verify"/>
               <xs:enumeration value="Unlock"/>
               <xs:enumeration value="Decrypt"/>
               <xs:enumeration value="KeyWrap"/>
               <xs:enumeration value="Unwrap"/>
               <xs:enumeration value="Derive"/>
               <xs:enumeration value="Generate"/>
          </xs:restriction>
     </xs:simpleType>
     <xs:complexType name="DeviceInfoType">
          <xs:sequence>
               <xs:element name="Manufacturer" 
                    type="xs:string" minOccurs="0"/>
               <xs:element name="SerialNo" 
                    type="xs:string" minOccurs="0"/>
               <xs:element name="Model" 
                    type="xs:string" minOccurs="0"/>
               <xs:element name="IssueNo" 
                    type="xs:string" minOccurs="0"/>
               <xs:element name="DeviceBinding" 
                    type="xs:string" minOccurs="0"/>
               <xs:element name="StartDate" 
                    type="xs:dateTime" minOccurs="0"/>
               <xs:element name="ExpiryDate" 
                    type="xs:dateTime" minOccurs="0"/>
               <xs:element name="UserId" 
                    type="xs:string" minOccurs="0"/>
               <xs:element name="Extensions" 
                    type="pskc:ExtensionsType" minOccurs="0"
                    maxOccurs="unbounded"/>
          </xs:sequence>
     </xs:complexType>
     <xs:complexType name="CryptoModuleInfoType">
          <xs:sequence>
               <xs:element name="Id" type="xs:string"/>
               <xs:element name="Extensions" 
                    type="pskc:ExtensionsType" minOccurs="0"
                    maxOccurs="unbounded"/>
          </xs:sequence>
     </xs:complexType>
     <xs:complexType name="KeyPackageType">
          <xs:sequence>
               <xs:element name="DeviceInfo" 
                    type="pskc:DeviceInfoType" minOccurs="0"/>
               <xs:element name="CryptoModuleInfo" 
                    type="pskc:CryptoModuleInfoType" minOccurs="0"/>
               <xs:element name="Key" 
                    type="pskc:KeyType" minOccurs="0"/>
               <xs:element name="Extensions" 
                    type="pskc:ExtensionsType" minOccurs="0"
                    maxOccurs="unbounded"/>
          </xs:sequence>
     </xs:complexType>
     <xs:complexType name="AlgorithmParametersType">
          <xs:choice>
               <xs:element name="Suite" type="xs:string" minOccurs="0"/>
               <xs:element name="ChallengeFormat" minOccurs="0">
                    <xs:complexType>
                         <xs:attribute name="Encoding" 
                              type="pskc:ValueFormatType" 
						      use="required"/>
                         <xs:attribute name="Min" 
                              type="xs:unsignedInt" use="required"/>
                         <xs:attribute name="Max" 
                              type="xs:unsignedInt" use="required"/>
                         <xs:attribute name="CheckDigits" 
                              type="xs:boolean" default="false"/>
                    </xs:complexType>
               </xs:element>
               <xs:element name="ResponseFormat" minOccurs="0">
                    <xs:complexType>
                         <xs:attribute name="Encoding" 
                              type="pskc:ValueFormatType" 
						      use="required"/>
                         <xs:attribute name="Length" 
                              type="xs:unsignedInt" use="required"/>
                         <xs:attribute name="CheckDigits" 
                              type="xs:boolean" default="false"/>
                    </xs:complexType>
               </xs:element>
               <xs:element name="Extensions" 
                    type="pskc:ExtensionsType" minOccurs="0"
                    maxOccurs="unbounded"/>
          </xs:choice>
     </xs:complexType>
     <xs:complexType name="ExtensionsType">
          <xs:sequence>
               <xs:any namespace="##other" 
                    processContents="lax" maxOccurs="unbounded"/>
          </xs:sequence>
          <xs:attribute name="definition" 
               type="xs:anyURI" use="optional"/>
     </xs:complexType>
     <xs:simpleType name="KeyAlgorithmType">
          <xs:restriction base="xs:anyURI"/>
     </xs:simpleType>
     <xs:simpleType name="ValueFormatType">
          <xs:restriction base="xs:string">
               <xs:enumeration value="DECIMAL"/>
               <xs:enumeration value="HEXADECIMAL"/>
               <xs:enumeration value="ALPHANUMERIC"/>
               <xs:enumeration value="BASE64"/>
               <xs:enumeration value="BINARY"/>
          </xs:restriction>
     </xs:simpleType>
     <xs:complexType name="MACMethodType">
	   <xs:sequence>
		  <xs:choice>
			<xs:element name="MACKey" 
              type="xenc:EncryptedDataType" minOccurs="0"/>
			<xs:element name="MACKeyReference" 
				type="xs:string" minOccurs="0"/>
			</xs:choice>
			<xs:any namespace="##other" 
           processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
       </xs:sequence>
       <xs:attribute name="Algorithm" type="xs:anyURI" use="required"/>
	</xs:complexType>     
     <xs:element name="KeyContainer" 
          type="pskc:KeyContainerType"/>
</xs:schema>
]]></artwork>
					<postamble/>
				</figure>
			</t>
		</section>

		<!-- ****************************************************************************************** -->

		<section anchor="iana" title="IANA Considerations">

			<section title="Content-Type Registration for 'application/pskc+xml'">

				<t>This specification contains the registration
of a new media type according to the
					procedures of RFC 4288 <xref target="RFC4288"/> and guidelines in RFC 3023 <xref
						target="RFC3023"/>.</t>
				<t>
					<list style="hanging">
						<t hangText="MIME media type name:">application </t>

						<t hangText="MIME subtype name:">pskc+xml </t>

						<t hangText="Required parameters:">There is no required parameter. </t>

						<t hangText="Optional parameters:">charset<vspace blankLines="1"/> Indicates
							the character encoding of enclosed XML. </t>

						<t hangText="Encoding considerations:"> Uses XML, which can employ 8-bit
							characters, depending on the character encoding used. See RFC 3023 <xref
								target="RFC3023"/>, Section 3.2.</t>

						<t hangText="Security considerations:"> Please refer to <xref target="SecurityConsiderations"/> of RFC 6030.</t>

						<t hangText="Interoperability considerations:">None</t>

						<t hangText="Published specification:">RFC 6030. </t>

						<t hangText="Applications which use this media type:"> This media type is
							being used as a symmetric key container format for transport and
							provisioning of symmetric keys (One-Time Password (OTP) shared secrets
							or symmetric cryptographic keys) to different types of strong
							authentication devices. As such, it is used for key provisioning
							systems. </t>

						<t hangText="Additional information:">
							<list style="hanging">
								<t hangText="Magic Number:">None </t>

								<t hangText="File Extension:">.pskcxml </t>

								<t hangText="Macintosh file type code:">'TEXT' </t>
							</list>
						</t>

						<t hangText="Personal and email address to contact for further information:">Philip
							Hoyer, Philip.Hoyer@actividentity.com </t>

						<t hangText="Intended usage:">LIMITED USE </t>
						
						<t hangText="Restrictions on usage:">None </t>

						<t hangText="Author:"> This specification is a work item of the IETF KEYPROV
							working group, with mailing list address
							&lt;keyprov@ietf.org&gt;. </t>
						<t hangText="Change controller:"> The IESG &lt;iesg@ietf.org&gt;
						</t>
					</list>
				</t>
			</section>

			<section title="XML Schema Registration">

				<t> This section registers an XML schema as per the guidelines in <xref
						target="RFC3688"/>.</t>
				<t>
					<list style="hanging">
						<t hangText="URI:">urn:ietf:params:xml:schema:keyprov:pskc</t>
						<t hangText="Registrant Contact:">IETF KEYPROV Working Group, Philip Hoyer
							(Philip.Hoyer@actividentity.com).</t>
						<t hangText="XML Schema:">The XML schema to be registered is contained in
								<xref target="schema"/>. Its first line is <figure>
								<artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
]]></artwork>
							</figure> and its last line is<figure>
								<artwork><![CDATA[
</xs:schema>
]]></artwork>
							</figure>
						</t>
					</list>
				</t>
			</section>

			<section title="URN Sub-Namespace Registration">

				<t> This section registers a new XML namespace,
					"urn:ietf:params:xml:ns:keyprov:pskc", per the guidelines in <xref
						target="RFC3688"/>. </t>

				<t>
					<list style="hanging">
						<t hangText="URI:">urn:ietf:params:xml:ns:keyprov:pskc</t>

						<t hangText="Registrant Contact:">IETF KEYPROV Working Group, Philip Hoyer
							(Philip.Hoyer@actividentity.com).</t>

						<t hangText="XML:">
							<figure>
								<artwork><![CDATA[
BEGIN
<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.0//EN"
  "http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type"
        content="text/html;charset=iso-8859-1"/>
  <title>PSKC Namespace</title>
</head>
<body>
  <h1>Namespace for PSKC</h1>
  <h2>urn:ietf:params:xml:ns:keyprov:pskc</h2>
<p>See <a href="http://www.rfc-editor.org/rfc/rfc6030.txt">
 RFC 6030</a>.</p>
</body>
</html>
END
]]></artwork>
							</figure>
						</t>
					</list>
				</t>
			</section>

			<section title="PSKC Algorithm Profile Registry"
				anchor="SymmetricKeyAlgorithmIdentifierRegistry">
				<t>IANA has created a registry for PSKC
					algorithm profiles in accordance with the principles set out in <xref
						target="RFC5226">RFC 5226</xref>. </t>
				<t> As part of this registry, IANA maintains the following information: </t>
				<t>
					<list style="hanging">
						<t hangText="Common Name:"> The name by which the PSKC algorithm profile is
							generally referred. </t>
						<t hangText="Class:"> The type of PSKC algorithm profile registry entry
							being created, such as encryption, Message Authentication Code (MAC),
							One-Time Password (OTP), Digest. </t>
						<t hangText="URI:"> The URI to be used to identify the profile. </t>
						<t hangText="Identifier Definition:"> IANA will add a pointer to
							the specification containing information about the PSKC algorithm
							profile registration. </t>
						<t hangText="Algorithm Definition:"> A reference to the stable document in
							which the algorithm being used with the PSKC is defined. </t>
						<t hangText="Registrant Contact:"> Contact information about the party
							submitting the registration request. </t>
						<t hangText="Deprecated:">TRUE
if this entry has been deprecated based on expert approval and SHOULD not be used in any new implementations. Otherwise, FALSE.
						</t>							
						<t hangText="PSKC Profiling:"> Information about PSKC XML elements and
							attributes being used (or not) with this specific profile of PSKC.
						</t>

					</list>
				</t>
				<t> PSKC algorithm profile identifier registrations are to be subject to Specification Required as per <xref target="RFC5226">RFC 5226</xref>. Updates can be provided based 
					on expert approval only. Based on expert approval, it is possible to mark entries as
   "deprecated".  A designated expert will be appointed by the IESG.
</t>

				<t> IANA has added two initial values to the registry based on the
					algorithm profiles described in <xref target="profiles"/>. </t>
			</section>

			<section title="PSKC Version Registry">

				<t>IANA has created a registry for PSKC version numbers. The registry has
					the following structure: <figure>
						<artwork><![CDATA[
  PSKC Version              | Specification
+---------------------------+----------------
| 1.0                       | RFC 6030
      ]]></artwork>
					</figure>
				</t>
				<t> Standards action is required to define new versions of PSKC. It is not
					envisioned to deprecate, delete, or modify existing PSKC versions. </t>

			</section>


			<section title="Key Usage Registry">
				<t>IANA has created a registry for key usage. A description of the
					&lt;KeyUsage&gt; element can be found in <xref target="policy"/>. </t>

			<t> As part of this registry IANA will maintain the following information: </t>
				<t>
					<list style="hanging">
						<t hangText=" Key Usage:"> The identifier of the Key Usage. </t>
						<t hangText="Specification:">
IANA will add a pointer to
							the specification containing information about the semantics of a new Key Usage registration.</t>
						<t hangText="Deprecated:">TRUE
if this entry has been deprecated based on expert approval and SHOULD not be used in any new implementations. Otherwise, FALSE.
						</t>							
					</list>
				</t>
				<t>	
					IANA has added these initial values to the registry: <figure>
						<artwork><![CDATA[
  Key Usage     | Specification                | Deprecated
+---------------+------------------------------+-----------
| OTP           | [Section 5 of this document] | FALSE
| CR            | [Section 5 of this document] | FALSE
| Encrypt       | [Section 5 of this document] | FALSE
| Integrity     | [Section 5 of this document] | FALSE
| Verify        | [Section 5 of this document] | FALSE
| Unlock        | [Section 5 of this document] | FALSE
| Decrypt       | [Section 5 of this document] | FALSE
| KeyWrap       | [Section 5 of this document] | FALSE
| Unwrap        | [Section 5 of this document] | FALSE 
| Derive        | [Section 5 of this document] | FALSE 
| Generate      | [Section 5 of this document] | FALSE 
+---------------+------------------------------+-----------
							]]></artwork>
					</figure>
				</t>

				<t>Key Usage Registry registrations are to be subject to Specification Required as per <xref target="RFC5226">RFC 5226</xref>.  Expert Review is required to define new Key Usage values. Updates can be provided based 
					on expert approval only. Based on expert approval, it is possible to mark entries as
   "deprecated".  A designated expert will be appointed by the IESG.</t>

			</section>

		</section>

		<!-- ****************************************************************************************** -->

		<section title="Security Considerations" anchor="SecurityConsiderations">
			<t>The portable symmetric key container (PSKC) carries sensitive information (e.g., cryptographic keys)
				and may be transported across the boundaries of one secure perimeter to another. For
				example, a container residing within the secure perimeter of a back-end provisioning
				server in a secure room may be transported across the Internet to an end-user device
				attached to a personal computer. This means that special care MUST be taken to
				ensure the confidentiality, integrity, and authenticity of the information contained
				within.</t>
			<section title="PSKC Confidentiality">
				<t>By design, the container allows two main approaches to guaranteeing the
					confidentiality of the information it contains while transported. </t>
				<t>First, the container key data payload may be encrypted.</t>
				<t>In this case, no transport layer security is required. However, standard security
					best practices apply when selecting the strength of the cryptographic algorithm
					for key data payload encryption. 
					A symmetric cryptographic cipher SHOULD be used -- the
					longer the cryptographic key, the stronger the protection. Please see <xref target="SymmetricKeyProtectionDescription"/> for recommendations of key data payload protection using symmetric cryptographic ciphers.
					In cases where the exchange of
  key encryption keys between the sender and the receiver is not
  possible, asymmetric encryption of the key data payload may be
  employed, see <xref target="AsymmetricKeyProtectionDescription"/>. Similar to symmetric key cryptography,
					the stronger the asymmetric key, the more secure the protection. </t>
				<t>If the key data payload is encrypted with a method that uses one of the password-based
					encryption methods (PBE methods) detailed in <xref target="PBEbasedEncryption"/>, the key data payload may be subjected to password
					dictionary attacks to break the encryption password and recover the information.
					Standard security best practices for selection of strong encryption passwords
					apply.</t>
				<t>Additionally, it is strongly RECOMMENDED that practical implementations use PBESalt and PBEIterationCount when PBE
					encryption is used. A different PBESalt value per PSKC SHOULD be used for
					best protection.</t>
				<t>The second approach to protecting the confidentiality of the key data
  is based on using lower-layer security mechanisms (e.g., <xref target="TLS"/>,
  <xref target="IPsec"/>).  The secure connection established between the source
  secure perimeter (the provisioning server from the example above) and
  the target perimeter (the device attached to the end-user computer)
  utilizes encryption to protect the messages that travel across that
  connection.  No key data payload encryption is required in this mode.
  Secure connections that encrypt and digest each message provide an
  extra measure of security.
 </t>
				<t>Because of the fact that the plaintext PSKC is protected only by the
					transport layer security, practical implementation MUST ensure protection
					against man-in-the-middle attacks. Authenticating  the secure channel endpoints is
					critically important for eliminating intruders that may compromise the
					confidentiality of the PSKC.</t>
			</section>
			<section title="PSKC Integrity">
				<t>The PSKC provides means to guarantee the integrity of the
  information it contains through the use of digital signatures. It is RECOMMENDED that for best security	practices, the digital signature of the container encompasses the entire
					PSKC. This provides assurances for the integrity of all attributes. It also
					allows verification of the integrity of a given PSKC even after the container
					is delivered through the communication channel to the target perimeter and
					channel message integrity check is no longer possible. </t>
			</section>
			<section title="PSKC Authenticity">
				<t>The digital signature of the PSKC is the primary way of showing its
					authenticity. The recipient of the container SHOULD use the public key associated
					with the signature to assert the authenticity of the sender by tracing it back
					to a pre-loaded public key or certificate. Note that the digital signature of the
					PSKC can be checked even after the container has been delivered through the
					secure channel of communication.</t>
				<t>Authenticity guarantee may be provided by <xref target="TLS"/> or <xref target="IPsec"/>. However, no authenticity verification is possible once the container is delivered at the recipient end. Since the TLS endpoints could differ from the key provisioning endpoints, this solution is weaker than the previous solution that relies on a digital signature of the PSKC. </t>
			</section>
		</section>

		<!-- ****************************************************************************************** -->

		<section title="Contributors">
			<t>We would like Hannes Tschofenig for his text contributions to this document.</t>
		</section>

		<!-- ****************************************************************************************** -->

		<section title="Acknowledgements">
			<t> The authors of this document would like to thank the following people for their
				feedback: Apostol Vassilev, Shuh Chang, Jon Martinson, Siddhart Bajaj, Stu Vaeth,
				Kevin Lewis, Philip Hallam-Baker, Andrea Doherty, Magnus Nystrom, Tim Moses, Anders
				Rundgren, Sean Turner, and especially Robert Philpott. </t>
			<t>We would like to thank Sean Turner for his review in January 2009. We would
				also like to thank Anders Rundgren for triggering the discussion regarding to the
				selection of encryption algorithms (KW&nbhy;AES&nbhy;128 vs. AES-128-CBC) and his input on the
				keyed message digest computation.</t>
			<t>This work is based on earlier work by the members of OATH (Initiative for Open
				AuTHentication), see <xref target="OATH"/>, to specify a format that can be freely
				distributed to the technical community.</t>
		</section>

		<!-- ****************************************************************************************** -->

	</middle>
	<back>
<?rfc rfcedstyle="no" ?>
		<references title="Normative References">

<!--[rfced] Please note that the below URL redirects to http://www.rsa.com/rsalabs/node.asp?id=2124.  Should this be updated?  -->
			<reference anchor="PKCS5" target="http://www.rsasecurity.com/rsalabs/pkcs/">
				<front>
					<title>PKCS #5: Password-Based Cryptography Standard</title>
					<author>
						<organization> RSA Laboratories </organization>
					</author>
					<date month="March" year="1999"/>
				</front>
				<seriesInfo name="Version" value="2.0"/>
			</reference>

<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>

<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.

</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />

</reference>

<reference anchor='XMLDSIG'
           target='http://www.w3.org/TR/2002/REC-xmldsig-core-20020212'>
<front>
<title>XML-Signature Syntax and Processing</title>

<author initials='D.' surname='Solo' fullname='David Solo'>
    <organization />
</author>

<author initials='J.' surname='Reagle' fullname='Joseph Reagle'>
    <organization />
</author>

<author initials='D.' surname='Eastlake' fullname='Donald Eastlake'>
    <organization />
</author>

<date month='February' day='12' year='2002' />
</front>

<seriesInfo name='World Wide Web Consortium FirstEdition' value='REC-xmldsig-core-20020212' />
<format type='HTML' target='http://www.w3.org/TR/2002/REC-xmldsig-core-20020212' />
</reference>


			<reference anchor="XMLENC" target="http://www.w3.org/TR/xmlenc-core/">
				<front>
					<title>XML Encryption Syntax and Processing.</title>
					<author initials="D. Eastlake and J. Reagle." surname="Eastlake"
						fullname="D. Eastlake and J. Reagle.">
						<organization> </organization>
					</author>
					<date month="December" year="2002"/>
				</front>
				<seriesInfo name="W3C" value="Recommendation"/>
			</reference>

			<reference anchor="XMLENC11"
           target='http://www.w3.org/TR/2009/WD-xmlenc-core1-20090730'>
<front>
<title>XML Encryption Syntax and Processing Version 1.1</title>

<author initials='J.' surname='Reagle' fullname='Joseph Reagle'>
    <organization />
</author>

<author initials='D.' surname='Eastlake' fullname='Donald Eastlake'>
    <organization />
</author>

<date month='July' day='30' year='2009' />
</front>

<seriesInfo name='World Wide Web Consortium WD' value='WD-xmlenc-core1-20090730' />
<format type='HTML' target='http://www.w3.org/TR/2009/WD-xmlenc-core1-20090730' />
</reference>

			
			
<reference anchor='RFC4288'>

<front>
<title>Media Type Specifications and Registration Procedures</title>
<author initials='N.' surname='Freed' fullname='N. Freed'>
<organization /></author>
<author initials='J.' surname='Klensin' fullname='J. Klensin'>
<organization /></author>
<date year='2005' month='December' />
<abstract>
<t>This document defines procedures for the specification and registration of media types for use in MIME and other Internet protocols.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='13' />

<seriesInfo name='RFC' value='4288' />
<format type='TXT' octets='52667' target='http://www.rfc-editor.org/rfc/rfc4288.txt' />
</reference>



<reference anchor='RFC3023'>

<front>
<title>XML Media Types</title>
<author initials='M.' surname='Murata' fullname='M. Murata'>
<organization /></author>
<author initials='S.' surname='St. Laurent' fullname='S. St. Laurent'>
<organization /></author>
<author initials='D.' surname='Kohn' fullname='D. Kohn'>
<organization /></author>
<date year='2001' month='January' />
<abstract>
<t>This document standardizes five new media types -- text/xml, application/xml, text/xml-external-parsed-entity, application/xml- external-parsed-entity, and application/xml-dtd -- for use in exchanging network entities that are related to the Extensible Markup Language (XML).  This document also standardizes a convention (using the suffix '+xml') for naming media types outside of these five types when those media types represent XML MIME (Multipurpose Internet Mail Extensions) entities. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3023' />

</reference>


<reference anchor='RFC5646'>

<front>
<title>Tags for Identifying Languages</title>
<author initials='A.' surname='Phillips' fullname='A. Phillips'>
<organization /></author>
<author initials='M.' surname='Davis' fullname='M. Davis'>
<organization /></author>
<date year='2009' month='September' />
<abstract>
<t>This document describes the structure, content, construction, and semantics of language tags for use in cases where it is desirable to indicate the language used in an information object.  It also describes how to register values for use in language tags and the creation of user-defined extensions for private interchange.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='47' />
<seriesInfo name='RFC' value='5646' />
</reference>


<reference anchor='RFC3688'>

<front>
<title>The IETF XML Registry</title>
<author initials='M.' surname='Mealling' fullname='M. Mealling'>
<organization /></author>
<date year='2004' month='January' />
<abstract>
<t>This document describes an IANA maintained registry for IETF standards which use Extensible Markup Language (XML) related items such as Namespaces, Document Type Declarations (DTDs), Schemas, and Resource Description Framework (RDF) Schemas.</t></abstract></front>

<seriesInfo name='BCP' value='81' />
<seriesInfo name='RFC' value='3688' />
<format type='TXT' octets='17325' target='http://www.rfc-editor.org/rfc/rfc3688.txt' />

</reference>


<reference anchor='RFC4514'>

<front>
<title>Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names</title>
<author initials='K.' surname='Zeilenga' fullname='K. Zeilenga'>
<organization /></author>
<date year='2006' month='June' />
<abstract>
<t>The X.500 Directory uses distinguished names (DNs) as primary keys to entries in the directory.  This document defines the string representation used in the Lightweight Directory Access Protocol (LDAP) to transfer distinguished names.  The string representation is designed to give a clean representation of commonly used distinguished names, while being able to represent any distinguished name. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4514' />
<format type='TXT' octets='31859' target='http://www.rfc-editor.org/rfc/rfc4514.txt' />
</reference>

<reference anchor='RFC4648'>

<front>
<title>The Base16, Base32, and Base64 Data Encodings</title>
<author initials='S.' surname='Josefsson' fullname='S. Josefsson'>
<organization /></author>
<date year='2006' month='October' />
<abstract>
<t>This document describes the commonly used base 64, base 32, and base 16 encoding schemes.  It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4648' />
<format type='TXT' octets='35491' target='http://www.rfc-editor.org/rfc/rfc4648.txt' />
</reference>

	
			
			<reference anchor="ISOIEC7812"
				target="http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=39698">
				<front>
					<title>ISO/IEC 7812-1:2006 Identification cards -- Identification of issuers -- Part 1: Numbering system</title>
					<author>
						<organization>ISO</organization>
					</author>
					<date year="2006" month="October"/>
					<abstract>
						<t>ISO/IEC 7812-1:2006 specifies a numbering system for the identification of 
						issuers of cards that require an issuer identification number to operate in international, 
						interindustry and/or intra-industry interchange. LUHN is a simple checksum formula 
						used to validate a variety of identification numbers, which is defined in Annex B 
						of ISO/IEC 7812-1.</t>
					</abstract>
				</front>
				
			</reference>			
			<reference anchor="OATHMAN"
				target="http://www.openauthentication.org/oath-id/prefixes/">
				<front>
					<title>List of OATH Manufacturer Prefixes (omp)</title>
					<author>
						<organization>OATH</organization>
					</author>
					<date year="2009" month="April"/>
					<abstract>
						<t>The OATH Token Identifier is one of the key deliverable items on the OATH technology roadmap and was developed through the collaboration of several OATH members. The OATH Token Identifier Specification enables every OATH-compatible token to be uniquely identified globally across manufacturers. As part of this work OATH will assign unique prefixes to token manufacturers (including OATH non-member companies) and maintain a registry of prefixes. </t>
					</abstract>
				</front>
				
			</reference>					
			
<!--[rfced] Please note that we have truncated the following URL in compliance with RFC 5226. -->
			<reference anchor="IANAPENREG"
				target="http://www.iana.org">
				<front>
					<title>Private Enterprise Numbers</title>
					<author>
						<organization>IANA</organization>
					</author>
					<date/>
					<abstract>
						<t>Private Enterprise Number (PEN), typically used in Simple Network Management Protocol Management Information Base configurations can be requested at http://pen.iana.org/pen/PenApplication.page  </t>
					</abstract>
				</front>
				
			</reference>				
<reference anchor='RFC5649'>

<front>
<title>Advanced Encryption Standard (AES) Key Wrap with Padding Algorithm</title>
<author initials='R.' surname='Housley' fullname='R. Housley'>
<organization /></author>
<author initials='M.' surname='Dworkin' fullname='M. Dworkin'>
<organization /></author>
<date year='2009' month='September' />
<abstract>
<t>This document specifies a padding convention for use with the AES Key Wrap algorithm specified in RFC 3394.  This convention eliminates the requirement that the length of the key to be wrapped be a multiple of 64 bits, allowing a key of any practical length to be wrapped.  This memo provides information for the Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='5649' />

<format type='TXT' octets='22507' target='http://www.rfc-editor.org/rfc/rfc5649.txt' />
</reference>
		
			
			<reference anchor="HOTP">

<front>
<title>HOTP: An HMAC-Based One-Time Password Algorithm</title>
<author initials='D.' surname='M&apos;Raihi' fullname='D. M&apos;Raihi'>
<organization /></author>
<author initials='M.' surname='Bellare' fullname='M. Bellare'>
<organization /></author>
<author initials='F.' surname='Hoornaert' fullname='F. Hoornaert'>
<organization /></author>
<author initials='D.' surname='Naccache' fullname='D. Naccache'>
<organization /></author>
<author initials='O.' surname='Ranen' fullname='O. Ranen'>
<organization /></author>

<date year='2005' month='December' />
<abstract>
<t>This document describes an algorithm to generate one-time password values, based on Hashed Message Authentication Code (HMAC). A security analysis of the algorithm is presented, and important parameters related to the secure deployment of the algorithm are discussed. The proposed algorithm can be used across a wide range of network applications ranging from remote Virtual Private Network (VPN) access, Wi-Fi network logon to transaction-oriented Web applications.&lt;/t>&lt;t> This work is a joint effort by the OATH (Open AuTHentication) membership to specify an algorithm that can be freely distributed to the technical community. The authors believe that a common and shared algorithm will facilitate adoption of two-factor authentication on the Internet by enabling interoperability across commercial and open-source implementations. This memo provides information for the Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='4226' />
</reference>


		
			
			<reference anchor="FIPS197">
				<front>
					<title>FIPS Pub 197: Advanced Encryption Standard (AES)</title>
					<author surname="National Institute of Standards">
						<organization/>
					</author>
					<date month="November" year="2001"/>
				</front>
			</reference>				
			
		    <reference anchor="SP800-67">
				<front>
					<title>NIST Special Publication 800-67 Version 1.1: Recommendation for the Triple Data Encryption Algorithm (TDEA) Block Cipher</title>
					<author surname="National Institute of Standards">
						<organization/>
					</author>
					<date month="May" year="2008"/>
				</front>
				<seriesInfo name="NIST Special Publication" value="800-67"/>				
			</reference>				

		 


<reference anchor='W3C.REC-xmlschema-2-20041028'
           target='http://www.w3.org/TR/2004/REC-xmlschema-2-20041028'>
<front>
<title>XML Schema Part 2: Datatypes Second Edition</title>

<author initials='A.' surname='Malhotra' fullname='Ashok Malhotra'>
    <organization />
</author>

<author initials='P.' surname='Biron' fullname='Paul V. Biron'>
    <organization />
</author>

<date month='October' day='28' year='2004' />
</front>

<seriesInfo name='World Wide Web Consortium Recommendation' value='REC-xmlschema-2-20041028' />
<format type='HTML' target='http://www.w3.org/TR/2004/REC-xmlschema-2-20041028' />
</reference>

					

			
		</references>
		
		<references title="Informative References">		
	


			
				<reference anchor="PSKC-ALGORITHM-PROFILES">
<front>
<title>Additional Portable Symmetric Key Container (PSKC) Algorithm Profiles</title>

<author initials='P' surname='Hoyer' fullname='Philip Hoyer'>
    <organization />
</author>

<author initials='M' surname='Pei' fullname='Mingliang Pei'>
    <organization />
</author>

<author initials='S' surname='Machani' fullname='Salah Machani'>
    <organization />
</author>

<author initials='A' surname='Doherty' fullname='Andrea Doherty'>
    <organization />
</author>

<date month='May' day='2' year='2010' />

<abstract><t>The Portable Symmetric Key Container (PSKC) contains a number of XML elements and XML attributes carrying keys and related information. Not all algorithms, however, are able to use all elements and for other algorithm certain information is mandatory.  This lead to the introduction of PSKC algorithm profiles that provide further description about the mandatory and optional information elements and their semantic, including extensions that may be needed.  The main PSKC specification defines two PSKC algorithm profiles, namely "HOTP" and "PIN".  This document extends the initial set and specifies nine further algorithm profiles for PKSC.</t></abstract>
</front>
<seriesInfo name='Work in' value='Progress' />

</reference>

	
				<reference anchor="NIST800-57">
				<front>
					<title>NIST Special Publication 800-57, Recommendation for Key Management Part
						1: General (Revised)</title>
					<author initials="E." surname="Barker" fullname="Elaine Barker">
						<organization/>
					</author>
					<author initials="W." surname="Barker" fullname="William Barker">
						<organization/>
					</author>
					<author initials="W." surname="Burr" fullname="William Burr">
						<organization/>
					</author>
					<author initials="W." surname="Polk" fullname="William Polk">
						<organization/>
					</author>
					<author initials="M." surname="Smid" fullname="Miles Smid">
						<organization/>
					</author>
					<date year="2007" month="March"/>
				</front>
				<seriesInfo name="NIST Special Publication" value="800-57"/>
			</reference>


<reference anchor='RFC5226'>

<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='T.' surname='Narten' fullname='T. Narten'>
<organization /></author>
<author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'>
<organization /></author>
<date year='2008' month='May' />
<abstract>
<t>Many protocols make use of identifiers consisting of constants and other well-known values. Even after a protocol has been defined and deployment has begun, new values may need to be assigned (e.g., for a new option type in DHCP, or a new encryption or authentication transform for IPsec). To ensure that such quantities have consistent values and interpretations across all implementations, their assignment must be administered by a central authority. For IETF protocols, that role is provided by the Internet Assigned Numbers Authority (IANA).&lt;/t>&lt;t> In order for IANA to manage a given namespace prudently, it needs guidelines describing the conditions under which new values can be assigned or when modifications to existing values can be made. If IANA is expected to play a role in the management of a namespace, IANA must be given clear and concise instructions describing that role. This document discusses issues that should be considered in formulating a policy for assigning values to a namespace and provides guidelines for authors on the specific text that must be included in documents that place demands on IANA.&lt;/t>&lt;t> This document obsoletes RFC 2434. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='26' />
<seriesInfo name='RFC' value='5226' />
<format type='TXT' octets='66160' target='http://www.rfc-editor.org/rfc/rfc5226.txt' />
</reference>

		


<reference anchor='RFC3986'>

<front>
<title abbrev='URI Generic Syntax'>Uniform Resource Identifier (URI): Generic Syntax</title>
<author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
<organization abbrev='W3C/MIT'>World Wide Web Consortium</organization>
<address>
<postal>
<street>Massachusetts Institute of Technology</street>
<street>77 Massachusetts Avenue</street>
<city>Cambridge</city>

<region>MA</region>
<code>02139</code>
<country>USA</country></postal>
<phone>+1-617-253-5702</phone>
<facsimile>+1-617-258-5999</facsimile>
<email>timbl@w3.org</email>
<uri>http://www.w3.org/People/Berners-Lee/</uri></address></author>
<author initials='R.' surname='Fielding' fullname='Roy T. Fielding'>
<organization abbrev='Day Software'>Day Software</organization>

<address>
<postal>
<street>5251 California Ave., Suite 110</street>
<city>Irvine</city>
<region>CA</region>
<code>92617</code>
<country>USA</country></postal>
<phone>+1-949-679-2960</phone>
<facsimile>+1-949-679-2972</facsimile>
<email>fielding@gbiv.com</email>

<uri>http://roy.gbiv.com/</uri></address></author>
<author initials='L.' surname='Masinter' fullname='Larry Masinter'>
<organization abbrev='Adobe Systems'>Adobe Systems Incorporated</organization>
<address>
<postal>
<street>345 Park Ave</street>
<city>San Jose</city>
<region>CA</region>
<code>95110</code>
<country>USA</country></postal>

<phone>+1-408-536-3024</phone>
<email>LMM@acm.org</email>
<uri>http://larry.masinter.net/</uri></address></author>
<date year='2005' month='January' />
<area>Applications</area>
<keyword>uniform resource identifier</keyword>
<keyword>URI</keyword>
<keyword>URL</keyword>
<keyword>URN</keyword>

<keyword>WWW</keyword>
<keyword>resource</keyword>
<abstract>
<t>
A Uniform Resource Identifier (URI) is a compact sequence of characters
that identifies an abstract or physical resource.  This specification
defines the generic URI syntax and a process for resolving URI references
that might be in relative form, along with guidelines and security
considerations for the use of URIs on the Internet.
The URI syntax defines a grammar that is a superset of all valid URIs,
allowing an implementation to parse the common components of a URI
reference without knowing the scheme-specific requirements of every
possible identifier.  This specification does not define a generative
grammar for URIs; that task is performed by the individual
specifications of each URI scheme.
</t></abstract></front>

<seriesInfo name='STD' value='66' />
<seriesInfo name='RFC' value='3986' />
<format type='TXT' octets='141811' target='http://www.rfc-editor.org/rfc/rfc3986.txt' />
<format type='HTML' octets='213584' target='http://xml.resource.org/public/rfc/html/rfc3986.html' />
<format type='XML' octets='163534' target='http://xml.resource.org/public/rfc/xml/rfc3986.xml' />
</reference>


			
			<reference anchor="TLS">

<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<date year='2008' month='August' />
<abstract>
<t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5246' />

<format type='TXT' octets='222395' target='http://www.rfc-editor.org/rfc/rfc5246.txt' />
</reference>

				
			<reference anchor="IPsec">

<front>
<title>Security Architecture for the Internet Protocol</title>
<author initials='S.' surname='Kent' fullname='S. Kent'>
<organization /></author>
<author initials='K.' surname='Seo' fullname='K. Seo'>
<organization /></author>
<date year='2005' month='December' />
<abstract>
<t>This document describes an updated version of the "Security Architecture for IP", which is designed to provide security services for traffic at the IP layer.  This document obsoletes RFC 2401 (November 1998). [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4301' />

<format type='TXT' octets='262123' target='http://www.rfc-editor.org/rfc/rfc4301.txt' />
</reference>

				
			<reference anchor="CAP">
				<front>
					<title>Chip Authentication Program Functional Architecture</title>
					<author>
						<organization> MasterCard International </organization>
					</author>
					<date month="September" year="2004"/>
				</front>
				<format type="TXT" octets="94506" target="http://www.rfc-editor.org/rfc/rfc2200.txt"/>
			</reference>
		



			<reference anchor="OATH" target="http://www.openauthentication.org">
				<front>
					<title>Initiative for Open AuTHentication</title>
					<author>
						<organization> </organization>
					</author>
					<date year=""/>
				</front>
			</reference>
			<reference anchor="XMLNS" target='http://www.w3.org/TR/1999/REC-xml-names-19990114'>
<front>
<title>Namespaces in XML</title>

<author initials='D.' surname='Hollander' fullname='Dave Hollander'>
    <organization />
</author>

<author initials='T.' surname='Bray' fullname='Tim Bray'>
    <organization />
</author>

<author initials='A.' surname='Layman' fullname='Andrew Layman'>
    <organization />
</author>

<date month='January' day='14' year='1999' />
</front>

<seriesInfo name='World Wide Web Consortium FirstEdition' value='REC-xml-names-19990114' />
<format type='HTML' target='http://www.w3.org/TR/1999/REC-xml-names-19990114' />
</reference>


						
		</references>
<?rfc rfcedstyle="yes" ?>

		<section title="Use Cases">

			<t>This section describes a comprehensive list of use cases that inspired the
				development of this specification. These requirements were used to derive the
				primary requirement that drove the design. These requirements are covered in the
				next section.</t>
			<t>These use cases also help in understanding the applicability of this specification to
				real-world situations.</t>
			<section title="Online Use Cases">

				<t>This section describes the use cases related to provisioning the keys using an
					online provisioning protocol.</t>

				<section title="Transport of Keys from Server to Cryptographic Module">
					<t>For example, a mobile device user wants to obtain a symmetric key for use
						with a cryptographic module on the device. The cryptographic module from
						vendor A initiates the provisioning process against a provisioning system
						from vendor B using a standards-based provisioning protocol. The provisioning entity delivers one or more keys in a
						standard format that can be processed by the mobile device.</t>

					<t>For example, in a variation of the above, instead of the user's mobile phone,
						a key is provisioned in the user's soft token application on a laptop using
						a network-based online protocol. As before, the provisioning system delivers
						a key in a standard format that can be processed by the soft token on the
						PC.</t>

					<t>For example, the end user or the key issuer wants to update or configure an
						existing key in the cryptographic module and requests a replacement key
						container. The container may or may not include a new key and may include
						new or updated key attributes such as a new counter value in HOTP key case,
						a modified response format or length, a new friendly name, etc.</t>

				</section>

				<section title="Transport of Keys from Cryptographic Module to Cryptographic Module">
					<t>For example, a user wants to transport a key from one cryptographic module to
						another. There may be two cryptographic modules, one on a computer and one on a
						mobile phone, and the user wants to transport a key from the computer to the
						mobile phone. The user can export the key and related data in a standard
						format for input into the other cryptographic module.</t>
				</section>

				<section title="Transport of Keys from Cryptographic Module to Server">
					<t>For example, a user wants to activate and use a new key and related data
						against a validation system that is not aware of this key. This key may be
						embedded in the cryptographic module (e.g., a Secure Digital (SD) card, USB drive) that the user
						has purchased at the local electronics retailer. Along with the
						cryptographic module, the user may get the key on a CD or a floppy in a
						standard format. The user can now upload via a secure online channel or
						import this key and related data into the new validation system and start
						using the key.</t>
				</section>

				<section title="Server-to-Server Bulk Import/Export of Keys">
					<t>From time to time, a key management system may be required to import or
						export keys in bulk from one entity to another. </t>
					<t>For example, instead of importing keys from a manufacturer using a file, a
						validation server may download the keys using an online protocol. The keys
						can be downloaded in a standard format that can be processed by a validation
						system.</t>
					<t>For example, in a variation of the above, an Over-The-Air (OTA) key
						provisioning gateway that provisions keys to mobile phones may obtain key
						material from a key issuer using an online protocol. The keys are delivered
						in a standard format that can be processed by the key provisioning gateway
						and subsequently sent to the mobile phone of the end user.</t>
				</section>
			</section>

			<section title="Offline Use Cases">
				<t>This section describes the use cases relating to offline transport of keys from
					one system to another, using some form of export and import model. </t>

				<section title="Server-to-Server Bulk Import/Export of Keys">
					<t>For example, cryptographic modules, such as OTP authentication tokens, may
						have their symmetric keys initialized during the manufacturing process in
						bulk, requiring copies of the keys and algorithm data to be loaded into the
						authentication system through a file on portable media. The manufacturer
						provides the keys and related data in the form of a file containing records
						in standard format, typically on a CD. Note that the token manufacturer and
						the vendor for the validation system may be the same or different. Some
						crypto modules will allow local PIN management (the device will have a PIN
						pad); hence, random initial PINs set at manufacturing should be transmitted
						together with the respective keys they protect.</t>
					<t>For example, an enterprise wants to port keys and related data from an
						existing validation system A into a different validation system B. The
						existing validation system provides the enterprise with a functionality that
						enables export of keys and related data (e.g., for OTP authentication tokens)
						in a standard format. Since the OTP tokens are in the standard format, the
						enterprise can import the token records into the new validation system B and
						start using the existing tokens. Note that the vendors for the two
						validation systems may be the same or different. </t>
				</section>

			</section>
		</section>
		<section title="Requirements">
			<t>This section outlines the most relevant requirements that are the basis of this work.
				Several of the requirements were derived from use cases described above. <list
					style="format R%d:">
					<t>The format MUST support the transport of multiple types of symmetric keys and
						related attributes for algorithms including HOTP, other OTP,
						Challenge/Response, etc.</t>
					<t>The format MUST handle the symmetric key itself as well of attributes that
						are typically associated with symmetric keys. Some of these attributes may
						be <list style="symbols">
							<t>Unique Key Identifier</t>
							<t>Issuer information</t>
							<t>Algorithm ID</t>
							<t>Algorithm mode</t>
							<t>Issuer Name</t>
							<t>Key friendly name</t>
							<t>Event counter value (moving factor for OTP algorithms)</t>
							<t>Time value</t>
						</list>
					</t>
					<t>The format SHOULD support both offline and online scenarios. That is, it
						should be serializable to a file as well as it should be possible to use
						this format in online provisioning protocols.</t>
					<t>The format SHOULD allow bulk representation of symmetric keys.</t>
					<t>The format SHOULD allow bulk representation of PINs related to specific keys.</t>
					<t>The format SHOULD be portable to various platforms. Furthermore, it SHOULD be
						computationally efficient to process.</t>
					<t>The format MUST provide an appropriate level of security in terms of data
						encryption and data integrity. </t>
					<t>For online scenarios, the format SHOULD NOT rely on transport layer security
						(e.g., Secure Socket Layer/Transport Layer Security (SSL/TLS)) for core security requirements.</t>
					<t>The format SHOULD be extensible. It SHOULD enable extension points allowing
						vendors to specify additional attributes in the future.</t>
					<t>The format SHOULD allow for distribution of key derivation data without the
						actual symmetric key itself. This is to support symmetric key management
						schemes that rely on key derivation algorithms based on a pre-placed master
						key. The key derivation data typically consists of a reference to the key,
						rather than the key value itself.</t>
					<t>The format SHOULD allow for additional life cycle management operations such
						as counter resynchronization. Such processes require confidentiality between
						client and server, thus could use a common secure container format, without
						the transfer of key material.</t>
					<t>The format MUST support the use of pre-shared symmetric keys to ensure
						confidentiality of sensitive data elements. </t>
					<t>The format MUST support a password-based encryption (PBE) <xref
							target="PKCS5"/> scheme to ensure security of sensitive data elements.
						This is a widely used method for various provisioning scenarios.</t>
					<t>The format SHOULD support asymmetric encryption algorithms such as RSA to
						ensure end-to-end security of sensitive data elements. This is to support
						scenarios where a pre-set shared key encryption key is difficult to use.
					</t>
				</list>
			</t>
		</section>
	</back>

</rfc>
