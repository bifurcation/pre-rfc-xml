<?xml version="1.0" encoding="US-ASCII"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc ipr="trust200902" number="8225" category="std" submissionType="IETF" consensus="yes">

  <front>
    <title abbrev="PASSporT">PASSporT: Personal Assertion Token</title>

    <author initials="C." surname="Wendt" fullname="Chris Wendt">
      <organization>Comcast</organization>
      <address>
        <postal>
          <street>One Comcast Center</street>
          <city>Philadelphia</city>
          <region>PA</region>
          <code>19103</code>
          <country>United States of America</country>
        </postal>
        <email>chris-ietf@chriswendt.net</email>
      </address>
    </author>

    <author initials="J." surname="Peterson" fullname="Jon Peterson">
      <organization>Neustar Inc.</organization>
      <address>
        <postal>
          <street>1800 Sutter St. Suite 570</street>
          <city>Concord</city>
          <region>CA</region>
          <code>94520</code>
          <country>United States of America</country>
        </postal>
        <email>jon.peterson@neustar.biz</email>
      </address>
    </author>

    <date year="2018" month="February"/>

    <abstract>

<t>This document defines a method for creating and validating a token that
cryptographically verifies an originating identity or, more generally, a URI
or telephone number representing the originator of personal communications.
The Personal Assertion Token, PASSporT, is cryptographically signed to protect
the integrity of the identity of the originator and to verify the assertion of
the identity information at the destination. The cryptographic signature is
defined with the intention that it can confidently verify the originating
persona even when the signature is sent to the destination party over an
insecure channel. PASSporT is particularly useful for many
personal-communications applications over IP networks and other multi-hop
interconnection scenarios where the originating and destination parties may
not have a direct trusted relationship.</t>
    </abstract>

  </front>

<middle>

<section anchor="introduction" title="Introduction">

<t>In today's IP-enabled telecommunications world, there is a growing concern
about the ability to trust incoming invitations for communications sessions,
including video, voice, and messaging <xref target="RFC7340"/>. As an example,
modern telephone networks provide the ability to spoof the calling party's
telephone number for many legitimate purposes, including providing network
features and services on behalf of a legitimate telephone number. However,
as we have seen, bad actors have taken advantage of this ability for
illegitimate and fraudulent purposes meant to trick telephone users into
believing that they are someone they are not. This problem can be extended to
many emerging forms of personal communications.</t>

<t>This document defines a method for creating and validating a token that
cryptographically verifies an originating identity or, more generally, a URI
or telephone number representing the originator of personal
communications. Through the extensions defined in
<xref target="extending_passport"/> of this document, other information
relevant to the personal communications can also be added to the token. The
goal of PASSporT is to provide a common framework for signing information
related to the originating identity in an extensible way. Additionally, this
functionality is independent of any specific call logic for
personal&nbhy;communications signaling, so that the assertion of
information related to the originating identity can be implemented in a
flexible way and can be used in such applications as end&nbhy;to&nbhy;end
applications that require different signaling protocols or gateways
between different communications systems. It is anticipated that guidance
specific to the signaling protocol will be provided in other related documents
and specifications to specify how to use and transport PASSporTs; however,
this is intentionally out of scope for this document.</t>

<t><xref target="RFC8224"/> provides details of the use of PASSporT
within the SIP <xref target="RFC3261"/> signaling protocol for the
signing and verification of telephone numbers and SIP URIs.</t>

</section>

<section anchor="terminology" title="Terminology">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
"SHALL&nbsp;NOT", "SHOULD", "SHOULD&nbsp;NOT", "RECOMMENDED",
"NOT&nbsp;RECOMMENDED", "MAY", and "OPTIONAL" in this document
are to be interpreted as described in BCP&nbsp;14
<xref format="default" pageno="false" target="RFC2119"/>
<xref format="default" pageno="false" target="RFC8174"/> when,
and only when, they appear in all capitals, as shown here.</t>

</section>

<section anchor="passport_overview" title="PASSporT Overview">

<t>"JSON Web Token (JWT)" <xref target="RFC7519"/>, "JSON Web Signature (JWS)"
<xref target="RFC7515"/>, and other related specifications define a standard
token format that can be used as a way of encapsulating claimed or asserted
information with an associated digital signature using X.509-based
certificates. JWT provides a set of claims in JSON format that can
conveniently accommodate asserted originating-identity information and that
are easily extensible for use in the extension mechanisms defined below.
Additionally, JWS provides a path for updating methods and cryptographic
algorithms used for the associated digital signatures.</t>

<t>JWS defines the use of JSON data structures in a specified canonical format
for signing data corresponding to the JSON Object Signing and Encryption (JOSE)
Header, JWS Payload, and JWS Signature. JWT defines a set of claims that are
represented by specified JSON objects that can be extended with custom keys
for specific applications. The next sections define the header and claims that
MUST be minimally used with JWT and JWS for PASSporT.</t>

<t>PASSporT specifically uses this token format and defines claims that convey
the identity of the origination and destination of personal communications.
The primary value asserted in a PASSporT object is the originating identity
representing the identity of the calling party or the initiator of a
personal&nbhy;communications session. The signer of a PASSporT object may or
may not correspond to the originating identity. For a given application's use
or using protocol of PASSporT, the creation of the PASSporT object is
performed by an entity that is authoritative to assert the caller's
identity. This authority is represented by the certificate credentials and the
signature, and the PASSporT object is created and initiated to the
destination(s) per the application's choice of authoritative point(s) in the
network. For example, the PASSporT object could be created at a device that
has authenticated with a user or at a network entity with an authenticated
trust relationship with that device and its user. Destination identities
represent the intended destination of the personal communications, i.e., the
identity(s) being called by the caller. The destination point or points
determined by the application need to have the capability to verify the
PASSporT and the digital signature. The PASSporT-associated certificate is
used to validate the authority of the originating signer, generally via a
certificate chain to the trust anchor for that application.</t>

</section>

<section anchor="passport_header" title="PASSporT Header">

<t>The JWS token header is a JOSE Header
(<xref target="RFC7515"/>, Section&nbsp;4) that defines the type and
encryption algorithm used in the token.</t>

<t>The PASSporT header should include, at a minimum, the Header Parameters
defined in the next three subsections.</t>

<section anchor="typ-type-header-parameter" title="&quot;typ&quot; (Type) Header Parameter">

<t>The "typ" (Type) Header Parameter is defined in JWS
(<xref target="RFC7515"/>, Section 4.1.9) to declare the media type
of the complete JWS.</t>

<t>For the PASSporT, the "typ" header MUST be the string "passport".
This signifies that the encoded token is a JWT of type "passport".</t>

</section>

<section anchor="alg-algorithm-header-parameter" title="&quot;alg&quot; (Algorithm) Header Parameter">

<t>The "alg" (Algorithm) Header Parameter is defined in JWS
(<xref target="RFC7515"/>, Section&nbsp;4.1.1). This definition includes the
ability to specify the use of a cryptographic algorithm for the signature part
of the JWS. It also refers to a list of defined "alg" values as part of a
registry established by JSON Web Algorithms (JWA)
(<xref target="RFC7518"/>, Section&nbsp;3.1).</t>

<t>For the creation and verification of PASSporTs and their digital
signatures, implementations MUST support ES256 as defined in JWA
(<xref target="RFC7518"/>, Section&nbsp;3.4). Implementations MAY support other
algorithms registered in the "JSON Web Signature and Encryption Algorithms"
registry created by <xref target="RFC7518"/>. The contents of that registry
may be updated in the future, depending on cryptographic strength requirements
guided by current security best practices. The mandatory-to-support algorithm
for PASSporTs may likewise be updated in future updates to this
document.</t>

<t>Implementations of PASSporT digital signatures using ES256 as defined above
SHOULD use the deterministic Elliptic Curve Digital Signature Algorithm (ECDSA)
if or when supported for the reasons stated in <xref target="RFC6979"/>.</t>

</section>

<section anchor="x5u-x509-url-header-parameter" title="&quot;x5u&quot; (X.509 URL) Header Parameter">

<t>As defined in JWS (<xref target="RFC7515"/>, Section&nbsp;4.1.5),
the "x5u" Header Parameter defines a URI <xref target="RFC3986"/> referring to
the resource for the X.509 public key certificate or certificate chain <xref
target="RFC5280"/> corresponding to the key used to digitally sign the
JWS. Generally, as defined in JWS
(<xref target="RFC7515"/>, Section&nbsp;4.1.5), this would correspond to
an HTTPS or DNSSEC resource using integrity protection.</t>

</section>
<section anchor="example-passport-header" title="Example PASSporT Header">

<t>An example of the header would be the following, including the specified
passport type, ES256 algorithm, and a URI referencing the network location of
the certificate needed to validate the PASSporT signature.</t>

<figure><artwork><![CDATA[
{
  "typ":"passport",
  "alg":"ES256",
  "x5u":"https://cert.example.org/passport.cer"
}
]]></artwork></figure>

</section>
</section>

<section anchor="passport_payload" title="PASSporT Payload">

<t>The token claims consist of the information that needs to be verified at
the destination party. These claims follow the definition of a JWT claim
(<xref target="RFC7519"/>, Section&nbsp;4) and are encoded as defined by the
JWS Payload (<xref target="RFC7515"/>, Section&nbsp;3).</t>

<t>PASSporT defines the use of a standard JWT-defined claim as well as custom
claims corresponding to the two parties associated with personal
communications -- the originator and destination, as detailed below.</t>

<t>For PASSporT, any claim names MUST use the ASCII character set.
Any claim values can contain characters that are outside the ASCII range,
consistent with the rules of creating a JWT Claims Set as defined in
<xref target="RFC7519"/>, Section&nbsp;7.1.
</t>

<section anchor="jwt-defined-claims" title="JWT-Defined Claims">

<section anchor="iat-issued-at-claim" title="&quot;iat&quot; (Issued At) Claim">

<t>The JSON claim MUST include the "iat" (Issued At) claim
(<xref target="RFC7519"/>, Section&nbsp;4.1.6).
As defined, the "iat" claim should be set to the date and time of issuance of
the JWT and MUST indicate the date and time of the origination of the personal
communications. The time value should be of the NumericDate format as
defined in <xref target="RFC7519"/>, Section&nbsp;2. This is included for
securing the token against replay and cut-and-paste attacks, as explained
further in <xref target="security_considerations"/> ("Security
Considerations").</t>

</section>
</section>

<section anchor="passport_claims" title="PASSporT-Specific Claims">

<section anchor="orig_dest" title="Originating and Destination Identity Claims">

<t>The originating identity and the destination identity are represented by
two claims that are required for PASSporT -- the "orig" and "dest" claims.
Both "orig" and "dest" MUST contain claim values that are identity claim
JSON objects where the child claim name represents an identity type and the
claim value is the identity string, both defined in subsequent
subsections. Currently, these identities can be represented as either
telephone numbers or Uniform Resource Indicators (URIs).</t>

<t>The "orig" claim is a JSON object with the claim name of "orig" and a claim
value that is a JSON object representing the asserted identity of any type
(currently either "tn" or "uri") of the originator of the
personal-communications signaling.  There MUST be exactly one "orig" claim
with exactly one identity claim object in a PASSporT object.</t>

<t>Note: As explained in <xref target="passport_overview"/>, the
originating identity represents the calling party and may or may not
correspond to the authoritative signer of the token.</t>

<t>The "dest" claim is a JSON object with the claim name of "dest" and MUST
have at least one identity claim object. The "dest" claim value is an
array containing one or more identity claim JSON objects representing the
destination identities of any type (currently "tn" or "uri"). If the "dest"
claim value array contains both "tn" and "uri" claim names, the JSON object
should list the "tn" array first and the "uri" array second. Within the "tn"
and "uri" arrays, the identity strings should be put in lexicographical order,
including the scheme-specific portion of the URI characters.</t>

<t>Note: As explained in <xref target="passport_overview"/>, the
destination identity represents the called party and may or may not correspond
to the authoritative party verifying the token signature.</t>

<section anchor="tn-telephone-number-identity" title="&quot;tn&quot; (Telephone Number) Identity">

<t>If the originating or destination identity is a telephone number, the claim
name representing the identity MUST be "tn".</t>

<t>The claim value for the "tn" claim is the telephone number and MUST be
canonicalized according to the procedures specified in <xref
target="RFC8224"/>, Section&nbsp;8.3.</t>

</section>

<section anchor="uri-uri-identity" title="&quot;uri&quot; (URI) Identity">

<t>If any of the originating or destination identities is in the form of a
URI as defined in <xref target="RFC3986"/>, the claim name representing the
identity MUST be "uri", and the claim value is the URI form of the
identity.</t>

</section>

<section anchor="future-identity-forms" title="Future Identity Forms">

<t>We recognize that in the future there may be other standard mechanisms for
representing identities. The "orig" and "dest" claims currently support "tn"
and "uri" but could be extended in the future to allow for other identity
types with new IANA-registered unique types to represent these forms.</t>

</section>

<section anchor="passport_payload_example" title="Examples">

<t>The following is an example of a single originator with telephone number
identity +12155551212, to a single destination with URI identity
"sip:alice@example.com":</t>

<figure><artwork><![CDATA[
{
  "dest":{"uri":["sip:alice@example.com"]},
  "iat":1443208345,
  "orig":{"tn":"12155551212"}
}
]]></artwork></figure>

<t>The following is an example of a single originator with telephone number
identity +12155551212, to multiple destination identities with
telephone number identity +12125551212 and two URI identities --
"sip:alice@example.com" and "sip:bob@example.com":
</t>

<figure><artwork><![CDATA[
{
  "dest":{
    "tn":["12125551212"],
    "uri":["sip:alice@example.com",
      "sip:bob@example.net"]
  },
  "iat":1443208345,
  "orig":{"tn":"12155551212"}
}
]]></artwork></figure>

</section>
</section>

<section anchor="mky" title="&quot;mky&quot; (Media Key) Claim">

<t>Some protocols that use PASSporT may also want to protect media security
keys delivered within their signaling in order to bind those keys to the
identities established in the signaling layers. The "mky" claim is an optional
PASSporT claim defining the assertion of media key fingerprints carried in
the Session Description Protocol (SDP) <xref target="RFC4566"/> via the
"a=fingerprint" attribute (<xref target="RFC4572"/>, Section&nbsp;5).
This claim can support either a single fingerprint or multiple fingerprints
appearing in a single SDP body corresponding to one or more media streams
offered as defined in <xref target="RFC8122"/>.</t>

<t>The "mky" claim MUST be formatted as a JSON object with an array that
includes the "alg" and "dig" claims with the corresponding algorithm and
hexadecimal values. If there is more than one fingerprint value associated
with different media streams in SDP, the fingerprint values MUST be
constructed as a JSON array denoted by square brackets ("[" and "]").
For the "dig" claim, the claim value MUST be the hash of the
hexadecimal value without any colons.</t>

<t>The "mky" claim is a JSON object with a claim name of "mky" and a claim
value of a JSON array denoted by brackets.  The "mky" claim value JSON array
MUST be constructed as follows:</t>

<t><list style="numbers">
  <t>Take each "a=fingerprint" line carried in the SDP.</t>

  <t>Sort the lines based on the UTF-8 <xref target="RFC3629"/> encoding
  of the concatenation of the "alg" and "dig" claim value strings.</t>
  <t>Encode the array in the order of the sorted lines, where each "mky" array
  element is a JSON object with two elements corresponding to the "alg" and
  "dig" objects, with "alg" first and "dig" second.</t>
</list></t>

<t>An example claim with the "mky" claim is as follows:</t>

<t>For an SDP offer that includes the following fingerprint values,</t>

<figure><artwork><![CDATA[
a=fingerprint:sha-256 4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:
5D:49:6B:19:E5:7C:AB:3E:4B:65:2E:7D:46:3F:54:42:CD:54:F1
a=fingerprint:sha-256 02:1A:CC:54:27:AB:EB:9C:53:3F:3E:4B:65
:2E:7D:46:3F:54:42:CD:54:F1:7A:03:A2:7D:F9:B0:7F:46:19:B2
]]></artwork></figure>

<t>the PASSporT Payload object would be:</t>

<figure><artwork><![CDATA[
{
  "dest":{"uri":["sip:alice@example.com"]},
  "iat":1443208345,
  "mky":[
    {
      "alg":"sha-256",
      "dig":"021ACC5427ABEB9C533F3E4B652E7D463F5442CD54
        F17A03A27DF9B07F4619B2"
    },
    {
      "alg":"sha-256",
      "dig":"4AADB9B13F82183B540212DF3E5D496B19E57C
        AB3E4B652E7D463F5442CD54F1"
    }
  ],
  "orig":{"tn":"12155551212"}
}
]]></artwork></figure>

</section>
</section>
</section>

<section anchor="passport_signature" title="PASSporT Signature">

<t>The signature of the PASSporT is created as specified by JWS
(<xref target="RFC7515"/>, Section&nbsp;5.1, Steps&nbsp;1 through 6).
PASSporT MUST use the JWS Protected Header. For the JWS Payload and the JWS
Protected Header, however, the lexicographic ordering and whitespace rules
described in Sections&nbsp;<xref target="passport_header" format="counter"/>
and <xref target="passport_payload" format="counter"/> of this document,
and the JSON serialization rules in <xref target="json_serialization"/> of
this document, MUST be followed.
</t>

<t><xref
target="example-es256-based-passport-jws-serialization-and-signature"/> of
this document has a detailed example of how to follow the steps to create
the JWS Signature.
</t>

<t>Step 7 of the JSON serialization procedure in
<xref target="RFC7515"/>, Section&nbsp;5.1 is not supported for PASSporT.</t>


<t><xref target="RFC7515"/>, Section&nbsp;5.1, Step&nbsp;8 describes
the method to create the final JWS Compact Serialization form of the PASSporT.
</t>

</section>
<section anchor="compact_form_of_passport" title="Compact Form of PASSporT">

<t>For a using protocol of PASSporT, the PASSporT claims as well as the
PASSporT header may include redundant or default information that could be
reconstructed at the destination based on information provided in the
signaling protocol transporting the PASSporT object. In this case, it may be
advantageous to have a more compact form of PASSporT to save the transmission
of the bytes needed to represent the header and claims.</t>

<t>This specification defines the compact form of the PASSporT, in the
spirit of the form defined in <xref target="RFC7515"/>, Appendix&nbsp;F, with
the use of two periods ("..") to represent the header and claim objects being
removed, followed by the PASSporT signature as defined in <xref
target="passport_signature"/>, and the need for the destination to reconstruct
the header and claim objects in order to verify the signature.</t>

<t>In order to construct the compact form of the PASSporT string, the
procedure described in <xref target="passport_signature"/> MUST be used,
with the exception of <xref target="RFC7515"/>, Section&nbsp;5.1, Step&nbsp;8.
This step would be replaced by the following construction of the compact form
of PASSporT, ".." || BASE64URL(JWS Signature).</t>

<t>The using protocol of the compact form of PASSporT MUST be accompanied by a
specification for how the header and claims objects can be reconstructed from
information in the signaling protocol being used.</t>

<t>Note that the full form of the PASSporT, containing the entire
header, payload, and signature, should also use the lexicographic ordering and
whitespace serialization rules, particularly in the case where some using
protocols or interworking between protocols may require switching between full
and compact forms and maintaining the integrity of the signature.</t>

<section anchor="example-compact-form-passport" title="Example Compact
Form of PASSporT">

<t>The compact form of the following example token (with line breaks
between periods used for readability purposes only)
</t>

<figure><artwork><![CDATA[
eyJhbGciOiJFUzI1NiIsInR5cCI6InBhc3Nwb3J0IiwieDV1IjoiaHR0cHM6Ly9j
ZXJ0LmV4YW1wbGUub3JnL3Bhc3Nwb3J0LmNlciJ9
.
eyJkZXN0Ijp7InVyaSI6WyJzaXA6YWxpY2VAZXhhbXBsZS5jb20iXX0sImlhdCI
6IjE0NDMyMDgzNDUiLCJvcmlnIjp7InRuIjoiMTIxNTU1NTEyMTIifX0
.
rq3pjT1hoRwakEGjHCnWSwUnshd0-zJ6F1VOgFWSjHBr8Qjpjlk-cpFYpFYsojN
CpTzO3QfPOlckGaS6hEck7w
]]></artwork></figure>

<t>would be as follows:</t>

<figure><artwork><![CDATA[
..rq3pjT1hoRwakEGjHCnWSwUnshd0-zJ6F1VOgFWSjHBr8Qjpjlk-cpFYpFYsojN
CpTzO3QfPOlckGaS6hEck7w
]]></artwork></figure>

</section>
</section>
<section anchor="extending_passport" title="Extending PASSporT">

<t>PASSporT includes the bare-minimum set of claims needed to securely assert
the originating identity and support the secure properties discussed in
various parts of this document. JWT supports a straightforward way to add
additional asserted or signed information by simply adding new
claims. PASSporT can be extended beyond the defined base set of claims to
represent other information requiring assertion or validation beyond the
originating identity itself as needed.</t>

<section anchor="ppt" title="&quot;ppt&quot; (PASSporT) Header Parameter">

<t>Any using protocol can extend the payload of PASSporT with additional
JWT claims. JWT claims are managed by the "JSON Web Token Claims"
IANA registry as defined in <xref target="RFC7519"/>,
Section&nbsp;10.1. Implementations of PASSporT MUST support the baseline
claims defined in <xref target="passport_claims"/> and MAY support extended
claims. If it is necessary for an extension to PASSporT to require that a
relying party support a particular extended claim or set of claims in the
PASSporT object, it can do so by specifying a "ppt" element for the PASSporT
JOSE Header. All values of "ppt" need to be defined in a specification that
associates the new value of the "ppt" element with the required claims and
behaviors. Relying parties MUST fail to validate PASSporT objects containing
an unsupported "ppt".</t>

<t>Using protocols MUST explicitly define how they carry each claim and the
rules for how the header and payload objects are constructed beyond the
lexicographical and serialization rules defined in this document.</t>

<t>Using protocols that carry the compact form of PASSporT 
(<xref target="compact_form_of_passport"/>) instead of the full form MUST
use only mandatory extensions signaled with "ppt" -- if a using protocol were
to add additional optional claims to a PASSporT object it carried in compact
form, relying parties would have no way to reconstruct the token. Moreover,
using protocols that support the compact form of PASSporT MUST have some field
to signal "ppt" to relying parties, as the compact form of PASSporT omits the
JOSE Header.</t>

</section>

<section anchor="example-extended-passport-header" title="Example Extended PASSporT Header">

<t>An example header with a PASSporT extension type of "foo" is as follows:</t>

<figure><artwork><![CDATA[
{
  "alg":"ES256",
  "ppt":"foo",
  "typ":"passport",
  "x5u":"https://tel.example.org/passport.cer"
}
]]></artwork></figure>

</section>
<section anchor="extended-passport-claims" title="Extended PASSporT Claims">

<t>Specifications that define extensions to the PASSporT mechanism MUST
explicitly specify what claims they include beyond the base set of claims from
this document, the order in which they will appear, and any further
information necessary to implement the extension. All extensions MUST include
the baseline PASSporT claim elements specified in <xref
target="passport_payload"/>; claims may only be appended to the claims object
specified; they can never be removed or reordered. Specifying new claims
follows the baseline JWT procedures (<xref target="RFC7519"/>,
Section&nbsp;10.1). Understanding an extension or new claims defined by the
extension on the destination verification of the PASSporT is
optional. The creator of a PASSporT object cannot assume that destination
systems will understand any given extension. Verification of PASSporTs
by destination systems that do support an extension may then trigger
appropriate application-level behavior in the presence of an extension;
authors of extensions should provide appropriate extension-specific guidance
to application developers on this point.</t>

<t>An example set of extended claims, extending the first example in <xref
target="passport_payload_example"/> using "bar" as the newly defined claim,
would be as follows:</t>

<figure><artwork><![CDATA[
{
  "bar":"beyond all recognition"
  "dest":{"uri":["sip:alice@example.com"]},
  "iat":1443208345,
  "orig":{"tn":"12155551212"}
}
]]></artwork></figure>

</section>
</section>
<section anchor="json_serialization" title="Deterministic JSON Serialization">

<t>JSON objects can include spaces and line breaks, and key value pairs can
occur in any order. It is therefore a non-deterministic string format. In
order to make the digital signature verification work deterministically, the
JSON representation of the JWS Protected Header object and JWS Payload object
MUST be computed as follows.</t>

<t>The JSON object MUST follow the following rules.  These rules are based on
the thumbprint of a JSON Web Key (JWK) as defined in Section&nbsp;3
Step 1 of <xref target="RFC7638"/>.</t>

<t><list style="numbers">
  <t>The JSON object MUST contain no whitespace or line breaks before or after
  any syntactic elements.</t>
  <t>JSON objects MUST have the keys ordered lexicographically by the Unicode
  <xref target="UNICODE"/> code points of the member names.</t>
  <t>JSON value literals MUST be lowercase.</t>
  <t>JSON numbers are to be encoded as integers unless the field is defined to
  be encoded otherwise.</t>
  <t>Encoding rules MUST be applied recursively to member values and array
  values.</t>
</list></t>

<t>Note: For any PASSporT extension claims, member names within the scope of a
JSON object MUST NOT be equal to other member names; otherwise, serialization
will not be deterministic.</t>

<section anchor="example-passport-deterministic-json-form" title="Example PASSporT Deterministic JSON Form">

<t>This section demonstrates the deterministic JSON serialization for the
example PASSporT Payload shown in <xref target="passport_payload_example"/>.
</t>

<t>The initial JSON object is shown here:</t>

<figure><artwork><![CDATA[
{
  "dest":{"uri":["sip:alice@example.com"]},
  "orig":{"tn":"12155551212"}
  "iat":1443208345,
  "mky":[
    {
      "alg":"sha-256",
      "dig":"021ACC5427ABEB9C533F3E4B652E7D463F5442CD54
        F17A03A27DF9B07F4619B2"
    },
    {
      "alg":"sha-256",
      "dig":"4AADB9B13F82183B540212DF3E5D496B19E57C
        AB3E4B652E7D463F5442CD54F1"
    }
  ],
}
]]></artwork></figure>

<t>The parent members of the JSON object are as follows:</t>

<t><list style="symbols">
  <t>"dest"</t>
  <t>"orig"</t>
  <t>"iat"</t>
  <t>"mky"</t>
</list></t>

<t>Their lexicographic order is:</t>

<t><list style="symbols">
  <t>"dest"</t>
  <t>"iat"</t>
  <t>"mky"</t>
  <t>"orig"</t>
</list></t>

<t>The final constructed deterministic JSON serialization representation,
with whitespace and line breaks removed (with line breaks used for display
purposes only), is:</t>

<figure><artwork><![CDATA[
{"dest":{"uri":["sip:alice@example.com"],"iat":1443208345,"mky":
[{"alg":"sha-256","dig":"021ACC5427ABEB9C533F3E4B652E7D463F5442CD5
4F17A03A27DF9B07F4619B2"},{"alg":"sha-256","dig":"4AADB9B13F82183B5
40212DF3E5D496B19E57CAB3E4B652E7D463F5442CD54F1"}],
"orig":{"tn":"12155551212"}}
]]></artwork></figure>

</section>
</section>

<section anchor="security_considerations" title="Security Considerations">

<section anchor="avoidance-of-replay-and-cut-and-paste-attacks" title="Avoidance of Replay and Cut-and-Paste Attacks">

<t>There are a number of security considerations regarding the use of the
token for the avoidance of replay and cut-and-paste attacks. PASSporTs
SHOULD only be sent with application-level protocol information (e.g.,
for SIP, an INVITE as defined in <xref target="RFC3261"/>) corresponding to
the required fields in the token. A unique set of token claims and token
signature is constructed using the originating identity being asserted
with the "orig" claim along with the following two claims:</t>

<t><list style="symbols">
  <t>The "iat" claim should correspond to a date/time that the message was
  originated. It should also be within a relative time that is reasonable for
  clock drift and transmission time characteristics associated with the
  application using the PASSporT. Therefore, validation of the token
  should consider date and time correlation, which could be influenced by
  usage specific to the signaling protocol and by network time differences.</t>
  <t>The "dest" claim is included to further restrict the use of a valid
  PASSporT being sent as a replay attack to other destination parties. The
  verification of the PASSporT at the destination should verify that the
  "dest" claim matches the destination party as the intended recipient of
  the message.</t>
</list></t>

</section>
<section anchor="solution-considerations" title="Solution Considerations">

<t>The use of PASSporTs based on the validation of the digital signature
and the associated certificate requires consideration of the authentication
and authority or reputation of the signer to attest to the identity being
asserted. The following considerations should be recognized when using
PASSporT:</t>

<t><list style="symbols">
  <t>The use of this token should not, in its own right, be considered a full
  solution for absolute non-repudiation of the identity being asserted.</t>

  <t>In many applications, the signer and the end user represented by the
  asserted identity may not be one and the same. For example, when a
  service provider signs and validates the token on behalf of the user
  consuming the service, the provider MUST have an authenticated and secure
  relationship with the end user or the device initiating and terminating the
  communications signaling.</t>

  <t>Applications that use PASSporT should ensure that the verification
  of the signature includes a means for verifying that the signer is
  authoritative through the use of an application-specific or
  service-specific set of common trust anchors for the application.</t>
</list></t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<section anchor="media-type-registration" title="Media Type Registration">

<t>This section registers the "application/passport" media type
(see <xref target="RFC2046"/> for the definition of "media type")
in the "Media Types" registry in the manner described in
<xref target="RFC6838"/>, to indicate that the content is a
PASSporT-defined JWT.</t>

<t><list style="symbols">
  <t>Type name: application</t>
  <t>Subtype name: passport</t>
  <t>Required parameters: N/A</t>
  <t>Optional parameters: N/A</t>

  <t>Encoding considerations: 8bit; application/passport values are encoded as
  a series of base64url-encoded values (some of which may be the empty string)
  separated by period (".") characters.</t>

  <t>Security considerations: See the Security Considerations section of <xref
  target="RFC7515"/>.</t>

  <t>Interoperability considerations: N/A</t>
  <t>Published specification: RFC 8225</t>

  <t>Applications that use this media type: Secure Telephone Identity Revisited
  (STIR) and other applications that require identity&nbhy;related assertion
  </t>

  <t>Fragment identifier considerations: N/A</t>

  <t>Additional information:
  <list style="empty">
    <t>Magic number(s): N/A</t>
    <t>File extension(s): N/A</t>
    <t>Macintosh file type code(s): N/A</t>
  </list></t>

  <t>Person &amp; email address to contact for further information: Chris
  Wendt, chris-ietf@chriswendt.net</t>

  <t>Intended usage: COMMON</t>
  <t>Restrictions on usage: none</t>
  <t>Author: Chris Wendt &lt;chris-ietf@chriswendt.net&gt;</t>
  <t>Change Controller: IESG</t>
  <t>Provisional registration?  No</t>
</list></t>

</section>

<section anchor="json-web-token-claims-registration" title="Registrations in &quot;JSON Web Token Claims&quot;">

<?rfc subcompact="yes"?>
<t><list style="empty">
  <t>Claim Name: "orig"</t>
  <t>Claim Description: Originating Identity String</t>
  <t>Change Controller: IESG</t>
  <t>Reference: <xref target="orig_dest"/> of RFC 8225</t>
</list></t>
<t><list style="empty">
  <t>Claim Name: "dest"</t>
  <t>Claim Description: Destination Identity String</t>
  <t>Change Controller: IESG</t>
  <t>Reference: <xref target="orig_dest"/> of RFC 8225</t>
</list></t>
<t><list style="empty">
  <t>Claim Name: "mky"</t>
  <t>Claim Description: Media Key Fingerprint String</t>
  <t>Change Controller: IESG</t>
  <t>Reference: <xref target="mky"/> of RFC 8225</t>
</list></t>
<?rfc subcompact="no"?>

</section>

<section anchor="json-web-signature-and-encryption-header-parameter-registry"
	 title="Registration in &quot;JSON Web Signature and Encryption Header Parameters&quot;">

<?rfc subcompact="yes"?>
<t><list style="empty">
  <t>Header Parameter Name: "ppt"</t>
  <t>Header Parameter Description: PASSporT extension identifier</t>
  <t>Header Parameter Usage Location(s): JWS</t>
  <t>Change Controller: IESG</t>
  <t>Reference: <xref target="ppt"/> of RFC 8225</t>
</list></t>
<?rfc subcompact="no"?>

</section>

<section anchor="passport-extension-registry-request" title="PASSporT Extensions Registry">

<t>The IANA has created a new PASSporT Type registry for "ppt"
parameter values. That parameter and its values are defined in <xref
target="ppt"/>. New registry entries must contain the name of the "ppt"
parameter value and the specification in which the value is described. The
policy for this registry is Specification Required <xref target="RFC8126"/>.
</t>

</section>
</section>

  </middle>

  <back>

    <references title='Normative References'>

<?rfc include="reference.RFC.2046"?>
<?rfc include="reference.RFC.2119"?>
<?rfc include="reference.RFC.3629"?>
<?rfc include="reference.RFC.3986"?>
<?rfc include="reference.RFC.4566"?>
<?rfc include="reference.RFC.4572"?>
<?rfc include="reference.RFC.6838"?>
<?rfc include="reference.RFC.6979"?>
<?rfc include="reference.RFC.7515"?>
<?rfc include="reference.RFC.7518"?>
<?rfc include="reference.RFC.7519"?>
<?rfc include="reference.RFC.7638"?>
<?rfc include="reference.RFC.8122"?>
<?rfc include="reference.RFC.8174"?>

<!-- draft-ietf-stir-rfc4474bis (RFC 8224) -->
<reference anchor="RFC8224" target="https://www.rfc-editor.org/info/rfc8224">
<front>
<title>Authenticated Identity Management in the Session Initiation Protocol (SIP)</title>
<author initials='J' surname='Peterson' fullname='Jon Peterson'>
    <organization />
</author>
<author initials='C' surname='Jennings' fullname='Cullen Jennings'>
    <organization />
</author>
<author initials='E' surname='Rescorla' fullname='Eric Rescorla'>
    <organization />
</author>
<author initials='C' surname='Wendt' fullname='Chris Wendt'>
    <organization />
</author>
<date month='February' year='2018' />
</front>
<seriesInfo name="RFC" value="8224"/>
<seriesInfo name="DOI" value="10.17487/RFC8224"/>
</reference>

<reference anchor="UNICODE" target="http://www.unicode.org/versions/latest/">
  <front>
    <title>The Unicode Standard</title>
    <author >
      <organization>The Unicode Consortium</organization>
    </author>
    <date/>
  </front>
</reference>

</references>

<references title='Informative References'>

<?rfc include="reference.RFC.3261"?>
<?rfc include="reference.RFC.5280"?>
<?rfc include="reference.RFC.7340"?>
<?rfc include="reference.RFC.8126"?>

</references>


<section anchor="example-es256-based-passport-jws-serialization-and-signature" title="Example ES256-Based PASSporT JWS Serialization and Signature">

<t>For PASSporT, there will always be a JWS with the following members:</t>

<t><list style="symbols">
  <t>"protected", with the value BASE64URL(UTF8(JWS Protected Header))</t>
  <t>"payload", with the value BASE64URL(JWS Payload)</t>
  <t>"signature", with the value BASE64URL(JWS Signature)</t>
</list></t>

<t>This example will follow the steps in JWS (<xref target="RFC7515"/>,
Section&nbsp;5.1, Steps 1-6 and 8); it incorporates the additional
serialization steps required for PASSporT.</t>

<t>Step 1 for JWS references the JWS Payload. An example PASSporT Payload is
as follows:</t>

<figure><artwork><![CDATA[
{
  "dest":{"uri":["sip:alice@example.com"]}
  "iat":1471375418,
  "orig":{"tn":"12155551212"}
}
]]></artwork></figure>

<t>This would be serialized to the following form (with line break used for
display purposes only):</t>

<figure><artwork><![CDATA[
{"dest":{"uri":["sip:alice@example.com"]},"iat":1471375418,
"orig":{"tn":"12155551212"}}
]]></artwork></figure>

<t>Step 2 computes the BASE64URL(JWS Payload), producing this value
(with line break used for display purposes only):</t>

<figure><artwork><![CDATA[
eyJkZXN0Ijp7InVyaSI6WyJzaXA6YWxpY2VAZXhhbXBsZS5jb20iXX0sImlhdCI
6MTQ3MTM3NTQxOCwib3JpZyI6eyJ0biI6IjEyMTU1NTUxMjEyIn19
]]></artwork></figure>

<t>For Step 3, an example PASSporT Protected Header constructed as a
JOSE Header is as follows:
</t>

<figure><artwork><![CDATA[
{
  "alg":"ES256",
  "typ":"passport",
  "x5u":"https://cert.example.org/passport.cer"
}
]]></artwork></figure>

<t>This would be serialized to the following form (with line break used
for display purposes only):</t>

<figure><artwork><![CDATA[
{"alg":"ES256","typ":"passport","x5u":"https://cert.example.org
  /passport.cer"}
]]></artwork></figure>

<t>Step 4 performs the BASE64URL(UTF8(JWS Protected Header)) operation and
encoding, producing this value (with line break used for display purposes
only):</t>

<figure><artwork><![CDATA[
eyJhbGciOiJFUzI1NiIsInR5cCI6InBhc3Nwb3J0IiwieDV1IjoiaHR0cHM6Ly9j
ZXJ0LmV4YW1wbGUub3JnL3Bhc3Nwb3J0LmNlciJ9
]]></artwork></figure>

<t>Steps 5 and 6 perform the computation of the digital signature of the
PASSporT Signing Input
ASCII(BASE64URL(UTF8(JWS Protected Header)) || "." || BASE64URL(JWS Payload)),
using ES256 as the algorithm and the BASE64URL(JWS Signature).</t>

<figure><artwork><![CDATA[
VLBCIVDCaeK6M4hLJb6SHQvacAQVvoiiEOWQ_iUkqk79UD81fHQ0E1b3_GluIkb
a7UWYRM47ZbNFdOJquE35cw
]]></artwork></figure>

<t>Step 8 describes how to create the final PASSporT, concatenating the
values in the order Header.Payload.Signature with period (".") characters. For
the above example values, this would produce the following (with line breaks
between periods used for readability purposes only):</t>

<figure><artwork><![CDATA[
eyJhbGciOiJFUzI1NiIsInR5cCI6InBhc3Nwb3J0IiwieDV1IjoiaHR0cHM6Ly9j
ZXJ0LmV4YW1wbGUub3JnL3Bhc3Nwb3J0LmNlciJ9
.
eyJkZXN0Ijp7InVyaSI6WyJzaXA6YWxpY2VAZXhhbXBsZS5jb20iXX0sImlhdCI
6MTQ3MTM3NTQxOCwib3JpZyI6eyJ0biI6IjEyMTU1NTUxMjEyIn19
.
VLBCIVDCaeK6M4hLJb6SHQvacAQVvoiiEOWQ_iUkqk79UD81fHQ0E1b3_GluIkb
a7UWYRM47ZbNFdOJquE35cw
]]></artwork></figure>

<section anchor="x509-private-key-in-pkcs8-format-for-es256-example"
         title="X.509 Private Key in PKCS #8 Format for ES256 Example">

<figure><artwork><![CDATA[
-----BEGIN PRIVATE KEY-----
MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgi7q2TZvN9VDFg8Vy
qCP06bETrR2v8MRvr89rn4i+UAahRANCAAQWfaj1HUETpoNCrOtp9KA8o0V79IuW
ARKt9C1cFPkyd3FBP4SeiNZxQhDrD0tdBHls3/wFe8++K2FrPyQF9vuh
-----END PRIVATE KEY-----
]]></artwork></figure>

</section>
<section anchor="x509-public-key-for-es256-example" title="X.509 Public Key for ES256 Example">

<figure><artwork><![CDATA[
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE8HNbQd/TmvCKwPKHkMF9fScavGeH
78YTU8qLS8I5HLHSSmlATLcslQMhNC/OhlWBYC626nIlo7XeebYS7Sb37g==
-----END PUBLIC KEY-----
]]></artwork></figure>

</section>
</section>

<section anchor="acknowledgements" title="Acknowledgments" numbered="no">

<t>Particular thanks to members of the ATIS and SIP Forum NNI Task Group,
including Jim McEachern, Martin Dolly, Richard Shockey, John Barnhill, Christer
Holmberg, Victor Pascual Avila, Mary Barnes, and Eric Burger, for their review,
ideas, and contributions.  Thanks also to Henning Schulzrinne, Russ Housley,
Alan Johnston, Richard Barnes, Mark Miller, Ted Hardie, Dave Crocker, Robert
Sparks, and Jim Schaad for valuable feedback on the technical and security
aspects of the document. Additional thanks to Harsha Bellur for assistance in
coding the example tokens.</t>

</section>

  </back>
</rfc>
