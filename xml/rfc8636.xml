<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
	  <!ENTITY rfc6150 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6150.xml'>
	  <!ENTITY rfc1321 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1321.xml'>
	  <!ENTITY rfc2119 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
	  <!ENTITY rfc5280 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml'>
	  <!ENTITY rfc5652 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5652.xml'>
	  <!ENTITY rfc3961 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3961.xml'>
	  <!ENTITY rfc4120 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4120.xml'>
	  <!ENTITY rfc4556 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4556.xml'>
	  <!ENTITY rfc6234 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6234.xml'>
	  <!ENTITY rfc6194 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6194.xml'>
	  <!ENTITY rfc7696 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.7696.xml'>
	  <!ENTITY rfc8062 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.8062.xml'>
	  <!ENTITY rfc8070 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.8070.xml'>
	  <!ENTITY rfc8174 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.8174.xml'>
	  <!ENTITY rfc6113 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6113.xml'>
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="6"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc submissionType="IETF" category="std" consensus="yes" ipr="pre5378Trust200902" updates="4556" number="8636">

  <front>
    <title abbrev="PKINIT Algorithm Agility">Public Key Cryptography for
    Initial Authentication in Kerberos (PKINIT) Algorithm Agility</title>
    <author initials="L." surname="Hornquist Astrand" fullname="Love Hornquist Astrand">
      <organization>Apple, Inc</organization>
      <address>
        <postal>
	  <street/>
          <city>Cupertino, CA</city> <code/>
          <country>United States of America</country>
        </postal>
        <email>lha@apple.com</email>
      </address>
    </author>
    <author initials="L" surname="Zhu" fullname="Larry Zhu">
      <organization>Oracle Corporation</organization>
      <address>
        <postal>
          <street>500 Oracle Parkway</street>
          <city>Redwood Shores, CA</city> <code>94065</code>
          <country>United States of America</country>
        </postal>
        <email>larryzhu@live.com</email>
      </address>
    </author>
    <author initials="M." surname="Cullen" fullname="Margaret Cullen">
      <organization>Painless Security</organization>
      <address>
        <postal>
          <street>4 High St, Suite 134</street>
          <city>North Andover</city> <region>MA</region>
          <code>01845</code>
          <country>United States of America</country>
        </postal>
        <phone>+1 781-405-7464</phone>
        <email>margaret@painless-security.com</email>
      </address>
    </author>
    <author initials="G." surname="Hudson" fullname="Greg Hudson">
      <organization>MIT</organization>
      <address>
        <email>ghudson@mit.edu</email>
      </address>
    </author>
    
    <date month="July" year="2019"/>
    <area>Security</area>
    <workgroup>Kitten Working Group</workgroup>

<keyword>example</keyword>

    <abstract>
      <t>
        This document updates the Public Key Cryptography for Initial
        Authentication in Kerberos (PKINIT) standard (RFC 4556) to remove
	protocol structures tied to specific cryptographic algorithms.  The
	PKINIT key derivation function is made negotiable, and the digest
        algorithms for signing the pre-authentication data and the
        client's X.509 certificates are made discoverable.
      </t>

      <t>
   These changes provide preemptive protection against vulnerabilities
   discovered in the future in any specific cryptographic algorithm and 
   allow incremental deployment of newer algorithms.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction"> 
      <t>
        The Public Key Cryptography for Initial Authentication in
        Kerberos (PKINIT) standard <xref target="RFC4556"/> defines
        several protocol structures that are either tied to SHA-1
        <xref target="RFC6234"/> or do not support negotiation or
        discovery but are instead based on local policy:
      </t>
      <t>
        <list style="symbols">
          <t>
            The checksum algorithm in the authentication request is hardwired
            to use SHA-1.
          </t>
          <t>
            The acceptable digest algorithms for signing the authentication
            data are not discoverable.
          </t>
          <t>
            The key derivation function in Section 3.2.3.1 of
            <xref target="RFC4556"/> is hardwired to use SHA-1.
          </t>
          <t>
            The acceptable digest algorithms for signing the client X.509
            certificates are not discoverable.
          </t>
        </list>
      </t>

      <t>
        In August 2004, Xiaoyun Wang's research group reported MD4
        <xref target="RFC6150"/> collisions <xref target="WANG04"/>, alongside attacks on
        later hash functions including MD5
        <xref target="RFC1321"/> and SHA-1 <xref target="RFC6234"/>.
        These attacks and their consequences are discussed in
        <xref target="RFC6194"/>.  These discoveries challenged the
        security of protocols relying on the collision-resistance
        properties of these hashes.  
      </t>
      <t> 
        The Internet Engineering Task Force (IETF) called for
        action to update existing protocols to provide crypto
        algorithm agility so that protocols support multiple
        cryptographic algorithms (including hash functions) and
        provide clean, tested transition strategies between
        algorithms, as recommended by BCP 201
        <xref target="RFC7696"/>.
      </t>
      <t>
        To address these concerns, new key derivation functions
        (KDFs), identified by object identifiers, are defined.  The
        PKINIT client provides a list of KDFs in the request, and the
        Key Distribution Center (KDC) picks one in the response. Thus,
        a mutually supported KDF is negotiated.
      </t>
      <t>
        Furthermore, structures are defined to allow the client to
        discover the Cryptographic Message Syntax (CMS)
        <xref target="RFC5652"/> digest algorithms supported by the
        KDC for signing the pre-authentication data and the
        client X.509 certificate.
      </t>
    </section>
    <section title="Requirements Notation">
        <t>
    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
    "MAY", and "OPTIONAL" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
    </section>
    <section anchor="paChecksum" title="paChecksum Agility">
      <t>
        The paChecksum defined in Section 3.2.1 of
        <xref target="RFC4556"/> provides a cryptographic binding
        between the client's pre-authentication data and the
        corresponding Kerberos request body.  This also prevents the
        KDC-REQ body from being tampered with.  SHA-1 is the only
        allowed checksum algorithm defined in
        <xref target="RFC4556"/>. This facility relies on the
        collision-resistance properties of the SHA-1 checksum
        <xref target="RFC6234"/>.
      </t>

      <t>
        When the reply key delivery mechanism is based on public key
        encryption as described in Section 3.2.3.2 of
        <xref target="RFC4556"/>, the
   asChecksum in the KDC reply provides integrity protection for the
   unauthenticated clear text in these messages and the binding between
   the pre-authentication and the ticket request and response messages.

        However, if the reply key delivery mechanism is based on the
        Diffie-Hellman key agreement as described in Section 3.2.3.1
        of <xref target="RFC4556"/>, the security provided by using
        SHA-1 in the paChecksum is weak, and nothing else
        cryptographically binds the Authentication Service
   (AS) request to the ticket response.
        In this case, the new KDF selected by the KDC, as described in
        <xref target="KDF"/>, provides the cryptographic binding and
        integrity protection.
      </t>
    </section>

    <section anchor="digest" title="CMS Digest Algorithm Agility">
      <t>
        Section 3.2.2 of <xref target="RFC4556"/> is updated to add
        optional typed data to the
        KDC_ERR_DIGEST_IN_SIGNED_DATA_NOT_ACCEPTED error.  When a KDC
        implementation conforming to this specification returns this
        error code, it MAY include a list of supported CMS types
        signifying the digest algorithms supported by the KDC in decreasing
	order of preference.  This is accomplished by
        including a TD_CMS_DATA_DIGEST_ALGORITHMS typed data element
        in the error data.
      </t>
      <t>
        <figure>
          <artwork><![CDATA[
td-cms-digest-algorithms INTEGER ::= 111
]]></artwork>
        </figure>
      </t>
      <t>
        The corresponding data for the TD_CMS_DATA_DIGEST_ALGORITHMS contains
        the TD-CMS-DIGEST-ALGORITHMS-DATA structure, which is ASN.1
        Distinguished Encoding Rules (DER) <xref target="X680"/> <xref
        target="X690"/> encoded and is defined as follows:
      </t>
      <t>
        <figure>
          <artwork><![CDATA[
TD-CMS-DIGEST-ALGORITHMS-DATA ::= SEQUENCE OF
    AlgorithmIdentifier
        -- Contains the list of CMS algorithm [RFC5652]
        -- identifiers indicating the digest algorithms
        -- acceptable to the KDC for signing CMS data in
        -- decreasing order of preference.
]]></artwork>
        </figure>
        The algorithm identifiers in TD-CMS-DIGEST-ALGORITHMS identify
        the digest algorithms supported by the KDC.
      </t>
      <t>
        This information sent by the KDC via TD_CMS_DATA_DIGEST_ALGORITHMS
        can facilitate troubleshooting when none of the digest algorithms
        supported by the client is supported by the KDC.
      </t>
    </section>
    <section anchor="sign" title="X.509 Certificate Signer Algorithm Agility">
      <t>
        Section 3.2.2 of <xref target="RFC4556"/> is updated to add
        optional typed data to the KDC_ERR_DIGEST_IN_CERT_NOT_ACCEPTED
        error.  When a KDC conforming to this specification returns
        this error, it MAY send a list of digest algorithms acceptable
        to the KDC for use by the certification authority (CA) in
        signing the client's X.509 certificate in decreasing order of
	preference.  This is accomplished by including a
        TD_CERT_DIGEST_ALGORITHMS typed data element in the error
        data.  The corresponding data contains the ASN.1 DER encoding
        of the TD-CERT-DIGEST-ALGORITHMS-DATA structure defined as
        follows:
        <figure>
          <artwork><![CDATA[
td-cert-digest-algorithms INTEGER ::= 112

TD-CERT-DIGEST-ALGORITHMS-DATA ::= SEQUENCE {
        allowedAlgorithms [0] SEQUENCE OF AlgorithmIdentifier,
                   -- Contains the list of CMS algorithm [RFC5652]
                   -- identifiers indicating the digest algorithms
                   -- that are used by the CA to sign the client's
                   -- X.509 certificate and are acceptable to the KDC
                   -- in the process of validating the client's X.509
                   -- certificate in decreasing order of
                   -- preference.
        rejectedAlgorithm [1] AlgorithmIdentifier OPTIONAL,
                   -- This identifies the digest algorithm that was
                   -- used to sign the client's X.509 certificate and
                   -- has been rejected by the KDC in the process of
                   -- validating the client's X.509 certificate
                   -- [RFC5280].
        ...
}
]]></artwork>
        </figure>
        The KDC fills in the allowedAlgorithm field with the list of
        algorithm <xref target="RFC5652"/> identifiers indicating
        digest algorithms that are used by the CA to sign the client's
        X.509 certificate and are acceptable to the KDC in the process
        of validating the client's X.509 certificate in decreasing order of
        preference.  The rejectedAlgorithm field identifies
        the signing algorithm for use in signing the client's X.509
        certificate that has been rejected by the KDC in the process
        of validating the client's certificate
        <xref target="RFC5280"/>.
      </t>
    </section>
    <section anchor="KDF" title="KDF Agility">
      <t>
        Section 3.2.3.1 of <xref target="RFC4556"/> is updated to
        define additional key derivation functions (KDFs) to derive a
        Kerberos protocol key based on the secret value generated by
        the Diffie-Hellman key exchange.  Section 3.2.1 of
        <xref target="RFC4556"/> is updated to add a new field to the
        AuthPack structure to indicate which new KDFs are supported by
        the client.  Section 3.2.3 of <xref target="RFC4556"/> is
        updated to add a new field to the DHRepInfo structure to
        indicate which KDF is selected by the KDC.
      </t>
      <t>
        The KDF algorithm described in this document (based on
        <xref target="SP80056A"/>) can be implemented using any
        cryptographic hash function.
      </t>
      <t>
        A new KDF for PKINIT usage is identified by an object
        identifier.  The following KDF object identifiers are defined:
      </t>
      <t>
        <figure>
          <artwork><![CDATA[
id-pkinit OBJECT IDENTIFIER ::=
         { iso(1) identified-organization(3) dod(6) internet(1)
           security(5) kerberosv5(2) pkinit (3) }
    -- Defined in RFC 4556 and quoted here for the reader.

id-pkinit-kdf OBJECT IDENTIFIER      ::= { id-pkinit kdf(6) }
    -- PKINIT KDFs

id-pkinit-kdf-ah-sha1 OBJECT IDENTIFIER
    ::= { id-pkinit-kdf sha1(1) }
    -- SP800-56A ASN.1 structured hash-based KDF using SHA-1

id-pkinit-kdf-ah-sha256 OBJECT IDENTIFIER
    ::= { id-pkinit-kdf sha256(2) }
    -- SP800-56A ASN.1 structured hash-based KDF using SHA-256

id-pkinit-kdf-ah-sha512 OBJECT IDENTIFIER
    ::= { id-pkinit-kdf sha512(3) }
    -- SP800-56A ASN.1 structured hash-based KDF using SHA-512

id-pkinit-kdf-ah-sha384 OBJECT IDENTIFIER
    ::= { id-pkinit-kdf sha384(4) }
    -- SP800-56A ASN.1 structured hash-based KDF using SHA-384
]]></artwork>
        </figure>
      </t>
      <t>
        Where id-pkinit is defined in <xref target="RFC4556"/>.  All
        key derivation functions specified above use the one-step key
        derivation method described in Section 5.8.2.1 of
        <xref target="SP80056A"/>, choosing the ASN.1 format for
        FixedInfo, and Section 4.1 of <xref target="SP80056C"/>, choosing
        option 1 for the auxiliary function H.  id-pkinit-kdf-ah-sha1
        uses SHA-1 <xref target="RFC6234"/> as the hash function.
        id-pkinit-kdf-ah-sha256, id&nbhy;pkinit-kdf-ah-sha356, and
        id-pkinit-kdf-ah-sha512 use SHA-256 <xref target="RFC6234"/>,
        SHA-384 <xref target="RFC6234"/>, and SHA-512
        <xref target="RFC6234"/>, respectively.
      </t>
      <t>
        To name the input parameters, an abbreviated version of the
        key derivation method is described below.
        <list style="numbers">
          <t>
            reps = ceiling(L/H_outputBits)
          </t>
          <t>
            Initialize a 32-bit, big-endian bit string counter as 1. 
          </t>
          <t>
            For i = 1 to reps by 1, do the following: 
            <list style="numbers">
              <t>
                Compute Hashi = H(counter || Z || OtherInfo). 
              </t>
              <t>
                Increment counter (not to exceed 2^32-1)
              </t>
            </list>
          </t>
          <t>
            Set key_material = Hash1 || Hash2 || ... so that the
            length of key_material is L bits, truncating the last
            block as necessary.
          </t>
          <t>
            The above KDF produces a bit string of length L in bits as
            the keying material.  The AS reply key is the output of
            random-to-key() <xref target="RFC3961"/>, using that
            keying material as the input.
          </t>
        </list>
      </t>
      <t>
        The input parameters for these KDFs are provided as follows:
      </t>
      <t>
        <list style="symbols">
          <t>
            H_outputBits is 160 bits for id-pkinit-kdf-ah-sha1,
            256 bits for id-pkinit-kdf-ah-sha256, 384 bits for
            id-pkinit-kdf-ah-sha384, and 512 bits for
            id-pkinit-kdf-ah-sha512.
          </t>
          <t>
            max_H_inputBits is 2^64.
          </t>
          <t>
            The secret value (Z) is the shared secret value generated by the
            Diffie-Hellman exchange.  The Diffie-Hellman shared value is first
            padded with leading zeros such that the size of the secret value
            in octets is the same as that of the modulus, then represented as
            a string of octets in big-endian order.
          </t>
          <t>
            The key data length (L) is the key-generation seed length
            in bits <xref target="RFC3961"/> for the Authentication
            Service (AS) reply key.  The enctype of the AS reply key is
            selected according to <xref target="RFC4120"/>.
          </t>
          <t>
            The algorithm identifier (algorithmID) input parameter is
            the identifier of the respective KDF.  For example, this
            is id-pkinit-kdf-ah-sha1 if the KDF uses SHA-1 as the hash.
          </t>
          <t>
            The initiator identifier (partyUInfo) contains the ASN.1
            DER encoding of the KRB5PrincipalName
            <xref target="RFC4556"/> that identifies the client as
            specified in the AS-REQ <xref target="RFC4120"/> in the
            request.
          </t>
          <t>
            The recipient identifier (partyVInfo) contains the ASN.1
            DER encoding of the KRB5PrincipalName
            <xref target="RFC4556"/> that identifies the ticket-granting
	    server (TGS) as
            specified in the AS-REQ <xref target="RFC4120"/> in the
            request.
          </t>
          <t>
            The supplemental public information (suppPubInfo) is the
            ASN.1 DER encoding of the PkinitSuppPubInfo structure, as
            defined later in this section.
          </t>
          <t>
            The supplemental private information (suppPrivInfo) is absent.
          </t>
        </list>
      </t>
      <t>
        OtherInfo is the ASN.1 DER encoding of the following sequence:
        <figure>
          <artwork><![CDATA[
OtherInfo ::= SEQUENCE { 
        algorithmID   AlgorithmIdentifier, 
        partyUInfo     [0] OCTET STRING, 
        partyVInfo     [1] OCTET STRING, 
        suppPubInfo    [2] OCTET STRING OPTIONAL, 
        suppPrivInfo   [3] OCTET STRING OPTIONAL 
}
]]></artwork>
        </figure>
      </t>
      <t>
        The PkinitSuppPubInfo structure is defined as follows:
        <figure>
          <artwork><![CDATA[
PkinitSuppPubInfo ::= SEQUENCE {
       enctype           [0] Int32,
           -- The enctype of the AS reply key.
       as-REQ            [1] OCTET STRING,
           -- The DER encoding of the AS-REQ [RFC4120] from the
           -- client.
       pk-as-rep         [2] OCTET STRING,
           -- The DER encoding of the PA-PK-AS-REP [RFC4556] in the
           -- KDC reply.
       ...
}
]]></artwork>
        </figure>

        The PkinitSuppPubInfo structure contains mutually known public
        information specific to the authentication exchange.  The
        enctype field is the enctype of the AS reply key as selected
        according to <xref target="RFC4120"/>.  The as-REQ field
        contains the DER encoding of the AS-REQ type <xref target="RFC4120"/>
	in the request sent from the client to the KDC. 


 Note that the as-REQ
	field does not include the
        wrapping 4-octet length when TCP is used.  The pk-as-rep
        field contains the DER encoding of the PA-PK-AS-REP
        <xref target="RFC4556"/> type in the KDC reply.  The
        PkinitSuppPubInfo provides a cryptographic binding between
        the pre-authentication data and the corresponding ticket
        request and response, thus addressing the concerns described
        in <xref target="paChecksum"/>.
      </t>
      <t>
        The KDF is negotiated between the client and the KDC.  The
        client sends an unordered set of supported KDFs in the
        request, and the KDC picks one from the set in the reply.
      </t>
      <t>
        To accomplish this, the AuthPack structure in
        <xref target="RFC4556"/> is extended as follows:
        <figure>
          <artwork><![CDATA[
AuthPack ::= SEQUENCE {
       pkAuthenticator   [0] PKAuthenticator,
       clientPublicValue [1] SubjectPublicKeyInfo OPTIONAL,
       supportedCMSTypes [2] SEQUENCE OF AlgorithmIdentifier
                OPTIONAL,
       clientDHNonce     [3] DHNonce OPTIONAL,
       ...,
       supportedKDFs     [4] SEQUENCE OF KDFAlgorithmId OPTIONAL,
           -- Contains an unordered set of KDFs supported by the
           -- client.
       ...
}

KDFAlgorithmId ::= SEQUENCE {
       kdf-id            [0] OBJECT IDENTIFIER,
           -- The object identifier of the KDF
       ...
}
]]></artwork>
        </figure>
        The new supportedKDFs field contains an unordered set of KDFs
        supported by the client.
      </t>
      <t>
        The KDFAlgorithmId structure contains an object identifier that
        identifies a KDF.  The algorithm of the KDF and its parameters are
        defined by the corresponding specification of that KDF.
      </t>
      <t>
        The DHRepInfo structure in <xref target="RFC4556"/> is
        extended as follows:
        <figure>
          <artwork><![CDATA[
DHRepInfo ::= SEQUENCE {
        dhSignedData         [0] IMPLICIT OCTET STRING,
        serverDHNonce        [1] DHNonce OPTIONAL,
        ...,
        kdf                  [2] KDFAlgorithmId OPTIONAL,
            -- The KDF picked by the KDC.
        ...
}
]]></artwork>
        </figure>
        The new kdf field in the extended DHRepInfo structure identifies the
        KDF picked by the KDC.  If the supportedKDFs field is present in the
        request, a KDC conforming to this specification MUST choose one of
        the KDFs supported by the client and indicate its selection in the
        kdf field in the reply.  If the supportedKDFs field is absent in the
        request, the KDC MUST omit the kdf field in the reply and use the
        key derivation function from Section 3.2.3.1 of
        <xref target="RFC4556"/>.  If none of the KDFs supported by the
        client is acceptable to the KDC, the KDC MUST reply with the new
        error code KDC_ERR_NO_ACCEPTABLE_KDF:
        <list style="symbols">
          <t>
            KDC_ERR_NO_ACCEPTABLE_KDF 100
          </t>
        </list>
      </t>
      <t>
        If the client fills the supportedKDFs field in the request
        but the kdf field in the reply is not present, the client can
        deduce that the KDC is not updated to conform with this
        specification, or that the exchange was subjected to a
        downgrade attack.  It is a matter of local policy on the
        client whether to reject the reply when the kdf field is
        absent in the reply; if compatibility with non-updated KDCs is
        not a concern, the reply should be rejected.
      </t>
      <t>
        Implementations conforming to this specification MUST support
        id&nbhy;pkinit-kdf-ah-sha256.
      </t>
    </section>
    <section title="Interoperability">
      <t>
        An old client interoperating with a new KDC will not recognize a
        TD&nbhy;CMS-DIGEST-ALGORITHMS-DATA element in a
        KDC_ERR_DIGEST_IN_SIGNED_DATA_NOT_ACCEPTED error or a
        TD-CERT-DIGEST-ALGORITHMS-DATA element in a
        KDC_ERR_DIGEST_IN_CERT_NOT_ACCEPTED error.  Because the error
        data is encoded as typed data, the client will ignore the
        unrecognized elements.
      </t>
      <t>
        An old KDC interoperating with a new client will not include a
        TD&nbhy;CMS-DIGEST-ALGORITHMS-DATA element in a
        KDC_ERR_DIGEST_IN_SIGNED_DATA_NOT_ACCEPTED error or a
        TD-CERT-DIGEST-ALGORITHMS-DATA element in a
        KDC_ERR_DIGEST_IN_CERT_NOT_ACCEPTED error.  To the client, this
        appears just as if a new KDC elected not to include a list of
        digest algorithms.
      </t>
      <t>
        An old client interoperating with a new KDC will not include the
        supportedKDFs field in the request.  The KDC MUST omit the kdf
        field in the reply and use the <xref target="RFC4556"/> KDF as
        expected by the client or reject the request if local policy
        forbids use of the old KDF.
      </t>
      <t>
        A new client interoperating with an old KDC will include the
        supportedKDFs field in the request; this field will be ignored as an
        unknown extension by the KDC.  The KDC will omit the kdf field in
        the reply and will use the <xref target="RFC4556"/> KDF.  The client
        can deduce from the omitted kdf field that the KDC is not updated to
        conform to this specification or that the exchange was subjected to
        a downgrade attack.  The client MUST use the
        <xref target="RFC4556"/> KDF or reject the reply if local policy
        forbids the use of the old KDF.
      </t>
    </section>
    <section title="Test Vectors">
      <t>
        This section contains test vectors for the KDF defined above.
      </t>
      <section title="Common Inputs">
        <t>
          <figure>
<artwork><![CDATA[
Z: Length = 256 bytes, Hex Representation = (All Zeros)
00000000 00000000 00000000 00000000 000000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 000000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 000000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 000000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 000000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 000000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 000000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 000000000 00000000 00000000 00000000

client: Length = 9 bytes, ASCII Representation = lha@SU.SE

server: Length = 18 bytes, ASCII Representation = krbtgt/SU.SE@SU.SE

as-req: Length = 10 bytes, Hex Representation =
AAAAAAAA AAAAAAAA AAAA

pk-as-rep:  Length = 9 bytes, Hex Representation =
BBBBBBBB BBBBBBBB BB

ticket: Length =  55 bytes, Hex Representation =
61353033 A0030201 05A1071B 0553552E 5345A210 300EA003 020101A1 0730051B
036C6861 A311300F A0030201 12A20804 0668656A 68656A
]]></artwork>
          </figure>
        </t>
        </section>
      <section title="Test Vector for SHA-1, enctype 18">
        <section title="Specific Inputs">
          <t>
            <figure>
<artwork><![CDATA[algorithm-id: (id-pkinit-kdf-ah-sha1) Length = 8 bytes, Hex 
Representation = 2B060105 02030601

enctype: (aes256-cts-hmac-sha1-96) Length = 1 byte, Decimal
Representation = 18
]]></artwork>
            </figure>
          </t>
        </section>
        <section title="Outputs">
          <t>
            <figure>
<artwork><![CDATA[
key-material: Length = 32 bytes, Hex Representation =
E6AB38C9 413E035B B079201E D0B6B73D 8D49A814 A737C04E E6649614 206F73AD

key: Length = 32 bytes, Hex Representation =
E6AB38C9 413E035B B079201E D0B6B73D 8D49A814 A737C04E E6649614 206F73AD
]]></artwork>
            </figure>
          </t>
        </section>
      </section>


      <section title="Test Vector for SHA-256, enctype 18">
        <section title="Specific Inputs">
          <t>
            <figure>
<artwork><![CDATA[
algorithm-id: (id-pkinit-kdf-ah-sha256) Length = 8 bytes, Hex 
Representation = 2B060105 02030602

enctype: (aes256-cts-hmac-sha1-96) Length = 1 byte, Decimal
Representation = 18
]]></artwork>
            </figure>
          </t>
        </section>
        <section title="Outputs">
          <t>
            <figure>
<artwork><![CDATA[
key-material: Length = 32 bytes, Hex Representation =
77EF4E48 C420AE3F EC75109D 7981697E ED5D295C 90C62564 F7BFD101 FA9bC1D5

key: Length = 32 bytes, Hex Representation =
77EF4E48 C420AE3F EC75109D 7981697E ED5D295C 90C62564 F7BFD101 FA9bC1D5
]]></artwork>
            </figure>
          </t>
        </section>
      </section>
      <section title="Test Vector for SHA-512, enctype 16">
        <section title="Specific Inputs">
          <t>
            <figure>
<artwork><![CDATA[
algorithm-id: (id-pkinit-kdf-ah-sha512) Length = 8 bytes, Hex 
Representation = 2B060105 02030603

enctype: (des3-cbc-sha1-kd) Length = 1 byte, Decimal 
Representation = 16
]]></artwork>
            </figure>
          </t>
        </section>
        <section title="Outputs">
          <t>
            <figure>
<artwork><![CDATA[
key-material: Length = 24 bytes, Hex Representation =
D3C78A79 D65213EF E9A826F7 5DFB01F7 2362FB16 FB01DAD6

key: Length = 32 bytes, Hex Representation =
D3C78A79 D65213EF E9A826F7 5DFB01F7 2362FB16 FB01DAD6
]]></artwork>
            </figure>
          </t>
        </section>
      </section>
    </section>
    <section title="Security Considerations">
      <t>
        This document describes negotiation of checksum types, key
        derivation functions, and other cryptographic functions.  If a
        given negotiation is unauthenticated, care must be taken to
        accept only secure values; to do otherwise allows an active
        attacker to perform a downgrade attack.
      </t>

      <t>
	The discovery method described in <xref target="digest"/> uses
	a Kerberos error message, which is unauthenticated in a
	typical exchange.  An attacker may attempt to downgrade a
	client to a weaker CMS type by forging a
	KDC_ERR_DIGEST_IN_SIGNED_DATA_NOT_ACCEPTED error.  It is a
	matter of local policy whether a client accepts a downgrade to
	a weaker CMS type and whether the KDC accepts the weaker CMS
	type.  A client may reasonably assume that the real KDC
	implements all hash functions used in the client's X.509
	certificate, and so the client may refuse attempts to downgrade to weaker hash
	functions.
      </t>
      <t>
	The discovery method described in <xref target="sign"/> also
	uses a Kerberos error message.  An attacker may attempt to
	downgrade a client to a certificate using a weaker signing
	algorithm by forging a KDC_ERR_DIGEST_IN_CERT_NOT_ACCEPTED
	error.  It is a matter of local policy whether a client
	accepts a downgrade to a weaker certificate and whether the
	KDC accepts the weaker certificate.  This attack is only
	possible if the client device possesses multiple client
	certificates of varying strengths.
      </t>
      <t>
	In the KDF negotiation method described in
	<xref target="KDF"/>, the client supportedKDFs value is
	protected by the signature on the signedAuthPack field in the
	request. 

	If this signature algorithm is vulnerable to collision
	attacks, an attacker may attempt to downgrade the negotiation
	by substituting an AuthPack with a different or absent
	supportedKDFs value, using a PKINIT freshness token
	<xref target="RFC8070"/> to partially control the legitimate
	AuthPack value.  A client that is performing anonymous PKINIT
	<xref target="RFC8062"/> does not sign the AuthPack, so an
	attacker can easily remove the supportedKDFs value in this
	case.  Finally, the kdf field in the DHRepInfo of the KDC
	response is unauthenticated and could be altered or removed by
	an attacker, although this alteration will likely result in a
	decryption failure by the client rather than a successful
	downgrade.  It is a matter of local policy whether a client
	accepts a downgrade to the old KDF and whether the KDC allows
	the use of the old KDF.
      </t>
      <t>
	The paChecksum field, which binds the client
	pre-authentication data to the Kerberos request body, remains
	fixed at SHA-1.  If an attacker substitutes a different
	request body using an attack against SHA-1 (a second preimage
	attack is likely required as the attacker does not control any
	part of the legitimate request body), the KDC will not detect
	the substitution.  Instead, if a new KDF is negotiated, the
	client will detect the substitution by failing to decrypt the
	reply.
      </t>
      <t>
	An attacker may attempt to impersonate the KDC to the client
	via an attack on the hash function used in the dhSignedData
	signature, substituting the attacker's subjectPublicKey for
	the legitimate one without changing the hash value.  It is a
	matter of local policy which hash function the KDC uses in its
	signature and which hash functions the client will accept in
	the KDC signature.  A KDC may reasonably assume that the
	client implements all hash functions used in the KDF
	algorithms listed the supportedKDFs field of the request.
      </t>
    </section>

    <section title="IANA Considerations">
      <t>
        IANA has made the following assignments in the
        Kerberos "Pre-authentication and Typed Data" registry created by
        Section 7.1 of RFC 6113.
      </t>
      <t>
        <figure>
          <artwork><![CDATA[
            TD-CMS-DIGEST-ALGORITHMS   111  [RFC8636]
            TD-CERT-DIGEST-ALGORITHMS  112  [RFC8636]
]]></artwork>
        </figure>
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      &rfc2119;
      &rfc5280;
      &rfc5652;
      &rfc3961;
      &rfc4120;
      &rfc4556;
      &rfc6234;
      &rfc8174;
      

<reference anchor='SP80056A' target="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar3.pdf">
        <front>
          <title>Recommendation for Pair-Wise Key-Establishment
            Schemes Using Discrete Logarithm
            Cryptography</title>

          <author initials='E.' surname='Barker' fullname='Elaine Barker'>
            <organization>National Institute of Standards and Technology</organization>
          </author>    

          <author initials='L.' surname='Chen' fullname='Lily Chen'>
            <organization>National Institute of Standards and Technology</organization>
          </author>    

          <author initials='A.' surname='Roginsky' fullname='Allen Roginsky'>
            <organization>National Institute of Standards and Technology</organization>
          </author>    

          <author initials='A.' surname='Vassilev' fullname='Apostol Vassilev'>
            <organization>National Institute of Standards and Technology</organization>
          </author>    

          <author initials='R.' surname='Davis' fullname='Richard Davis'>
            <organization>National Institute of Standards and Technology</organization>
          </author>    

          <date year='2018' month='April'/>
        </front>
<seriesInfo name="NIST Special Publications" value="800-56A, Revision 3"/>
	<seriesInfo name="DOI" value="10.6028/NIST.SP.800-56Ar3"/>
      </reference>


      <reference anchor='SP80056C' target="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Cr1.pdf">
        <front>
          <title>Recommendation for Key-Derivation Methods in
          Key-Establishment Schemes</title>

          <author initials='E.' surname='Barker' fullname='Elaine Barker'>
            <organization>National Institute of Standards and Technology</organization>
          </author>    

          <author initials='L.' surname='Chen' fullname='Lily Chen'>
            <organization>National Institute of Standards and Technology</organization>
          </author>    

          <author initials='R.' surname='Davis' fullname='Richard Davis'>
            <organization>National Institute of Standards and Technology</organization>
          </author>    

          <date year='2018' month='April'/>
        </front>
<seriesInfo name="NIST Special Publications" value="800-56C, Revision 1"/>
<seriesInfo name="DOI" value="10.6028/NIST.SP.800-56Cr1"/>
      </reference>



      <reference anchor="X680" target="https://www.itu.int/rec/T-REC-X.680-201508-I/en">
        <front>
          <title>
            Information technology - Abstract Syntax Notation One
            (ASN.1): Specification of basic notation
          </title>
          <author><organization>ITU-T</organization></author>
          <date year='2015' month='August'/>
        </front>
	<seriesInfo name="ITU-T Recommendation" value="X.680"/>
      </reference>


      <reference anchor="X690" target="https://www.itu.int/rec/T-REC-X.690-201508-I/en">
        <front>
          <title>
	    Information technology - ASN.1 encoding Rules:            
            Specification of Basic Encoding Rules (BER), Canonical
            Encoding Rules (CER) and Distinguished Encoding Rules (DER)
          </title>
          <author><organization>ITU-T</organization></author>
          <date year='2015' month='August'/>
        </front>
	<seriesInfo name="ITU-T Recommendation" value="X.690"/>
      </reference>

    </references>
    
    <references title="Informative References">
      &rfc6150;
      &rfc1321;
      &rfc6194;
      &rfc7696;
      &rfc8062;
      &rfc8070;


      <reference anchor='WANG04'>
        <front>
          <title>Cryptanalysis of the Hash Functions MD4 and RIPEMD</title>
          
          <author initials='X.' surname='Wang'> <organization/></author>
          <author initials='X.' surname='Lai'> <organization/></author>
          <author initials='D.' surname='Feng'> <organization/></author>
          <author initials='H.' surname='Chen'> <organization/></author>
          <author initials='X.' surname='Yu'> <organization/></author>
          
          <date year='2004' month='August'/>
        </front>
<seriesInfo name="Advances in Cryptology - EUROCRYPT" value="2005"/>
<seriesInfo name="DOI" value="10.1007/11426639_1"/> 
      </reference>

    </references>

    <section title="PKINIT ASN.1 Module">
      <t>
        <figure>
          <artwork>
            <![CDATA[
KerberosV5-PK-INIT-Agility-SPEC {
       iso(1) identified-organization(3) dod(6) internet(1)
       security(5) kerberosV5(2) modules(4) pkinit(5) agility (1)
} DEFINITIONS EXPLICIT TAGS ::= BEGIN

IMPORTS
   AlgorithmIdentifier, SubjectPublicKeyInfo
       FROM PKIX1Explicit88 { iso (1)
         identified-organization (3) dod (6) internet (1)
         security (5) mechanisms (5) pkix (7) id-mod (0)
         id-pkix1-explicit (18) }
         -- As defined in RFC 5280.

   Ticket, Int32, Realm, EncryptionKey, Checksum
       FROM KerberosV5Spec2 { iso(1) identified-organization(3)
         dod(6) internet(1) security(5) kerberosV5(2)
         modules(4) krb5spec2(2) }
         -- as defined in RFC 4120.

   PKAuthenticator, DHNonce, id-pkinit
       FROM KerberosV5-PK-INIT-SPEC {
         iso(1) identified-organization(3) dod(6) internet(1)
         security(5) kerberosV5(2) modules(4) pkinit(5) };
         -- as defined in RFC 4556.

id-pkinit-kdf OBJECT IDENTIFIER      ::= { id-pkinit kdf(6) }
    -- PKINIT KDFs

id-pkinit-kdf-ah-sha1 OBJECT IDENTIFIER
    ::= { id-pkinit-kdf sha1(1) }
    -- SP800-56A ASN.1 structured hash-based KDF using SHA-1

id-pkinit-kdf-ah-sha256 OBJECT IDENTIFIER
    ::= { id-pkinit-kdf sha256(2) }
    -- SP800-56A ASN.1 structured hash-based KDF using SHA-256

id-pkinit-kdf-ah-sha512 OBJECT IDENTIFIER
    ::= { id-pkinit-kdf sha512(3) }
    -- SP800-56A ASN.1 structured hash-based KDF using SHA-512

id-pkinit-kdf-ah-sha384 OBJECT IDENTIFIER
    ::= { id-pkinit-kdf sha384(4) }
    -- SP800-56A ASN.1 structured hash-based KDF using SHA-384

TD-CMS-DIGEST-ALGORITHMS-DATA ::= SEQUENCE OF
    AlgorithmIdentifier
        -- Contains the list of CMS algorithm [RFC5652]
        -- identifiers indicating the digest algorithms
        -- acceptable to the KDC for signing CMS data in
        -- decreasing order of preference.

TD-CERT-DIGEST-ALGORITHMS-DATA ::= SEQUENCE {
       allowedAlgorithms [0] SEQUENCE OF AlgorithmIdentifier,
           -- Contains the list of CMS algorithm [RFC5652]
           -- identifiers indicating the digest algorithms
           -- that are used by the CA to sign the client's
           -- X.509 certificate and are acceptable to the KDC
           -- in the process of validating the client's X.509
           -- certificate in decreasing order of
           -- preference.
       rejectedAlgorithm [1] AlgorithmIdentifier OPTIONAL,
           -- This identifies the digest algorithm that was
           -- used to sign the client's X.509 certificate and
           -- has been rejected by the KDC in the process of
           -- validating the client's X.509 certificate
           -- [RFC5280].
       ...
}

OtherInfo ::= SEQUENCE { 
        algorithmID   AlgorithmIdentifier, 
        partyUInfo     [0] OCTET STRING, 
        partyVInfo     [1] OCTET STRING, 
        suppPubInfo    [2] OCTET STRING OPTIONAL, 
        suppPrivInfo   [3] OCTET STRING OPTIONAL 
}

PkinitSuppPubInfo ::= SEQUENCE {
       enctype           [0] Int32,
           -- The enctype of the AS reply key.
       as-REQ            [1] OCTET STRING,
           -- The DER encoding of the AS-REQ [RFC4120] from the
           -- client.
       pk-as-rep         [2] OCTET STRING,
           -- The DER encoding of the PA-PK-AS-REP [RFC4556] in the
           -- KDC reply.
       ...
}

AuthPack ::= SEQUENCE {
       pkAuthenticator   [0] PKAuthenticator,
       clientPublicValue [1] SubjectPublicKeyInfo OPTIONAL,
       supportedCMSTypes [2] SEQUENCE OF AlgorithmIdentifier
                OPTIONAL,
       clientDHNonce     [3] DHNonce OPTIONAL,
       ...,
       supportedKDFs     [4] SEQUENCE OF KDFAlgorithmId OPTIONAL,
           -- Contains an unordered set of KDFs supported by the
           -- client.
       ...
}

KDFAlgorithmId ::= SEQUENCE {
       kdf-id            [0] OBJECT IDENTIFIER,
           -- The object identifier of the KDF
       ...
}

DHRepInfo ::= SEQUENCE {
       dhSignedData      [0] IMPLICIT OCTET STRING,
       serverDHNonce     [1] DHNonce OPTIONAL,
       ...,
       kdf               [2] KDFAlgorithmId OPTIONAL,
           -- The KDF picked by the KDC.
       ...
}
END
]]></artwork>
        </figure>
      </t>
    </section>
    <section title="Acknowledgements" numbered="no">
      <t>
        Jeffery Hutzelman, Shawn Emery, Tim Polk, Kelley Burgin, Ben
        Kaduk, Scott Bradner, and Eric Rescorla reviewed the document
        and provided suggestions for improvements.
      </t>
    </section>

  </back>
</rfc>
