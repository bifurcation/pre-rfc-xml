<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
	<!ENTITY rfc2119 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
	<!ENTITY rfc2104 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml'>
	<!ENTITY rfc4013 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4013.xml'>
	<!ENTITY rfc3454 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3454.xml'>
	<!ENTITY rfc4086 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4086.xml'>
	<!ENTITY rfc5996 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5996.xml'>
	<!ENTITY rfc4301 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4301.xml'>
	<!ENTITY rfc5869 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5869.xml'>
	<!ENTITY rfc5931 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5931.xml'>
	<!ENTITY rfc6090 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6090.xml'>
	<!ENTITY rfc6467 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6467.xml'>
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<?rfc rfcedstyle="yes"?>

<rfc number="6617" category="exp" ipr="trust200902" submissionType="IETF" consensus="yes">

      <front>
		<title abbrev="Secure PSK Authentication for
		IKE">Secure Pre-Shared Key (PSK) Authentication for&nbsp;the&nbsp;Internet&nbsp;Key&nbsp;Exchange&nbsp;Protocol&nbsp;(IKE)</title>

	<author fullname="Dan Harkins" initials="D.H." surname="Harkins">
		<organization>Aruba Networks</organization>
	  <address>
	    <postal>
		<street>1322 Crossman Avenue</street>
		<city>Sunnyvale</city>
		<region>CA</region>
		<code>94089-1113</code>
		<country>United States of America</country>
	    </postal>
	    <email>dharkins@arubanetworks.com</email>
	  </address>
	</author>
	<date month="May" year="2012"/>

      <area>Security</area>
      <keyword>Authenticated Key Exchange</keyword> 
      <keyword>Dictionary Attack</keyword>



      <abstract>
	  <t>
	  This memo describes a secure pre-shared key (PSK) authentication
method for the Internet Key Exchange Protocol (IKE).
	  It is resistant to dictionary attack and retains security even when used
	  with weak pre-shared keys.
	  </t>
      </abstract>
    </front>
    <middle>

      <section title="Introduction">
	<t>
	  <xref target="RFC5996"/> allows for authentication
	  of the IKE peers using a pre-shared key. This exchange, though, is susceptible
	  to dictionary attack and is therefore insecure when used with weak pre-shared
	  keys, such as human-memorizable passwords. 
	  To address the security issue, <xref target="RFC5996"/> recommends that the
	  pre-shared key used for authentication
	  "contain as much unpredictability as the strongest key being negotiated". That means any
	  non-hexadecimal key would require over 100 characters to provide enough strength to
	  generate a 128-bit key suitable for AES. This is an unrealistic requirement because
	  humans have
	  a hard time entering a string over 20 characters without error. Consequently, pre-shared
	  key authentication in <xref target="RFC5996"/> is used insecurely today. 
	</t>
	<t>
	  A pre-shared key authentication method built on top of a zero-knowledge proof will
	  provide resistance to dictionary attack and still allow for security when used with
	  weak pre-shared keys, such as user-chosen passwords. Such an authentication
	  method is described in this memo.
	</t>
	  <t>
	    Resistance to dictionary attack is achieved when an adversary
	    gets one, and only one, guess at the secret per active attack (see, for
	    example, <xref target="BM92"/>, <xref target="BMP00"/>, and <xref target="BPR00"/>).
	    Another way of putting this is that any advantage the adversary can realize is
	    through interaction and not through computation. This is demonstrably
	    different than the technique from <xref target="RFC5996"/> of using a
	    large, random number as the pre-shared key. That can only make
	    a dictionary attack less likely to succeed; it does not prevent a
	    dictionary attack. Furthermore, as <xref target="RFC5996"/>  notes, it is completely
	    insecure when used with weak keys like user-generated passwords.
	  </t>
	<section title="Keyword Definitions">
  	  <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
             "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
             document are to be interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
	  </t>
	</section>

      </section>
      <section title="Usage Scenarios" anchor="scenarios">
        <t>
	  <xref target="RFC5996"/> describes usage scenarios for IKEv2. These are:
	  <list style="numbers">
	    <t>"Security Gateway to Security Gateway Tunnel":
	      The endpoints of the IKE (and IPsec) communication
	      are network nodes that protect traffic on behalf of connected networks.
	      Protected traffic is between devices on the respective protected networks.
	    </t>
	    <t> "Endpoint-to-Endpoint Transport":
	      The endpoints of the IKE (and IPsec) communication
	      are hosts according to <xref target="RFC4301"/>. Protected traffic is
	      between the two endpoints.
	    </t>
	    <t> "Endpoint to Security Gateway Tunnel":
	      One endpoint connects to a protected network
	      through a network node. The endpoints of the IKE (and IPsec) communication
	      are the endpoint and network node, but the protected traffic is between
	      the endpoint and another device on the protected network behind the node.
	    </t>
	  </list>
	</t>
	<t>
	  The authentication and key exchange process described in this memo is suitable
	  for all the usage scenarios described in <xref target="RFC5996"/>. In the
	   "Security Gateway to Security Gateway Tunnel" scenario and the
	  "Endpoint-to-Endpoint Transport" scenario, it provides a secure method of
	  authentication without requiring a certificate. For the "Endpoint to Security
	  Gateway Tunnel" scenario, it provides for secure username+password authentication
	  that is popular in remote-access VPN situations.
	</t>

      </section>	    
	  <section anchor="notation" title="Terms and Notation">
            <t>
	    The following terms and notations are used in this memo:
	    <list hangIndent="4" style="hanging">
		<t hangText="PSK">
			<vspace blankLines="0"/>A shared, secret, and potentially low-entropy word,
				phrase, code, or key used as a credential to mutually authenticate
				the peers.</t>
		<t hangText="a = prf(b, c)">
			<vspace blankLines="0"/>The string "b" and "c" are given to a pseudo-random
				 function (prf) to produce a fixed-length output "a". </t>
		<t hangText="a | b">
			<vspace blankLines="0"/> denotes concatenation of string "a" with string "b". </t>
		<t hangText="[a]b">
			<vspace blankLines="0"/> indicates a string consisting of the single bit "a" 
				 repeated "b" times.</t>
		<t hangText="len(a)">
			<vspace blankLines="0"/> indicates the length in bits of the string "a". </t>
		<t hangText="LSB(a)">
			<vspace blankLines="0"/> returns the least-significant bit of the bitstring "a".</t>
		<t hangText="element">
			<vspace blankLines="0"/> one member of a finite cyclic group.</t>
		<t hangText="scalar">
			<vspace blankLines="0"/> a quantity that can multiply an element.</t>
	    </list>
	    </t>
	    <t>
	      The convention for this memo to represent an element in a finite cyclic group is
	      to use an upper-case letter or acronym, while a scalar is indicated with a
	      lowercase letter or acronym.
	    </t>
	  </section>
	  <section title="Discrete Logarithm Cryptography">
	    <t>
	    This protocol uses Discrete Logarithm Cryptography to achieve authentication. Each
	    party to the exchange derives ephemeral public and private keys with respect to a
	    particular set of domain parameters (referred to here as a "group"). 
	    Groups can be either based on finite field cryptography (modular
exponentiation (MODP) groups) or elliptic
	    curve cryptography (ECP groups). 
	    </t>
	    <t>
	    This protocol uses the same group as the IKE exchange in which it is being used
	    for authentication, with the exception of characteristic-two elliptic curve
	    groups (EC2N). Use of such groups is undefined for this authentication method, and
	    an IKE exchange that negotiates one of these groups MUST NOT use this method of
	    authentication.
	    </t>
	    <t>
	    For each group, the following operations are defined:
	      <list style="symbols">
	        <t>
		  "scalar operation" -- takes a scalar and an element in the group
		  to produce another element -- Z = scalar-op(x, Y).
		</t>
		<t>
		  "element operation" -- takes two elements in the group to
produce a third -- Z = element-op(X, Y).
		</t>
		<t>
		  "inverse operation" -- takes an element and returns another element such that
		  the element operation on the two produces the identity element of the
group -- Y = inverse(X).
		</t>
	      </list>
	    </t>
	  <section anchor="ec_definition" title="Elliptic Curve Cryptography (ECP) Groups">
	    <t>
	      The key exchange defined in this memo uses fundamental algorithms of ECP groups 
	      as described in <xref target="RFC6090"/>.
	    </t>
	    <t>
	    Domain parameters for ECP elliptic curves used for Secure PSK Authentication include:
	      <list style="symbols">
	         <t>A prime, p, determining a prime field GF(p). The cryptographic group will be a
	           subgroup of the full elliptic curve group that consists of points on an elliptic
	           curve -- elements from GF(p) that satisfy the curve's equation -- together with
	           the "point at infinity" (denoted here as "0")  that serves as the identity element.
	         </t>
	         <t>Elements a and b from GF(p) that define the curve's equation. The point (x,y)
	           is on the elliptic curve if and only if y^2 = x^3 + a*x + b.
	         </t>
	         <t>A prime, r, which is the order of, or number of elements
in, a subgroup
		   generated by an element G.
	         </t>
	      </list>
	    </t>
	    <t>
	    The scalar operation is multiplication of a point on the curve by itself a number of
	    times. The point Y is multiplied x-times to produce another point Z:
	    <list hangIndent="4" style="hanging">
	      <t>
		Z = scalar-op(x, Y) = x*Y
	      </t>
	    </list>
	    The element operation is addition of two points on the curve. Points X and Y
	    are summed to produce another point Z:
	    <list hangIndent="4" style="hanging">
	      <t>
		Z = element-op(X, Y) = X + Y
	      </t>
	    </list>
	    The inverse function is defined such that the sum of an element and its inverse is "0",
	    the point-at-infinity of an elliptic curve group:
	    <list hangIndent="4" style="empty">
	      <t>
	        Q + inverse(Q) = "0"
	      </t>
	    </list>
	    </t>
	    <t>
	    Elliptic curve groups require a mapping function, q = F(Q), to convert a group element
	    to an integer. The mapping function used in this memo returns the x-coordinate of the
	    point it is passed.
	    </t>
	    <t>
	    scalar-op(x, Y) can be viewed as x iterations of element-op() by defining:
	    <list hangIndent="4" style="empty">
	      <t>Y = scalar-op(1, Y)</t>
	      <t>Y = scalar-op(x, Y) = element-op(Y, scalar-op(x-1, Y)), for x > 1</t>
	    </list>
	    A definition of how to add two points on an elliptic curve (i.e., element-op(X, Y))
	    can be found in <xref target="RFC6090"/>.
	    </t>
	    <t>
	      Note: There is another ECP domain parameter, a cofactor, h, that is defined by the
	      requirement that the size of the full elliptic curve group (including "0") be the
	      product of h and r. ECP groups used for Secure PSK Authentication MUST
	      have a cofactor of one (1). At the time of publication of this memo, all ECP groups
	      in <xref target="IKEV2-IANA"/> had a cofactor of one (1).
	    </t>
	  </section>
	  <section title="Finite Field Cryptography (MODP) Groups">
	    <t>
	      Domain parameters for MODP groups used for Secure PSK Authentication
	      include:
	      <list style="symbols">
	        <t>
		  A prime, p, determining a prime field GF(p), the integers modulo p.
	        </t>
	        <t>
		  A prime, r, which is the multiplicative order, and thus also the
	          size, of the cryptographic subgroup of GF(p)* that is generated by 
		  an element G.
	        </t>
	      </list>
	    </t>
	    <t>
	      The scalar operation is exponentiation of a generator modulo a prime. An element
	      Y is taken to the x-th power modulo the prime, thereby returning another element, Z:
	      <list hangIndent="4" style="hanging">
	        <t>
		  Z = scalar-op(x, Y) = Y^x mod p
	        </t>
	      </list>
	      The element operation is modular multiplication. Two elements, X and Y, are
	      multiplied modulo the prime, thereby returning another element, Z:
	      <list hangIndent="4" style="hanging">
	        <t>
		  Z = element-op(X, Y) = (X * Y) mod p
		</t>
	      </list>
	      The inverse function for a MODP group is defined such that the product of
	      an element and its inverse modulo the group prime equals one (1). In other words,
	      <list hangIndent="4" style="empty">
	          <t>
	            (Q * inverse(Q)) mod p = 1
	          </t>
	      </list>
	    </t>
	    <t>
	      Unlike ECP groups, MODP groups do not require a mapping function
	      to convert an element into an integer. However, for the purposes of notation in protocol
	      definition, the function F, when used below, shall just return the value
	      that was passed to it, i.e., F(i) = i.
	    </t>
	    <t>
	      Some MODP groups in <xref target="IKEV2-IANA"/>
	      are based on safe primes, and the order is not included in the group's domain parameter
	      set. In this case only, the order, r, MUST be computed as the prime minus one divided by
	      two -- (p-1)/2. If an order is included in the group's domain parameter set, that value
	      MUST be used in this exchange when an order is called for. If a MODP group does not
	      include an order in its domain parameter set and is not based on a safe prime, it MUST
	      NOT be used with this exchange.
	    </t>
	  </section>

	</section>
      <section anchor="rand_num" title="Random Numbers">
        <t>
        As with IKE itself, the security of the Secure PSK Authentication method
	relies upon each participant in the protocol producing
        quality secret random numbers. A poor random number chosen by either side in a
        single exchange can compromise the shared secret from that exchange and open
        up the possibility of a dictionary attack.
        </t>
        <t>
        Producing quality random numbers without specialized hardware entails
        using a cryptographic mixing function (like a strong hash function) to
        mix entropy from multiple, uncorrelated sources of information and events.
        A very good discussion of this can be found in <xref target="RFC4086"/>.
        </t>

      </section>

      <section anchor="passwords" title="Using Passwords and Raw Keys For Authentication">
	<t>
	The PSK used as an authentication credential with this protocol can be
	either a character-based password or passphrase, or it could be a binary or 
	hexadecimal string. Regardless, however, this protocol requires both the Initiator
	and Responder to have identical binary representations of the shared credential.
	</t>
	<t>
	If the PSK is a character-based password or passphrase, there are two types of
	pre-processing that SHALL be employed to convert the password or passphrase
	into a hexadecimal string suitable for use with Secure PSK Authentication. If
	a PSK is already a hexadecimal or binary string, it SHALL be used directly as
	the shared credential without any pre-processing.
	</t>
	<t>
	The first step of pre-processing is to remove ambiguities that may arise
	due to internationalization. Each character-based password or passphrase
	MUST be pre-processed to remove that ambiguity by processing the character-based
	password or passphrase according to the rules
	of the SASLprep <xref target="RFC4013"/> profile of <xref target="RFC3454"/>.
	The password or passphrase SHALL be considered a "stored string" per
	<xref target="RFC3454"/>, and unassigned code points are therefore prohibited.
	The output SHALL be the binary representation of the processed UTF-8 character
	string. Prohibited output and unassigned codepoints encountered in SASLprep
	pre-processing SHALL cause a failure of pre-processing, and the output
	SHALL NOT be used with Secure PSK Authentication.
	</t>
	<t>
	The next pre-processing step for character-based passwords or passphrases is
	to effectively obfuscate the string. This is done in an attempt to reduce
	exposure of stored passwords in the event of server compromise, or 
	compromise of a server's database of
	stored passwords. The step involves taking the output of the
	SASLprep <xref target="RFC4013"/>
	profile of <xref target="RFC3454"/> and passing it, as the key, 
	with the ASCII string "IKE Secure PSK Authentication", as the data, to 
	HMAC-SHA256(). The output of this obfuscation step SHALL become the shared
	credential used with Secure PSK Authentication.
	</t>
	<t>
	Note: Passwords tend to be shared for multiple purposes, and compromise of a
	server or database of stored plaintext passwords can be used, in that event,
	to mount multiple attacks. The obfuscation step is merely to hide the password
	in the event of	server compromise or compromise of the database of stored
	passwords. Advances in distributed computing power have diminished the
	effectiveness of performing multiple prf iterations as a technique to prevent
	dictionary attacks, so no such behavior is proscribed here. Mutually consenting
	implementations can agree to use a different password obfuscation method;
	the one described here is for interoperability purposes only.
	</t>
	<t>
	If a device stores passwords for use at a later time, it SHOULD pre-process the
	password prior to storage. If a user enters a password into a device at
	authentication time, it MUST be pre-processed upon entry and prior to use with
	Secure PSK Authentication.
	</t>
      </section>
      <section anchor="assumptions" title="Assumptions">
        <t>
	  The security of the protocol relies on certain assumptions. They are:
          <list hangIndent="4" style="numbers">
	    <t>The pseudo-random function, prf, defined in <xref target="RFC5996"/>, 
	    acts as an "extractor" (see <xref target="RFC5869"/>) by distilling the
	       entropy from a secret input into a short, fixed string. The output of prf
	       is indistinguishable from a random source.
	    </t>
            <t>
	      The discrete logarithm problem for the chosen finite cyclic group is hard.
              That is, given G, p and Y = G^x mod p, it is computationally infeasible to
              determine x. Similarly, for an elliptic curve group given the curve definition,
              a generator G, and Y = x * G, it is computationally infeasible to determine x.
            </t>
            <t>
	      The pre-shared key is drawn from a finite pool of potential keys. Each
	      possible key in the pool has equal probability of being the shared key.
              All potential adversaries have access to this pool of keys.
            </t>
          </list>
        </t>

      </section>
	<section anchor="the_exchange" title="Secure PSK Authentication Message Exchange">
	  <t>
	    The key exchange described in this memo is based on the "Dragonfly" key exchange,
	    which has also been defined for use in 802.11 wireless networks (see <xref target="SAE"/>)
	    and as an Extensible Authentication Protocol (EAP) method (see <xref target="RFC5931"/>).
	    "Dragonfly" is patent-free and royalty-free. 
	    It SHALL use the same pseudo-random function (prf) and the same Diffie-Hellman
	    group that are negotiated for use in the IKE exchange that "Dragonfly" is
	    authenticating.
	  </t>
	  <t>
	    A pseudo-random function that uses a block cipher is NOT RECOMMENDED for use
	    with Secure PSK Authentication due to its poor job operating as an "extractor" 
	    (see <xref target="assumptions"/>). Pseudo-random functions based on hash functions
	    using the HMAC construct from <xref target="RFC2104"/> SHOULD be used.
	  </t>
	  <t>
	    To perform Secure PSK Authentication, each side must generate
	    a shared and secret element in the chosen group based on the pre-shared
	    key. This element, called the Secret Key Element, or SKE, is then used
	    in the "Dragonfly" authentication and key exchange protocol. "Dragonfly"
	    consists of each side exchanging a Commit payload and then proving
	    knowledge of the resulting shared secret.
	  </t>
	  <t>
	    The Commit payload contributes ephemeral information to the exchange and
	    binds the sender to a single value of the pre-shared key from the
	    pool of potential pre-shared keys. An authentication payload (AUTH) proves
	    that the pre-shared key is known and completes the zero-knowledge proof.
	  </t>
	  <section anchor="neg_SPSK" title="Negotiation of Secure PSK Authentication">
	      <t>
	        The Initiator indicates its desire to use Secure PSK Authentication
		by adding a Notify payload of type SECURE_PASSWORD_METHODS 
		(see <xref target="RFC6467"/>)
		to the first message of the IKE_SA_INIT exchange
		and by including 3 in the notification data
		field of the Notify payload, indicating Secure PSK Authentication.
	      </t>
	      <t>
	        The Responder indicates its acceptance to perform Secure PSK Authentication
		by adding a Notify payload of type 
		SECURE_PASSWORD_METHODS to its response in the IKE_SA_INIT exchange and
		by adding the sole value of 3 to the notification data field of the Notify
		payload.
	      </t>
	      <t>
		If the Responder does not include a Notify payload of type
		SECURE_PASSWORD_METHODS in its IKE_SA_INIT response, the Initiator MUST
		terminate the exchange, and it MUST NOT fall back to the PSK authentication
		method of <xref target="RFC5996"/>. If the Initiator only indicated
		its support for Secure PSK Authentication (i.e., if the Notify data field
		only contained 3) and the Responder replies with a Notify payload of
		type SECURE_PASSWORD_METHODS and a different value in the Notify data
		field, the Initiator MUST terminate the exchange.
	      </t>
	  </section>
	  <section anchor="fixing_SKE" title="Fixing the Secret Element, SKE">
	    <t>
	      The method of fixing SKE depends on the type of group, either MODP
	      or ECP. The function "prf+" from <xref target="RFC5996"/> is used as
	      a key derivation function. 
	    </t>
	    <t>
	      Fixing SKE involves an iterative hunting-and-pecking technique using
	      the prime from the negotiated group's domain parameter set and an ECP-
	      or MODP-specific operation depending on the negotiated group. This
	      technique requires the pre-shared key to be a binary string; therefore,
	      any pre-processing transformation (see <xref target="passwords"/>)
	      MUST be performed on the pre-shared key prior to fixing SKE.
	    </t>
	    <t>
	      To thwart side-channel attacks that attempt to determine the number of 
	      iterations of the hunting-and-pecking loop that are used to find SKE
	      for a given password, a security parameter, k, is used to ensure that
	      at least k iterations are always performed. 
	    </t>
	    <t>
	      Prior to beginning the hunting-and-pecking loop, an 8-bit counter is
	      set to the value one (1). Then the loop begins. First, the pseudo-random
	      function is used to generate a secret seed using the counter, the
	      pre-shared key, and two nonces (without the fixed headers) exchanged by
	      the Initiator and the Responder (see <xref target="ikev2_exchange"/>):
	        <list hangIndent="2" style="empty">
		  <t>ske-seed = prf(Ni | Nr, psk | counter)</t>
	        </list>
	    </t>
	    <t>
	      Then, the ske-seed is expanded using prf+ to create an ske-value:
	        <list hangIndent="2" style="empty">
		  <t>ske-value = prf+(ske-seed, "IKE SKE Hunting And Pecking")</t>
	        </list>
		where len(ske-value) is the same as len(p), the length of the prime from
		the domain parameter set of the negotiated group.
	    </t>
	    <t>
	      If the ske-seed is greater than or equal to the prime, p, the counter is
	      incremented, a new ske-seed is generated, and the hunting-and-pecking
	      continues. If ske-seed is less than the prime, p, it is passed to the
	      group-specific operation to select the SKE or fail. If the group-specific
	      operation fails, the counter is incremented, a new ske-seed is generated,
	      and the hunting-and-pecking continues. This process continues until the
	      group-specific operation returns the password element. After the
	      password element has been chosen, a random number is used in place of 
	      the password in the ske-seed calculation, and the hunting-and-pecking
	      continues until the counter is greater than the security parameter, k.
	    </t>
	    <section title="ECP Operation to Select SKE">
	      <t>
	        The group-specific operation for ECP groups uses ske-value, ske-seed, and
		the equation of the curve to produce SKE. First, ske-value is used directly
		as the x-coordinate, x, with the equation of the elliptic curve, with
		parameters a and b from the domain parameter set of the curve, to solve
		for a y-coordinate, y.
	      </t>
	      <t>
		Note: A method of checking whether a solution to the equation of the elliptic
		curve is to see whether the Legendre symbol of (x^3 + ax + b) equals one (1).
		If it does, then a solution exists; if it does not, then there is no
		solution.
	      </t>
	      <t>
	        If there is no solution to the equation of the elliptic curve, then the
		operation fails, the counter
		is incremented, a new ske-value and ske-seed are selected, and the
		hunting-and-pecking continues. If there is a solution then, y is
		calculated as the square root of (x^3 + ax + b) using the equation of
		the elliptic curve. In this case, an ambiguity
		exists as there are technically two solutions to the equation, and ske-seed
		is used to unambiguously select one of them. If the low-order bit of ske-seed
		is equal to the low-order bit of y, then a candidate SKE is defined as
		the point (x,y); if the low-order bit of ske-seed differs from the low-order
		bit of y then a candidate SKE is defined as the point (x, p-y) where p is
		the prime from the negotiated group's domain parameter set. The candidate
		SKE becomes the SKE, and the ECP-specific operation completes successfully.
	      </t>
	      <t>
	      Algorithmically, the process looks like this:
	      <figure anchor="Fixing_ECP_SKE" title="Fixing SKE for ECP Groups">
		<artwork align="center"><![CDATA[
  found = 0
  counter = 1
  v = psk
  do {
    ske-seed = prf(Ni | Nr, v | counter)
    ske-value = prf+(ske-seed, "IKE SKE Hunting And Pecking")
    if (ske-value < p) 
    then
      x = ske-value
      if ( (y = sqrt(x^3 + ax + b)) != FAIL)
      then
        if (found == 0)
        then
          if (LSB(y) == LSB(ske-seed))
          then
            SKE = (x,y)
          else
            SKE = (x, p-y)
          fi		        
          found = 1
          v = random()
        fi
      fi
    fi
    counter = counter + 1
  } while ((found == 0) || (counter <= k))
	      ]]></artwork>
		<postamble>
		  where FAIL indicates that there is no solution to sqrt(x^3 + ax + b).
		</postamble>
	      </figure>
	      </t>
	    <t>
	      Note: For ECP groups, the probability that more than "n" iterations of the 
	      hunting-and-pecking loop are required to find SKE is roughly (1-(r/2p))^n,
	      which rapidly approaches zero (0) as "n" increases.
	    </t>
	    </section>
	    <section title="MODP Operation to Select SKE">
	      <t>
	        The group-specific operation for MODP groups takes ske-value, the prime, p,
		and order, r, from the group's domain parameter set to directly produce a
		candidate SKE by exponentiating the ske-value to the value ((p-1)/r) modulo the
		prime. If the candidate SKE is greater than one (1), the candidate SKE becomes
		the SKE, and the MODP-specific operation completes successfully. Otherwise,
		the MODP-specific operation fails (and the hunting-and-pecking continues).
	      </t>
	      <t>
	      Algorithmically, the process looks like this:
	      <figure anchor="Fixing_MODP_SKE" title="Fixing SKE for MODP Groups">
		<artwork align="center"><![CDATA[
  found = 0
  counter = 1
  v = psk
  do {
    ske-seed = prf(Ni | Nr, v | counter)
    ske-value = prf+(ske-seed, "IKE SKE Hunting And Pecking")
    if (ske-value < p) 
    then
      ELE = ske-value ^ ((p-1)/r) mod p
      if (ELE > 1)
      then
        if (found == 0)
          SKE = ELE
          found = 1
          v = random()
        fi
      fi
    fi
    counter = counter + 1
  } while ((found == 0) || (counter <= k))
	      ]]></artwork>
	      </figure>
	      </t>


	    <t>
	      Note: For MODP groups, the probability that more than "n" iterations of the 
	      hunting-and-pecking loop are required to find SKE is roughly ((m-p)/p)^n,
	      where m is the largest unsigned number that can be expressed in len(p) bits,
	      which rapidly approaches zero (0) as "n" increases.
	    </t>
	    </section>
	  </section>
	  <section anchor="encoding" title="Encoding and Decoding of Group Elements and Scalars">
	    <t>
	      The payloads used in the Secure PSK Authentication method
	      contain elements from the negotiated group and scalar values. To
	      ensure interoperability, scalars and field elements MUST be represented
	      in payloads in accordance with the requirements in this section.
	    </t>
	    <section anchor="enc_scalar" title="Encoding and Decoding of Scalars">
	      <t>
	        Scalars MUST be represented (in binary form) as unsigned integers
		that are strictly less than r, the order of the generator of the 
		agreed-upon cryptographic group. The binary representation of each
		scalar MUST have a bit length equal to the bit length of the binary
		representation of r. This requirement is enforced, if necessary, by
		prepending the binary representation of the integer with zeros until
		the required length is achieved.
	      </t>
	      <t>
	        Scalars in the form of unsigned integers are converted into
octet strings
		and back again using the technique described in <xref target="RFC6090"/>.
	      </t>
	    </section>
	    <section anchor="enc_elem" title="Encoding and Decoding of ECP Elements">
	      <t>
	        Elements in ECP groups are points on the negotiated elliptic curve.
	        Each such element MUST be represented by the concatenation of two
	        components, an x-coordinate and a y-coordinate.
	      </t>
	      <t>
	      	Each of the two components, the x-coordinate and the y-coordinate,
		MUST be represented (in binary form) as an unsigned integer that
		is strictly less than the prime, p, from the group's domain parameter
		set. The binary representation of each component MUST have a bit
		length equal to the bit length of the binary representation of p.
		This length requirement is enforced, if necessary, by prepending 
		the binary representation of the integer with zeros until the
		required length is achieved.
	      </t>
	      <t>
	        The unsigned integers that represent the coordinates of the point
		are converted into octet strings and back again using the technique
		described in <xref target="RFC6090"/>.
	      </t>
	      <t>
	        Since the field element is represented in a payload by 
	        the x-coordinate followed by the y-coordinate, it follows, then, that
	        the length of the element in the payload MUST be twice the bit length
	        of p.
	      </t>
	    </section>
	    <section title="Encoding and Decoding of MODP Elements">
	      <t>
	      Elements in MODP groups MUST be represented (in binary form) as
	      unsigned integers that are strictly less than the prime, p, from
	      the group's domain parameter set. The binary representation of each
	      group element MUST have a bit length equal to the bit length of
	      the binary representation of p. This length requirement is enforced,
	      if necessary, by prepending the binary representation of the integer
	      with zeros until the required length is achieved.
	      </t>
	      <t>
	        The unsigned integer that represents a MODP element is converted into
		an octet string and back using the technique described in 
		<xref target="RFC6090"/>.
	      </t>
	    </section>
	  </section>
	  <section title="Message Generation and Processing">
	  <section anchor="gen_commit" title="Generation of a Commit">
	    <t>
	      Before a Commit payload can be generated, the SKE must be fixed using the
	      process described in <xref target="fixing_SKE"/>.
	    </t>
	    <t>
	      A Commit payload has two components, a scalar and an element.
	      To generate a Commit payload, two random numbers, a "private" value and
	      a "mask" value, are generated (see 
	      <xref target="rand_num"/>). Their sum modulo the order of the group, r,
	      becomes the scalar component:
	      <list hangIndent="4" style="empty">
		<t>
		  scalar = (private + mask) mod r
		</t>
	      </list>
	      If the scalar is not greater than one (1), the private and mask values
	      MUST be thrown away, and new values randomly generated. If the scalar
	      is greater than one (1), the inverse of the scalar operation with the
	      mask and SKE becomes the element component.
	      <list hangIndent="4" style="empty">
		<t>
		  Element = inverse(scalar-op(mask, SKE))
		</t>
	      </list>
	      The Commit payload consists of the scalar followed by the element,
	      and the scalar and element are encoded in the Commit payload according
	      to <xref target="encoding"/>.
	    </t>
	  </section>
	  <section anchor="proc_commit" title="Processing of a Commit">
	    <t>
	      Upon receipt of a peer's Commit payload, the scalar and element MUST
	      be validated. The processing of an element depends on the type, either
	      an ECP element or a MODP element.
	    </t>
	      <section anchor="valid_ecp_elem" title="Validation of an ECP Element">
	        <t>
	        Validating a received ECP element involves: 1) checking whether the
	        two coordinates, x and y, are both greater than zero (0) and less
	        than the prime defining the underlying field; and 2) checking whether
	        the x- and y-coordinates satisfy the equation of the curve (that is,
	        that they produce a valid point on the curve that is not "0").
	        If either of these conditions are not met, the received
	        element is invalid; otherwise, the received element is valid.
	      </t>
	    </section>
	    <section anchor="valid_modp_elem" title="Validation of a MODP Element">
	      <t>
	        A received MODP element is valid if: 1) it is between one (1) and the
	        prime, p, exclusive; and 2) if modular exponentiation of the element
	        by the group order, r, equals one (1).  If either of these conditions
	        are not true, the received element is invalid; otherwise, the 
		received element is valid.
	      </t>
	    </section>
	    <section anchor="comm_proc" title="Commit Processing Steps">
	      <t>
	      Commit payload validation is accomplished by the following steps:
	      <list hangIndent="0" style="numbers">
	        <t>
		  The length of the Commit payload is checked against its anticipated
		  length (the anticipated length of the scalar plus the anticipated length of the
		  element, for the negotiated group). If it
		  is incorrect, the Commit payload is invalidated; otherwise, processing continues.
		</t>
		<t>
		  The peer's scalar is extracted from the Commit payload according to
		  <xref target="enc_scalar"/> and checked to ensure
		  it is between one (1) and r, the order of the negotiated group, exclusive.
		  If it is not, the Commit payload is invalidated; otherwise, processing continues.
		</t>
		<t>
		  The peer's element is extracted from the Commit payload according to
		  <xref target="enc_elem"/> and checked in a manner
		  that depends on the type of group negotiated. If the group is ECP, the
		  element is validated according to <xref target="valid_ecp_elem"/>. If the
		  group is MODP, the element is validated according to
		  <xref target="valid_modp_elem"/>. If the element is not valid, then
		  the Commit payload is invalidated; otherwise, the Commit payload is validated.
		</t>
		<t>
		  The Initiator of the IKE exchange has an added requirement to verify that
		  the received element and scalar from the Commit payload differ from the
		  element and scalar sent to the Responder. If they are identical, it
		  signifies a reflection attack, and the Commit payload is invalidated.
		</t>
	      </list>
	      If the Commit payload is invalidated, the payload MUST be discarded and the 
	      IKE exchange aborted.
	      </t>
	      </section>
	  </section>
	  <section anchor="authentication" title="Authentication of the Exchange">
	    <t>
	      After a Commit payload has been generated and a peer's Commit payload 
	      has been processed, a shared secret used to authenticate the peer is
	      derived. Using SKE, the "private" value generated as part of Commit payload
	      generation, and the peer's scalar and element from the peer's Commit
	      payload, named here peer-scalar and Peer-Element, respectively, a
	      preliminary shared secret, skey, is generated as:
	    </t>
	      <figure>
		<artwork align="center"><![CDATA[
skey = F(scalar-op(private, 
                   element-op(Peer-Element, 
                              scalar-op(peer-scalar, SKE))))
		]]></artwork>
	      </figure>			    
	    <t>
	        For the purposes of subsequent computation, 
		the bit length of skey SHALL be equal to the bit length of the prime, p,
		used in either a MODP or ECP group. This bit length SHALL be enforced,
		if necessary, by prepending zeros to the value until the required
		length is achieved.
	    </t>
	    <t>
	      A shared secret, ss, is then computed from skey and the nonces exchanged
	      by the Initiator (Ni) and Responder (Nr) (without the fixed headers)
	      using prf():
	    </t>
	      <figure>
	        <artwork align="center"><![CDATA[
ss = prf(Ni | Nr, skey | "Secure PSK Authentication in IKE")
	        ]]></artwork>
	      </figure>
	    <t>
	      The shared secret, ss, is used in an AUTH authentication payload 
	      to prove possession of the shared secret and therefore knowledge of the
	      pre-shared key. 
	    </t>
	  </section>

	  </section>
	  <section title="Payload Format">
	  <section anchor="commit_payload" title="Commit Payload">
	  <t>
	    <xref target="RFC6467"/>
	    defines a Generic Secure Password Method (GSPM) payload 
	    that is used to convey information that is specific to a particular secure
	    password method. This memo uses the GSPM payload as a Commit payload to 
	    contain the scalar and element used in the Secure PSK Authentication
	    exchange:
	  </t>
<t>The Commit payload is defined as follows:
</t>



	      <figure>
	        <artwork align="center"><![CDATA[
                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    ! Next Payload  !C!  RESERVED   !         Payload Length        !
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                            scalar                             ~
    |                                                               |
    ~                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                               |                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               ~
    |                                                               |
    ~                           Element                             ~
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		]]></artwork>
	      </figure>
	    <t>
	      The scalar and element SHALL be encoded in the Commit payload
	      according to <xref target="encoding"/>.
	    </t>
	  </section>

	  </section>
	  <section anchor="ikev2_exchange" title="IKEv2 Messaging">
	    <t>
	      Secure PSK Authentication modifies the IKE_AUTH exchange by adding one additional
	      round trip to exchange Commit payloads to perform the Secure PSK Authentication
	      exchange and by changing the calculation of the AUTH payload data to bind
	      the IKEv2 exchange to the outcome of the Secure PSK Authentication exchange
	      (see <xref target="ikev2_flow"/>).
	    </t>
	    <figure anchor="ikev2_flow" title="Secure PSK in IKEv2">
	      <artwork align="center"><![CDATA[
 Initiator                               Responder
-----------                             -----------

IKE_SA_INIT:

 HDR, SAi1, KEi, Ni, 
      N(SPM-SPSK)  -->

                               <--    HDR, SAr1, KEr, Nr,
                                           N(SPM-SPSK)

IKE_AUTH:

 HDR, SK {IDi, COMi, [IDr,]
          SAi2, TSi, TSr}      -->
                               <--    HDR, SK {IDr, COMr}
 HDR, SK {AUTHi}               -->
                               <--    HDR, SK {AUTHr, SAr2, TSi, TSr}
	      ]]></artwork>
	      <postamble>
	        where N(SPM-SPSK) indicates the Secure Password Methods Notify payloads
		used to negotiate the use of Secure PSK Authentication
		(see <xref target="neg_SPSK"/>), COMi and AUTHi are the Commit
		payload and AUTH payload, respectively, sent by the Initiator, and COMr 
		and AUTHr are the Commit payload and AUTH payload, respectively, sent
		by the Responder.
	      </postamble>
	    </figure>
	    <t>
	      When doing Secure PSK Authentication, the AUTH payloads SHALL be computed as
	      <list hangIndent="4" style="empty">
	        <t>
		  AUTHi = prf(ss, &lt;InitiatorSignedOctets&gt; | COMi | COMr)
		</t>
	        <t>
		  AUTHr = prf(ss, &lt;ResponderSignedOctets&gt; | COMr | COMi)
		</t>
	      </list>
	      where "ss" is the shared secret derived in <xref target="authentication"/>,
	      COMi and COMr are the entire Commit payloads (including the fixed headers)
	      sent by the Initiator and Responder, respectively, 
	      and &lt;InitiatorSignedOctets&gt; and &lt;ResponderSignedOctets&gt; are
	      defined in <xref target="RFC5996"/>.
	      The Authentication Method indicated in both AUTH payloads SHALL be 
	      "Generic Secure Password Authentication Method", value 12, from
	      <xref target="IKEV2-IANA"/>.
	    </t>
	  </section>
	</section>

      <section anchor="IANA" title="IANA Considerations">
	<t>
	  IANA has assigned the value 3 for "Secure PSK Authentication"
	  from the Secure Password Authentication Method registry
	  in <xref target="IKEV2-IANA"/>.
	</t>
      </section>
      <section anchor="Security" title="Security Considerations">
        <t>
	  Both the Initiator and Responder obtain a shared secret, "ss" (see
	  <xref target="authentication"/>), based on a secret group element and
	  their own private values contributed to the exchange. If they do
	  not share the same pre-shared key, they will be unable to derive
	  the same secret group element, and if they do
	  not share the same secret group element, they will be unable to
	  derive the same shared secret.
	</t>
	  <t>
	    Resistance to dictionary attack means that the adversary must launch an active attack
	    to make a single guess at the pre-shared key. If the size of the pool from which the
	    key was extracted was d and each key in the pool has an equal probability
	    of being chosen, then the probability of success after a
	    single guess is 1/d.&nbsp; After
	    x guesses, and removal of failed guesses from the pool of possible keys, the
	    probability becomes 1/(d-x). As x grows, so does the probability of success.
	    Therefore, it is possible for an adversary to determine the pre-shared key through
	    repeated brute-force, active, guessing attacks. This authentication method does not
	    presume to be secure against this, and implementations SHOULD ensure the value of d is
	    sufficiently large to prevent this attack. Implementations SHOULD also take
	    countermeasures, for instance, refusing authentication attempts for a certain
	    amount of time after the number of failed authentication attempts reaches a certain
	    threshold. No such threshold or amount of time is recommended in this memo.
          </t>
	  <t>
	    An active attacker can impersonate the Responder of the exchange and
	    send a forged Commit payload after receiving the Initiator's Commit payload. The attacker
	    then waits until it receives the authentication payload from the Responder.
	    Now the attacker can attempt to run through all possible values of the pre-shared key,
	    computing SKE (see <xref target="fixing_SKE"/>), computing "ss"
	    (see <xref target="authentication"/>), and attempting to recreate the
	    Confirm payload from the Responder.
	  </t>
	  <t>
	    But, by sending a forged Commit payload the attacker commits to a single guess of the
	    pre-shared key. That value was used by the Responder in his computation
	    of "ss", which was used in the authentication payload. Any guess of the pre-shared
	    key that differs from the one used in the forged Commit payload would result in
	    each side using a different secret element in the computation of "ss" and
	    therefore the authentication payload could not be verified as correct, even if
	    a subsequent guess, while running through all possible values, was correct.
	    The attacker gets one guess, and one guess only, per active attack.
          </t>
	  <t>
	    An attacker, acting as either the Initiator or Responder, can take the
	    element from the Commit payload received from the other party, reconstruct
	    the random "mask" value used
	    in its construction, and then recover the other party's "private" value 
	    from the scalar in the Commit payload.
	    But this requires the attacker to solve the discrete logarithm problem, which
	    we assumed was intractable (<xref target="assumptions"/>).
	  </t>
	<t>
	  Instead of attempting to guess at pre-shared keys, an attacker can attempt
	  to determine SKE and then launch an attack, but SKE is determined by the
	  output of the pseudo-random function, prf, which is assumed to be indistinguishable
	  from a random source (<xref target="assumptions"/>). 
	  Therefore, each element of the finite cyclic group
	  will have an equal probability of being the SKE. The probability of guessing
	  SKE will be 1/r, where r is the order of the group. This is the same
	  probability of guessing the solution to the discrete logarithm, which is
	  assumed to be intractable (<xref target="assumptions"/>). The attacker would have 
	  a better chance of success at guessing the input to prf, i.e., the pre-shared key,
	  since the order of the group will be many orders of magnitude greater than
	  the size of the pool of pre-shared keys.
	</t>
	  <t>
	    The implications of resistance to dictionary attack are significant.
	    An implementation can provision a pre-shared key in a practical and realistic
	    manner -- i.e., it MAY be a character string, and it MAY be relatively short --
	    and still maintain security. The nature of the pre-shared key determines
	    the size of the pool, D, and countermeasures can prevent an adversary from
	    determining the secret in the only possible way: repeated, active, guessing attacks.
	    For example, a simple four-character string using lowercase English characters,
	    and assuming random selection of those characters,
	    will result in D of over four hundred thousand.
	    An adversary would need to mount over one hundred thousand
	    active, guessing attacks (which will easily be detected) before gaining any
	    significant advantage in determining the pre-shared key.
	  </t>
	  <t>
	    If an attacker knows the number of hunting-and-pecking loops that were
	    required to determine SKE, it is possible to eliminate passwords from the
	    pool of potential passwords and increase the probability of successfully
	    guessing the real password. MODP groups will require more than "n" loops
	    with a probability based on the value of the prime -- if m is the largest
	    unsigned number that can be expressed in len(p) bits, then the probability
	    is ((m-p)/p)^n -- which will typically be very small for the groups defined
	    in <xref target="IKEV2-IANA"/>. ECP groups will require more than one "n"
	    loop with a probability of roughly (1-(r/2p))^n. Therefore, a security
	    parameter, k, is defined that will ensure that at least k loops will always
	    be executed regardless of whether SKE is found in less than k loops. There
	    is still a probability that a password would require more than k loops,
	    and a side-channel attacker could use that information to his advantage,
	    so selection of the value of k should be based on a trade-off between the
	    additional workload to always perform k iterations and the potential of
	    providing information to a side-channel attacker. It is important to note
	    that the possibility of a successful side-channel attack is greater against
	    ECP groups than MODP groups, and it might be appropriate to have separate
	    values of k for the two.
	  </t>
	  <t>
	    For a more detailed discussion of the security of the key exchange underlying
	    this authentication method, see <xref target="SAE"/> and <xref target="RFC5931"/>.
	  </t>
      </section>
      <section anchor="Acknowledgements" title="Acknowledgements">
	<t>
        The author would like to thank Scott Fluhrer and Hideyuki Suzuki for their
	insight in discovering flaws in earlier versions of the key exchange that
	underlies this authentication method and for their helpful suggestions in
	improving it. Thanks to Lily Chen for useful advice on the hunting-and-pecking
	technique  to "hash into" an
	element in a group and to Jin-Meng Ho for a discussion on countering a
	small sub-group attack. Rich Davis suggested several checks on received
	messages that greatly increase the security of the underlying key exchange.
	Hugo Krawczyk suggested using the prf as an extractor.
        </t>
      </section>
    </middle>

    <back>

      <references title="Normative References">

        &rfc2119;
	&rfc2104;
	&rfc4013;
	&rfc3454;
	&rfc5996;
	&rfc6090;
	&rfc6467;

	<reference anchor="IKEV2-IANA" target="http://www.iana.org/assignments/ikev2-parameters">
	  <front>
	    <title>
	     IKEv2 Parameters
	    </title>
	    <author>
	      <organization>IANA</organization>
	    </author>
	  </front>
	</reference>
      </references>
      <references title="Informative References">

	&rfc4086;
	&rfc4301;
	&rfc5869;
	&rfc5931;

	<reference anchor="SAE">
	  <front>
	    <title>
	      Simultaneous Authentication of Equals: A Secure, Password-Based Key Exchange
	      for Mesh Networks
	    </title>
	    <author initials="D" surname="Harkins">
	      <organization/>
	    </author>
	    <date year="2008"/>
	  </front>
	  <seriesInfo name="Proceedings of the 2008 Second International Conference on Sensor
			   Technologies and Applications" value="Volume 00"/>
	</reference>

	<reference anchor="BM92">
	  <front>
	    <title>Encrypted Key Exchange: Password-Based Protocols Secure Against Dictionary Attacks</title>
	    <author initials="S" surname="Bellovin">
		<organization>Bell Laboratories</organization>
	    </author>
	    <author initials="M" surname="Merritt">
		<organization>Bell Laboratories</organization>
	    </author>
	    <date year="1992"/>
	  </front>
	  <seriesInfo name="Proceedings of the IEEE Symposium on Security and Privacy," value="Oakland"/>
	</reference>



	<reference anchor="BPR00">
	  <front>
	    <title>Authenticated Key Exchange Secure Against Dictionary Attacks</title>
	    <author initials="M" surname="Bellare">
	      <organization/>
	    </author>
	    <author initials="D" surname="Pointcheval">
	      <organization/>
	    </author>
	    <author initials="P" surname="Rogaway">
	      <organization/>
	    </author>
	    <date year="2000"/>
	  </front>
	  <seriesInfo name="Advances in Cryptology -- Eurocrypt '00, Lecture Notes in Computer Science" value="Springer-Verlag"/>
	</reference>
	<reference anchor="BMP00">
	  <front>
	    <title>Provably Secure Password-Authenticated Key Exchange Using Diffie-Hellman</title>
	    <author initials="V" surname="Boyko">
		<organization/>
	    </author>
	    <author initials="P" surname="MacKenzie">
		<organization/>
	    </author>
	    <author initials="S" surname="Patel">
		<organization/>
	    </author>
	    <date year="2000"/>
	  </front>
	  <seriesInfo name="Proceedings of Eurocrypt 2000, LNCS 1807" value="Springer-Verlag"/>
	</reference>
    </references>
  </back>
</rfc>
