<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc2246 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2246.xml">
<!ENTITY rfc4346 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4346.xml">
<!ENTITY rfc4309 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4309.xml">
<!ENTITY rfc4366 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4366.xml">
<!ENTITY rfc5288 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5288.xml">
<!ENTITY ietf-tls-rfc4346-bis SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-tls-rfc4346-bis.xml">
<!ENTITY ietf-tls-rfc4347-bis SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-tls-rfc4347-bis.xml">
<!ENTITY ietf-tls-ctr SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-tls-ctr.xml">
<!ENTITY rescorla-tls-suiteb SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.rescorla-tls-suiteb.xml">
<!ENTITY I-D.draft-mcgrew-fundamental-ecc PUBLIC "" "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.draft-mcgrew-fundamental-ecc-04.xml">
<!ENTITY rfc8126 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml">
<!ENTITY rfc4309 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4309.xml">
<!ENTITY rfc4506 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4506.xml">
<!ENTITY rfc5246 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY rfc5116 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5116.xml">
<!ENTITY rfc5430 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5430.xml">
<!ENTITY rfc5246 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY rfc4492 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4492.xml">
<!ENTITY rfc6090 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6090.xml">
<!ENTITY rfc8174 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml">

]>
<?rfc toc="yes"?>
<?rfc tocdepth="6"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc number="8391" ipr="trust200902" category="info" submissionType="IRTF" consensus="yes">

  <front>

    <title abbrev="XMSS">XMSS: eXtended Merkle Signature Scheme</title>

    <author fullname="Andreas Huelsing" initials="A" surname="Huelsing">
      <organization>TU Eindhoven</organization>
      <address>
        <postal>
          <street>P.O. Box 513</street>
          <city>Eindhoven</city>
          <code>5600 MB</code>
          <country>The Netherlands</country>
        </postal>
        <email>ietf@huelsing.net</email>
      </address>
    </author>

    <author fullname="Denis Butin" initials="D" surname="Butin">
      <organization>TU Darmstadt</organization>
      <address>
        <postal>
          <street>Hochschulstrasse 10</street>
          <city>Darmstadt</city>
          <code>64289</code>
          <country>Germany</country>
        </postal>
        <email>dbutin@cdc.informatik.tu-darmstadt.de</email>
      </address>
    </author>

    <author fullname="Stefan-Lukas Gazdag" initials="S" surname="Gazdag">
      <organization>genua GmbH</organization>
      <address>
        <postal>
          <street>Domagkstrasse 7</street>
          <city>Kirchheim bei Muenchen</city>
          <code>85551</code>
          <country>Germany</country>
        </postal>
        <email>ietf@gazdag.de</email>
      </address>
    </author>

    <author fullname="Joost Rijneveld" initials="J" surname="Rijneveld">
      <organization>Radboud University</organization>
      <address>
        <postal>
          <street>Toernooiveld 212</street>
          <city>Nijmegen</city>
          <code>6525 EC</code>
          <country>The Netherlands</country>
        </postal>
        <email>ietf@joostrijneveld.nl</email>
      </address>
    </author>
    
    <author fullname="Aziz Mohaisen" initials="A" surname="Mohaisen">
      <organization>University of Central Florida</organization>
      <address>
        <postal>
          <street>4000 Central Florida Blvd</street>
          <city>Orlando</city>
          <region>FL</region>
          <code>32816</code>
          <country>United States of America</country>
        </postal>
        <phone>+1 407 823-1294</phone>
        <email>mohaisen@ieee.org</email>
      </address>
    </author>

<date month="May" year="2018"/>
<area>IRTF</area>

<workgroup>Crypto Forum</workgroup>


<abstract>
<t>
This note describes the eXtended Merkle Signature Scheme (XMSS), a hash-based
digital signature system that is based on existing descriptions in scientific
literature. 
   This note specifies Winternitz One-Time Signature Plus (WOTS+), a one-time
   signature scheme; XMSS, a single-tree
   scheme; and XMSS^MT, a multi-tree variant of XMSS.    
Both XMSS and XMSS^MT
use WOTS+ as a main building block. XMSS provides cryptographic digital
signatures without relying on the conjectured hardness of mathematical problems.


Instead, it is proven that it only relies on the properties of cryptographic
hash functions. XMSS provides strong security guarantees and is even secure
when the collision resistance of the underlying hash function is broken. It is
suitable for compact implementations, is relatively simple to implement, and
naturally resists side-channel attacks. Unlike most other signature systems,
hash-based signatures can so far withstand known attacks using quantum computers.
</t>
</abstract>

</front>

<middle>
<section title="Introduction">

<t>
A (cryptographic) digital signature scheme provides asymmetric message authentication. The key 
generation algorithm produces a key pair consisting of a private and a public key. A message is 
signed using a private key to produce a signature.  A message/signature 
pair can be verified using a public key. A One-Time Signature (OTS) scheme allows using a 
key pair to sign exactly one message securely. A Many-Time Signature (MTS) 
system can be used to sign multiple messages.  
</t>

<t>
OTS schemes, and MTS schemes
composed from them, were proposed by Merkle in 1979 <xref target="Merkle83"/>. 
They were well-studied in the 1990s and have regained interest from the mid 2000s onwards because of their
resistance against quantum-computer-aided attacks. These kinds of signature schemes are called 
hash-based signature schemes as they are built out of a cryptographic hash function.
Hash-based signature schemes generally feature small 
private and public keys as well as fast signature generation and verification; however,
they also feature large signatures and relatively slow key generation.  In
addition, they are suitable for compact
implementations that benefit various applications and are naturally resistant to most kinds of side-channel attacks.
</t>


<t>
Some progress has already been made toward introducing and
standardizing hash-based signatures. Buchmann, Dahmen,
and Huelsing proposed the eXtended Merkle Signature Scheme (XMSS) <xref
target="BDH11"/>, which offers better efficiency than
   Merkle's original scheme and a modern security proof in the standard model.
   McGrew, Curcio, and Fluhrer authored an Internet-Draft <xref target="MCF18"/>
   specifying the
   Leighton-Micali Signature (LMS) scheme, which builds on the seminal works
   by
   Lamport, Diffie, Winternitz, and Merkle, taking a different approach than
   XMSS and
    relying entirely on security arguments in the random oracle model.  
   Very recently, the stateless hash-based signature scheme SPHINCS was
   introduced <xref target="BHH15"/>, with the intent of being easier to
   deploy in
   current applications.  A reasonable next step toward introducing
   hash-based signatures is to complete the specifications of the basic
   algorithms -- LMS, XMSS, SPHINCS, and/or variants.
</t>

<t>
The eXtended Merkle Signature Scheme (XMSS) <xref target="BDH11"/> is the latest
stateful hash-based signature scheme. It has the smallest signatures out of such schemes and comes
with a multi-tree variant that solves the problem of slow key generation. Moreover,
it can be shown that XMSS is secure, making only mild assumptions on the underlying hash function.  In particular,
it is not required that the cryptographic hash function is collision-resistant for the security of XMSS.
Improvements upon XMSS, as described in <xref target="HRS16"/>, are part of this note.
</t>


<t>
This document describes a single-tree and a multi-tree variant of XMSS. 
It also describes WOTS+, a variant of the Winternitz OTS scheme 
introduced in <xref target="Huelsing13"/> that is used by XMSS. The schemes are described with 
enough specificity to ensure interoperability between implementations.
</t>

<t>
This document is structured as follows.  Notation is introduced in
<xref target="notation"/>. <xref target="primitives"/> describes
the WOTS+ signature system. MTS schemes are defined in <xref target="schemes"/>: the eXtended Merkle 
Signature Scheme (XMSS) in <xref target="xmss"/> and its multi-tree 
variant (XMSS^MT) in <xref target="xmssmt"/>. Parameter sets are 
described in <xref target="param"/>. 
<xref target="rationale"/> describes the rationale behind choices in this
note. 
<xref target="code"/> gives
information about the reference code.
The IANA registry for these signature systems is described in 
<xref target="IANA"/>.  Finally, security considerations are presented in 
<xref target="Security"/>.
</t>

<section title="CFRG Note on Post-Quantum Cryptography">
    <t>
All post-quantum algorithms documented by the Crypto Forum Research Group (CFRG) are today
considered ready for experimentation and further engineering
development (e.g., to establish the impact of performance and sizes
on IETF protocols). However, at the time of writing, we do not have
significant deployment experience with such algorithms.
    </t>
    <t>
Many of these algorithms come with specific restrictions, e.g.,
change of classical interface or less cryptanalysis of proposed
parameters than established schemes. CFRG has consensus that all
documents describing post-quantum technologies include the above
paragraph and a clear additional warning about any specific restrictions,
especially as those might affect use or deployment of the specific scheme.
That guidance may be changed over time via document updates.
    </t>
    <t>
Additionally, for XMSS:
    </t>
    <t>
CFRG consensus is that we are confident in the cryptographic security
of the signature schemes described in this document against
quantum computers, given the current state of the research
community's knowledge about quantum algorithms. Indeed, we are
confident that the security of a significant part of the Internet
could be made dependent on the signature schemes defined in this
document, if developers take care of the following.
    </t>
    <t>
In contrast to traditional signature schemes, the signature schemes
described in this document are stateful, meaning the secret key
changes over time. If a secret key state is used twice, no cryptographic
security guarantees remain. In consequence, it becomes feasible to forge 
a signature on a new message. This is a new property that most
developers will not be familiar with and requires careful handling of
secret keys. Developers should not use the schemes described here
except in systems that prevent the reuse of secret key states.
    </t>
    <t>
Note that the fact that the schemes described in this document are stateful 
also implies that classical APIs for digital signatures cannot be used without
modification. The API MUST be able to handle a secret key state; in particular,
this 
means that the API MUST allow to return an updated secret key state.
    </t>
</section>

<section title="Conventions Used in This Document">

        <t>
    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
    "MAY", and "OPTIONAL" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>

</section>

</section>

<section title="Notation" anchor="notation">

<section title="Data Types" anchor="datatypes">

<t>
Bytes and byte strings are the fundamental data types. A byte
is a sequence of eight bits. A single byte is denoted as a
pair of hexadecimal digits with a leading "0x". A byte string is an
ordered sequence of zero or more bytes and is denoted as an ordered
sequence of hexadecimal characters with a leading "0x". For example,
0xe534f0 is a byte string of length 3. An array of byte strings is an
ordered, indexed set starting with index 0 in which all byte strings
have identical length. We assume big-endian representation for any
data types or structures.
</t>

</section>

<section title="Functions" anchor="functions">
<t>
If x is a non-negative real number, then we define the following functions:
<list>
<t>ceil(x): returns the smallest integer greater than or equal to x.</t>
<t>floor(x): returns the largest integer less than or equal to x.</t>
<t>lg(x): returns the logarithm to base 2 of x.</t>
</list>
</t>
</section>

<section title="Operators" anchor="operators">

<t>
When a and b are integers, mathematical operators are defined as follows:
<list>
<t>^ : a ^ b denotes the result of a raised to the power of b.</t>
<t>* : a * b denotes the product of a and b. This operator is
sometimes omitted in the absence of ambiguity, as in
usual mathematical notation.</t>
<t>/ : a / b denotes the quotient of a by non-zero b.</t>
<t>% : a % b denotes the non-negative remainder of the integer division of a
by b.</t>
<t>+ : a + b denotes the sum of a and b.</t>
<t>- : a - b denotes the difference of a and b.</t>

<t>++ : a++ denotes incrementing a by 1, i.e., a = a + 1.</t>
<t>&lt;&lt; : a &lt;&lt; b denotes a logical left shift with b being non-negative, i.e., a * 2^b.</t>
<t>&gt;&gt; : a &gt;&gt; b denotes a logical right shift with b being non-negative, i.e., floor(a / 2^b).</t>
</list>
The standard order of operations is used when evaluating arithmetic expressions.
</t>

<t>
Arrays are used in the common way, where the i^th element of an array A is
denoted A[i]. Byte strings are treated as arrays of bytes where necessary:
if X is a byte string, then X[i] denotes its i^th byte, where X[0] is the
leftmost byte.
</t>

<t>
If A and B are byte strings of equal length, then:
<list style="symbols">
<t>A AND B denotes the bitwise logical conjunction operation.</t>
<t>A XOR B denotes the bitwise logical exclusive disjunction operation.</t>
</list>
</t>

<t>
When B is a byte and i is an integer, then B &gt;&gt; i denotes the logical
right-shift operation.
</t>

<t>
If X is an x-byte string and Y a y-byte string, then X || Y denotes the
concatenation of X and Y, with X || Y = X[0] ... X[x-1] Y[0] ... Y[y-1].
</t>

</section>


<section title="Integer-to-Byte Conversion" anchor="intToByte">
<t>
If x and y are non-negative integers, we define Z = toByte(x, y) to be the y-byte
string containing the binary representation of x in big-endian byte order.
</t>
</section>

<section title="Hash Function Address Scheme" anchor="address">

<t>
The schemes described in this document randomize each hash function call. This
means that aside from the initial message digest, 
a different key and different bitmask is used for each hash function
call. These values are pseudorandomly
generated using a pseudorandom function that takes a key SEED and a 32-byte
address ADRS as input and outputs an n-byte value, where n is the security
parameter. Here we explain the structure of
address ADRS and propose setter methods to manipulate the address. 
We explain the generation of the addresses in the following
sections where they are used.
</t>

<t>
The schemes in the next two sections use two kinds of hash functions
parameterized by security parameter n. For the hash tree constructions, a hash
function that maps an n-byte key and 2n-byte inputs to n-byte outputs is used.
To randomize this function, 3n bytes are needed -- n bytes for the key and 2n
bytes for a bitmask. For the OTS scheme constructions, a hash
function that maps n-byte keys and n-byte inputs to n-byte outputs is used. To
randomize this function, 2n bytes are needed -- n bytes for the key and n bytes
for a bitmask. Consequently, three addresses are needed for the first function
and two addresses for the second one.
</t>

<t>
There are three different types of addresses for the different use cases. One
type is used for the hashes in OTS schemes, one is used for hashes
within the main Merkle tree construction, and one is used for hashes in the
L-trees. The latter is used to compress one-time public keys. All these
types share as much format as possible.
In the remainder of this section, we describe these
types in detail.
</t>

<t>
The structure of an address complies with word
borders, with a word being 32 bits long in this context. 
Only the tree address is too
long to fit a single word, but it can fit a double word.
An address is
structured as follows. It always starts with a layer address of one word in the
most significant bits, followed by a tree address of two words. Both addresses
are needed for the multi-tree variant (see <xref target="xmssmt"/>) and
describe the position of a tree within a multi-tree. They are therefore set to
zero in single-tree applications. For multi-tree hash-based signatures,
the layer address describes the height of a tree within the multi-tree, starting
from height zero for trees at the bottom layer. The tree address describes the
position of a tree within a layer of a multi-tree starting with index zero for
the leftmost tree. The next word defines the type of the address. It is set to 0
for an OTS address, to 1 for an L-tree address, and to 2 for a hash tree address.
Whenever the type word of an address is changed, all following words should be 
initialized with 0 to prevent non-zero values in unused padding words.
</t>

<t>
We first describe the OTS address case. In this case, the type word is followed 
by an OTS address word that encodes the index of the
OTS key pair within the tree. The next word encodes the chain address
followed by a word that encodes the address of the hash function call within
the chain. The last word, called keyAndMask, is used to generate two different 
addresses for one hash function call. The
word is set to zero to generate the key. To generate the n-byte bitmask, the word is set to one.
</t>


<figure title="An OTS Hash Address">
<artwork>
                  +-------------------------+
                  | layer address  (32 bits)|
                  +-------------------------+
                  | tree address   (64 bits)|
                  +-------------------------+
                  | type = 0       (32 bits)|
                  +-------------------------+
                  | OTS address    (32 bits)|
                  +-------------------------+
                  | chain address  (32 bits)|
                  +-------------------------+
                  | hash address   (32 bits)|
                  +-------------------------+
                  | keyAndMask     (32 bits)|
                  +-------------------------+
</artwork>
</figure>

<t>
We now discuss the L-tree case, which means that the type word is set to one. In
that case, the type word is followed by an L-tree address word that
encodes the index of the leaf computed with this L-tree. The next word
encodes the height of the node being input for the next computation inside the
L-tree. The following word
encodes the index of the node at that height, inside the L-tree. This time, the last 
word, keyAndMask, is used to generate three different addresses for one function call. 
The word is set to zero to generate the key. To generate the most significant
n bytes of the 2n-byte bitmask, the word is set to one. The
least significant bytes are generated using the address with the word set
to two.
</t>

<figure title="An L-tree Address">
<artwork>
                  +-------------------------+
                  | layer address  (32 bits)|
                  +-------------------------+
                  | tree address   (64 bits)|
                  +-------------------------+
                  | type = 1       (32 bits)|
                  +-------------------------+
                  | L-tree address (32 bits)|
                  +-------------------------+
                  | tree height    (32 bits)|
                  +-------------------------+
                  | tree index     (32 bits)|
                  +-------------------------+
                  | keyAndMask     (32 bits)|
                  +-------------------------+
</artwork>
</figure>

<t>
We now describe the remaining type for the main tree hash addresses. In this
case, the type word is set to two, followed by a zero padding of one word. The
next word encodes the height of the tree node being input for the next computation,
followed by a word that encodes the index of this node at that height. As for 
the L-tree addresses, the last word, keyAndMask, is used to generate three 
different addresses for one function call. The word is set to zero to generate 
the key. To generate the most significant n bytes of the 2n-byte bitmask, the 
word is set to one. The least significant bytes are generated using the address 
with the word set to two.
</t>

<figure title="A Hash Tree Address">
<artwork>
                  +-------------------------+
                  | layer address  (32 bits)|
                  +-------------------------+
                  | tree address   (64 bits)|
                  +-------------------------+
                  | type = 2       (32 bits)|
                  +-------------------------+
                  | Padding = 0    (32 bits)|
                  +-------------------------+
                  | tree height    (32 bits)|
                  +-------------------------+
                  | tree index     (32 bits)|
                  +-------------------------+
                  | keyAndMask     (32 bits)|
                  +-------------------------+
</artwork>
</figure>

<t>
All fields within these addresses encode unsigned integers. When describing
the generation of addresses we use setter methods that take positive integers
and set the bits of a field to the binary representation of that integer of the
length of the field. We furthermore assume that the setType() method sets the 
four words following the type word to zero.
</t>

</section>

<section title="Strings of Base w Numbers" anchor="basew">

<t>
A byte string can be considered as a string of base w numbers, i.e., integers
in the set {0, ... , w - 1}.  The correspondence is defined by the function
base_w(X, w, out_len) (Algorithm 1) as follows. If X is a len_X-byte string, and w is a member
of the set {4, 16}, then base_w(X, w, out_len) outputs an array of out_len
integers between 0 and w - 1. The length out_len is REQUIRED to be less than or
equal to 8 * len_X / lg(w).
</t>


<figure>
<preamble>
Algorithm 1: base_w
</preamble>
<artwork>
  Input: len_X-byte string X, int w, output length out_len
  Output: out_len int array basew
  
    int in = 0;
    int out = 0;
    unsigned int total = 0;
    int bits = 0;
    int consumed;

    for ( consumed = 0; consumed &lt; out_len; consumed++ ) {
        if ( bits == 0 ) {
            total = X[in];
            in++;
            bits += 8;
        }
        bits -= lg(w);
        basew[out] = (total &gt;&gt; bits) AND (w - 1);
        out++;
    }
    return basew;
</artwork>
</figure>

<figure title="Example">
<preamble>
For example, if X is the (big-endian) byte string 0x1234, then base_w(X, 16, 4)
returns the array a = {1, 2, 3, 4}.
</preamble>
<artwork>
                   X (represented as bits)
      +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
      | 0| 0| 0| 1| 0| 0| 1| 0| 0| 0| 1| 1| 0| 1| 0| 0|
      +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                 X[0]         |         X[1]

              X (represented as base 16 numbers)
      +-----------+-----------+-----------+-----------+
      |     1     |     2     |     3     |     4     |
      +-----------+-----------+-----------+-----------+

                       base_w(X, 16, 4)
      +-----------+-----------+-----------+-----------+
      |     1     |     2     |     3     |     4     |
      +-----------+-----------+-----------+-----------+
          a[0]        a[1]        a[2]        a[3]
        
                       base_w(X, 16, 3)
      +-----------+-----------+-----------+
      |     1     |     2     |     3     |
      +-----------+-----------+-----------+
          a[0]        a[1]        a[2]     

                       base_w(X, 16, 2)
      +-----------+-----------+
      |     1     |     2     |
      +-----------+-----------+
          a[0]        a[1]     
</artwork>
</figure>
</section>

<section title="Member Functions" anchor="member_f">

<t>
To simplify algorithm descriptions, we assume the existence of member functions.
If a complex data structure like a public key PK contains a value X, then
getX(PK) returns the value of X for this public key. Accordingly, setX(PK, X, Y)
sets value X in PK to the value held by Y. Since camelCase is used for member
function names, a value z may be referred to as Z in the function name, e.g.,
getZ.
</t>

</section>
</section>

<section anchor="primitives" title="Primitives">



<section anchor="wots" title="WOTS+: One-Time Signatures">

<t>
This section describes the WOTS+ system in a manner similar to that in
<xref target="Huelsing13"/>. WOTS+ is an OTS scheme; while a private key can be 
used to sign any message, each private key MUST be used only once to sign a single message. In particular, if a 
private key is used to sign two different messages, the scheme becomes insecure.
</t>

<t>
This section starts with an explanation of parameters. Afterwards, the so-called chaining function,
which forms the main building block of the WOTS+ scheme, is explained. A description of the algorithms for 
key generation, signing, and verification follows. Finally, pseudorandom key generation is discussed. 
</t>

<section title='WOTS+ Parameters' anchor='wots_params'>
<t>
WOTS+ uses the parameters n and w; they both take
positive integer values. These parameters are summarized as follows:

<list>
<t>n: the message length as well as the length of a private key, public key, or signature element in bytes.</t>
<t>w: the Winternitz parameter; it is a member of the set {4, 16}.
</t>
</list>

The parameters are used to compute values len, len_1, and len_2:

<list>
<t>len: the number of n-byte string elements in a WOTS+ 
private key, public key, and signature. It is computed as len = len_1 + len_2, 
with len_1 = ceil(8n / lg(w)) and len_2 = floor(lg(len_1 * (w - 1)) / lg(w)) + 1.
</t>
</list>

</t>

<t>
The value of n is determined by the cryptographic hash function used 
for WOTS+.  The hash function is chosen to ensure an appropriate level of
security. The value of n is the input length that can be processed by the signing algorithm. 
It is often the length of a message digest. The parameter w can be chosen from the set {4, 16}. A larger
value of w results in shorter signatures but slower overall signing operations; it has little 
effect on security. Choices of w are limited to the values 4 and 16 since 
these values yield optimal trade-offs and easy implementation.
</t>

<t>
WOTS+ parameters are implicitly included in algorithm inputs as needed.
</t>

<section title='WOTS+ Functions' anchor='wots_hash_func'>

<t>
The WOTS+ algorithm uses a keyed cryptographic hash function F.
F accepts and returns byte strings of length n using keys of length n.
More detail on specific instantiations can be found in <xref target='param' />.
Security requirements on F are discussed in <xref target='Security' />.
In addition, WOTS+ uses a pseudorandom function PRF. PRF takes as input an
n-byte key and a 32-byte index and generates pseudorandom outputs of length n.
More detail on specific instantiations can be found in <xref target='param' />.
Security requirements on PRF are discussed in <xref target='Security' />.
</t>

</section>
</section>

<section title='WOTS+ Chaining Function' anchor='wots_chain'>

<t>
The chaining function (Algorithm 2) computes an iteration of F on an n-byte input
using outputs of PRF. It takes an OTS hash address as input. 
This address will have the first six 32-bit words set to encode the address of this chain. 
In each iteration, PRF is used to generate a key for F and a bitmask that is XORed to the intermediate result before it is
processed by F. In the following, ADRS is a 32-byte OTS hash address as specified in <xref target='address'/> and SEED is an n-byte string. To 
generate the keys and bitmasks, PRF is called with SEED as key and ADRS as input.
The chaining function takes
as input an n-byte string X, a start index i, a number of steps s, as well as ADRS and SEED. 
The chaining function returns as output the value obtained by iterating F for s times on 
input X, using the outputs of PRF.
</t>

<figure>
<preamble>Algorithm 2: chain - Chaining Function
</preamble>
<artwork>
  Input: Input string X, start index i, number of steps s,
  seed SEED, address ADRS
  Output: value of F iterated s times on X
  
  if ( s == 0 ) {
    return X;
  }
  if ( (i + s) &gt; (w - 1) ) {
    return NULL;
  }
  byte[n] tmp = chain(X, i, s - 1, SEED, ADRS);
  
  ADRS.setHashAddress(i + s - 1);
  ADRS.setKeyAndMask(0);
  KEY = PRF(SEED, ADRS);
  ADRS.setKeyAndMask(1);
  BM = PRF(SEED, ADRS);
  
  tmp = F(KEY, tmp XOR BM);
  return tmp;
</artwork>
<postamble>
</postamble>
</figure>

</section>

<section title='WOTS+ Private Key' anchor='wots_prv_key'>

<t>
The private key in WOTS+, denoted by sk (s for secret), is a length len array of n-byte strings. This 
private key MUST be only used to sign at most one message. Each n-byte string MUST either
be selected randomly from the uniform distribution or be selected using a
cryptographically secure pseudorandom procedure.
In the latter case, the security of the used procedure MUST at least match that of the WOTS+ parameters used. 
For a further discussion on pseudorandom key generation, see <xref target='prg_kg'/>.
The following pseudocode (Algorithm 3) describes an algorithm for generating sk.
</t>

<figure>
<preamble>Algorithm 3: WOTS_genSK - 
Generating a WOTS+ Private Key
</preamble>
<artwork>
  Input: No input
  Output: WOTS+ private key sk

  for ( i = 0; i &lt; len; i++ ) {
    initialize sk[i] with a uniformly random n-byte string;
  }
  return sk;
</artwork>
<postamble>
</postamble>
</figure>

</section>

<section title='WOTS+ Public Key' anchor='wots_pub_key'>

<t>
A WOTS+ key pair defines a virtual structure that consists
of len hash chains of length w. The len n-byte strings in the private
key each define the start node for one hash chain. The public
key consists of the end nodes of these hash chains. Therefore, like
the private key, the public key is also a length len array of n-byte 
strings. To compute the hash chain, the chaining function (Algorithm 2)
is used. An OTS hash address ADRS and a seed SEED have to be provided by the calling algorithm.
This address will encode the address of the WOTS+ key pair within a greater structure.
   Hence, a
   WOTS+ algorithm MUST NOT manipulate any parts of ADRS except for the
   last three 32-bit words.
Please note that the SEED used here is public information also available to a verifier.
The following pseudocode (Algorithm 4) describes an algorithm for generating 
the public key pk, where sk is the private key.
</t>

<figure>
<preamble>Algorithm 4: WOTS_genPK - 
Generating a WOTS+ Public Key From a Private Key
</preamble>
<artwork>
  Input: WOTS+ private key sk, address ADRS, seed SEED
  Output: WOTS+ public key pk
  
  for ( i = 0; i &lt; len; i++ ) {
    ADRS.setChainAddress(i);
    pk[i] = chain(sk[i], 0, w - 1, SEED, ADRS);
  }
  return pk;
</artwork>
</figure>

</section>

<section title='WOTS+ Signature Generation' anchor='wots_sig_gen'>
<t>
A WOTS+ signature is a length len array of n-byte strings. The WOTS+ 
signature is generated by mapping a message to len integers between 0 and 
w - 1. To this end, the message is transformed into len_1 base w numbers using the base_w function defined in <xref target="basew"/>.
Next, a checksum is computed and appended to the transformed message as len_2 base w numbers using the base_w function.
Note that the checksum may reach a maximum integer value of len_1 * (w - 1) * 2^8 and
therefore depends on the parameters n and w. For the parameter sets given
in <xref target="param"/>, a 32-bit unsigned integer is sufficient to hold the checksum. If other
parameter settings are used, the size of the variable holding the integer value of the checksum MUST be sufficiently large.
Each of the base w integers is used to select a node from a different hash chain. The
signature is formed by concatenating the selected nodes.
An OTS hash address ADRS and a seed SEED have to be provided by the calling algorithm.
This address will encode the address of the WOTS+ key pair within a greater structure.
Hence, a
WOTS+ algorithm MUST NOT manipulate any parts of ADRS except for the
last three 32-bit words.
Please note that the SEED used here is public information also available to a verifier.
The pseudocode for signature generation is shown below (Algorithm 5), where M is the message and sig
is the resulting signature.
</t>

<figure>
<preamble>Algorithm 5: WOTS_sign - 
Generating a signature from a private key and a message
</preamble>
<artwork>
  Input: Message M, WOTS+ private key sk, address ADRS, seed SEED
  Output: WOTS+ signature sig
  
  csum = 0;

  // Convert message to base w
  msg = base_w(M, w, len_1);

  // Compute checksum
  for ( i = 0; i &lt; len_1; i++ ) {
        csum = csum + w - 1 - msg[i];
  }

  // Convert csum to base w
  csum = csum &lt;&lt; ( 8 - ( ( len_2 * lg(w) ) % 8 ));
  len_2_bytes = ceil( ( len_2 * lg(w) ) / 8 );
  msg = msg || base_w(toByte(csum, len_2_bytes), w, len_2);
  for ( i = 0; i &lt; len; i++ ) {
       ADRS.setChainAddress(i);
       sig[i] = chain(sk[i], 0, msg[i], SEED, ADRS);
  }
  return sig;
</artwork>
</figure>

<t>
The data format for a signature is given below.
</t>

<figure title="WOTS+ Signature">
<artwork>
          +---------------------------------+
          |                                 |
          |           sig_ots[0]            |    n bytes
          |                                 |
          +---------------------------------+
          |                                 |
          ~              ....               ~
          |                                 |
          +---------------------------------+
          |                                 |
          |          sig_ots[len - 1]       |    n bytes
          |                                 |
          +---------------------------------+
</artwork>
</figure>
</section>

<section title='WOTS+ Signature Verification' anchor='wots_sig_vrf'>

<t>
In order to verify a signature sig on a message M, the verifier computes a WOTS+ public key value from the signature.
This can be done by "completing" the chain computations starting from the signature values,
using the base w values of the message hash and its checksum. This step, called WOTS_pkFromSig, is described below
in Algorithm 6. The result of WOTS_pkFromSig is then compared to the given public key. If the values are equal, the signature is accepted.
Otherwise, the signature MUST be rejected. 
An OTS hash address ADRS and a seed SEED have to be provided by the calling algorithm.
This address will encode the address of the WOTS+ key pair within a greater structure.
   Hence, a
   WOTS+ algorithm MUST NOT manipulate any parts of ADRS except for the
   last three 32-bit words.
Please note that the SEED used here is public information also available to a verifier.
</t>

<figure>
<preamble>Algorithm 6: WOTS_pkFromSig - 
Computing a WOTS+ public key from a message and its signature
</preamble>
<artwork>
  Input: Message M, WOTS+ signature sig, address ADRS, seed SEED
  Output: 'Temporary' WOTS+ public key tmp_pk
  
  csum = 0;

  // Convert message to base w
  msg = base_w(M, w, len_1);

  // Compute checksum
  for ( i = 0; i &lt; len_1; i++ ) {
        csum = csum + w - 1 - msg[i];
  }

  // Convert csum to base w
  csum = csum &lt;&lt; ( 8 - ( ( len_2 * lg(w) ) % 8 ));
  len_2_bytes = ceil( ( len_2 * lg(w) ) / 8 );
  msg = msg || base_w(toByte(csum, len_2_bytes), w, len_2);
  for ( i = 0; i &lt; len; i++ ) {
       ADRS.setChainAddress(i);
       tmp_pk[i] = chain(sig[i], msg[i], w - 1 - msg[i], SEED, ADRS);
  }
  return tmp_pk;
</artwork>
</figure>

<t>
Note: XMSS uses WOTS_pkFromSig to compute a public key value and delays the comparison to a later point.  
</t>

</section>
  
<section title='Pseudorandom Key Generation' anchor='prg_kg'>

<t>
An implementation MAY use a cryptographically secure pseudorandom method to 
generate the private key from a single n-byte value. For example, the method 
suggested in <xref target="BDH11"/> and explained below MAY be used. Other methods MAY be used. The choice of a
pseudorandom method does not affect interoperability, but the
cryptographic strength MUST match that of the used WOTS+ parameters.
</t>

<t>
The advantage of generating the private key elements from a random n-byte string is
that only this n-byte string needs to be stored instead of the full private key. The key
can be regenerated when needed. The suggested method from <xref target="BDH11"/> 
can be described using PRF. During key generation, a uniformly random n-byte string S is sampled 
from a secure source of randomness. This string S is stored as private key. The private key elements 
are computed as sk[i] = PRF(S, toByte(i, 32)) whenever needed. Please note that this seed S MUST be different 
from the seed SEED used to randomize the hash function calls. Also, this seed S MUST be kept secret.
The seed S MUST NOT be a low entropy, human-memorable value since private key elements are derived
from S deterministically and their confidentiality is security-critical.
</t>

</section>
</section>
</section>

<section anchor="schemes" title="Schemes">

<t>
In this section, the eXtended Merkle Signature Scheme 
(XMSS) is described using WOTS+.  XMSS comes in two flavors: a single-tree 
variant (XMSS) and a multi-tree variant (XMSS^MT).  Both allow 
combining a large number of WOTS+ key pairs under a single small public 
key.  The main ingredient added is a binary hash tree construction. 
XMSS uses a single hash tree while XMSS^MT uses a tree of XMSS
key pairs.
</t>

<section anchor="xmss" title="XMSS: eXtended Merkle Signature Scheme">

<t>
XMSS is a method for signing a potentially large but fixed number of 
messages.  It is based on the Merkle signature scheme.  XMSS uses four 
cryptographic components: WOTS+ as OTS method, two additional 
cryptographic hash functions H and H_msg, and a pseudorandom function 
PRF.  One of the main advantages of XMSS with WOTS+ is that it does 
not rely on the collision resistance of the used hash functions but on 
weaker properties.  Each XMSS public/private key pair is associated 
with a perfect binary tree, every node of which contains an n-byte 
value.  Each tree leaf contains a special tree hash of a WOTS+ public 
key value.  Each non-leaf tree node is computed by first concatenating
the values of its child nodes, computing the XOR with a bitmask, and 
applying the keyed hash function H to the result. The bitmasks and the keys 
for the hash function H are generated from a (public) seed that is part of the 
public key using the pseudorandom function PRF. The value corresponding to 
the root of the XMSS tree forms the XMSS public key together with the seed.
</t>

<t>
To generate a key pair that can be used to sign 2^h messages, a tree of 
height h is used.  XMSS is a stateful signature scheme, meaning that 
the private key changes with every signature generation. To prevent one-time 
private keys from being used twice, the WOTS+ key pairs are numbered 
from 0 to (2^h) - 1 according to the related leaf, starting from index 0 
for the leftmost leaf.  The private key contains an index that is 
updated with every signature generation, such that it contains the index of the 
next unused WOTS+ key pair.
</t>

<t>
A signature consists of the index of the used WOTS+ key pair, the WOTS+ 
signature on the message, and the so-called authentication path.  The 
latter is a vector of tree nodes that allow a verifier to compute a 
value for the root of the tree starting from a WOTS+ signature. A verifier computes the root value and 
compares it to the respective value in the XMSS public key.  If they 
match, the signature is declared valid.  The XMSS private key consists of all 
WOTS+ private keys and the current index.  To reduce storage, a 
pseudorandom key generation procedure, as described in 
<xref target="BDH11"/>, MAY be used.  The security of the used method 
MUST at least match the security of the XMSS instance.
</t>

<section title='XMSS Parameters' anchor='xmss_params'>

<t>
XMSS has the following parameters:

<list>
  <t>
  h: the height (number of levels - 1) of the tree
  </t>
  <t>
  n: the length in bytes of the message digest as well as each node
  </t>
  <t>
  w: the Winternitz parameter as defined for WOTS+ in 
  <xref target="wots"/>
  </t>
</list>
  
There are 2^h leaves in the tree.
</t>

<t>
For XMSS and XMSS^MT, private and public keys are denoted by SK (S for secret)
and PK, respectively. 
For WOTS+, private and public keys are denoted by sk (s for secret) and pk, 
respectively.  XMSS and XMSS^MT signatures are denoted by Sig.  WOTS+ 
signatures are denoted by sig.
</t>

<t>
XMSS and XMSS^MT parameters are implicitly included in algorithm inputs as needed. 
</t>

</section>

<section  title='XMSS Hash Functions' anchor='xmss_hash_func'>
<t>
Besides the cryptographic hash function F and the pseudorandom function PRF required by WOTS+, XMSS 
uses two more functions:
<list style="symbols">
  <t>A cryptographic hash function H.  H accepts n-byte keys and byte strings of length 
    2n and returns an n-byte string.</t>
  <t>A cryptographic hash function H_msg.  H_msg accepts 3n-byte keys and byte strings of arbitrary 
    length and returns an n-byte string.</t>
</list>
More detail on specific instantiations can be found in <xref target='param' />.
Security requirements on H and H_msg are discussed in <xref target='Security' />.
</t>

</section>

<section anchor="xmss_priv" title="XMSS Private Key">

<t>
   An XMSS private key SK contains 2^h WOTS+ private keys, the leaf
   index idx of the next WOTS+ private key that has not yet been used,
   SK_PRF (an n-byte key to generate pseudorandom values for randomized
   message hashing), the n-byte value root (which is the root node of the
   tree and SEED), and the n-byte public seed used to pseudorandomly generate
   bitmasks and hash function keys.
Although root and SEED formally would be considered only part of the public key,
they are needed (e.g., for signature generation) and hence are also required for functions that do not 
take the public key as input.
</t>
<t>
The leaf index idx is initialized to zero when the XMSS private key is created. The key SK_PRF
MUST be sampled from a secure source of randomness that follows the uniform distribution.
The WOTS+ private keys MUST be generated as described in <xref target="wots"/>, or, to reduce
the private key size, a cryptographic pseudorandom method MUST be used as discussed in <xref target="prg_kg_xmss"/>.
SEED is generated as a uniformly random n-byte string. Although SEED is public, it is critical for 
security that it is 
generated using a good entropy source. The root node is generated as
described below in the section on key generation (<xref target="xmss_alg"/>). 
That section also contains an example algorithm for combined private and public key generation.
</t>

<t>
For the following algorithm descriptions, the existence of a method getWOTS_SK(SK, i) is assumed. 
This method takes as input an XMSS private key SK and an integer i and outputs the i^th WOTS+ private
key of SK.
</t>

</section>

<section anchor="rand_hash" title="Randomized Tree Hashing">

<t>
To improve readability, we introduce a function RAND_HASH(LEFT, RIGHT, SEED,
ADRS) (Algorithm 7) that does the randomized hashing in the tree. 
It takes as input two n-byte values LEFT and RIGHT that represent the left and the right halves
of the hash function input, the seed SEED used as key for PRF, and the address ADRS of this hash function call.
RAND_HASH first uses PRF with SEED and ADRS to generate a key KEY and n-byte bitmasks BM_0, BM_1. 
Then, it returns the randomized hash H(KEY, (LEFT XOR BM_0) || (RIGHT XOR BM_1)).
</t>

<figure>
<preamble>Algorithm 7: RAND_HASH
</preamble>
<artwork>
  Input:  n-byte value LEFT, n-byte value RIGHT, seed SEED, 
          address ADRS
  Output: n-byte randomized hash
  
  ADRS.setKeyAndMask(0);
  KEY = PRF(SEED, ADRS);
  ADRS.setKeyAndMask(1);
  BM_0 = PRF(SEED, ADRS);
  ADRS.setKeyAndMask(2);
  BM_1 = PRF(SEED, ADRS);
  
  return H(KEY, (LEFT XOR BM_0) || (RIGHT XOR BM_1));
</artwork>
</figure>
</section>

<section  title='L-Trees' anchor='ltree'>

<t>
To compute the leaves of the binary hash tree, a so-called L-tree is used. 
An L-tree is an unbalanced binary 
hash tree, distinct but similar to the main XMSS binary hash tree. The 
algorithm ltree (Algorithm 8) takes as input a WOTS+ public key pk and 
compresses it to a single n-byte value pk[0]. 
It also takes as input an 
L-tree address ADRS that encodes the address of the L-tree and
the seed SEED. 
</t>

<figure>
<preamble>Algorithm 8: ltree
</preamble>
<artwork>
  Input: WOTS+ public key pk, address ADRS, seed SEED
  Output: n-byte compressed public key value pk[0]
  
  unsigned int len' = len;
  ADRS.setTreeHeight(0);
  while ( len' &gt; 1 ) {
    for ( i = 0; i &lt; floor(len' / 2); i++ ) {
      ADRS.setTreeIndex(i);
      pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);
    }
    if ( len' % 2 == 1 ) {
      pk[floor(len' / 2)] = pk[len' - 1];
    }
    len' = ceil(len' / 2);
    ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);
  }
  return pk[0];
</artwork>
</figure>
</section>

<section  title='TreeHash' anchor='treehash'>

<t>
For the computation of the internal n-byte nodes of a Merkle tree, the 
subroutine treeHash (Algorithm 9) accepts an XMSS private key SK (including seed SEED), 
an unsigned integer s (the start index), an unsigned integer t (the target node height), 
and an address ADRS that encodes the address of the containing tree. 
For the height of a node within a tree, counting starts with the leaves at height zero. 
The treeHash algorithm returns the root node of a tree of height t 
with the leftmost leaf being the hash of the WOTS+ pk with index s. 
It is REQUIRED that s % 2^t = 0, i.e., that the leaf at index s is a leftmost
leaf of a sub-tree of height t. Otherwise, the hash-addressing scheme fails.
The treeHash algorithm described here uses a stack holding up to (t - 1) nodes, with
the usual stack functions push() and pop(). We furthermore assume that the height of 
a node (an unsigned integer) is stored alongside a node's
value (an n-byte string) on the stack.
</t>

<figure>
<preamble>Algorithm 9: treeHash
</preamble>
<artwork>
  Input: XMSS private key SK, start index s, target node height t, 
         address ADRS
  Output: n-byte root node - top node on Stack
  
  if( s % (1 &lt;&lt; t) != 0 ) return -1;
  for ( i = 0; i &lt; 2^t; i++ ) {
    SEED = getSEED(SK);
    ADRS.setType(0);   // Type = OTS hash address 
    ADRS.setOTSAddress(s + i);
    pk = WOTS_genPK (getWOTS_SK(SK, s + i), SEED, ADRS);
    ADRS.setType(1);   // Type = L-tree address 
    ADRS.setLTreeAddress(s + i);
    node = ltree(pk, SEED, ADRS);
    ADRS.setType(2);   // Type = hash tree address 
    ADRS.setTreeHeight(0);
    ADRS.setTreeIndex(i + s);
    while ( Top node on Stack has same height t' as node ) {
       ADRS.setTreeIndex((ADRS.getTreeIndex() - 1) / 2);
       node = RAND_HASH(Stack.pop(), node, SEED, ADRS);
       ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);
    }
    Stack.push(node);
  }
  return Stack.pop();
</artwork>
</figure>
</section>

<section anchor="xmss_alg" title="XMSS Key Generation">

<t>
The XMSS key pair is computed as described in XMSS_keyGen (Algorithm 10). 
The XMSS public key PK 
consists of the root of the binary hash tree and the seed SEED, both also stored in SK. 
The root is computed using treeHash. 
For XMSS, there is only a single main tree. 
Hence, the used address is set to the all-zero string in the beginning.
Note that we do not define any specific format or handling for the XMSS
private key SK by introducing this algorithm. It relates to
requirements described earlier and simply shows
a basic but very inefficient example to initialize a private key.
</t>

<figure>
<preamble>Algorithm 10: XMSS_keyGen - Generate an XMSS key pair
</preamble>
<artwork>
  Input: No input
  Output: XMSS private key SK, XMSS public key PK

  // Example initialization for SK-specific contents
  idx = 0;
  for ( i = 0; i &lt; 2^h; i++ ) {
    wots_sk[i] = WOTS_genSK();
  }
  initialize SK_PRF with a uniformly random n-byte string;
  setSK_PRF(SK, SK_PRF);

  // Initialization for common contents
  initialize SEED with a uniformly random n-byte string;
  setSEED(SK, SEED);
  setWOTS_SK(SK, wots_sk));
  ADRS = toByte(0, 32);
  root = treeHash(SK, 0, h, ADRS);

  SK = idx || wots_sk || SK_PRF || root || SEED;
  PK = OID || root || SEED;
  return (SK || PK);
</artwork>
</figure>

<t>
The above is just an example algorithm. It is strongly RECOMMENDED to
use pseudorandom key generation to reduce the private key size.
Public and private key generation MAY be interleaved to save space.
Particularly, when a pseudorandom method is used to generate the private
key, generation MAY be done when the respective WOTS+ key pair is
needed by treeHash.
</t>

<t>
The format of an XMSS public key is given below.
</t>

<figure title="XMSS Public Key">
<artwork>
         +---------------------------------+
         |          algorithm OID          |
         +---------------------------------+
         |                                 |
         |            root node            |     n bytes
         |                                 |
         +---------------------------------+
         |                                 |
         |              SEED               |     n bytes
         |                                 |
         +---------------------------------+
</artwork>
</figure>
</section>

<section anchor="xmss_sig" title="XMSS Signature">
<t>
An XMSS signature is a (4 + n + (len + h) * n)-byte string consisting of:
<list style="symbols">
  <t>
    the index idx_sig of the used WOTS+ key pair (4 bytes),
  </t>
  <t>
    a byte string r used for randomized message hashing (n bytes),
  </t>
  <t>
    a WOTS+ signature sig_ots (len * n bytes), and
  </t>
  <t>
    the so-called authentication path 'auth' for the leaf associated with the used 
    WOTS+ key pair (h * n bytes).
  </t>
</list>
</t>

<t>
The authentication path is an array of h n-byte strings.  It contains 
the siblings of the nodes on the path from the used leaf to the root. 
It does not contain the nodes on the path itself.  A verifier needs these nodes 
to compute a root node for the tree from the WOTS+
public key. A node Node is addressed by its position in the tree. 
Node(x, y) denotes the y^th node on level x with y = 0 being the leftmost node on a level.  
The leaves are on level 0; the root is on level h.  An authentication path contains exactly 
one node on every layer 0 &le; x &le; (h - 1). 
For the i^th WOTS+ key pair, counting from zero, 
the j^th authentication path node is:
<list>
<t>Node(j, floor(i / (2^j)) XOR 1)</t>
</list>
The computation of the authentication path is discussed in <xref target="xmss_sig_gen"/>.
</t>

<t>
The data format for a signature is given below.
</t>

<figure title="XMSS Signature">
<artwork>
          +---------------------------------+
          |                                 |
          |          index idx_sig          |    4 bytes
          |                                 |
          +---------------------------------+
          |                                 |
          |          randomness r           |    n bytes
          |                                 |
          +---------------------------------+
          |                                 |
          |     WOTS+ signature sig_ots     |    len * n bytes
          |                                 |
          +---------------------------------+
          |                                 |
          |             auth[0]             |    n bytes
          |                                 |
          +---------------------------------+
          |                                 |
          ~              ....               ~
          |                                 |
          +---------------------------------+
          |                                 |
          |           auth[h - 1]           |    n bytes
          |                                 |
          +---------------------------------+
</artwork>
</figure>
</section>

<section anchor="xmss_sig_gen" title="XMSS Signature Generation">

<t>
To compute the XMSS signature of a message M with an XMSS private key, 
the signer first computes a randomized message digest using a random
value r, idx_sig, the index of the WOTS+ key pair to be used, and the root value from the public key as key. Then, a WOTS+ 
signature of the message digest is computed using the next unused WOTS+ private key. 
Next, the authentication path is computed.  Finally, the private key is updated, i.e., 
idx is incremented.  An implementation MUST NOT output the signature 
before the private key is updated.
</t>

<t>
The node values of the authentication path MAY be computed in any way. 
This computation is assumed to be performed by the subroutine buildAuth
for the function XMSS_sign (Algorithm 12). 
The fastest alternative is to store all tree nodes and set the 
array in the signature by copying the respective nodes.  The least 
storage-intensive alternative is to recompute all nodes for each 
signature online using the treeHash algorithm (Algorithm 9). 
Several algorithms exist in between, with different 
time/storage trade-offs. For an overview, see <xref target="BDS09"/>. 
A further approach can be found in <xref target="KMN14"/>. 
Note that the details of this procedure are not 
relevant to interoperability; it is not necessary to know any of these 
details in order to perform the signature verification operation. The 
following version of buildAuth is given for completeness. 
It is a simple example for understanding, but extremely inefficient. 
The use of one of the alternative algorithms is strongly RECOMMENDED.
</t>

<t>
Given an XMSS private key SK, all nodes in a tree are determined. 
Their values are defined in terms of treeHash (Algorithm 9). 
Hence, one can compute the authentication path as follows:
</t>
<figure>
<preamble>
(Example) buildAuth - Compute the authentication path for the i^th WOTS+ key pair
</preamble>
<artwork>
  Input: XMSS private key SK, WOTS+ key pair index i, ADRS
  Output: Authentication path auth
  
  for ( j = 0; j &lt; h; j++ ) {
    k = floor(i / (2^j)) XOR 1;
    auth[j] = treeHash(SK, k * 2^j, j, ADRS);
  }
</artwork>
</figure>

<t>
We split the description of the signature generation into two main algorithms. 
The first one, treeSig (Algorithm 11), generates the main part of an XMSS signature and is also used by the multi-tree variant
XMSS^MT. XMSS_sign (Algorithm 12) calls treeSig but handles message compression before and the private key update afterwards.
</t>

<t>
The algorithm treeSig (Algorithm 11) described below calculates the WOTS+ signature on an n-byte message and the 
corresponding authentication path. 
treeSig takes as input an n-byte message M', 
an XMSS private key SK, a signature index idx_sig, and an address ADRS. It returns the concatenation of the WOTS+ signature sig_ots and 
authentication path auth. 
</t>

<figure>
<preamble>Algorithm 11: treeSig - Generate a WOTS+ signature on a message with corresponding authentication path
</preamble>
<artwork>
  Input: n-byte message M', XMSS private key SK, 
         signature index idx_sig, ADRS
  Output: Concatenation of WOTS+ signature sig_ots and 
          authentication path auth
  
  auth = buildAuth(SK, idx_sig, ADRS);
  ADRS.setType(0);   // Type = OTS hash address
  ADRS.setOTSAddress(idx_sig);
  sig_ots = WOTS_sign(getWOTS_SK(SK, idx_sig),
                      M', getSEED(SK), ADRS);
  Sig = sig_ots || auth;
  return Sig;
</artwork>
</figure>

<t>
The algorithm XMSS_sign (Algorithm 12) described below calculates an 
updated private key SK and a signature on a message M.  XMSS_sign takes as
input a message M of arbitrary length and
an XMSS private key SK. It returns the byte string containing the concatenation of 
the updated private key SK and the signature Sig. 
</t>

<figure>
<preamble>Algorithm 12: XMSS_sign - Generate an XMSS signature and
update the XMSS private key
</preamble>
<artwork>
  Input: Message M, XMSS private key SK
  Output: Updated SK, XMSS signature Sig

  idx_sig = getIdx(SK);
  setIdx(SK, idx_sig + 1);
  ADRS = toByte(0, 32);
  byte[n] r = PRF(getSK_PRF(SK), toByte(idx_sig, 32));
  byte[n] M' = H_msg(r || getRoot(SK) || (toByte(idx_sig, n)), M);
  Sig = idx_sig || r || treeSig(M', SK, idx_sig, ADRS);
  return (SK || Sig);
</artwork>
</figure>

</section>

<section anchor="xmss_sig_vrf" title="XMSS Signature Verification">

<t>
An XMSS signature is verified by first computing the message digest 
using randomness r, index idx_sig, the root from PK and message M. Then the used WOTS+ public key pk_ots is computed 
from the WOTS+ signature using WOTS_pkFromSig. The WOTS+ public key in turn is used to compute the 
corresponding leaf using an L-tree. The leaf, together with index idx_sig and 
authentication path auth is used to compute an 
alternative root value for the tree. The
verification succeeds if and only if the computed root value matches the one in the XMSS public key. 
In any other case, it MUST return fail.
</t>
<t>
As for signature generation, we split verification into two parts to allow for reuse in the XMSS^MT description. 
The steps also needed for XMSS^MT are done by the function XMSS_rootFromSig (Algorithm 13). 
XMSS_verify (Algorithm 14) calls XMSS_rootFromSig as a subroutine and handles the XMSS-specific steps.
</t>
<t>
The main part of XMSS signature verification is done by the function XMSS_rootFromSig (Algorithm 13) described below. 
XMSS_rootFromSig takes as input an index idx_sig, a WOTS+ signature sig_ots, an authentication path auth, an n-byte 
message M', seed SEED, and address ADRS. XMSS_rootFromSig returns an n-byte string holding
the value of the root of a tree defined by the input data. 
</t>

<figure>
<preamble>
Algorithm 13: XMSS_rootFromSig - Compute a root node from a tree signature
</preamble>
<artwork>
  Input: index idx_sig, WOTS+ signature sig_ots, authentication path  
         auth, n-byte message M', seed SEED, address ADRS
  Output: n-byte root value node[0]
  
  ADRS.setType(0);   // Type = OTS hash address 
  ADRS.setOTSAddress(idx_sig);
  pk_ots = WOTS_pkFromSig(sig_ots, M', SEED, ADRS);
  ADRS.setType(1);   // Type = L-tree address 
  ADRS.setLTreeAddress(idx_sig);
  byte[n][2] node;
  node[0] = ltree(pk_ots, SEED, ADRS);
  ADRS.setType(2);   // Type = hash tree address 
  ADRS.setTreeIndex(idx_sig);
  for ( k = 0; k &lt; h; k++ ) {
    ADRS.setTreeHeight(k);
    if ( (floor(idx_sig / (2^k)) % 2) == 0 ) {
      ADRS.setTreeIndex(ADRS.getTreeIndex() / 2);
      node[1] = RAND_HASH(node[0], auth[k], SEED, ADRS);
    } else {
      ADRS.setTreeIndex((ADRS.getTreeIndex() - 1) / 2);
      node[1] = RAND_HASH(auth[k], node[0], SEED, ADRS);
    }
    node[0] = node[1];
  }
  return node[0];
</artwork>
</figure>

<t>
The full XMSS signature verification is depicted below (Algorithm 14).
It handles message compression, delegates the root computation to XMSS_rootFromSig,
and compares the result to the value in the public key. 
XMSS_verify takes as input an XMSS signature Sig, a message M, and an XMSS public key PK.
XMSS_verify returns true if and only if Sig is a valid signature on M under 
public key PK. Otherwise, it returns false.
</t>

<figure>
<preamble>
Algorithm 14: XMSS_verify - Verify an XMSS signature using 
the corresponding XMSS public key and a message
</preamble>
<artwork>
  Input: XMSS signature Sig, message M, XMSS public key PK
  Output: Boolean
  
  ADRS = toByte(0, 32);
  byte[n] M' = H_msg(r || getRoot(PK) || (toByte(idx_sig, n)), M);
  
  byte[n] node = XMSS_rootFromSig(idx_sig, sig_ots, auth, M',
                                  getSEED(PK), ADRS);
  if ( node == getRoot(PK) ) {
    return true;
  } else {
    return false;
  }
</artwork>
</figure>

</section>

<section title='Pseudorandom Key Generation' anchor='prg_kg_xmss'>

<t>
An implementation MAY use a cryptographically secure pseudorandom method to 
generate the XMSS private key from a single n-byte value. For example, the method 
suggested in <xref target="BDH11"/> and explained below MAY be used. Other methods,
such as the one in <xref target="HRS16"/>, MAY be used. The choice of a
pseudorandom method does not affect interoperability, but the
cryptographic strength MUST match that of the used XMSS parameters. 
</t>

<t>
For XMSS, a method similar to that for WOTS+ can be used.  
The suggested method from <xref target="BDH11"/> can be described using PRF.  
During key generation, a uniformly random n-byte string S is sampled 
from a secure source of randomness. This seed S MUST NOT be confused with the public seed SEED.
The seed S MUST be independent of SEED, and because it is the main secret, it MUST be kept secret.
This seed S is used to generate an n-byte value S_ots for each WOTS+ key pair. 
The n-byte value S_ots can then be used to compute the 
respective WOTS+ private key using the method described in <xref target="prg_kg"/>.  
The seeds for the WOTS+ key pairs are computed as S_ots[i] = PRF(S, toByte(i, 32)) where i is the index of the WOTS+ key pair. 
An advantage of this method is that a WOTS+ key can be computed using only len + 1 evaluations of PRF when S is given.
</t>

</section>

<section anchor="idx_handling" title="Free Index Handling and Partial Private Keys">

<t>
Some applications might require working with partial private keys or copies of private keys.  
Examples include load balancing and delegation of signing rights or proxy signatures.  
Such applications MAY use their own key format and MAY use a signing algorithm different from the
one described above.  The index in partial private keys or copies of a private key MAY be manipulated 
as required by the applications.  However, applications MUST establish means that guarantee that 
each index, and thereby each WOTS+ key pair, is used to sign only a single message. 
</t>

</section>

</section>

<section anchor="xmssmt" title="XMSS^MT: Multi-Tree XMSS">

<t>
XMSS^MT is a method for signing a large but fixed number of messages. It was first described in <xref target='HRB13'/>. It builds on XMSS.  
XMSS^MT uses a tree of several layers of XMSS trees, a so-called hypertree. The trees on 
top and intermediate layers are used to sign the root nodes of the 
trees on the respective layer below. Trees on the lowest layer are used to sign the actual 
messages. All XMSS trees have equal height. 
</t>

<t>
Consider an XMSS^MT tree of total height h that has d layers of XMSS trees of
height h / d. Then, layer d - 1 contains
one XMSS tree, layer d - 2 contains 2^(h / d) XMSS trees, and so on. Finally,
layer 0 contains 2^(h - h / d) XMSS trees.
</t>

<section title='XMSS^MT Parameters' anchor='xmssmt_params'>

<t>
In addition to all XMSS parameters, an XMSS^MT system requires 
the number of tree layers d, specified as an integer value that divides h without remainder. The same 
tree height h / d and the same Winternitz parameter w are used for all 
tree layers. 
</t>

<t>
All the trees on higher layers sign root nodes of other trees, with
the root nodes being n-byte strings.
Hence, no message 
compression is needed, and WOTS+ is used to sign the root nodes themselves
instead of their hash values.  
</t>
</section>

<section anchor="xmssmt_alg_mt" title="XMSS^MT Key Generation">
<t>
An XMSS^MT private key SK_MT (S for secret) consists of one reduced XMSS
private key for each XMSS tree. 

   These reduced XMSS private keys
   just contain the WOTS+ private keys corresponding to that XMSS key
   pair; they do not contain a pseudorandom function key, index, public seed,
   or root node.

Instead, SK_MT contains a single n-byte pseudorandom function key SK_PRF, a single (ceil(h / 8))-byte index idx_MT, a single n-byte seed SEED, and a single root value root
(which is the root of the single tree on the top layer).
The index is a global index over all WOTS+ key pairs of all XMSS trees on layer 0. It is initialized with 0. It stores the index of the last used WOTS+ key pair on the bottom 
layer, i.e., a number between 0 and 2^h - 1. 
</t>
<t>
The reduced XMSS private keys MUST either be generated as described in <xref
target="xmss_priv"/> 
or be generated using a cryptographic pseudorandom method as discussed in
<xref target="prg_kg_xmssmt"/>.

As for XMSS, the PRF key SK_PRF
MUST be sampled from a secure source of randomness that follows the uniform distribution.
SEED is generated as a uniformly random n-byte string. Although SEED is public, it is critical for 
security that it is 
generated using a good entropy source. The root is the root node of the single XMSS tree on the top layer. Its computation is explained below.
As for XMSS, root and SEED are public information and would classically be considered part of the public key. However, as both are needed for
signing, which only takes the private key, they are also part of SK_MT.
</t>
<t>
This document does not define any specific format for the XMSS^MT
private key SK_MT as it is not required for interoperability.

Algorithms 15 and 16 use a function getXMSS_SK(SK, x, y) that outputs the reduced private key of 
the x^th XMSS tree on the y^th layer.
</t>
<t>
The XMSS^MT public key PK_MT contains the root of the single XMSS tree on layer d - 1 and the seed SEED. These are the same values as in the private key SK_MT. 
The pseudorandom function PRF keyed with SEED  is used to generate the bitmasks and keys for all XMSS trees. 
XMSSMT_keyGen (Algorithm 15) shows example pseudocode to generate SK_MT and PK_MT. The n-byte root node of the top-layer tree is computed using 
treeHash. The algorithm XMSSMT_keyGen outputs an XMSS^MT private key SK_MT and an XMSS^MT public key PK_MT.
The algorithm below gives an example of how the reduced XMSS private keys can be generated. However, any of the above mentioned ways is acceptable as long
as the cryptographic strength of the used method matches or supersedes that of the used XMSS^MT parameter set.
</t>

<figure>
<preamble>Algorithm 15: XMSSMT_keyGen - Generate an XMSS^MT key pair
</preamble>
<artwork>
  Input: No input
  Output: XMSS^MT private key SK_MT, XMSS^MT public key PK_MT

  // Example initialization
  idx_MT = 0;
  setIdx(SK_MT, idx_MT);
  initialize SK_PRF with a uniformly random n-byte string;
  setSK_PRF(SK_MT, SK_PRF);
  initialize SEED with a uniformly random n-byte string;
  setSEED(SK_MT, SEED);

  // Generate reduced XMSS private keys
  ADRS = toByte(0, 32);
  for ( layer = 0; layer &lt; d; layer++ ) {
     ADRS.setLayerAddress(layer);
     for ( tree = 0; tree &lt;
           (1 &lt;&lt; ((d - 1 - layer) * (h / d)));
           tree++ ) {
        ADRS.setTreeAddress(tree);
        for ( i = 0; i &lt; 2^(h / d); i++ ) {
          wots_sk[i] = WOTS_genSK();
        }
        setXMSS_SK(SK_MT, wots_sk, tree, layer);
     }
  }

  SK = getXMSS_SK(SK_MT, 0, d - 1);
  setSEED(SK, SEED);
  root = treeHash(SK, 0, h / d, ADRS);
  setRoot(SK_MT, root);

  PK_MT = OID || root || SEED;
  return (SK_MT || PK_MT);
</artwork>
</figure>

<t>
The above is just an example algorithm. It is strongly RECOMMENDED to
use pseudorandom key generation to reduce the private key size.
Public and private key generation MAY be interleaved to save space.
In particular, when a pseudorandom method is used to generate the private
key, generation MAY be delayed to the point that the respective WOTS+
key pair is needed by another algorithm.
</t>

<t>
The format of an XMSS^MT public key is given below.
</t>

<figure title="XMSS^MT Public Key">
<artwork>
         +---------------------------------+
         |          algorithm OID          |
         +---------------------------------+
         |                                 |
         |            root node            |     n bytes
         |                                 |
         +---------------------------------+
         |                                 |
         |              SEED               |     n bytes
         |                                 |
         +---------------------------------+
</artwork>
</figure>

</section>

<section anchor="xmssmt_sig" title="XMSS^MT Signature">
<t>
An XMSS^MT signature Sig_MT is a byte string of length (ceil(h / 8) + n + (h + d * len) * n). 
It consists of:

<list style="symbols">
  <t>
    the index idx_sig of the used WOTS+ key pair on the bottom layer (ceil(h / 8) bytes),
  </t>
  <t>
    a byte string r used for randomized message hashing (n bytes), and
  </t>
  <t>
    d reduced XMSS signatures ((h / d + len) * n bytes each).
  </t>
</list>

The reduced XMSS signatures only contain a WOTS+ signature sig_ots and an authentication path auth.
They contain no index idx and no byte string r. 
</t>

<t>
The data format for a signature is given below.
</t>

<figure title="XMSS^MT Signature">
<artwork>
        +---------------------------------+
        |                                 |
        |          index idx_sig          |   ceil(h / 8) bytes
        |                                 |
        +---------------------------------+
        |                                 |
        |          randomness r           |   n bytes
        |                                 |
        +---------------------------------+
        |                                 |
        |  (reduced) XMSS signature Sig   |   (h / d + len) * n bytes
        |        (bottom layer 0)         |
        |                                 |
        +---------------------------------+
        |                                 |
        |  (reduced) XMSS signature Sig   |   (h / d + len) * n bytes
        |            (layer 1)            |
        |                                 |
        +---------------------------------+
        |                                 |
        ~              ....               ~
        |                                 |
        +---------------------------------+
        |                                 |
        |  (reduced) XMSS signature Sig   |   (h / d + len) * n bytes
        |          (layer d - 1)          |
        |                                 |
        +---------------------------------+
</artwork>
</figure>
</section>

<section anchor="xmssmt_sig_gen" title="XMSS^MT Signature Generation">

<t>
To compute the XMSS^MT signature Sig_MT of a message M using an XMSS^MT private 
key SK_MT, XMSSMT_sign (Algorithm 16) described below uses treeSig as defined in <xref target="xmss_sig_gen"/>. 
First, the signature index is set to idx_sig. Next, PRF is used to compute a pseudorandom n-byte string r. 
This n-byte string, idx_sig, and the root node from PK_MT are then used to compute a randomized message digest of length n.
The message digest is signed using the WOTS+ key pair on the bottom layer with absolute index idx.
   The authentication path for
   the WOTS+ key pair and the root of the containing XMSS tree are computed.
The root is signed by the parent XMSS tree. This is repeated until the top tree is reached.
</t>

<figure>
<preamble>
Algorithm 16: XMSSMT_sign - Generate an XMSS^MT signature and update
the XMSS^MT private key
</preamble>
<artwork>
  Input: Message M, XMSS^MT private key SK_MT
  Output: Updated SK_MT, signature Sig_MT

  // Init
  ADRS = toByte(0, 32);
  SEED = getSEED(SK_MT);
  SK_PRF = getSK_PRF(SK_MT);
  idx_sig = getIdx(SK_MT);

  // Update SK_MT
  setIdx(SK_MT, idx_sig + 1);

  // Message compression
  byte[n] r = PRF(SK_PRF, toByte(idx_sig, 32));
  byte[n] M' = H_msg(r || getRoot(SK_MT) || (toByte(idx_sig, n)), M);

  // Sign
  Sig_MT = idx_sig;
  unsigned int idx_tree
                = (h - h / d) most significant bits of idx_sig;
  unsigned int idx_leaf = (h / d) least significant bits of idx_sig;
  SK = idx_leaf || getXMSS_SK(SK_MT, idx_tree, 0) || SK_PRF
        || toByte(0, n) || SEED;
  ADRS.setLayerAddress(0);
  ADRS.setTreeAddress(idx_tree);
  Sig_tmp = treeSig(M', SK, idx_leaf, ADRS);
  Sig_MT = Sig_MT || r || Sig_tmp;
  for ( j = 1; j &lt; d; j++ ) {
     root = treeHash(SK, 0, h / d, ADRS);
     idx_leaf = (h / d) least significant bits of idx_tree;
     idx_tree = (h - j * (h / d)) most significant bits of idx_tree;
     SK = idx_leaf || getXMSS_SK(SK_MT, idx_tree, j) || SK_PRF 
            || toByte(0, n) || SEED;
     ADRS.setLayerAddress(j);
     ADRS.setTreeAddress(idx_tree);
     Sig_tmp = treeSig(root, SK, idx_leaf, ADRS);
     Sig_MT = Sig_MT || Sig_tmp;
  }
  return SK_MT || Sig_MT;
</artwork>
</figure>

<t>
Algorithm 16 is only one method to compute XMSS^MT signatures. 
Time-memory trade-offs exist that
allow reduction of the signing time to less than the signing time of an XMSS
scheme with tree height h / d. 
   These trade-offs 1) prevent certain values from
   being recomputed several times by keeping a state and 2) distribute all
   computations over all signature generations.
Details can be
found in <xref target="Huelsing13a"/>. 
</t>

</section>

<section anchor="xmssmt_sig_vrf" 
title="XMSS^MT Signature Verification">

<t>
XMSS^MT signature verification (Algorithm 17) can be summarized as
d XMSS signature verifications with small changes. First, the message is hashed.
The XMSS signatures are then all on n-byte values. Second,
instead of comparing the computed root node to a given value, a signature on this root node is verified.
Only the root node of the top tree is compared to the value in the XMSS^MT public key.
XMSSMT_verify uses XMSS_rootFromSig. The function getXMSSSignature(Sig_MT, i)
returns the ith reduced XMSS signature from the XMSS^MT signature Sig_MT. XMSSMT_verify takes as
input an XMSS^MT signature Sig_MT, a message M, and a public key PK_MT. XMSSMT_verify returns true
if and only if Sig_MT is a valid signature on M under public key PK_MT.  Otherwise, it
returns false.
</t>

<figure>
<preamble>
Algorithm 17: XMSSMT_verify - Verify an XMSS^MT signature Sig_MT on a message M using an XMSS^MT 
public key PK_MT
</preamble>
<artwork>
  Input: XMSS^MT signature Sig_MT, message M, 
         XMSS^MT public key PK_MT
  Output: Boolean

  idx_sig = getIdx(Sig_MT);
  SEED = getSEED(PK_MT);
  ADRS = toByte(0, 32);

  byte[n] M' = H_msg(getR(Sig_MT) || getRoot(PK_MT)
                     || (toByte(idx_sig, n)), M);

  unsigned int idx_leaf 
                = (h / d) least significant bits of idx_sig;
  unsigned int idx_tree 
                = (h - h / d) most significant bits of idx_sig;
  Sig' = getXMSSSignature(Sig_MT, 0);
  ADRS.setLayerAddress(0);
  ADRS.setTreeAddress(idx_tree);
  byte[n] node = XMSS_rootFromSig(idx_leaf, getSig_ots(Sig'),
                                   getAuth(Sig'), M', SEED, ADRS);
  for ( j = 1; j &lt; d; j++ ) {
     idx_leaf = (h / d) least significant bits of idx_tree;
     idx_tree = (h - j * h / d) most significant bits of idx_tree;
     Sig' = getXMSSSignature(Sig_MT, j);
     ADRS.setLayerAddress(j);
     ADRS.setTreeAddress(idx_tree);
     node = XMSS_rootFromSig(idx_leaf, getSig_ots(Sig'),
                           getAuth(Sig'), node, SEED, ADRS);
  }
  if ( node == getRoot(PK_MT) ) {
    return true;
  } else {
    return false;
  }
</artwork>
</figure>
</section>

<section title='Pseudorandom Key Generation' anchor='prg_kg_xmssmt'>

<t>
Like for XMSS, an implementation MAY use a cryptographically secure pseudorandom method to 
generate the XMSS^MT private key from a single n-byte value. For example, the method 
explained below MAY be used. Other methods, such as the one in <xref target="HRS16"/>,
MAY be used. The choice of a
pseudorandom method does not affect interoperability, but the
cryptographic strength MUST match that of the used XMSS^MT parameters.
</t>

<t> 
For XMSS^MT, a method similar to that for XMSS and WOTS+ can be used. The method uses 
PRF. During key generation,
a uniformly random n-byte string S_MT is sampled from a secure source of
randomness. This seed S_MT is used
to generate one n-byte value S for each XMSS key pair. This n-byte value can be used to compute the 
respective XMSS private key using the method described in <xref target="prg_kg_xmss"/>.
Let S[x][y] be the seed for the x^th XMSS private key on layer y. The seeds are computed as S[x][y] = PRF(PRF(S, toByte(y, 32)), toByte(x, 32)). 
</t>

</section>

<section anchor="idx_handling_xmssmt" title="Free Index Handling and Partial Private Keys">

<t>
The content of <xref target="idx_handling"/> also applies to XMSS^MT. 
</t>

</section>

</section>

</section>
<section anchor="param" title="Parameter Sets">


<t>
This section provides basic parameter sets that are assumed to cover
most relevant applications. 
Parameter sets for two classical security levels are defined. Parameters with
n = 32 provide a classical 
security level of 256 bits. Parameters with n = 64 provide a classical 
security level of 512 bits. 
Considering quantum-computer-aided attacks, these output sizes yield post-quantum 
security of 128 and 256 bits, respectively.
</t>

<t>
While this document specifies several parameter sets, an implementation is
only REQUIRED to provide support
for verification of all REQUIRED parameter sets. The REQUIRED parameter sets
all use SHA2-256 to instantiate 
all functions. The REQUIRED parameter sets are only distinguished by the tree
height parameter h (which determines
the number of signatures that can be done with a single key pair) and the
number of layers d (which defines a 
trade-off between speed and signature size). An implementation MAY provide
support for signature generation using 
any of the proposed parameter sets. For convenience, this document defines a
default option for XMSS (XMSS_SHA2_20_256) 
and XMSS^MT (XMSSMT-SHA2_60/3_256). These are supposed to match the most
generic requirements.
</t>

<section anchor="function_instantiation" title="Implementing the Functions">

<t>
  For the n = 32 setting, we give parameters that use
  SHA2-256 as defined in <xref target="FIPS180"/> and other parameters that use 
  the SHA3/Keccak-based extendable-output function SHAKE-128 as 
  defined in <xref target="FIPS202"/>.  For the n = 64 setting, we give parameters that use 
  SHA2-512 as defined in <xref target="FIPS180"/> and other parameters that use 
  the SHA3/Keccak-based extendable-output functions SHAKE-256 
  as defined in <xref target="FIPS202"/>.
The parameter sets using SHA2-256 are mandatory for deployment and therefore 
MUST be provided by any implementation. The remaining
parameter sets specified in this document are OPTIONAL. 
</t>

<t>
SHA2 does not provide a keyed-mode itself. 
To implement the keyed hash functions, the following is used for SHA2 with n = 32:
<list>
  <t>F: SHA2-256(toByte(0, 32) || KEY || M),</t>
  <t>H: SHA2-256(toByte(1, 32) || KEY || M),</t>
  <t>H_msg: SHA2-256(toByte(2, 32) || KEY || M), and</t>
  <t>PRF: SHA2-256(toByte(3, 32) || KEY || M).</t>
</list>  
Accordingly, for SHA2 with n = 64 we use:
<list>
  <t>F: SHA2-512(toByte(0, 64) || KEY || M),</t>
  <t>H: SHA2-512(toByte(1, 64) || KEY || M),</t>
  <t>H_msg: SHA2-512(toByte(2, 64) || KEY || M), and</t>
  <t>PRF: SHA2-512(toByte(3, 64) || KEY || M).</t>
</list>
The n-byte padding is used for two reasons. First, it is necessary that the
internal compression function takes 2n-byte blocks, but keys are n and 3n bytes long.
Second, the padding is used to achieve independence of the different function families.
Finally, for the PRF, no full-fledged Hash-Based Message Authentication Code
(HMAC) is needed as the message length is fixed,
meaning that standard length extension attacks are not a concern here. For that
reason, the simpler construction above suffices.
</t>

<t>
Similar constructions are used with SHA3. 
To implement the keyed hash functions, the following is used for SHA3 with n = 32:
<list>
  <t>F: 	SHAKE128(toByte(0, 32) || KEY || M, 256),</t>
  <t>H: 	SHAKE128(toByte(1, 32) || KEY || M, 256),</t>
  <t>H_msg: 	SHAKE128(toByte(2, 32) || KEY || M, 256),</t>
  <t>PRF: 	SHAKE128(toByte(3, 32) || KEY || M, 256).</t>
</list>
Accordingly, for SHA3 with n = 64, we use:
<list>
  <t>F: 	SHAKE256(toByte(0, 64) || KEY || M, 512),</t>
  <t>H: 	SHAKE256(toByte(1, 64) || KEY || M, 512),</t>
  <t>H_msg: 	SHAKE256(toByte(2, 64) || KEY || M, 512),</t>
  <t>PRF: 	SHAKE256(toByte(3, 64) || KEY || M, 512).</t>
</list>
As for SHA2, an initial n-byte identifier is used to achieve independence 
of the different function families.
While a shorter identifier could be used in case of SHA3, we use n bytes for consistency with the SHA2 implementations.
</t>
</section>

<section anchor="wotsparams" title="WOTS+ Parameters">

<t>
To fully describe a WOTS+ signature method, the parameters n and w,
as well as the functions F and PRF, MUST be specified. The following table defines
several WOTS+ signature systems, each of which is identified by a name.
Naming follows this convention: WOTSP-[Hashfamily]_[n in bits]. Naming does not 
include w as all parameter sets in this document use w=16.
Values for len are provided for convenience.
</t>

<?rfc compact="no" ?>
<texttable anchor='wots_sig_table'>
<ttcol align='left'>Name</ttcol>
<ttcol align='left'>F / PRF</ttcol>
<ttcol align='right'>n</ttcol>
<ttcol align='right'>w</ttcol>
<ttcol align='right'>len</ttcol>

<c>REQUIRED:</c><c></c><c></c><c></c><c></c>
<c>WOTSP-SHA2_256</c><c>SHA2-256</c><c>32</c><c>16</c><c>67</c>

<c>OPTIONAL:</c><c></c><c></c><c></c><c></c>
<c>WOTSP-SHA2_512</c><c>SHA2-512</c><c>64</c><c>16</c><c>131</c>
<c>WOTSP-SHAKE_256</c><c>SHAKE128</c><c>32</c><c>16</c><c>67</c>
<c>WOTSP-SHAKE_512</c><c>SHAKE256</c><c>64</c><c>16</c><c>131</c>

</texttable>
<?rfc compact="yes" ?>

<t>
The implementation of the single functions is done as described above.
External Data Representation (XDR) formats for WOTS+ are listed in <xref target="wotsxdr"/>.
</t>

</section>

<section anchor="xmssparams" title="XMSS Parameters">
<t>
To fully describe an XMSS signature method, the parameters n, w, and h,
as well as the functions F, H, H_msg, and PRF, MUST be specified. The
following table defines
different XMSS signature systems, each of which is identified by a name. 
Naming follows this convention: XMSS-[Hashfamily]_[h]_[n in bits]. Naming does not 
include w as all parameter sets in this document use w=16.
</t>

<?rfc compact="no" ?>
<texttable anchor='xmss_param_table_bm_sha'>
<ttcol align='left'>Name</ttcol>
<ttcol align='left'>Functions</ttcol>
<ttcol align='right'>n</ttcol>
<ttcol align='right'>w</ttcol>
<ttcol align='right'>len</ttcol>
<ttcol align='right'>h</ttcol>

<c>REQUIRED:</c><c></c><c></c><c></c><c></c><c></c>
<c>XMSS-SHA2_10_256</c><c>SHA2-256</c><c>32</c><c>16</c><c>67</c> <c>10</c>
<c>XMSS-SHA2_16_256</c><c>SHA2-256</c><c>32</c><c>16</c><c>67</c> <c>16</c>
<c>XMSS-SHA2_20_256</c><c>SHA2-256</c><c>32</c><c>16</c><c>67</c> <c>20</c>

<c>OPTIONAL:</c><c></c><c></c><c></c><c></c><c></c>
<c>XMSS-SHA2_10_512</c><c>SHA2-512</c><c>64</c><c>16</c><c>131</c><c>10</c>
<c>XMSS-SHA2_16_512</c><c>SHA2-512</c><c>64</c><c>16</c><c>131</c><c>16</c>
<c>XMSS-SHA2_20_512</c><c>SHA2-512</c><c>64</c><c>16</c><c>131</c><c>20</c>

<c>XMSS-SHAKE_10_256</c><c>SHAKE128</c><c>32</c><c>16</c><c>67</c> <c>10</c>
<c>XMSS-SHAKE_16_256</c><c>SHAKE128</c><c>32</c><c>16</c><c>67</c> <c>16</c>
<c>XMSS-SHAKE_20_256</c><c>SHAKE128</c><c>32</c><c>16</c><c>67</c> <c>20</c>

<c>XMSS-SHAKE_10_512</c><c>SHAKE256</c><c>64</c><c>16</c><c>131</c><c>10</c>
<c>XMSS-SHAKE_16_512</c><c>SHAKE256</c><c>64</c><c>16</c><c>131</c><c>16</c>
<c>XMSS-SHAKE_20_512</c><c>SHAKE256</c><c>64</c><c>16</c><c>131</c><c>20</c>
</texttable>
<?rfc compact="yes" ?>

<t>
The XDR formats for XMSS are listed in <xref target="xmssxdr"/>.
</t>
<section anchor="xmssguide" title="Parameter Guide">
    <t>
In contrast to traditional signature schemes like RSA or Digital Signature
Algorithm (DSA), XMSS has a tree
height parameter h that determines the number of messages that can be signed 
with one key pair. Increasing the height allows using a key pair for more signatures,
but it also increases the signature size and slows down key generation, signing, and verification.
To demonstrate the impact of different values of h, the following table shows signature size 
and runtimes. Runtimes are given as the number of calls to F and H when the 
BDS algorithm is used to compute authentication paths for the worst case. The last column shows the 
number of messages that can be signed with one key pair. The numbers are 
the same for the XMSS-SHAKE instances with same parameters h and n. 
</t>

<?rfc compact="no" ?>
<texttable anchor='xmss_perf_table'>
<ttcol align='left'>Name</ttcol>
<ttcol align='right'>|Sig|</ttcol>
<ttcol align='right'>KeyGen</ttcol>
<ttcol align='right'>Sign</ttcol>
<ttcol align='right'>Verify</ttcol>
<ttcol align='right'>#Sigs</ttcol>

<c>REQUIRED:</c><c></c><c></c><c></c><c></c><c></c>
<c>XMSS-SHA2_10_256</c><c>2,500</c><c>1,238,016</c><c>5,725</c><c>1,149</c><c>2^10</c>
<c>XMSS-SHA2_16_256</c><c>2,692</c><c>79*10^6</c><c>9,163</c><c>1,155</c><c>2^16</c>
<c>XMSS-SHA2_20_256</c><c>2,820</c><c>1,268*10^6</c><c>11,455</c><c>1,159</c><c>2^20</c>

<c>OPTIONAL:</c><c></c><c></c><c></c><c></c><c></c>
<c>XMSS-SHA2_10_512</c><c>9,092</c><c>2,417,664</c><c>11,165</c><c>2,237</c><c>2^10</c>
<c>XMSS-SHA2_16_512</c><c>9,476</c><c>155*10^6</c><c>17,867</c><c>2,243</c><c>2^16</c>
<c>XMSS-SHA2_20_512</c><c>9,732</c><c>2,476*10^6</c><c>22,335</c><c>2,247</c><c>2^20</c>
</texttable>
<?rfc compact="yes" ?>


<t>As a default, users without special requirements should use option XMSS-SHA2_20_256,
which allows signing of 2^20 messages with one key pair and provides reasonable
speed and signature size.
Users that require more signatures per key pair or faster key generation
should consider XMSS^MT.
</t>
</section>
</section>

<section anchor="xmssmtparams" title="XMSS^MT Parameters">

<t>
To fully describe an XMSS^MT signature method, the parameters n, w, h, and d,
as well as the functions F, H, H_msg, and PRF, MUST be specified. The
following table defines
different XMSS^MT signature systems, each of which is identified by a name.
Naming follows this convention: XMSSMT-[Hashfamily]_[h]/[d]_[n in bits]. Naming does not 
include w as all parameter sets in this document use w=16.
</t>

<?rfc compact="no" ?>
<texttable anchor='xmssmt_param_table_sha'>
<ttcol align='left'>Name</ttcol>
<ttcol align='left'>Functions</ttcol>
<ttcol align='right'>n</ttcol>
<ttcol align='right'>w</ttcol>
<ttcol align='right'>len</ttcol>
<ttcol align='right'>h</ttcol>
<ttcol align='right'>d</ttcol>

<c>REQUIRED:</c><c></c><c></c><c></c><c></c><c></c><c></c>
<c>XMSSMT-SHA2_20/2_256</c><c>SHA2-256</c><c>32</c><c>16</c><c>67</c> <c>20</c><c>2</c>
<c>XMSSMT-SHA2_20/4_256</c><c>SHA2-256</c><c>32</c><c>16</c><c>67</c> <c>20</c><c>4</c>
<c>XMSSMT-SHA2_40/2_256</c><c>SHA2-256</c><c>32</c><c>16</c><c>67</c> <c>40</c><c>2</c>
<c>XMSSMT-SHA2_40/4_256</c><c>SHA2-256</c><c>32</c><c>16</c><c>67</c> <c>40</c><c>4</c>
<c>XMSSMT-SHA2_40/8_256</c><c>SHA2-256</c><c>32</c><c>16</c><c>67</c> <c>40</c><c>8</c>
<c>XMSSMT-SHA2_60/3_256</c><c>SHA2-256</c><c>32</c><c>16</c><c>67</c> <c>60</c><c>3</c>
<c>XMSSMT-SHA2_60/6_256</c><c>SHA2-256</c><c>32</c><c>16</c><c>67</c> <c>60</c><c>6</c>
<c>XMSSMT-SHA2_60/12_256</c><c>SHA2-256</c><c>32</c><c>16</c><c>67</c> <c>60</c><c>12</c>

<c>OPTIONAL:</c><c></c><c></c><c></c><c></c><c></c><c></c>
<c>XMSSMT-SHA2_20/2_512</c><c>SHA2-512</c><c>64</c><c>16</c><c>131</c><c>20</c><c>2</c>
<c>XMSSMT-SHA2_20/4_512</c><c>SHA2-512</c><c>64</c><c>16</c><c>131</c><c>20</c><c>4</c>
<c>XMSSMT-SHA2_40/2_512</c><c>SHA2-512</c><c>64</c><c>16</c><c>131</c><c>40</c><c>2</c>
<c>XMSSMT-SHA2_40/4_512</c><c>SHA2-512</c><c>64</c><c>16</c><c>131</c><c>40</c><c>4</c>
<c>XMSSMT-SHA2_40/8_512</c><c>SHA2-512</c><c>64</c><c>16</c><c>131</c><c>40</c><c>8</c>
<c>XMSSMT-SHA2_60/3_512</c><c>SHA2-512</c><c>64</c><c>16</c><c>131</c><c>60</c><c>3</c>
<c>XMSSMT-SHA2_60/6_512</c><c>SHA2-512</c><c>64</c><c>16</c><c>131</c><c>60</c><c>6</c>
<c>XMSSMT-SHA2_60/12_512</c><c>SHA2-512</c><c>64</c><c>16</c><c>131</c><c>60</c><c>12</c>

<c>XMSSMT-SHAKE_20/2_256</c><c>SHAKE128</c><c>32</c><c>16</c><c>67</c> <c>20</c><c>2</c>
<c>XMSSMT-SHAKE_20/4_256</c><c>SHAKE128</c><c>32</c><c>16</c><c>67</c> <c>20</c><c>4</c>
<c>XMSSMT-SHAKE_40/2_256</c><c>SHAKE128</c><c>32</c><c>16</c><c>67</c> <c>40</c><c>2</c>
<c>XMSSMT-SHAKE_40/4_256</c><c>SHAKE128</c><c>32</c><c>16</c><c>67</c> <c>40</c><c>4</c>
<c>XMSSMT-SHAKE_40/8_256</c><c>SHAKE128</c><c>32</c><c>16</c><c>67</c> <c>40</c><c>8</c>
<c>XMSSMT-SHAKE_60/3_256</c><c>SHAKE128</c><c>32</c><c>16</c><c>67</c> <c>60</c><c>3</c>
<c>XMSSMT-SHAKE_60/6_256</c><c>SHAKE128</c><c>32</c><c>16</c><c>67</c> <c>60</c><c>6</c>
<c>XMSSMT-SHAKE_60/12_256</c><c>SHAKE128</c><c>32</c><c>16</c><c>67</c> <c>60</c><c>12</c>

<c>XMSSMT-SHAKE_20/2_512</c><c>SHAKE256</c><c>64</c><c>16</c><c>131</c><c>20</c><c>2</c>
<c>XMSSMT-SHAKE_20/4_512</c><c>SHAKE256</c><c>64</c><c>16</c><c>131</c><c>20</c><c>4</c>
<c>XMSSMT-SHAKE_40/2_512</c><c>SHAKE256</c><c>64</c><c>16</c><c>131</c><c>40</c><c>2</c>
<c>XMSSMT-SHAKE_40/4_512</c><c>SHAKE256</c><c>64</c><c>16</c><c>131</c><c>40</c><c>4</c>
<c>XMSSMT-SHAKE_40/8_512</c><c>SHAKE256</c><c>64</c><c>16</c><c>131</c><c>40</c><c>8</c>
<c>XMSSMT-SHAKE_60/3_512</c><c>SHAKE256</c><c>64</c><c>16</c><c>131</c><c>60</c><c>3</c>
<c>XMSSMT-SHAKE_60/6_512</c><c>SHAKE256</c><c>64</c><c>16</c><c>131</c><c>60</c><c>6</c>
<c>XMSSMT-SHAKE_60/12_512</c><c>SHAKE256</c><c>64</c><c>16</c><c>131</c><c>60</c><c>12</c>
</texttable>
<?rfc compact="yes" ?>

<t>
XDR formats for XMSS^MT are listed in <xref target="xmssmtxdr"/>.
</t>

<section anchor="xmssmtguide" title="Parameter Guide">
       <t>
In addition to the tree height parameter already used for XMSS, XMSS^MT has
the parameter d that determines the number of tree layers. XMSS can be understood as XMSS^MT
with a single layer, i.e., d=1.
Hence, the choice of h has the same effect as for XMSS.
The number of tree layers provides a trade-off between signature size on the one side and 
key generation and signing speed on the other side. Increasing the number of layers reduces
key generation time exponentially and signing time linearly at the cost of increasing the 
signature size linearly. Essentially, an XMSS^MT signature contains one WOTSP signature 
per layer. Speed roughly corresponds to d-times the speed for XMSS with trees of height h/d.
</t>
<t>
To demonstrate the impact of different values of h and d, the following table shows signature size 
and runtimes. Runtimes are given as the number of calls to F and H when the 
BDS algorithm and distributed signature generation are used. Timings are worst-case times. 
The last column shows the number of messages that can be signed with one key pair. The numbers are 
the same for the XMSS-SHAKE instances with same parameters h and n. Due to formatting limitations, only
the parameter part of the parameter set names are given, omitting the name "XMSSMT".
</t>

<?rfc compact="no" ?>
<texttable anchor='xmssmt_perf_table'>
<ttcol align='left'>Name</ttcol>
<ttcol align='right'>|Sig|</ttcol>
<ttcol align='right'>KeyGen</ttcol>
<ttcol align='right'>Sign</ttcol>
<ttcol align='right'>Verify</ttcol>
<ttcol align='right'>#Sigs</ttcol>

<c>REQUIRED:</c><c></c><c></c><c></c><c></c><c></c>
<c>SHA2_20/2_256</c><c>4,963</c><c>2,476,032</c><c>7,227</c><c>2,298</c><c>2^20</c>
<c>SHA2_20/4_256</c><c>9,251</c><c>154,752</c><c>4,170</c><c>4,576</c><c>2^20</c>
<c>SHA2_40/2_256</c><c>5,605</c><c>2,535*10^6</c><c>13,417</c><c>2,318</c><c>2^40</c>
<c>SHA2_40/4_256</c><c>9,893</c><c>4,952,064</c><c>7,227</c><c>4,596</c><c>2^40</c>
<c>SHA2_40/8_256</c><c>18,469</c><c>309,504</c><c>4,170</c><c>9,152</c><c>2^40</c>
<c>SHA2_60/3_256</c><c>8,392</c><c>3,803*10^6</c><c>13,417</c><c>3,477</c><c>2^60</c>
<c>SHA2_60/6_256</c><c>14,824</c><c>7,428,096</c><c>7,227</c><c>6,894</c><c>2^60</c>
<c>SHA2_60/12_256</c><c>27,688</c><c>464,256</c><c>4,170</c><c>13,728</c><c>2^60</c>

<c>OPTIONAL:</c><c></c><c></c><c></c><c></c><c></c>
<c>SHA2_20/2_512</c><c>18,115</c><c>4,835,328</c><c>14,075</c><c>4,474</c><c>2^20</c>
<c>SHA2_20/4_512</c><c>34,883</c><c>302,208</c><c>8,138</c><c>8,928</c><c>2^20</c>
<c>SHA2_40/2_512</c><c>19,397</c><c>4,951*10^6</c><c>26,025</c><c>4,494</c><c>2^40</c>
<c>SHA2_40/4_512</c><c>36,165</c><c>9,670,656</c><c>14,075</c><c>8,948</c><c>2^40</c>
<c>SHA2_40/8_512</c><c>69,701</c><c>604,416</c><c>8,138</c><c>17,856</c><c>2^40</c>
<c>SHA2_60/3_512</c><c>29,064</c><c>7,427*10^6</c><c>26,025</c><c>6,741</c><c>2^60</c>
<c>SHA2_60/6_512</c><c>54,216</c><c>14,505,984</c><c>14,075</c><c>13,422</c><c>2^60</c>
<c>SHA2_60/12_512</c><c>104,520</c><c>906,624</c><c>8,138</c><c>26,784</c><c>2^60</c>
</texttable>
<?rfc compact="yes" ?>

<t>As a default, users without special requirements should use option
XMSSMT-SHA2_60/3_256, which allows signing of 2^60 messages with one key pair
(this is a virtually unbounded number
of signatures). At the same time, signature size and speed are well balanced.
</t>

</section>
</section>
</section>

<section anchor="rationale" title="Rationale">


<t>
The goal of this note is to describe the WOTS+, XMSS, and XMSS^MT algorithms
based on the scientific literature. 
The description is done in a modular way 
that allows basing a description of stateless hash-based signature algorithms like
SPHINCS <xref target='BHH15'/> on it.
</t>

<t>
This note slightly deviates from the scientific literature by using a tweak that prevents 
multi-user and multi-target attacks against H_msg. To this end, the public key as well as 
the index of the used one-time key pair become part of the hash function key. Thereby,
we achieve a domain separation that forces an attacker to decide which hash value to attack.
</t>

<t>
For the generation of the randomness used for randomized message hashing, we apply a PRF, 
keyed with a secret value, to the index of the used one-time key pair instead of the message.
The reason is that this requires processing the message only once instead of twice. For 
long messages, this improves speed and simplifies implementations on resource-constrained devices 
that cannot hold the entire message in storage.
</t>

<t>
We give one mandatory set of parameters using SHA2-256. The reasons are
twofold. On the one hand,
SHA2-256 is part of most cryptographic libraries.
On the other hand, a 256-bit hash function leads to parameters that provide 128 bits of security even
against quantum-computer-aided attacks. A post-quantum security level of 256 bits seems overly
conservative. However, to prepare for possible cryptanalytic breakthroughs, we also provide
OPTIONAL parameter sets using the less widely supported SHA2-512, SHAKE-256, and SHAKE-512 functions.
</t>

<t>
We suggest the value w = 16 for the Winternitz parameter. 
No bigger values are included since the decrease in signature size then becomes less significant.
Furthermore, the value w = 16 considerably simplifies the implementations 
of some of the algorithms. Please note that we do allow w = 4 but 
limit the specified parameter sets to w = 16 for efficiency reasons. 
</t>

<t>
The signature and public key formats are designed so that they are
easy to parse.  Each format starts with a 32-bit enumeration value
that indicates all of the details of the signature algorithm and
hence defines all of the information that is needed in order to parse the
format.
</t>

</section>

<section anchor="code" title="Reference Code">
<t>
For testing purposes, a reference implementation in C is available. The code
contains a basic implementation that closely follows
the pseudocode in this document and an optimized implementation that uses the
BDS algorithm <xref target="BDS08"/> to compute authentication paths and 
distributed signature generation as described in <xref target="HRB13"/> for XMSS^MT.
</t>
<t>
The code is permanently available at
&lt;https://github.com/joostrijneveld/xmss-reference&gt;.
</t>
</section>
<section anchor="IANA" title="IANA Considerations">

<t>
The Internet Assigned Numbers Authority (IANA) has created
three registries: one for WOTS+ signatures (as defined in
<xref target="primitives"/>), one for XMSS signatures (as defined in <xref
target="schemes"/>), and one for XMSS^MT
signatures (as defined in <xref target="schemes"/>). 


For the sake of clarity and convenience, the first collection of
WOTS+, XMSS, and XMSS^MT parameter sets is defined in <xref
target="param"/>. Additions to these registries require that a
specification be documented in an RFC or another permanent and readily
available reference in sufficient detail as defined by the
"Specification Required" policy described in <xref target="RFC8126"/>
to make interoperability between independent implementations possible.
Each entry in these registries contains the following elements:
 <list style="symbols">
   <t>a short name, such as "XMSS_SHA2_20_256",    </t>

   <t>a positive number, and</t>

   <t>a reference to a specification that completely defines the
   signature method test cases or provides a reference
   implementation that can be used to verify the correctness of an
   implementation (or a reference to such an
   implementation).</t>
 </list>
Requests to add an entry to these registries MUST include the name and the
reference.  The number is assigned by IANA.  These number assignments SHOULD use
the smallest available positive number.  Submitters MUST have their requests
reviewed and approved.  Designated Experts for this task as requested by the
"Specification Required" policy defined by <xref target="RFC8126"/> will
be assigned by the Internet Engineering Steering Group (IESG).
The IESG can be contacted at iesg@ietf.org. Interested applicants that are
unfamiliar with IANA processes should visit &lt;http://www.iana.org&gt;.
</t>

<t>
The number 0x00000000 (decimal 0) is Reserved. The numbers between 0xDDDDDDDD
(decimal 3,722,304,989) and
0xFFFFFFFF (decimal 4,294,967,295) inclusive will not be
assigned by IANA and are Reserved for Private Use; no attempt
will be made to prevent multiple sites from using the same
value in different (and incompatible) ways
<xref target="RFC8126"/>.
</t>

<t>
The "WOTS+ Signatures" registry is as follows.
</t>

<?rfc compact="no" ?>
   <texttable anchor="iana_reg_wotsp">

     <ttcol align="center">Numeric Identifier</ttcol>

     <ttcol align="left">Name</ttcol>

     <ttcol align="center">Reference</ttcol>

     
     <c>0x00000000</c><c>Reserved</c><c>this RFC</c>
     <c>0x00000001</c><c>WOTSP-SHA2_256</c><c><xref target="wotsparams"/></c> 
     <c>0x00000002</c><c>WOTSP-SHA2_512</c><c><xref target="wotsparams"/></c>

     <c>0x00000003</c><c>WOTSP-SHAKE_256</c><c><xref target="wotsparams"/></c>
     <c>0x00000004</c><c>WOTSP-SHAKE_512</c><c><xref target="wotsparams"/></c>

   </texttable>
<?rfc compact="yes" ?>

<t>
The "XMSS Signatures" registry is as follows.
</t>

<?rfc compact="no" ?>
   <texttable anchor="iana_reg_xmss">

     <ttcol align="center">Numeric Identifier</ttcol>

     <ttcol align="left">Name</ttcol>

     <ttcol align="center">Reference</ttcol>

     <c>0x00000000</c><c>Reserved</c><c>this RFC</c>
     <c>0x00000001</c><c>XMSS-SHA2_10_256</c><c> <xref target="xmssparams"/></c>
     <c>0x00000002</c><c>XMSS-SHA2_16_256</c><c> <xref target="xmssparams"/></c>
     <c>0x00000003</c><c>XMSS-SHA2_20_256</c><c> <xref target="xmssparams"/></c>
     <c>0x00000004</c><c>XMSS-SHA2_10_512</c><c> <xref target="xmssparams"/></c>
     <c>0x00000005</c><c>XMSS-SHA2_16_512</c><c> <xref target="xmssparams"/></c>
     <c>0x00000006</c><c>XMSS-SHA2_20_512</c><c> <xref target="xmssparams"/></c>

     <c>0x00000007</c><c>XMSS-SHAKE_10_256</c><c> <xref target="xmssparams"/></c>
     <c>0x00000008</c><c>XMSS-SHAKE_16_256</c><c> <xref target="xmssparams"/></c>
     <c>0x00000009</c><c>XMSS-SHAKE_20_256</c><c> <xref target="xmssparams"/></c>
     <c>0x0000000A</c><c>XMSS-SHAKE_10_512</c><c> <xref target="xmssparams"/></c>
     <c>0x0000000B</c><c>XMSS-SHAKE_16_512</c><c> <xref target="xmssparams"/></c>
     <c>0x0000000C</c><c>XMSS-SHAKE_20_512</c><c> <xref target="xmssparams"/></c>

   </texttable>

<?rfc compact="yes" ?>

<t>
The "XMSS^MT Signatures" registry is as follows.
</t>

<?rfc compact="no" ?>
<texttable anchor="iana_reg_xmssmt">

  <ttcol align="center">Numeric Identifier</ttcol>

  <ttcol align="left">Name</ttcol>

  <ttcol align="center">Reference</ttcol>

  <c>0x00000000</c><c>Reserved</c><c>this RFC</c>
  <c>0x00000001</c><c>XMSSMT-SHA2_20/2_256</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x00000002</c><c>XMSSMT-SHA2_20/4_256</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x00000003</c><c>XMSSMT-SHA2_40/2_256</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x00000004</c><c>XMSSMT-SHA2_40/4_256</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x00000005</c><c>XMSSMT-SHA2_40/8_256</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x00000006</c><c>XMSSMT-SHA2_60/3_256</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x00000007</c><c>XMSSMT-SHA2_60/6_256</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x00000008</c><c>XMSSMT-SHA2_60/12_256</c><c> <xref target="xmssmtparams"/></c> 
  <c>0x00000009</c><c>XMSSMT-SHA2_20/2_512</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x0000000A</c><c>XMSSMT-SHA2_20/4_512</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x0000000B</c><c>XMSSMT-SHA2_40/2_512</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x0000000C</c><c>XMSSMT-SHA2_40/4_512</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x0000000D</c><c>XMSSMT-SHA2_40/8_512</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x0000000E</c><c>XMSSMT-SHA2_60/3_512</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x0000000F</c><c>XMSSMT-SHA2_60/6_512</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x00000010</c><c>XMSSMT-SHA2_60/12_512</c><c> <xref target="xmssmtparams"/></c> 

  <c>0x00000011</c><c>XMSSMT-SHAKE_20/2_256</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x00000012</c><c>XMSSMT-SHAKE_20/4_256</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x00000013</c><c>XMSSMT-SHAKE_40/2_256</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x00000014</c><c>XMSSMT-SHAKE_40/4_256</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x00000015</c><c>XMSSMT-SHAKE_40/8_256</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x00000016</c><c>XMSSMT-SHAKE_60/3_256</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x00000017</c><c>XMSSMT-SHAKE_60/6_256</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x00000018</c><c>XMSSMT-SHAKE_60/12_256</c><c> <xref target="xmssmtparams"/></c> 
  <c>0x00000019</c><c>XMSSMT-SHAKE_20/2_512</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x0000001A</c><c>XMSSMT-SHAKE_20/4_512</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x0000001B</c><c>XMSSMT-SHAKE_40/2_512</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x0000001C</c><c>XMSSMT-SHAKE_40/4_512</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x0000001D</c><c>XMSSMT-SHAKE_40/8_512</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x0000001E</c><c>XMSSMT-SHAKE_60/3_512</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x0000001F</c><c>XMSSMT-SHAKE_60/6_512</c><c> <xref target="xmssmtparams"/></c>  
  <c>0x00000020</c><c>XMSSMT-SHAKE_60/12_512</c><c> <xref target="xmssmtparams"/></c> 

</texttable>
<?rfc compact="yes" ?>

<t>
An IANA registration of a signature system does not constitute an
endorsement of that system or its security.
</t>

</section>

<section anchor="Security" title="Security Considerations">

<t>
A signature system is considered secure if it prevents an attacker
from forging a valid signature. More specifically, consider a setting 
in which an attacker gets a public key and can learn signatures 
on arbitrary messages of its choice. 
A signature system is secure if,
even in this setting, the attacker cannot produce a new message/signature 
pair of his choosing such that the verification algorithm accepts.
</t>

<t>
Preventing an attacker from mounting an attack means that the attack is computationally
too expensive to be carried out. There are various estimates for when
a computation is too expensive to be done. For that reason, this note only 
describes how expensive it is for an attacker to generate a forgery.
Parameters are accompanied by a bit security value. The meaning of bit security is as follows.
A parameter set grants b bits of security if the best attack takes at least 2^(b - 1)
bit operations to achieve a success probability of 1/2. Hence, to mount a successful attack, 
an attacker needs to perform 2^b bit operations on average. The given values for bit security 
were estimated according to <xref target='HRS16'/>.
</t>

<section title="Security Proofs">

<t>
A full security proof for all schemes described in this document can be found in <xref target='HRS16'/>. This proof
shows that an attacker has to break at least one out of certain security properties 
of the used hash functions and PRFs to forge a signature in any of the described schemes. The proof in <xref target='HRS16'/> considers
an initial message compression different from the randomized hashing used here. We comment on this below.
For the original schemes, these proofs show that 
an attacker has to break certain minimal security properties. In particular, it is not 
sufficient to break the collision resistance of the hash functions to generate a forgery.
</t>

<t>
More specifically, the requirements on the used functions are that 
F and H are post-quantum multi-function multi-target second-preimage
resistant keyed functions,
F fulfills an additional statistical requirement that roughly says that most
images have at least two preimages, 
PRF is a post-quantum pseudorandom function, and
H_msg is a post-quantum multi-target extended target collision-resistant keyed hash function. 
For detailed definitions of these properties see <xref target='HRS16'/>. To
give some intuition: multi-function multi-target second-preimage resistance is 
an extension of second-preimage resistance to keyed hash functions, covering the case where an adversary succeeds if it finds a second preimage for 
one out of many values. The same holds for multi-target extended target collision resistance,
which just lacks the multi-function identifier as target collision resistance
already considers keyed hash functions.
The proof in <xref target='HRS16'/> splits PRF into two functions. When PRF is used for pseudorandom key generation or generation of randomness 
for randomized message hashing, it is still considered a pseudorandom function. Whenever PRF is used to
generate bitmasks and hash function keys, it is modeled as a random oracle. This is due to technical reasons in the proof, and an implementation 
using a pseudorandom function is secure.
</t>

<t>
The proof in <xref target='HRS16'/> considers classical randomized hashing for the initial message compression, i.e., H(r, M) instead of H(r || getRoot(PK) || index, M). 
This classical randomized hashing allows getting a security reduction from extended target collision resistance <xref target='HRS16'/>, a property that is 
conjectured to be strictly weaker than collision resistance. However, it turns out that in this case, an attacker could still launch a multi-target attack even against multiple users at the same time.
The reason is that the adversary attacking u users at the same time learns u * 2^h randomized hashes H(r_i_j || M_i_j) with signature index i in [0, 2^h - 1] and user index j in [0, u]. 
It suffices to find a single pair (r*, M*) such that H(r* || M*) = H(r_i_u || M_i_u) for one out of the u * 2^h learned hashes. Hence, an attacker can do a brute-force search in time 2^n / u * 2^h instead of 2^n.
</t>

<t>
The indexed randomized hashing H(r || getRoot(PK) || toByte(idx, n), M)
used in this work makes the hash function calls position- and
user-dependent. This thwarts the above attack because each hash
function evaluation during an attack can only target one of the learned
randomized hash values. More specifically, an attacker now has to
decide which index idx and which root value to use for each query. 
If one assumes that the used hash function is a random function, it can be shown that
a multi-user existential forgery attack that targets this message compression has a complexity
of 2^n hash function calls.
</t>

<t>
The given bit security values were estimated based on the complexity of the
best-known generic attacks against 
the required security properties of the used hash and pseudorandom functions,
assuming conventional and quantum adversaries.
At the time of writing, generic attacks are the best-known attacks for the
parameters suggested in the classical setting. Also,
in the quantum setting, there are no dedicated attacks known that perform
better than generic attacks. Nevertheless, 
the topic of quantum cryptanalysis of hash functions is not as well understood
as in the classical setting. 
</t>

</section>

<section title="Minimal Security Assumptions">

  <t>
The assumptions one has to make to prove security of the
described schemes are minimal in the following sense.
Any signature algorithm
that allows arbitrary size messages relies on the security of a cryptographic
hash function, either on collision resistance
or on extended target collision resistance if randomized hashing is used for message compression.
For the schemes described here, this is already sufficient to be secure. In
contrast, common signature schemes like RSA, DSA, and Elliptic Curve Digital
Signature Algorithm (ECDSA) additionally rely
on the conjectured hardness of certain mathematical problems. 
</t>

</section>

<section title="Post-Quantum Security" anchor="pq">

<t>
A post-quantum cryptosystem is a system that is secure against attackers with
access to a reasonably sized quantum computer. At the time of writing this note,  
whether or not it is feasible to build such a machine is an open conjecture. However, significant progress was
made over the last few years in this regard. Hence, we consider it a matter of risk assessment to prepare for this case.
</t>

<t>
In contrast to RSA, DSA, and ECDSA, the described signature systems are post-quantum-secure if they
are used with an appropriate cryptographic hash function. In particular, for post-quantum security,
the size of n must be twice the size required for classical security.  This is in order to
protect against quantum square-root attacks due to Grover's algorithm. 
<xref target='HRS16'/> shows that 
variants of Grover's algorithm are the optimal generic attacks against the
security properties of hash functions required 
for the described schemes.  
</t>

<t>
As stated above, we only consider generic attacks here, as cryptographic hash
functions should be deprecated as soon as 
dedicated attacks that perform significantly better exist. This also applies
to the quantum setting. As soon as
dedicated quantum attacks against the used hash function that can perform
significantly better than the described generic attacks exist,
these hash functions should not be used anymore for the described schemes, or
the computation of the security level has to be redone.

</t>
</section>

</section>

</middle>

<back>

<references title="Normative References">

&rfc2119;

&rfc8126;

&rfc4506;

&rfc8174;

<reference anchor="FIPS180">
<front>
<title>
Secure Hash Standard (SHS)
</title>
<author>
<organization>
National Institute of Standards and Technology
</organization>
</author>
<date year="2015" month="August"></date>
</front>
<seriesInfo name="FIPS PUB" value="180-4"></seriesInfo>
<seriesInfo name='DOI' value='10.6028/NIST.FIPS.180-4' />
</reference>

<reference anchor="FIPS202">
<front>
<title>
SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions
</title>
<author>
<organization>
National Institute of Standards and Technology
</organization>
</author>
<date year="2015" month="August"></date>
</front>
<seriesInfo name="FIPS PUB" value="202"></seriesInfo>
<seriesInfo name='DOI' value='10.6028/NIST.FIPS.202' />
</reference>

</references>

<references title="Informative References">

<reference anchor="BDS09">
<front>
<title>
Hash-based Digital Signature Schemes
</title>
<author surname="Buchmann" initials="J.">
<organization />
</author>
<author surname="Dahmen" initials="E.">
<organization />
</author>
<author surname="Szydlo" initials="M.">
<organization />
</author>
<date year="2009" />
</front>
<seriesInfo name="Book chapter," value="Post-Quantum Cryptography"/>
<seriesInfo name='DOI' value='10.1007/978-3-540-88702-7_3' />
</reference>

<reference anchor='MCF18'>
<front>
<title>Hash-Based Signatures</title>
<author initials='D' surname='McGrew' fullname='David McGrew'>
<organization />
</author>
<author initials='M' surname='Curcio' fullname='Michael Curcio'>
<organization />
</author>
<author initials='S' surname='Fluhrer' fullname='Scott Fluhrer'>
<organization />
</author>
<date month='April' year='2018' />

</front>
<seriesInfo name='Work in Progress,' value='draft-mcgrew-hash-sigs-11' />
</reference>

<reference anchor="Merkle83" target="">
<front>
<title>
Secrecy, Authentication, and Public Key Systems
</title>
<author surname="Merkle" initials="R. C.">
<organization />
</author>
<date year="1983" />
</front>
<seriesInfo name="Computer Science Series," value="UMI Research Press, ISBN: 9780835713849" />
</reference>

<reference anchor="BDH11">
<front>
<title>
XMSS - A Practical Forward Secure Signature Scheme Based on Minimal 
Security Assumptions
</title>
<author surname="Buchmann" initials="J." >
<organization />
</author>
<author surname="Dahmen" initials="E." >
<organization />
</author>
<author surname="Huelsing" initials="A." >
<organization />
</author>
<date year="2011" />
</front>
<seriesInfo name="Lecture Notes in Computer Science, Volume 7071," 
	value="Post-Quantum Cryptography" />
<seriesInfo name='DOI' value='10.1007/978-3-642-25405-5_8' />
</reference>

<reference anchor="HRB13">
<front>
<title>
Optimal Parameters for XMSS^MT
</title>
<author surname="Huelsing" initials="A." >
<organization />
</author>
<author surname="Rausch" initials="L." >
<organization />
</author>
<author surname="Buchmann" initials="J." >
<organization />
</author>
<date year="2013" />
</front>
<seriesInfo name="Lecture Notes in Computer Science, Volume 8128," value="CD-ARES" />
<seriesInfo name='DOI' value='10.1007/978-3-642-40588-4_14' />

</reference>

<reference anchor="Huelsing13">
<front>
<title>
W-OTS+ - Shorter Signatures for Hash-Based Signature Schemes
</title>
<author surname="Huelsing" initials="A." >
<organization />
</author>
<date year="2013" />
</front>
<seriesInfo name="Lecture Notes in Computer Science, Volume 7918,"
	    value="Progress in Cryptology - AFRICACRYPT" />
<seriesInfo name='DOI' value='10.1007/978-3-642-38553-7_10' />
</reference>

<reference anchor="Huelsing13a" target="http://tuprints.ulb.tu-darmstadt.de/3651/1/Thesis.pdf">
<front>
<title>Practical Forward Secure Signatures using Minimal Security Assumptions</title>
<author surname="Huelsing" initials="A." >
<organization />
</author>
<date year="2013" />
</front>
<seriesInfo name="PhD thesis" value="TU Darmstadt" />
</reference>

<reference anchor="BHH15">
<front>
<title>SPHINCS: Practical Stateless Hash-Based Signatures</title>
<author surname="Bernstein" initials="D. J." >
<organization />
</author>
<author surname="Hopwood" initials="D." >
<organization />
</author>
<author surname="Huelsing" initials="A." >
<organization />
</author>
<author surname="Lange" initials="T." >
<organization />
</author>
<author surname="Niederhagen" initials="R." >
<organization />
</author>
<author surname="Papachristodoulou" initials="L." >
<organization />
</author>
<author surname="Schneider" initials="M." >
<organization />
</author>
<author surname="Schwabe" initials="P." >
<organization />
</author>
<author surname="Wilcox-O'Hearn" initials="Z." >
<organization />
</author> 
<date year="2015" />
</front>
<seriesInfo name="Lecture Notes in Computer Science, Volume 9056,"
	    value="Advances in Cryptology - EUROCRYPT" />
<seriesInfo name='DOI' value='10.1007/978-3-662-46800-5_15' />
</reference>

<reference anchor="HRS16">
<front>
<title>
Mitigating Multi-Target Attacks in Hash-based Signatures
</title>
<author surname="Huelsing" initials="A." >
<organization />
</author>
<author surname="Rijneveld" initials="J." >
<organization />
</author>
<author surname="Song" initials="F." >
<organization />
</author>
<date year="2016" />
</front>
<seriesInfo name="Lecture Notes in Computer Science, Volume 9614,"
	    value="Public-Key Cryptography - PKC" />
<seriesInfo name='DOI' value='10.1007/978-3-662-49384-7_15' />
</reference>

<reference anchor="KMN14">
<front>
<title>
A space- and time-efficient Implementation of the Merkle Tree Traversal Algorithm
</title>
<author surname="Knecht" initials="M." >
<organization />
</author>
<author surname="Meier" initials="W." >
<organization />
</author>
<author surname="Nicola" initials="C." > 
<organization />
</author>
<date year="2014" />
</front>
<seriesInfo name="Computing Research Repository (CoRR)," value="arXiv:1409.4081" />
</reference>

<reference anchor="BDS08">
<front>
<title>
Merkle Tree Traversal Revisited
</title>
<author surname="Buchmann" initials="J." >
<organization />
</author>
<author surname="Dahmen" initials="E." >
<organization />
</author>
<author surname="Schneider" initials="M." >
<organization />
</author>
<date year="2008" />
</front>
<seriesInfo name="Lecture Notes in Computer Science, Volume 5299," 
value="Post-Quantum Cryptography" />
<seriesInfo name='DOI' value='10.1007/978-3-540-88403-3_5' />
</reference>

</references>



<section anchor="wotsxdr" title="WOTS+ XDR Formats">

<t>
The WOTS+ signature and public key formats are formally defined
using XDR <xref target="RFC4506" /> in order to provide an
unambiguous, machine readable definition.
Though XDR is used, these formats are simple and easy to
parse without any special tools. Note that this representation includes all
optional parameter sets. The same applies for the XMSS and XMSS^MT formats below.
</t>

<section title="WOTS+ Parameter Sets">

<figure>
<preamble>
WOTS+ parameter sets are defined using XDR syntax as follows:
</preamble>
<artwork><![CDATA[
   /* ots_algorithm_type identifies a particular
      signature algorithm */

   enum ots_algorithm_type {
     wotsp_reserved  = 0x00000000,
     wotsp-sha2_256  = 0x00000001,
     wotsp-sha2_512  = 0x00000002,
     wotsp-shake_256 = 0x00000003,
     wotsp-shake_512 = 0x00000004,
   };
]]></artwork>
</figure>

</section>

<section title="WOTS+ Signatures">

<figure>
<preamble>
WOTS+ signatures are defined using XDR syntax as follows:
</preamble>
<artwork><![CDATA[
   /* Byte strings */

   typedef opaque bytestring32[32];
   typedef opaque bytestring64[64];

   union ots_signature switch (ots_algorithm_type type) {
     case wotsp-sha2_256:
     case wotsp-shake_256:
       bytestring32 ots_sig_n32_len67[67];

     case wotsp-sha2_512:
     case wotsp-shake_512:
       bytestring64 ots_sig_n64_len18[131];

     default:
       void;   /* error condition */
   };
]]></artwork>
</figure>

</section>

<section title="WOTS+ Public Keys">

<figure>
<preamble>
WOTS+ public keys are defined using XDR syntax as follows:
</preamble>
<artwork><![CDATA[
   union ots_pubkey switch (ots_algorithm_type type) {
     case wotsp-sha2_256:
     case wotsp-shake_256:
       bytestring32 ots_pubk_n32_len67[67];

     case wotsp-sha2_512:
     case wotsp-shake_512:
       bytestring64 ots_pubk_n64_len18[131];

     default:
       void;   /* error condition */
   };
 ]]></artwork>
</figure>

</section>
</section>

<section anchor="xmssxdr" title="XMSS XDR Formats">

<section title="XMSS Parameter Sets">
<figure>
<preamble>
XMSS parameter sets are defined using XDR syntax as follows:
</preamble>
<artwork><![CDATA[
   /* Byte strings */

   typedef opaque bytestring4[4];

   /* Definition of parameter sets */

   enum xmss_algorithm_type {
     xmss_reserved     = 0x00000000,

     /* 256 bit classical security, 128 bit post-quantum security */

     xmss-sha2_10_256  = 0x00000001,
     xmss-sha2_16_256  = 0x00000002,
     xmss-sha2_20_256  = 0x00000003,

     /* 512 bit classical security, 256 bit post-quantum security */

     xmss-sha2_10_512  = 0x00000004,
     xmss-sha2_16_512  = 0x00000005,
     xmss-sha2_20_512  = 0x00000006,

     /* 256 bit classical security, 128 bit post-quantum security */

     xmss-shake_10_256 = 0x00000007,
     xmss-shake_16_256 = 0x00000008,
     xmss-shake_20_256 = 0x00000009,

     /* 512 bit classical security, 256 bit post-quantum security */

     xmss-shake_10_512 = 0x0000000A,
     xmss-shake_16_512 = 0x0000000B,
     xmss-shake_20_512 = 0x0000000C,
   };
]]></artwork>
</figure>
</section>

<section title="XMSS Signatures">
<figure>
<preamble>
XMSS signatures are defined using XDR syntax as follows:
</preamble>
<artwork><![CDATA[
   /* Authentication path types */

   union xmss_path switch (xmss_algorithm_type type) {
     case xmss-sha2_10_256:
     case xmss-shake_10_256:
       bytestring32 path_n32_t10[10];

     case xmss-sha2_16_256:
     case xmss-shake_16_256:
       bytestring32 path_n32_t16[16];

     case xmss-sha2_20_256:
     case xmss-shake_20_256:
       bytestring32 path_n32_t20[20];

     case xmss-sha2_10_512:
     case xmss-shake_10_512:
       bytestring64 path_n64_t10[10];

     case xmss-sha2_16_512:
     case xmss-shake_16_512:
       bytestring64 path_n64_t16[16];

     case xmss-sha2_20_512:
     case xmss-shake_20_512:
       bytestring64 path_n64_t20[20];

     default:
       void;     /* error condition */
   };

   /* Types for XMSS random strings */

   union random_string_xmss switch (xmss_algorithm_type type) {
     case xmss-sha2_10_256:
     case xmss-sha2_16_256:
     case xmss-sha2_20_256:
     case xmss-shake_10_256:
     case xmss-shake_16_256:
     case xmss-shake_20_256:
       bytestring32 rand_n32;

     case xmss-sha2_10_512:
     case xmss-sha2_16_512:
     case xmss-sha2_20_512:
     case xmss-shake_10_512:
     case xmss-shake_16_512:
     case xmss-shake_20_512:
       bytestring64 rand_n64;

     default:
       void;     /* error condition */
   };

   /* Corresponding WOTS+ type for given XMSS type */

   union xmss_ots_signature switch (xmss_algorithm_type type) {
     case xmss-sha2_10_256:
     case xmss-sha2_16_256:
     case xmss-sha2_20_256:
       wotsp-sha2_256;

     case xmss-sha2_10_512:
     case xmss-sha2_16_512:
     case xmss-sha2_20_512:
       wotsp-sha2_512;

     case xmss-shake_10_256:
     case xmss-shake_16_256:
     case xmss-shake_20_256:
       wotsp-shake_256;

     case xmss-shake_10_512:
     case xmss-shake_16_512:
     case xmss-shake_20_512:
       wotsp-shake_512;

     default:
       void;     /* error condition */
   };

   /* XMSS signature structure */

   struct xmss_signature {
     /* WOTS+ key pair index */
     bytestring4 idx_sig;
     /* Random string for randomized hashing */
     random_string_xmss rand_string;
     /* WOTS+ signature */
     xmss_ots_signature sig_ots;
     /* authentication path */
     xmss_path nodes;
   };
]]></artwork>
</figure>
</section>

<section title="XMSS Public Keys">
<figure>
<preamble>
XMSS public keys are defined using XDR syntax as follows:
</preamble>
<artwork><![CDATA[
   /* Types for bitmask seed */

   union seed switch (xmss_algorithm_type type) {
     case xmss-sha2_10_256:
     case xmss-sha2_16_256:
     case xmss-sha2_20_256:
     case xmss-shake_10_256:
     case xmss-shake_16_256:
     case xmss-shake_20_256:
       bytestring32 seed_n32;

     case xmss-sha2_10_512:
     case xmss-sha2_16_512:
     case xmss-sha2_20_512:
     case xmss-shake_10_512:
     case xmss-shake_16_512:
     case xmss-shake_20_512:
       bytestring64 seed_n64;

     default:
       void;     /* error condition */
   };

   /* Types for XMSS root node */

   union xmss_root switch (xmss_algorithm_type type) {
     case xmss-sha2_10_256:
     case xmss-sha2_16_256:
     case xmss-sha2_20_256:
     case xmss-shake_10_256:
     case xmss-shake_16_256:
     case xmss-shake_20_256:
       bytestring32 root_n32;

     case xmss-sha2_10_512:
     case xmss-sha2_16_512:
     case xmss-sha2_20_512:
     case xmss-shake_10_512:
     case xmss-shake_16_512:
     case xmss-shake_20_512:
       bytestring64 root_n64;

     default:
       void;     /* error condition */
   };

   /* XMSS public key structure */

   struct xmss_public_key {
     xmss_root root;  /* Root node */
     seed SEED;  /* Seed for bitmasks */
   };
]]></artwork>
</figure>
</section>
</section>

<section anchor="xmssmtxdr" title="XMSS^MT XDR Formats">

<section title="XMSS^MT Parameter Sets">
<figure>
<preamble>
XMSS^MT parameter sets are defined using XDR syntax as follows:
</preamble>
<artwork><![CDATA[
   /* Byte strings */

   typedef opaque bytestring3[3];
   typedef opaque bytestring5[5];
   typedef opaque bytestring8[8];

   /* Definition of parameter sets */

   enum xmssmt_algorithm_type {
     xmssmt_reserved        = 0x00000000,

     /* 256 bit classical security, 128 bit post-quantum security */

     xmssmt-sha2_20/2_256   = 0x00000001,
     xmssmt-sha2_20/4_256   = 0x00000002,
     xmssmt-sha2_40/2_256   = 0x00000003,
     xmssmt-sha2_40/4_256   = 0x00000004,
     xmssmt-sha2_40/8_256   = 0x00000005,
     xmssmt-sha2_60/3_256   = 0x00000006,
     xmssmt-sha2_60/6_256   = 0x00000007,
     xmssmt-sha2_60/12_256  = 0x00000008,

     /* 512 bit classical security, 256 bit post-quantum security */

     xmssmt-sha2_20/2_512   = 0x00000009,
     xmssmt-sha2_20/4_512   = 0x0000000A,
     xmssmt-sha2_40/2_512   = 0x0000000B,
     xmssmt-sha2_40/4_512   = 0x0000000C,
     xmssmt-sha2_40/8_512   = 0x0000000D,
     xmssmt-sha2_60/3_512   = 0x0000000E,
     xmssmt-sha2_60/6_512   = 0x0000000F,
     xmssmt-sha2_60/12_512  = 0x00000010,

     /* 256 bit classical security, 128 bit post-quantum security */

     xmssmt-shake_20/2_256  = 0x00000011,
     xmssmt-shake_20/4_256  = 0x00000012,
     xmssmt-shake_40/2_256  = 0x00000013,
     xmssmt-shake_40/4_256  = 0x00000014,
     xmssmt-shake_40/8_256  = 0x00000015,
     xmssmt-shake_60/3_256  = 0x00000016,
     xmssmt-shake_60/6_256  = 0x00000017,
     xmssmt-shake_60/12_256 = 0x00000018,

     /* 512 bit classical security, 256 bit post-quantum security */

     xmssmt-shake_20/2_512  = 0x00000019,
     xmssmt-shake_20/4_512  = 0x0000001A,
     xmssmt-shake_40/2_512  = 0x0000001B,
     xmssmt-shake_40/4_512  = 0x0000001C,
     xmssmt-shake_40/8_512  = 0x0000001D,
     xmssmt-shake_60/3_512  = 0x0000001E,
     xmssmt-shake_60/6_512  = 0x0000001F,
     xmssmt-shake_60/12_512 = 0x00000020,
   };
]]></artwork>
</figure>
</section>

<section title="XMSS^MT Signatures">
<figure>
<preamble>
XMSS^MT signatures are defined using XDR syntax as follows:
</preamble>
<artwork><![CDATA[
   /* Type for XMSS^MT key pair index */
   /* Depends solely on h */

   union idx_sig_xmssmt switch (xmss_algorithm_type type) {
     case xmssmt-sha2_20/2_256:
     case xmssmt-sha2_20/4_256:
     case xmssmt-sha2_20/2_512:
     case xmssmt-sha2_20/4_512:
     case xmssmt-shake_20/2_256:
     case xmssmt-shake_20/4_256:
     case xmssmt-shake_20/2_512:
     case xmssmt-shake_20/4_512:
       bytestring3 idx3;

     case xmssmt-sha2_40/2_256:
     case xmssmt-sha2_40/4_256:
     case xmssmt-sha2_40/8_256:
     case xmssmt-sha2_40/2_512:
     case xmssmt-sha2_40/4_512:
     case xmssmt-sha2_40/8_512:
     case xmssmt-shake_40/2_256:
     case xmssmt-shake_40/4_256:
     case xmssmt-shake_40/8_256:
     case xmssmt-shake_40/2_512:
     case xmssmt-shake_40/4_512:
     case xmssmt-shake_40/8_512:
       bytestring5 idx5;

     case xmssmt-sha2_60/3_256:
     case xmssmt-sha2_60/6_256:
     case xmssmt-sha2_60/12_256:
     case xmssmt-sha2_60/3_512:
     case xmssmt-sha2_60/6_512:
     case xmssmt-sha2_60/12_512:
     case xmssmt-shake_60/3_256:
     case xmssmt-shake_60/6_256:
     case xmssmt-shake_60/12_256:
     case xmssmt-shake_60/3_512:
     case xmssmt-shake_60/6_512:
     case xmssmt-shake_60/12_512:
       bytestring8 idx8;

     default:
       void;     /* error condition */
   };

   union random_string_xmssmt switch (xmssmt_algorithm_type type) {
     case xmssmt-sha2_20/2_256:
     case xmssmt-sha2_20/4_256:
     case xmssmt-sha2_40/2_256:
     case xmssmt-sha2_40/4_256:
     case xmssmt-sha2_40/8_256:
     case xmssmt-sha2_60/3_256:
     case xmssmt-sha2_60/6_256:
     case xmssmt-sha2_60/12_256:
     case xmssmt-shake_20/2_256:
     case xmssmt-shake_20/4_256:
     case xmssmt-shake_40/2_256:
     case xmssmt-shake_40/4_256:
     case xmssmt-shake_40/8_256:
     case xmssmt-shake_60/3_256:
     case xmssmt-shake_60/6_256:
     case xmssmt-shake_60/12_256:
       bytestring32 rand_n32;

     case xmssmt-sha2_20/2_512:
     case xmssmt-sha2_20/4_512:
     case xmssmt-sha2_40/2_512:
     case xmssmt-sha2_40/4_512:
     case xmssmt-sha2_40/8_512:
     case xmssmt-sha2_60/3_512:
     case xmssmt-sha2_60/6_512:
     case xmssmt-sha2_60/12_512:
     case xmssmt-shake_20/2_512:
     case xmssmt-shake_20/4_512:
     case xmssmt-shake_40/2_512:
     case xmssmt-shake_40/4_512:
     case xmssmt-shake_40/8_512:
     case xmssmt-shake_60/3_512:
     case xmssmt-shake_60/6_512:
     case xmssmt-shake_60/12_512:
       bytestring64 rand_n64;

     default:
       void;     /* error condition */
   };

   /* Type for reduced XMSS signatures */

   union xmss_reduced (xmss_algorithm_type type) {
     case xmssmt-sha2_20/2_256:
     case xmssmt-sha2_40/4_256:
     case xmssmt-sha2_60/6_256:
     case xmssmt-shake_20/2_256:
     case xmssmt-shake_40/4_256:
     case xmssmt-shake_60/6_256:
       bytestring32 xmss_reduced_n32_t77[77];

     case xmssmt-sha2_20/4_256:
     case xmssmt-sha2_40/8_256:
     case xmssmt-sha2_60/12_256:
     case xmssmt-shake_20/4_256:
     case xmssmt-shake_40/8_256:
     case xmssmt-shake_60/12_256:
       bytestring32 xmss_reduced_n32_t72[72];

     case xmssmt-sha2_40/2_256:
     case xmssmt-sha2_60/3_256:
     case xmssmt-shake_40/2_256:
     case xmssmt-shake_60/3_256:
       bytestring32 xmss_reduced_n32_t87[87];

     case xmssmt-sha2_20/2_512:
     case xmssmt-sha2_40/4_512:
     case xmssmt-sha2_60/6_512:
     case xmssmt-shake_20/2_512:
     case xmssmt-shake_40/4_512:
     case xmssmt-shake_60/6_512:
       bytestring64 xmss_reduced_n32_t141[141];

     case xmssmt-sha2_20/4_512:
     case xmssmt-sha2_40/8_512:
     case xmssmt-sha2_60/12_512:
     case xmssmt-shake_20/4_512:
     case xmssmt-shake_40/8_512:
     case xmssmt-shake_60/12_512:
       bytestring64 xmss_reduced_n32_t136[136];

     case xmssmt-sha2_40/2_512:
     case xmssmt-sha2_60/3_512:
     case xmssmt-shake_40/2_512:
     case xmssmt-shake_60/3_512:
       bytestring64 xmss_reduced_n32_t151[151];

     default:
       void;     /* error condition */
   };

   /* xmss_reduced_array depends on d */

   union xmss_reduced_array (xmss_algorithm_type type) {
     case xmssmt-sha2_20/2_256:
     case xmssmt-sha2_20/2_512:
     case xmssmt-sha2_40/2_256:
     case xmssmt-sha2_40/2_512:
     case xmssmt-shake_20/2_256:
     case xmssmt-shake_20/2_512:
     case xmssmt-shake_40/2_256:
     case xmssmt-shake_40/2_512:
       xmss_reduced xmss_red_arr_d2[2];

     case xmssmt-sha2_60/3_256:
     case xmssmt-sha2_60/3_512:
     case xmssmt-shake_60/3_256:
     case xmssmt-shake_60/3_512:
       xmss_reduced xmss_red_arr_d3[3];

     case xmssmt-sha2_20/4_256:
     case xmssmt-sha2_20/4_512:
     case xmssmt-sha2_40/4_256:
     case xmssmt-sha2_40/4_512:
     case xmssmt-shake_20/4_256:
     case xmssmt-shake_20/4_512:
     case xmssmt-shake_40/4_256:
     case xmssmt-shake_40/4_512:
       xmss_reduced xmss_red_arr_d4[4];

     case xmssmt-sha2_60/6_256:
     case xmssmt-sha2_60/6_512:
     case xmssmt-shake_60/6_256:
     case xmssmt-shake_60/6_512:
       xmss_reduced xmss_red_arr_d6[6];

     case xmssmt-sha2_40/8_256:
     case xmssmt-sha2_40/8_512:
     case xmssmt-shake_40/8_256:
     case xmssmt-shake_40/8_512:
       xmss_reduced xmss_red_arr_d8[8];

     case xmssmt-sha2_60/12_256:
     case xmssmt-sha2_60/12_512:
     case xmssmt-shake_60/12_256:
     case xmssmt-shake_60/12_512:
       xmss_reduced xmss_red_arr_d12[12];

     default:
       void;     /* error condition */
   };

   /* XMSS^MT signature structure */

   struct xmssmt_signature {
     /* WOTS+ key pair index */
     idx_sig_xmssmt idx_sig;
     /* Random string for randomized hashing */
     random_string_xmssmt randomness;
     /* Array of d reduced XMSS signatures */
     xmss_reduced_array;
   };
]]></artwork>
</figure>
</section>

<section title="XMSS^MT Public Keys">
<figure>
<preamble>
XMSS^MT public keys are defined using XDR syntax as follows:
</preamble>
<artwork><![CDATA[
   /* Types for bitmask seed */

   union seed switch (xmssmt_algorithm_type type) {
     case xmssmt-sha2_20/2_256:
     case xmssmt-sha2_40/4_256:
     case xmssmt-sha2_60/6_256:
     case xmssmt-sha2_20/4_256:
     case xmssmt-sha2_40/8_256:
     case xmssmt-sha2_60/12_256:
     case xmssmt-sha2_40/2_256:
     case xmssmt-sha2_60/3_256:
     case xmssmt-shake_20/2_256:
     case xmssmt-shake_40/4_256:
     case xmssmt-shake_60/6_256:
     case xmssmt-shake_20/4_256:
     case xmssmt-shake_40/8_256:
     case xmssmt-shake_60/12_256:
     case xmssmt-shake_40/2_256:
     case xmssmt-shake_60/3_256:
       bytestring32 seed_n32;

     case xmssmt-sha2_20/2_512:
     case xmssmt-sha2_40/4_512:
     case xmssmt-sha2_60/6_512:
     case xmssmt-sha2_20/4_512:
     case xmssmt-sha2_40/8_512:
     case xmssmt-sha2_60/12_512:
     case xmssmt-sha2_40/2_512:
     case xmssmt-sha2_60/3_512:
     case xmssmt-shake_20/2_512:
     case xmssmt-shake_40/4_512:
     case xmssmt-shake_60/6_512:
     case xmssmt-shake_20/4_512:
     case xmssmt-shake_40/8_512:
     case xmssmt-shake_60/12_512:
     case xmssmt-shake_40/2_512:
     case xmssmt-shake_60/3_512:
       bytestring64 seed_n64;

     default:
       void;     /* error condition */
   };

   /* Types for XMSS^MT root node */

   union xmssmt_root switch (xmssmt_algorithm_type type) {
     case xmssmt-sha2_20/2_256:
     case xmssmt-sha2_20/4_256:
     case xmssmt-sha2_40/2_256:
     case xmssmt-sha2_40/4_256:
     case xmssmt-sha2_40/8_256:
     case xmssmt-sha2_60/3_256:
     case xmssmt-sha2_60/6_256:
     case xmssmt-sha2_60/12_256:
     case xmssmt-shake_20/2_256:
     case xmssmt-shake_20/4_256:
     case xmssmt-shake_40/2_256:
     case xmssmt-shake_40/4_256:
     case xmssmt-shake_40/8_256:
     case xmssmt-shake_60/3_256:
     case xmssmt-shake_60/6_256:
     case xmssmt-shake_60/12_256:
       bytestring32 root_n32;

     case xmssmt-sha2_20/2_512:
     case xmssmt-sha2_20/4_512:
     case xmssmt-sha2_40/2_512:
     case xmssmt-sha2_40/4_512:
     case xmssmt-sha2_40/8_512:
     case xmssmt-sha2_60/3_512:
     case xmssmt-sha2_60/6_512:
     case xmssmt-sha2_60/12_512:
     case xmssmt-shake_20/2_512:
     case xmssmt-shake_20/4_512:
     case xmssmt-shake_40/2_512:
     case xmssmt-shake_40/4_512:
     case xmssmt-shake_40/8_512:
     case xmssmt-shake_60/3_512:
     case xmssmt-shake_60/6_512:
     case xmssmt-shake_60/12_512:
       bytestring64 root_n64;

     default:
       void;     /* error condition */
   };

   /* XMSS^MT public key structure */

   struct xmssmt_public_key {
     xmssmt_root root;  /* Root node */
     seed SEED;  /* Seed for bitmasks */
   };
]]></artwork>
</figure>
</section>
</section>


<section anchor="Acknowledgements" title="Acknowledgements" numbered="no">
<t>
We would like to thank Johannes Braun, Peter Campbell, Florian Caullery,
Stephen Farrell, Scott Fluhrer, Burt Kaliski, Adam Langley, Marcos Manzano,
David McGrew, Rafael Misoczki, Sean Parkinson, Sebastian Roland, and
the Keccak team for their help and comments.
</t>
</section>


</back>
</rfc>
