<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes" ?>
<?rfc compact="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc subcompact="no"?>
<?rfc rfcedstyle="yes" ?>

<rfc number="6202" category="info" ipr="trust200902">

  <front>
    <title abbrev="Bidirectional HTTP">Known Issues and Best Practices for the Use of Long Polling and Streaming in Bidirectional HTTP</title>

    <author initials="S." surname="Loreto" fullname="Salvatore Loreto">
      <organization>Ericsson</organization>
      <address>
        <postal>
          <street>Hirsalantie 11</street>
          <code>02420</code> 
          <city>Jorvas</city> 
          <country>Finland</country>
        </postal>
        <email>salvatore.loreto@ericsson.com</email>
      </address>
    </author>

    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization>Cisco</organization>
       <address>
         <postal>
           <street>1899 Wyknoop Street, Suite 600</street>
           <city>Denver</city>
           <region>CO</region>
           <code>80202</code>
           <country>USA</country>
         </postal>
         <phone>+1-303-308-3282</phone>
         <email>psaintan@cisco.com</email>
       </address>
    </author>

    <author initials="S." surname="Salsano" fullname="Stefano Salsano">
      <organization>University of Rome "Tor Vergata"</organization>
      <address>
        <postal>
          <street>Via del Politecnico, 1</street>
          <code>00133</code> 
          <city>Rome</city> 
          <country>Italy</country>
        </postal>
        <email>stefano.salsano@uniroma2.it</email>
      </address>
    </author>

    <author initials="G." surname="Wilkins" fullname="Greg Wilkins">
      <organization>Webtide</organization>
      <address>
        <email>gregw@webtide.com</email>
      </address>
    </author> 

    <date month="March" year="2011"/>

    <area>Applications</area>
    <keyword>HTTP</keyword>
    <keyword>HTTP Streaming</keyword>
    <keyword>Long Polling</keyword>

    <abstract>
      <t>On today's Internet, the Hypertext Transfer Protocol (HTTP) is often
used (some would say abused) to enable asynchronous, "server-initiated"
communication from a server to a client as well as communication from a client to a server.  This document describes known issues and best practices related to such "bidirectional HTTP" applications, focusing on the two most common mechanisms: HTTP long polling and HTTP streaming.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction" toc="default">
      <t>The Hypertext Transfer Protocol <xref target="RFC2616"/> is a request/response protocol.  HTTP defines the following entities: clients, proxies, and servers.  A client establishes connections to a server for the purpose of sending HTTP requests.  A server accepts connections from clients in order to service HTTP requests by sending back responses.  Proxies are intermediate entities that can be involved in the delivery of requests and responses from the client to the server and vice versa.</t>
      <t>In the standard HTTP model, a server cannot initiate a connection with a client nor send an unrequested HTTP response to a client; thus, the server cannot push asynchronous events to clients.  Therefore, in order to receive asynchronous events as soon as possible, the client needs to poll the server periodically for new content.  However, continual polling can consume significant bandwidth by forcing a request/response round trip when no data is available.  It can also be inefficient because it reduces the responsiveness of the application since data is queued until the server receives the next poll request from the client.</t>
      <t>In order to improve this situation, several server-push programming
mechanisms have been implemented in recent years.  These mechanisms, which are
often grouped under the common label "Comet" <xref target="COMET"/>, enable a web server to send updates to clients without waiting for a poll request from the client.  Such mechanisms can deliver updates to clients in a more timely manner while avoiding the latency experienced by client applications due to the frequent opening and closing of connections necessary to periodically poll for data.</t>
      <t>The two most common server-push mechanisms are HTTP long polling and HTTP streaming:</t>
      <t>
        <list style="hanging">
          <t hangText="HTTP Long Polling:"> The server attempts to "hold open" (not immediately reply to) each HTTP request, responding only when there are events to deliver.  In this way, there is always a pending request to which the server can reply for the purpose of delivering events as they occur, thereby minimizing the latency in message delivery.</t>
          <t hangText="HTTP Streaming:"> The server keeps a request open indefinitely; that is, it never terminates the request or closes the connection, even after it pushes data to the client.</t>
        </list>
      </t>
      <t>It is possible to define other technologies for bidirectional HTTP; however, such technologies typically require changes to HTTP itself (e.g., by defining new HTTP methods).  This document focuses only on bidirectional HTTP technologies that work within the current scope of HTTP as defined in <xref target="RFC2616"/> (HTTP 1.1) and <xref target="RFC1945"/> (HTTP 1.0).</t>
      <t>The authors acknowledge that both the HTTP long polling and HTTP streaming mechanisms stretch the original semantic of HTTP and that the HTTP protocol was not designed for bidirectional communication.  This document neither encourages nor discourages the use of these mechanisms, and takes no position on whether they provide appropriate solutions to the problem of providing bidirectional communication between clients and servers.  Instead, this document merely identifies technical issues with these mechanisms and suggests best practices for their deployment.</t>
      <t>The remainder of this document is organized as follows.  <xref
target="polling"/> analyzes the HTTP long polling technique.  <xref
target="streaming"/> analyzes the HTTP streaming technique.  <xref
target="tech"/> provides an overview of the specific technologies that use the server-push technique.  <xref target="practices"/> lists best practices for bidirectional HTTP using existing technologies.</t>
    </section>

    <section anchor="polling" title="HTTP Long Polling">
      <section anchor="polling-definition" title="Definition">
        <t>With the traditional or "short polling" technique, a client sends regular requests to the server and each request attempts to "pull" any available events or data.  If there are no events or data available, the server returns an empty response and the client waits for some time before sending another poll request.  The polling frequency depends on the latency that the client can tolerate in retrieving updated information from the server.  This mechanism has the drawback that the consumed resources (server processing and network) strongly depend on the acceptable latency in the delivery of updates from server to client.  If the acceptable latency is low (e.g., on the order of seconds), then the polling frequency can cause an unacceptable burden on the server, the network, or both.</t>
        <t>In contrast with such "short polling", "long polling" attempts to
minimize both the latency in server-client message delivery and the use of processing/network resources.  The server achieves these efficiencies by responding to a request only when a particular event, status, or timeout has occurred.  Once the server sends a long poll response, typically the client immediately sends a new long poll request.  Effectively, this means that at any given time the server will be holding open a long poll request, to which it replies when new information is available for the client.  As a result, the server is able to asynchronously "initiate" communication.</t>
        <t>The basic life cycle of an application using HTTP long polling is as follows:</t>
        <t>
          <list style="numbers">
            <t>The client makes an initial request and then waits for a response.</t>
            <t>The server defers its response until an update is available or until a particular status or timeout has occurred.</t>
            <t>When an update is available, the server sends a complete response to the client.</t>
            <t>The client typically sends a new long poll request, either immediately upon receiving a response or after a pause to allow an acceptable latency period.</t>
           </list>
         </t>
         <t>The HTTP long polling mechanism can be applied to either persistent or non-persistent HTTP connections.  The use of persistent HTTP connections will avoid the additional overhead of establishing a new TCP/IP connection <xref target='TCP'/> for every long poll request.</t>
       </section>

       <section anchor="polling-issues" title="HTTP Long Polling Issues">
         <t>The HTTP long polling mechanism introduces the following issues.</t>
         <t>
           <list style="hanging">
             <t hangText="Header Overhead:">With the HTTP long polling
             technique, every long poll request and long poll response
             is a complete HTTP message and thus contains a full set
             of HTTP headers in the message framing.  For small,
             infrequent messages, the headers can represent a large
             percentage of the data transmitted.  If the network MTU
             (Maximum Transmission Unit) allows all the information
             (including the HTTP header) to fit within a single IP
             packet, this typically does not represent a significant
             increase in the burden for networking entities.  On the
             other hand, the amount of transferred data can be
             significantly larger than the real payload carried by
             HTTP, and this can have a significant impact (e.g., when
             volume-based charging is in place).</t>

             <t hangText="Maximal Latency:">After a long poll response is sent to a client, the server needs to wait for the next long poll request before another message can be sent to the client.  This means that while the average latency of long polling is close to one network transit, the maximal latency is over three network transits (long poll response, next long poll request, long poll response).  However, because HTTP is carried over TCP/IP, packet loss and retransmission can occur; therefore, maximal latency for any TCP/IP protocol will be more than three network transits (lost packet, next packet, negative ack, retransmit).  When HTTP pipelining (see <xref target="pipelining"/>) is available, the latency due to the server waiting for a new request can be avoided.</t>
             <t hangText="Connection Establishment:">A common criticism of both short polling and long polling is that these mechanisms frequently open TCP/IP connections and then close them.  However, both polling mechanisms work well with persistent HTTP connections that can be reused for many poll requests.  Specifically, the short duration of the pause between a long poll response and the next long poll request avoids the closing of idle connections.</t>
             <t hangText="Allocated Resources:">Operating systems will allocate resources to TCP/IP connections and to HTTP requests outstanding on those connections.  The HTTP long polling mechanism requires that for each client both a TCP/IP connection and an HTTP request are held open.  Thus, it is important to consider the resources related to both of these when sizing an HTTP long polling application.  Typically, the resources used per TCP/IP connection are minimal and can scale reasonably.  Frequently, the resources allocated to HTTP requests can be significant, and scaling the total number of requests outstanding can be limited on some gateways, proxies, and servers.</t>
             <t hangText="Graceful Degradation:">A long polling client
 or server that is under load has a natural tendency to gracefully
 degrade in performance at a cost of message latency.  If load causes
 either a client or server to run slowly, then events to be pushed to
 the client will queue (waiting either for the client to send a long
 poll request or for the server to free up CPU cycles that can be used to
 process a long poll request that is being held at the server). 

 If multiple messages are queued for a client, they might be delivered in a batch within a single long poll response.  This can significantly reduce the per-message overhead and thus ease the workload of the client or server for the given message load.</t>
             <t hangText="Timeouts:">Long poll requests 
need to remain pending or "hanging" until the server has something to send to the client.  The timeout issues related to these pending requests are discussed in <xref target="timeouts"/>.</t>
             <t hangText="Caching:">Caching mechanisms implemented by intermediate entities can interfere with long poll requests.  This issue is discussed in <xref target="network"/>.</t>
           </list>
         </t>
       </section>
     </section>

     <section anchor="streaming" title="HTTP Streaming">
       <section anchor="streaming-definition" title="Definition">
         <t>The HTTP streaming mechanism keeps a request open indefinitely.  It never terminates the request or closes the connection, even after the server pushes data to the client.  This mechanism significantly reduces the network latency because the client and the server do not need to open and close the connection.</t>
         <t>The basic life cycle of an application using HTTP streaming is as follows:</t>
         <t>
           <list style="numbers">
             <t>The client makes an initial request and then waits for a response.</t>
             <t>The server defers the response to a poll request until an update is available, or until a particular status or timeout has occurred.</t>
             <t>Whenever an update is available, the server sends it back to the client as a part of the response.</t>
             <t>The data sent by the server does not terminate the request or the connection.  The server returns to step 3.</t>
           </list>
         </t>
         <t>The HTTP streaming mechanism is based on the capability of the server to send several pieces of information in the same response, without terminating the request or the connection.  This result can be achieved by both HTTP/1.1 and HTTP/1.0 servers.</t>
         <t>An HTTP response content length can be defined using three options:</t>
         <t>
           <list style="hanging">
             <t hangText="Content-Length header:">This indicates the size of the entity body in the message, in bytes.</t>
             <t hangText="Transfer-Encoding header:">The 'chunked' valued in this header indicates the message will break into chunks of known size if needed.</t>
             <t hangText="End of File (EOF):">This is actually the default approach for HTTP/1.0 where the connections are not persistent.  Clients do not need to know the size of the body they are reading; instead they expect to read the body until the server closes the connection.  Although with HTTP/1.1 the default is for persistent connections, it is still possible to use EOF by setting the 'Connection:close' header in either the request or the response, thereby indicating that the connection is not to be considered 'persistent' after the current request/response is complete.  The client's inclusion of the 'Connection: close' header field in the request will also prevent pipelining.</t><t>The main issue with EOF is that it is difficult to tell the difference between a connection terminated by a fault and one that is correctly terminated.</t>
           </list>
         </t>
	<t>An HTTP/1.0 server can use only EOF as a streaming mechanism.  In contrast, both EOF and "chunked transfer" are available to an HTTP/1.1 server.</t>
         <t>The "chunked transfer" mechanism is the one typically used
         by HTTP/1.1 servers for streaming.  This is accomplished by
         including the header "Transfer-Encoding: chunked" at the
         beginning of the response, which enables the server to send the following parts of the response in different "chunks" over the same connection.  Each chunk starts with the hexadecimal expression of the length of its data, followed by CR/LF (the end of the response is indicated with a chunk of size 0).</t>
         <figure anchor="notifier" title="Transfer-Encoding response">
           <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height=""><![CDATA[
        HTTP/1.1 200 OK
        Content-Type: text/plain
        Transfer-Encoding: chunked

        25
        This is the data in the first chunk

        1C
        and this is the second one

        0
           ]]></artwork>
         </figure>
         <t>To achieve the same result, an HTTP/1.0 server will omit the
Content-Length header in the response. Thus, it will be able to send the subsequent parts of the response on the same connection (in this case, the different parts of the response are not explicitly separated by HTTP protocol, and the end of the response is achieved by closing the connection).</t>
       </section>
        
       <section anchor="streaming-issues" title="HTTP Streaming Issues">
         <t>The HTTP streaming mechanism introduces the following issues.</t>
         <t>
           <list style="hanging">
             <t hangText="Network Intermediaries:">The HTTP protocol allows for
intermediaries (proxies, transparent proxies, gateways, etc.) to be involved in
the transmission of a response from the server to the client.  There is no
requirement for an intermediary to immediately forward a partial response, and
it is legal for the intermediary to buffer the entire response before sending any data to the client (e.g., caching transparent proxies).  HTTP streaming will not work with such intermediaries.</t>
             <t hangText="Maximal Latency:">Theoretically, on a
 perfect network, an HTTP streaming protocol's average and maximal
 latency is one network transit.  However, in practice, the maximal
 latency is higher due to network and browser limitations.  The
 browser techniques used to terminate HTTP streaming connections are
 often associated with JavaScript and/or DOM (Document Object Model)
 elements that will grow in size for every message received.  Thus, in
 order to avoid unlimited growth of memory usage in the client, an HTTP
 streaming implementation occasionally needs to terminate the
 streaming response and send a request to initiate a new streaming
 response (which is essentially equivalent to a long poll). 

 Thus, the
 maximal latency is at least three network transits.  Also, because
 HTTP is carried over TCP/IP, packet loss and retransmission can
 occur; therefore maximal latency for any TCP/IP protocol will be more
 than three network transits (lost packet, next packet, negative ack,
 retransmit).</t>

             <t hangText="Client Buffering:">There is no requirement in
existing HTTP specifications for a client library to make the data from a
partial HTTP response available to the client application.  For example, if
each response chunk contains a statement of JavaScript, there is no requirement
in the browser to execute that JavaScript before the entire response is
received.   However, in practice, most browsers do execute JavaScript received
in partial responses -- although some require a buffer overflow to trigger
execution. In most implementations, blocks of white space can be sent to achieve buffer overflow.</t>
             <t hangText="Framing Techniques:">Using HTTP streaming, several application messages can be sent within a single HTTP response.  The separation of the response stream into application messages needs to be performed at the application level and not at the HTTP level.  In particular, it is not possible to use the HTTP chunks as application message delimiters, since intermediate proxies might "re-chunk" the message stream (for example, by combining different chunks into a longer one).  This issue does not affect the HTTP long polling technique, which provides a canonical framing technique: each application message can be sent in a different HTTP response.</t>
           </list>
         </t>
       </section>
     </section>

    <section anchor="tech" title="Overview of Technologies">
      <t>This section provides an overview of existing technologies that implement HTTP-based server-push mechanisms to asynchronously deliver messages from the server to the client.</t>

      <section anchor="bayeux" title="Bayeux">
        <t>The Bayeux protocol <xref target="BAYEUX"/> was developed in 2006-2007 by the Dojo Foundation.  Bayeux can use both the HTTP long polling and HTTP streaming mechanisms.</t> 
        <t>In order to achieve bidirectional communications, a Bayeux client will use two HTTP connections to a Bayeux server so that both server-to-client and client-to-server messaging can occur asynchronously.</t>
        <t>The Bayeux specification requires that implementations control pipelining of HTTP requests, so that requests are not pipelined inappropriately (e.g., a client-to-server message pipelined behind a long poll request).</t>
        <t>In practice, for JavaScript clients, such control over
        pipelining is not possible in current browsers.  Therefore,
        JavaScript implementations of Bayeux attempt to meet this
        requirement by limiting themselves to a maximum of two
        outstanding HTTP requests at any one time, so that browser
        connection limits will not be applied and the requests will
        not be queued or pipelined.  While broadly effective, this
        mechanism can be disrupted if non-Bayeux JavaScript clients simultaneously issue requests to the same host.</t>
        <t>Bayeux connections are negotiated between client and server with handshake messages that allow the connection type, authentication method, and other parameters to be agreed upon between the client and the server.  Furthermore, during the handshake phase, the client and the server reveal to each other their acceptable bidirectional techniques, and the client selects one from the intersection of those sets.</t>
        <t>For non-browser or same-domain Bayeux, clients use HTTP POST requests to the server for both the long poll request and the request to send messages to the server.  The Bayeux protocol packets are sent as the body of the HTTP messages using the "application/json" Internet media type <xref target="RFC4627"/>.</t>
        <t>For browsers that are operating in cross-domain mode, Bayeux attempts to use Cross-Origin Resource Sharing <xref target="CORS"/> checking if the browser and server support it, so that normal HTTP POST requests can be used.  If this mechanism fails, Bayeux clients use the "JSONP" mechanism as described in <xref target="JSONP"/>.  In this last case, client-to-server messages are sent as encoded JSON on the URL query parameters, and server-to-client messages are sent as a JavaScript program that wraps the message JSON with a JavaScript function call to the already loaded Bayeux implementation.</t>
      </section>

      <section anchor="bosh" title="BOSH" toc="bosh">
         <t>BOSH, which stands for Bidirectional-streams Over Synchronous HTTP <xref target="BOSH"/>, was developed by the XMPP Standards Foundation in 2003-2004.  The purpose of BOSH is to emulate normal TCP connections over HTTP (TCP is the standard connection mechanism used in the Extensible Messaging and Presence Protocol as described in <xref target="RFC6120"/>).  BOSH employs the HTTP long polling mechanism by allowing the server (called a "BOSH connection manager") to defer its response to a request until it actually has data to send to the client from the application server itself (typically an XMPP server).  As soon as the client receives a response from the connection manager, it sends another request to the connection manager, thereby ensuring that the connection manager is (almost) always holding a request that it can use to "push" data to the client.</t>
         <t>In some situations, the client needs to send data to the
         server while it is waiting for data to be pushed from the
         connection manager.  To prevent data from being pipelined
         behind the long poll request that is on hold, the client can
         send its outbound data in a second HTTP request over a second
         TCP connection.  BOSH forces the server to respond to the
         request it has been holding on the first connection as soon
         as it receives a new request from the client, even if it has
         no data to send to the client.  It does so to make sure that
         the client can send more data immediately, if necessary -- even
         in the case where the client is not able to pipeline the
         requests -- while simultaneously respecting the two-connection
         limit discussed in <xref target="connectionlimit"/>.</t>

         <t>The number of long poll request-response pairs is negotiated during the first request sent from the client to the connection manager.  Typically, BOSH clients and connection managers will negotiate the use of two pairs, although it is possible to use only one pair or more than two pairs.</t>
         <t>The roles of the two request-response pairs typically switch whenever the client sends data to the connection manager.  This means that when the client issues a new request, the connection manager immediately answers the blocked request on the other TCP connection, thus freeing it; in this way, in a scenario where only the client sends data, the even requests are sent over one connection, and the odd ones are sent over the other connection.</t>
         <t>BOSH is able to work reliably both when network conditions
         force every HTTP request to be made over a different TCP
         connection and when it is possible to use HTTP/1.1 and then
         rely on two persistent TCP connections.</t>

         <t>If the connection manager has no data to send to the client for an agreed amount of time (also negotiated during the first request), then the connection manager will respond to the request it has been holding with no data, and that response immediately triggers a fresh client request.  The connection manager does so to ensure that if a network connection is broken then both parties will realize that fact within a reasonable amount of time.</t>
        <t>Moreover, BOSH defines the negotiation of an "inactivity period" value that specifies the longest allowable inactivity period (in seconds).  This enables the client to ensure that the periods with no requests pending are never too long.</t>
        <t>BOSH allows data to be pushed immediately when HTTP pipelining is available.  However, if HTTP pipelining is not available and one of the endpoints has just pushed some data, BOSH will usually need to wait for a network round-trip time until the server is able to again push data to the client.</t>
        <t>BOSH uses standard HTTP POST request and response bodies to encode all information.</t>
        <t>BOSH normally uses HTTP pipelining over a persistent
        HTTP/1.1 connection.  However, a client can deliver its POST
        requests in any way permitted by HTTP 1.0 or HTTP 1.1.
        (Although the use of HTTP POST with pipelining is discouraged
        in RFC 2616, BOSH employs various methods, such as request identifiers, to ensure that this usage does not lead to indeterminate results if the transport connection is terminated prematurely.)</t>
        <t>BOSH clients and connection managers are not allowed to use Chunked Transfer Coding, since intermediaries might buffer each partial HTTP request or response and only forward the full request or response once it is available.</t>
        <t>BOSH allows the usage of the Accept-Encoding and Content-Encoding headers in the request and in the response, respectively, and then compresses the response body accordingly.</t>
        <t>Each BOSH session can share the HTTP connection(s) it uses with other HTTP traffic, including other BOSH sessions and HTTP requests and responses completely unrelated to the BOSH protocol (e.g., Web page downloads).</t>
      </section>

      <section anchor="server-sent-events" title="Server-Sent Events">
        <t>W3C Server-Sent Events specification <xref target="WD-eventsource"></xref> defines an API that enables servers to push data to Web pages over HTTP in the form of DOM events.</t> 
        <t>The data is encoded as "text/event-stream" content and pushed
        using an HTTP streaming mechanism, but the specification
        suggests disabling HTTP chunking for serving event streams
        unless the rate of messages is high enough to avoid the
        possible negative effects of this technique as described in <xref target="streaming-issues"/>.</t>
        <t>However, it is not clear if there are significant benefits to using EOF rather than chunking with regards to intermediaries, unless they support only HTTP/1.0.</t>
      </section>

    </section>

    <section anchor="practices" title="HTTP Best Practices">
      <section anchor="connectionlimit" title="Limits to the Maximum Number of Connections">
        <t>HTTP <xref target="RFC2616"/>, Section 8.1.4, recommends
        that a single user client not maintain more than two
        connections to any server or proxy, in order to prevent the
        server from being overloaded and to avoid unexpected side
        effects in congested networks.  Until recently, this limit was
implemented by most commonly deployed browsers, thus making connections a
scarce resource that needed to be shared within the browser.  Note that the
available JavaScript APIs in the browsers hide the connections, and the
security model inhibits the sharing of any resource between frames.  The new
HTTP specification <xref target="HTTPBIS"/> removes the two-connection
limitation, only encouraging clients to be conservative when opening multiple
connections.  In fact, recent browsers have increased this limit to 6 or 8 connections; however, it is still not possible to discover the local limit, and usage of multiple frames and tabs still places 8 connections within easy reach.</t> 
        <t>Web applications need to limit the number of long poll requests initiated, ideally to a single long poll that is shared between frames, tabs, or windows of the same browser.  However, the security constraints of the browsers make such sharing difficult.</t>
        <t>A best practice for a server is to use cookies <xref target="COOKIE"/> to detect multiple long poll requests from the same browser and to avoid deferring both requests since this might cause connection starvation and/or pipeline issues.</t>
      </section>

      <section anchor="pipelining" title="Pipelined Connections">
        <t>HTTP <xref target="RFC2616"/> permits optional request pipelining over persistent connections.  Multiple requests can be enqueued before the responses arrive.</t>
        <t>In the case of HTTP long polling, the use of HTTP pipelining can reduce latency when multiple messages need to be sent by a server to a client in a short period of time.  With HTTP pipelining, the server can receive and enqueue a set of HTTP requests.  Therefore, the server does not need to receive a new HTTP request from the client after it has sent a message to the client within an HTTP response.  In principle, the HTTP pipelining can be applied to HTTP GET and HTTP POST requests, but using HTTP POST requests is more critical.  In fact, the use of HTTP POST with pipelining is discouraged in RFC 2616 and needs to be handled with special care.</t>
        <t>There is an issue regarding the inability to control pipelining.  Normal requests can be pipelined behind a long poll, and are thus delayed until the long poll completes.</t>
        <t>Mechanisms for bidirectional HTTP that want to exploit HTTP
        pipelining need to verify that HTTP pipelining is available
        (e.g., supported by the client, the intermediaries, and the
        server); if it's not available, they need to fall back to solutions without HTTP pipelining.</t>
      </section>

      <section anchor="proxies" title="Proxies">
        <t>Most proxies work well with HTTP long polling because a
        complete HTTP response will be sent either on an event or a
        timeout.  Proxies are advised to return that response
        immediately to the user agent, which immediately acts on it.</t>
        <t>The HTTP streaming mechanism uses partial responses and
        sends some JavaScript in an HTTP/1.1 chunk as described in
        <xref target="streaming"/>.  This mechanism can face problems
        caused by two factors: (1) it relies on proxies to forward
        each chunk (even though there is no requirement for them to do
        so, and some caching proxies do not), and (2) it relies on
        user agents to execute the chunk of JavaScript as it arrives (even though there is also no requirement for them to do so).</t>
        <t>A "reverse proxy" basically is a proxy that pretends to be the actual server (as far as any client or client proxy is concerned), but it passes on the request to the actual server that is usually sitting behind another layer of firewalls.  Any HTTP short polling or HTTP long polling solution will work fine with this, as will most HTTP streaming solutions.  The main downside is performance, since most proxies are not designed to hold many open connections.</t>
        <t>Reverse proxies can come to grief when they try to share
 connections to the servers between multiple clients. 
 As an example, Apache with mod_jk shares a small set of connections (often 8 or 16) between all clients.  If long polls are sent on those shared connections, then the proxy can be starved of connections, which means that other requests (either long poll or normal) can be held up.  Thus, Comet mechanisms currently need to avoid any connection sharing -- either in the browser or in any intermediary -- because the HTTP assumption is that each request will complete as fast as possible.</t>
        <t>One of the main reasons why both HTTP long polling and HTTP
 streaming are perceived as having a negative impact on servers and
 proxies is that they use a synchronous programming model for handling
 requests, since the resources allocated to each request are held for
 the duration of the request.   Asynchronous proxies and servers can handle long polls
using slightly more resources than normal HTTP traffic.

 Unfortunately some synchronous proxies do exist (e.g., Apache mod_jk) and many HTTP application servers also have a blocking model for their request handling (e.g., the Java servlet 2.5 specification).</t>
      </section>

      <section anchor="responses" title="HTTP Responses">
        <t>In accordance with <xref target='RFC2616'/>, the server responds to a request it has successfully received by sending a 200 OK answer, but only when a particular event, status, or timeout has occurred.  The 200 OK body section contains the actual event, status, or timeout that occurred.  This "best practice" is simply standard HTTP.</t>
      </section>

      <section anchor="timeouts" title="Timeouts">
        <t>The HTTP long polling mechanism allows the server to respond to a request only when a particular event, status, or timeout has occurred.  In order to minimize (as much as possible) both latency in server-client message delivery and the processing/network resources needed, the long poll request timeout ought to be set to a high value.</t>
        <t>However, the timeout value has to be chosen carefully;
        indeed, problems can occur if this value is set too high
        (e.g., the client might receive a 408 Request Timeout answer
        from the server or a 504 Gateway Timeout answer from a proxy).
        The default timeout value in a browser is 300 seconds, but
        most network infrastructures include proxies and servers whose
        timeouts are not that long.</t>
        <t>Several experiments have shown success with timeouts as high as 120 seconds, but generally 30 seconds is a safer value.  Therefore, vendors of network equipment wishing to be compatible with the HTTP long polling mechanism are advised to implement a timeout substantially greater than 30 seconds (where "substantially" means several times more than the medium network transit time).</t>
      </section>
      <section anchor="network" title="Impact on Intermediary Entities">
        <t>There is no way for an end client or host to signal to HTTP
        intermediaries that long polling is in use; therefore, long
        poll requests are completely transparent for intermediary
        entities and are handled as normal requests.  This can have an
        impact on intermediary entities that perform operations that
        are not useful in case of long polling.  However, any capabilities that might interfere with bidirectional flow (e.g., caching) can be controlled with standard headers or cookies.</t>
        <t>As a best practice, caching is always intentionally suppressed in a long poll request or response, i.e., the "Cache-Control" header is set to "no-cache".</t>
      </section>
    </section>

    <section title="Security Considerations" anchor="security">
      <t>This document is meant to describe current usage of HTTP to enable asynchronous or server-initiated communication.  It does not propose any change to the HTTP protocol or to the expected behavior of HTTP entities.  Therefore this document does not introduce new security concerns into existing HTTP infrastructure.  The considerations reported hereafter refer to the solutions that are already implemented and deployed.</t>
      <t>One security concern with cross-domain HTTP long polling is related to the fact that often the mechanism is implemented by executing the JavaScript returned from the long poll request.  If the server is prone to injection attacks, then it could be far easier to trick a browser into executing the code <xref target="CORS"/>.</t>
      <t>Another security concern is that the number of open
      connections that needs to be maintained by a server in HTTP long
      polling and HTTP streaming could more easily lead to
      denial-of-service (DoS) attacks <xref target="RFC4732"/>.</t>
    </section>

  </middle>

  <back>

    <references title="Normative References">

<reference anchor='RFC1945'>
<front>
<title abbrev='HTTP/1.0'>Hypertext Transfer Protocol -- HTTP/1.0</title>
<author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
<organization>MIT, Laboratory for Computer Science</organization>
<address>
<postal>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code>
<country>US</country></postal>
<facsimile>+1 617 258 8682</facsimile>
<email>timbl@w3.org</email></address></author>
<author initials='R.T.' surname='Fielding' fullname='Roy T.  Fielding'>
<organization>University of California, Irvine, Department of Information and Computer Science</organization>
<address>
<postal>
<street />
<city>Irvine</city>
<region>CA</region>
<code>92717-3425</code>
<country>US</country></postal>
<facsimile>+1 714 824 4056</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials='H.F.' surname='Nielsen' fullname='Henrik Frystyk Nielsen'>
<organization>W3 Consortium, MIT Laboratory for Computer Science</organization>
<address>
<postal>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code>
<country>US</country></postal>
<facsimile>+1 617 258 8682</facsimile>
<email>frystyk@w3.org</email></address></author>
<date year='1996' month='May' />
<abstract>
<t>The Hypertext Transfer Protocol (HTTP) is an application-level protocol with the lightness and speed necessary for distributed, collaborative, hypermedia information systems.  It is a generic, stateless, object-oriented protocol which can be used for many tasks, such as name servers and distributed object management systems, through extension of its request methods (commands).  A feature of HTTP is the typing of data representation, allowing systems to be built independently of the data being transferred.</t>
<t>HTTP has been in use by the World-Wide Web global information initiative since 1990.  This specification reflects common usage of the protocol referred to as "HTTP/1.0".</t></abstract></front>
<seriesInfo name='RFC' value='1945' />
<format type='TXT' octets='137582' target='http://www.rfc-editor.org/rfc/rfc1945.txt' />
</reference>

<reference anchor='RFC2616'>
<front>
<title abbrev='HTTP/1.1'>Hypertext Transfer Protocol -- HTTP/1.1</title>
<author initials='R.' surname='Fielding' fullname='Roy T.  Fielding'>
<organization abbrev='UC Irvine'>Department of Information and Computer Science</organization>
<address>
<postal>
<street>University of California, Irvine</street>
<city>Irvine</city>
<region>CA</region>
<code>92697-3425</code></postal>
<facsimile>+1(949)824-1715</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials='J.' surname='Gettys' fullname='James Gettys'>
<organization abbrev='Compaq/W3C'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>jg@w3.org</email></address></author>
<author initials='J.' surname='Mogul' fullname='Jeffrey C.  Mogul'>
<organization abbrev='Compaq'>Compaq Computer Corporation</organization>
<address>
<postal>
<street>Western Research Laboratory</street>
<street>250 University Avenue</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94305</code></postal>
<email>mogul@wrl.dec.com</email></address></author>
<author initials='H.' surname='Frystyk' fullname='Henrik Frystyk Nielsen'>
<organization abbrev='W3C/MIT'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>frystyk@w3.org</email></address></author>
<author initials='L.' surname='Masinter' fullname='Larry Masinter'>
<organization abbrev='Xerox'>Xerox Corporation</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>3333 Coyote Hill Road</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94034</code></postal>
<email>masinter@parc.xerox.com</email></address></author>
<author initials='P.' surname='Leach' fullname='Paul J.  Leach'>
<organization abbrev='Microsoft'>Microsoft Corporation</organization>
<address>
<postal>
<street>1 Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code></postal>
<email>paulle@microsoft.com</email></address></author>
<author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
<organization abbrev='W3C/MIT'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>timbl@w3.org</email></address></author>
<date year='1999' month='June' />
<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems.  It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers .  A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.
</t>
<t>
   HTTP has been in use by the World-Wide Web global information
   initiative since 1990.  This specification defines the protocol
   referred to as "HTTP/1.1", and is an update to RFC 2068 .
</t></abstract></front>
<seriesInfo name='RFC' value='2616' />
<format type='TXT' octets='422317' target='http://www.rfc-editor.org/rfc/rfc2616.txt' />
<format type='PS' octets='5529857' target='http://www.rfc-editor.org/rfc/rfc2616.ps' />
<format type='PDF' octets='550558' target='http://www.rfc-editor.org/rfc/rfc2616.pdf' />
<format type='HTML' octets='636125' target='http://xml.resource.org/public/rfc/html/rfc2616.html' />
<format type='XML' octets='493420' target='http://xml.resource.org/public/rfc/xml/rfc2616.xml' />
</reference>

<reference anchor='RFC4732'>
<front>
<title>Internet Denial-of-Service Considerations</title>
<author initials='M.' surname='Handley' fullname='M.  Handley'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E.  Rescorla'>
<organization /></author>
<author>
<organization>IAB</organization></author>
<date year='2006' month='December' />
<abstract>
<t>This document provides an overview of possible avenues for denial-of-service (DoS) attack on Internet systems.  The aim is to encourage protocol designers and network engineers towards designs that are more robust.  We discuss partial solutions that reduce the effectiveness of attacks, and how some solutions might inadvertently open up alternative vulnerabilities.  This memo provides information for the Internet community.</t></abstract></front>
<seriesInfo name='RFC' value='4732' />
<format type='TXT' octets='91844' target='http://www.rfc-editor.org/rfc/rfc4732.txt' />
</reference>

    </references>

    <references title="Informative References">

<reference anchor="BAYEUX"
            target="http://svn.cometd.com/trunk/bayeux/bayeux.html">
  <front>
    <title>Bayeux Protocol -- Bayeux 1.0.0</title>
    <author initials="A." surname="Russell" fullname="Alex Russel">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="G." surname="Wilkins" fullname="Greg Wilins">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="D." surname="Davis" fullname="David Davis">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
   <author initials="M." surname="Nesbitt" fullname="Mark Nesbitt">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <date day="" month="" year="2007"/>
  </front>
  <format type="HTML" target="http://svn.cometd.com/trunk/bayeux/bayeux.html"/>
</reference>

<reference anchor="BOSH">
  <front>
    <title>Bidirectional-streams Over Synchronous HTTP (BOSH)</title>

    <author initials="I." surname="Paterson" fullname="Ian Paterson">
      <organization/>
      <address>
        <email>ian.paterson@clientside.co.uk</email>
      </address>
    </author>
    <author initials="D." surname="Smith" fullname="Dave Smith">
      <organization/>
      <address>
        <email>dizzyd@jabber.org</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="21" month="February" year="2007"/>
  </front>
  <seriesInfo name="XSF XEP" value="0124"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0124.html"/>
</reference>

<reference anchor="COMET" target="http://infrequently.org/2006/03/comet-low-latency-data-for-the-browser/ ">
  <front>
    <title>Comet: Low Latency Data for the Browser</title>
    <author initials="A." surname="Russell" fullname="Alex Russell">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <date day="3" month="March" year="2006"/>
  </front>
  <format type="HTML" target="http://infrequently.org/2006/03/comet-low-latency-data-for-the-browser/"/>
</reference>

<reference anchor='COOKIE'>
<front>
<title>HTTP State Management Mechanism</title>
<author initials='A' surname='Barth' fullname='Adam Barth'>
    <organization />
</author>
<date month='March' year='2011' />

</front>
<seriesInfo name='Work in' value='Progress'/>

</reference>

<reference anchor='CORS' target='http://www.w3.org/TR/2010/WD-cors-20100727/'>
  <front>
    <title>Cross-Origin Resource Sharing</title>
    <author fullname='Anne van Kesteren' surname='van Kesteren' initials='A.'/>
    <date year='2010' month='July' day='27'/>
  </front>
  <seriesInfo name='W3C Working Draft' value='WD-cors-20100727'/>
<seriesInfo name='latest version available at'
value='&lt;http://www.w3.org/TR/cors/&gt;' />
</reference>

<reference anchor='HTTPBIS'>
<front>
<title>HTTP/1.1, part 1: URIs, Connections, and Message Parsing</title>
<author initials='R' surname='Fielding' fullname='Roy Fielding' role='editor'>
    <organization />
</author>
<author initials='J' surname='Gettys' fullname='Jim Gettys'>
    <organization />
</author>
<author initials='J' surname='Mogul' fullname='Jeffrey Mogul'>
    <organization />
</author>
<author initials='H' surname='Nielsen' fullname='Henrik Nielsen'>
    <organization />
</author>
<author initials='L' surname='Masinter' fullname='Larry Masinter'>
    <organization />
</author>
<author initials='P' surname='Leach' fullname='Paul Leach'>
    <organization />
</author>
<author initials='T' surname='Berners-Lee' fullname='Tim Berners-Lee'>
    <organization />
</author>
<author initials='Y' surname='Lafon' fullname='Yves Lafon' role='editor'>
    <organization />
</author>
<author initials='J' surname='Reschke' fullname='Julian Reschke' role='editor'>
    <organization />
</author>
<date month='March' year='2011' />

</front>
<seriesInfo name='Work in' value='Progress'/>
</reference>

<reference anchor='JSONP'
           target='http://en.wikipedia.org/wiki/JSONP#JSONP'>
  <front>
    <title>JSON with padding</title>
    <author><organization>Wikipedia</organization>
    </author>
  </front>
  <format type='HTML' target='http://en.wikipedia.org/wiki/JSONP#JSONP'/>
</reference>

<reference anchor='RFC4627'>
<front>
<title>The application/json Media Type for JavaScript Object Notation (JSON)</title>
<author initials='D.' surname='Crockford' fullname='D.  Crockford'>
<organization /></author>
<date year='2006' month='July' />
<abstract>
<t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.  This memo provides information for the Internet community.</t></abstract></front>
<seriesInfo name='RFC' value='4627' />
<format type='TXT' octets='16319' target='http://www.rfc-editor.org/rfc/rfc4627.txt' />
</reference>

<reference anchor='TCP'>
<front>
<title abbrev='Transmission Control Protocol'>Transmission Control Protocol</title>
<author initials='J.' surname='Postel' fullname='Jon Postel'>
<organization>University of Southern California (USC)/Information Sciences Institute</organization>
<address>
<postal>
<street>4676 Admiralty Way</street>
<city>Marina del Rey</city>
<region>CA</region>
<code>90291</code>
<country>US</country></postal></address></author>
<date year='1981' day='1' month='September' /></front>
<seriesInfo name='STD' value='7' />
<seriesInfo name='RFC' value='793' />
<format type='TXT' octets='172710' target='http://www.rfc-editor.org/rfc/rfc793.txt' />
</reference>

<!-- 3920bis is in AUTH48 as of 3/23/11  -->
<reference anchor="RFC6120">
<front>
<title>Extensible Messaging and Presence Protocol (XMPP): Core</title>
<author initials='P' surname='Saint-Andre' fullname='Peter Saint-Andre'>
    <organization />
</author>
<date month='March' year='2011' />

</front>
<seriesInfo name='RFC' value='6120'/>
</reference>

<reference anchor='WD-eventsource'
           target='http://www.w3.org/TR/2009/WD-eventsource-20091222/'>
  <front>
    <title>Server-Sent Events</title>
    <author fullname='Ian Hickson' surname='Hickson' initials='I.'/>
    <date year='2009' month='December' day='22'/>
  </front>
  <seriesInfo name='W3C Working Draft' value='WD-eventsource-20091222'/>
<seriesInfo name='latest version available at'
value='&lt;http://www.w3.org/TR/eventsource/&gt;' />
</reference> 

    </references>

    <section title="Acknowledgments">
      <t>Thanks to Joe Hildebrand, Julien Laganier, Jack Moffitt, Subramanian Moonesamy, Mark Nottingham, Julian Reschke, Martin Thomson, and Martin Tyler for their feedback.</t>
    </section>

  </back>
</rfc>
