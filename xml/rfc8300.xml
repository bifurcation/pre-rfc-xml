<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY RFC2119 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2629 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC3552 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC0768 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0768.xml">
<!ENTITY RFC0791 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0791.xml">
<!ENTITY RFC2784 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2784.xml">
<!ENTITY RFC6071 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6071.xml">
<!ENTITY RFC8126 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml">
<!ENTITY RFC7498 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7498.xml">
<!ENTITY RFC1191 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1191.xml">
<!ENTITY RFC6830 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6830.xml">
<!ENTITY RFC7665 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7665.xml">
<!ENTITY RFC1981 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1981.xml">
<!ENTITY RFC7325 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7325.xml">
<!ENTITY RFC2827 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2827.xml">
]>


<rfc submissionType="IETF" category="std" consensus="yes" ipr="trust200902" number="8300">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

  <front>

    <title>Network Service Header (NSH)</title>

       <author fullname="Paul Quinn" initials="P." surname="Quinn" role="editor">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <email>paulq@cisco.com</email>
      </address>
    </author>

      <author fullname="Uri Elzur" initials="U." surname="Elzur" role="editor">
      <organization>Intel</organization>
      <address>
        <email>uri.elzur@intel.com</email>
      </address>
    </author>

       <author fullname="Carlos Pignataro" initials="C." surname="Pignataro" role="editor">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <email>cpignata@cisco.com</email>
      </address>
    </author>



    <date month="January" year="2018"/>


   <area>Routing</area>

   <workgroup>Service Function Chaining</workgroup>



    <abstract>
     <t>

   This document describes a Network Service Header (NSH) imposed on
   packets or frames to realize Service Function Paths (SFPs).
   The NSH also provides a mechanism for metadata exchange along the
   instantiated service paths.  The NSH is the Service Function Chaining (SFC) encapsulation
   required to support the SFC architecture (defined in RFC 7665).

     </t>
    </abstract>



</front>


<middle>

    <section title="Introduction" toc="default">
    <t>
   Service Functions are widely deployed and essential in many networks.
   These Service Functions provide a range of features such as security,
   WAN acceleration, and server load balancing.  Service Functions may
   be instantiated at different points in the network infrastructure
   such as the WAN, data center, and so forth.
    </t>
    <t>
   Prior to development of the SFC architecture <xref target="RFC7665" /> and the protocol specified
   in this document, current Service Function deployment models have been relatively static
   and bound to topology for insertion and policy selection.
   Furthermore, they do not adapt well to elastic service environments
   enabled by virtualization.
    </t>
    <t>
   New data-center network and cloud architectures require more flexible
   Service Function deployment models.  Additionally, the transition to
   virtual platforms demands an agile service insertion model that
   supports dynamic and elastic service delivery. Specifically, the following
functions are necessary:
<list style="numbers"><t>The movement of Service Functions
   and application workloads in the network.
</t>
<t>The ability to easily
   bind service policy to granular information, such as per-subscriber
   state.
</t><t>The capability to steer traffic to the requisite Service Function(s).</t>
</list>
    </t>
    <t>

   This document, the Network Service Header (NSH) specification, defines a new data-plane
   protocol, which is an encapsulation for SFCs.

   The NSH is designed to encapsulate
   an original packet or frame and, in turn, be encapsulated by an outer transport
encapsulation (which is used to deliver the NSH
   to NSH-aware network elements),
   as shown in <xref target="encapsulation" />:</t>
    <t>
            <figure title="Network Service Header Encapsulation" anchor="encapsulation">
              <artwork align="center">
+------------------------------+
|    Transport Encapsulation   |
+------------------------------+
| Network Service Header (NSH) |
+------------------------------+
|    Original Packet / Frame   |
+------------------------------+
              </artwork>
          </figure>
    </t>
   <t>The NSH is composed of the following elements:</t>

    <t><list style="numbers">
        <t>
        Service Function Path identification.
        </t>
        <t>
        Indication of location within a Service Function Path.
        </t>
        <t>
        Optional, per-packet metadata (fixed-length or variable).
        </t>
        </list></t>

<t>
<xref target="RFC7665" /> provides an overview of a
   service chaining architecture that clearly defines the roles of the
   various elements and the scope of a SFC
   encapsulation. Figure 3 of <xref target="RFC7665" /> depicts the SFC architectural components after classification. The NSH is the SFC encapsulation referenced in <xref target="RFC7665" />.
</t>

<section title="Applicability">


<t>
The NSH is designed to be easy to implement across a range of devices,
   both physical and virtual, including hardware platforms.
</t><t>
The intended scope of the NSH is for use within a single provider's operational domain.
This deployment scope is deliberately constrained, as explained also in <xref target="RFC7665" />,
and limited to a single network administrative domain.
In this context, a "domain" is a set of network entities within a single administration.
For example, a network administrative domain can include a single data center,
or an overlay domain using virtual connections and tunnels.
A corollary is that a network administrative domain has a well-defined perimeter.
</t><t>
   An NSH-aware control plane is outside the scope of this document.
     </t>

</section>

<section title="Requirements Language">

<t>
    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
    "MAY", and "OPTIONAL" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>

</section>

    <section title="Definition of Terms" anchor="terms">



   <t><list style="hanging">
        <t hangText="Byte:">
           All references to "bytes" in this document refer to
           8-bit bytes, or octets.

        </t>

        <t hangText="Classification:">
            Defined in <xref target="RFC7665"></xref>.
        </t>

        <t hangText="Classifier:">
            Defined in <xref target="RFC7665"></xref>.
            </t>

    <t hangText="Metadata (MD):">
            Defined in <xref target="RFC7665"></xref>.
The metadata, or context information shared between Classifiers and SFs, and among SFs,
is carried on the NSH's Context Headers. It allows summarizing a classification result
in the packet itself, avoiding subsequent re-classifications.  Examples of metadata include classification information used for
       policy enforcement and network context for forwarding after
       service delivery.
            </t>

    <t hangText="Network Locator:">
        Data-plane address, typically IPv4 or IPv6, used to send and receive network traffic.
        </t>

         <t hangText="Network Node/Element:">
            Device that forwards packets or frames based on an outer header (i.e., transport encapsulation) information.
        </t>

        <t hangText="Network Overlay:">
           Logical network built on top of an existing network
      (the underlay).  Packets are encapsulated or tunneled to create
      the overlay network topology.

        </t>


         <t hangText="NSH-aware:">
NSH-aware means
SFC-encapsulation-aware, where
the NSH provides the SFC encapsulation.  This specification uses NSH-aware as a more specific
term from the more generic term "SFC-aware" <xref target="RFC7665" />.
        </t>


    <t hangText="Service Classifier:">
           Logical entity providing classification function.  Since they are logical,
        Classifiers may be co-resident with SFC elements such as SFs or SFFs.  Service Classifiers perform
        classification and
      impose the NSH. The initial Classifier imposes the initial NSH and sends the NSH
      packet to the first SFF in the path.  Non-initial (i.e.,
      subsequent) classification can occur as needed and can alter, or
      create a new service path.
       </t>

         <t hangText="Service Function (SF):">
                    Defined in <xref target="RFC7665"></xref>.
        </t>


        <t hangText="Service Function Chain (SFC):">
                    Defined in <xref target="RFC7665"></xref>.
        </t>


        <t hangText="Service Function Forwarder (SFF):">
                    Defined in <xref target="RFC7665"></xref>.
        </t>

        <t hangText="Service Function Path (SFP):">
                    Defined in <xref target="RFC7665"></xref>.

        </t>

        <t hangText="Service Plane:">
                    The collection of SFFs and associated SFs creates a service-plane
   overlay in which all SFs and SFC Proxies reside <xref target="RFC7665"></xref>.
        </t>


        <t hangText="SFC Proxy:">
               Defined in <xref target="RFC7665"></xref>.
        </t>


    </list></t>
    </section>


     <section title="Problem Space" anchor="problem">
      <t>
         The NSH addresses several limitations associated
   with Service Function deployments.  <xref target="RFC7498"></xref> provides
a comprehensive review of those issues.

      </t>

  </section>


    <section title="NSH-Based Service Chaining">
    <t>
          The NSH creates a dedicated service plane; more specifically, the NSH
   enables:

    </t>
    <t><list style="numbers">
    <t>
    Topological Independence: Service forwarding occurs within the
       service plane, so the underlying network
       topology does not require modification.  The NSH provides an
       identifier used to select the network overlay for network forwarding.
    </t>

    <t>
    Service Chaining: The NSH enables service chaining per <xref target="RFC7665" />. The NSH contains path identification information
       needed to realize a service path.  Furthermore, the NSH provides the
       ability to monitor and troubleshoot a service chain, end-to-end
       via service-specific Operations, Administration, and Maintenance (OAM) messages. The NSH fields can be used by administrators (for example, via a
  traffic analyzer) to verify the path specifics (e.g., accounting, ensuring correct chaining, providing reports, etc.) of packets
  being forwarded along a service path.


    </t>

    <t>
    The NSH provides a mechanism to carry shared
       metadata between participating entities and Service Functions.
       The semantics of the shared metadata are communicated via a control plane (which
       is outside the scope of this document) to participating nodes.  Section 3.3 of <xref target="SFC-CONTROL-PLANE"></xref> provides an example of this.
       Examples of metadata include classification information used for
       policy enforcement and network context for forwarding post
       service delivery.  Sharing the metadata allows Service Functions
    to share initial and intermediate classification results with downstream Service
    Functions saving re-classification, where enough information was enclosed.
    </t>

    <t>
    The NSH offers a common and standards-based header for service chaining to all network and service nodes.
    </t>

    <t>
    Transport Encapsulation Agnostic: The NSH is transport encapsulation independent:
meaning it can be transported
       by a variety of encapsulation protocols. An appropriate (for a given deployment)
    encapsulation protocol can be used to carry NSH-encapsulated traffic.
    This transport encapsulation may form an
       overlay network; and if an existing overlay
       topology provides the required service path connectivity, that
       existing overlay may be used.
    </t>


    </list></t>

    </section>
</section>



 <section title="Network Service Header" anchor="NSH">


      <t>
An NSH is imposed on the original packet/frame.  This NSH contains
service path information and, optionally, metadata that are added to a
packet or frame and used to create a service plane. Subsequently, an
outer transport encapsulation is imposed on the NSH, which is used for
network forwarding.
     </t>

    <t>
       A Service Classifier adds the NSH.  The NSH is removed by
   the last SFF in the service chain or by an SF that consumes the packet.

    </t>

 <section title="Network Service Header Format" anchor="nshformat">

    <t>
       The NSH is composed of a 4-byte
       Base Header, a 4-byte Service Path
   Header, and optional Context Headers, as shown in <xref target="stack" />.


    </t>
            <figure title="Network Service Header" anchor="stack">
              <artwork align="center">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Base Header                                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Service Path Header                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
~                Context Header(s)                              ~
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              </artwork>       
   </figure>
<t>
<list style="hanging">

    <t hangText="Base Header:">Provides information about the service header and the payload protocol.
    </t>
    <t hangText="Service Path Header:">Provides path identification and location within a service path.
    </t>
    <t hangText="Context Header:">Carries metadata (i.e., context data) along a service path.
    </t>
</list>
</t>
</section>


<section title="NSH Base Header" anchor="base">

<t>
<xref target="baseheader" /> depicts the NSH Base Header:
</t>

            <figure title="NSH Base Header" anchor="baseheader">
              <artwork align="center">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              </artwork>
          </figure>

    <t>
    The field descriptions are as follows:
    </t>

<t><list style="hanging">
    <t hangText="Version:">
    The Version field is used to ensure backward
    compatibility going forward with future NSH specification
    updates. It MUST be set to 0x0 by the sender, in this first
    revision of the NSH.  If a packet presumed to carry an NSH header
    is received at an SFF, and the SFF does not understand the version
    of the protocol as indicated in the base header, the packet MUST
    be discarded, and the event SHOULD be logged.  Given the
    widespread implementation of existing hardware that uses the first
    nibble after an MPLS label stack for Equal-Cost Multipath (ECMP)
    decision processing, this document reserves version 01b. This
    value MUST NOT be used in future versions of the protocol.  Please
    see <xref target="RFC7325"></xref> for further discussion of
    MPLS-related forwarding requirements.

    </t>


    <t hangText="O bit:">
  Setting this bit indicates an OAM packet (see <xref
  target="RFC6291" />). The actual format and processing of SFC OAM
  packets is outside the scope of this specification (for example, see
  <xref target="SFC-OAM-FRAMEWORK"></xref> for one approach).
            <vspace blankLines="1" />
  The O bit MUST be set for OAM packets and MUST NOT be set for non-OAM
   packets. The O bit MUST NOT be modified along the SFP.
            <vspace blankLines="1" />
  SF/SFF/SFC Proxy/Classifier implementations that do not support SFC
   OAM procedures SHOULD discard packets with O bit set, but MAY
   support a configurable parameter to enable forwarding received SFC
   OAM packets unmodified to the next element in the chain. Forwarding OAM
   packets unmodified by SFC elements that do not support SFC OAM procedures
   may be acceptable for a subset of OAM functions, but it can result in
   unexpected outcomes for others; thus, it is recommended to analyze the
   impact of forwarding an OAM packet for all OAM functions prior to enabling
   this behavior. The configurable parameter MUST be disabled by default.
    </t>
    <t hangText="TTL:">
Indicates the maximum SFF hops for an SFP. This field is used for
service-plane loop detection. The initial TTL value SHOULD be
configurable via the control plane; the configured initial value can
be specific to one or more SFPs. If no initial value is explicitly
provided, the default initial TTL value of 63 MUST be used. Each SFF
involved in forwarding an NSH packet MUST decrement the TTL value by 1
prior to NSH forwarding lookup. Decrementing by 1 from an incoming
value of 0 shall result in a TTL value of 63. The packet MUST NOT be
forwarded if TTL is, after decrement, 0.
            <vspace blankLines="1" />
     This TTL field is the primary loop-prevention mechanism. This TTL mechanism
     represents a robust complement to the Service Index
     (see <xref target="sph" />),
     as the TTL is
     decremented by each SFF.   The handling of an incoming 0 TTL allows for
     better, although not perfect, interoperation with pre-standard
     implementations that do not support this TTL field.

</t>

    <t hangText="Length:">
     The total length, in 4-byte words, of the NSH including the
   Base Header, the Service Path Header, the Fixed-Length Context Header,
   or Variable-Length Context Header(s). The length MUST
   be 0x6 for MD Type 0x1, and it MUST be 0x2 or
   greater for MD Type 0x2.  The length of the Network Service Header MUST
   be an integer multiple of 4 bytes; thus, variable-length metadata is
   always padded out to a multiple of 4 bytes.
</t>


    <t hangText="Unassigned bits:">
All other flag fields, marked U, are unassigned and available for future use; see <xref target="bbits" />. Unassigned bits
   MUST be set to zero upon origination, and they MUST be ignored and preserved
   unmodified by other NSH supporting elements.  At reception, all elements MUST NOT modify their
actions based on these unknown bits.

    </t>

<t hangText="Metadata (MD) Type:">
    Indicates the format of the NSH beyond the mandatory NSH Base Header and the Service Path Header. MD Type defines the
   format of the metadata being carried.  Please see the IANA Considerations in <xref target="mdt" />.

            <vspace blankLines="1" />
             This document specifies the following four MD Type values:
                     <list style="hanging" hangIndent="6">
    <t hangText="0x0:">This is a reserved value. Implementations SHOULD silently discard packets with MD Type 0x0.</t>
                  
    <t hangText="0x1:">This indicates that the format of the header
    includes a Fixed-Length Context Header (see <xref target="t1c" />
    below).</t>

            
    <t hangText="0x2:">This does not mandate any headers beyond the
    Base Header and Service Path Header, but may contain optional
    Variable-Length Context Header(s).  With MD Type 0x2, a length of
    0x2 implies there are no Context Headers.  The semantics of the
    Variable-Length Context Header(s) are not defined in this
    document.

The format of the optional Variable-Length Context Headers is provided
in <xref target="tlvagain" />.</t>

           
    <t hangText="0xF:">This value is reserved for experimentation and
    testing, as per <xref target="RFC3692" />. Implementations not
    explicitly configured to be part of an experiment SHOULD silently
    discard packets with MD Type 0xF.</t></list>
      
    The format of the Base Header and the Service Path Header is
    invariant and not affected by MD Type.

    <vspace blankLines="1" />
The NSH MD Type 1 and MD Type 2 are described in detail in Sections <xref target="t1" format="counter" />
and <xref target="t2" format="counter" />, respectively.
NSH implementations MUST support MD Types 0x1 and 0x2 (where the length
   is 0x2). NSH implementations SHOULD support MD Type 0x2 with length greater than 0x2.  

Devices that do not support MD Type 0x2 with a length greater than 
  0x2 MUST ignore any optional Context Headers and process the packet 
  without them; the Base Header Length field can be used to determine the 
  original payload offset if access to the original packet/frame is required. 


This specification does not disallow the MD Type value from changing
along an SFP; however, the specification of the necessary mechanism to
allow the MD Type to change along an SFP are outside the scope of this
document and would need to be defined for that functionality to be
available.  Packets with MD Type values not supported by an
implementation MUST be silently dropped.

    </t>

    <t hangText="Next Protocol:">
    Indicates the protocol type of the encapsulated
    data.  The NSH does not alter the inner payload, and the semantics
    on the inner protocol remain unchanged due to NSH SFC.  Please see the
    IANA Considerations in <xref target="bnp" />.

            <vspace blankLines="1" />
    This document defines the following Next Protocol values:
            <vspace blankLines="1" />
    0x1: IPv4
            <vspace blankLines="0" />
    0x2: IPv6
        <vspace blankLines="0" />

    0x3: Ethernet
        <vspace blankLines="0" />
    0x4: NSH
        <vspace blankLines="0" />
    0x5: MPLS
        <vspace blankLines="0" />
    0xFE: Experiment 1
        <vspace blankLines="0" />
    0xFF: Experiment 2
    </t>
    <t>
The functionality of hierarchical NSH using a Next Protocol value of
0x4 (NSH) is outside the scope of this specification.  Packets with
Next Protocol values not supported SHOULD be silently dropped by
default, although an implementation MAY provide a configuration
parameter to forward them.


Additionally, an implementation not explicitly configured for a
specific experiment <xref target="RFC3692" /> SHOULD silently drop
packets with Next Protocol values 0xFE and 0xFF.
    </t>
  </list></t>

</section>

    <section title="Service Path Header" anchor="sph">

<t>
<xref target="pathreader" /> shows the format of the Service Path Header:
</t>

            <figure title="NSH Service Path Header" anchor="pathreader">
              <artwork align="center">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Service Path Identifier (SPI)        | Service Index |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Service Path Identifier (SPI): 24 bits
Service Index (SI): 8 bits
              </artwork>
          </figure>

<t>
The meaning of these fields is as follows:
</t>


    <t>
    Service Path Identifier (SPI):  Uniquely identifies a Service Function Path (SFP).
 Participating nodes MUST use this identifier for SFP selection.  The initial Classifier MUST set the appropriate SPI
 for a given classification result.

    </t>

    <t>
Service Index (SI): Provides location within the SFP. The
initial Classifier for a given SFP SHOULD set the SI to 255; however, the
control plane MAY configure the initial value of the SI as appropriate
(i.e., taking into account the length of the SFP).
The Service Index MUST be decremented by a value of 1 by Service Functions or by SFC
   Proxy nodes after performing required services; the new
   decremented SI value MUST be used in the egress packet's NSH.

The initial Classifier
MUST send the packet to the first SFF in the identified SFP  for
forwarding along an SFP. If re-classification occurs, and that
re-classification results in a new SPI, the (re-)Classifier is, in
effect, the initial Classifier for the resultant SPI.
               <vspace blankLines="1" />
The SI is used in conjunction with the Service Path Identifier for
SFP selection and for determining the next SFF/SF in
the path. The SI is also valuable when troubleshooting or
reporting service paths.

     While the TTL provides the primary SFF-based loop prevention for
     this mechanism, SI decrement by SF serves as a limited loop-prevention mechanism.  NSH packets, as described above, are discarded
     when an SFF decrements the TTL to 0.  In addition, an SFF that is
     not the terminal SFF for an SFP will discard any
     NSH packet with an SI of 0, as there will be no valid next SF
     information.
    </t>

</section>

<section title="NSH MD Type 1" anchor="t1">

<t>
When the Base Header specifies MD Type 0x1, a Fixed-Length Context
Header (16-bytes) MUST be present immediately following the Service
Path Header, as per <xref target="t1c" />.  The value of a
Fixed-Length Context Header that carries no metadata MUST be set to
zero.
</t>




<figure title="NSH MD Type 0x1" anchor="t1c">
        <artwork align="center">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Service Path Identifier              | Service Index |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                 Fixed-Length Context Header                   |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </artwork>
    </figure>



<t>
This specification does not make any assumptions about the content of
 the 16-byte Context Header that must be present when the MD Type
 field is set to 1, and it does not describe the structure or meaning of
 the included metadata.
</t>
<t>
An SFC-aware SF or SFC Proxy needs to receive the data structure and
semantics first in order to process the data placed in the mandatory
context field. The data structure and semantics include both the
allocation schema and order as well as the meaning of the included data. How
an SFC-aware SF or SFC Proxy gets the data structure and semantics is
outside the scope of this specification.
</t>
<t>
An SF or SFC Proxy that does not know the format or semantics of the
 Context Header for an NSH with MD Type 1 MUST discard any packet with
 such an NSH (i.e., MUST NOT ignore the metadata that it cannot
 process), and MUST log the event at least once per the SPI for which
 the event occurs (subject to thresholding).
</t>
<t>
<xref target="NSH-DC-ALLOCATION"></xref> and <xref target="NSH-BROADBAND-ALLOCATION"></xref> provide specific
examples of how metadata can be allocated.
</t>

</section>

<section title="NSH MD Type 2" anchor="t2">

<t>
   When the Base Header specifies MD Type 0x2, zero or more
   Variable-Length Context Headers MAY be added, immediately following
   the Service Path Header (see <xref target="t2c" />). Therefore,
   Length = 0x2, indicates that only the Base Header and Service Path
   Header are present (and in that order). The optional
   Variable-Length Context Headers MUST be of an integer number of
   4-bytes.  The Base Header Length field MUST be used to determine
   the offset to locate the original packet or frame for SFC nodes
   that require access to that information.
</t>



    <figure title="NSH MD Type 0x2" anchor="t2c">
        <artwork align="center">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Service Path Identifier              | Service Index |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
~              Variable-Length Context Headers  (opt.)          ~
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </artwork>
    </figure>



<section title="Optional Variable-Length Metadata" anchor="tlvagain">
    <t>
        The format of the optional Variable-Length Context Headers, is
        as depicted in <xref target="vars" />.
      </t>


    <figure title="Variable-Length Context Headers" anchor="vars">
        <artwork align="center">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Metadata Class       |      Type     |U|    Length   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   Variable-Length Metadata                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </artwork>
    </figure>

<t>
<list style="hanging">
    <t hangText="Metadata Class (MD Class):">
    Defines the scope of the Type field to
    provide a hierarchical namespace.  <xref target="mdclass" /> defines how the
    MD Class values can be allocated to standards bodies, vendors, and others.

    </t>

    <t hangText="Type:">
    Indicates the explicit type of metadata being carried. The definition of the Type is the responsibility
    of the MD Class owner.

    </t>

    <t hangText="Unassigned bit:">
    One unassigned bit is available for future use.  This bit
    MUST NOT be set, and it MUST be ignored on receipt.
    </t>

    <t hangText="Length:">
    Indicates the length of the variable-length metadata, in bytes.
    In case the metadata length is not an integer number of 4-byte
    words, the sender MUST add pad bytes immediately following the
    last metadata byte to extend the metadata to an integer number of
    4-byte words.  The receiver MUST round the Length field up to the
    nearest 4-byte-word boundary, to locate and process the next field
    in the packet. The receiver MUST access only those bytes in the
    metadata indicated by the Length field (i.e., actual number of
    bytes) and MUST ignore the remaining bytes up to the nearest
    4-byte-word boundary. The length may be 0 or greater.
    <vspace blankLines="1" />
  A value of
0 denotes a Context Header without a  Variable-Length Metadata field.
    </t>
    </list>
    </t>
    <t>
This specification does not make any assumption about Context Headers
that are mandatory to implement or those that are mandatory to
process. These considerations are deployment specific. However, the
control plane is entitled to instruct SFC-aware SFs with the data
structure of the Context Header together with its scoping (see e.g.,
Section 3.3.3 of <xref target="SFC-CONTROL-PLANE"></xref>).
</t>
<t>
Upon receipt of a packet that belongs to a given SFP, if a
mandatory-to-process Context Header is missing in that packet, the
SFC-aware SF MUST NOT process the packet and MUST log an error at
least once per the SPI for which the mandatory metadata is missing.
</t>
<t>
If multiple mandatory-to-process Context Headers are required for a
given SFP, the control plane MAY instruct the SFC-aware SF with the
order to consume these Context Headers. If no instructions are
provided and the SFC-aware SF will make use of or modify the specific
Context Header, then the SFC-aware SF MUST process these Context
Headers in the order they appear in an NSH packet.
</t>
<t>
 If multiple instances of the same metadata are included in an NSH packet,
 but the definition of that Context Header does not allow for it, the SFC-aware
 SF MUST process the first instance and ignore subsequent instances.
The SFC-aware SF MAY log or increase a counter for this event.

</t>

  </section>
</section>


</section>



    <section title="NSH Actions" anchor="actions">
      <t>
NSH-aware nodes (which include Service Classifiers, SFFs, SFs, and SFC
Proxies) may alter the contents of the NSH headers. These nodes have
several possible NSH-related actions:

      </t>
     <t><list style="numbers">
     <t>Insert or remove the NSH: These actions can occur respectively
     at the start and end of a service path.  Packets are classified,
     and if determined to require servicing, an NSH will be imposed.  A
     Service Classifier MUST insert an NSH at the start of an SFP.  An
     imposed NSH MUST contain both a valid Base Header and Service
     Path Header. At the end of an SFP, an SFF MUST
     remove the NSH before forwarding or delivering the
     un-encapsulated packet. Therefore, it is the last node operating
     on the service header.


     <vspace blankLines="1" />
     Multiple logical Classifiers may exist within a given service
     path.  Non-initial Classifiers may re-classify data, and that
     re-classification MAY result in the selection of a different
     SFP.  When the logical Classifier performs
     re-classification that results in a change of service path, it
     MUST replace the existing NSH with a new NSH with the Base Header
     and Service Path Header reflecting the new service path
     information and MUST set the initial SI.  The O bit, the TTL field, and
unassigned flags MUST be copied transparently from the old NSH to a new NSH.

  Metadata MAY be preserved in the new NSH.
    <vspace blankLines="1" />

     </t>
    <t>Select service path: The Service Path Header provides service path
       information and is used by SFFs to determine correct service path
       selection.  SFFs MUST use the Service Path Header for selecting the next
       SF or SFF in the service path.
    </t>
    <t>Update the NSH: SFs MUST decrement the service index by one.
    If an SFF receives a packet with an SPI and SI that do not
    correspond to a valid next hop in a valid SFP,
    that packet MUST be dropped by the SFF.
    <vspace blankLines="1" />
Classifiers MAY update Context Headers if new/updated
       context is available.
    <vspace blankLines="1" />
     If an SFC proxy is in use (acting on behalf of an
      NSH-unaware Service Function for NSH actions), then the proxy
       MUST update the Service Index and MAY update contexts.  When an SFC
       Proxy receives an NSH-encapsulated packet, it MUST remove the NSH
       before forwarding it to an NSH-unaware SF.  When the SFC Proxy receives a
       packet back from an NSH-unaware SF, it MUST re-encapsulate it with the correct NSH,
       and it MUST decrement the Service Index by one.

    <vspace blankLines="1" />

    </t>
    <t>Service policy selection: Service Functions derive
       policy (i.e., service actions such as permit or deny) selection and enforcement from the NSH.
       Metadata shared in the NSH can provide a range of service-relevant
       information such as traffic classification.
    </t>
    </list></t>
    <t>
    <xref target="actionsandroles" /> maps each of the four actions above to the components in the SFC architecture that can perform it.
    </t>

                <figure title="NSH Action and Role Mapping" anchor="actionsandroles">
              <artwork align="center">
+-----------+-----------------------+-------+---------------+-------+
|           | Insert, remove, or    |Forward| Update        |Service|
|           | replace the NSH       |the NSH| the NSH       |policy |
|           |                       |packets|               |sel.   |
|Component  +-------+-------+-------+       +-------+-------+       |
|           |       |       |       |       |Dec.   |Update |       |
|           |Insert |Remove |Replace|       |Service|Context|       |
|           |       |       |       |       |Index  |Header |       |
+-----------+-------+-------+-------+-------+-------+-------+-------+
|           |  +    |       |   +   |       |       |   +   |       |
|Classifier |       |       |       |       |       |       |       |
+-----------+-------+-------+-------+-------+-------+-------+-------+
|Service    |       |   +   |       |   +   |       |       |       |
|Function   |       |       |       |       |       |       |       |
|Forwarder  |       |       |       |       |       |       |       |
|(SFF)      |       |       |       |       |       |       |       |
+-----------+-------+-------+-------+-------+-------+-------+-------+
|Service    |       |       |       |       |   +   |   +   |   +   |
|Function   |       |       |       |       |       |       |       |
|(SF)       |       |       |       |       |       |       |       |
+-----------+-------+-------+-------+-------+-------+-------+-------+
|           |  +    |   +   |       |       |   +   |   +   |       |
|SFC Proxy  |       |       |       |       |       |       |       |
+-----------+-------+-------+-------+-------+-------+-------+-------+
             </artwork>
          </figure>

</section>

<section title="NSH Transport Encapsulation" anchor="encap">

    <t>
       Once the NSH is added to a packet, an outer transport
       encapsulation is used to forward the original packet and the
       associated metadata to the start of a service chain.  The
       encapsulation serves two purposes:

    </t>
    <t><list style="numbers">
    <t>
    Creates a topologically independent services plane.  Packets are
       forwarded to the required services without changing the
       underlying network topology.

    </t>
    <t>
Transit network nodes simply forward the encapsulated packets without
modification.

    </t>
    </list></t>
    <t>
    The service header is independent of the transport encapsulation
    used.  Existing transport encapsulations can be used.  The
    presence of an NSH is indicated via a protocol type or another
    indicator in the outer transport encapsulation.

    </t>
</section>


<section title="Fragmentation Considerations">
<t>
The NSH and the associated transport encapsulation header are "added"
to the encapsulated packet/frame.  This additional information
increases the size of the packet.
</t>
<t>
Within a managed administrative domain, an operator can ensure that
the underlay MTU is sufficient to carry SFC traffic without requiring
fragmentation.  Given that the intended scope of the NSH is within a
single provider's operational domain, that approach is sufficient.
</t>
<t>
However, although explicitly outside the scope of this specification,
there might be cases where the underlay MTU is not large enough to
carry the NSH traffic.  Since the NSH does not provide fragmentation
support at the service plane, the transport encapsulation protocol
ought to provide the requisite fragmentation handling.  For instance,
Section 9 of <xref target="RTG-ENCAP"></xref> provides
exemplary approaches and guidance for those scenarios.
</t>

<t>
When the transport encapsulation protocol supports fragmentation, and fragmentation procedures needs to be used, such fragmentation is part of the transport encapsulation logic.  If, as it is common, fragmentation is performed by the endpoints of the transport encapsulation, then fragmentation procedures are performed at the sending NSH entity as part of the transport encapsulation, and reassembly procedures are performed at the receiving NSH entity during transport de-encapsulation handling logic.  In no case would such fragmentation result in duplication of the NSH header.
</t>

<t>
For example, when the NSH is encapsulated in IP, IP-level fragmentation coupled with
Path MTU Discovery (PMTUD) (e.g., <xref target="RFC8201" />) is used.
Since
   PMTUD relies on ICMP messages, an operator should ensure ICMP
   packets are not blocked.

When, on the other hand, the underlay does not support fragmentation procedures,
an error message SHOULD be logged when dropping a packet too big.
Lastly, NSH-specific fragmentation and reassembly methods
may be defined as well, but
these methods are outside the scope of this document and subject for future work.
</t>
</section>


<section title="Service Path Forwarding with NSH" anchor="fwding">


<section title="SFFs and Overlay Selection" anchor="overlay">
   <t>
     As described above, the NSH contains a Service Path Identifier
     (SPI) and a Service Index (SI).  The SPI is, as per its name, an
     identifier.  The SPI alone cannot be used to forward packets
     along a service path.  Rather, the SPI provides a level of
     indirection between the service path / topology and the network
     transport encapsulation.  Furthermore, there is no requirement for,
     or expectation of, an SPI being bound to a predetermined or
     static network path.
  </t>
  <t>
  The Service Index provides an indication of location within a
  service path.  The combination of SPI and SI provides the
  identification of a logical SF and its order within the service
  plane.  This combination is used to select the appropriate network
  locator(s) for overlay forwarding.  The logical SF may be a single
  SF or a set of eligible SFs that are equivalent.  In the latter
  case, the SFF provides load distribution amongst the collection of
  SFs as needed.
   </t>
   <t>
  SI serves as a mechanism for detecting invalid SFPs.
  In particular, an SI value of zero indicates that forwarding
  is incorrect and the packet must be discarded.
  </t>
  <t>
 This indirection -- SPI to overlay -- creates a true service plane.
 That is, the SFF/SF topology is constructed without impacting the
 network topology, but, more importantly, service-plane-only
 participants (i.e., most SFs) need not be part of the network overlay
 topology and its associated infrastructure (e.g., control plane,
 routing tables, etc.).  SFs need to be able to return a packet to an
 appropriate SFF (i.e., has the requisite NSH information) when
 service processing is complete.  This can be via the overlay or
 underlay and, in some cases, can require additional configuration on the
 SF.

   As mentioned above, an existing overlay
   topology may be used, provided it offers the requisite connectivity.

  </t>
 <t>
The mapping of SPI to transport encapsulation occurs on an SFF (as
discussed above, the first SFF in the path gets an NSH encapsulated
packet from the Classifier).  The SFF consults the SPI/ID values to
determine the appropriate overlay transport encapsulation protocol
(several may be used within a given network) and next hop for the
requisite SF.  <xref target="map1" /> depicts an example of a
single next-hop SPI/SI-to-network overlay network locator mapping.

</t>

<?rfc compact="no" ?>
 <texttable title="SFF NSH Mapping Example" anchor="map1">
          <ttcol align="left">SPI</ttcol>
          <ttcol align="left">SI</ttcol>
          <ttcol align="left">Next Hop(s)</ttcol>
          <ttcol align="left">Transport Encapsulation</ttcol>

<c>  10  </c><c> 255 </c><c>  192.0.2.1          </c><c>   VXLAN-gpe        </c>
<c>  10  </c><c> 254 </c><c>  198.51.100.10      </c><c>   GRE              </c>
<c>  10  </c><c> 251 </c><c>  198.51.100.15      </c><c>   GRE              </c>
<c>  40  </c><c> 251 </c><c>  198.51.100.15      </c><c>   GRE              </c>
<c>  50  </c><c> 200 </c><c>  01:23:45:67:89:ab  </c><c>   Ethernet         </c>
<c>  15  </c><c> 212 </c><c>  Null (end of path) </c><c>   None             </c>
</texttable>
<?rfc compact="yes" ?>

  <t>
    Additionally, further indirection is possible: the resolution of the
   required SF network locator may be a localized resolution on an
   SFF, rather than an SFC control plane
   responsibility, as per Tables
<xref target="map2"  format="counter"/> and <xref target="map3" format="counter"/>.

  </t>
    <t>
    Please note: VXLAN-gpe and GRE in the above table refer to <xref target="VXLAN-GPE"></xref>
 and <xref target="RFC2784"></xref> <xref target="RFC7676"></xref>, respectively.
    </t>

<?rfc compact="no" ?>
            <texttable title="NSH-to-SF Mapping Example" anchor="map2">
<ttcol> SPI </ttcol><ttcol>  SI </ttcol><ttcol>  Next Hop(s)   </ttcol>
 <c> 10  </c><c>  3  </c><c>      SF2       </c>
 <c> 245 </c><c>  12 </c><c>      SF34      </c>
 <c> 40  </c><c>  9  </c><c>      SF9       </c>
          </texttable>



            <texttable title="SF Locator Mapping Example" anchor="map3">
<ttcol>SF</ttcol><ttcol>Next Hop(s)</ttcol><ttcol>Transport Encapsulation</ttcol>
<c>  SF2 </c><c>  192.0.2.2        </c><c>  VXLAN-gpe  </c>
<c>  SF34</c><c>  198.51.100.34    </c><c>  UDP        </c>
<c>  SF9 </c><c>  2001:db8::1      </c><c>  GRE        </c>
          </texttable>
<?rfc compact="yes" ?>

<t>
   Since the SPI is a representation of the service path, the lookup
   may return more than one possible next hop within a service path
   for a given SF, essentially a series of weighted (equally or
   otherwise) paths to be used (for load distribution, redundancy, or
   policy); see <xref target="map4" />.  The metric depicted in <xref
   target="map4" /> is an example to help illustrate weighing SFs.


  In a real network, the metric will range
  from a simple preference (similar to routing next-hop) to a true
  dynamic composite metric based on the state of a Service Function
  (including load, session state, capacity, etc.).
</t>

<?rfc compact="no" ?>
            <texttable title="NSH Weighted Service Path" anchor="map4">
<ttcol> SPI </ttcol><ttcol> SI </ttcol><ttcol>   NH        </ttcol><ttcol>  Metric </ttcol>
   <c> 10  </c><c>  3 </c><c> 203.0.113.1 </c><c>  1      </c>
   <c>     </c><c>    </c><c> 203.0.113.2 </c><c>  1      </c>
   <c> 20  </c><c> 12 </c><c> 192.0.2.1   </c><c>  1      </c>
   <c>     </c><c>    </c><c> 203.0.113.4 </c><c>  1      </c>
   <c> 30  </c><c>  7 </c><c> 192.0.2.10  </c><c>  10     </c>
   <c>     </c><c>    </c><c> 198.51.100.1</c><c>  5      </c>
<postamble>(encapsulation type omitted for formatting)</postamble>
          </texttable>
<?rfc compact="yes" ?>

<t>
The information contained in Tables 1-4 may be received from the control plane, but the exact mechanism is outside the scope of this document.
</t>

</section>


<section title="Mapping the NSH to Network Topology">

<t>
As described above, the mapping of the SPI to network topology may
result in a single path, or it might result in a more complex
topology.  Furthermore, the SPI-to-overlay mapping occurs at each SFF
independently.  Any combination of topology selection is possible.
Please note, there is no requirement to create a new overlay topology
if a suitable one already exists.  NSH packets can use any (new or
existing) overlay, provided the requisite connectivity requirements are
satisfied.

</t>

<t>
Examples of mapping for a topology:
</t>

 <t><list style="numbers">
 <t>
Next SF is located at SFFb with locator 2001:db8::1
<vspace blankLines="0" />
SFFa mapping: SPI=10 --> VXLAN-gpe, dst-ip: 2001:db8::1
  </t>
  <t>
Next SF is located at SFFc with multiple network locators for load-distribution purposes:
<vspace blankLines="0" />
SFFb mapping: SPI=10 --> VXLAN-gpe, dst_ip:203.0.113.1, 203.0.113.2, 203.0.113.3, equal cost
  </t>
  <t>
Next SF is located at SFFd with two paths from SFFc, one for
       redundancy:
<vspace blankLines="0" />
SFFc mapping: SPI=10 --> VXLAN-gpe, dst_ip:192.0.2.10 cost=10,
       203.0.113.10, cost=20
  </t>
</list></t>

<t>
   In the above example, each SFF makes an independent decision about
   the network overlay path and policy for that path.  In other words,
   there is no a priori mandate about how to forward packets in the
   network (only the order of services that must be traversed).

</t>
<t>
The network operator retains the ability to engineer the network
   paths as required.  For example, the overlay path between SFFs
   may utilize traffic engineering, QoS marking, or
   ECMP, without requiring complex configuration and network protocol
   support to be extended to the service path explicitly.  In other
   words, the network operates as expected, and evolves as required, as
   does the service plane.

</t>


</section>


<section title="Service Plane Visibility">
<t>
The SPI and SI serve an important function for visibility into the
service topology.  An operator can determine what service path a
packet is "on" and its location within that path simply by viewing NSH
information (packet capture, IP Flow Information Export (IPFIX), etc.).
The information can be used for service scheduling and placement
decisions, troubleshooting, and compliance verification.

</t>
</section>

<section title="Service Graphs" anchor="graph">
<t>

While a given realized SFP is a specific sequence of Service
Functions, the service, as seen by a user, can actually be a
collection of SFPs, with the interconnection provided by Classifiers
(in-service path, non-initial re-classification).  These internal
re-Classifiers examine the packet at relevant points in the network,
and, if needed, SPI and SI are updated (whether this update is a
re-write, or the imposition of a new NSH with new values is
implementation specific) to reflect the "result" of the
classification.  These Classifiers may, of course, also modify the
metadata associated with the packet.
<vspace blankLines="0" />
Section 2.1 of <xref target="RFC7665" /> describes Service Graphs in detail.
</t>

</section>



</section>

<section title="Policy Enforcement with NSH">

<section title="NSH Metadata and Policy Enforcement">
<t>
As described in <xref target="NSH" />, NSH provides the ability to
carry metadata along a service path.  This metadata may be derived
from several sources. Common examples include:

</t>
 <t><list style="hanging">
 <t>
Network nodes/devices: Information provided by network nodes can
indicate network-centric information (such as VPN Routing and
Forwarding (VRF) or tenant) that may be used by Service Functions or
conveyed to another network node post service path egress.

</t>
<t>
External (to the network) systems: External systems, such as
      orchestration systems, often contain information that is valuable
      for Service Function policy decisions.  In most cases, this
      information cannot be deduced by network nodes.  For example, a
      cloud orchestration platform placing workloads "knows" what
      application is being instantiated and can communicate this
      information to all NSH nodes via metadata carried in the Context Header(s).

</t>

<t>
Service Functions: A Classifier co-resident with Service Functions
often performs very detailed and valuable classification.

</t>
</list></t>

<t>
   Regardless of the source, metadata reflects the "result" of
   classification.  The granularity of classification may vary.  For
   example, a network switch, acting as a Classifier, might only be
   able to classify based on a 2-tuple, or based on a 5-tuple, while a
   Service Function may be able to inspect application information.
   Regardless of granularity, the classification information can be
   represented in the NSH.

</t>

<t>
Once the data is added to the NSH, it is carried along the service
path.  NSH-aware SFs receive the metadata, and can use that metadata
for local decisions and policy enforcement.  Figures <xref target="g1" format="counter"/> and
<xref target="g2" format="counter"/> highlight the relationship between metadata and
policy.

</t>



            <figure title="Metadata and Policy" anchor="g1">
              <artwork align="center">
+-------+        +-------+        +-------+
|  SFF  )------->(  SFF  |------->|  SFF  |
+---+---+        +---+---+        +---+---+
    ^                |                |
  ,-|-.            ,-|-.            ,-|-.
 /     \          /     \          /     \
( Class )        (  SF1  )        (  SF2  )
 \ ify /          \     /          \     /
  `---'            `---'            `---'
 5-tuple:        Permit             Inspect
 Tenant A        Tenant A           AppY
 AppY
             </artwork>
          </figure>


            <figure title="External Metadata and Policy" anchor="g2">
              <artwork align="center">
 +-----+           +-----+            +-----+
 | SFF |---------> | SFF |----------> | SFF |
 +--+--+           +--+--+            +--+--+
    ^                 |                  |
  ,-+-.             ,-+-.              ,-+-.
 /     \           /     \            /     \
( Class )         (  SF1  )          (  SF2  )
 \ ify /           \     /            \     /
  `-+-'             `---'              `---'
    |              Permit            Deny AppZ
+---+---+          employees
|       |
+-------+
External
system:
Employee
AppZ
             </artwork>
          </figure>

<t>
   In both of the examples above, the Service Functions perform policy
   decisions based on the result of the initial classification: the SFs
   did not need to perform re-classification; instead, they rely on an
   antecedent classification for local policy enforcement.

</t>
<t>
Depending on the information carried in the metadata, data privacy
impact needs to be considered.  For example, if the metadata conveys
tenant information, that information may need to be authenticated
and/or encrypted between the originator and the intended recipients
(which may include intended SFs only); one approach to an optional
capability to do this is explored in <xref
target="NSH-ENCRYPT" />.  The NSH itself does not
provide privacy functions, rather it relies on the transport
encapsulation/overlay.  An operator can select the appropriate set of
transport encapsulation protocols to ensure confidentiality (and other
security) considerations are met.  Metadata privacy and security
considerations are a matter for the documents that define metadata
format.
</t>

</section>

<section title="Updating/Augmenting Metadata">

<t>
   Post-initial metadata imposition (typically, performed during initial
   service path determination), the metadata may be augmented or updated:

</t>

<t>
<list style="numbers">
<t>
Metadata Augmentation: Information may be added to the NSH's existing
metadata, as depicted in <xref target="augment" />.  For example, if
the initial classification returns the tenant information, a secondary
classification (perhaps co-resident with deep packet inspection (DPI)
or server load balancing (SLB)) may augment the tenant classification
with application information, and impose that new information in NSH
metadata.  The tenant classification is still valid and present, but
additional information has been added to it.

</t>

<t>
Metadata Update: Subsequent Classifiers may update the initial
       classification if it is determined to be incorrect or not
       descriptive enough.  For example, the initial Classifier adds
       metadata that describes the traffic as "Internet", but a security
       Service Function determines that the traffic is really "attack".
       <xref target="update" /> illustrates an example of updating metadata.
</t>

</list>
</t>

            <figure title="Metadata Augmentation" anchor="augment">
              <artwork align="center">
 +-----+           +-----+            +-----+
 | SFF |---------> | SFF |----------> | SFF |
 +--+--+           +--+--+            +--+--+
    ^                 |                  |
  ,---.             ,---.              ,---.
 /     \           /     \            /     \
( Class )         (  SF1  )          (  SF2  )
 \     /           \     /            \     /
  `-+-'             `---'              `---'
    |              Inspect           Deny
+---+---+          employees         employee+
|       |          Class=AppZ        appZ
+-------+
External
system:
Employee
             </artwork>
          </figure>



<figure title="Metadata Update" anchor="update">
              <artwork align="center">
  +-----+           +-----+            +-----+
  | SFF |---------> | SFF |----------> | SFF |
  +--+--+           +--+--+            +--+--+
     ^                 |                  |
   ,---.             ,---.              ,---.
  /     \           /     \            /     \
 ( Class )         (  SF1  )          (  SF2  )
  \     /           \     /            \     /
   `---'             `---'              `---'
5-tuple:            Inspect             Deny
Tenant A            Tenant A            attack
                     --> attack
             </artwork>
          </figure>

</section>

<section title="Service Path Identifier and Metadata">
<t>
 Metadata information may influence the service path selection since
 the Service Path Identifier values can represent the result of
 classification.  A given SPI can be defined based on classification
 results (including metadata classification).  The imposition of the
 SPI and SI results in the packet being placed on the newly specified
 SFP at the position indicated by the imposed SPI and SI.
</t>
<t>
   This relationship provides the ability to create a dynamic service
   plane based on complex classification, without requiring each node
   to be capable of such classification or requiring a coupling to
   the network topology.  This yields Service Graph functionality as
   described in <xref target="graph" />.  <xref target="g3" />
   illustrates an example of this behavior.
</t>



            <figure title="Path ID and Metadata" anchor="g3">
              <artwork align="center">
  +-----+           +-----+            +-----+
  | SFF |---------> | SFF |------+---> | SFF |
  +--+--+           +--+--+      |     +--+--+
     |                 |         |        |
   ,---.             ,---.       |      ,---.
  /     \           / SF1 \      |     /     \
 (  SCL  )         (   +   )     |    (  SF2  )
  \     /           \SCL2 /      |     \     /
   `---'             `---'    +-----+   `---'
5-tuple:            Inspect   | SFF |    Original
Tenant A            Tenant A  +--+--+    next SF
                     --> DoS     |
                                 V
                               ,-+-.
                              /     \
                             (  SF10 )
                              \     /
                               `---'
                                DoS
                             "Scrubber"

Legend:
SCL = Service Classifier
              </artwork>

          </figure>


<t>
Specific algorithms for mapping metadata to an SPI are outside the
   scope of this document.
</t>

</section>

</section>




<section title="Security Considerations" toc="default">


<t>
    NSH security must be considered in the contexts of the SFC
    architecture and operators' environments. One important
    characteristic of NSH is that it is not an end-to-end protocol.  As
    opposed to a protocol that "starts" on a host and "ends" on a
    server or another host, NSH is typically imposed by a network device
    on ingress to the SFC domain and removed at the egress of the SFC
    domain.    As such, and as with any other network-centric protocols
  (e.g., IP Tunneling, Traffic Engineering, MPLS, or Provider-Provisioned Virtual Private Networks), there is an underlying trust in
  the network devices responsible for imposing, removing, and acting on
  NSH information.


</t><t>
    The following sections detail an analysis and present a set of
    requirements and recommendations in those two areas.
</t>

<section title="NSH Security Considerations from Operators' Environments" toc="default">

<t>
    Trusted Devices
    

    <list style="empty">

    <t>
        All Classifiers, SFFs and SFs (hereinafter referred to as
        "SFC devices") within an operator's environment are assumed to
        have been selected, vetted, and actively maintained;
        therefore, they are trusted by that operator.  This assumption
        differs from the oft held view that devices are untrusted,
        often referred to as the "zero-trust model".  Operators SHOULD
        regularly monitor (i.e., continuously audit) these devices to
        help ensure compliant behavior. This trust, therefore, extends
        into NSH operations: SFC devices are not, themselves,
        considered to be attack vectors.  This assumption, and the
        resultant conclusion is reasonable since this is the very
        basis of an operator posture; the operator depends on this
        reality to function.  If these devices are not trusted, and
        indeed are compromised, almost the entirety of the operator's
        standard-based IP and MPLS protocol suites are vulnerable;
        therefore, the operation of the entire network is compromised.

   Although there are well-documented monitoring-based methods for detecting
   compromise (such as included continuous monitoring and audit and log
   review), these may not be sufficient to contain damage
   by a completely compromised element.


</t><t>
        Methods and best practices to secure devices are also widely
        documented and outside the scope of this document.
</t>
</list>
</t>
<t>

    Single Domain Boundary
    <list style="empty">
    <t>
        As per <xref target="RFC7665" />, NSH is designed for use within a single
        administrative domain.  This scoping provides two important
        characteristics:
</t><t>

        i)  Clear NSH boundaries
</t><t>

        NSH egress devices MUST strip the NSH headers before they send
        the users' packets or frames out of the NSH domain.
</t><t>

        Means to prevent leaking privacy-related information outside an
        administrative domain are natively supported by the NSH given
        that the last SFF of a service path will systematically remove
        the NSH encapsulation before forwarding a packet exiting the
        service path.
</t><t>

        The second step in such prevention is to filter the transport
        encapsulation protocol used by NSH at the domain edge.  The
        transport encapsulation protocol MUST be filtered and MUST NOT
        leave the domain edge.
</t><t>

        Depending upon the transport encapsulation protocol used for
        NSH, this can be done either by completely blocking the
        transport encapsulation (e.g., if MPLS is the chosen NSH
        transport encapsulation protocol, it is therefore never allowed
        to leave the domain) or by examining the carried protocol with
        the transport encapsulation (e.g., if VXLAN-gpe is used as the
        NSH transport encapsulation protocol, all domain edges need to
        filter based on the carried protocol in the VXLAN-gpe.)
</t><t>

        The other consequence of this bounding is that ingress packets
        MUST also be filtered to prevent attackers from sending in NSH
        packets with service path identification and metadata of their
        own selection.  The same filters as described above for both the
        NSH at SFC devices and for the transport encapsulation protocol
        as general edge protections MUST be applied on ingress.
</t><t>

        In summary, packets originating outside the SFC-enabled domain
        MUST be dropped if they contain an NSH.  Similarly, packets
        exiting the SFC-enabled domain MUST be dropped if they contain
        an NSH.
</t><t>
        ii) Mitigation of external threats
</t><t>

        As per the trusted SFC device points raised above, given that
        NSH is scoped within an operator's domain, that operator can
        ensure that the environment and its transitive properties
        comply with that operator's required security
        posture. Continuous audits for assurance are recommended with
        this reliance on a fully trusted environment. The term
        "continuous audits" describes a method (automated or manual)
        of checking security-control compliance on a regular basis, at
        some set period of time.
</t>
</list>
</t>


</section>


<section title="NSH Security Considerations from the SFC Architecture" toc="default">

<t>
    The SFC architecture defines functional roles (e.g., SFF), as well
    as protocol elements (e.g., Metadata).  This section considers each
    role and element in the context of threats posed in the areas of
    integrity and confidentiality.  As with routing, the distributed
    computation model assumes a distributed trust model.
</t><t>

    An important consideration is that NSH contains mandatory-to-mute
    fields, and further, the SFC architecture describes cases where
    other fields in NSH change, all on a possible SFP hop-by-hop basis.
    This means that any cryptographic solution requires complex key
    distribution and life-cycle operations.
</t>

<section title="Integrity" toc="default">

<t>
      SFC devices

    <list style="empty">
    <t>

        SFC devices MAY perform various forms of verification on
        received NSH packets such as only accepting NSH packets from
        expected devices, checking that NSH SPI and SI values received
        from expected devices conform to expected values and so on.
        Implementation of these additional checks are a local matter and,
        thus, out of scope of this document.
</t></list></t>

<t>    

      NSH Base and Service Path Headers
    <list style="empty">
    <t>
        Attackers who can modify packets within the operator's network
        may be able to modify the SFP, path position, and/or the
        metadata associated with a packet.  </t>

<t> One specific
        concern is an attack in which a malicious modification of the
        SPI/SI results in an alteration of the path to avoid security
        devices. The options discussed in this section help thwart that
        attack, and so does the use of the optional "Proof of Transit"
        method <xref target="PROOF-OF-TRANSIT" />.
        </t><t>

        As stated above, SFC devices are trusted; in the case where an
        SFC device is compromised, NSH integrity protection would be
        subject to forging (in many cases) as well.
</t><t>

        NSH itself does not mandate protocol-specific integrity
        protection. However, if an operator deems protection is required, several options are viable:
</t><t>

    <list style="numbers">

        <t> SFF/SF NSH verification
     <vspace blankLines="1" />

            Although, strictly speaking, not integrity protection, some of
            the techniques mentioned above, such as checking expected NSH
            values are received from expected SFC device(s), can provide
            a form of verification without incurring the burden of a
            full-fledged integrity-protection deployment.

        </t><t>  Transport Security
     <vspace blankLines="1" />

            NSH is always encapsulated by an outer transport
            encapsulation as detailed in <xref target="encap"/> of
            this specification, and as depicted in <xref
            target="encapsulation" />.  If an operator deems
            cryptographic integrity protection necessary due to their
            risk analysis, then an outer transport encapsulation that
            provides such protection <xref target="RFC6071" />, such
            as IPsec, MUST be used.
     <vspace blankLines="1" />

         Although the threat model and recommendations of Section 5 of
         BCP 72 <xref target="RFC3552" /> would normally require
         cryptographic data origin authentication for the header, this
         document does not mandate such mechanisms in order to reflect
         the operational and technical realities of deployment.
     <vspace blankLines="1" />


            Given that NSH is transport independent, as mentioned above,
            a secure transport, such as IPsec can be used for carry NSH.
            IPsec can be used either alone or in conjunction with other
            transport encapsulation protocols, in turn, encapsulating NSH.
     <vspace blankLines="1" />

            Operators MUST ensure the selected transport encapsulation
            protocol can be supported by the transport
            encapsulation/underlay of all relevant network segments as
            well as SFFs, SFs, and SFC Proxies in the service path.
     <vspace blankLines="1" />

If connectivity between SFC-enabled devices traverses the public Internet,
then such connectivity
MUST be secured at the transport encapsulation layer.
IPsec is an example of such a transport.


        </t><t>  NSH Variable Header-Based Integrity
     <vspace blankLines="1" />

            Lastly, NSH MD Type 2 provides, via variable-length headers,
            the ability to append cryptographic integrity protection to
            the NSH packet.  The implementation of such a scheme is
            outside the scope of this document.
            </t></list>
</t></list></t>
<t>
       NSH metadata
    <list style="empty">
    <t>

        As with the Base and Service Path Headers, if an operator deems
        cryptographic integrity protection needed, then an existing,
        standard transport protocol MUST be used since the integrity
        protection applies to entire encapsulated NSH packets.  As
        mentioned above, a risk assessment that deems data-plane traffic
        subject to tampering will apply not only to NSH but to the
        transport information; therefore, the use of a secure
        transport is likely needed already to protect the entire stack.
</t><t>
        If an MD Type 2 variable header integrity scheme is in place,
        then the integrity of the metadata can be ensured via that
        mechanism as well.
</t></list></t>

</section>

<section title="Confidentiality" toc="default">

<t>
      SFC devices
    <list style="empty">
    <t>

        SFC devices can "see" (and need to use) NSH information.
    </t></list>
</t>
<t>
    NSH Base and Service Path Headers
    <list style="empty">
    <t>

        SPI and other base / service path information does not typically
        require confidentiality; however, if an operator does deem
        confidentiality to be required, then, as with integrity, an existing
        transport encapsulation that provides encryption MUST be
        utilized.
    </t></list>
</t>
<t>
       NSH metadata
    <list style="empty">
    <t>

        An attacker with access to the traffic in an operator's network
        can potentially observe the metadata NSH carries with packets,
        potentially discovering privacy-sensitive information.
</t><t>
        Much of the metadata carried by NSH is not sensitive.  It often
        reflects information that can be derived from the underlying
        packet or frame.  Direct protection of such information is not
        necessary, as the risks are simply those of carrying the
        underlying packet or frame.
</t><t>

        Implementers and operators MUST be aware that metadata can have
        privacy implications, and those implications are sometimes hard
        to predict. Therefore, attached metadata should be limited to
        that necessary for correct operation of the SFP. Further,
        <xref target="RFC8165" /> defines metadata considerations that operators can
        take into account when using NSH.
</t><t>

        Protecting NSH metadata information between SFC components can
        be done using transport encapsulation protocols with suitable
        security capabilities, along the lines discussed above. If a
        security analysis deems these protections necessary, then
        security features in the transport encapsulation protocol (such
        as IPsec) MUST be used.
</t><t>

        One useful element of providing privacy protection for
        sensitive metadata is described under the "SFC Encapsulation"
        area of the Security Considerations of <xref target="RFC7665"
        />.  Operators can and should use indirect identification for
        metadata deemed to be sensitive (such as personally
        identifying information), significantly mitigating the risk of
        a privacy violation.  In particular, subscriber-identifying
        information should be handled carefully, and, in general, SHOULD
        be obfuscated.  </t><t>

        For those situations where obfuscation is either inapplicable or
        judged to be insufficient, an operator can also encrypt the
        metadata. An approach to an optional capability to do this was
        explored in <xref target="NSH-ENCRYPT" />.  For other situations
        where greater assurance is desired, optional mechanisms such as
        <xref
target="PROOF-OF-TRANSIT" /> can be used.
    </t></list>
</t>
</section>
</section>
</section>

    <section anchor="iana" title="IANA Considerations" toc="default">



     <section title = "NSH Parameters" anchor ="sfcparams">
      <t>
      IANA has created a new "Network Service Header (NSH) Parameters" registry.
      The following subsections detail new registries within the "Network Service Header (NSH) Parameters" registry.
      </t>

      <section title = "NSH Base Header Bits" anchor ="bbits">
      <t>
   There are five unassigned bits (U bits) in the NSH Base Header, and one assigned bit (O bit).  New bits are assigned via Standards Action <xref
        target="RFC8126"></xref>.
    </t>
    <t>
   Bit 2 - O (OAM) bit
   <vspace blankLines="0" />
   Bit 3 - Unassigned
  <vspace blankLines="0" />
   Bits 16-19 - Unassigned
   </t>
       </section>

      <section title = "NSH Version" anchor ="vbits">
      <t>
        IANA has set up the "NSH Version" registry.
        New values are assigned via Standards Action <xref target="RFC8126" />.
    </t>

<?rfc compact="yes" ?>
 <texttable title="NSH Version" anchor="ver_tab">

          <ttcol align="left">Version</ttcol>

          <ttcol align="left">Description</ttcol>

          <ttcol align="left">Reference</ttcol>

   <c>Version 00b</c><c>Protocol as defined by RFC 8300</c><c>RFC 8300</c>

   <c>Version 01b</c><c>Reserved</c><c>RFC 8300</c>

   <c>Version 10b</c><c>Unassigned</c><c></c>

   <c>Version 11b</c><c>Unassigned</c><c></c>
 </texttable>
<?rfc compact="no" ?>
      </section>


     <section title ="NSH MD Types" anchor="mdt">

    <t>
IANA has set up the "NSH MD Types" registry, which contains 4-bit
values. MD Type values 0x0, 0x1, 0x2, and 0xF are specified in this
document; see <xref target="tab1" />.

Registry entries are assigned via the "IETF Review" policy
defined in <xref target="RFC8126">RFC 8126</xref>.
</t>

<?rfc compact="no" ?>
 <texttable title="MD Type Values" anchor="tab1">

          <ttcol align="left">MD Type</ttcol>

          <ttcol align="left">Description</ttcol>

          <ttcol align="left">Reference</ttcol>

          <c>0x0</c>

          <c>Reserved</c>

          <c>RFC 8300</c>

          <c>0x1</c>

          <c>NSH MD Type 1</c>

          <c>RFC 8300</c>

           <c>0x2</c>

          <c>NSH MD Type 2</c>

          <c>RFC 8300</c>

          <c>0x3 - 0xE</c>

          <c>Unassigned</c>

          <c></c>

          <c>0xF</c>

          <c>Experimentation</c>

          <c>RFC 8300</c>

        </texttable>
<?rfc compact="yes" ?>

    </section>

     <section title ="NSH MD Class" anchor="mdclass">

    <t>
IANA has set up the "NSH MD Class" registry, which contains 16-bit
   values. New allocations are to be made according to the
   following policies:

  <vspace blankLines="1" />
   0x0000 to 0x01ff: IETF Review
  <vspace blankLines="0" />
   0x0200 to 0xfff5: Expert Review
</t>
<t>
IANA has assigned the values as follows:
</t>

<?rfc compact="no" ?>
<texttable anchor="ttab" title="NSH MD Class" >
<ttcol>Value </ttcol><ttcol>Meaning</ttcol><ttcol> Reference </ttcol>
<c>0x0000   </c><c>IETF Base NSH MD Class</c><c>RFC 8300</c>
<c>0xfff6 to 0xfffe</c><c>Experimental</c><c>RFC 8300</c>
<c>0xffff</c><c>Reserved</c><c>RFC 8300</c>

</texttable>
<?rfc compact="yes" ?>

<t>A registry for Types for the MD Class of 0x0000 is defined in <xref target="tr" />.</t>

<t>


   Designated Experts evaluating new allocation requests
   from the "Expert Review" range should principally
   consider whether a new MD class is needed compared to
   adding MD Types to an existing class.  The Designated
   Experts should also encourage the existence of an
   associated and publicly visible registry of MD Types
   although this registry need not be maintained by IANA.
</t>
<t>
When evaluating a request for an allocation, the Expert should verify
that the allocation plan includes considerations to handle privacy and
security issues associated with the anticipated individual MD Types
allocated within this class. These plans should consider, when
appropriate, alternatives such as indirection, encryption, and limited-deployment scenarios. Information that can't be directly derived from
viewing the packet contents should be examined for privacy and
security implications.
</t>


 </section>


<section title="NSH IETF-Assigned Optional Variable-Length Metadata Types" anchor="tr">
<t>
The Type values within the IETF Base NSH MD Class, i.e., when the MD
Class is set to 0x0000 (see <xref target="mdclass" />), are the Types
owned by the IETF.  Per this document, IANA has created a registry
for the Type values for the IETF Base NSH MD Class called the
"NSH IETF-Assigned Optional Variable-Length Metadata Types" registry, as
specified in <xref target="tlvagain" />.


</t>
<t>
   The type values are assigned via Standards Action <xref
   target="RFC8126" />.
</t>
<t>
   No initial values are assigned at the creation of the registry.
</t>
</section>



<section title ="NSH Next Protocol" anchor="bnp">
    <t>
    IANA has set up the "NSH Next Protocol" registry, which contains 8-bit values.
    Next Protocol values 0, 1, 2, 3, 4, and 5 are defined in this document (see <xref target="tab2" />).  New
   values are assigned via "Expert Review" as per <xref
        target="RFC8126"></xref>.

</t>
<?rfc compact="no" ?>
    <texttable title="NSH Base Header Next Protocol Values" anchor="tab2">


          <ttcol align="left">Next Protocol</ttcol>

          <ttcol align="left">Description</ttcol>

          <ttcol align="left">Reference</ttcol>

          <c>0x00</c>

          <c>Unassigned</c>

          <c></c>

          <c>0x01</c>

          <c>IPv4</c>

          <c>RFC 8300</c>

          <c>0x02</c>

          <c>IPv6</c>

          <c>RFC 8300</c>

          <c>0x03</c>

          <c>Ethernet</c>

          <c>RFC 8300</c>

          <c>0x04</c>

          <c>NSH</c>

          <c>RFC 8300</c>

          <c>0x05</c>

          <c>MPLS</c>

          <c>RFC 8300</c>


          <c>0x06 - 0xFD</c>

          <c>Unassigned</c>

          <c></c>

          <c>0xFE</c>

          <c>Experiment 1</c>

          <c>RFC 8300</c>

          <c>0xFF</c>

          <c>Experiment 2</c>

          <c>RFC 8300</c>

        </texttable>
<?rfc compact="yes" ?>

<t>
Expert Review requests MUST include a single codepoint per request.
   Designated Experts evaluating new allocation requests from this registry
   should consider the potential scarcity of codepoints for an 8-bit value,
   and check both for duplications and availability of documentation.

If the actual assignment of the Next Protocol field allocation
reaches half of the range (that is, when there are 128 unassigned values), IANA
needs to alert the IESG.  At that point, a new more strict allocation 
policy SHOULD be considered.
</t>

</section>

</section>

</section>

<section anchor="etype" title="NSH-Related Codepoints" toc="default">

     <section title ="NSH Ethertype" anchor="et">
     <t>
     An IEEE Ethertype, 0x894F, has been allocated for NSH.
    </t>

    </section>
</section>



</middle>


  <back>




    <references title="Normative References">


&RFC2119;
&RFC8126;
&RFC7665;
<?rfc include="reference.RFC.8174"?>


    </references>

    <references title="Informative References">

    &RFC2784;
    &RFC6071;
    &RFC7325;
    &RFC7498;
    &RFC3552;
   <?rfc include="reference.RFC.8165.xml"?>
   <?rfc include="reference.RFC.6291.xml"?>
   <?rfc include="reference.RFC.3692.xml"?>
   <?rfc include="reference.RFC.7676.xml"?>
   <?rfc include="reference.RFC.8201.xml"?>

<!-- draft-ietf-sfc-oam-framework : I-D exists -->
<reference anchor='SFC-OAM-FRAMEWORK'>
<front>
<title>Service Function Chaining (SFC) Operation, Administration and Maintenance (OAM) Framework</title>

<author initials='S' surname='Aldrin' fullname='Sam Aldrin'>
    <organization />
</author>

<author initials='C' surname='Pignataro' fullname='Carlos Pignataro'>
    <organization />
</author>

<author initials='N' surname='Kumar' fullname='Nagendra Kumar'>
    <organization />
</author>

<author initials='N' surname='Akiya' fullname='Nobo Akiya'>
    <organization />
</author>

<author initials='R' surname='Krishnan' fullname='Ram Krishnan'>
    <organization />
</author>

<author initials='A' surname='Ghanwani' fullname='Anoop Ghanwani'>
    <organization />
</author>

<date month='September' day='7' year='2017' />

<abstract><t>This document provides a reference framework for Operations, Administration and Maintenance (OAM) for Service Function Chaining (SFC).</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-sfc-oam-framework-03' />
</reference>

<!--  draft-guichard-sfc-nsh-dc-allocation :  I-D Exists -->

<reference anchor='NSH-DC-ALLOCATION'>
<front>
<title>Network Service Header (NSH) MD Type 1: Context Header Allocation (Data Center)</title>

<author initials='J' surname='Guichard' fullname='Jim Guichard'>
    <organization />
</author>

<author initials='M' surname='Smith' fullname='Michael Smith'>
    <organization />
</author>

<author initials='S' surname='Kumar' fullname='Surendra Kumar'>
    <organization />
</author>

<author initials='S' surname='Majee' fullname='Sumandra Majee'>
    <organization />
</author>

<author initials='P' surname='Agarwal' fullname='Puneet Agarwal'>
    <organization />
</author>

<author initials='K' surname='Glavin' fullname='Kevin Glavin'>
    <organization />
</author>

<author initials='Y' surname='Laribi' fullname='Youcef Laribi'>
    <organization />
</author>

<author initials='T' surname='Mizrahi' fullname='Tal Mizrahi'>
    <organization />
</author>

<date month='August' day='18' year='2017' />

<abstract><t>This document provides a recommended default allocation for the Network Service Header (NSH) MD Type 1 fixed length context header when NSH is used for Service Function Chaining within a data center.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-guichard-sfc-nsh-dc-allocation-07' />

</reference>


<!-- draft-napper-sfc-nsh-broadband-allocation : I-D exists -->
<reference anchor='NSH-BROADBAND-ALLOCATION'>
<front>
<title>NSH Context Header Allocation -- Broadband</title>

<author initials='J' surname='Napper' fullname='Jeffrey Napper'>
    <organization />
</author>

<author initials='S' surname='Kumar' fullname='Surendra Kumar'>
    <organization />
</author>

<author initials='P' surname='Muley' fullname='Praveen Muley'>
    <organization />
</author>

<author initials='W' surname='Henderickx' fullname='Wim Henderickx'>
    <organization />
</author>

<author initials='M' surname='Boucadair' fullname='Mohamed Boucadair'>
    <organization />
</author>

<date month='November' day='13' year='2017' />

<abstract><t>This document provides a recommended allocation of context headers for a Network Service Header (NSH) within the broadband service provider network context.  NSH is described in detail in [ietf-sfc-nsh].  This allocation is intended to support uses cases as defined in [ietf-sfc-use-case-mobility].</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-napper-sfc-nsh-broadband-allocation-04' />

</reference>

<!-- draft-ietf-nvo3-vxlan-gpe : I-D Exists -->
<reference anchor='VXLAN-GPE'>
<front>
<title>Generic Protocol Extension for VXLAN</title>

<author initials='F' surname='Maino' fullname='Fabio Maino'>
    <organization />
</author>

<author initials='L' surname='Kreeger' fullname='Larry Kreeger'>
    <organization />
</author>

<author initials='U' surname='Elzur' fullname='Uri Elzur'>
    <organization />
</author>

<date month='October' day='30' year='2017' />

<abstract><t>This draft describes extending Virtual eXtensible Local Area Network (VXLAN), via changes to the VXLAN header, with three new capabilities: support for multi-protocol encapsulation, operations, administration and management (OAM) signaling and explicit versioning.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-nvo3-vxlan-gpe-05' />

</reference>


<!--   <?rfc include="reference.I-D.ietf-sfc-control-plane.xml"?>; Expired -->



<reference anchor='SFC-CONTROL-PLANE'>
<front>
<title>Service Function Chaining (SFC) Control Plane Components &amp; Requirements</title>

<author initials='M' surname='Boucadair' fullname='Mohamed Boucadair'>
    <organization />
</author>

<date month='October' day='23' year='2016' />

<abstract><t>This document describes requirements for conveying information between Service Function Chaining (SFC) control elements and SFC data plane functional elements.  Also, this document identifies a set of control interfaces to interact with SFC-aware elements to establish, maintain or recover service function chains.  This document does not specify protocols nor extensions to existing protocols.  This document exclusively focuses on SFC deployments that are under the responsibility of a single administrative entity.  Inter-domain considerations are out of scope.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-sfc-control-plane-08' />

</reference>


<!--   <?rfc include="reference.I-D.ietf-rtgwg-dt-encap.xml"?>; Expired -->



<reference anchor='RTG-ENCAP'>
<front>
<title>Encapsulation Considerations</title>

<author initials='E' surname='Nordmark' fullname='Erik Nordmark'>
    <organization />
</author>

<author initials='A' surname='Tian' fullname='Albert Tian'>
    <organization />
</author>

<author initials='J' surname='Gross' fullname='Jesse Gross'>
    <organization />
</author>

<author initials='J' surname='Hudson' fullname='Jon Hudson'>
    <organization />
</author>

<author initials='L' surname='Kreeger' fullname='Larry Kreeger'>
    <organization />
</author>

<author initials='P' surname='Garg' fullname='Pankaj Garg'>
    <organization />
</author>

<author initials='P' surname='Thaler' fullname='Patricia Thaler'>
    <organization />
</author>

<author initials='T' surname='Herbert' fullname='Tom Herbert'>
    <organization />
</author>

<date month='October' day='31' year='2016' />

<abstract><t>The IETF Routing Area director has chartered a design team to look at common issues for the different data plane encapsulations being discussed in the NVO3 and SFC working groups and also in the BIER BoF, and also to look at the relationship between such encapsulations in the case that they might be used at the same time.  The purpose of this design team is to discover, discuss and document considerations across the different encapsulations in the different WGs/BoFs so that we can reduce the number of wheels that need to be reinvented in the future.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-rtgwg-dt-encap-02' />

</reference>


<!--   <?rfc include="reference.I-D.reddy-sfc-nsh-encrypt.xml"?>; Expired -->



<reference anchor='NSH-ENCRYPT'>
<front>
<title>Authenticated and encrypted NSH service chains</title>

<author initials='T' surname='Reddy' fullname='Tirumaleswar Reddy'>
    <organization />
</author>

<author initials='P' surname='Patil' fullname='Prashanth Patil'>
    <organization />
</author>

<author initials='S' surname='Fluhrer' fullname='Scott Fluhrer'>
    <organization />
</author>

<author initials='P' surname='Quinn' fullname='Paul Quinn'>
    <organization />
</author>

<date month='April' day='9' year='2015' />

<abstract><t>This specification adds data origin authentication and optional encryption directly to Network Service Headers (NSH) used for Service Function Chaining.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-reddy-sfc-nsh-encrypt-00' />

</reference>

<!-- draft-brockners-proof-of-transit : I-D Exists -->
<reference anchor='PROOF-OF-TRANSIT'>
<front>
<title>Proof of Transit</title>

<author initials='F' surname='Brockners' fullname='Frank Brockners'>
    <organization />
</author>

<author initials='S' surname='Bhandari' fullname='Shwetha Bhandari'>
    <organization />
</author>

<author initials='S' surname='Dara' fullname='Sashank Dara'>
    <organization />
</author>

<author initials='C' surname='Pignataro' fullname='Carlos Pignataro'>
    <organization />
</author>

<author initials='J' surname='Leddy' fullname='John Leddy'>
    <organization />
</author>

<author initials='S' surname='Youell' fullname='Stephen Youell'>
    <organization />
</author>

<author initials='D' surname='Mozes' fullname='David Mozes'>
    <organization />
</author>

<author initials='T' surname='Mizrahi' fullname='Tal Mizrahi'>
    <organization />
</author>

<date month='October' day='30' year='2017' />

<abstract><t>Several technologies such as Traffic Engineering (TE), Service Function Chaining (SFC), and policy based routing are used to steer traffic through a specific, user-defined path.  This document defines mechanisms to securely prove that traffic transited said defined path.  These mechanisms allow to securely verify whether, within a given path, all packets traversed all the nodes that they are supposed to visit.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-brockners-proof-of-transit-04' />

</reference>

</references>

    <section title="Acknowledgments" numbered="no">
      <t>
      The authors would like to thank Sunil Vallamkonda, Nagaraj
      Bagepalli, Abhijit Patra, Peter Bosch, Darrel Lewis, Pritesh
      Kothari, Tal Mizrahi, and Ken Gray for their detailed reviews,
      comments, and contributions.
      </t>
      <t>
      A special thank you goes to David Ward and Tom Edsall for their
      guidance and feedback.
      </t>
      <t>
      Additionally, the authors would like to thank Larry Kreeger for
      his invaluable ideas and contributions, which are reflected
      throughout this document.
      </t>
      <t>
        Loa Andersson provided a thorough review and valuable
        comments; we thank him for that.
     </t>
      <t>
      Reinaldo Penno deserves a particular thank you for his
      architecture and implementation work that helped guide the
      protocol concepts and design.
      </t>
      <t>
The editors also acknowledge comprehensive reviews and respective
useful suggestions by Med Boucadair, Adrian Farrel, Juergen
Schoenwaelder, Acee Lindem, and Kathleen Moriarty.
      </t>
      <t>
      Lastly, David Dolson has provided significant review, feedback,
      and suggestions throughout the evolution of this document.  His
      contributions are very much appreciated.
       </t>
    </section>

  <section title="Contributors" anchor="contrib" numbered="no">
      <t>

This WG document originated as draft-quinn-sfc-nsh; the following are
its coauthors and contributors along with their respective
affiliations at the time of WG adoption.  The editors of this document
would like to thank and recognize them and their contributions.  These
coauthors and contributors provided invaluable concepts and content
for this document's creation.
</t>
 <t>
<?rfc subcompact="yes"?>
<list style="symbols">
 <t>Jim Guichard, Cisco Systems, Inc.</t>
 <t>Surendra Kumar, Cisco Systems, Inc.</t>
 <t>Michael Smith, Cisco Systems, Inc.</t>
 <t>Wim Henderickx, Alcatel-Lucent</t>
 <t>Tom Nadeau, Brocade</t>
 <t>Puneet Agarwal</t>
 <t>Rajeev Manur, Broadcom</t>
 <t>Abhishek Chauhan, Citrix</t>
 <t>Joel Halpern, Ericsson</t>
 <t>Sumandra Majee, F5</t>
 <t>David Melman, Marvell</t>
 <t>Pankaj Garg, Microsoft</t>
 <t>Brad McConnell, Rackspace</t>
 <t>Chris Wright, Red Hat, Inc.</t>
 <t>Kevin Glavin, Riverbed</t>
 <t>Hong (Cathy) Zhang, Huawei US R&amp;D</t>
 <t>Louis Fourie, Huawei US R&amp;D</t>
 <t>Ron Parker, Affirmed Networks</t>
 <t>Myo Zarny, Goldman Sachs</t>
 <t>Andrew Dolganow, Alcatel-Lucent</t>
 <t>Rex Fernando, Cisco Systems, Inc.</t>
 <t>Praveen Muley, Alcatel-Lucent</t>
 <t>Navindra Yadav, Cisco Systems, Inc.</t>
</list>

      </t>
<?rfc subcompact="no"?>

    </section>

  </back>



</rfc>
