<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC1319 PUBLIC '' 'reference.RFC.1319.xml'>
<!ENTITY RFC1321 PUBLIC '' 'reference.RFC.1321.xml'>
<!ENTITY RFC2119 PUBLIC '' 'reference.RFC.2119.xml'>
<!ENTITY RFC2313 PUBLIC '' 'reference.RFC.2313.xml'>
<!ENTITY RFC2315 PUBLIC '' 'reference.RFC.2315.xml'>
<!ENTITY RFC2437 PUBLIC '' 'reference.RFC.2437.xml'>
<!ENTITY RFC2629 PUBLIC '' 'reference.RFC.2629.xml'>
<!ENTITY RFC3447 PUBLIC '' 'reference.RFC.3447.xml'>
<!ENTITY RFC3552 PUBLIC '' 'reference.RFC.3552.xml'>
<!ENTITY RFC5958 PUBLIC '' 'reference.RFC.5958.xml'>
<!ENTITY RFC5226 PUBLIC '' 'reference.RFC.5226.xml'>
<!ENTITY RFC5246 PUBLIC '' 'reference.RFC.5246.xml'>
<!ENTITY RFC5652 PUBLIC '' 'reference.RFC.5652.xml'>
<!ENTITY RFC6149 PUBLIC '' 'reference.RFC.6149.xml'>
<!ENTITY RFC7292 PUBLIC '' 'reference.RFC.7292.xml'>
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<rfc category="info" number="8017" ipr="trust200902" obsoletes="3447" submissionType="IETF" consensus="yes">

 <front>

   <title abbrev="PKCS #1 v2.2">PKCS #1: RSA Cryptography Specifications
   Version 2.2</title>

   <author fullname="Kathleen M. Moriarty" initials="K.M." role="editor"
           surname="Moriarty">
     <organization>EMC Corporation</organization>

     <address>
       <postal>
         <street>176 South Street</street>

         <city>Hopkinton</city>
         <region>MA</region>
         <code>01748</code>
         <country>United States of America</country>
       </postal>

       <phone></phone>

       <email>kathleen.moriarty@emc.com</email>

     </address>
   </author>
  
    <author fullname="Burt Kaliski" initials="B."
           surname="Kaliski">
     <organization>Verisign</organization>

     <address>
       <postal>
         <street>12061 Bluemont Way</street>
         <city>Reston</city>
         <region>VA</region>
         <code>20190</code>
         <country>United States of America</country>
       </postal>
       <email>bkaliski@verisign.com</email>
        <uri>http://verisignlabs.com</uri>
     </address>
   </author>
   
   <author fullname="Jakob Jonsson" initials="J." surname="Jonsson">
     <organization>Subset AB</organization>
      <address>
        <postal>
          <street>Munkbrogtan 4</street>
          <code>SE-11127</code>
          <city>Stockholm</city>
          <country>Sweden</country>
        </postal>
       <phone>+46 8 428 687 43</phone>
        <email>jakob.jonsson@subset.se</email>
      </address>
   </author>

     <author fullname="Andreas Rusch" initials="A." surname="Rusch">
      <organization>RSA</organization>
      <address>
       <postal>
          <street>345 Queen Street</street>
         <city>Brisbane</city>
          <region>QLD</region>
          <code>4000</code>
          <country>Australia</country>
        </postal>
        <email>andreas.rusch@rsa.com</email>
      </address>
   </author>

   <date month="November" year="2016" />

   <abstract>
     <t>This document provides recommendations for the implementation of
 public-key cryptography based on the RSA algorithm, covering
 cryptographic primitives, encryption schemes, signature schemes
 with appendix, and ASN.1 syntax for representing keys and for
 identifying the schemes.</t>

 <t>This document represents a republication of PKCS #1 v2.2 from RSA
 Laboratories' Public-Key Cryptography Standards (PKCS) series.  By
 publishing this RFC, change control is transferred to the IETF.</t>

     <t>This document also obsoletes RFC 3447.</t>
   </abstract>
 </front>

 <middle>
    <section anchor="introduction" title="Introduction">
   
      <t>This document provides recommendations for the implementation of public-key cryptography based on the RSA algorithm <xref target="RSA"/>, covering the following aspects:</t>
      <t>
        <list style="symbols">
          <t>Cryptographic primitives</t>
          <t>Encryption schemes</t>
          <t>Signature schemes with appendix</t>
          <t>ASN.1 syntax for representing keys and for identifying the schemes</t>
        </list>
      </t>
      <t>The recommendations are intended for general application within computer and communications systems and as such include a fair amount of flexibility. It is expected that application standards based on these specifications may include additional constraints. The recommendations are intended to be compatible with the standards IEEE 1363 <xref target="IEEE1363"/>, IEEE 1363a <xref target="IEEE1363A"/>, and ANSI X9.44 <xref target="ANSIX944"/>.</t>

      <t>This document supersedes PKCS #1 version 2.1 <xref target="RFC3447"/> but includes compatible techniques.</t>
      <t>The organization of this document is as follows:</t>
   
      <t>
        <list style="symbols">
          <t><xref target="introduction"/> is an introduction.</t>

          <t><xref target="notation"/> defines some notation used in this document.</t>

          <t><xref target="key_types"/> defines the RSA public and private key types.</t>

          <t>Sections <xref target="data_conversion_primitives" format="counter"/> and <xref target="cryptographic_primitives" format="counter"/> define several primitives, or basic mathematical
      operations.  Data conversion primitives are in <xref target="data_conversion_primitives"/>, and
      cryptographic primitives (encryption-decryption and signature-
      verification) are in <xref target="cryptographic_primitives"/>.</t>

          <t>Sections <xref target="overview_of_schemes" format="counter"/>, <xref target="encryption_schemes" format="counter"/>, and <xref target="signature_scheme_with_appendix" format="counter"/> deal with the encryption and signature
      schemes in this document.  <xref target="overview_of_schemes"/> gives an overview.  Along
      with the methods found in PKCS #1 v1.5, <xref target="encryption_schemes"/> defines an
      encryption scheme based on Optimal Asymmetric Encryption Padding (OAEP) <xref target="OAEP"/>, and <xref target="signature_scheme_with_appendix"/> defines a
      signature scheme with appendix based on the Probabilistic Signature Scheme (PSS) <xref target="RSARABIN"/> <xref target="PSS"/>.</t>

          <t><xref target="encoding_methods_for_sigs_with_appendix"/> defines the encoding methods for the signature schemes
      in <xref target="signature_scheme_with_appendix"/>.</t>

          <t><xref target="appendix_ASNsyntax"/> defines the ASN.1 syntax for the keys defined in
      <xref target="key_types"/> and the schemes in Sections <xref target="encryption_schemes" format="counter"/> and <xref target="signature_scheme_with_appendix" format="counter"/>.</t>

          <t><xref target="appendix_supporting"/> defines the hash functions and the mask generation
      function (MGF) used in this document, including ASN.1 syntax for the
      techniques.</t>

          <t><xref target="appendix_ASNmodule"/> gives an ASN.1 module.</t>

          <t>Appendices <xref target="appendix_revhistory" format="counter"/> and <xref target="appendix_aboutPKCS" format="counter"/> 
      outline the revision history of PKCS #1 and provide general information about
      the Public-Key Cryptography Standards.</t>
        </list>
      </t>
<t>This document represents a republication of PKCS #1 v2.2 <xref target="PKCS1_22"/>
 from RSA Laboratories' Public-Key Cryptography Standards (PKCS)
 series.</t>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119"/>.</t>
      </section>
   </section>

   <section anchor="notation" title="Notation">
      <t>The notation in this document includes:</t>
      <figure>  
        <artwork align="left"><![CDATA[
   c              ciphertext representative, an integer between 0 and
                  n-1

   C              ciphertext, an octet string

   d              RSA private exponent

   d_i            additional factor r_i's CRT exponent,
                  a positive integer such that

                    e * d_i == 1 (mod (r_i-1)), i = 3, ..., u

   dP             p's CRT exponent, a positive integer such that

                    e * dP == 1 (mod (p-1))

   dQ             q's CRT exponent, a positive integer such that

                    e * dQ == 1 (mod (q-1))

   e              RSA public exponent

   EM             encoded message, an octet string

   emBits         (intended) length in bits of an encoded message EM

   emLen          (intended) length in octets of an encoded message 
                  EM

   GCD(. , .)     greatest common divisor of two nonnegative integers

   Hash           hash function

   hLen           output length in octets of hash function Hash

   k              length in octets of the RSA modulus n

   K              RSA private key

   L              optional RSAES-OAEP label, an octet string

   LCM(., ..., .) least common multiple of a list of nonnegative
                  integers

   m              message representative, an integer between 0 and 
                  n-1

   M              message, an octet string

   mask           MGF output, an octet string

   maskLen        (intended) length of the octet string mask

   MGF            mask generation function

   mgfSeed        seed from which mask is generated, an octet string

   mLen           length in octets of a message M

   n              RSA modulus, n = r_1 * r_2 * ... * r_u , u >= 2

   (n, e)         RSA public key

   p, q           first two prime factors of the RSA modulus n

   qInv           CRT coefficient, a positive integer less than 
                  p such that q * qInv == 1 (mod p)

   r_i            prime factors of the RSA modulus n, including 
                  r_1 = p, r_2 = q, and additional factors if any

   s              signature representative, an integer between 0 and 
                  n-1

   S              signature, an octet string

   sLen           length in octets of the EMSA-PSS salt

   t_i            additional prime factor r_i's CRT coefficient, a
                  positive integer less than r_i such that

                    r_1 * r_2 * ... * r_(i-1) * t_i == 1 (mod r_i) ,

                  i = 3, ... , u

   u              number of prime factors of the RSA modulus, u >= 2

   x              a nonnegative integer

   X              an octet string corresponding to x

   xLen           (intended) length of the octet string X

   0x             indicator of hexadecimal representation of an octet
                  or an octet string: "0x48" denotes the octet with
                  hexadecimal value 48; "(0x)48 09 0e" denotes the
                  string of three consecutive octets with hexadecimal
                  values 48, 09, and 0e, respectively

   \lambda(n)     LCM(r_1-1, r_2-1, ... , r_u-1)

   \xor           bit-wise exclusive-or of two octet strings

   \ceil(.)       ceiling function; \ceil(x) is the smallest integer
                  larger than or equal to the real number x

   ||             concatenation operator

   ==             congruence symbol; a == b (mod n) means that the
                  integer n divides the integer a - b
   ]]></artwork>
        <postamble> Note: The Chinese Remainder Theorem (CRT) can be applied in a non-recursive as well as a
        recursive way.  In this document, a recursive approach following
        Garner's algorithm <xref target="GARNER" /> is used.  See also Note 1 in <xref target="rsa_private_key"/>.
        </postamble>
      </figure>
   </section>

   <section anchor="key_types" title="Key Types">

      <t>Two key types are employed in the primitives and schemes defined in this document: RSA public key and RSA private key. Together, an RSA public key and an RSA private key form an RSA key pair.</t>
      <t>This specification supports so-called "multi-prime" RSA where the modulus may have more than two prime factors. The benefit of multi-prime RSA is lower computational cost for the decryption and signature primitives, provided that the CRT is used. Better performance can be achieved on single processor platforms, but to a greater extent on multiprocessor platforms, where the modular exponentiations involved can be done in parallel.</t>
      <t>For a discussion on how multi-prime affects the security of the RSA cryptosystem, the reader is referred to <xref target="SILVERMAN"/>.</t>

     <section anchor="rsa_public_key" title="RSA Public Key">
        <t>For the purposes of this document, an RSA public key consists of two
   components:</t>
    
        <figure>
          <artwork align="left"><![CDATA[
      n        the RSA modulus, a positive integer
      e        the RSA public exponent, a positive integer
]]></artwork>
        </figure>
    
        <t>In a valid RSA public key, the RSA modulus n is a product of u
        distinct odd primes r_i, i = 1, 2, ..., u, where u &gt;= 2, and the RSA
        public exponent e is an integer between 3 and n - 1 satisfying GCD(e,
        \lambda(n)) = 1, where \lambda(n) = LCM(r_1 - 1, ..., r_u - 1).  By
        convention, the first two primes r_1 and r_2 may also be denoted p
        and q, respectively.</t>

        <t>A recommended syntax for interchanging RSA public keys between
        implementations is given in <xref target="rsa_public_key_syntax"/>; an implementation's
        internal representation may differ.</t>
     </section>

     <section anchor="rsa_private_key" title="RSA Private Key">
        <t>For the purposes of this document, an RSA private key may have either of two representations.</t>

        <t>
          <list style="numbers">
      
            <t>The first representation consists of the pair (n, d), where the
            components have the following meanings:
      
        <figure>
          <artwork align="left"><![CDATA[
         n       the RSA modulus, a positive integer
         d       the RSA private exponent, a positive integer
]]></artwork>
       </figure></t>
    
            <t>The second representation consists of a quintuple (p, q, dP, dQ,
            qInv) and a (possibly empty) sequence of triplets (r_i, d_i, t_i),
            i = 3, ..., u, one for each prime not in the quintuple, where the
            components have the following meanings:
            </t>
          </list>
        </t>
      
        <figure>
          <artwork align="left"><![CDATA[
         p      the first factor, a positive integer
         q      the second factor, a positive integer
         dP     the first factor's CRT exponent, a positive integer
         dQ     the second factor's CRT exponent, a positive integer
         qInv   the (first) CRT coefficient, a positive integer
         r_i    the i-th factor, a positive integer
         d_i    the i-th factor's CRT exponent, a positive integer
         t_i    the i-th factor's CRT coefficient, a positive integer
]]></artwork>
       </figure>



        <t>In a valid RSA private key with the first representation, the RSA
   modulus n is the same as in the corresponding RSA public key and is
   the product of u distinct odd primes r_i, i = 1, 2, ..., u, where u
   >= 2.  The RSA private exponent d is a positive integer less than n
   satisfying</t>

        <t>
          <list style="empty">
            <t>e * d == 1 (mod \lambda(n)),</t>
          </list>
        </t>

        <t>where e is the corresponding RSA public exponent and \lambda(n) is
        defined as in <xref target="rsa_public_key"/>.</t>

        <t>In a valid RSA private key with the second representation, the two
        factors p and q are the first two prime factors of the RSA modulus n
        (i.e., r_1 and r_2); the CRT exponents dP and dQ are positive
        integers less than p and q, respectively, satisfying</t>

        <t>
          <list style="empty">
            <t>e * dP == 1 (mod (p-1))</t>
            <t>e * dQ == 1 (mod (q-1)) ,</t>
          </list>
        </t>

        <t>and the CRT coefficient qInv is a positive integer less than p
        satisfying</t>
        <t>
          <list style="empty">
            <t>q * qInv == 1 (mod p).</t>
          </list>
        </t>

        <t>If u > 2, the representation will include one or more triplets (r_i,
   d_i, t_i), i = 3, ..., u.  The factors r_i are the additional prime
   factors of the RSA modulus n.  Each CRT exponent d_i (i = 3, ..., u)
   satisfies</t>
        <t>
          <list style="empty">
            <t>e * d_i == 1 (mod (r_i - 1)).</t>
          </list>
        </t>

        <t>Each CRT coefficient t_i (i = 3, ..., u) is a positive integer less
   than r_i satisfying</t>
        <t>
          <list style="empty">
            <t>R_i * t_i == 1 (mod r_i) ,</t>
          </list>
        </t>

        <t>where R_i = r_1 * r_2 * ... * r_(i-1).</t>

        <t>A recommended syntax for interchanging RSA private keys between
   implementations, which includes components from both representations,
   is given in <xref target="rsa_private_key_syntax"/>; an implementation's internal
   representation may differ.</t>

        <t>Notes:</t>
        <t>
          <list style="numbers">
            <t>The definition of the CRT coefficients here and the formulas that
            use them in the primitives in <xref target="cryptographic_primitives"/> generally follow Garner's
            algorithm <xref target="GARNER"/> (see also Algorithm 14.71 in <xref target="HANDBOOK"/>). However, for
            compatibility with the representations of RSA private keys in PKCS
            #1 v2.0 and previous versions, the roles of p and q are reversed
            compared to the rest of the primes.  Thus, the first CRT
            coefficient, qInv, is defined as the inverse of q mod p, rather
            than as the inverse of R_1 mod r_2, i.e., of p&nbsp;mod&nbsp;q.</t>

            <t>Quisquater and Couvreur <xref target="FASTDEC"/> observed the benefit of applying the
            CRT to RSA operations.</t>
          </list>
        </t>

      </section>
   </section>

   <section anchor="data_conversion_primitives" title="Data Conversion Primitives">
      <t>Two data conversion primitives are employed in the schemes defined in this document:</t>

      <t>
        <list style="symbols">
          <t>I2OSP - Integer-to-Octet-String primitive</t>
          <t>OS2IP - Octet-String-to-Integer primitive</t>
        </list>
      </t>

      <t>For the purposes of this document, and consistent with ASN.1 syntax, an octet string is an ordered sequence of octets (eight-bit bytes). The sequence is indexed from first (conventionally, leftmost) to last (rightmost). For purposes of conversion to and from integers, the first octet is considered the most significant in the following conversion primitives.</t>

     <section anchor="i2osp" title="I2OSP">
        <t>I2OSP converts a nonnegative integer to an octet string of a specified length.</t>

        <t>I2OSP (x, xLen)
          <list style="hanging">
            <t hangText="Input:">
              <list style="hanging" hangIndent="9">
                <t hangText="x">nonnegative integer to be converted</t>
                <t hangText="xLen">intended length of the resulting octet string</t>
              </list>
            </t>

            <t hangText="Output:">
              <list style="empty">
                <t>X        corresponding octet string of length xLen</t>
              </list>
            </t>

            <t hangText="Error:">"integer too large"</t>

             <t hangText="Steps:">
                <list style="numbers">
                  <t>If x &gt;= 256^xLen, output "integer too large" and stop.</t>

                  <t>Write the integer x in its unique xLen-digit representation in base 256:

                    <list style="empty"> 
                      <t>x = x_(xLen-1) 256^(xLen-1) + x_(xLen-2) 256^(xLen-2) + ... + x_1 256 + x_0,</t>
                    </list>
                  where 0 &lt;= x_i &lt; 256 (note that one or more leading digits will be zero if x is less than 256^(xLen-1)).
                  </t>

                  <t>Let the octet X_i have the integer value x_(xLen-i) for 1 &lt;= i &lt;= xLen.  Output the octet string
                    <list style="empty">
                      <t>X = X_1 X_2 ... X_xLen.</t>
                    </list>
                  </t>
                </list>
              </t>
          </list>
        </t>
     </section>

     <section anchor="os2ip" title="OS2IP">
        <t>OS2IP converts an octet string to a nonnegative integer.</t>

        <t>OS2IP (X)
          <list style="hanging">
            <t hangText="Input:">X        octet string to be converted</t>

            <t hangText="Output:">x        corresponding nonnegative integer</t>

            <t hangText="Steps:">
              <list style="numbers">
                <t>Let X_1 X_2 ... X_xLen be the octets of X from first to last,
      and let x_(xLen-i) be the integer value of the octet X_i for
      1 &lt;= i &lt;= xLen.</t>

                <t>Let x = x_(xLen-1) 256^(xLen-1) + x_(xLen-2) 256^(xLen-2) + ...
      + x_1 256 + x_0.</t>

                <t>Output x.</t>
              </list>
            </t>
          </list>
        </t>
     </section>
   </section>

   <section anchor="cryptographic_primitives" title="Cryptographic Primitives">
      <t>Cryptographic primitives are basic mathematical operations on which cryptographic schemes can be built. They are intended for implementation in hardware or as software modules and are not intended to provide security apart from a scheme.</t>
      <t>Four types of primitive are specified in this document, organized in pairs: encryption and decryption; and signature and verification.</t>
      <t>The specifications of the primitives assume that certain conditions are met by the inputs, in particular that RSA public and private keys are valid.</t>

     <section anchor="encrypt_decrypt_primitives" title="Encryption and Decryption Primitives">
        <t>An encryption primitive produces a ciphertext representative from a message representative under the control of a public key, and a decryption primitive recovers the message representative from the ciphertext representative under the control of the corresponding private key.</t>
        <t>One pair of encryption and decryption primitives is employed in the encryption schemes defined in this document and is specified here: RSA Encryption Primitive (RSAEP) / RSA Decryption Primitive (RSADP). RSAEP and RSADP involve the same mathematical operation, with different keys as input.
The primitives defined here are the same as Integer Factorization Encryption Primitive using RSA (IFEP-RSA) / Integer Factorization Decryption Primitive using RSA (IFDP-RSA) in IEEE 1363 <xref target="IEEE1363"/> (except that support for multi-prime RSA has been added) and are compatible with PKCS #1 v1.5.</t>

        <t>The main mathematical operation in each primitive is exponentiation.</t>


       <section anchor="rsaep" title="RSAEP">
          <t>RSAEP ((n, e), m)
            <list style="hanging">
              <t hangText="Input:">
                <list style="empty">
                  <t>(n, e)   RSA public key</t>
                  <t>m        message representative, an integer between 0 and n - 1</t>
                </list>
              </t>

              <t hangText="Output:">
              c        ciphertext representative, an integer between 0 and n - 1
              </t>

              <t hangText="Error:">"message representative out of range"</t>

              <t hangText="Assumption:">RSA public key (n, e) is valid</t>

              <t hangText="Steps:">
                <list style="numbers">
                  <t>If the message representative m is not between 0 and n - 1, output
                  "message representative out of range" and stop.</t>

                  <t>Let c = m^e mod n.</t>
                  <t>Output c.</t>
                </list>
              </t>
            </list>
          </t>
       </section>

       <section anchor="rsadp" title="RSADP">
          <t>RSADP (K, c)
            <list style="hanging">
              <t hangText="Input:">
                <list>
                  <t>K        RSA private key, where K has one of the following forms:
                    <list style="symbols">
                      <t>a pair (n, d)</t>
                      <t>a quintuple (p, q, dP, dQ, qInv) and a possibly empty sequence of triplets (r_i, d_i, t_i), i = 3, ..., u</t>
                    </list>
                  </t>
                  <t>c        ciphertext representative, an integer between 0 and n - 1</t>
                </list>
              </t>

              <t hangText="Output:">
                m        message representative, an integer between 0 and n - 1
              </t>
              <t hangText="Error:">"ciphertext representative out of range"</t>

              <t hangText="Assumption:">RSA private key K is valid</t>

              <t hangText="Steps:">
                <list style="numbers">
                  <t>If the ciphertext representative c is not between 0 and n - 1,
                  output "ciphertext representative out of range" and stop.</t>

                  <t>The message representative m is computed as follows.
                    <list style="letters">

                      <t>If the first form (n, d) of K is used, let m = c^d mod n.</t>

                      <t>If the second form (p, q, dP, dQ, qInv) and (r_i, d_i, t_i)
                      of K is used, proceed as follows:

                        <list style="format %i.">
                          <t>Let m_1 = c^dP mod p and m_2 = c^dQ mod q.</t>
                          <t>If u &gt; 2, let m_i = c^(d_i) mod r_i, i = 3, ..., u.</t>
                          <t>Let h = (m_1 - m_2) * qInv mod p.</t>
                          <t>Let m = m_2 + q * h.</t>
                          <t>If u &gt; 2, let R = r_1 and for i = 3 to u do
                            <list style="numbers">
                              <t>Let R = R * r_(i-1).</t>
                              <t>Let h = (m_i - m) * t_i mod r_i.</t>
                              <t>Let m = m + R * h.</t>
                            </list>
                          </t>
                        </list>
                      </t>
                    </list>
                  </t>
                  <t>Output m.</t>
                </list>
              </t>
            </list>
          </t>
          <t>Note: Step 2.b can be rewritten as a single loop, provided that one
          reverses the order of p and q.  For consistency with PKCS #1 v2.0,
          however, the first two primes p and q are treated separately from
          the additional primes.</t>
       </section>
     </section>
     
     <section title="Signature and Verification Primitives">
        <t>A signature primitive produces a signature representative from a message representative under the control of a private key, and a verification primitive recovers the message representative from the signature representative under the control of the corresponding public key. One pair of signature and verification primitives is employed in the signature schemes defined in this document and is specified here: RSA Signature Primitive, version 1 (RSASP1) / RSA Verification Primitive, version 1 (RSAVP1).</t>
        <t>The primitives defined here are the same as Integer Factorization Signature Primitive using RSA, version 1 (IFSP-RSA1) / Integer Factorization Verification Primitive using RSA, version 1 (IFVP-RSA1) in IEEE 1363 <xref target="IEEE1363"/> (except that support for multi-prime RSA has been added) and are compatible with PKCS #1 v1.5.</t>
        <t>The main mathematical operation in each primitive is exponentiation, as in the encryption and decryption primitives of <xref target="encrypt_decrypt_primitives"/>. RSASP1 and RSAVP1 are the same as RSADP and RSAEP except for the names of their input and output arguments; they are distinguished as they are intended for different purposes.</t>

       <section anchor="rsasp1" title="RSASP1">
          <t>RSASP1 (K, m)
            <list style="hanging">
              <t hangText="Input:">
                <figure>
                  <artwork align="left"><![CDATA[     
   K        RSA private key, where K has one of the following forms:
            - a pair (n, d)
            - a quintuple (p, q, dP, dQ, qInv) and a (possibly empty)
              sequence of triplets (r_i, d_i, t_i), i = 3, ..., u
   m        message representative, an integer between 0 and n - 1
]]>
                  </artwork>
                </figure>
              </t>
              <t hangText="Output:">
                <figure>
                  <artwork align="left"><![CDATA[
   s        signature representative, an integer between 0 and n - 1
]]></artwork>
                </figure>
              </t>
              <t hangText="Error:">"message representative out of range"</t>
              <t hangText="Assumption:">RSA private key K is valid</t>
              <t hangText="Steps:">
               <list style="numbers">
                  <t>If the message representative m is not between 0 and n - 1,
                  output "message representative out of range" and stop.</t>
                  <t>The signature representative s is computed as follows.
                    <list style="letters">
                      <t>If the first form (n, d) of K is used, let s = m^d mod n.</t>
                      <t>If the second form (p, q, dP, dQ, qInv) and (r_i, d_i, t_i)
                      of K is used, proceed as follows:
                        <list style="numbers">
                          <t>Let s_1 = m^dP mod p and s_2 = m^dQ mod q.</t>
                          <t>If u &gt; 2, let s_i = m^(d_i) mod r_i, i = 3, ..., u.</t>
                          <t>Let h = (s_1 - s_2) * qInv mod p.</t>
                          <t>Let s = s_2 + q * h.</t>
                          <t>If u &gt; 2, let R = r_1 and for i = 3 to u do
                            <list style="letters">
                              <t>Let R = R * r_(i-1).</t>
                              <t>Let h = (s_i - s) * t_i mod r_i.</t>
                              <t>Let s = s + R * h.</t>
                            </list>
                          </t>
                        </list>
                      </t>
                    </list>
                  </t>
                  <t>Output s.</t>
                </list>
              </t>
            </list>
          </t>
          
          <t>Note: Step 2.b can be rewritten as a single loop, provided that one
          reverses the order of p and q.  For consistency with PKCS #1 v2.0,
          however, the first two primes p and q are treated separately from the
          additional primes.</t>
       </section>
    
        <section anchor="rsavp1" title="RSAVP1">
          <t>RSAVP1 ((n, e), s)
            <list style="hanging">
              <t hangText="Input:">
                <list style="empty">
                  <t>(n, e)   RSA public key</t>
                  <t>s        signature representative, an integer between 0 and n - 1</t>
                </list>
              </t>
              <t hangText="Output:">
                <list style="empty">
                  <t>m        message representative, an integer between 0 and n - 1</t>
                </list>
              </t>
              <t hangText="Error:">"signature representative out of range"</t>
              <t hangText="Assumption:">RSA public key (n, e) is valid</t>
              <t hangText="Steps:">
                <list style="numbers">
                  <t>If the signature representative s is not between 0 and n - 1,
                  output "signature representative out of range" and stop.</t>
                  <t>Let m = s^e mod n.</t>
                  <t>Output m.</t>
                </list>
              </t>
            </list>
          </t>
        </section>
     </section>
   </section>

    <section anchor="overview_of_schemes" title="Overview of Schemes">
      <t>A scheme combines cryptographic primitives and other techniques to achieve a particular security goal. Two types of scheme are specified in this document: encryption schemes and signature schemes with appendix.</t>
      <t>The schemes specified in this document are limited in scope in that their operations consist only of steps to process data with an RSA public or private key, and they do not include steps for obtaining or validating the key. Thus, in addition to the scheme operations, an application will typically include key management operations by which parties may select RSA public and private keys for a scheme operation. The specific additional operations and other details are outside the scope of this document.</t>
      <t>As was the case for the cryptographic primitives (<xref target="cryptographic_primitives"/>), the specifications of scheme operations assume that certain conditions are met by the inputs, in particular that RSA public and private keys are valid. The behavior of an implementation is thus unspecified when a key is invalid. The impact of such unspecified behavior depends on the application. Possible means of addressing key validation include explicit key validation by the application; key validation within the public-key infrastructure; and assignment of liability for operations performed with an invalid key to the party who generated the key.</t>
      <t>A generally good cryptographic practice is to employ a given RSA key pair in only one scheme. This avoids the risk that vulnerability in one scheme may compromise the security of the other and may be essential to maintain provable security. While RSAES-PKCS1-v1_5 (<xref target="rsaes_pkcs1_v1_5"/>) and RSASSA-PKCS1-v1_5 (<xref target="rsassa_pkcs1_v1_5"/>) have traditionally been employed together without any known bad interactions (indeed, this is the model introduced by PKCS #1 v1.5), such a combined use of an RSA key pair is NOT RECOMMENDED for new applications.</t> 

      <t>To illustrate the risks related to the employment of an RSA key pair in more than one scheme, suppose an RSA key pair is employed in both RSAES-OAEP (<xref target="rsaes_oaep"/>) and RSAES-PKCS1-v1_5. Although RSAES-OAEP by itself would resist attack, an opponent might be able to exploit a weakness in the implementation of RSAES-PKCS1-v1_5 to recover messages encrypted with either scheme. As another example, suppose an RSA key pair is employed in both RSASSA-PSS (<xref target="rsassa_pss"/>) and RSASSA-PKCS1-v1_5. Then the security proof for RSASSA-PSS would no longer be sufficient since the proof does not account for the possibility that signatures might be generated with a second scheme. Similar considerations may apply if an RSA key pair is employed in one of the schemes defined here and in a variant defined elsewhere.</t>
   </section>

   <section anchor="encryption_schemes" title="Encryption Schemes">
      <t>For the purposes of this document, an encryption scheme consists of
      an encryption operation and a decryption operation, where the
      encryption operation produces a ciphertext from a message with a
      recipient's RSA public key, and the decryption operation recovers the
      message from the ciphertext with the recipient's corresponding RSA
      private key.</t>

      <t>An encryption scheme can be employed in a variety of applications. A typical application is a key establishment protocol, where the message contains key material to be delivered confidentially from one party to another. For instance, PKCS #7 <xref target="RFC2315"/> employs such a protocol to deliver a content-encryption key from a sender to a recipient; the encryption schemes defined here would be suitable key-encryption algorithms in that context.</t>
   
      <t>Two encryption schemes are specified in this document: RSAES-OAEP and RSAES-PKCS1-v1_5. RSAES-OAEP is REQUIRED to be supported for new applications; RSAES-PKCS1-v1_5 is included only for compatibility with existing applications.</t>
      <t>The encryption schemes given here follow a general model similar to that employed in IEEE 1363 <xref target="IEEE1363"/>, combining encryption and decryption primitives with an encoding method for encryption. The encryption operations apply a message encoding operation to a message to produce an encoded message, which is then converted to an integer message representative. An encryption primitive is applied to the message representative to produce the ciphertext. Reversing this, the decryption operations apply a decryption primitive to the ciphertext to recover a message representative, which is then converted to an octet-string-encoded message. A message decoding operation is applied to the encoded message to recover the message and verify the correctness of the decryption.</t>
   
      <t>To avoid implementation weaknesses related to the way errors are handled within the decoding operation (see <xref target="BLEICHENBACHER"/> and <xref target="MANGER"/>), the encoding and decoding operations for RSAES-OAEP and RSAES-PKCS1-v1_5 are embedded in the specifications of the respective encryption schemes rather than defined in separate specifications. Both encryption schemes are compatible with the corresponding schemes in PKCS #1 v2.1.</t>

      <section anchor="rsaes_oaep" title="RSAES-OAEP">
        <t>RSAES-OAEP combines the RSAEP and RSADP primitives (Sections <xref
	target="rsaep" format="counter"/> and <xref target="rsadp"
	format="counter"/>) with the EME-OAEP encoding method (Step 2 in <xref
	target="encryption_operation"/>, and Step 3 in <xref
	target="decryption_operation"/>). EME-OAEP is based on Bellare and
	Rogaway's Optimal Asymmetric Encryption scheme <xref target="OAEP"/>.

It is compatible with the Integer Factorization Encryption Scheme (IFES) defined in IEEE 1363 <xref target="IEEE1363"/>, where the encryption and decryption primitives are IFEP-RSA and IFDP-RSA and the message encoding method is EME-OAEP. RSAES-OAEP can operate on messages of length up to k - 2hLen -2 octets, where hLen is the length of the output from the underlying hash function and k is the length in octets of the recipient's RSA modulus.</t>

        <t>Assuming that computing e-th roots modulo n is infeasible and the
        mask generation function in RSAES-OAEP has appropriate properties,
        RSAES-OAEP is semantically secure against adaptive chosen-ciphertext
        attacks.  This assurance is provable in the sense that the difficulty
        of breaking RSAES-OAEP can be directly related to the difficulty of
        inverting the RSA function, provided that the mask generation
        function is viewed as a black box or random oracle; see <xref target="FOPS"/> and the
        note below for further discussion.</t>

        <t>Both the encryption and the decryption operations of RSAES-OAEP take
        the value of a label L as input.  In this version of PKCS #1, L is
        the empty string; other uses of the label are outside the scope of
        this document.  See <xref target="appendix_rsaes_oaep"/> for the relevant ASN.1 syntax.</t>

        <t>RSAES-OAEP is parameterized by the choice of hash function and mask
        generation function.  This choice should be fixed for a given RSA
        key.  Suggested hash and mask generation functions are given in
        <xref target="appendix_supporting"/>.</t>

        <t>Note: Past results have helpfully clarified the security properties of the OAEP encoding method <xref target="OAEP"/>  (roughly the procedure described in Step 2 in <xref target="encryption_operation"/>). The background is as follows. In 1994, Bellare and Rogaway <xref target="OAEP"/> introduced a security concept that they denoted plaintext awareness (PA94). They proved that if a deterministic public-key encryption primitive (e.g., RSAEP) is hard to invert without the private key, then the corresponding OAEP-based encryption scheme is plaintext aware (in the random oracle model), meaning roughly that an adversary cannot produce a valid ciphertext without actually "knowing" the underlying plaintext. Plaintext awareness of an encryption scheme is closely related to the resistance of the scheme against chosen-ciphertext attacks. In such attacks, an adversary is given the opportunity to send queries to an oracle simulating the decryption primitive. Using the results of these queries, the adversary attempts to decrypt a challenge ciphertext.</t>
        <t>However, there are two flavors of chosen-ciphertext attacks, and PA94 implies security against only one of them. The difference relies on what the adversary is allowed to do after she is given the challenge ciphertext. The indifferent attack scenario (denoted CCA1) does not admit any queries to the decryption oracle after the adversary is given the challenge ciphertext, whereas the adaptive scenario (denoted CCA2) does (except that the decryption oracle refuses to decrypt the challenge ciphertext once it is published). In 1998, Bellare and Rogaway, together with Desai and Pointcheval <xref target="PA98"/>, came up with a new, stronger notion of plaintext awareness (PA98) that does imply security against CCA2.</t>
        <t>To summarize, there have been two potential sources for misconception: that PA94 and PA98 are equivalent concepts, or that CCA1 and CCA2 are equivalent concepts. Either assumption leads to the conclusion that the Bellare-Rogaway paper implies security of OAEP against CCA2, which it does not.</t>  

        <t>(Footnote: It might be fair to mention that PKCS #1 v2.0 cites <xref target="OAEP"/>
        and claims that "a chosen ciphertext attack is ineffective against a
        plaintext-aware encryption scheme such as RSAES-OAEP" without
        specifying the kind of plaintext awareness or chosen ciphertext
        attack considered.)</t>

        <t>OAEP has never been proven secure against CCA2; in fact, Victor Shoup <xref target="SHOUP"/> has demonstrated that such a proof does not exist in the general case. Put briefly, Shoup showed that an adversary in the CCA2 scenario who knows how to partially invert the encryption primitive but does not know how to invert it completely may well be able to break the scheme. For example, one may imagine an attacker who is able to break RSAES-OAEP if she knows how to recover all but the first 20 bytes of a random integer encrypted with RSAEP. Such an attacker does not need to be able to fully invert RSAEP, because she does not use the first 20 octets in her attack.</t>

        <t>Still, RSAES-OAEP is secure against CCA2, which was proved by Fujisaki, Okamoto, Pointcheval, and Stern <xref target="FOPS"/> shortly after the announcement of Shoup's result. Using clever lattice reduction techniques, they managed to show how to invert RSAEP completely given a sufficiently large part of the pre-image. This observation, combined with a proof that OAEP is secure against CCA2 if the underlying encryption primitive is hard to partially invert, fills the gap between what Bellare and Rogaway proved about RSAES-OAEP and what some may have believed that they proved. Somewhat paradoxically, we are hence saved by an ostensible weakness in RSAEP (i.e., the whole inverse can be deduced from parts of it).</t> 

        <t>Unfortunately, however, the security reduction is not efficient for concrete parameters. While the proof successfully relates an adversary A against the CCA2 security of RSAES-OAEP to an algorithm I inverting RSA, the probability of success for I is only approximately \epsilon^2 / 2^18, where \epsilon is the probability of success for A.</t>  

       <t>(Footnote: In <xref target="FOPS"/>, the probability of success for the inverter was
        \epsilon^2 / 4.  The additional factor 1 / 2^16 is due to the eight
        fixed zero bits at the beginning of the encoded message EM, which are
        not present in the variant of OAEP considered in <xref target="FOPS"/>. (A must be applied
        twice to invert RSA, and each application corresponds to a factor
        1 / 2^8.))</t>

        <t>In addition, the running time for I is approximately t^2, where t is the running time of the adversary. The consequence is that we cannot exclude the possibility that attacking RSAES-OAEP is considerably easier than inverting RSA for concrete parameters. Still, the existence of a security proof provides some assurance that the RSAES&nbhy;OAEP construction is sounder than ad hoc constructions such as RSAES&nbhy;PKCS1-v1_5. </t>

        <t>Hybrid encryption schemes based on the RSA Key Encapsulation Mechanism (RSA-KEM) paradigm offer tight proofs of security directly applicable to concrete parameters; see <xref target="ISO18033"/> for discussion. Future versions of PKCS #1 may specify schemes based on this paradigm.</t>

        <section anchor="encryption_operation" title="Encryption Operation">
          <t>RSAES-OAEP-ENCRYPT ((n, e), M, L)
            <list style="hanging">
              <t hangText="Options:">
                <figure>
                  <artwork align="left"><![CDATA[
   Hash     hash function (hLen denotes the length in octets of 
            the hash function output)
   MGF      mask generation function
]]></artwork>
                </figure>
              </t>
              <t hangText="Input:">
                <figure>
                  <artwork align="left"><![CDATA[
   (n, e)   recipient's RSA public key (k denotes the length in 
            octets of the RSA modulus n)
   M        message to be encrypted, an octet string of length mLen,
            where mLen <= k - 2hLen - 2
   L        optional label to be associated with the message; the
            default value for L, if L is not provided, is the empty
            string
]]></artwork>
                </figure>
              </t>
              <t hangText="Output:">
                <figure>
                  <artwork align="left"><![CDATA[
   C        ciphertext, an octet string of length k
]]></artwork>
                </figure>
              </t>
              <t hangText="Errors:">"message too long"; "label too long"</t>
              <t hangText="Assumption:">RSA public key (n, e) is valid</t>
              <t hangText="Steps:">
                <list style="numbers">
                  <t>Length checking:
                    <list style="letters">
                      <t>If the length of L is greater than the input limitation for the
                      hash function (2^61 - 1 octets for SHA-1), output "label too
                      long" and stop.</t>
                      <t>If mLen > k - 2hLen - 2, output "message too long" and stop.</t>
                    </list>
                  </t>
                  <t>EME-OAEP encoding (see Figure 1 below):
                    <list style="letters">
                      <t>If the label L is not provided, let L be the empty string. Let
                      lHash = Hash(L), an octet string of length hLen (see the note
                      below).</t>

                <t>Generate a padding string PS consisting of k - mLen - 2hLen - 2
                      zero octets.  The length of PS may be zero.</t>
                      <t>Concatenate lHash, PS, a single octet with hexadecimal value
                      0x01, and the message M to form a data block DB of length k -
                      hLen - 1 octets as
                        <list style="empty">
                          <t>DB = lHash || PS || 0x01 || M.</t>
                        </list>
                      </t>
                      <t>Generate a random octet string seed of length hLen.</t>
                      <t>Let dbMask = MGF(seed, k - hLen - 1).</t>
                      <t>Let maskedDB = DB \xor dbMask.</t>
                      <t>Let seedMask = MGF(maskedDB, hLen).</t>
                      <t>Let maskedSeed = seed \xor seedMask.</t>
                      <t>Concatenate a single octet with hexadecimal value 0x00,
                      maskedSeed, and maskedDB to form an encoded message EM of
                      length k octets as
                        <list style="empty">
                          <t>EM = 0x00 || maskedSeed || maskedDB.</t>
                        </list>
                      </t>
                    </list>
                  </t>
                  <t>RSA encryption:
                    <list style="letters">
                      <t>Convert the encoded message EM to an integer message
                      representative m (see <xref target="os2ip"/>):
                        <list style="empty">
                          <t>m = OS2IP (EM).</t>
                        </list>
                      </t>
                      <t>Apply the RSAEP encryption primitive (<xref target="rsaep"/>) to the RSA
                      public key (n, e) and the message representative m to produce
                      an integer ciphertext representative c:
                        <list style="empty">
                          <t>c = RSAEP ((n, e), m).</t>
                        </list>
                      </t>
                      <t>Convert the ciphertext representative c to a ciphertext C of
                      length k octets (see <xref target="i2osp"/>):
                        <list style="empty">
                          <t>C = I2OSP (c, k).</t>
                        </list>
                      </t>
                    </list>
                  </t>
                  <t>Output the ciphertext C.</t>
                </list>
              </t>
            </list>
          </t>

          <figure align="center">

            <artwork align="left"><![CDATA[
   _________________________________________________________________

                             +----------+------+--+-------+
                        DB = |  lHash   |  PS  |01|   M   |
                             +----------+------+--+-------+
                                            |
                  +----------+              |
                  |   seed   |              |
                  +----------+              |
                        |                   |
                        |-------> MGF ---> xor
                        |                   |
               +--+     V                   |
               |00|    xor <----- MGF <-----|
               +--+     |                   |
                 |      |                   |
                 V      V                   V
               +--+----------+----------------------------+
         EM =  |00|maskedSeed|          maskedDB          |
               +--+----------+----------------------------+
   _________________________________________________________________
]]></artwork>

            <postamble>Figure 1: EME-OAEP Encoding Operation
            </postamble>
          </figure>

      <t>Notes:
      <list style="hanging">
      <t hangText="-"> lHash is the hash of the optional label L.</t>
      <t hangText="-"> The decoding operation follows reverse steps to recover M 
           and verify lHash and PS.</t>
      <t hangText="-"> If L is the empty string, the corresponding hash value lHash
           has the following hexadecimal representation for different choices of
           Hash:</t></list>
            </t>
           
        <figure>
           <artwork align="left"><![CDATA[
   SHA-1:   (0x)da39a3ee 5e6b4b0d 3255bfef 95601890 afd80709
   SHA-256: (0x)e3b0c442 98fc1c14 9afbf4c8 996fb924 27ae41e4 649b934c
                a495991b 7852b855
   SHA-384: (0x)38b060a7 51ac9638 4cd9327e b1b1e36a 21fdb711 14be0743
                4c0cc7bf 63f6e1da 274edebf e76f65fb d51ad2f1 4898b95b
   SHA-512: (0x)cf83e135 7eefb8bd f1542850 d66d8007 d620e405 0b5715dc
                83f4a921 d36ce9ce 47d0d13c 5d85f2b0 ff8318d2 877eec2f
                63b931bd 47417a81 a538327a f927da3e
]]></artwork>
          </figure>

        </section>

        <section anchor="decryption_operation" title="Decryption Operation">

          <t>RSAES-OAEP-DECRYPT (K, C, L)
            <list style="hanging">
              <t hangText="Options:">
                <figure>
                  <artwork align="left"><![CDATA[
   Hash     hash function (hLen denotes the length in octets of 
            the hash function output)
   MGF      mask generation function
]]></artwork>
                </figure>
              </t>
              <t hangText="Input:">
                <figure>
                  <artwork align="left"><![CDATA[
   K        recipient's RSA private key (k denotes the length in 
            octets of the RSA modulus n), where k >= 2hLen + 2
   C        ciphertext to be decrypted, an octet string of length k
   L        optional label whose association with the message is to 
            be verified; the default value for L, if L is not 
            provided, is the empty string
]]></artwork>
               </figure>
              </t>
              <t hangText="Output:">
                <figure>
                  <artwork align="left"><![CDATA[
   M        message, an octet string of length mLen, where 
            mLen <= k - 2hLen - 2
]]></artwork>
                </figure>
              </t>
              <t hangText="Error:">"decryption error"</t>
              <t hangText="Steps:">
                <list style="numbers">
                  <t>Length checking:
                    <list style="letters">
                      <t>If the length of L is greater than the input limitation for the
                      hash function (2^61 - 1 octets for SHA-1), output "decryption
                      error" and stop.</t>

                      <t>If the length of the ciphertext C is not k octets, output
                      "decryption error" and stop.</t>

                      <t>If k &lt; 2hLen + 2, output "decryption error" and stop.</t>
                    </list>
                  </t>

                  <t>RSA decryption:
                    <list style="letters">
                      <t>Convert the ciphertext C to an integer ciphertext representative c (see <xref target="os2ip"/>):
                        <list style="empty">
                          <t>c = OS2IP (C).</t>
                        </list>
                      </t>

                      <t>Apply the RSADP decryption primitive (<xref target="rsadp"/>) to the
                      RSA private key K and the ciphertext representative c to
                      produce an integer message representative m:
                        <list style="empty">
                          <t>m = RSADP (K, c).</t>
                        </list>
                        If RSADP outputs "ciphertext representative out of range"
                        (meaning that c &gt;= n), output "decryption error" and stop.
                      </t>

                      <t>Convert the message representative m to an encoded message EM
                      of length k octets (see <xref target="i2osp"/>):
                        <list style="empty">
                          <t>EM = I2OSP (m, k).</t>
                        </list>
                      </t>
                    </list>
                  </t>

                  <t>EME-OAEP decoding:
                    <list style="letters">
                      <t>If the label L is not provided, let L be the empty string. Let
                      lHash = Hash(L), an octet string of length hLen (see the note
                      in <xref target="encryption_operation"/>).</t>
                      <t>Separate the encoded message EM into a single octet Y, an octet
                      string maskedSeed of length hLen, and an octet string maskedDB
                      of length k - hLen - 1 as
                        <list style="empty">
                          <t>EM = Y || maskedSeed || maskedDB.</t>
                        </list>
                      </t>
                      <t>Let seedMask = MGF(maskedDB, hLen).</t>
                      <t>Let seed = maskedSeed \xor seedMask.</t>
                      <t>Let dbMask = MGF(seed, k - hLen - 1).</t>
                      <t>Let DB = maskedDB \xor dbMask.</t>
                      <t>Separate DB into an octet string lHash' of length hLen, a
                      (possibly empty) padding string PS consisting of octets with
                      hexadecimal value 0x00, and a message M as
                        <list style="empty">
                          <t>DB = lHash' || PS || 0x01 || M.</t>
                        </list>
                        If there is no octet with hexadecimal value 0x01 to separate PS
                        from M, if lHash does not equal lHash', or if Y is nonzero,
                        output "decryption error" and stop.  (See the note below.)
                      </t>
                    </list>
                  </t>

                  <t>Output the message M.</t>
                </list>
               Note: Care must be taken to ensure that an opponent cannot
                distinguish the different error conditions in Step 3.g, whether by
                error message or timing, and, more generally, that an opponent cannot learn partial
                information about the encoded message EM.  Otherwise, an opponent may
                be able to obtain useful information about the decryption of the
                ciphertext C, leading to a chosen-ciphertext attack such as the one
                observed by Manger <xref target="MANGER"/>.
             </t>
            </list>
          </t>
        </section>
        
      </section>

      <section anchor="rsaes_pkcs1_v1_5" title="RSAES-PKCS1-v1_5">

        <t>RSAES-PKCS1-v1_5 combines the RSAEP and RSADP primitives (Sections
        <xref target="rsaep" format="counter"/> and <xref target="rsadp" format="counter"/>) with the EME-PKCS1-v1_5 encoding method (Step 2 in
        <xref target="encryption_operation_v1_5"/>, and Step 3 in <xref target="decryption_operation_v1_5"/>).  It is mathematically
        equivalent to the encryption scheme in PKCS #1 v1.5.  RSAES&nbhy;PKCS1&nbhy;v1_5
        can operate on messages of length up to k - 11 octets (k is the
        octet length of the RSA modulus), although care should be taken to
        avoid certain attacks on low-exponent RSA due to Coppersmith,
        Franklin, Patarin, and Reiter when long messages are encrypted (see
        the third bullet in the notes below and <xref target="LOWEXP"/>; <xref target="NEWATTACK"/> contains an
        improved attack).  As a general rule, the use of this scheme for
        encrypting an arbitrary message, as opposed to a randomly generated
        key, is NOT RECOMMENDED.</t>

        <t>It is possible to generate valid RSAES-PKCS1-v1_5 ciphertexts without
        knowing the corresponding plaintexts, with a reasonable probability
        of success.  This ability can be exploited in a chosen-ciphertext
        attack as shown in <xref target="BLEICHENBACHER"/>.  Therefore, if RSAES-PKCS1-v1_5 is to be
        used, certain easily implemented countermeasures should be taken to
        thwart the attack found in <xref target="BLEICHENBACHER"/>.  Typical examples include the
        addition of structure to the data to be encoded, rigorous checking of
        PKCS #1 v1.5 conformance (and other redundancy) in decrypted
        messages, and the consolidation of error messages in a client-server
        protocol based on PKCS #1 v1.5.  These can all be effective
        countermeasures and do not involve changes to a protocol based on PKCS #1 v1.5. 
        See <xref target="BKS"/> for a further discussion of these and other
        countermeasures.  It has recently been shown that the security of the
        SSL/TLS handshake 
        protocol <xref target="RFC5246"/>, which uses RSAES-PKCS1-v1_5 and
        certain countermeasures, can be related to a variant of the RSA
        problem; see <xref target="RSATLS"/> for discussion.</t>

        <t>Note: The following passages describe some security recommendations
        pertaining to the use of RSAES-PKCS1-v1_5.  Recommendations from
        PKCS #1 v1.5 are included as well as new
        recommendations motivated by cryptanalytic advances made in the
        intervening years.
          <list style="symbols">
            <t>It is RECOMMENDED that the pseudorandom octets in Step 2 in
            <xref target="encryption_operation_v1_5"/> be generated independently for each encryption
            process, especially if the same data is input to more than one
            encryption process.  Haastad's results <xref target="HAASTAD"/> are one motivation for
            this recommendation.</t>

            <t>The padding string PS in Step 2 in <xref target="encryption_operation_v1_5"/> is at least eight
            octets long, which is a security condition for public-key
            operations that makes it difficult for an attacker to recover data
            by trying all possible encryption blocks.</t>

            <t>The pseudorandom octets can also help thwart an attack due to
            Coppersmith et al. <xref target="LOWEXP"/> (see <xref target="NEWATTACK"/> for an improvement of the
            attack) when the size of the message to be encrypted is kept
            small.  The attack works on low-exponent RSA when similar messages
            are encrypted with the same RSA public key.  More specifically, in
            one flavor of the attack, when two inputs to RSAEP agree on a
            large fraction of bits (8/9) and low-exponent RSA (e = 3) is used
            to encrypt both of them, it may be possible to recover both inputs
            with the attack.  Another flavor of the attack is successful in
            decrypting a single ciphertext when a large fraction (2/3) of the
            input to RSAEP is already known.  For typical applications, the
            message to be encrypted is short (e.g., a 128-bit symmetric key),
            so not enough information will be known or common between two
            messages to enable the attack.  However, if a long message is
            encrypted, or if part of a message is known, then the attack may
            be a concern.  In any case, the RSAES-OAEP scheme overcomes the
            attack.</t>
          </list>
        </t>

        <section anchor="encryption_operation_v1_5" title="Encryption Operation">
          <t>RSAES-PKCS1-V1_5-ENCRYPT ((n, e), M)
            <list style="hanging">
              <t hangText="Input:">
                <figure>
                  <artwork align="left"><![CDATA[
   (n, e)   recipient's RSA public key (k denotes the length in
            octets of the modulus n)
   M        message to be encrypted, an octet string of length
            mLen, where mLen <= k - 11
]]></artwork>
                </figure>
              </t>
              <t hangText="Output:">
                <figure>
                  <artwork align="left"><![CDATA[
   C        ciphertext, an octet string of length k
]]></artwork>
                </figure>
              </t>
              <t hangText="Error:">"message too long"</t>
              <t hangText="Steps:">
                <list style="numbers">
                  <t>Length checking: If mLen &gt; k - 11, output "message too long" and stop.</t>
                  <t>EME-PKCS1-v1_5 encoding:
                    <list style="letters">
                      <t>Generate an octet string PS of length k - mLen - 3 consisting
                      of pseudo-randomly generated nonzero octets.  The length of PS
                      will be at least eight octets.</t>
                      <t>Concatenate PS, the message M, and other padding to form an
                      encoded message EM of length k octets as
                        <list style="empty">
                          <t>EM = 0x00 || 0x02 || PS || 0x00 || M.</t>
                        </list>
                      </t>
                    </list>
                  </t>
                  <t>RSA encryption:
                    <list style="letters">
                      <t>Convert the encoded message EM to an integer message
                      representative m (see <xref target="os2ip"/>):
                        <list style="empty">
                          <t>m = OS2IP (EM).</t>
                        </list>
                      </t>
                      <t>Apply the RSAEP encryption primitive (<xref target="rsaep"/>) to the RSA
                      public key (n, e) and the message representative m to produce
                      an integer ciphertext representative c:
                        <list style="empty">
                          <t>c = RSAEP ((n, e), m).</t>
                        </list>
                      </t>
                      <t>Convert the ciphertext representative c to a ciphertext C of
                      length k octets (see <xref target="i2osp"/>):
                        <list style="empty">
                          <t>C = I2OSP (c, k). </t>
                        </list>
                      </t>
                    </list>
                  </t>
                  <t>Output the ciphertext C.</t>
                </list>
              </t>
            </list>
          </t>
        </section>
    
        <section anchor="decryption_operation_v1_5" title="Decryption Operation">
          <t>RSAES-PKCS1-V1_5-DECRYPT (K, C)
            <list style="hanging">
              <t hangText="Input:">
                <figure>
                  <artwork align="left"><![CDATA[
   K        recipient's RSA private key
   C        ciphertext to be decrypted, an octet string of length k,
            where k is the length in octets of the RSA modulus n
]]></artwork>
                </figure>
              </t>

              <t hangText="Output:">
                <figure>
                  <artwork align="left"><![CDATA[
   M        message, an octet string of length at most k - 11
]]></artwork>
                </figure>
              </t>
              <t hangText="Error:">"decryption error"</t>
              <t hangText="Steps:">
                <list style="numbers">
                  <t>Length checking: If the length of the ciphertext C is not k octets
                  (or if k &lt; 11), output "decryption error" and stop.</t>
                  <t>RSA decryption:
                    <list style="letters">
                      <t>Convert the ciphertext C to an integer ciphertext representative c (see <xref target="os2ip"/>):
                        <list style="empty">
                          <t>c = OS2IP (C).</t>
                        </list>
                      </t>
                      <t>Apply the RSADP decryption primitive (<xref target="rsadp"/>) to the RSA
                      private key (n, d) and the ciphertext representative c to
                      produce an integer message representative m:
                        <list style="empty">
                          <t>m = RSADP ((n, d), c).</t>
                        </list>
                        If RSADP outputs "ciphertext representative out of range"
                        (meaning that c &gt;= n), output "decryption error" and stop.
                      </t>
                      <t>Convert the message representative m to an encoded message EM of length k octets (see <xref target="i2osp"/>):
                        <list style="empty">
                          <t>EM = I2OSP (m, k).</t>
                        </list>
                      </t>
                    </list>
                  </t>
                  <t>EME-PKCS1-v1_5 decoding: Separate the encoded message EM into an
                  octet string PS consisting of nonzero octets and a message M as
                    <list style="empty">
                      <t>EM = 0x00 || 0x02 || PS || 0x00 || M.</t>
                    </list>
                    If the first octet of EM does not have hexadecimal value 0x00, if
                    the second octet of EM does not have hexadecimal value 0x02, if
                    there is no octet with hexadecimal value 0x00 to separate PS from
                    M, or if the length of PS is less than 8 octets, output
                    "decryption error" and stop.  (See the note below.) 
                  </t>
                  <t>Output M.</t>
                </list>
                Note: Care shall be taken to ensure that an opponent cannot
                distinguish the different error conditions in Step 3, whether by
                error message or timing.  Otherwise, an opponent may be able to obtain
                useful information about the decryption of the ciphertext C, leading
                to a strengthened version of Bleichenbacher's attack <xref target="BLEICHENBACHER"/>; compare to
                Manger's attack <xref target="MANGER"/>.
              </t>
            </list>
          </t>
          
        </section>
      </section>
   </section>

   <section anchor="signature_scheme_with_appendix" title="Signature Scheme with Appendix">

     <t>For the purposes of this document, a signature scheme with appendix consists of a signature generation operation and a signature verification operation, where the signature generation operation produces a signature from a message with a signer's RSA private key, and the signature verification operation verifies the signature on the message with the signer's corresponding RSA public key. To verify a signature constructed with this type of scheme, it is necessary to have the message itself. In this way, signature schemes with appendix are distinguished from signature schemes with message recovery, which are not supported in this document.</t>
   
     <t>A signature scheme with appendix can be employed in a variety of applications. For instance, the signature schemes with appendix defined here would be suitable signature algorithms for X.509 certificates <xref target="ISO9594"/>. Related signature schemes could be employed in PKCS #7 <xref target="RFC2315"/>, although for technical reasons the current version of PKCS #7 separates a hash function from a signature scheme, which is different than what is done here; see the note in <xref target="appendix_rsassa_pss"/> for more discussion.</t>

     <t>Two signature schemes with appendix are specified in this document: RSASSA-PSS and RSASSA-PKCS1-v1_5. Although no attacks are known against RSASSA-PKCS1-v1_5, in the interest of increased robustness, RSASSA-PSS is REQUIRED in new applications. RSASSA-PKCS1-v1_5 is included only for compatibility with existing applications.</t>
   
     <t>The signature schemes with appendix given here follow a general model similar to that employed in IEEE 1363 <xref target="IEEE1363"/>, combining signature and verification primitives with an encoding method for signatures. The signature generation operations apply a message encoding operation to a message to produce an encoded message, which is then converted to an integer message representative. A signature primitive is applied to the message representative to produce the signature. Reversing this, the signature verification operations apply a signature verification primitive to the signature to recover a message representative, which is then converted to an octet-string-encoded message. A verification operation is applied to the message and the encoded message to determine whether they are consistent.</t>
   
     <t>If the encoding method is deterministic (e.g., EMSA-PKCS1-v1_5), the verification operation may apply the message encoding operation to the message and compare the resulting encoded message to the previously derived encoded message. If there is a match, the signature is considered valid. If the method is randomized (e.g., EMSA-PSS), the verification operation is typically more complicated. For example, the verification operation in EMSA-PSS extracts the random salt and a hash output from the encoded message and checks whether the hash output, the salt, and the message are consistent; the hash output is a deterministic function in terms of the message and the salt.
For both signature schemes with appendix defined in this document, the signature generation and signature verification operations are readily implemented as "single-pass" operations if the signature is placed after the message. See PKCS #7 <xref target="RFC2315"/> for an example format in the case of RSASSA-PKCS1-v1_5.</t>

     <section anchor="rsassa_pss" title="RSASSA-PSS">

        <t>RSASSA-PSS combines the RSASP1 and RSAVP1 primitives with the EMSA&nbhy;PSS encoding method. It is compatible with the Integer Factorization Signature Scheme with Appendix (IFSSA) as amended in IEEE 1363a <xref target="IEEE1363A"/>, where the signature and verification primitives are IFSP-RSA1 and IFVP-RSA1 as defined in IEEE 1363 <xref target="IEEE1363"/>, and the message encoding method is EMSA4. EMSA4 is slightly more general than EMSA-PSS as it acts on bit strings rather than on octet strings. EMSA-PSS is equivalent to EMSA4 restricted to the case that the operands as well as the hash and salt values are octet strings.</t>

        <t>The length of messages on which RSASSA-PSS can operate is either unrestricted or constrained by a very large number, depending on the hash function underlying the EMSA-PSS encoding method.</t>

        <t>Assuming that computing e-th roots modulo n is infeasible and the
	hash and mask generation functions in EMSA-PSS have appropriate
	properties, RSASSA-PSS provides secure signatures. This assurance is
	provable in the sense that the difficulty of forging signatures can be
	directly related to the difficulty of inverting the RSA function,
	provided that the hash and mask generation functions are viewed as
	black boxes or random oracles. The bounds in the security proof are
	essentially "tight", meaning that the success probability and running
	time for the best forger against RSASSA-PSS are very close to the
	corresponding parameters for the best RSA inversion algorithm; see
	<xref target="RSARABIN"/> <xref target="PSSPROOF"/> <xref target="JONSSON"/> for further discussion.</t>

        <t>In contrast to the RSASSA-PKCS1-v1_5 signature scheme, a hash function identifier is not embedded in the EMSA-PSS encoded message, so in theory it is possible for an adversary to substitute a different (and potentially weaker) hash function than the one selected by the signer. Therefore, it is RECOMMENDED that the EMSA&nbhy;PSS mask generation function be based on the same hash function. In this manner, the entire encoded message will be dependent on the hash function, and it will be difficult for an opponent to substitute a different hash function than the one intended by the signer. This matching of hash functions is only for the purpose of preventing hash function substitution and is not necessary if hash function substitution is addressed by other means (e.g., the verifier accepts only a designated hash function). See <xref target="HASHID"/> for further discussion of these points. The provable security of RSASSA-PSS does not rely on the hash function in the mask generation function being the same as the hash function applied to the message.</t>

        <t>RSASSA-PSS is different from other RSA-based signature schemes in that it is probabilistic rather than deterministic, incorporating a randomly generated salt value. The salt value enhances the security of the scheme by affording a "tighter" security proof than deterministic alternatives such as Full Domain Hashing (FDH); see <xref target="RSARABIN"/> for discussion. However, the randomness is not critical to security. In situations where random generation is not possible, a fixed value or a sequence number could be employed instead, with the resulting provable security similar to that of FDH <xref target="FDH"/>.</t>

        <section title="Signature Generation Operation">
          <t>RSASSA-PSS-SIGN (K, M)
            <list style="hanging">
              <t hangText="Input:">
                <figure>
                  <artwork align="left"><![CDATA[
   K        signer's RSA private key
   M        message to be signed, an octet string
]]></artwork>
                </figure>
              </t>
              <t hangText="Output:">
                <figure>
                  <artwork align="left"><![CDATA[
   S        signature, an octet string of length k, where k is the
            length in octets of the RSA modulus n
]]></artwork>
                </figure>
              </t>
              <t hangText="Errors:">"message too long;" "encoding error"</t>
             <t hangText="Steps:">
                <list style="numbers">
                  <t>EMSA-PSS encoding: Apply the EMSA-PSS encoding operation (<xref target="encoding_operation"/>) 
                  to the message M to produce an encoded message EM of length
                  \ceil ((modBits - 1)/8) octets such that the bit length of the
                  integer OS2IP (EM) (see <xref target="os2ip"/>) is at most modBits - 1, where
                  modBits is the length in bits of the RSA modulus n:
                    <list style="empty">
                      <t>EM = EMSA-PSS-ENCODE (M, modBits - 1).</t>
                    </list>
                    Note that the octet length of EM will be one less than k if
                    modBits - 1 is divisible by 8 and equal to k otherwise.  If the
                    encoding operation outputs "message too long", output "message too
                    long" and stop.  If the encoding operation outputs "encoding
                    error", output "encoding error" and stop.
                  </t>
                  <t>RSA signature:
                    <list style="letters">
                      <t>Convert the encoded message EM to an integer message representative m (see <xref target="os2ip"/>):
                        <list style="empty">
                          <t>m = OS2IP (EM).</t>
                        </list>
                      </t>
                      <t>Apply the RSASP1 signature primitive (<xref target="rsasp1"/>) to the RSA
                      private key K and the message representative m to produce an
                      integer signature representative s:
                        <list style="empty">
                          <t>s = RSASP1 (K, m).</t>
                        </list>
                      </t>
                      <t>Convert the signature representative s to a signature S of length k octets (see <xref target="i2osp"/>):
                        <list style="empty">
                          <t>S = I2OSP (s, k).</t>
                        </list>
                      </t>
                   </list>
                  </t>
                 <t>Output the signature S.</t>
                </list>
              </t>
            </list>
          </t>
        </section>

        <section title="Signature Verification Operation">
          <t>RSASSA-PSS-VERIFY ((n, e), M, S)
            <list style="hanging">
              <t hangText="Input:">
               <figure>
                  <artwork align="left"><![CDATA[
   (n, e)  signer's RSA public key
   M       message whose signature is to be verified, an octet string
   S       signature to be verified, an octet string of length k, 
           where k is the length in octets of the RSA modulus n
]]></artwork>
                </figure>
              </t>
              <t hangText="Output:">"valid signature" or "invalid signature"</t>
             <t hangText="Steps:">
                <list style="numbers">
                  <t>Length checking: If the length of the signature S is not k octets,
                  output "invalid signature" and stop.</t>
                 <t>RSA verification:
                    <list style="letters">
                      <t>Convert the signature S to an integer signature representative s (see <xref target="os2ip"/>):
                        <list style="empty">
                          <t>s = OS2IP (S).</t>
                        </list>
                      </t>
                      <t>Apply the RSAVP1 verification primitive (<xref target="rsavp1"/>) to the
                      RSA public key (n, e) and the signature representative s to
                      produce an integer message representative m:
                        <list style="empty">
                          <t>m = RSAVP1 ((n, e), s).</t>
                        </list>
                        If RSAVP1 output "signature representative out of range", output "invalid signature" and stop.
                      </t>

                      <t>Convert the message representative m to an encoded message EM
                      of length emLen = \ceil ((modBits - 1)/8) octets, where modBits
                      is the length in bits of the RSA modulus n (see <xref target="i2osp"/>):
                       <list style="empty">
                          <t>EM = I2OSP (m, emLen).</t>
                        </list>
                        Note that emLen will be one less than k if modBits - 1 is
                        divisible by 8 and equal to k otherwise.  If I2OSP outputs
                        "integer too large", output "invalid signature" and stop.
                      </t>
                    </list>
                  </t>
                 <t>EMSA-PSS verification: Apply the EMSA-PSS verification operation
                  (<xref target="verification_operation"/>) to the message M and the encoded message EM to
                  determine whether they are consistent:
                    <list style="empty">
                      <t>Result = EMSA-PSS-VERIFY (M, EM, modBits - 1).</t>
                    </list>
                  </t>
                 <t>If Result = "consistent", output "valid signature". Otherwise, output "invalid signature".</t>
                </list>
              </t>
                </list>
          </t>
        </section>

      </section>

      <section anchor="rsassa_pkcs1_v1_5" title="RSASSA-PKCS1-v1_5">
        <t>RSASSA-PKCS1-v1_5 combines the RSASP1 and RSAVP1 primitives with the EMSA-PKCS1-v1_5 encoding method. It is compatible with the IFSSA scheme defined in IEEE 1363 <xref target="IEEE1363"/>, where the signature and verification primitives are IFSP-RSA1 and IFVP-RSA1, and the message encoding method is EMSA-PKCS1-v1_5 (which is not defined in IEEE 1363 but is in IEEE 1363a <xref target="IEEE1363A"/>).</t>

        <t>The length of messages on which RSASSA-PKCS1-v1_5 can operate is either unrestricted or constrained by a very large number, depending on the hash function underlying the EMSA-PKCS1-v1_5 method.</t>

        <t>Assuming that computing e-th roots modulo n is infeasible and the hash function in EMSA-PKCS1-v1_5 has appropriate properties, RSASSA&nbhy;PKCS1&nbhy;v1_5 is conjectured to provide secure signatures. More precisely, forging signatures without knowing the RSA private key is conjectured to be computationally infeasible. Also, in the encoding method EMSA-PKCS1-v1_5, a hash function identifier is embedded in the encoding. Because of this feature, an adversary trying to find a message with the same signature as a previously signed message must find collisions of the particular hash function being used; attacking a different hash function than the one selected by the signer is not useful to the adversary. See <xref target="HASHID"/> for further discussion.</t>

        <t>Note: As noted in PKCS #1 v1.5, the EMSA-PKCS1-v1_5 encoding method has the property that the encoded message, converted to an integer message representative, is guaranteed to be large and at least somewhat "random". This prevents attacks of the kind proposed by Desmedt and Odlyzko <xref target="CHOSEN"/> where multiplicative relationships between message representatives are developed by factoring the message representatives into a set of small values (e.g., a set of small primes). Coron, Naccache, and Stern <xref target="PADDING"/> showed that a stronger form of this type of attack could be quite effective against some instances of the ISO/IEC 9796-2 signature scheme. They also analyzed the complexity of this type of attack against the EMSA&nbhy;PKCS1&nbhy;v1_5 encoding method and concluded that an attack would be impractical, requiring more operations than a collision search on the underlying hash function (i.e., more than 2^80 operations). Coppersmith, Halevi, and Jutla <xref target="FORGERY"/> subsequently extended Coron et al.'s attack to break the ISO/IEC 9796-1 signature scheme with message recovery. The various attacks illustrate the importance of carefully constructing the input to the RSA signature primitive, particularly in a signature scheme with message recovery. Accordingly, the EMSA-PKCS-v1_5 encoding method explicitly includes a hash operation and is not intended for signature schemes with message recovery. Moreover, while no attack is known against the EMSA&nbhy;PKCS&nbhy;v1_5 encoding method, a gradual transition to EMSA-PSS is recommended as a precaution against future developments.</t>

        <section title="Signature Generation Operation">

          <t>RSASSA-PKCS1-V1_5-SIGN (K, M)
            <list style="hanging">
             <t hangText="Input:">
                <figure>
                  <artwork align="left"><![CDATA[
   K        signer's RSA private key
   M        message to be signed, an octet string
]]></artwork>
                </figure>
              </t>
              <t hangText="Output:">
               <figure>
                  <artwork align="left"><![CDATA[
   S        signature, an octet string of length k, where k is the
            length in octets of the RSA modulus n
]]></artwork>
                </figure>
              </t>
              <t hangText="Errors:">"message too long"; "RSA modulus too short"</t>
             <t hangText="Steps:">
                <list style="numbers">
                  <t>EMSA-PKCS1-v1_5 encoding: Apply the EMSA-PKCS1-v1_5 encoding
                  operation (<xref target="emsa_pkcs1_v1_5"/>) to the message M to produce an encoded
                  message EM of length k octets:
                   <list style="empty">
                      <t>EM = EMSA-PKCS1-V1_5-ENCODE (M, k).</t>
                   </list>
                    If the encoding operation outputs "message too long", output
                    "message too long" and stop.  If the encoding operation outputs
                    "intended encoded message length too short", output "RSA modulus
                    too short" and stop.
                  </t>
                  <t>RSA signature:
                    <list style="letters">
                      <t>Convert the encoded message EM to an integer message representative m (see <xref target="os2ip"/>):
                        <list style="empty">
                          <t>m = OS2IP (EM).</t>
                        </list>
                      </t>
                      <t>Apply the RSASP1 signature primitive (<xref target="rsasp1"/>) to the RSA
                      private key K and the message representative m to produce an
                      integer signature representative s:
                        <list style="empty">
                          <t>s = RSASP1 (K, m).</t>
                        </list>
                      </t>
                     <t>Convert the signature representative s to a signature S of length k octets (see <xref target="i2osp"/>):
                        <list style="empty">
                          <t>S = I2OSP (s, k).</t>
                        </list>
                      </t>
                    </list>
                  </t>
                  <t>Output the signature S.</t>
                </list>
              </t>
            </list>
          </t>
        </section>

        <section title="Signature Verification Operation">
         <t>RSASSA-PKCS1-V1_5-VERIFY ((n, e), M, S)
            <list style="hanging">
              <t hangText="Input:">
                <figure>
                  <artwork align="left"><![CDATA[
   (n, e)  signer's RSA public key
   M       message whose signature is to be verified, an octet string
   S       signature to be verified, an octet string of length k, 
           where k is the length in octets of the RSA modulus n
]]></artwork>
                </figure>
              </t>
              <t hangText="Output">"valid signature" or "invalid signature"</t>
              <t hangText="Errors:">"message too long"; "RSA modulus too short"</t>
             <t hangText="Steps:">
                <list style="numbers">
                  <t>Length checking: If the length of the signature S is not k octets, output "invalid signature" and stop.</t>
                 <t>RSA verification:
                    <list style="letters">
                      <t>Convert the signature S to an integer signature representative s (see <xref target="os2ip"/>):
                        <list style="empty">
                          <t>s = OS2IP (S).</t>
                        </list>
                      </t>
                      <t>Apply the RSAVP1 verification primitive (<xref target="rsavp1"/>) to the
                      RSA public key (n, e) and the signature representative s to
                      produce an integer message representative m:
                       <list style="empty">
                          <t>m = RSAVP1 ((n, e), s).</t>
                        </list>
                        If RSAVP1 outputs "signature representative out of range", output "invalid signature" and stop.
                      </t>
                      <t>Convert the message representative m to an encoded message EM of length k octets (see <xref target="i2osp"/>):
                        <list style="empty">
                          <t>EM = I2OSP (m, k).</t>
                        </list>
                        If I2OSP outputs "integer too large", output "invalid signature" and stop.
                      </t>
                    </list>
                  </t>
                  <t>EMSA-PKCS1-v1_5 encoding: Apply the EMSA-PKCS1-v1_5 encoding
                  operation (<xref target="emsa_pkcs1_v1_5"/>) to the message M to produce a second
                  encoded message EM' of length k octets:
                    <list style="empty">
                      <t>EM' = EMSA-PKCS1-V1_5-ENCODE (M, k).</t>
                    </list>
                    If the encoding operation outputs "message too long", output
                    "message too long" and stop.  If the encoding operation outputs
                    "intended encoded message length too short", output "RSA modulus
                    too short" and stop.
                  </t>
                 <t>Compare the encoded message EM and the second encoded message EM'.
                  If they are the same, output "valid signature"; otherwise, output
                  "invalid signature".
                  </t>
                </list>
                Note: Another way to implement the signature verification operation
                is to apply a "decoding" operation (not specified in this document)
                to the encoded message to recover the underlying hash value, and then
                compare it to a newly computed hash value.  This has the advantage
                that it requires less intermediate storage (two hash values rather
                than two encoded messages), but the disadvantage that it requires
                additional code.
              </t>
            </list>
          </t>
       </section>

      </section>
   </section>

   <section anchor="encoding_methods_for_sigs_with_appendix" title="Encoding Methods for Signatures with Appendix">

      <t>Encoding methods consist of operations that map between octet string messages and octet-string-encoded messages, which are converted to and from integer message representatives in the schemes. The integer message representatives are processed via the primitives. The encoding methods thus provide the connection between the schemes, which process messages, and the primitives.</t>

      <t>An encoding method for signatures with appendix, for the purposes of this document, consists of an encoding operation and optionally a verification operation. An encoding operation maps a message M to an encoded message EM of a specified length. A verification operation determines whether a message M and an encoded message EM are consistent, i.e., whether the encoded message EM is a valid encoding of the message M.</t>

      <t>The encoding operation may introduce some randomness, so that different applications of the encoding operation to the same message will produce different encoded messages, which has benefits for provable security. For such an encoding method, both an encoding and a verification operation are needed unless the verifier can reproduce the randomness (e.g., by obtaining the salt value from the signer). For a deterministic encoding method, only an encoding operation is needed.</t>

      <t>Two encoding methods for signatures with appendix are employed in the signature schemes and are specified here: EMSA-PSS and EMSA&nbhy;PKCS1&nbhy;v1_5.</t>

      <section anchor="emsa_pss" title="EMSA-PSS">

        <t>This encoding method is parameterized by the choice of hash function, mask generation function, and salt length. These options should be fixed for a given RSA key, except that the salt length can be variable (see <xref target="JONSSON"/> for discussion). Suggested hash and mask generation functions are given in <xref target="appendix_supporting"/>. The encoding method is based on Bellare and Rogaway's Probabilistic Signature Scheme (PSS) <xref target="RSARABIN"/><xref target="PSS"/>. It is randomized and has an encoding operation and a verification operation.</t>

        <t>Figure 2 illustrates the encoding operation.</t>
        <figure>
          <artwork align="left"><![CDATA[
   __________________________________________________________________

                                  +-----------+
                                  |     M     |
                                  +-----------+
                                        |
                                        V
                                      Hash
                                        |
                                        V
                          +--------+----------+----------+
                     M' = |Padding1|  mHash   |   salt   |
                          +--------+----------+----------+
                                         |
               +--------+----------+     V
         DB =  |Padding2|   salt   |   Hash
               +--------+----------+     |
                         |               |
                         V               |
                        xor <--- MGF <---|
                         |               |
                         |               |
                         V               V
               +-------------------+----------+--+
         EM =  |    maskedDB       |     H    |bc|
               +-------------------+----------+--+
   __________________________________________________________________
]]></artwork>
          <postamble>Figure 2: EMSA-PSS Encoding Operation</postamble>
        </figure>

<t>Note that the verification operation follows reverse steps to recover salt and then forward steps to recompute and compare H.</t>

        <t>Notes:
          <list style="numbers">
            <t>The encoding method defined here differs from the one in Bellare and Rogaway's submission to IEEE 1363a <xref target="PSS"/> in three respects:
              <list style="symbols">
                <t>It applies a hash function rather than a mask generation function to the
                message. Even though the mask generation function is based on a hash function,
                it seems more natural to apply a hash function directly.</t>
                <t>The value that is hashed together with the salt value is the string
                (0x)00 00 00 00 00 00 00 00 || mHash rather than the message M itself. Here,
                mHash is the hash of M. Note that the hash function is the same in both steps.
                See Note 3 below for further discussion. (Also, the name "salt" is used instead
                of "seed", as it is more reflective of the value's role.)</t>
                <t>The encoded message in EMSA-PSS has nine fixed bits; the first bit is 0 and
                the last eight bits form a "trailer field", the octet 0xbc. In the original 
                scheme, only the first bit is fixed. The rationale for the trailer field is
                for compatibility with the Integer Factorization Signature Primitive using Rabin-Williams (IFSP-RW) in 
                IEEE 1363 <xref target="IEEE1363"/> and the corresponding primitive in ISO/IEC 9796-2:2010
                <xref target="ISO9796"/>.</t>
              </list>
            </t>
            <t>Assuming that the mask generation function is based on a hash function, it is RECOMMENDED that the hash function be the same as the one that is applied to the message; see <xref target="rsassa_pss"/> for further discussion.</t>
            <t>Without compromising the security proof for RSASSA-PSS, one may perform Steps 1 and 2 of EMSA-PSS-ENCODE and EMSA-PSS-VERIFY (the application of the hash function to the message) outside the module that computes the rest of the signature operation, so that mHash rather than the message M itself is input to the module. In other words, the security proof for RSASSA-PSS still holds even if an opponent can control the value of mHash. This is convenient if the module has limited I/O bandwidth, e.g., a smart card. Note that previous versions of PSS <xref target="RSARABIN"/><xref target="PSS"/> did not have this property. Of course, it may be desirable for other security reasons to have the module process the full message. For instance, the module may need to "see" what it is signing if it does not trust the component that computes the hash value.</t>

            <t>Typical salt lengths in octets are hLen (the length of the output of the hash function Hash) and 0. In both cases, the security of RSASSA-PSS can be closely related to the hardness of inverting RSAVP1. Bellare and Rogaway <xref target="RSARABIN"/> give a tight lower bound for the security of the original RSA-PSS scheme, which corresponds roughly to the former case, while Coron <xref target="FDH"/> gives a lower bound for the related Full Domain Hashing scheme, which corresponds roughly to the latter case. In <xref target="PSSPROOF"/>, Coron provides a general treatment with various salt lengths ranging from 0 to hLen; see <xref target="IEEE1363A"/> for discussion. See also <xref target="JONSSON"/>, which adapts the security proofs in <xref target="RSARABIN"/> <xref target="PSSPROOF"/> to address the differences between the original and the present version of RSA-PSS as listed in Note 1 above. </t>
            <t>As noted in IEEE 1363a <xref target="IEEE1363A"/>, the use of randomization in signature schemes -- such as the salt value in EMSA-PSS -- may provide a "covert channel" for transmitting information other than the message being signed. For more on covert channels, see <xref target="SIMMONS"/>.</t>
         </list>
        </t>

       <section anchor="encoding_operation" title="Encoding Operation">
          <t>EMSA-PSS-ENCODE (M, emBits)
            <list style="hanging">
              <t hangText="Options:">
               <figure>
                  <artwork align="left"><![CDATA[
   Hash     hash function (hLen denotes the length in octets of 
            the hash function output)
   MGF      mask generation function
   sLen     intended length in octets of the salt
]]></artwork>
                </figure>
              </t>
              <t hangText="Input:">
                <figure>
                  <artwork align="left"><![CDATA[
   M        message to be encoded, an octet string
   emBits   maximal bit length of the integer OS2IP (EM) (see Section
            4.2), at least 8hLen + 8sLen + 9
]]></artwork>
                </figure>
              </t>
              <t hangText="Output:">
                <figure>
                  <artwork align="left"><![CDATA[
   EM       encoded message, an octet string of length emLen = \ceil
            (emBits/8)
        ]]></artwork>
                </figure>
              </t>
              <t hangText="Errors:">"Encoding error"; "message too long"</t>
             <t hangText="Steps:">
                <list style="numbers">
                  <t> If the length of M is greater than the input limitation for the
                  hash function (2^61 - 1 octets for SHA-1), output "message too
                  long" and stop.</t>
                  <t> Let mHash = Hash(M), an octet string of length hLen.</t>
                 <t> If emLen &lt; hLen + sLen + 2, output "encoding error" and stop.</t>
                 <t> Generate a random octet string salt of length sLen; if sLen = 0, then salt is the empty string.</t>
                 <t> Let
                    <list style="empty">
                      <t>M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt;</t>
                    </list>
                    M' is an octet string of length 8 + hLen + sLen with eight initial zero octets.
                  </t>
                 <t> Let H = Hash(M'), an octet string of length hLen.</t>
                 <t> Generate an octet string PS consisting of emLen - sLen - hLen - 2 zero octets.  The length of PS may be 0.</t>
                 <t> Let DB = PS || 0x01 || salt; DB is an octet string of length emLen - hLen - 1.</t>
                 <t> Let dbMask = MGF(H, emLen - hLen - 1).</t>
                 <t> Let maskedDB = DB \xor dbMask.</t>
                 <t> Set the leftmost 8emLen - emBits bits of the leftmost octet in maskedDB to zero.</t>
                 <t> Let EM = maskedDB || H || 0xbc.</t>
                 <t> Output EM.</t>
                </list>
              </t>
           </list>
          </t>
       </section>

        <section anchor="verification_operation" title="Verification Operation">
          <t>EMSA-PSS-VERIFY (M, EM, emBits)
            <list style="hanging">
              <t hangText="Options:">
               <figure>
                  <artwork align="left"><![CDATA[
   Hash     hash function (hLen denotes the length in octets of 
            the hash function output)
   MGF      mask generation function
   sLen     intended length in octets of the salt
        ]]></artwork>
                </figure>
              </t>
              <t hangText="Input:">
                <figure>
                  <artwork align="left"><![CDATA[
   M        message to be verified, an octet string
   EM       encoded message, an octet string of length emLen = \ceil
            (emBits/8)
   emBits   maximal bit length of the integer OS2IP (EM) (see Section
            4.2), at least 8hLen + 8sLen + 9
      ]]></artwork>
                </figure>
              </t>
              <t hangText="Output:">"consistent" or "inconsistent"</t>
              <t hangText="Steps:">
                <list style="numbers">
                  <t> If the length of M is greater than the input limitation for the
                  hash function (2^61 - 1 octets for SHA-1), output "inconsistent"
                  and stop.</t>
                 <t> Let mHash = Hash(M), an octet string of length hLen.</t>
                 <t> If emLen &lt; hLen + sLen + 2, output "inconsistent" and stop.</t>
                 <t> If the rightmost octet of EM does not have hexadecimal value
                  0xbc, output "inconsistent" and stop.</t>
                 <t> Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and
                  let H be the next hLen octets.</t>
                  <t> If the leftmost 8emLen - emBits bits of the leftmost octet in
                  maskedDB are not all equal to zero, output "inconsistent" and stop.</t>
                 <t> Let dbMask = MGF(H, emLen - hLen - 1).</t>
                 <t> Let DB = maskedDB \xor dbMask.</t>
                 <t> Set the leftmost 8emLen - emBits bits of the leftmost octet in DB to zero.</t>
                 <t> If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero
                  or if the octet at position emLen - hLen - sLen - 1 (the leftmost
                  position is "position 1") does not have hexadecimal value 0x01,
                  output "inconsistent" and stop.</t>
                 <t> Let salt be the last sLen octets of DB.</t>
                 <t> Let
                    <list style="empty">
                      <t>M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt ;</t>
                    </list>
                    M' is an octet string of length 8 + hLen + sLen with eight initial zero octets.
                  </t>
                 <t> Let H' = Hash(M'), an octet string of length hLen.</t>
                 <t> If H = H', output "consistent". Otherwise, output "inconsistent".</t>
                </list>
              </t>
            </list>
          </t>
       </section>    
      </section>

      <section anchor="emsa_pkcs1_v1_5" title="EMSA-PKCS1-v1_5">

        <t>This encoding method is deterministic and only has an encoding operation.</t>
       <t>EMSA-PKCS1-v1_5-ENCODE (M, emLen)
          <list style="hanging">
            <t hangText="Option:">
              <figure>
                <artwork align="left"><![CDATA[
   Hash     hash function (hLen denotes the length in octets of
            the hash function output)
]]></artwork>
              </figure>
            </t>
            <t hangText="Input:">
              <figure>
                <artwork align="left"><![CDATA[
   M        message to be encoded
   emLen    intended length in octets of the encoded message, at 
            least tLen + 11, where tLen is the octet length of the 
            Distinguished Encoding Rules (DER) encoding T of 
            a certain value computed during the encoding operation
]]></artwork>
              </figure>
            </t>
            <t hangText="Output:">
              <figure>
                <artwork align="left"><![CDATA[
   EM       encoded message, an octet string of length emLen
]]></artwork>
              </figure>
            </t>
            <t hangText="Errors:">"message too long"; "intended encoded message length too short"</t>
            <t hangText="Steps:">
              <list style="numbers">
                <t> Apply the hash function to the message M to produce a hash value H:
                  <list style="empty">
                    <t>H = Hash(M).</t>
                  </list>
                  If the hash function outputs "message too long", output "message too long" and stop.
                </t>
                <t>Encode the algorithm ID for the hash function and the hash value
                into an ASN.1 value of type DigestInfo (see <xref target="appendix_rsassa_pkcs_v1_5"/>) with
                the DER, where the type DigestInfo
                has the syntax
                 <figure>
                    <artwork align="left"><![CDATA[
            DigestInfo ::= SEQUENCE {
                digestAlgorithm AlgorithmIdentifier,
                digest OCTET STRING
            }
        ]]></artwork>
                  </figure>
                  The first field identifies the hash function and the second
                  contains the hash value.  Let T be the DER encoding of the
                  DigestInfo value (see the notes below), and let tLen be the length
                  in octets of T.
                </t>
                <t> If emLen &lt; tLen + 11, output "intended encoded message length too short" and stop.</t>
               <t> Generate an octet string PS consisting of emLen - tLen - 3 octets
                with hexadecimal value 0xff.  The length of PS will be at least 8 octets.</t>
               <t> Concatenate PS, the DER encoding T, and other padding to form the encoded message EM as
                  <list style="empty">
                    <t>EM = 0x00 || 0x01 || PS || 0x00 || T.</t>
                  </list>
                </t>
               <t> Output EM.</t>
              </list>
            </t>
          </list>
          Notes:
           <list style="numbers">

             <t> For the nine hash functions mentioned in <xref target="hash_functions"/>, the DER
             encoding T of the DigestInfo value is equal to the following:
               <figure>
                 <artwork align="left"><![CDATA[
      MD2:     (0x)30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 02 05 00 04
                   10 || H.
      MD5:     (0x)30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 05 05 00 04
                   10 || H.
      SHA-1:   (0x)30 21 30 09 06 05 2b 0e 03 02 1a 05 00 04 14 || H.
      SHA-224:  (0x)30 2d 30 0d 06 09 60 86 48 01 65 03 04 02 04
                   05 00 04 1c || H.
      SHA-256: (0x)30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00
                   04 20 || H.
      SHA-384: (0x)30 41 30 0d 06 09 60 86 48 01 65 03 04 02 02 05 00
                   04 30 || H.
      SHA-512: (0x)30 51 30 0d 06 09 60 86 48 01 65 03 04 02 03 05 00
                   04 40 || H.
      SHA-512/224:  (0x)30 2d 30 0d 06 09 60 86 48 01 65 03 04 02 05
                        05 00 04 1c || H.
      SHA-512/256:  (0x)30 31 30 0d 06 09 60 86 48 01 65 03 04 02 06
                        05 00 04 20 || H.
]]></artwork>
               </figure>
             </t>
             <t> In version 1.5 of this document, T was defined as the BER
             encoding, rather than the DER encoding, of the DigestInfo value.
             In particular, it is possible -- at least in theory -- that the
             verification operation defined in this document (as well as in
             version 2.0) rejects a signature that is valid with respect to the
             specification given in PKCS #1 v1.5.  This occurs if other rules
             than DER are applied to DigestInfo (e.g., an indefinite length
             encoding of the underlying SEQUENCE type).  While this is unlikely
             to be a concern in practice, a cautious implementor may choose to
             employ a verification operation based on a BER decoding operation
             as specified in PKCS #1 v1.5.  In this manner, compatibility with
             any valid implementation based on PKCS #1 v1.5 is obtained.  Such
             a verification operation should indicate whether the underlying
             BER encoding is a DER encoding and hence whether the signature is
             valid with respect to the specification given in this document.</t>
          </list>
        </t>
      </section>
    </section>

  
    <section title="Security Considerations">
      <t>
        Security considerations are discussed throughout this memo.
     </t>
    </section>

 </middle>
 
 <back>
   <references title="Normative References">

     &RFC2119;

      
     <reference anchor="GARNER">
      <front>
        <title>The Residue Number System</title>
        <author initials="H." surname="Garner"/>
        <date month="June" year="1959"/>
      </front>
      <seriesInfo name="IRE Transactions on Electronic Computers," value="Volume EC-8, Issue 2, pp. 140-147" />
      <seriesInfo name="DOI" value="10.1109/TEC.1959.5219515"/>
     </reference>
     
     <reference anchor="RSA">
      <front>
        <title>A Method for Obtaining Digital Signatures and Public-Key Cryptosystems</title>
        <author initials="R." surname="Rivest"/>
        <author initials="A." surname="Shamir"/>
        <author initials="L." surname="Adleman"/>
        <date month="February" year="1978"/>
      </front>
      <seriesInfo name="Communications of the ACM," value="Volume 21, Issue 2, pp. 120-126"/>
      <seriesInfo name="DOI" value="10.1145/359340.359342"/>
     </reference>
   </references>

   <references title="Informative References">

     &RFC1319;
     &RFC1321;
     &RFC2313;
     &RFC2315;
     &RFC2437;  
     &RFC3447;
     &RFC5958;    
     &RFC5246;   
     &RFC5652;
     &RFC6149;
     &RFC7292;
      
     <reference anchor="BLEICHENBACHER">
      <front>
        <title>Chosen Ciphertext Attacks Against Protocols Based on the RSA Encryption Standard PKCS #1</title>
        <author initials="D." surname="Bleichenbacher"/>
        <date year="1998"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 1462, pp. 1-12"/>
     </reference>
     
     <reference anchor="BKS">
      <front>
        <title>Recent Results on PKCS #1: RSA Encryption Standard</title>
        <author initials="D." surname="Bleichenbacher"/>
        <author initials="B." surname="Kaliski"/>
        <author initials="J." surname="Staddon"/>
        <date month="June" year="1998"/>
      </front>
      <seriesInfo name="RSA Laboratories," value="Bulletin No. 7"/>
     </reference>

     <reference anchor="ANSIX944">
      <front>
        <title>Key Establishment Using Integer Factorization Cryptography</title>
        <author>
          <organization>ANSI</organization>
        </author>
        <date month="August" year="2007"/>
      </front>
    <seriesInfo name="ANSI" value="X9.44-2007"/>
     </reference>
     
    <reference anchor="CHOSEN">
      <front>
        <title>A Chosen Text Attack on the RSA Cryptosystem and Some Discrete Logarithm Schemes</title>
        <author initials="Y." surname="Desmedt"/>
        <author initials="A. M." surname="Odlyzko"/>
        <date year="1985"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 218, pp. 516-522"/>
     </reference>

     <reference anchor="COCHRAN" target="http://eprint.iacr.org/2007/474">
      <front>
        <title>Notes on the Wang et al. 2^63 SHA-1 Differential Path</title>
        <author initials="M." surname="Cochran"/>
        <date month="August" year="2008"/>
      </front>
     <seriesInfo name="Cryptology ePrint Archive:" value="Report 2007/474"/>
     </reference>

    <reference anchor="FASTDEC">
      <front>
        <title>Fast Decipherment Algorithm for RSA Public-Key Cryptosystem</title>
        <author initials="J.-J." surname="Quisquater"/>
        <author initials="C." surname="Couvreur"/>
        <date month="October" year="1982"/>
      </front>
      <seriesInfo name="Electronic Letters," value="Volume 18, Issue 21, pp. 905-907"/>
      <seriesInfo name="DOI" value="10.1049/el:19820617"/>
     </reference>

    <reference anchor="FDH">
      <front>
        <title>On the Exact Security of Full Domain Hash</title>
        <author initials="J.-S." surname="Coron"/>
        <date year="2000"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 1880, pp. 229-235"/>
     </reference>

    <reference anchor="FORGERY">
      <front>
        <title>ISO 9796-1 and the new forgery strategy</title>
        <author initials="D." surname="Coppersmith"/>
        <author initials="S." surname="Halevi"/>
        <author initials="C." surname="Jutla"/>
        <date month="August" year="1999"/>
      </front>
    <seriesInfo name="rump session of" value="Crypto"/>
     </reference>

    <reference anchor="FOPS">
      <front>
        <title>RSA-OAEP is Secure under the RSA Assumption</title>
        <author initials="E." surname="Fujisaki"/>
        <author initials="T." surname="Okamoto"/>
        <author initials="D." surname="Pointcheval"/>
        <author initials="J." surname="Stern"/>
        <date month ="August" year="2001"/>
      </front>
     <seriesInfo name="Lecture Notes in Computer Science," value="Volume 2139, pp. 260-274"/>
     </reference>


    <reference anchor="HAASTAD">
      <front>
        <title>Solving Simultaneous Modular Equations of Low Degree</title>
        <author initials="J." surname="Haastad"/>
        <date month="April" year="1988"/>
      </front>
      <seriesInfo name="SIAM Journal on" value="Computing"/> 
      <seriesInfo name="Volume" value="17"/>
      <seriesInfo name="Issue" value="2"/> 
      <seriesInfo name="pp." value="336-341"/>
      <seriesInfo name="DOI" value="10.1137/0217019"/>
     </reference>

   <reference anchor="HANDBOOK">
      <front>
        <title>Handbook of Applied Cryptography</title>
        <author initials="A." surname="Menezes"/>
        <author initials="P." surname="van Oorschot"/>
        <author initials="S." surname="Vanstone"/>
        <date year="1996"/>
      </front>
     <seriesInfo name="CRC Press," value="ISBN: 0849385237"/>
     </reference>

    <reference anchor="HASHID">
      <front>
        <title>On Hash Function Firewalls in Signature Schemes</title>
        <author initials="B." surname="Kaliski"/>
        <date month="February" year="2002"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 2271, pp. 1-16"/>
      <seriesInfo name="DOI" value="10.1007/3-540-45760-7_1"/>
     </reference>

  <reference anchor="IEEE1363" target="http://ieeexplore.ieee.org/document/891000/">
      <front>
        <title>Standard Specifications for Public Key Cryptography</title>
        <author><organization>IEEE</organization></author>
        <date month="August" year="2000"/>
      </front>
       <seriesInfo name="IEEE" value="Std 1363-2000"/>
     <seriesInfo name="DOI" value="10.1109/IEEESTD.2000.92292"/>
     </reference>

     <reference anchor="IEEE1363A" target="http://ieeexplore.ieee.org/document/1335427/">
      <front>
        <title>Standard Specifications for Public Key Cryptography - Amendment 1: Additional Techniques</title>
        <author><organization>IEEE</organization></author>
        <date month="September" year="2004"/>
      </front>
      <seriesInfo name="IEEE" value="Std 1363a-2004"/>
     <seriesInfo name="DOI" value="10.1109/IEEESTD.2004.94612"/>
     </reference>

    <reference anchor="ISO18033">
      <front>
        <title>Information technology -- Security techniques -- Encryption algorithms - Part 2: Asymmetric ciphers</title>
        <author><organization>International Organization for Standardization</organization></author>
        <date month="May" year="2006"/>
      </front>
  <seriesInfo name="ISO/IEC" value="18033-2:2006"/>
     </reference>

     <reference anchor="ISO9594">
      <front>
        <title>Information technology - Open Systems Interconnection - The Directory: Public-key and attribute certificate frameworks</title>
        <author><organization>International Organization for Standardization</organization></author>
        <date month="December" year="2008"/>
      </front>
   <seriesInfo name="ISO/IEC" value="9594-8:2008"/>
     </reference>

    <reference anchor="ISO9796">
      <front>
        <title>Information technology - Security techniques - Digital signature schemes giving message recovery - Part 2: Integer factorization based mechanisms</title>
        <author><organization>International Organization for Standardization</organization></author>
        <date month="December" year="2010"/>
      </front>
   <seriesInfo name="ISO/IEC" value="9796-2:2010"/>
     </reference>

      <reference anchor="LOWEXP">
      <front>
        <title>Low-Exponent RSA with Related Messages</title>
        <author initials="D." surname="Coppersmith"/>
        <author initials="M." surname="Franklin"/>
        <author initials="J." surname="Patarin"/>
        <author initials="M." surname="Reiter"/>
        <date year="1996"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 1070, pp. 1-9"/>
     </reference>

     <reference anchor="JONSSON" target="http://eprint.iacr.org/2001/053">
      <front>
        <title>Security Proofs for the RSA-PSS Signature Scheme and Its Variants</title>
        <author initials="J." surname="Jonsson"/>
        <date month="March" year="2002"/>
      </front>
      <seriesInfo name="Cryptology ePrint Archive:" value="Report 2001/053"/>
     </reference>

      <reference anchor="MANGER">
      <front>
        <title>A Chosen Ciphertext Attack on RSA Optimal Asymmetric Encryption Padding (OAEP) as Standardized in PKCS #1 v2.0</title>
        <author initials="J." surname="Manger"/>
        <date year="2001"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 2139, pp. 230-238"/>
     <seriesInfo name="DOI" value="10.1007/3-540-44647-8_14"/>
     </reference>

    <reference anchor="MD4">
      <front>
        <title>Cryptanalysis of MD4</title>
        <author initials="H." surname="Dobbertin"/>
        <date year="1996"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 1039, pp. 53-69"/>
     <seriesInfo name="DOI" value="10.1007/3-540-60865-6_43"/>
     </reference>

      <reference anchor="MD4FIRST">
      <front>
        <title>The First Two Rounds of MD4 are Not One-Way</title>
        <author initials="H." surname="Dobbertin"/>
        <date month="March" year="1998"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 1372, pp. 284-292"/>
     <seriesInfo name="DOI" value="10.1007/3-540-69710-1_19"/>
     </reference>

     <reference anchor="MD4LAST">
      <front>
        <title>An Attack on the Last Two Rounds of MD4</title>
        <author initials="B." surname="den Boer"/>
        <author initials="A." surname="Bosselaers"/>
        <date year="1992"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 576, pp. 194-203"/>
      <seriesInfo name="DOI" value="10.1007/3-540-46766-1_14"/>
     </reference>

    <reference anchor="NEWATTACK">
      <front>
        <title>New Attacks on PKCS #1 v1.5 Encryption</title>
        <author initials="J.-S." surname="Coron"/>
        <author initials="M." surname="Joye"/>
        <author initials="D." surname="Naccache"/>
        <author initials="P." surname="Paillier"/>
        <date month="May" year="2000"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 1807, pp. 369-381"/>
     <seriesInfo name="DOI" value="10.1007/3-540-45539-6_25"/>
     </reference>

     <reference anchor="OAEP">
      <front>
        <title>Optimal Asymmetric Encryption - How to Encrypt with RSA</title>
        <author initials="M." surname="Bellare"/>
        <author initials="P." surname="Rogaway"/>
        <date month="November" year="1995"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 950, pp. 92-111"/>
     </reference>

     <reference anchor="PA98">
      <front>
        <title>Relations Among Notions of Security for Public-Key Encryption Schemes</title>
        <author initials="M." surname="Bellare"/>
        <author initials="A." surname="Desai"/>
        <author initials="D." surname="Pointcheval"/>
        <author initials="P." surname="Rogaway"/>
        <date year="1998"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 1462, pp. 26-45"/>
     <seriesInfo name="DOI" value="10.1007/BFb0055718"/>
     </reference>

    <reference anchor="PADDING">
      <front>
        <title>On the Security of RSA Padding</title>
        <author initials="J.-S." surname="Coron"/>
        <author initials="D." surname="Naccache"/>
        <author initials="J. P." surname="Stern"/>
        <date month="December" year="1999"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 1666, pp. 1-18"/>
     <seriesInfo name="DOI" value="10.1007/3-540-48405-1_1"/>
     </reference>

     <reference anchor="PKCS1_22">
      <front>
        <title>PKCS #1: RSA Cryptography Standard Version 2.2</title>
        <author>
          <organization>RSA Laboratories</organization>
        </author>
        <date month="October" year="2012"/>
      </front>
     </reference>

      <reference anchor="PREFIX">
      <front>
        <title>Chosen-prefix collisions for MD5 and applications</title>
        <author initials="M." surname="Stevens"/>
        <author initials="A. K." surname="Lenstra"/>
        <author initials="B." surname="de Weger"/>
        <date month="July" year="2012"/>
      </front>
      <seriesInfo name="International Journal of Applied Cryptography," value="Volume 2, No. 4, pp. 322-359"/>
     </reference>

      <reference anchor="PSS" target="http://grouper.ieee.org/groups/1363/P1363a/contributions/pss-submission.pdf">
      <front>
        <title>PSS: Provably Secure Encoding Method for Digital Signatures</title>
        <author initials="M." surname="Bellare"/>
        <author initials="P." surname="Rogaway"/>
        <date month="August" year="1998"/>
      </front>
     <seriesInfo name="Submission to" value="IEEE P1363a"/>
     </reference>

     <reference anchor="PSSPROOF">
      <front>
        <title>Optimal Security Proofs for PSS and Other Signature Schemes</title>
        <author initials="J.-S." surname="Coron"/>
        <date year="2002"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 2332, pp. 272-287"/>
      <seriesInfo name="DOI" value="10.1007/3-540-46035-7_18"/>
     </reference>

    <reference anchor="RSARABIN">
      <front>
        <title>The Exact Security of Digital Signatures - How to Sign with RSA and Rabin</title>
        <author initials="M." surname="Bellare"/>
        <author initials="P." surname="Rogaway"/>
        <date year="1996"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 1070, pp. 399-416"/>
      <seriesInfo name="DOI" value="10.1007/3-540-68339-9_34"/>
     </reference>

   <reference anchor="RSATLS">
      <front>
        <title>On the Security of RSA Encryption in TLS</title>
        <author initials="J." surname="Jonsson"/>
        <author initials="B." surname="Kaliski"/>
        <date year="2002"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 2442, pp. 127-142"/>
      <seriesInfo name="DOI" value="10.1007/3-540-45708-9_9"/>
     </reference>

   <reference anchor="SHA1CRYPT" target="http://csrc.nist.gov/groups/ST/hash/documents/Wang_SHA1-New-Result.pdf">
      <front>
        <title>Cryptanalysis on SHA-1</title>
        <author initials="X." surname="Wang"/>
        <author initials="A. C." surname="Yao"/>
        <author initials="F." surname="Yao"/>
        <date month="February" year="2005"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 2442, pp. 127-142"/>
     </reference>

    <reference anchor="SHS" target="http://dx.doi.org/10.6028/NIST.FIPS.180-4">
       <front>
        <title>Secure Hash Standard (SHS)</title>
         <author><organization>National Institute of Standards and Technology</organization></author>
         <date month="August" year="2015"/>
       </front>
       <seriesInfo name="FIPS" value="PUB 180-4"/>
      </reference>


   <reference anchor="SHOUP">
      <front>
        <title>OAEP Reconsidered (Extended Abstract)</title>
        <author initials="V." surname="Shoup"/>
        <date year="2001"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 2139, pp. 239-259"/>
      <seriesInfo name="DOI" value="10.1007/3-540-44647-8_15"/>
     </reference>

   <reference anchor="SILVERMAN">
      <front>
        <title>A Cost-Based Security Analysis of Symmetric and Asymmetric Key Lengths</title>
        <author initials="R. D." surname="Silverman"/>
        <date year="2000"/>
      </front>
      <seriesInfo name="RSA Laboratories," value="Bulletin No. 13"/>
     </reference>

   <reference anchor="SIMMONS">
      <front>
        <title>Subliminal Communication is Easy Using the DSA</title>
        <author initials="G. J." surname="Simmons"/>
        <date year="1994"/>
      </front>
      <seriesInfo name="Lecture Notes in Computer Science," value="Volume 765, pp. 218-232"/>
      <seriesInfo name="DOI" value="10.1007/3-540-48285-7_18"/>
     </reference>

    </references>
  
 <section anchor="appendix_ASNsyntax" title="ASN.1 Syntax">
   <section anchor="rsa_key_representation" title="RSA Key Representation">
   <t>This section defines ASN.1 object identifiers for RSA public and
   private keys and defines the types RSAPublicKey and RSAPrivateKey.
   The intended application of these definitions includes X.509
     certificates, PKCS #8 <xref target="RFC5958"/>, and PKCS #12 <xref target="RFC7292"/>.</t>

   <t>The object identifier rsaEncryption identifies RSA public and private
   keys as defined in Appendices A.1.1 and A.1.2.  The parameters field
has   associated with this OID in a value of type AlgorithmIdentifier SHALL
   have a value of type NULL.</t>
    
    <figure>
   <artwork align="left"><![CDATA[
   rsaEncryption    OBJECT IDENTIFIER ::= { pkcs-1 1 }
]]></artwork></figure>

   <t>The definitions in this section have been extended to support multi-
   prime RSA, but they are backward compatible with previous versions.</t>

    <section anchor="rsa_public_key_syntax" title="RSA Public Key Syntax">
   <t>An RSA public key should be represented with the ASN.1 type
   RSAPublicKey:</t>
     
     <figure>
   <artwork align="left"><![CDATA[
      RSAPublicKey ::= SEQUENCE {
          modulus           INTEGER,  -- n
          publicExponent    INTEGER   -- e
      }
]]></artwork></figure>

   <t>The fields of type RSAPublicKey have the following meanings:</t>
   <t><list style="symbols">
       <t>modulus is the RSA modulus n.</t>
       <t>publicExponent is the RSA public exponent e.</t>
      </list></t>
    </section>
      
    <section anchor="rsa_private_key_syntax" title="RSA Private Key Syntax">
   <t>An RSA private key should be represented with the ASN.1 type
   RSAPrivateKey:</t>
     
     <figure>
   <artwork align="left"><![CDATA[
      RSAPrivateKey ::= SEQUENCE {
          version           Version,
          modulus           INTEGER,  -- n
          publicExponent    INTEGER,  -- e
          privateExponent   INTEGER,  -- d
          prime1            INTEGER,  -- p
          prime2            INTEGER,  -- q
          exponent1         INTEGER,  -- d mod (p-1)
          exponent2         INTEGER,  -- d mod (q-1)
          coefficient       INTEGER,  -- (inverse of q) mod p
          otherPrimeInfos   OtherPrimeInfos OPTIONAL
      }
]]></artwork></figure>

   <t>The fields of type RSAPrivateKey have the following meanings:</t>

    <t><list style="symbols">
      <t>version is the version number, for compatibility with future
      revisions of this document.  It SHALL be 0 for this version of the
      document, unless multi-prime is used; in which case, it SHALL be 1.</t>
      </list></t>
     
     <figure>
   <artwork align="left"><![CDATA[
         Version ::= INTEGER { two-prime(0), multi(1) }
            (CONSTRAINED BY
            {-- version must be multi if otherPrimeInfos present --})
]]></artwork></figure>

    <t><list style="symbols">
     <t>modulus is the RSA modulus n.</t>

     <t>publicExponent is the RSA public exponent e.</t>

     <t>privateExponent is the RSA private exponent d.</t>

     <t>prime1 is the prime factor p of n.</t>

     <t>prime2 is the prime factor q of n.</t>

     <t>exponent1 is d mod (p - 1).</t>

     <t>exponent2 is d mod (q - 1).</t>

     <t>coefficient is the CRT coefficient q^(-1) mod p.</t>

     <t>otherPrimeInfos contains the information for the additional primes
      r_3, ..., r_u, in order.  It SHALL be omitted if version is 0 and
      SHALL contain at least one instance of OtherPrimeInfo if version
      is 1.</t>
      </list></t>
     
     <figure>
   <artwork align="left"><![CDATA[
         OtherPrimeInfos ::= SEQUENCE SIZE(1..MAX) OF OtherPrimeInfo

         OtherPrimeInfo ::= SEQUENCE {
             prime             INTEGER,  -- ri
             exponent          INTEGER,  -- di
             coefficient       INTEGER   -- ti
         }
]]></artwork></figure>

   <t>The fields of type OtherPrimeInfo have the following meanings:</t>

    <t><list style="symbols">
      <t>prime is a prime factor r_i of n, where i &gt;= 3.</t>

      <t>exponent is d_i = d mod (r_i - 1).</t>

       <t>coefficient is the CRT coefficient t_i = (r_1 * r_2 * ... * r_(i-1))^(-1) mod r_i.</t>
      </list></t>

   <t>Note: It is important to protect the RSA private key against both
   disclosure and modification.  Techniques for such protection are
   outside the scope of this document.  Methods for storing and
   distributing private keys and other cryptographic data are described
   in PKCS #12 and #15.</t>
      </section>
    </section>

   <section title="Scheme Identification">
<t>This section defines object identifiers for the encryption and signature schemes. The schemes compatible with PKCS #1 v1.5 have the same definitions as in PKCS #1 v1.5. The intended application of these definitions includes X.509 certificates and PKCS #7.</t>

<t>Here are type identifier definitions for the PKCS #1 OIDs:</t>
    
    <figure>
   <artwork align="left"><![CDATA[
PKCS1Algorithms    ALGORITHM-IDENTIFIER ::= {
    { OID rsaEncryption                PARAMETERS NULL } |
    { OID md2WithRSAEncryption         PARAMETERS NULL } |
    { OID md5WithRSAEncryption         PARAMETERS NULL } |
    { OID sha1WithRSAEncryption        PARAMETERS NULL } |
    { OID sha224WithRSAEncryption      PARAMETERS NULL } |
    { OID sha256WithRSAEncryption      PARAMETERS NULL } |
    { OID sha384WithRSAEncryption      PARAMETERS NULL } |
    { OID sha512WithRSAEncryption      PARAMETERS NULL } |
    { OID sha512-224WithRSAEncryption  PARAMETERS NULL } |
    { OID sha512-256WithRSAEncryption  PARAMETERS NULL } |
    { OID id-RSAES-OAEP   PARAMETERS RSAES-OAEP-params } |
    PKCS1PSourceAlgorithms                               |
    { OID id-RSASSA-PSS   PARAMETERS RSASSA-PSS-params },
    ...  -- Allows for future expansion --
}
]]></artwork></figure>

    <section anchor="appendix_rsaes_oaep" title="RSAES-OAEP">
<t>The object identifier id-RSAES-OAEP identifies the RSAES-OAEP encryption scheme.</t>
     
     <figure>
   <artwork align="left"><![CDATA[
    id-RSAES-OAEP    OBJECT IDENTIFIER ::= { pkcs-1 7 }
]]></artwork></figure>

<t>The parameters field associated with this OID in a value of type AlgorithmIdentifier SHALL have a value of type RSAES-OAEP-params:</t>
     
     <figure>
   <artwork align="left"><![CDATA[
RSAES-OAEP-params ::= SEQUENCE {
    hashAlgorithm      [0] HashAlgorithm     DEFAULT sha1, 
    maskGenAlgorithm   [1] MaskGenAlgorithm  DEFAULT mgf1SHA1, 
    pSourceAlgorithm   [2] PSourceAlgorithm  DEFAULT pSpecifiedEmpty 
}
]]></artwork></figure>

<t>The fields of type RSAES-OAEP-params have the following meanings:</t>
<t><list style="symbols">
    <t>hashAlgorithm identifies the hash function. It SHALL be an algorithm ID with an OID in the set OAEP-PSSDigestAlgorithms. For a discussion of supported hash functions, see <xref target="hash_functions"/>.</t>
      </list></t>
     
     <figure>
   <artwork align="left"><![CDATA[
    HashAlgorithm ::= AlgorithmIdentifier {
       {OAEP-PSSDigestAlgorithms} 
    }

    OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
        { OID id-sha1       PARAMETERS NULL }|
        { OID id-sha224     PARAMETERS NULL }|
        { OID id-sha256     PARAMETERS NULL }|
        { OID id-sha384     PARAMETERS NULL }|
        { OID id-sha512     PARAMETERS NULL }|
        { OID id-sha512-224 PARAMETERS NULL }|
        { OID id-sha512-256 PARAMETERS NULL },
        ...  -- Allows for future expansion --
    }
]]></artwork></figure>

<t>The default hash function is SHA-1:</t>
     
     <figure>
   <artwork align="left"><![CDATA[
    sha1    HashAlgorithm ::= {
        algorithm   id-sha1, 
        parameters  SHA1Parameters : NULL
    }

    SHA1Parameters ::= NULL
]]></artwork></figure>

<t><list style="symbols">
<t>maskGenAlgorithm identifies the mask generation function. It SHALL be an algorithm ID with an OID in the set PKCS1MGFAlgorithms, which for this version SHALL consist of id&nbhy;mgf1, identifying the MGF1 mask generation function (see <xref target="mgf1"/>). The parameters field associated with id-mgf1 SHALL be an algorithm ID with an OID in the set OAEP&nbhy;PSSDigestAlgorithms, identifying the hash function on which MGF1 is based.</t>
      </list></t>
     
     <figure>
   <artwork align="left"><![CDATA[
    MaskGenAlgorithm ::= AlgorithmIdentifier { {PKCS1MGFAlgorithms} }

    PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
        { OID id-mgf1 PARAMETERS HashAlgorithm }, 
        ...  -- Allows for future expansion --
    }
]]></artwork></figure>

    <t><list style="symbols"><t>The default mask generation function is MGF1 with SHA-1:</t></list></t>

     <figure>
   <artwork align="left"><![CDATA[
    mgf1SHA1    MaskGenAlgorithm ::= {
        algorithm   id-mgf1, 
        parameters  HashAlgorithm : sha1
    }
]]></artwork></figure>

<t><list style="symbols">
<t>pSourceAlgorithm identifies the source (and possibly the value) of the label L. It SHALL be an algorithm ID with an OID in the set PKCS1PSourceAlgorithms, which for this version SHALL consist of id-pSpecified, indicating that the label is specified explicitly. The parameters field associated with id-pSpecified SHALL have a value of type OCTET STRING, containing the label. In previous versions of this specification, the term "encoding parameters" was used rather than "label", hence the name of the type below.
       
       <figure>
   <artwork align="left"><![CDATA[
    PSourceAlgorithm ::= AlgorithmIdentifier {
       {PKCS1PSourceAlgorithms} 
    }

    PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {
        { OID id-pSpecified PARAMETERS EncodingParameters }, 
        ...  -- Allows for future expansion --
    }

    id-pSpecified    OBJECT IDENTIFIER ::= { pkcs-1 9 }

    EncodingParameters ::= OCTET STRING(SIZE(0..MAX))
]]></artwork></figure></t>
 
<t>The default label is an empty string (so that lHash will contain the hash of the empty string):
       
       <figure>
   <artwork align="left"><![CDATA[
    pSpecifiedEmpty    PSourceAlgorithm ::= {
        algorithm   id-pSpecified, 
        parameters  EncodingParameters : emptyString
    }

    emptyString    EncodingParameters ::= ''H 
]]></artwork></figure></t>
       
      </list></t>

<t>If all of the default values of the fields in RSAES-OAEP-params are used, then the algorithm identifier will have the following value:</t>
     
     <figure>
   <artwork align="left"><![CDATA[
    rSAES-OAEP-Default-Identifier    RSAES-AlgorithmIdentifier ::= {
        algorithm   id-RSAES-OAEP,
        parameters  RSAES-OAEP-params : {
            hashAlgorithm       sha1,
            maskGenAlgorithm    mgf1SHA1,
            pSourceAlgorithm    pSpecifiedEmpty
        }
    }

    RSAES-AlgorithmIdentifier ::= AlgorithmIdentifier  {
        {PKCS1Algorithms}
    }
]]></artwork></figure>


      </section>

    <section title="RSAES-PKCS-v1_5">
<t>The object identifier rsaEncryption (see <xref target="rsa_key_representation"/>) identifies the RSAES-PKCS1-v1_5 encryption scheme. The parameters field associated with this OID in a value of type AlgorithmIdentifier SHALL have a value of type NULL. This is the same as in PKCS #1 v1.5.</t>
     
     <figure>
   <artwork align="left"><![CDATA[
    rsaEncryption    OBJECT IDENTIFIER ::= { pkcs-1 1 }
]]></artwork></figure>


    </section>
    <section anchor="appendix_rsassa_pss" title="RSASSA-PSS">
<t>The object identifier id-RSASSA-PSS identifies the RSASSA-PSS encryption scheme.</t>
     
     <figure>
   <artwork align="left"><![CDATA[
    id-RSASSA-PSS    OBJECT IDENTIFIER ::= { pkcs-1 10 }
]]></artwork></figure>

<t>The parameters field associated with this OID in a value of type AlgorithmIdentifier SHALL have a value of type RSASSA-PSS-params:</t>
     
     <figure>
   <artwork align="left"><![CDATA[
RSASSA-PSS-params ::= SEQUENCE {
    hashAlgorithm      [0] HashAlgorithm      DEFAULT sha1, 
    maskGenAlgorithm   [1] MaskGenAlgorithm   DEFAULT mgf1SHA1, 
    saltLength         [2] INTEGER            DEFAULT 20,
    trailerField       [3] TrailerField       DEFAULT trailerFieldBC
}
]]></artwork></figure>

<t>The fields of type RSASSA-PSS-params have the following meanings:</t>

     <t><list style="symbols">
       <t>hashAlgorithm identifies the hash function. It SHALL be an algorithm ID with an OID in the set OAEP-PSSDigestAlgorithms (see <xref target="appendix_rsaes_oaep"/>). The default hash function is SHA-1.</t>

       <t>maskGenAlgorithm identifies the mask generation function. It SHALL be an algorithm ID with an OID in the set PKCS1MGFAlgorithms (see <xref target="appendix_rsaes_oaep"/>). The default mask generation function is MGF1 with SHA-1. For MGF1 (and more generally, for other mask generation functions based on a hash function), it is RECOMMENDED that the underlying hash function be the same as the one identified by hashAlgorithm; see Note 2 in <xref target="emsa_pss"/> for further comments.</t>

       <t>saltLength is the octet length of the salt. It SHALL be an integer. For a given hashAlgorithm, the default value of saltLength is the octet length of the hash value. Unlike the other fields of type RSASSA-PSS-params, saltLength does not need to be fixed for a given RSA key pair. </t>

       <t>trailerField is the trailer field number, for compatibility with IEEE 1363a <xref target="IEEE1363A"/>. It SHALL be 1 for this version of the document, which represents the trailer field with hexadecimal value 0xbc. Other trailer fields (including the trailer field HashID || 0xcc in IEEE 1363a) are not supported in this document.</t>
      </list></t>
     
     <figure>
   <artwork align="left"><![CDATA[
    TrailerField ::= INTEGER { trailerFieldBC(1) }
]]></artwork></figure>

<t>If the default values of the hashAlgorithm, maskGenAlgorithm, and trailerField fields of RSASSA-PSS-params are used, then the algorithm identifier will have the following value:</t>
     
     <figure>
   <artwork align="left"><![CDATA[
    rSASSA-PSS-Default-Identifier    RSASSA-AlgorithmIdentifier ::= {
        algorithm   id-RSASSA-PSS, 
        parameters  RSASSA-PSS-params : {
            hashAlgorithm       sha1,
            maskGenAlgorithm    mgf1SHA1,
            saltLength          20,
            trailerField        trailerFieldBC
        }
    }

    RSASSA-AlgorithmIdentifier ::= AlgorithmIdentifier { 
        {PKCS1Algorithms} 
    }
]]></artwork></figure>

<t>Note: In some applications, the hash function underlying a signature scheme is identified separately from the rest of the operations in the signature scheme. For instance, in PKCS #7 <xref target="RFC2315"/>, a hash function identifier is placed before the message and a "digest encryption" algorithm identifier (indicating the rest of the operations) is carried with the signature. In order for PKCS #7 to support the RSASSA-PSS signature scheme, an object identifier would need to be defined for the operations in RSASSA-PSS after the hash function (analogous to the RSAEncryption OID for the RSASSA&nbhy;PKCS1&nbhy;v1_5 scheme). S/MIME Cryptographic Message Syntax (CMS) <xref target="RFC5652"/> takes a different approach. Although a hash function identifier is placed before the message, an algorithm identifier for the full signature scheme may be carried with a CMS signature (this is done for DSA signatures). Following this convention, the id&nbhy;RSASSA&nbhy;PSS OID can be used to identify RSASSA-PSS signatures in CMS. Since CMS is considered the successor to PKCS #7 and new developments such as the addition of support for RSASSA-PSS will be pursued with respect to CMS rather than PKCS #7, an OID for the "rest of" RSASSA&nbhy;PSS is not defined in this version of PKCS #1.</t>

    </section>

    <section anchor="appendix_rsassa_pkcs_v1_5" title="RSASSA-PKCS-v1_5">
<t>The object identifier for RSASSA-PKCS1-v1_5 SHALL be one of the following. The choice of OID depends on the choice of hash algorithm: MD2, MD5, SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA&nbhy;512/224, or SHA-512/256. Note that if either MD2 or MD5 is used, then the OID is just as in PKCS #1 v1.5. For each OID, the parameters field associated with this OID in a value of type AlgorithmIdentifier SHALL have a value of type NULL. The OID should be chosen in accordance with the following table:</t>
     
     <figure>
   <artwork align="left"><![CDATA[
      Hash algorithm   OID
      ------------------------------------------------------------
      MD2              md2WithRSAEncryption        ::= {pkcs-1 2}
      MD5              md5WithRSAEncryption        ::= {pkcs-1 4}
      SHA-1            sha1WithRSAEncryption       ::= {pkcs-1 5}
      SHA-256          sha224WithRSAEncryption     ::= {pkcs-1 14}
      SHA-256          sha256WithRSAEncryption     ::= {pkcs-1 11}
      SHA-384          sha384WithRSAEncryption     ::= {pkcs-1 12}
      SHA-512          sha512WithRSAEncryption     ::= {pkcs-1 13}
      SHA-512/224      sha512-224WithRSAEncryption ::= {pkcs-1 15}
      SHA-512/256      sha512-256WithRSAEncryption ::= {pkcs-1 16}
]]></artwork></figure>

<t>The EMSA-PKCS1-v1_5 encoding method includes an ASN.1 value of type DigestInfo, where the type DigestInfo has the syntax</t>
     
     <figure>
   <artwork align="left"><![CDATA[
    DigestInfo ::= SEQUENCE {
        digestAlgorithm DigestAlgorithm,
        digest OCTET STRING 
    }
]]></artwork></figure>

<t>digestAlgorithm identifies the hash function and SHALL be an algorithm ID with an OID in the set PKCS1-v1-5DigestAlgorithms. For a discussion of supported hash functions, see <xref target="hash_functions"/>.</t>
     
     <figure>
   <artwork align="left"><![CDATA[
    DigestAlgorithm ::= AlgorithmIdentifier {
       {PKCS1-v1-5DigestAlgorithms} 
    }

    PKCS1-v1-5DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
        { OID id-md2        PARAMETERS NULL }|
        { OID id-md5        PARAMETERS NULL }|
        { OID id-sha1       PARAMETERS NULL }|
        { OID id-sha224     PARAMETERS NULL }|
        { OID id-sha256     PARAMETERS NULL }|
        { OID id-sha384     PARAMETERS NULL }|
        { OID id-sha512     PARAMETERS NULL }|
        { OID id-sha512-224 PARAMETERS NULL }|
        { OID id-sha512-256 PARAMETERS NULL }
    }
]]></artwork></figure>


    </section>


   </section>
   </section>
<section anchor="appendix_supporting" title="Supporting Techniques">
<t>This section gives several examples of underlying functions supporting the encryption schemes in <xref target="encryption_schemes"/> and the encoding methods in <xref target="encoding_methods_for_sigs_with_appendix"/>. A range of techniques is given here to allow compatibility with existing applications as well as migration to new techniques. While these supporting techniques are appropriate for applications to implement, none of them is required to be implemented. It is expected that profiles for PKCS #1 v2.2 will be developed that specify particular supporting techniques.</t>

<t>This section also gives object identifiers for the supporting techniques.</t>

<section anchor="hash_functions" title="Hash Functions">
<t>Hash functions are used in the operations contained in Sections <xref target="encryption_schemes" format="counter"/> and <xref target="encoding_methods_for_sigs_with_appendix" format="counter"/>. Hash functions are deterministic, meaning that the output is completely determined by the input. Hash functions take octet strings of variable length and generate fixed-length octet strings. 
The hash functions used in the operations contained in Sections <xref target="encryption_schemes" format="counter"/> and <xref target="encoding_methods_for_sigs_with_appendix" format="counter"/> should generally be collision-resistant. This means that it is infeasible to find two distinct inputs to the hash function that produce the same output. A collision-resistant hash function also has the desirable property of being one-way; this means that given an output, it is infeasible to find an input whose hash is the specified output. In addition to the requirements, the hash function should yield a mask generation function (<xref target="mask_generation_functions"/>) with pseudorandom output.</t>

<t>Nine hash functions are given as examples for the encoding methods in this document: MD2 <xref target="RFC1319"/> (which was retired by <xref target="RFC6149"/>), MD5 <xref target="RFC1321"/>, SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256 <xref target="SHS"/>. For the RSAES&nbhy;OAEP encryption scheme and EMSA-PSS encoding method, only SHA&nbhy;1, SHA&nbhy;224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA&nbhy;512/256 are RECOMMENDED. For the EMSA-PKCS1-v1_5 encoding method, SHA-224, SHA&nbhy;256, SHA-384, SHA-512, SHA-512/224, and SHA&nbhy;512/256 are RECOMMENDED for new applications. MD2, MD5, and SHA-1 are recommended only for compatibility with existing applications based on PKCS #1 v1.5.</t>

<t>The object identifiers id-md2, id-md5, id-sha1, id-sha224, id-sha256, id-sha384, id-sha512, id-sha512/224, and id-sha512/256 identify the respective hash functions:</t>
     
     <figure>
   <artwork align="left"><![CDATA[    
    id-md2      OBJECT IDENTIFIER ::= {
        iso (1) member-body (2) us (840) rsadsi (113549) 
        digestAlgorithm (2) 2
    }

    id-md5      OBJECT IDENTIFIER ::= {
        iso (1) member-body (2) us (840) rsadsi (113549) 
        digestAlgorithm (2) 5
    }

    id-sha1    OBJECT IDENTIFIER ::= {
        iso(1) identified-organization(3) oiw(14) secsig(3)
         algorithms(2) 26
    }

    id-sha224    OBJECT IDENTIFIER ::= {
        joint-iso-itu-t (2) country (16) us (840) organization (1) 
        gov (101) csor (3) nistalgorithm (4) hashalgs (2) 4
    }

    id-sha256    OBJECT IDENTIFIER ::= {
        joint-iso-itu-t (2) country (16) us (840) organization (1) 
        gov (101) csor (3) nistalgorithm (4) hashalgs (2) 1
    }

    id-sha384    OBJECT IDENTIFIER ::= {
        joint-iso-itu-t (2) country (16) us (840) organization (1) 
        gov (101) csor (3) nistalgorithm (4) hashalgs (2) 2
    }

    id-sha512    OBJECT IDENTIFIER ::= {
        joint-iso-itu-t (2) country (16) us (840) organization (1) 
        gov (101) csor (3) nistalgorithm (4) hashalgs (2) 3
    }

    id-sha512-224    OBJECT IDENTIFIER ::= {
        joint-iso-itu-t (2) country (16) us (840) organization (1) 
        gov (101) csor (3) nistalgorithm (4) hashalgs (2) 5
    }

    id-sha512-256    OBJECT IDENTIFIER ::= {
        joint-iso-itu-t (2) country (16) us (840) organization (1) 
        gov (101) csor (3) nistalgorithm (4) hashalgs (2) 6
    }
]]></artwork></figure>

<t>The parameters field associated with these OIDs in a value of type AlgorithmIdentifier SHALL have a value of type NULL.</t>

<t>The parameters field associated with id-md2 and id-md5 in a value of type AlgorithmIdentifier shall have a value of type NULL.</t>

<t>The parameters field associated with id-sha1, id-sha224, id-sha256, id-sha384, id-sha512, id-sha512/224, and id-sha512/256 should generally be omitted, but if present, it shall have a value of type NULL.</t>

<t>This is to align with the definitions originally promulgated by NIST. For the SHA algorithms, implementations MUST accept AlgorithmIdentifier values both without parameters and with NULL parameters.</t>

<t>Exception: When formatting the DigestInfoValue in EMSA-PKCS1-v1_5 (see Section 9.2), the parameters field associated with id&nbhy;sha1, id&nbhy;sha224, id&nbhy;sha256, id&nbhy;sha384, id&nbhy;sha512, id&nbhy;sha512/224, and id&nbhy;sha512/256 shall have a value of type NULL. This is to maintain compatibility with existing implementations and with the numeric information values already published for EMSA-PKCS1-v1_5, which are also reflected in IEEE 1363a <xref target="IEEE1363A"/>.</t>

<t>Note: Version 1.5 of PKCS #1 also allowed for the use of MD4 in signature schemes. The cryptanalysis of MD4 has progressed significantly in the intervening years. For example, Dobbertin <xref target="MD4"/> demonstrated how to find collisions for MD4 and that the first two rounds of MD4 are not one-way <xref target="MD4FIRST"/>. Because of these results and others (e.g., <xref target="MD4LAST"/>), MD4 is NOT RECOMMENDED.</t>

<t>Further advances have been made in the cryptanalysis of MD2 and MD5, especially after the findings of Stevens et al. <xref target="PREFIX"/> on chosen-prefix collisions on MD5. MD2 and MD5 should be considered cryptographically broken and removed from existing applications. This version of the standard supports MD2 and MD5 just for backwards-compatibility reasons.</t>

<t>There have also been advances in the cryptanalysis of SHA-1. Particularly, the results of Wang et al. <xref target="SHA1CRYPT"/> (which have been independently verified by M. Cochran in his analysis <xref target="COCHRAN"/>) on using a differential path to find collisions in SHA-1, which conclude that the security strength of the SHA-1 hashing algorithm is significantly reduced. However, this reduction is not significant enough to warrant the removal of SHA-1 from existing applications, but its usage is only recommended for backwards-compatibility reasons.</t>

<t>To address these concerns, only SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256 are RECOMMENDED for new applications. As of today, the best (known) collision attacks against these hash functions are generic attacks with complexity 2L/2, where L is the bit length of the hash output. For the signature schemes in this document, a collision attack is easily translated into a signature forgery. Therefore, the value L / 2 should be at least equal to the desired security level in bits of the signature scheme (a security level of B bits means that the best attack has complexity 2B). The same rule of thumb can be applied to RSAES-OAEP; it is RECOMMENDED that the bit length of the seed (which is equal to the bit length of the hash output) be twice the desired security level in bits.</t>
</section>

<section anchor="mask_generation_functions" title="Mask Generation Functions">
<t>A mask generation function takes an octet string of variable length and a desired output length as input and outputs an octet string of the desired length. There may be restrictions on the length of the input and output octet strings, but such bounds are generally very large. Mask generation functions are deterministic; the octet string output is completely determined by the input octet string. The output of a mask generation function should be pseudorandom: Given one part of the output but not the input, it should be infeasible to predict another part of the output. The provable security of RSAES&nbhy;OAEP and RSASSA-PSS relies on the random nature of the output of the mask generation function, which in turn relies on the random nature of the underlying hash.</t>

<t>One mask generation function is given here: MGF1, which is based on a hash function. MGF1 coincides with the mask generation functions defined in IEEE 1363 <xref target="IEEE1363"/> and ANSI X9.44 <xref target="ANSIX944"/>. Future versions of this document may define other mask generation functions.</t>
<section anchor="mgf1" title="MGF1">
   <t>MGF1 is a mask generation function based on a hash function.</t>

   <t>MGF1 (mgfSeed, maskLen)</t>

   <t>Options:</t>
      
      <figure>
   <artwork align="left"><![CDATA[   
   Hash     hash function (hLen denotes the length in octets of 
            the hash function output)
]]></artwork></figure>

      <t>Input:</t>
      <figure>
   <artwork align="left"><![CDATA[   
   mgfSeed  seed from which mask is generated, an octet string
   maskLen  intended length in octets of the mask, at most 2^32 hLen
]]></artwork></figure>

   <t>Output:</t>
      <figure>
   <artwork align="left"><![CDATA[   
   mask     mask, an octet string of length maskLen
]]></artwork></figure>

   <t>Error:  "mask too long"</t>

   <t>Steps:</t>

<t><list style="numbers">
   <t>If maskLen > 2^32 hLen, output "mask too long" and stop.</t>

   <t>Let T be the empty octet string.</t>

   <t>For counter from 0 to \ceil (maskLen / hLen) - 1, do the
      following:
     <list style="letters">

       <t>Convert counter to an octet string C of length 4 octets (see
         <xref target="i2osp"/>):
          <list style="empty">

            <t>C = I2OSP (counter, 4) .</t>
          </list>
       </t>

       <t>Concatenate the hash of the seed mgfSeed and C to the octet
         string T:

          <list style="empty">
            <t>T = T || Hash(mgfSeed || C) .</t>
           </list>
       </t>
     </list>
   </t>

   <t>Output the leading maskLen octets of T as the octet string mask.</t>
 </list></t>

   <t>The object identifier id-mgf1 identifies the MGF1 mask generation
   function:</t>
      
      <figure>
   <artwork align="left"><![CDATA[   
   id-mgf1    OBJECT IDENTIFIER ::= { pkcs-1 8 }
]]></artwork></figure>

   <t>The parameters field associated with this OID in a value of type
   AlgorithmIdentifier shall have a value of type hashAlgorithm,
   identifying the hash function on which MGF1 is based.</t>

</section>
   </section>
   </section>

<section anchor="appendix_ASNmodule" title="ASN.1 Module">
     
     <figure>
   <artwork align="left"><![CDATA[   
-- PKCS #1 v2.2 ASN.1 Module
-- Revised October 27, 2012

-- This module has been checked for conformance with the
-- ASN.1 standard by the OSS ASN.1 Tools 

PKCS-1 {
    iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) 
    modules(0) pkcs-1(1)
}

DEFINITIONS EXPLICIT TAGS ::=

BEGIN

-- EXPORTS ALL
-- All types and values defined in this module are exported for use
-- in other ASN.1 modules.

IMPORTS

id-sha224, id-sha256, id-sha384, id-sha512, id-sha512-224, 
id-sha512-256
    FROM NIST-SHA2 {
        joint-iso-itu-t(2) country(16) us(840) organization(1) 
        gov(101) csor(3) nistalgorithm(4) hashAlgs(2)
    };

-- ============================
--   Basic object identifiers 
-- ============================

-- The DER encoding of this in hexadecimal is:
-- (0x)06 08 
--        2A 86 48 86 F7 0D 01 01
--
pkcs-1    OBJECT IDENTIFIER ::= { 
    iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1
}

--
-- When rsaEncryption is used in an AlgorithmIdentifier,
-- the parameters MUST be present and MUST be NULL.
--
rsaEncryption    OBJECT IDENTIFIER ::= { pkcs-1 1 }

--
-- When id-RSAES-OAEP is used in an AlgorithmIdentifier, the
-- parameters MUST be present and MUST be RSAES-OAEP-params.
--
id-RSAES-OAEP    OBJECT IDENTIFIER ::= { pkcs-1 7 }

--
-- When id-pSpecified is used in an AlgorithmIdentifier, the
-- parameters MUST be an OCTET STRING.
--
id-pSpecified    OBJECT IDENTIFIER ::= { pkcs-1 9 }

--
-- When id-RSASSA-PSS is used in an AlgorithmIdentifier, the
-- parameters MUST be present and MUST be RSASSA-PSS-params.
--
id-RSASSA-PSS    OBJECT IDENTIFIER ::= { pkcs-1 10 }

--
-- When the following OIDs are used in an AlgorithmIdentifier,
-- the parameters MUST be present and MUST be NULL.
--
md2WithRSAEncryption         OBJECT IDENTIFIER ::= { pkcs-1 2 }
md5WithRSAEncryption         OBJECT IDENTIFIER ::= { pkcs-1 4 }
sha1WithRSAEncryption        OBJECT IDENTIFIER ::= { pkcs-1 5 }
sha224WithRSAEncryption      OBJECT IDENTIFIER ::= { pkcs-1 14 }
sha256WithRSAEncryption      OBJECT IDENTIFIER ::= { pkcs-1 11 }
sha384WithRSAEncryption      OBJECT IDENTIFIER ::= { pkcs-1 12 }
sha512WithRSAEncryption      OBJECT IDENTIFIER ::= { pkcs-1 13 }
sha512-224WithRSAEncryption  OBJECT IDENTIFIER ::= { pkcs-1 15 }
sha512-256WithRSAEncryption  OBJECT IDENTIFIER ::= { pkcs-1 16 }

--
-- This OID really belongs in a module with the secsig OIDs.
--
id-sha1    OBJECT IDENTIFIER ::= {
    iso(1) identified-organization(3) oiw(14) secsig(3) algorithms(2)
    26
}

--
-- OIDs for MD2 and MD5, allowed only in EMSA-PKCS1-v1_5.
--
id-md2 OBJECT IDENTIFIER ::= {
    iso(1) member-body(2) us(840) rsadsi(113549) digestAlgorithm(2) 2
}

id-md5 OBJECT IDENTIFIER ::= {
    iso(1) member-body(2) us(840) rsadsi(113549) digestAlgorithm(2) 5
}

--
-- When id-mgf1 is used in an AlgorithmIdentifier, the parameters 
-- MUST be present and MUST be a HashAlgorithm, for example, sha1.
--
id-mgf1    OBJECT IDENTIFIER ::= { pkcs-1 8 }

-- ================
--   Useful types
-- ================

ALGORITHM-IDENTIFIER ::= CLASS {
    &id    OBJECT IDENTIFIER  UNIQUE, 
    &Type  OPTIONAL
}
    WITH SYNTAX { OID &id [PARAMETERS &Type] }

-- Note: the parameter InfoObjectSet in the following definitions
-- allows a distinct information object set to be specified for sets
-- of algorithms such as:  
-- DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
--     { OID id-md2  PARAMETERS NULL }|
--     { OID id-md5  PARAMETERS NULL }|
--     { OID id-sha1 PARAMETERS NULL }
-- }
--

AlgorithmIdentifier { ALGORITHM-IDENTIFIER:InfoObjectSet } ::= 
    SEQUENCE {
      algorithm   
          ALGORITHM-IDENTIFIER.&id({InfoObjectSet}), 
      parameters  
          ALGORITHM-IDENTIFIER.&Type({InfoObjectSet}{@.algorithm})  
            OPTIONAL
}



-- ==============
--   Algorithms
-- ==============

--
-- Allowed EME-OAEP and EMSA-PSS digest algorithms.
--
OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
    { OID id-sha1       PARAMETERS NULL }|
    { OID id-sha224     PARAMETERS NULL }|
    { OID id-sha256     PARAMETERS NULL }|
    { OID id-sha384     PARAMETERS NULL }|
    { OID id-sha512     PARAMETERS NULL }|
    { OID id-sha512-224 PARAMETERS NULL }|
    { OID id-sha512-256 PARAMETERS NULL },
    ...  -- Allows for future expansion --
}

--
-- Allowed EMSA-PKCS1-v1_5 digest algorithms.
--
PKCS1-v1-5DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
    { OID id-md2        PARAMETERS NULL }|
    { OID id-md5        PARAMETERS NULL }|
    { OID id-sha1       PARAMETERS NULL }|
    { OID id-sha224     PARAMETERS NULL }|
    { OID id-sha256     PARAMETERS NULL }|
    { OID id-sha384     PARAMETERS NULL }|
    { OID id-sha512     PARAMETERS NULL }|
    { OID id-sha512-224 PARAMETERS NULL }|
    { OID id-sha512-256 PARAMETERS NULL }
}

-- When id-md2 and id-md5 are used in an AlgorithmIdentifier, the
-- parameters field shall have a value of type NULL.

-- When id-sha1, id-sha224, id-sha256, id-sha384, id-sha512,
-- id-sha512-224, and id-sha512-256 are used in an
-- AlgorithmIdentifier, the parameters (which are optional) SHOULD be
-- omitted, but if present, they SHALL have a value of type NULL. 
-- However, implementations MUST accept AlgorithmIdentifier values
-- both without parameters and with NULL parameters.

-- Exception: When formatting the DigestInfoValue in EMSA-PKCS1-v1_5
-- (see Section 9.2), the parameters field associated with id-sha1,
-- id-sha224, id-sha256, id-sha384, id-sha512, id-sha512-224, and
-- id-sha512-256 SHALL have a value of type NULL.  This is to 
-- maintain compatibility with existing implementations and with the
-- numeric information values already published for EMSA-PKCS1-v1_5, 
-- which are also reflected in IEEE 1363a.

sha1    HashAlgorithm ::= {
    algorithm   id-sha1, 
    parameters  SHA1Parameters : NULL
}

HashAlgorithm ::= AlgorithmIdentifier { {OAEP-PSSDigestAlgorithms} }

SHA1Parameters ::= NULL

--
-- Allowed mask generation function algorithms. 
-- If the identifier is id-mgf1, the parameters are a HashAlgorithm. 
--
PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
    { OID id-mgf1 PARAMETERS HashAlgorithm }, 
    ...  -- Allows for future expansion --
}

--
-- Default AlgorithmIdentifier for id-RSAES-OAEP.maskGenAlgorithm and
-- id-RSASSA-PSS.maskGenAlgorithm.
--
mgf1SHA1    MaskGenAlgorithm ::= {
    algorithm   id-mgf1, 
    parameters  HashAlgorithm : sha1
}

MaskGenAlgorithm ::= AlgorithmIdentifier { {PKCS1MGFAlgorithms} }

--
-- Allowed algorithms for pSourceAlgorithm.
--
PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {
    { OID id-pSpecified PARAMETERS EncodingParameters }, 
    ...  -- Allows for future expansion --
}

EncodingParameters ::= OCTET STRING(SIZE(0..MAX))

-- 
-- This identifier means that the label L is an empty string, so the
-- digest of the empty string appears in the RSA block before
-- masking.
--

pSpecifiedEmpty    PSourceAlgorithm ::= {
    algorithm   id-pSpecified, 
    parameters  EncodingParameters : emptyString
}

PSourceAlgorithm ::= AlgorithmIdentifier { {PKCS1PSourceAlgorithms} }

emptyString    EncodingParameters ::= ''H 

--
-- Type identifier definitions for the PKCS #1 OIDs.
--
PKCS1Algorithms    ALGORITHM-IDENTIFIER ::= {
    { OID rsaEncryption                PARAMETERS NULL } |
    { OID md2WithRSAEncryption         PARAMETERS NULL } |
    { OID md5WithRSAEncryption         PARAMETERS NULL } |
    { OID sha1WithRSAEncryption        PARAMETERS NULL } |
    { OID sha224WithRSAEncryption      PARAMETERS NULL } |
    { OID sha256WithRSAEncryption      PARAMETERS NULL } |
    { OID sha384WithRSAEncryption      PARAMETERS NULL } |
    { OID sha512WithRSAEncryption      PARAMETERS NULL } |
    { OID sha512-224WithRSAEncryption  PARAMETERS NULL } |
    { OID sha512-256WithRSAEncryption  PARAMETERS NULL } |
    { OID id-RSAES-OAEP   PARAMETERS RSAES-OAEP-params } |
    PKCS1PSourceAlgorithms                               |
    { OID id-RSASSA-PSS   PARAMETERS RSASSA-PSS-params },
    ...  -- Allows for future expansion --
}

-- ===================
--   Main structures
-- ===================

RSAPublicKey ::= SEQUENCE {
    modulus           INTEGER,  -- n
    publicExponent    INTEGER   -- e 
}

-- 
-- Representation of RSA private key with information for the CRT
-- algorithm.
--
RSAPrivateKey ::= SEQUENCE {
    version           Version, 
    modulus           INTEGER,  -- n
    publicExponent    INTEGER,  -- e
    privateExponent   INTEGER,  -- d
    prime1            INTEGER,  -- p
    prime2            INTEGER,  -- q
    exponent1         INTEGER,  -- d mod (p-1)
    exponent2         INTEGER,  -- d mod (q-1) 
    coefficient       INTEGER,  -- (inverse of q) mod p
    otherPrimeInfos   OtherPrimeInfos OPTIONAL 
}

Version ::= INTEGER { two-prime(0), multi(1) }
    (CONSTRAINED BY 
      {-- version MUST
 be multi if otherPrimeInfos present --})

OtherPrimeInfos ::= SEQUENCE SIZE(1..MAX) OF OtherPrimeInfo


OtherPrimeInfo ::= SEQUENCE {
    prime             INTEGER,  -- ri
    exponent          INTEGER,  -- di
    coefficient       INTEGER   -- ti
}

--
-- AlgorithmIdentifier.parameters for id-RSAES-OAEP.
-- Note that the tags in this Sequence are explicit.
--
RSAES-OAEP-params ::= SEQUENCE {
    hashAlgorithm      [0] HashAlgorithm     DEFAULT sha1, 
    maskGenAlgorithm   [1] MaskGenAlgorithm  DEFAULT mgf1SHA1, 
    pSourceAlgorithm   [2] PSourceAlgorithm  DEFAULT pSpecifiedEmpty 
}

-- 
-- Identifier for default RSAES-OAEP algorithm identifier.
-- The DER encoding of this is in hexadecimal:
-- (0x)30 0D
--        06 09 
--           2A 86 48 86 F7 0D 01 01 07
--        30 00   
-- Notice that the DER encoding of default values is "empty". 
--

rSAES-OAEP-Default-Identifier    RSAES-AlgorithmIdentifier ::= {
    algorithm   id-RSAES-OAEP, 
    parameters  RSAES-OAEP-params : {
        hashAlgorithm       sha1, 
        maskGenAlgorithm    mgf1SHA1, 
        pSourceAlgorithm    pSpecifiedEmpty
    }
}

RSAES-AlgorithmIdentifier ::= AlgorithmIdentifier { 
    {PKCS1Algorithms} 
}

-- 
-- AlgorithmIdentifier.parameters for id-RSASSA-PSS.
-- Note that the tags in this Sequence are explicit.
--
RSASSA-PSS-params ::= SEQUENCE {
    hashAlgorithm      [0] HashAlgorithm      DEFAULT sha1, 
    maskGenAlgorithm   [1] MaskGenAlgorithm   DEFAULT mgf1SHA1, 
    saltLength         [2] INTEGER            DEFAULT 20,
    trailerField       [3] TrailerField       DEFAULT trailerFieldBC
}

TrailerField ::= INTEGER { trailerFieldBC(1) }

-- 
-- Identifier for default RSASSA-PSS algorithm identifier
-- The DER encoding of this is in hexadecimal:
-- (0x)30 0D
--        06 09 
--           2A 86 48 86 F7 0D 01 01 0A
--        30 00   
-- Notice that the DER encoding of default values is "empty". 
--
rSASSA-PSS-Default-Identifier    RSASSA-AlgorithmIdentifier ::= {
    algorithm   id-RSASSA-PSS, 
    parameters  RSASSA-PSS-params : {
        hashAlgorithm       sha1, 
        maskGenAlgorithm    mgf1SHA1, 
        saltLength          20,
        trailerField        trailerFieldBC
    }
}

RSASSA-AlgorithmIdentifier ::= AlgorithmIdentifier { 
    {PKCS1Algorithms} 
}

--
-- Syntax for the EMSA-PKCS1-v1_5 hash identifier.
--
DigestInfo ::= SEQUENCE {
    digestAlgorithm DigestAlgorithm,
    digest OCTET STRING 
}

DigestAlgorithm ::= AlgorithmIdentifier { 
    {PKCS1-v1-5DigestAlgorithms} 
}

END
]]></artwork>
      </figure>


</section>

<section anchor="appendix_revhistory" title="Revision History of PKCS #1">

<t>Versions 1.0 - 1.5:

<list style="empty">
<t>Versions 1.0 - 1.3 were distributed to participants in RSA Data Security, Inc.'s Public-Key Cryptography Standards meetings in February and March 1991.</t>

<t>Version 1.4 was part of the June 3, 1991 initial public release of PKCS. Version 1.4 was published as NIST/OSI Implementors' Workshop document SEC-SIG-91-18.</t>

<t>Version 1.5 incorporated several editorial changes, including updates to
the references and the addition of a revision history. The following
substantive changes were made:

<list style="symbols">
  <t>Section 10: "MD4 with RSA" signature and verification processes were added.</t>
  <t>Section 11: md4WithRSAEncryption object identifier was added.</t>
</list></t>

<t>Version 1.5 was republished as <xref target="RFC2313"></xref> (which was
later obsoleted by <xref target="RFC2437"></xref>).</t>
</list></t>

<t>Version 2.0:
<list style="empty">
<t>Version 2.0 incorporated major editorial changes in terms of the document
structure and introduced the RSAES-OAEP encryption scheme. This version
continued to support the encryption and signature processes in version 1.5,
although the hash algorithm MD4 was no longer allowed due to cryptanalytic
advances in the intervening years. Version 2.0 was republished as <xref
target="RFC2437"></xref> (which was later obsoleted by <xref target="RFC3447"/>).</t>
</list></t>

<t>Version 2.1:
<list style="empty">
<t>Version 2.1 introduced multi-prime RSA and the RSASSA-PSS signature scheme with appendix along with several editorial improvements. This version continued to support the schemes in version 2.0. Version 2.1 was republished as <xref target="RFC3447"/>.</t>
</list></t>

<t>Version 2.2:
<list style="empty">
<t>Version 2.2 updates the list of allowed hashing algorithms to align them with FIPS 180-4 <xref target="SHS"/>, therefore adding SHA-224, SHA&nbhy;512/224, and SHA-512/256. The following substantive changes were made:

 <list style="symbols">
    <t>Object identifiers for sha224WithRSAEncryption, sha512-224WithRSAEncryption, and sha512-256WithRSAEncryption were added.</t>
    <t>This version continues to support the schemes in version 2.1.</t>
      </list></t>
</list></t>

</section>

<section anchor="appendix_aboutPKCS" title="About PKCS">
<t>The Public-Key Cryptography Standards are specifications produced by RSA Laboratories in cooperation with secure systems developers worldwide for the purpose of accelerating the deployment of public-key cryptography. First published in 1991 as a result of meetings with a small group of early adopters of public-key technology, the PKCS documents have become widely referenced and implemented. Contributions from the PKCS series have become part of many formal and de facto standards, including ANSI X9 and IEEE P1363 documents, PKIX, Secure Electronic Transaction (SET), S/MIME, SSL/TLS, and Wireless Application Protocol (WAP) / WAP Transport Layer Security (WTLS).</t>
<t>Further development of most PKCS documents occurs through the IETF. Suggestions for improvement are welcome.</t>
</section>

<section anchor="Acknowledgements" title="Acknowledgements" numbered="no">
  <t>This document is based on a contribution of RSA Laboratories, the
   research center of RSA Security Inc.</t>
</section>

 </back>
</rfc>
