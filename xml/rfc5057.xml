<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY rfc3261 PUBLIC ''
    'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml'>
  <!ENTITY rfc3263 PUBLIC ''
    'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3263.xml'>
  <!ENTITY rfc3265 PUBLIC ''
    'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3265.xml'>
  <!ENTITY rfc3515 PUBLIC ''
    'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3515.xml'>
  <!ENTITY rfc3911 PUBLIC ''
    'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3911.xml'>
  <!ENTITY rfc3891 PUBLIC ''
    'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3891.xml'>
  <!ENTITY rfc4488 PUBLIC ''
    'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4488.xml'>
  <!ENTITY rfc4538 PUBLIC ''
    'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4538.xml'>
  <!ENTITY rfc3903 PUBLIC ''
    'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3903.xml'>
  <!ENTITY rfc4730 PUBLIC ''
    'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4730.xml'>
]>

<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>

<?rfc symrefs="no"?>    <!-- use symbolic referenc tags -->
<?rfc sortrefs="yes" ?>

<?rfc rfcedstyle="yes"?>

<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc number="5057" category="info">

<front>

<title abbrev="Multiple Dialog Usages">
Multiple Dialog Usages in the Session Initiation Protocol
</title>

<author initials="R." surname="Sparks" fullname="Robert J. Sparks">
 <organization>Estacado Systems</organization>
 <address>
  <email>RjS@estacado.net</email>
  </address>
</author>
<date month="October" year="2007"/>

<abstract>
 <t>
Several methods in the Session Initiation Protocol (SIP) can create
an association between endpoints known as a dialog. Some of
these methods can also create a different, but related, 
association within an existing dialog. These multiple 
associations, or dialog usages, require carefully coordinated 
processing as they have independent
life-cycles, but share common dialog state. Processing multiple dialog
usages correctly is not completely understood. What is understood is
difficult to implement.
</t>
<t>This memo argues that multiple dialog usages should be
avoided. It discusses alternatives to their use and clarifies
essential behavior for elements that cannot currently avoid
them.
 </t>
<t>This is an informative document and makes no normative
statements of any kind.</t>
</abstract>

</front>
<middle>
<section title="Overview">
<t>
This is an informative document. It makes no normative statements of any kind. This document 
refines the concept of a dialog usage in the Session Initiation Protocol (SIP <xref target="RFC3261"/>), and discusses what
led to its existence. It explores ambiguity associated with processing 
multiple dialog usages that share a dialog. In particular, it surveys the effect of SIP failure
responses on transaction, dialog usage, and dialog state. This document will help the implementer understand
what is required to process multiple dialog usages correctly, and
will provide information for future standards-track work that will
clarify RFC 3261 and other related documents. Finally, the document explores
single-usage dialog alternatives (using SIP extensions) to multiple dialog usages.
</t>
</section>
<section title="Introduction">
<t>
Several methods in SIP can establish a dialog. When
they do so, they also establish an association between
the endpoints within that dialog. This association has
been known for some time as a "dialog usage" in the 
developer community.  A dialog initiated with an INVITE 
request has an invite usage.  A dialog initiated with a 
SUBSCRIBE request has a subscribe usage. A dialog initiated
with a REFER request has a subscribe usage.
</t><t>
Dialogs with multiple usages arise when a usage-creating
action occurs inside an existing dialog. Such actions
include accepting a REFER or SUBSCRIBE issued inside a 
dialog established with an INVITE request. Multiple REFERs 
within a dialog create multiple subscriptions, each of which is a
new dialog usage sharing common dialog state. (Note that any
REFER issued utilizing the subscription-suppression mechanism
specified in <xref target="RFC4488"/> creates no new usage.)
Similarly, an endpoint in a dialog established with an INVITE 
might subscribe to its peer's Key Press Markup Language (KPML) <xref target="RFC4730"/> and
later issue a REFER, resulting in three dialog usages sharing common dialog state.
</t><t>
The common state in the dialog shared by any usages is exactly:
<list style="symbols">
<t>the Call-ID</t>
<t>the local Tag</t>
<t>the remote Tag</t>
<t>the local CSeq</t>
<t>the remote CSeq</t>
<t>the Route-set</t>
<t>the local contact</t>
<t>the remote target</t>
<t>the secure flag</t>
</list>
</t><t>
Usages have state that is not shared in the dialog. For example,
a subscription has a duration, along with other usage-specific state.
Multiple subscriptions in the same dialog each have their own duration.
</t><t>
A dialog comes into existence with the creation of the
first usage, and continues to exist until the last usage
is terminated (reference counting).
Unfortunately, many of the usage management aspects of SIP,
such as authentication, 
were originally designed with the implicit assumption that there was
one usage per dialog. The resulting mechanisms have mixed effects,
some influencing the usage, and some influencing the entire dialog.
 </t>
<t>The current specifications define two usages, invite and subscribe.
A dialog can share up to one invite usage and arbitrarily many
subscribe usages. </t>
<t>Because RFC 3261 <xref target="RFC3261"/> states that user-agents should reuse
Call-ID and increment CSeq across a series of registration requests (and that to-tags
appear in register responses in some of the examples), some implementations have treated
REGISTER as if it were in a dialog. However, RFC 3261 explicitly calls out that REGISTER
does not create a dialog.  A series of REGISTER requests does not create any usage or 
dialog. Similarly, PUBLISH <xref target="RFC3903"/> does not create any usage or dialog.
</t>
<!--
0         1         2         3         4         5         6         7        
01234567890123456789012345678901234567890123456789012345678901234567890123456789
-->
</section>
<section title="Examples of Multiple Usages" anchor="simpleexamples">
<section title="Transfer">
<t>
In <xref target="transferexample"/>, Alice transfers a call she
received from Bob to Carol. A dialog (and an invite dialog usage)
between Alice and Bob comes into being with the 200 OK labeled F1.
A second usage (a subscription to event refer) comes into being 
with the NOTIFY labeled F2. This second usage ends when the
subscription is terminated by the NOTIFY transaction labeled F3. 
The dialog still has one usage (the invite usage), which lasts 
until the BYE transaction labeled F4. At this point, the dialog
has no remaining usages, so it ceases to exist. Details of each
of these messages are shown in <xref target="transferexampledetails"/>.
</t>
<figure anchor="transferexample"><artwork><![CDATA[
                             Alice              Bob         Carol
                               |    INVITE       |            |
                               |<----------------|            |
 Dialog 1  Usage 1             |    200 OK (F1)  |            |
 -start-   -start- ----------->|---------------->|            |
    |         |                |    ACK          |            |
    |         |                |<----------------|            |
    |         |                | reINVITE/200/ACK|            |
    |         |                |   (hold)        |            |
    |         |                |---------------->|            |
    |         |                |   REFER         |            |
    |         |     Dialog 1   |---------------->|            |
    |         |     Usage 2    |   NOTIFY (F2)   |            |
    |         |     -start- -->|<----------------| INVITE     |
    |         |        |       |   200 NOTIFY    |----------->|
    |         |        |       |---------------->| 200 OK     |
    |         |        |       |   200 REFER     |<-----------|
    |         |        |       |<----------------| ACK        |
    |         |        |       |   NOTIFY (F3)   |----------->|
    |         |        |       |<----------------|            |
    |         |        |       |   200           |     .      |
    |         |      -end-  -->|---------------->|     .      |
    |         |                |   BYE (F4)      |  Dialog 2  |
    |         |                |<----------------|  proceeds  |
    |         |                |   200           |     .      |
  -end-     -end- ------------>|---------------->|     .      |
]]>
</artwork></figure>
<figure anchor="transferexampledetails"><artwork><![CDATA[
  Message Details (abridged to show only dialog or usage details)
  F1
    SIP/2.0 200 OK
    Call-ID: dialog1@bob.example.com
    CSeq: 100 INVITE
    To: <sip:Alice@alice.example.com>;tag=alicetag1
    From: <sip:Bob@bob.example.com>;tag=bobtag1    
    Contact: <sip:aliceinstance@alice.example.com>

  F2
    NOTIFY sip:aliceinstance@alice.example.com SIP/2.0
    Event: refer
    Call-ID: dialog1@bob.example.com
    CSeq: 101 NOTIFY
    To: <sip:Alice@alice.example.com>;tag=alicetag1
    From: <sip:Bob@bob.example.com>;tag=bobtag1    
    Contact: <sip:bobinstance@bob.example.com>

  F3
    NOTIFY sip:aliceinstance@alice.example.com SIP/2.0
    Event: refer
    Subscription-State: terminated;reason=noresource
    Call-ID: dialog1@bob.example.com
    CSeq: 102 NOTIFY
    To: <sip:Alice@alice.example.com>;tag=alicetag1
    From: <sip:Bob@bob.example.com>;tag=bobtag1    
    Contact: <sip:bobinstance@bob.example.com>
    Content-Type: message/sipfrag

    SIP/2.0 200 OK
   
  F4
    BYE sip:aliceinstance@alice.example.com SIP/2.0
    Call-ID: dialog1@bob.example.com
    CSeq: 103 BYE
    To: <sip:Alice@alice.example.com>;tag=alicetag1
    From: <sip:Bob@bob.example.com>;tag=bobtag1    
    Contact: <sip:bobinstance@bob.example.com>
    
]]>
</artwork></figure>
</section>
<?rfc needLines="30"?>
<section title="Reciprocal Subscription">
<t>
In <xref target="subscribeexample"/>, Alice subscribes
to Bob's presence. For simplicity, assume Bob and Alice
are both serving their presence from their endpoints
instead of a presence server. To focus on the essential points, the figure
leaves out any rendezvous signaling through which
Alice discovers Bob's endpoint. 
</t>
<t>
Bob is interested in Alice's presence too, so he 
subscribes to Alice (in most deployed presence/IM
systems, people watch each other). He decides to skip
the rendezvous step since he's already in a dialog
with Alice, and sends his SUBSCRIBE inside that dialog
(a few early SIMPLE clients behaved exactly this way).
</t>
<t>The dialog and its first usage comes into being at
F1, which establishes Alice's subscription to 
Bob. Its second usage begins at F2, which establishes
Bob's subscription to Alice. These two subscriptions
are independent - they have distinct and different
expirations, but they share all the dialog state.
</t>
<t>The first usage ends when Alice decides to unsubscribe
at F3. Bob's subscription to Alice, and thus the dialog,
continues to exist. Alice's UA must maintain this dialog
state even though the subscription that caused it to exist
in the first place is now over. The second usage ends when Alice
decides to terminate Bob's subscription at F4 (she's
probably going to reject any attempt on Bob's part to 
resubscribe until she's ready to subscribe to Bob again).
Since this was the last usage, the dialog also terminates.
Details of these messages are shown in <xref target="subscribeexampledetails"/>.
</t>
<figure anchor="subscribeexample"><artwork><![CDATA[
                            Alice                 Bob
                              |                    |
                              | SUBSCRIBE          |
                              |------------------->|
 Dialog    Usage 1            | NOTIFY (F1)        |
 -start-   -start-  --------->|<-------------------|
    |         |               | 200 SUBSCRIBE      |
    |         |               |<-------------------|
    |         |               | 200 NOTIFY         |
    |         |               |------------------->|
    |         |               | SUBSCRIBE          |
    |         |               |<-------------------|
    |         |    Usage 2    | NOTIFY (F2)        |
    |         |    -start- -->|------------------->|
    |         |       |       | 200 SUBSCRIBE
    |         |       |       |------------------->|
    |         |       |       | 200 NOTIFY         |
    |         |       |       |<-------------------|
    |         |       |       |         :          |
    |         |       |       |         :          |
    |         |       |       | (un)SUBSCRIBE (F3) |
    |         |       |       |------------------->|
    |         |       |       | 200                |
    |         |       |       |<-------------------|
    |         |       |       | NOTIFY             |
    |         |       |       |<-------------------|
    |         |       |       | 200                |
    |       -end- ----------->|------------------->|
    |                 |       |         :          |
    |                 |       |         :          |
    |                 |       | NOTIFY        (F4) |
    |                 |       | (Terminated)       |
    |                 |       |------------------->|
    |                 |       | 200                |
  -end-             -end-  -->|<-------------------|
                              |                    |
]]>
</artwork></figure>
<figure anchor="subscribeexampledetails"><artwork><![CDATA[
  Message Details (abridged to show only dialog or usage details)
  F1
    NOTIFY sip:aliceinstance@alice.example.com SIP/2.0
    Event: presence
    Subscription-State: active;expires=600
    Call-ID: alicecallid1@alice.example.com
    From: <sip:Bob@bob.example.com>;tag=bobtag2
    To: <sip:Alice@alice.example.com>;tag=alicetag2
    CSeq: 100 NOTIFY
    Contact: <sip:bobinstance@bob.example.com>

  F2
    NOTIFY sip:bobinstance@bob.example.com SIP/2.0
    Event: presence
    Subscription-State: active;expires=1200
    Call-ID: alicecallid1@alice.example.com
    To: <sip:Bob@bob.example.com>;tag=bobtag2
    From: <sip:Alice@alice.example.com>;tag=alicetag2
    CSeq: 500 NOTIFY
    Contact: <sip:aliceinstance@alice.example.com>

  F3 
    SUBSCRIBE sip:bobinstance@bob.example.com SIP/2.0
    Event: presence
    Expires: 0
    Call-ID: alicecallid1@alice.example.com
    To: <sip:Bob@bob.example.com>;tag=bobtag2
    From: <sip:Alice@alice.example.com>;tag=alicetag2
    CSeq: 501 SUBSCRIBE
    Contact: <sip:aliceinstance@alice.example.com>

  F4
    NOTIFY sip:bobinstance@bob.example.com SIP/2.0
    Event: presence
    Subscription-State: terminated;reason=deactivated
    Call-ID: alicecallid1@alice.example.com
    To: <sip:Bob@bob.example.com>;tag=bobtag2
    From: <sip:Alice@alice.example.com>;tag=alicetag2
    CSeq: 502 NOTIFY
    Contact: <sip:aliceinstance@alice.example.com>

]]>
</artwork></figure>
</section>
</section>
<section title="Usage Creation and Destruction">
<t> Dialogs come into existence along with their first usage.
Dialogs terminate when their last usage is destroyed. The messages
that create and destroy usages vary per usage. This section provides
a high-level categorization of those messages. The section does not
attempt to explore the REGISTER pseudo-dialog.
</t>
<section title="Invite Usages">
<list style="hanging">
<t hangText="Created by:"> non-100 provisional responses to INVITE; 200 response to INVITE</t>
<t hangText="Destroyed by:"> 200 responses to BYE; certain failure responses to INVITE, UPDATE, PRACK, INFO, or BYE; anything that destroys a dialog and all its usages</t>
</list>
</section>
<section title="Subscribe usages">
<list style="hanging">
<t hangText="Created by:"> 200 class responses to SUBSCRIBE; 200 class responses to REFER; NOTIFY requests</t>
<t hangText="Destroyed by:"> 200 class responses to NOTIFY-terminated; NOTIFY or refresh-SUBSCRIBE request timeout; certain failure responses to NOTIFY or SUBSCRIBE; expiration without refresh if network issues prevent the terminal NOTIFY from arriving; anything that destroys a dialog and all its usages</t>
</list>
</section>
</section>
<section title="Proper Handling of Multiple Usages" anchor="handling">
<t> The examples in <xref target="simpleexamples"/> show
    straightforward cases where it is fairly obvious when
    the dialog begins and ends. Unfortunately, there are
    many scenarios where such clarity is not present. For
    instance, in <xref target="transferexample"/>, what would
    it mean if the response to the NOTIFY (F2) were a 481? Does
    that simply terminate the refer subscription, or does it
    destroy the entire dialog? This section explores the problem
    areas with multiple usages that have been identified to date.
  </t>
<section anchor="survey" title="A Survey of the Effect of Failure Responses on Usages and Dialogs">
<t> For this survey, consider a subscribe usage inside a dialog established
with an invite usage. Unless stated otherwise, we'll discuss the effect on
each usage and the dialog when a client issuing a NOTIFY inside the
subscribe usage receives a failure response (such as a transferee
issuing a NOTIFY to event refer). Further, unless otherwise stated,
the conclusions apply to arbitrary multiple usages.
</t>
<?rfc needLines="10"?>
<t>This survey is written from the perspective of a client receiving the
error response. The effect on dialogs and usages at the server issuing
the response is the same.
</t>
<t><list style="hanging">
<t hangText="3xx responses:"> 
Redirection mid-dialog is not well understood in SIP,
but whatever effect it has impacts the entire dialog and 
all of its usages equally.
In our example scenario, both the subscription and the invite usage would be
redirected by this single response.
</t>
</list></t>
<t>
For the failure responses with code 400 and greater, there are three common ways the failure can
affect the transaction, usage, and dialog state.
<list style="hanging">
<t hangText="Transaction Only">
The error affects only the transaction, not the usage 
or dialog the transaction occurs in (beyond affecting the local CSeq). 
Any other usage of the dialog is unaffected. The error is a complaint 
about this transaction, not the usage or dialog that the transaction occurs in.
</t>
<t hangText="Destroys Usage">
The error destroys the usage, but not the dialog. Any other usages sharing this dialog are not affected.
</t>
<t hangText="Destroys Dialog">
The error destroys the dialog and all usages sharing it.
</t>
</list>
</t>
<t><xref target="codetable"/> and <xref target="codelisttable"/> display how the various codes affect transaction, usage, or dialog state.
Response code specific comments or exceptions follow the table.
</t>
<t>
<texttable anchor="codetable">
<ttcol align='center'>Transaction Only</ttcol>
<ttcol align='center'>Destroys Usage</ttcol>
<ttcol align='center'>Destroys Dialog</ttcol>
<c>400 (or unknown 4xx) </c><c>405, 480      </c><c>404, 410, 416</c>
<c>401, 402, 403, 406  </c><c>481, 489     </c><c>482, 483     </c>
<c>407, 408, 412-415   </c><c>501            </c><c>484, 485      </c>
<c>417, 420, 421, 422  </c><c>                </c><c>502, 604      </c>
<c>423, 428, 429       </c><c>                </c><c>                </c>
<c>436-438, 486, 487   </c><c>                </c><c>                </c>
<c>488, 491, 493, 494   </c><c>                </c><c>                </c>
<c>500 (or unknown 5xx)</c><c>                </c><c>                </c>
<c>503, 504, 505      </c><c>                </c><c>                </c>
<c>513, 580              </c><c>                </c><c>                </c>
<c>600 (or unknown 6xx)</c><c>                </c><c>                </c>
<c>603, 606            </c><c>                </c><c>                </c>

</texttable>
<?rfc needLines="100"?>
<texttable anchor="codelisttable">
<ttcol align='center'>Code</ttcol>
<ttcol align='left'>Reason</ttcol>
<ttcol align='center'>Impact</ttcol>
<ttcol align='center'>Notes</ttcol>
<c>400/4xx</c><c>Bad Request</c><c>Transaction</c><c></c>
<c>401</c><c>Unauthorized</c><c>Transaction</c><c></c>
<c>402</c><c>Payment Required</c><c>Transaction</c><c>(1)</c>
<c>403</c><c>Forbidden</c><c>Transaction</c><c></c>
<c>404</c><c>Not Found</c><c>Dialog</c><c>(2)</c>
<c>405</c><c>Method Not Allowed</c><c>Usage</c><c>(3)</c>
<c>406</c><c>Not Acceptable</c><c>Transaction</c><c></c>
<c>407</c><c>Proxy Authentication Required</c><c>Transaction</c><c></c>
<c>408</c><c>Request Timeout</c><c>Transaction</c><c>(4)</c>
<c>410</c><c>Gone</c><c>Dialog</c><c>(2)</c>
<c>412</c><c>Conditional Request Failed</c><c>Transaction</c><c></c>
<c>413</c><c>Request Entity Too Large</c><c>Transaction</c><c></c>
<c>414</c><c>Request-URI Too Long</c><c>Transaction</c><c></c>
<c>415</c><c>Unsupported Media Type</c><c>Transaction</c><c></c>
<c>416</c><c>Unsupported URI Scheme</c><c>Dialog</c><c>(2)</c>
<c>417</c><c>Unknown Resource-Priority</c><c>Transaction</c><c></c>
<c>420</c><c>Bad Extension</c><c>Transaction</c><c></c>
<c>421</c><c>Extension Required</c><c>Transaction</c><c></c>
<c>422</c><c>Session Interval Too Small</c><c>Transaction</c><c>(5)</c>
<c>423</c><c>Interval Too Brief</c><c>Transaction</c><c></c>
<c>428</c><c>Use Identity Header</c><c>Transaction</c><c></c>
<c>429</c><c>Provide Referrer Identity</c><c>Transaction</c><c>(6)</c>
<c>436</c><c>Bad Identity-Info</c><c>Transaction</c><c></c>
<c>437</c><c>Unsupported Certificate</c><c>Transaction</c><c></c>
<c>438</c><c>Invalid Identity Header</c><c>Transaction</c><c></c>
<c>480</c><c>Temporarily Unavailable</c><c>Usage</c><c>(7)</c>
<c>481</c><c>Call/Transaction Does Not Exist</c><c>Usage</c><c>(8)</c>
<c>482</c><c>Loop Detected</c><c>Dialog</c><c>(9)</c>
<c>483</c><c>Too Many Hops</c><c>Dialog</c><c>(10)</c>
<c>484</c><c>Address Incomplete</c><c>Dialog</c><c>(2)</c>
<c>485</c><c>Ambiguous</c><c>Dialog</c><c>(2)</c>
<c>486</c><c>Busy Here</c><c>Transaction</c><c>(11)</c>
<c>487</c><c>Request Terminated</c><c>Transaction</c><c></c>
<c>488</c><c>Not Acceptable Here</c><c>Transaction</c><c></c>
<c>489</c><c>Bad Event</c><c>Usage</c><c>(12)</c>
<c>491</c><c>Request Pending</c><c>Transaction</c><c></c>
<c>493</c><c>Undecipherable</c><c>Transaction</c><c></c>
<c>494</c><c>Security Agreement Required</c><c>Transaction</c><c></c>
<c>500/5xx</c><c>Server Internal Error</c><c>Transaction</c><c>(13)</c>
<c>501</c><c>Not Implemented</c><c>Usage</c><c>(3)</c>
<c>502</c><c>Bad Gateway</c><c>Dialog</c><c>(14)</c>
<c>503</c><c>Service Unavailable</c><c>Transaction</c><c>(15)</c>
<c>504</c><c>Server Time-Out</c><c>Transaction</c><c>(16)</c>
<c>505</c><c>Version Not Supported</c><c>Transaction</c><c></c>
<c>513</c><c>Message Too Large</c><c>Transaction</c><c></c>
<c>580</c><c>Precondition Failure</c><c>Transaction</c><c></c>
<c>600/6xx</c><c>Busy Everywhere</c><c>Transaction</c><c>(17)</c>
<c>603</c><c>Decline</c><c>Transaction</c><c></c>
<c>604</c><c>Does Not Exist Anywhere</c><c>Dialog</c><c>(2)</c>
<c>606</c><c>Not Acceptable</c><c>Transaction</c><c></c>
</texttable>
</t>
<t><list style="hanging">
<t hangText="(1) 402 Payment Required:">
This is a reserved response code. If encountered, it
should be treated as an unrecognized 4xx.</t>
<t hangText="(2) 404 Not Found:"></t>
<t hangText="    410 Gone:"></t>
<t hangText="    416 Unsupported URI Scheme:"></t>
<t hangText="    484 Address Incomplete:"></t>
<t hangText="    485 Ambiguous:"></t>
<t hangText="    604 Does Not Exist Anywhere:"></t>
<t>
The Request-URI that is being rejected is the remote target set by the Contact
provided by the peer. Getting this response means that something has gone
fundamentally wrong with the dialog state.</t>
<t hangText="(3) 405 Method Not Allowed:"></t>
<t hangText="    501 Not Implemented:"></t>
<t>
Either of these responses would be aberrant in our example scenario since
support for the NOTIFY method is required by the usage. In this case, the
UA knows the condition is unrecoverable and should stop sending NOTIFYs
on the usage. Any refresh subscriptions should be rejected. In general,
these errors will affect at most the usage. If the request was not integral
to the usage (it used an unknown method, or was an INFO inside an INVITE usage,
for example), only the transaction will be affected.</t>
<t hangText="(4) 408 Request Timeout:">Receiving a 408 will have the
same effect on usages and dialogs as a real transaction timeout
as described in 
<xref target="timeout"/>.
</t>
<t hangText="(5) 422 Session Interval Too Small:">
This response does not make sense for any mid-usage request. If it is
received, an element in the path of the request is violating protocol,
and the recipient should treat this as it would an unknown 4xx 
response. 
</t>
<t hangText="(6) 429 Provide Referrer Identity:">
This response won't be returned to a NOTIFY as in our example
scenario, but when it is returned to a REFER, it is objecting
only to the REFER request itself.
</t>
<t hangText="(7) 480 Temporarily Unavailable:">
RFC 3261 is unclear on what this response means for mid-usage
requests. Future updates to that specification are expected to clarify
that this response affects only the usage in which the request occurs. No other usages
are affected. If the response included a Retry-After header field,
further requests in that usage should not be sent until the indicated
time has past. Requests in other usages may still be sent at any time.
</t>
<t hangText="(8) 481 Call/Transaction Does Not Exist:">
This response indicates that the peer has lost its copy of the
dialog usage state. The dialog itself should not be destroyed unless
this was the last usage.
</t>
<t>
The effects of a 481 on a dialog and its usages are the most
ambiguous of any final response. There are implementations that
have chosen the meaning recommended here, and others that destroy 
the entire dialog
without regard to the number of outstanding usages. Going forward with
this clarification will allow those deployed implementations that assumed
only the usage was destroyed to work with a wider number of implementations.
Existing implementations that destroy all other usages in the dialog
will continue to function as they do now, except that peers following the
recommendation will attempt to do things with the other usages and
this element will return 481s for each of them until they are all gone.
However, the necessary clarification to RFC 3261 needs to make it very clear that the
ability to terminate usages independently from the overall dialog using a 481
is not justification for designing new applications that count on multiple
usages in a dialog.
</t>
<t>
The 481 response to a CANCEL request has to be treated differently. For CANCEL,
a 481 means the UAS can't find a matching transaction. A 481 response to
a CANCEL affects only the CANCEL transaction. The usage associated with the INVITE
is not affected.
</t>
<t hangText="(9) 482 Loop Detected:">
This response is aberrant mid-dialog. It will only occur if
the Record-Route header field were improperly constructed by 
the proxies involved in setting up the dialog's initial usage,
or if a mid-dialog request forks and merges (which should never
happen). Future requests using this dialog state will also
fail. 
</t>
<t><list style="hanging">
<t hangText="">An edge condition exists during RFC 3263 failover
at the element sending a request, where the request effectively
forks to multiple destinations from the client. Some implementations
increase risk entering this edge condition by trying the next 
potential location as determined by RFC 3263 very rapidly if the first
does not immediately respond. In any situation where a client sends the
same request to more than one endpoint, it must be prepared to receive
a response from each branch (and should choose a "best" response to act
on following the same guidelines as a forking proxy). In this particular
race condition, if multiple branches respond, all but one will most likely
return a 482 Merged Request. The client should select the remaining
non-482 response as the "best" response.</t>
</list></t>
<t hangText="(10) 483 Too Many Hops:">
Similar to 482, receiving this mid-dialog is aberrant. 
Unlike 482,
 recovery
may be possible by increasing Max-Forwards (assuming that the
requester did something strange like using a smaller value for
Max-Forwards in mid-dialog requests than it used for an initial
request). If the request isn't tried with an increased Max-Forwards,
then the agent should follow the Destroy Dialog actions.
</t>
<t hangText="(11) 486 Busy Here:">
This response is nonsensical in our example scenario, or in any
scenario where this response comes inside an established usage.
If it occurs in that context, it should be treated as an unknown
4xx response.</t>
<t hangText="(12) 489 Bad Event:">
In our example scenario, <xref target="RFC3265"/> declares that the 
subscription usage in which the NOTIFY is sent is terminated. 
This response is only valid in the context of SUBSCRIBE and NOTIFY. UAC
behavior for receiving this response to other methods is not specified,
but treating it as an unknown 4xx is a reasonable practice.
</t>
<t hangText="(13) 500 and 5xx unrecognized responses:">
If the response contains a Retry-After header field value,
the server thinks the condition is temporary, and the request can be
retried after the indicated interval. 
If the response does not contain
a Retry-After header field value, the UA may decide to retry after
an interval of its choosing or attempt to gracefully terminate the
usage. Whether or not to terminate other usages depends on the
application. If the UA receives a 500 (or unrecognized 5xx) in
response to an attempt to gracefully terminate this usage, it
can treat this usage as terminated. If this is the last usage sharing
the dialog, the dialog is also terminated.
</t>
<t hangText="(14) 502 Bad Gateway:">
This response is aberrant mid-dialog. It will only occur if
the Record-Route header field were improperly constructed by 
the proxies involved in setting up the dialog's initial usage.
Future requests using this dialog state will also
fail. 
</t>
 
<t hangText="(15) 503 Service Unavailable:">
As per <xref target="RFC3263"/>, the logic handling locating
SIP servers for transactions may handle 503 requests (effectively,
sequentially forking at the endpoint based on DNS results). If 
this process does not yield a better response, a 503 may be returned 
to the transaction user. Like a 500 response, the error is a 
complaint about this transaction, not the usage. 
Because this response occurred in the context of an established usage
(hence an existing dialog), the route-set has already been formed
and any opportunity to try alternate servers (as recommended in
<xref target="RFC3261"/>) has been exhausted by the RFC3263 logic.
</t>
 
<t hangText="(16) 504 Server Time-out:">
It is not obvious under what circumstances this response would
be returned to a request in an existing dialog. 
</t>
 
<t hangText="(17) 600 and 6xx unrecognized responses:">
Unlike 400 Bad Request, a 600 response code says something
about the recipient user, not the request that was made.
This end user is stating an unwillingness to communicate.
If the response contains a Retry-After header field value,
the user is indicating willingness to communicate later
 and the request can be
retried after the indicated interval. This usage, and any other usages
sharing the dialog are unaffected. If the response does not contain
a Retry-After header field value, the UA may decide to retry after
an interval of its choosing or attempt to gracefully terminate the
usage. Whether or not to terminate other usages depends on the
application. If the UA receives a 600 (or unrecognized 6xx) in
response to an attempt to gracefully terminate this usage, it
can treat this usage as terminated. If this is the last usage sharing
the dialog, the dialog is also terminated.
</t>
 
</list></t>
</section>
<section anchor="timeout" title="Transaction Timeouts">
<t>
<xref target="RFC3261"/> states that a UAC should terminate
a dialog (by sending a BYE) if no response is received for a request
sent within a dialog. This recommendation should have been limited to
the invite usage instead of the whole dialog.  <xref target="RFC3265"/> states 
that a timeout for a NOTIFY removes a subscription, but a SUBSCRIBE 
that fails with anything other than a 481 does not. 
Given these statements, it is unclear whether a refresh SUBSCRIBE issued 
in a dialog shared with an invite usage destroys either usage or the dialog
if it times out.
</t>
<t>
Generally, a transaction timeout should affect only the usage in
which the transaction occurred. Other uses sharing the dialog should
not be affected. In the worst case of timeout due to total transport
failure, it may require multiple failed messages to remove all usages 
from a dialog (at least one per usage).
</t>
<t>
There are some mid-dialog messages that never belong
to any usage. If they timeout, they will have no effect on
the dialog or its usages.
</t>
</section>
<section title="Matching Requests to Usages">
<t>
For many mid-dialog requests, identifying the usage they 
belong to is obvious. A dialog can have at most one invite
usage, so any INVITE, UPDATE, PRACK, ACK, CANCEL, BYE, or INFO
requests belong to it. The usage (i.e. the particular subscription)
SUBSCRIBE, NOTIFY, and REFER requests belong to can be determined 
from the Event header field of the request. REGISTER requests
within a (pseudo)-dialog belong to the registration usage. (As
mentioned before, implementations aren't mixing registration
usages with other usages, so this document isn't exploring
the consequences of that bad behavior).
</t>
<t>
According to <xref target="RFC3261"/>, "an
OPTIONS request received within a dialog generates a 200
OK response that is identical to one constructed outside
a dialog and does not have any impact on that dialog". Thus,
OPTIONS does not belong to any usage. Only those failures
discussed in <xref target="survey"/> and <xref target="timeout"/>
that destroy entire dialogs will have any effect on the usages
sharing the dialog with a failed OPTIONS request.
</t>
<t>
MESSAGE requests are discouraged inside a dialog. Implementations
are restricted from creating a usage for the purpose of carrying
a sequence of MESSAGE requests  (though
some implementations use it that way, against the standard
recommendation).  A failed MESSAGE occurring inside an existing
dialog will have similar effects on the dialog and its usages
as a failed OPTIONS request.
</t>
<t>
Mid-dialog requests with unknown methods cannot be matched
with a usage. Servers will return a failure response (likely
a 501). The effect on the dialog and its usages at either the
client or the server should be similar to that of a failed OPTIONS 
request.
</t>
<t>
These guidelines for matching messages to usages (or determining
there is no usage) apply equally when acting as a UAS, a UAC, or any
third party tracking usage and dialog state by inspecting all messages
between two endpoints.
</t>
</section>
<section title="Target Refresh Requests">
<t>Target refresh requests update the remote target of a dialog
when they are successfully processed. The currently defined target
refresh requests are INVITE, UPDATE, SUBSCRIBE, NOTIFY, and REFER
<xref target="RFC3515"/>).
</t>
<t>The remote target is part of the dialog state. When a target refresh
request affects it, it affects it for ALL usages sharing that dialog.
If a subscription and invite usage are sharing a dialog, sending a
refresh SUBSCRIBE with a different contact will cause reINVITEs from
the peer to go to that different contact.
</t>
<t>A UAS will only update the remote target if it sends a 200
class response to a target refresh request. A UAC will only
update the remote target if it receives a 200 class response
to a target refresh request. Again, any update to a dialog's
remote target affects all usages of that dialog.</t>
<t>
There is known ambiguity around the effects of provisional responses
on remote targets that a future specification will attempt to clarify.
Furthermore, because the remote target is part of the dialog state,
not any usage state, there is ambiguity in having target refresh
requests in progress simultaneously on multiple usages in the same dialog.
Implementation designers should consider these conditions with care.
</t>
</section>
<section title="Refreshing and Terminating Usages">
<t>Subscription and registration usages expire over time and must be
refreshed (with a refresh SUBSCRIBE, for example). This expiration
is usage state, not dialog state. If several subscriptions share
a dialog, refreshing one of them has no effect on the expiration
of the others.</t>
<t>Normal termination of a usage has no effect on other usages
sharing the same dialog. For instance, terminating a subscription 
with a NOTIFY/Subscription-State: terminated will not terminate
an invite usage sharing its dialog. Likewise, ending an invite
usage with a BYE does not terminate any active Event: refer
subscriptions established on that dialog.</t>
</section>
<section title="Refusing New Usages">
<t>As the survey of the effect of failure responses shows, care
must be taken when refusing a new usage inside an existing dialog.
Choosing the wrong response code will terminate the dialog and all
of its usages. Generally, returning a 603 Decline is the safest 
way to refuse a new usage.</t>
</section>
<section title="Replacing Usages">
<t>
<xref target="RFC3891"/> defines a mechanism through
which one usage can replace another. It can be used, for example, to
associate the two dialogs in which a transfer target is involved during
an attended transfer. It is written using the term "dialog", but its
intent was only to affect the invite usage of the dialog it targets.
Any other usages inside that dialog are unaffected. For some applications,
the other usages may no longer make sense, and the application may
terminate them as well.
</t>
<t>However, the interactions between Replaces and multiple dialog usages
have not been well explored. More discussion of this topic is needed.
Implementers should avoid this scenario completely.
</t>
</section>
</section>
<section title="Avoiding Multiple Usages">
<t>
Processing multiple usages correctly is not completely understood. What is
understood is difficult to implement and is very likely to lead to
interoperability problems. The best way to avoid the trouble that comes 
with such complexity is to avoid it altogether.
</t>
<t>When designing new applications or features that use SIP dialogs, do not 
require endpoints to construct multiple usages to participate in the application
or use the feature. When designing endpoints, address the existing multiple usage
scenarios as best as possible. Outside those scenarios, if a peer attempts to 
create a second usage inside a dialog, refuse it.</t>
<t>Unfortunately, there are existing applications, like transfer,
that currently entail multiple usages, so the simple solution of
"don't do it" will require some transitional work. This section 
looks at the pressures that led to these existing multiple usages and
suggests alternatives.</t>
<?rfc needLines="30"?>
<t>When executing a transfer, the transferor and transferee currently 
share an invite usage and a subscription usage within the dialog between 
them. This is a result of sending the REFER request within the dialog
established by the invite usage. Implementations were led to this
behavior by these primary problems:
<list style="numbers">
<t>There was no way to ensure that a REFER on a new dialog
   would reach the particular endpoint involved in a transfer.
   Many factors, including details of implementations and changes
   in proxy routing between an INVITE and a REFER could cause the
   REFER to be sent to the wrong place. Sending the REFER down the
   existing dialog ensured it got to the same endpoint with which the dialog
   was established. </t>
<t>It was unclear how to associate an existing invite usage
   with a REFER arriving on a new dialog, where it was completely
   obvious what the association was when the REFER came on the
   invite usage's dialog. </t>
<t>There were concerns with authorizing out-of-dialog REFERs.
   The authorization policy for REFER in most implementations 
   piggybacks on the authorization policy for INVITE (which is, 
   in most cases, based simply on "I placed or answered this call").</t>
</list>
</t>
<t>Globally Routable User Agent (UA) URIs (GRUUs) <xref target="SIP-GRUU"/> have been defined
specifically to address problem 1 by providing a URI that will reach
one specific user-agent.  The Target-Dialog header field
<xref target="RFC4538"/> was created to address problems 2 and 3. This header
field allows a request to indicate the dialog identifiers of some other dialog,
providing association with the other dialog that can be used in an authorization
decision.
</t>
<t>The Join <xref target="RFC3911"/> and 
Replaces <xref target="RFC3891"/> mechanisms can also be used to address problem 1. 
When using this technique, a new request is sent outside any dialog with
the expectation that it will fork to possibly many endpoints, including
the one we're interested in. This request contains a header field
listing the dialog identifiers of a dialog in progress. Only the endpoint
holding a dialog matching those identifiers will accept the request.
The other endpoints the request may have forked to will respond with an
error. This mechanism is reasonably robust, failing only when the routing
logic for out-of-dialog requests changes such that the new request does not arrive
at the endpoint holding the dialog of interest.</t>
<t>The reachability aspects of using a GRUU to address problem 1 can be
combined with the association-with-other-dialogs aspects of the Join/Replaces
and Target-Dialog mechanisms.  A REFER request sent out-of-dialog can be sent towards a GRUU, and
identify an existing dialog as part of the context the receiver should use. 
The Target-Dialog header field can be included 
in the REFER listing the dialog this REFER is associated with.
<xref target="goodrefer"/> sketches how this could be used to achieve transfer
without reusing a dialog. For simplicity, the diagram and message details
do not show the server at example.com that will be involved in routing
the GRUU. Refer to <xref target="SIP-GRUU"/> for those details.
</t>
<figure anchor="goodrefer" title="Transfer without dialog reuse">
<artwork><![CDATA[

Alice                             Bob                           Carol
  |                                |                              |
  | F1 INVITE (Bob's AOR)          |                              |
  |    Call-ID: (call-id one)      |                              |
  |    Contact: (Alice's-GRUU)     |                              |
  |------------------------------->|                              |
  | F2 200 OK                      |                              |
  |    To: <>;tag=totag1           |                              |
  |    From: <>;tag=fromtag1       |                              |
  |    Call-ID: (call-id one)      |                              |
  |    Contact: (Bob's-GRUU)       |                              |
  |<-------------------------------|                              |
  |    ACK                         |                              |
  |------------------------------->|                              |
  |             :                  |                              |
  |  (Bob places Alice on hold)    |                              |
  |             :                  | F3 INVITE (Carol's AOR)      |
  |                                |    Call-ID: (call-id two)    |
  |                                |    Contact: (Bob's-GRUU)     |
  |                                |----------------------------->|
  |                                | F4 200 OK                    |
  |                                |    To: <>;tag=totag2         |
  |                                |    From: <>;tag=fromtag2     |
  |                                |    Call-ID: (call-id two)    |
  |                                |    Contact: (Carol's-GRUU)   |
  |                                |<-----------------------------|
  |                                |    ACK                       |
  |                                |----------------------------->|
  |                                |            :                 |
  |                                |  (Bob places Carol on hold)  |
  | F5 REFER (Alice's-GRUU)        |            :                 |
  |    Call-ID: (call-id three)    |                              |
  |    Refer-To: (Carol's-GRUU)    |                              |
  |    Target-Dialog: (call-id one,totag1,fromtag1)               |
  |    Contact: (Bob's-GRUU)       |                              |
  |<-------------------------------|                              |
  |    202 Accepted                |                              |
  |------------------------------->|                              |
  |    NOTIFY (Bob's-GRUU)         |                              |
  |    Call-ID: (call-id three)    |                              |
  |------------------------------->|                              |
  |    200 OK                      |                              |
  |<-------------------------------|                              |
  |                                |                              |
  |                  F6 INVITE (Carol's-GRUU)                     | 
  |                     Call-ID: (call-id four)                   |
  |                     Contact: (Alice's-GRUU)                   |
  |-------------------------------------------------------------->|
  |                     200 OK                                    |
  |                     Contact: (Carol's-GRUU)                   |
  |<--------------------------------------------------------------|
  |                     ACK                                       |
  |-------------------------------------------------------------->|
  |                                |                              |
  | F7 NOTIFY (Bob's-GRUU)         |                              |
  |    Call-ID: (call-id three)    |                              |
  |------------------------------->|                              |
  |    200 OK                      |                              |
  |<-------------------------------|                              |
  |    BYE (Alice's-GRUU)          |                              |
  |    Call-ID: (call-id one)      |                              |
  |<-------------------------------|   BYE (Carol's-GRUU)         |
  |                                |   Call-ID: (call-id two)     |
  |    200 OK                      |----------------------------->|
  |------------------------------->|   200 OK                     |
  |                                |<-----------------------------|
  |                                |                              |

]]></artwork></figure>

<t>
In message F1, Alice invites Bob indicating support for GRUUs
(and offering a GRUU for herself):
</t>
<figure><artwork><![CDATA[
   Message F1 (abridged, detailing pertinent fields)

     INVITE sip:bob@example.com SIP/2.0
     Call-ID: 13jfdwer230jsdw@alice.example.com
     Supported: gruu
     Contact: <sip:alice@example.com;gr=urn:uuid:(Alice's UA's bits)> 

]]></artwork></figure>

<t>
Message F2 carries Bob's GRUU to Alice.
<figure><artwork><![CDATA[
   Message F2 (abridged, detailing pertinent fields)

     SIP/2.0 200 OK
     Supported: gruu
     To: <sip:bob@example.com>;tag=totag1
     From: <sip:alice@example.com>;tag=fromtag1
     Contact: <sip:bob@example.com;gr=urn:uuid:(Bob's UA's bits)> 

]]></artwork></figure>
</t>
<t>
Bob decides to try to transfer Alice to Carol, so he
puts Alice on hold and sends an INVITE to Carol. Carol
and Bob negotiate GRUU support similar to what happened
in F1 and F2.
<figure><artwork><![CDATA[
   Message F3 (abridged, detailing pertinent fields)

     INVITE sip:carol@example.com SIP/2.0
     Supported: gruu
     Call-ID: 23rasdnfoa39i4jnasdf@bob.example.com
     Contact: <sip:bob@example.com;gr=urn:uuid:(Bob's UA's bits)> 

   Message F4 (abridged, detailing pertinent fields)

     SIP/2.0 200 OK
     Supported: gruu
     To: <sip:carol@example.com>;tag=totag2
     From: <sip:bob@example.com>;tag=fromtag2
     Call-ID: 23rasdnfoa39i4jnasdf@bob.example.com
     Contact: <sip:carol@example.com;gr=urn:uuid:(Carol's UA's bits)> 

]]></artwork></figure>
</t>
<t>
After consulting Carol, Bob places her on hold and refers
Alice to her using message F5. Notice that the Refer-To
URI is Carol's GRUU, and that this is on a different
Call-ID than message F1. (The URI in the Refer-To header
is line-broken for readability in this document; it would not
be valid to break the URI this way in a real message.)
<figure><artwork><![CDATA[
   Message F5 (abridged, detailing pertinent fields)

     REFER sip:aanewmr203raswdf@example.com SIP/2.0
     Call-ID: 39fa99r0329493asdsf3n@bob.example.com
     Refer-To: <sip:carol@example.com;g=urn:uid:(Carol's UA's bits)
                ?Replaces=23rasdnfoa39i4jnasdf@bob.example.com;
                 to-tag=totag2;from-tag=fromtag2>
     Target-Dialog: 13jfdwer230jsdw@alice.example.com;
                    local-tag=fromtag1;remote-tag=totag1
     Supported: gruu
     Contact: <sip:bob@example.com;gr=urn:uuid:(Bob's UA's bits)> 
]]></artwork></figure>
</t>
<t>
Alice uses the information in the Target-Dialog header field to
determine that this REFER is associated with the dialog she already
has in place with Bob.  Alice is now in a position to use the same
admission policy she used for in-dialog REFERs: "Do I have a call with
this person?".  She accepts the REFER, sends Bob the obligatory immediate
NOTIFY, and proceeds to INVITE Carol with message F6.
<figure><artwork><![CDATA[
   Message F6 (abridged, detailing pertinent fields)

         sip:carol@example.com;gr=urn:uuid:(Carol's UA's bits) 
         \                                                   /
           \                                                /
            |                                              |
            v                                              v
     INVITE                                                  SIP/2.0
     Call-ID: 4zsd9f234jasdfasn3jsad@alice.example.com
     Replaces: 23rasdnfoa39i4jnasdf@bob.example.com;
               to-tag=totag2;from-tag=fromtag2
     Supported: gruu
     Contact: <sip:alice@example.com;gr=urn:uuid:(Alice's UA's bits)> 

]]></artwork></figure>
</t>
<t>
Carol accepts Alice's invitation to replace her dialog (invite
usage) with Bob, and notifies him that the REFERenced 
INVITE succeeded with F7:
<figure><artwork><![CDATA[
   Message F7 (abridged, detailing pertinent fields) 

     NOTIFY sip:boaiidfjjereis@example.com SIP/2.0
     Subscription-State: terminated;reason=noresource
     Call-ID: 39fa99r0329493asdsf3n@bob.example.com
     Contact: <sip:alice@example.com;gr=urn:uuid:(Alice's UA's bits)> 
     Content-Type: message/sipfrag

     SIP/2.0 200 OK

]]></artwork></figure>
</t>
<t>Bob then ends his invite usages with both Alice and Carol using
BYEs.</t>
</section>
<section title="Security Considerations">
<t>
Handling multiple usages within a single dialog is complex and introduces
scenarios where the right thing to do is not clear. The ambiguities described
here can result in unexpected disruption of communication if response codes are
chosen carelessly. Furthermore, these ambiguities could be exploited, particularly
by third-parties injecting unauthenticated requests or inappropriate responses.
Implementations choosing to create or accept multiple usages within a dialog should
give extra attention to the security considerations in <xref target="RFC3261"/>, especially
those concerning the authenticity of requests and processing of responses.
</t>
<t>
Service implementations should carefully consider the effects on their service of
peers making different choices in these areas of ambiguity. A service that requires
multiple usages needs to pay particular attention to the effect on service and 
network utilization when a client fails to destroy a dialog the service believes
should be destroyed. A service that disallows multiple usages should consider the
effect on clients that, for instance, destroy the entire dialog when only a usage
should be torn down. In the worst case of a service deployed into a network with
a large number of misbehaving clients trying to create multiple usages in an automated
fashion, a retry storm similar to an avalanche restart could be induced.
</t>
</section>
<section title="Conclusion">
<t>
Handling multiple usages within a single dialog is complex and
introduces scenarios where the right thing to do is not clear.
Implementations should avoid entering into multiple usages whenever
possible. New applications should be designed to never introduce
multiple usages. 
</t>
<t>
There are some accepted SIP practices, including transfer, that
currently require multiple usages. Recent work, most notably GRUU,
makes those practices unnecessary. The standardization of those
practices and the implementations should be revised as soon as
possible to use only single-usage dialogs.
</t>
</section>
<section title="Acknowledgments">
<t>
The ideas in this document have been refined over several IETF
meetings with many participants. Significant contribution
was provided by Adam Roach, Alan Johnston, Ben Campbell, 
Cullen Jennings, Jonathan Rosenberg, Paul Kyzivat, and Rohan Mahy. 
Members of the reSIProcate project also shared their difficulties 
and discoveries while implementing multiple-usage dialog handlers.
</t>
</section>
</middle>
<back>
<references title="Informative References">
&rfc3261;
&rfc3263;
&rfc3265;
&rfc3515;
&rfc3911;
&rfc3891;
&rfc4488;
&rfc4538;
&rfc3903;
&rfc4730;

<reference anchor="SIP-GRUU">
<front>
<title>
Obtaining and Using Globally Routable User Agent (UA) URIs (GRUU) in
the  Session Initiation Protocol (SIP)
</title>
<author initials="J" surname="Rosenberg" fullname="Jonathan
Rosenberg">
<organization/>
</author>
<date month="June" day="15" year="2006"/>
<abstract>
<t>
Several applications of the Session Initiation Protocol (SIP) require
a user agent (UA) to construct and distribute a URI that can be used
by anyone on the Internet to route a call to that specific UA
instance. A URI that routes to a specific UA instance is called a
Globally Routable UA URI (GRUU). This document describes an extension
to SIP for obtaining a GRUU from a server and for communicating a GRUU
to a peer within a dialog.
</t>
</abstract>
</front>
<seriesInfo name="Work in" value="Progress"/>
<format type="TXT"
target="http://www.ietf.org/internet-drafts/draft-ietf-sip-gruu-08.txt"/>
</reference>

</references>
</back>
</rfc>
