<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

  <!ENTITY RFC1981 PUBLIC '' "reference.RFC.1981.xml">
  <!ENTITY RFC2119 PUBLIC '' "reference.RFC.2119.xml">
  <!ENTITY RFC4086 PUBLIC '' "reference.RFC.4086.xml">
  <!ENTITY RFC6024 PUBLIC '' "reference.RFC.6024.xml">
  <!ENTITY RFC4821 PUBLIC '' "reference.RFC.4821.xml">
  <!ENTITY RFC4279 PUBLIC '' "reference.RFC.4279.xml">
  <!ENTITY RFC5758 PUBLIC '' "reference.RFC.5758.xml">
  <!ENTITY RFC5480 PUBLIC '' "reference.RFC.5480.xml">
  <!ENTITY RFC4492 PUBLIC '' "reference.RFC.4492.xml"> 
  <!ENTITY RFC6125 PUBLIC '' "reference.RFC.6125.xml">
  <!ENTITY RFC5934 PUBLIC '' "reference.RFC.5934.xml">
  <!ENTITY RFC5077 PUBLIC '' "reference.RFC.5077.xml">
  <!ENTITY RFC5246 PUBLIC '' "reference.RFC.5246.xml">
  <!ENTITY RFC5746 PUBLIC '' "reference.RFC.5746.xml">
  <!ENTITY RFC6066 PUBLIC '' "reference.RFC.6066.xml">
  <!ENTITY RFC6347 PUBLIC '' "reference.RFC.6347.xml">
  <!ENTITY RFC5280 PUBLIC '' "reference.RFC.5280.xml">
  <!ENTITY RFC6733 PUBLIC '' "reference.RFC.6733.xml">
  <!ENTITY RFC3748 PUBLIC '' "reference.RFC.3748.xml">
  <!ENTITY RFC2865 PUBLIC '' "reference.RFC.2865.xml">
  <!ENTITY RFC6520 PUBLIC '' "reference.RFC.6520.xml">
  <!ENTITY RFC6961 PUBLIC '' "reference.RFC.6961.xml">
  <!ENTITY RFC7400 PUBLIC '' "reference.RFC.7400.xml">
  <!ENTITY RFC6090 PUBLIC '' "reference.RFC.6090.xml">  
  <!ENTITY RFC6655 PUBLIC '' "reference.RFC.6655.xml">
  <!ENTITY RFC5116 PUBLIC '' "reference.RFC.5116.xml">
  <!ENTITY RFC7252 PUBLIC '' "reference.RFC.7252.xml">
  <!ENTITY RFC7251 PUBLIC '' "reference.RFC.7251.xml">
  <!ENTITY RFC7228 PUBLIC '' "reference.RFC.7228.xml">
  <!ENTITY RFC6234 PUBLIC '' "reference.RFC.6234.xml">
  <!ENTITY RFC3610 PUBLIC '' "reference.RFC.3610.xml">
  <!ENTITY RFC5288 PUBLIC '' "reference.RFC.5288.xml">
  <!ENTITY RFC2104 PUBLIC '' "reference.RFC.2104.xml">
  <!ENTITY RFC4919 PUBLIC '' "reference.RFC.4919.xml">
  <!ENTITY RFC5247 PUBLIC '' "reference.RFC.5247.xml">
  <!ENTITY RFC5216 PUBLIC '' "reference.RFC.5216.xml">
  <!ENTITY RFC7397 PUBLIC '' "reference.RFC.7397.xml">
  <!ENTITY RFC7390 PUBLIC '' "reference.RFC.7390.xml">
  <!ENTITY RFC6943 PUBLIC '' "reference.RFC.6943.xml">
  <!ENTITY RFC6690 PUBLIC '' "reference.RFC.6690.xml">
  <!ENTITY RFC7452 PUBLIC '' "reference.RFC.7452.xml">
  <!ENTITY RFC7568 PUBLIC '' "reference.RFC.7568.xml">
  <!ENTITY RFC7539 PUBLIC '' "reference.RFC.7539.xml">
  <!ENTITY RFC7465 PUBLIC '' "reference.RFC.7465.xml">
  <!ENTITY RFC7366 PUBLIC '' "reference.RFC.7366.xml">
  <!ENTITY RFC7250 PUBLIC '' "reference.RFC.7250.xml">
  <!ENTITY RFC7507 PUBLIC '' "reference.RFC.7507.xml">
  <!ENTITY RFC7525 PUBLIC '' "reference.RFC.7525.xml">
  <!ENTITY RFC7258 PUBLIC '' "reference.RFC.7258.xml">
  <!ENTITY RFC7748 PUBLIC '' "reference.RFC.7748.xml">
  <!ENTITY RFC7627 PUBLIC '' "reference.RFC.7627.xml">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>

<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="std" number="7925" ipr="trust200902" submissionType="IETF" consensus="yes">

  <front>
    <title abbrev="TLS/DTLS IoT Profiles">Transport Layer Security (TLS) / Datagram&nbsp;Transport&nbsp;Layer&nbsp;Security&nbsp;(DTLS) Profiles for&nbsp;the&nbsp;Internet&nbsp;of&nbsp;Things</title>

    <author role="editor" initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization>ARM Ltd.</organization>
      <address>
        <postal>
          <street>110 Fulbourn Rd</street>
          <city>Cambridge</city>
          <code>CB1 9NJ</code>
          <country>United Kingdom</country>
        </postal>
        <email>Hannes.tschofenig@gmx.net </email>
        <uri>http://www.tschofenig.priv.at</uri>
 
      </address>
    </author>

    <author fullname="Thomas Fossati" initials="T." surname="Fossati">
      <organization>Nokia</organization>
      <address>
        <postal>
          <street>3 Ely Road</street>
          <city>Milton, Cambridge</city>
          <code>CB24 6DD</code>
          <country>United Kingdom</country>
        </postal>
        <email>thomas.fossati@nokia.com</email>
      </address>
    </author>

    <date month="July" year="2016"/>
    <area>Security</area>
    <workgroup>dice</workgroup>

    <abstract>
<t>A common design pattern in Internet of Things (IoT) deployments is the use of a
constrained device that collects data via sensors or controls actuators for use in home automation, industrial control systems, smart 
cities, and other IoT deployments.</t>

<t>This document defines a Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) 1.2 
profile that offers communications security for this data exchange thereby 
preventing eavesdropping, tampering, and message forgery. The lack of communication 
security is a common vulnerability in IoT products that can easily 
be solved by using these well-researched and widely deployed Internet security protocols.</t>
    </abstract>
  </front>
  <middle>
    
    <section title="Introduction" anchor="introduction">
<t>An engineer developing an Internet of Things (IoT) device needs to 
investigate the security threats and decide about the security services that can be 
used to mitigate these threats.</t>

<t>Enabling IoT devices to exchange data often requires 
authentication of the two endpoints and the ability to provide 
integrity and confidentiality protection of exchanged data. While 
these security services can be provided at different layers in the 
protocol stack, the use of Transport Layer Security (TLS) / Datagram Transport Layer Security
(DTLS) has been very popular with many application protocols, and it 
is likely to be useful for IoT scenarios as well.</t>

<t>Fitting Internet protocols into constrained devices can be difficult, 
but thanks to the standardization efforts, new profiles and protocols 
are available, such as the Constrained Application Protocol (CoAP) 
<xref target="RFC7252"/>. 
CoAP messages are mainly carried over UDP/DTLS, but other transports can be
utilized, such as SMS (as described in <xref target="DTLSoSMS"/>) or TCP (as currently being proposed with <xref
target="COAP-TCP-TLS"/>).</t>

<t>While the main goal for this document is to protect CoAP
messages using DTLS 1.2 <xref target="RFC6347"/>, the information contained 
in the following sections is not limited to CoAP nor to DTLS itself.</t>

<t>Instead, this document defines a profile of DTLS 1.2 <xref target="RFC6347"/> 
and TLS 1.2 <xref target="RFC5246"/> that offers communication security services
for IoT applications and is reasonably implementable on many constrained 
devices. Profile thereby means that available configuration options 
and protocol extensions are utilized to best support the IoT 
environment. This document does not alter TLS/DTLS specifications and 
does not introduce any new TLS/DTLS extension.</t>

<t>The main target audience for this document is the embedded system 
developer configuring and using a TLS/DTLS stack. This document may, however, 
also help those developing or selecting a suitable TLS/DTLS stack for an 
IoT product. If you are familiar with (D)TLS, then skip ahead 
to <xref target="credentials"/>.</t>
      </section>

        <section title="Terminology">
   <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
   NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL"
   in this document are to be interpreted as described in RFC 2119
   <xref target="RFC2119"/>.</t>
		   
<t>This specification refers to TLS as well as DTLS and particularly to version 1.2, which is the 
most recent version at the time of writing. We refer to TLS/DTLS whenever the text is applicable to both versions of the protocol 
and to TLS or DTLS when there are differences between the two protocols. Note that TLS 1.3 is being developed, but it is not
expected that this profile will "just work" due to the significant changes being done to TLS for version 1.3.</t>

<t>Note that "client" and "server" in this document refer to TLS/DTLS roles, 
where the client initiates the handshake. This does not restrict the 
interaction pattern of the protocols on top of DTLS since the record layer 
allows bidirectional communication. This aspect is further described in <xref target="arch"/>.</t>
    
<t>RFC 7228 <xref target="RFC7228"/> introduces the notion of constrained-node 
networks, which are made of small devices with severe constraints on power, memory, and 
processing resources. The terms constrained devices and IoT
devices are used interchangeably.</t>

<t>The terms "certification authority" (CA) and "distinguished name" (DN) are taken from <xref target="RFC5280"/>. 
The terms "trust anchor" and "trust anchor store" are defined in <xref target="RFC6024"/> as: 

<list style="empty"> 
<t>
A trust anchor represents an authoritative entity via a public key and associated data. 
The public key is used to verify digital signatures, and the associated data is used to 
constrain the types of information for which the trust anchor is authoritative.
</t> 

<t>A trust anchor store is a set of one or more trust anchors stored in a
device.... A
device may have more than one trust anchor store, each of which may be used by one 
or more applications.
</t> 
</list> 
</t> 

</section> 


<section title="Overview">

<section title="TLS and DTLS"> 

<t>The TLS protocol <xref target="RFC5246"/> provides authenticated,
confidentiality- and integrity-protected communication between two
endpoints. The protocol is composed of two layers: the Record Protocol and the
handshaking protocols. At the lowest level, layered on top of a reliable
transport protocol (e.g., TCP), is the Record Protocol. It provides connection
security by using symmetric cryptography for confidentiality, data origin
authentication, and integrity protection. The Record Protocol is used for
encapsulation of various higher-level protocols. The handshaking protocols
consist of three subprotocols -- namely, the handshake protocol, the change cipher
spec protocol, and the alert protocol. The handshake protocol allows the server and client to authenticate each other and to negotiate an encryption algorithm and cryptographic keys before the application protocol transmits or receives data.</t>
    
<t>The design of DTLS <xref target="RFC6347"/> is intentionally very similar to TLS. However, since DTLS operates on top of an unreliable datagram transport, it must explicitly cope with the absence of reliable and ordered delivery assumptions made by TLS. RFC 6347 explains these differences in great detail. As a short summary, for those not familiar with DTLS, the differences are:
   <list style="symbols"> 
      <t>An explicit sequence number and an epoch field is included in the Record Protocol. Section 4.1 of RFC 6347 explains the processing rules for these two new fields. The value used to compute the Message Authentication Code (MAC) is the 64-bit value formed by concatenating the epoch and the sequence number.  </t>

      <t>Stream ciphers must not be used with DTLS. The only stream cipher defined for TLS 1.2 is RC4, and due to cryptographic weaknesses, it is not recommended anymore even for use with TLS <xref target="RFC7465"/>. Note that the term "stream cipher" is a technical term in the TLS specification. Section 4.7 of RFC 5246 defines stream ciphers in TLS as follows: "In stream cipher encryption, the plaintext is exclusive-ORed with an identical amount of output generated from a cryptographically secure keyed pseudorandom number generator."</t> 

      <t>The TLS handshake protocol has been enhanced to include a stateless cookie exchange for Denial-of-Service (DoS) resistance. For this purpose, a new handshake message, the HelloVerifyRequest, was added to DTLS. This handshake message is sent by the server and includes a stateless cookie, which is returned in a ClientHello message back to the server. Although the exchange is optional for the server to execute, a client implementation has to be prepared to respond to it. Furthermore, the handshake message format has been extended to deal with message loss, reordering, and fragmentation.  </t>
   </list>
</t>

</section> 

<section anchor="arch" title="Communication Models"> 

<t>This document describes a profile of DTLS and, to be useful, it has to make assumptions about the envisioned communication architecture.</t>

<t>Two communication architectures (and consequently two profiles) are described in this document.</t>

<section anchor="c-clients" title="Constrained TLS/DTLS Clients">
 
<t>The communication architecture shown in <xref target="model"/> assumes a unicast communication interaction with an IoT device utilizing a constrained TLS/DTLS client interacting with one or multiple TLS/DTLS servers.  </t> 

<t>Before a client can initiate the TLS/DTLS handshake, it needs to know the IP address of that server and what credentials to use. Application-layer protocols, such as CoAP, which is conveyed on top of DTLS, may be configured with URIs of the endpoints to which CoAP needs to register and publish data. This configuration information (including non-confidential credentials, like certificates) may be conveyed to clients as part of a firmware/software package or via a configuration protocol. The following credential types are supported by this profile:</t> 

   <t><list style="symbols"> 

<t> For authentication based on the Pre-Shared Key (PSK) (see <xref target="psk"/>), this includes the
   paired "PSK identity" and shared secret to be used with each server.</t>

<t> For authentication based on the raw public key (see <xref target="raw"/>), this
  includes either the server's public key or the hash of the server's
  public key.</t>

<t> For certificate-based authentication (see <xref target="certs"/>), this 
  includes a pre-populated trust anchor store that allows the DTLS stack
  to perform path validation for the certificate obtained during the
  handshake with the server.</t>
  
  </list> 
  </t> 

<t><xref target="model"/> shows example configuration information stored at the constrained client for use with respective servers.</t> 

<t>This document focuses on the description of the DTLS client-side functionality but, quite naturally, 
the equivalent server-side support has to be available. </t>

<t><figure title="Constrained Client Profile" anchor="model">
            <artwork><![CDATA[
           +////////////////////////////////////+
           |          Configuration             |
           |////////////////////////////////////|
           | Server A --> PSK Identity, PSK     |
           |                                    |
           | Server B --> Public Key (Server B),|
           |              Public/Private Key    |
           |              (for Client)          |
           |                                    |
           | Server C --> Public/Private Key    |
           |              (for Client)          |
           |              Trust Anchor Store    |
           +------------------------------------+
             oo
       oooooo
      o
+-----------+
|Constrained|
|TLS/DTLS   |
|Client     |-
+-----------+ \
               \  ,-------.
                ,'         `.            +------+
               /  IP-Based   \           |Server|
              (    Network    )          |  A   |
               \             /           +------+
                `.         ,'
                  '---+---'                  +------+
                      |                      |Server|
                      |                      |  B   |
                      |                      +------+
                      |
                      |                  +------+
                      +----------------->|Server|
                                         |  C   |
                                         +------+    
]]></artwork>
          </figure>
	    </t>


<section title="Examples of Constrained Client Exchanges">

<section title="Network Access Authentication Example">

<t>Reuse is a recurring theme when considering constrained environments and is behind a lot of the directions taken in developments for constrained environments. The corollary of reuse is to not add functionality if it can be avoided. An example relevant to the use of TLS is network access authentication, which takes place when a device connects to a network and needs to go through an authentication and access control procedure before it is allowed to communicate with other devices or connect to the Internet.</t>

<t><xref target="network-access"/> shows the network access architecture with the IoT device initiating the communication to an access point in the network using the procedures defined for a specific physical layer. Since credentials may be managed and stored centrally, in the Authentication, Authorization, and Accounting (AAA) server, the security protocol exchange may need to be relayed via the Authenticator, i.e., functionality running on the access point to the AAA server. The authentication and key exchange protocol itself is encapsulated within a container, the Extensible Authentication Protocol (EAP) <xref target="RFC3748"/>, and messages are conveyed back and forth between the EAP endpoints, namely the EAP peer located on the IoT device and the EAP server located on the AAA server or the access point. To route EAP messages from the access point, acting as a AAA client, to the AAA server requires an adequate protocol mechanism, namely RADIUS <xref target="RFC2865"/> or Diameter <xref target="RFC6733"/>. </t>

<t>More details about the concepts and a description about the terminology can be found in RFC 5247 <xref target="RFC5247"/>.</t> 

<t><figure title="Network Access Architecture" anchor="network-access">
            <artwork><![CDATA[
                                             +--------------+
                                             |Authentication|
                                             |Authorization |
                                             |Accounting    |
                                             |Server        |
                                             |(EAP Server)  |
                                             |              |
                                             +-^----------^-+
                                               * EAP      o RADIUS/
                                               *          o Diameter
                                             --v----------v--
                                          ///                \\\
                                        //                      \\
                                       |        Federation        |
                                       |        Substrate         |
                                        \\                      //
                                          \\\                ///
                                             --^----------^--
                                               * EAP      o RADIUS/
                                               *          o Diameter
 +-------------+                             +-v----------v--+
 |             |      EAP/EAP Method         |               |
 | Internet of |<***************************>| Access Point  |
 | Things      |                             |(Authenticator)|
 | Device      |    EAP Lower Layer and      |(AAA Client)   |
 | (EAP Peer)  | Secure Association Protocol |               |
 |             |<--------------------------->|               |
 |             |                             |               |
 |             |      Physical Layer         |               |
 |             |<===========================>|               |
 +-------------+                             +---------------+
   Legend:

    <****>: Device-to-AAA-Server Exchange
    <---->: Device-to-Authenticator Exchange
    <oooo>: AAA-Client-to-AAA-Server Exchange
    <====>: Physical layer like IEEE 802.11/802.15.4
]]></artwork>
          </figure>
	    </t>

<t>One standardized EAP method is EAP-TLS, defined in RFC 5216 <xref
target="RFC5216"/>, which reuses the TLS-based protocol exchange and
encapsulates it inside the EAP payload. In terms of reuse, this allows many
components of the TLS protocol to be shared between the network access
security functionality and the TLS functionality needed for securing
application-layer traffic. In the EAP-TLS exchange shown in <xref
target="eap-tls"/>, the IoT device as the EAP peer acts as a TLS client.</t>
	

<t><figure title="EAP-TLS Exchange" anchor="eap-tls">
            <artwork><![CDATA[
   Authenticating Peer     Authenticator
   -------------------     -------------
                           <- EAP-Request/
                           Identity
   EAP-Response/
   Identity (MyID) ->
                           <- EAP-Request/
                           EAP-Type=EAP-TLS
                           (TLS Start)
   EAP-Response/
   EAP-Type=EAP-TLS
   (TLS client_hello)->
                           <- EAP-Request/
                           EAP-Type=EAP-TLS
                           (TLS server_hello,
                            TLS certificate,
                            [TLS server_key_exchange,]
                            TLS certificate_request,
                            TLS server_hello_done)
   EAP-Response/
   EAP-Type=EAP-TLS
   (TLS certificate,
    TLS client_key_exchange,
    TLS certificate_verify,
    TLS change_cipher_spec,
    TLS finished) ->
                           <- EAP-Request/
                           EAP-Type=EAP-TLS
                           (TLS change_cipher_spec,
                            TLS finished)
   EAP-Response/
   EAP-Type=EAP-TLS ->
                           <- EAP-Success
]]></artwork>
          </figure>
	    </t>

<t>The guidance in this document also applies to the use of EAP-TLS for
network access authentication. An IoT device using a network access
authentication solution based on TLS can reuse most parts of the code for the
use of DTLS/TLS at the application layer, thereby saving a significant amount
of flash memory. Note, however, that the credentials used for network access
authentication and those used for application-layer security are very likely
different.</t>

</section> 

<section title="CoAP-Based Data Exchange Example">

<t>When a constrained client uploads sensor data to a server infrastructure,
it may use CoAP by pushing the data via a POST message to a preconfigured
endpoint on the server. In certain circumstances, this might be too limiting
and additional functionality is needed, as shown in Figures <xref
target="coap-rd-1" format="counter"/> and <xref target="coap-rd-2" format="counter"/>, where the IoT device itself runs a CoAP server hosting the resource that is made accessible to other entities. Despite running a CoAP server on the IoT device, it is still the DTLS client on the IoT device that initiates the interaction with the non-constrained resource server in our scenario. </t>

<t><xref target="coap-rd-1"/> shows a sensor starting a DTLS exchange with a resource directory and uses CoAP to register available resources in <xref target="coap-rd-2"/>. <xref target="CoRE-RD"/> defines the resource directory (RD) as a web entity that stores information about web resources and implements Representational State Transfer (REST) interfaces for registration and lookup of those resources. Note that the described exchange is borrowed from the Open Mobile Alliance (OMA) Lightweight Machine&nbhy;to&nbhy;Machine (LWM2M) specification <xref target="LWM2M"/> that uses RD but adds proxy functionality.</t>

<t>The initial DTLS interaction between the sensor, acting as a DTLS client, and the resource directory, acting as a DTLS server, will be a full DTLS handshake. Once this handshake is complete, both parties have established the DTLS record layer. Subsequently, the CoAP client can securely register at the resource directory.</t>

<t>After some time (assuming that the client regularly refreshes its registration), the resource directory receives a request from an application to retrieve the temperature information from the sensor. This request is relayed by the resource directory to the sensor using a GET message exchange. The already established DTLS record layer can be used to secure the message exchange.</t>
 
<t><figure title="DTLS/CoAP Exchange Using Resource Directory: Part 1 -- DTLS&nbsp;Handshake" anchor="coap-rd-1">

            <artwork><![CDATA[
                                                 Resource
    Sensor                                       Directory
    ------                                       ---------

  +---
  |
  | ClientHello             -------->
  | #client_certificate_type#
 F| #server_certificate_type#
 U|
 L|                         <-------    HelloVerifyRequest
 L|
  | ClientHello             -------->
 D| #client_certificate_type#
 T| #server_certificate_type#
 L|
 S|                                            ServerHello
  |                               #client_certificate_type#
 H|                               #server_certificate_type#
 A|                                            Certificate
 N|                                      ServerKeyExchange
 D|                                     CertificateRequest
 S|                         <--------      ServerHelloDone
 H|
 A| Certificate
 K| ClientKeyExchange
 E| CertificateVerify
  | [ChangeCipherSpec]
  | Finished                -------->
  |
  |                                     [ChangeCipherSpec]
  |                         <--------             Finished
  +---

   Note: Extensions marked with "#" were introduced with
         RFC 7250.
]]></artwork>
          </figure>
	    </t>

<t><xref target="coap-rd-2"/> shows the DTLS-secured communication between the 
sensor and the resource directory using CoAP. </t> 

<t><figure title="DTLS/CoAP Exchange Using Resource Directory: Part 2 -- CoAP/RD Exchange" anchor="coap-rd-2">
            <artwork><![CDATA[
                                                 Resource
    Sensor                                       Directory
    ------                                       ---------
              
[[==============DTLS-Secured Communication===================]]

  +---                                                  ///+
 C|                                                        \ D
 O| Req: POST coap://rd.example.com/rd?ep=node1            \ T
 A| Payload:                                               \ L
 P| </temp>;ct=41;                                         \ S
  |    rt="temperature-c";if="sensor",                     \
 R| </light>;ct=41;                                        \ R
 D|    rt="light-lux";if="sensor"                          \ E
  |                         -------->                      \ C
 R|                                                        \ O
 E|                                                        \ R
 G|                                     Res: 2.01 Created  \ D
  |                         <--------  Location: /rd/4521  \
  |                                                        \ L
  +---                                                     \ A
                                                           \ Y
                           *                               \ E
                           * (time passes)                 \ R
                           *                               \
  +---                                                     \ P
 C|                                                        \ R
 O|              Req: GET coaps://sensor.example.com/temp  \ O
 A|                         <--------                      \ T
 P|                                                        \ E
  | Res:  2.05 Content                                     \ C
 G| Payload:                                               \ T
 E| 25.5                     -------->                     \ E
 T|                                                        \ D
  +---                                                  ///+
]]></artwork>
          </figure>
	    </t>
<t>Note that the CoAP GET message transmitted from the resource server is protected using
the previously established DTLS record layer.</t> 

</section> 

</section>
  
</section> 

<section anchor="c-servers" title="Constrained TLS/DTLS Servers"> 

<t><xref target="c-clients"/> illustrates a deployment model where the TLS/DTLS client is constrained and efforts need to be taken to improve memory utilization, bandwidth consumption, reduce performance impacts, etc. In this section, we assume a scenario where constrained devices run TLS/DTLS servers to secure access to application-layer services running on top of CoAP, HTTP, or other protocols.  <xref target="model2"/> illustrates a possible deployment whereby a number of constrained servers are waiting for regular clients to access their resources. 
The entire process is likely, but not necessarily, controlled by a third party, the authentication and authorization server. This authentication and authorization server is responsible for holding authorization policies that govern the access to resources and distribution of keying material.</t> 

<t><figure title="Constrained Server Profile" anchor="model2">
            <artwork><![CDATA[
         +////////////////////////////////////+
         |          Configuration             |
         |////////////////////////////////////|
         | Credentials                        |
         |    Client A  -> Public Key         |
         |    Server S1 -> Symmetric Key      |
         |    Server S2 -> Certificate        |
         |    Server S3 -> Public Key         |
         | Trust Anchor Store                 |
         | Access Control Lists               |
         |    Resource X: Client A / GET      |
         |    Resource Y: Client A / PUT      |
         +------------------------------------+
             oo
       oooooo
      o
+---------------+                +-----------+
|Authentication |      +-------->|TLS/DTLS   |
|& Authorization|      |         |Client A   |
|Server         |      |         +-----------+
+---------------+     ++
             ^        |                  +-----------+
              \       |                  |Constrained|
               \  ,-------.              | Server S1 |
                ,'         `.            +-----------+
               /    Local    \
              (    Network    )
               \             /        +-----------+
                `.         ,'         |Constrained|
                  '---+---'           | Server S2 |
                      |               +-----------+
                      |
                      |                   +-----------+
                      +-----------------> |Constrained|
                                          | Server S3 |
                                          +-----------+
]]></artwork>
          </figure>
	    </t>


<t>A deployment with constrained servers has to overcome several challenges. Below we explain how these challenges can be solved with CoAP, as an example. Other protocols may offer similar capabilities. While the requirements for the TLS/DTLS protocol profile change only slightly when run on a constrained server (in comparison to running it on a constrained client), several other ecosystem factors will impact deployment.</t>

<t>There are several challenges that need to be addressed:  

<list style="hanging"> 

<t hangText="Discovery and Reachability:">
<vspace blankLines="1"/>
A client must first and foremost discover the server before initiating a connection to it.  Once it has been discovered, reachability to the device needs to be maintained.</t>
<t>
In CoAP, the discovery of resources offered by servers is accomplished by sending a unicast or multicast CoAP GET to a well-known URI. The Constrained RESTful Environments (CoRE) Link Format specification <xref target="RFC6690"/> describes the use case (see Section 1.2.1) and reserves the URI (see Section 7.1). Section 7 of the CoAP specification <xref target="RFC7252"/> describes the discovery procedure. <xref target="RFC7390"/> describes the use case for discovering CoAP servers using multicast (see Section 3.3) and specifies the protocol processing rules for CoAP group communications (see Section 2.7).</t>
<t>
The use of RD <xref target="CoRE-RD"/> is yet another possibility for discovering registered servers and their resources. Since RD is usually not a proxy, clients can discover links registered with the RD and then access them directly.</t>

<t hangText="Authentication:">
<vspace blankLines="1"/>
The next challenge concerns the provisioning of authentication credentials to the clients as well as servers. In <xref target="c-clients"/>, we assume that credentials (and other configuration information) are provisioned to the device, and that those can be used with the authorization servers. Of course, this leads to a very static relationship between the clients and their server-side infrastructure but poses fewer challenges from a deployment point of view, as described in Section 2 of <xref target="RFC7452"/>. In any case, engineers and product designers have to determine how the relevant credentials are distributed to the respective parties. For example, shared secrets may need to be provisioned to clients and the constrained servers for subsequent use of TLS/DTLS PSK. In other deployments, certificates, private keys, and trust anchors for use with certificate-based authentication may need to be utilized.</t>
<t>
Practical solutions use either pairing (also called imprinting) or a trusted third party. With pairing, two devices execute a special protocol exchange that is unauthenticated to establish a shared key (for example, using an unauthenticated Diffie-Hellman (DH) exchange). To avoid man-in-the-middle attacks, an out&nbhy;of&nbhy;band channel is used to verify that nobody has tampered with the exchanged protocol messages.   This out-of-band channel can come in many forms, including:
<list style="symbols"> 
<t>Human involvement by comparing hashed keys, entering passkeys, and scanning QR codes</t>
<t>The use of alternative wireless communication channels (e.g., infrared communication in addition to Wi-Fi)</t>
<t>Proximity-based information</t>
</list>
More details about these different pairing/imprinting techniques can be found in the Smart Object Security Workshop report <xref target="RFC7397"/> and various position papers submitted on that topic, such as <xref target="ImprintingSurvey"/>. The use of a trusted third party follows a different approach and is subject to ongoing standardization efforts in the Authentication and Authorization for Constrained Environments (ACE) working group <xref target="ACE-WG"/>. 
</t>

<t hangText="Authorization">
<vspace blankLines="1"/>
The last challenge is the ability for the constrained server to make an authorization decision when clients access protected resources. Pre-provisioning access control information to constrained servers may be one option but works only in a small scale, less dynamic environment. For a finer-grained and more dynamic access control solution, the reader is referred to the ongoing work in the IETF ACE working group.</t> 
</list> 
</t> 

<t><xref target="local-discovery"/> shows an example interaction whereby a device, a thermostat in our case, searches in the local network for discoverable resources and accesses those. The thermostat starts the procedure using a link-local discovery message using the "All CoAP Nodes" multicast address by utilizing the link format per RFC 6690 <xref target="RFC6690"/>. 
The IPv6 multicast address used for CoAP link-local discovery is FF02::FD. As a result, a temperature sensor and a fan respond. These responses allow the thermostat to subsequently read temperature information from the temperature sensor with a CoAP GET request issued to the previously learned endpoint. In this example we assume that accessing the temperature sensor readings and controlling the fan requires authentication and authorization of the thermostat and TLS is used to authenticate both endpoints and to secure the communication.</t>

<t><figure title="Local Discovery and Resource Access" anchor="local-discovery">
            <artwork><![CDATA[
                              Temperature
  Thermostat                     Sensor              Fan
  ----------                   ---------             ---

    Discovery
    -------------------->
    GET coap://[FF02::FD]/.well-known/core

                  CoAP 2.05 Content
   <-------------------------------
   </3303/0/5700>;rt="temperature";
                  if="sensor"

                                     CoAP 2.05 Content
   <--------------------------------------------------
                        </fan>;rt="fan";if="actuation"

+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
\ Protocol steps to obtain access token or keying        /
\ material for access to the temperature sensor and fan. /
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+

   Read Sensor Data 
   (authenticated/authorized)
   ------------------------------->
   GET /3303/0/5700

                 CoAP 2.05 Content
  <-------------------------------
                            22.5 C

  Configure Actuator 
  (authenticated/authorized)
  ------------------------------------------------->
  PUT /fan?on-off=true
                                   CoAP 2.04 Changed
  <-------------------------------------------------
]]></artwork>
          </figure>
	    </t>


</section>


</section>

<section title="The Ciphersuite Concept"> 
<t>TLS (and consequently DTLS) support ciphersuites,
   and an IANA registry <xref target="IANA-TLS"/> was created to register the suites. A ciphersuite (and the specification that defines it) contains the following information:
<list style="symbols">
  <t>Authentication and key exchange algorithm (e.g., PSK)</t>
  <t>Cipher and key length (e.g., Advanced Encryption Standard (AES) with 128-bit keys <xref target="AES"/>)</t>
  <t>Mode of operation (e.g., Counter with CBC-MAC (CCM) mode for AES) <xref target="RFC3610"/></t>
  <t>Hash algorithm for integrity protection, such as the Secure Hash Algorithm (SHA) in combination with Keyed-Hashing for Message Authentication (HMAC) (see <xref target="RFC2104"/> and <xref target="RFC6234"/>)</t>
  <t>Hash algorithm for use with pseudorandom functions (e.g., HMAC with the SHA-256) </t>
  <t>Misc information (e.g., length of authentication tags)</t>
  <t>Information whether the ciphersuite is suitable for DTLS or only for TLS</t>
</list> 
</t>

<t>The TLS ciphersuite TLS_PSK_WITH_AES_128_CCM_8, for example, uses a pre-shared authentication and key exchange algorithm. <xref target="RFC6655"/> defines this ciphersuite. It uses the AES encryption algorithm, which is a block cipher. Since the AES algorithm supports different key lengths (such as 128, 192, and 256 bits), this information has to be specified as well, and the selected ciphersuite supports 128-bit keys. 

A block cipher encrypts plaintext in fixed-size blocks, and AES operates on a block size of 128 bits. For messages exceeding 128 bits, the message is partitioned into 128-bit blocks, and the AES cipher is applied to these input blocks with appropriate chaining, which is called mode of operation.</t> 

<t>TLS 1.2 introduced Authenticated Encryption with Associated Data (AEAD) ciphersuites (see <xref target="RFC5116"/> and <xref target="RFC6655"/>). AEAD is a class of block cipher modes that encrypt (parts of) the message and authenticate the message simultaneously. AES-CCM <xref target="RFC6655"/> is an example of such a mode.</t>

<t>Some AEAD ciphersuites have shorter authentication tags (i.e., message authentication codes) and are therefore more suitable for networks with low bandwidth where small message size matters. The TLS_PSK_WITH_AES_128_CCM_8 ciphersuite that ends in "_8" has an 8-octet authentication tag, while the regular CCM ciphersuites have, at the time of writing, 16-octet authentication tags. The design of CCM and the security properties are described in <xref target="CCM"/>.</t>

<t>TLS 1.2 also replaced the combination of MD5/SHA-1 hash functions in the TLS pseudorandom function (PRF) used in earlier versions of TLS with ciphersuite-specified PRFs. For this reason, authors of more recent TLS 1.2 ciphersuite specifications explicitly indicate the MAC algorithm and the hash functions used with the TLS PRF.  </t>
</section> 


 </section> 

<section anchor="credentials" title="Credential Types">

<t>The mandatory-to-implement functionality will depend on the credential type used with IoT devices. The subsections below describe the implications of three different credential types, namely pre-shared secrets, raw public keys, and certificates. </t>

<section title="Preconditions">

<t>All exchanges described in the subsequent sections assume that some information has been distributed before the TLS/DTLS interaction starts. The credentials are used to authenticate the client to the server, and vice versa. What information items have to be distributed depends on the chosen credential types. In all cases, the IoT device needs to know what algorithms to prefer, particularly if there are multiple algorithm choices available as part of the implemented ciphersuites, as well as information about the other communication endpoint (for example, in the form of a URI) a particular credential has to be used with.</t>

<t><list style="hanging"> 

<t hangText="Pre-Shared Secrets:">In this case, a shared secret together with an identifier needs to be made available to the device as well as to the other communication party.</t>
<t hangText="Raw Public Keys:">A public key together with a private key are stored on the device and typically associated with some identifier. To authenticate the other communication party, the appropriate credential has to be known. If the other end uses raw public keys as well, then their public key needs to be provisioned (out of band) to the device.</t>

<t hangText="Certificates:">The use of certificates requires the device to store the public key (as part of the certificate) as well as the private key. The certificate will contain the identifier of the device as well as various other attributes. Both communication parties are assumed to be in possession of a trust anchor store that contains CA certificates and, in case of certificate pinning, end-entity certificates. Similar to the other credentials, the IoT device needs information about which entity to use which certificate with. Without a trust anchor store on the IoT device, it will not be possible to perform certificate validation.</t>
</list> 
</t>

<t>We call the above-listed information "device credentials" and these device credentials may be provisioned to the device already during the manufacturing time or later in the process, depending on the envisioned business and deployment model. These initial credentials are often called "root of trust". Whatever process is chosen for generating these initial device credentials, it MUST be ensured that a different key pair is provisioned for each device and installed in as secure a manner as possible. For example, it is preferable to generate public/private keys on the IoT device itself rather than generating them outside the device. Since an IoT device is likely to interact with various other parties, the initial device credential may only be used with some dedicated entities, and configuring further configuration and credentials to the device is left to a separate interaction. An example of a dedicated protocol used to distribute credentials, access control lists, and configure information is the LWM2M protocol <xref target="LWM2M"/>.</t>

<t>For all the credentials listed above, there is a chance that those may need to be replaced or deleted. While separate protocols have been developed to check the status of these credentials and to manage these credentials, such as the Trust Anchor Management Protocol (TAMP) <xref target="RFC5934"/>, their usage is, however, not envisioned in the IoT context so far. IoT devices are assumed to have a software update mechanism built-in, and it will allow updates of low-level device information, including credentials and configuration parameters. This document does, however, not mandate a specific software/firmware update protocol.</t>

<t>With all credentials used as input to TLS/DTLS authentication, it is important that these credentials have been generated with care. When using a pre-shared secret, a critical consideration is using sufficient entropy during the key generation, as discussed in <xref target="RFC4086"/>. Deriving a shared secret from a password, some device identifiers, or other low-entropy sources is not secure. A low-entropy secret, or password, is subject to dictionary attacks. Attention also has to be paid when generating public/private key pairs since the lack of randomness can result in the same key pair being used in many devices. This topic is also discussed in <xref target="random"/> since keys are generated during the TLS/DTLS exchange itself as well, and the same considerations apply.</t> 
 
</section> 

<section anchor="psk" title="Pre-Shared Secret">
<t>The use of pre-shared secrets is one of the most basic techniques for TLS/DTLS since it is both computationally efficient and bandwidth conserving. Authentication based on pre-shared secrets was introduced to TLS in RFC 4279 <xref target="RFC4279"/>.</t>

<t><xref target="dtls-psk"/> illustrates the DTLS exchange including the cookie exchange. While the server is not required to initiate a cookie exchange with every handshake, the client is required to implement and to react on it when challenged, as defined in RFC 6347 <xref target="RFC6347"/>. The cookie exchange allows the server to react to flooding attacks.</t>

<t><figure title="DTLS PSK Authentication Including the Cookie Exchange" anchor="dtls-psk">
            <artwork><![CDATA[
      Client                                               Server
      ------                                               ------
      ClientHello                 -------->

                                  <--------    HelloVerifyRequest
                                                (contains cookie)

      ClientHello                  -------->
      (with cookie)
                                                      ServerHello
                                               *ServerKeyExchange
                                   <--------      ServerHelloDone
      ClientKeyExchange
      ChangeCipherSpec
      Finished                     -------->
                                                 ChangeCipherSpec
                                   <--------             Finished
                                   
      Application Data             <------->     Application Data

Legend: 

* indicates an optional message payload 
]]></artwork>
          </figure>
	    </t>

<t>Note that <xref target="RFC4279"/> used the term "PSK identity" to refer to the identifier used to refer to the appropriate secret. While "identifier" would be more appropriate in this context, we reuse the terminology defined in RFC 4279 to avoid confusion. RFC 4279 does not mandate the use of any particular type of PSK identity, and the client and server have to agree on the identities and keys to be used.  
The UTF-8 encoding of identities described in Section 5.1 of RFC 4279 aims to improve interoperability for those cases where the identity is configured by a human using some management interface provided by a web browser. However, many IoT devices do not have a user interface, and most of their credentials are bound to the device rather than to the user. Furthermore, credentials are often provisioned into hardware modules or provisioned alongside with firmware. As such, the encoding considerations are not applicable to this usage environment. For use with this profile, the PSK identities SHOULD NOT assume a structured format (such as domain names, distinguished names, or IP addresses), and a byte-by-byte comparison operation MUST be used by the server for any operation related to the PSK identity. These types of identifiers are called "absolute" per RFC 6943 <xref target="RFC6943"/>.</t>

<t>Protocol-wise, the client indicates which key it uses by including a "PSK identity" in the ClientKeyExchange message. As described in <xref target="arch"/>, clients may have multiple pre-shared keys with a single server, for example, in a hosting context. The TLS Server Name Indication (SNI) extension allows the client to convey the name of the server it is contacting. A server implementation needs to guide the selection based on a received SNI value from the client.</t>
   
<t>RFC 4279 requires TLS implementations supporting PSK ciphersuites to support arbitrary PSK identities up to 128 octets in length and arbitrary PSKs up to 64 octets in length. This is a useful assumption for TLS stacks used in the desktop and mobile environments where management interfaces are used to provision identities and keys. Implementations in compliance with this profile MAY use PSK identities up to 128 octets in length and arbitrary PSKs up to 64 octets in length. The use of shorter PSK identities is RECOMMENDED.</t>

<t><xref target="RFC7252">"The Constrained Application Protocol (CoAP)"</xref> currently specifies TLS_PSK_WITH_AES_128_CCM_8 as the mandatory-to-implement ciphersuite for use with shared secrets. This ciphersuite uses the AES algorithm with 128 bit keys and CCM as the mode of operation. The label "_8" indicates that an 8-octet authentication tag is used. Note that the shorted authentication tag increases the chance that an adversary with no
knowledge of the secret key can present a message with a MAC that will pass the verification procedure. The likelihood of accepting forged data is explained in Section 5.3.5 of <xref target="SP800-107-rev1"/> and depends on the lengths of the authentication tag and allowed numbers of MAC verifications using a given key.</t>

<t>This ciphersuite makes use of the default TLS 1.2 PRF, which uses an HMAC with the SHA-256 hash function. Note: Starting with TLS 1.2 (and consequently DTLS 1.2), ciphersuites have to specify the PRF. RFC 5246 states that "New cipher suites MUST explicitly specify a PRF and, in general, SHOULD use the TLS PRF with SHA-256 or a stronger standard hash function." The ciphersuites recommended in this document use the SHA-256 construct defined in Section 5 of RFC 5246.</t>

<t>A device compliant with the profile in this section MUST implement TLS_PSK_WITH_AES_128_CCM_8 and follow the guidance from this section.</t>
</section> 

<section anchor="raw" title="Raw Public Key">

<t>The use of raw public keys with TLS/DTLS, as defined in <xref target="RFC7250"/>, is the first entry point into public key cryptography without having to pay the price of certificates and a public key infrastructure (PKI). The specification reuses the existing Certificate message to convey the raw public key encoded in the SubjectPublicKeyInfo structure. To indicate support, two new extensions had been defined, as shown in <xref target="dtls-raw"/>, namely the server_certificate_type and the client_certificate_type.</t>

<t>
<figure title="DTLS Raw Public Key Exchange" anchor="dtls-raw">
            <artwork><![CDATA[
 Client                                          Server
 ------                                          ------

 ClientHello             -------->
 #client_certificate_type#
 #server_certificate_type#

                                            ServerHello
                              #client_certificate_type#
                              #server_certificate_type#
                                            Certificate
                                      ServerKeyExchange
                                     CertificateRequest
                         <--------      ServerHelloDone

 Certificate
 ClientKeyExchange
 CertificateVerify
 [ChangeCipherSpec]
 Finished                -------->

                                     [ChangeCipherSpec]
                         <--------             Finished

Note: Extensions marked with "#" were introduced with 
      RFC 7250.
]]></artwork>
          </figure>
	    </t>
	    
<t>The CoAP-recommended ciphersuite for use with this credential type is TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 <xref target="RFC7251"/>. This AES-CCM TLS ciphersuite based on elliptic curve cryptography (ECC) uses the Ephemeral Elliptic Curve Diffie-Hellman (ECDHE) as the key establishment mechanism and an Elliptic Curve Digital Signature Algorithm (ECDSA) for authentication.

The named DH groups <xref target="FFDHE-TLS"/> are not applicable to this profile since it relies on the ECC-based counterparts. This ciphersuite makes use of the AEAD capability in DTLS 1.2 and utilizes an 8-octet authentication tag. The use of a DH key exchange provides perfect forward secrecy (PFS). More details about PFS can be found in <xref target="pfs"/>.</t>

<t><xref target="RFC6090"/> provides valuable information for implementing ECC algorithms, particularly for choosing methods that have been available in the literature for a long time (i.e., 20 years and more).</t>

<t>A device compliant with the profile in this section MUST implement TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 and follow the guidance from this section.</t>

</section> 


<section anchor="certs" title="Certificates">

<t>The use of mutual certificate-based authentication is shown in <xref target="dtls-cert"/>, which makes use of the "cached_info" extension <xref target="RFC7924"/>. Support of the "cached_info" extension is REQUIRED. Caching certificate chains allows the client to reduce the communication overhead significantly, otherwise the server would provide the end-entity certificate and the certificate chain with every full DTLS handshake. </t>

<t><figure title="DTLS Mutual Certificate-Based Authentication" anchor="dtls-cert">
            <artwork><![CDATA[
 Client                                          Server
 ------                                          ------

 ClientHello             -------->
 *cached_info*

                                            ServerHello
                                          *cached_info*
                                            Certificate
                                      ServerKeyExchange
                                     CertificateRequest
                         <--------      ServerHelloDone

 Certificate
 ClientKeyExchange
 CertificateVerify
 [ChangeCipherSpec]
 Finished                -------->

                                     [ChangeCipherSpec]
                         <--------             Finished

Note: Extensions marked with "*" were introduced with 
      RFC 7924.
]]></artwork>
          </figure>
	    </t>

<t>TLS/DTLS offers a lot of choices when selecting ECC-based ciphersuites. This document
restricts the use to named curves defined in RFC 4492 <xref target="RFC4492"/>.

At the time of writing, the recommended curve is secp256r1, and the use of uncompressed points follows the recommendation in CoAP.
Note that standardization for Curve25519 (for ECDHE) is
ongoing (see <xref target="RFC7748"/>), and support for this curve will likely
be required in the future.
</t>


<t>A device compliant with the profile in this section MUST implement TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 and follow the guidance from this section.</t>

<section anchor="server-certs" title="Certificates Used by Servers">

<t>The algorithm for verifying the service identity, as described in RFC
6125 <xref target="RFC6125"/>, is essential for ensuring proper security when certificates are used.
As a summary, the algorithm contains the following steps:

<list style="numbers">

<t> The client constructs a list of acceptable reference identifiers
      based on the source domain and, optionally, the type of service
      to which the client is connecting.</t>

<t>The server provides its identifiers in the form of a PKIX
      certificate.</t>

<t> The client checks each of its reference identifiers against the
      presented identifiers for the purpose of finding a match.</t>

<t>When checking a reference identifier against a presented
      identifier, the client matches the source domain of the
      identifiers and, optionally, their application service type.</t>

</list> 
</t>

<t>For various terms used in the algorithm shown above, consult RFC 6125.  It is important to highlight that comparing the reference identifier against the presented identifier obtained from the certificate is required to ensure the client is communicating with the intended server.</t>

<t>It is worth noting that the algorithm description and the text
in RFC 6125 assumes that fully qualified DNS domain names are used.
If a server node is provisioned with a fully qualified DNS domain, then the
server certificate MUST contain the fully qualified DNS domain name or "FQDN" as dNSName <xref target="RFC5280"/>. For CoAP, the coaps URI scheme is described in Section 6.2 of <xref target="RFC7252"/>. This FQDN is stored in the SubjectAltName or in the leftmost Commmon Name (CN) component of the subject name, as explained in Section 9.1.3.3 of <xref target="RFC7252"/>, and used by the client to match it against the FQDN used during the lookup process, as described in <xref target="RFC6125"/>. For other protocols, the appropriate URI scheme specification has to be consulted.</t>

<t>The following recommendation is provided:
<list style="numbers">
<t>Certificates MUST NOT use DNS domain names in the CN of certificates and instead use the subjectAltName attribute, as described in the previous paragraph.</t>
<t>Certificates MUST NOT contain domain names with wildcard characters.</t>
<t>Certificates MUST NOT contain multiple names (e.g., more than one dNSName field).</t>
</list> 
</t>

<t>Note that there will be servers that are not provisioned for use with DNS domain names, for example, IoT devices that offer resources to nearby devices in a local area network, as shown in <xref target="local-discovery"/>. When such constrained servers are used, then the use of certificates as described in <xref target="client-certs"/> is applicable. Note that the SNI extension cannot be used in this case since SNI does not offer the ability to convey a 64-bit Extended Unique Identifier (EUI-64) <xref target="EUI64"/>. Note that this document does not recommend use of IP addresses in certificates nor does it discuss the implications of placing IP addresses in certificates.</t>

</section> 

<section anchor="client-certs" title="Certificates Used by Clients">
<t>For client certificates, the identifier used in the SubjectAltName or in the leftmost CN component of subject name MUST be an EUI-64. </t>

</section>

<section title="Certificate Revocation">
<t>For certificate revocation, neither the Online Certificate Status Protocol (OCSP) nor Certificate Revocation Lists (CRLs) are used. Instead, this profile relies on a software update mechanism to provision information about revoked certificates. While multiple OCSP stapling <xref target="RFC6961"/> has recently been introduced as a mechanism to piggyback OCSP request/responses inside the DTLS/TLS handshake (to avoid the cost of a separate protocol handshake), further investigations are needed to determine its suitability for the IoT environment.</t>
<t>As stated earlier in this section, modifications to the trust anchor store depends on a software update mechanism as well.
There are limitations to the use of a software update mechanism because of the potential inability to change certain types of keys, such as those provisioned during manufacturing.  For this reason, manufacturer-provisioned credentials are typically employed only to obtain further certificates (for example, via a key distribution server) for use with servers the IoT device is finally communicating with.</t>
</section> 

<section title="Certificate Content">

<t>All certificate elements listed in <xref target="table_ex"/> MUST be implemented by clients and servers claiming support for certificate-based authentication. No other certificate elements are used by this specification.</t>

<t>When using certificates, IoT devices MUST provide support for a server certificate chain of at least 3, not including the trust anchor, and MAY reject connections from servers offering chains longer than 3. IoT devices MAY have client certificate chains of any length. Obviously, longer chains require more digital signature verification operations to perform and lead to larger certificate messages in the TLS handshake.</t>

<t><xref target="table_ex"/> provides a summary of the elements in a certificate for use with this profile.</t>

<texttable anchor="table_ex" title="Certificate Content">
    <ttcol align='center'>Element</ttcol>
    <ttcol align='center'>Notes</ttcol>

    <c>version</c>
    <c>This profile uses X.509 v3 certificates <xref target="RFC5280"/>.</c>

    <c></c>
    <c></c>

    <c>serialNumber</c>
    <c>Positive integer unique per certificate.</c>

    <c></c>
    <c></c>

    <c>signature</c>
    <c>This field contains the signature algorithm, and this profile uses ecdsa-with-SHA256 or stronger <xref target="RFC5758"/>.</c>

    <c></c>
    <c></c>

    <c>issuer</c>
    <c>Contains the DN of the issuing CA.</c>

    <c></c>
    <c></c>

    <c>validity</c>
    <c>Values expressed as UTC time in notBefore and notAfter fields.  No validity period mandated.</c>

    <c></c>
    <c></c>

    <c>subject</c>
    <c>See rules outlined in this section.</c>

    <c></c>
    <c></c>

    <c>subjectPublicKeyInfo</c>
    <c>The SubjectPublicKeyInfo structure indicates the algorithm and any associated parameters for the ECC public key.  This profile uses the id-ecPublicKey algorithm identifier for ECDSA signature keys, as defined and specified in <xref target="RFC5480"/>.</c>

    <c></c>
    <c></c>

    <c>signatureAlgorithm</c>
    <c>The ECDSA signature algorithm with ecdsa-with-SHA256 or stronger.</c>

    <c></c>
    <c></c>

    <c>signatureValue</c>
    <c>Bit string containing the digital signature.</c>

    <c></c>
    <c></c>

    <c>Extension: subjectAltName</c>
    <c>See rules outlined in this section.</c>

    <c></c>
    <c></c>

    <c>Extension: BasicConstraints</c>
    <c>Indicates whether the subject of the certificate is a CA and the maximum depth of valid certification
   paths that include this certificate.  This extension is used for CA certs only, and then the value of the "cA" field is set to TRUE.  The default is FALSE.</c>

    <c></c>
    <c></c>

    <c>Extension: Key Usage</c>
    <c>The KeyUsage field MAY have the following values in the context of this profile: digitalSignature or keyAgreement, keyCertSign for verifying signatures on public key certificates.</c>

    <c></c>
    <c></c>

    <c>Extension: Extended Key Usage</c>
    <c>The ExtKeyUsageSyntax field MAY have the following values in context of this profile: id-kp-serverAuth for server authentication, id-kp-clientAuth for client authentication, id-kp-codeSigning for code signing (for software update mechanism), and id-kp-OCSPSigning for future OCSP usage in TLS.</c>

</texttable>

<t>There are various cryptographic algorithms available to sign digital certificates; those algorithms include RSA, the Digital Signature Algorithm (DSA), and ECDSA.  As <xref target="table_ex"/> shows, certificates are signed using ECDSA in this profile.  This is not only true for the end-entity certificates but also for all other certificates in the chain, including CA certificates. This profiling reduces the amount of flash memory needed on an IoT device to store the code of several algorithm implementations due to the smaller number of options.</t>

<t>Further details about X.509 certificates can be found in Section 9.1.3.3 of <xref target="RFC7252"/>.</t>

</section> 

<section title="Client Certificate URLs"> 

<t>RFC 6066 <xref target="RFC6066"/> allows the sending of client-side certificates to be avoided and uses URLs instead. This reduces the over-the-air transmission. Note that the TLS "cached_info" extension does not provide any help with caching client certificates.</t>

<t>TLS/DTLS clients MUST implement support for client certificate URLs for those environments where client-side certificates are used and the server-side is not constrained. For constrained servers this functionality is NOT RECOMMENDED since it forces the server to execute an additional protocol exchange, potentially using a protocol it does not even support. The use of this extension also increases the risk of a DoS attack against the constrained server due to the additional workload.</t>

</section> 

<section title="Trusted CA Indication">

<t>RFC 6066 <xref target="RFC6066"/> allows clients to indicate what trust
anchor they support. With certificate-based authentication, a DTLS server
conveys its end-entity certificate to the client during the DTLS handshake.
Since the server does not necessarily know what trust anchors the client has
stored, to facilitate certification path construction and validation, it
includes intermediate CA certs in the certificate payload.</t> 

 <t>Today, in most IoT deployments there is a fairly static relationship
 between the IoT device (and the software running on them) and the server-side 
infrastructure. For these deployments where IoT devices interact with a fixed,
preconfigured 
  set of servers, this extension is NOT RECOMMENDED.</t>

<t>In cases where clients interact with 
  dynamically discovered TLS/DTLS servers, for example, in the use cases described in <xref target="c-servers"/>, the use of this extension is RECOMMENDED.</t>
</section> 

</section> 

</section>

<section title="Signature Algorithm Extension">

<t>The "signature_algorithms" extension, defined in Section 7.4.1.4.1 of RFC 5246 <xref target="RFC5246"/>, allows the client to indicate to the server which signature/hash algorithm pairs may be used in digital signatures. The client MUST send this extension to select the use of SHA-256, otherwise if this extension is absent, RFC 5246 defaults to SHA-1 / ECDSA for the ECDH_ECDSA and the ECDHE_ECDSA key exchange algorithms.</t>

<t>The "signature_algorithms" extension is not applicable to the PSK-based ciphersuite described in <xref target="psk"/>.</t> 

</section> 


<section title="Error Handling"> 

<t>TLS/DTLS uses the alert protocol to convey errors and specifies a long list of error types. However, not all error messages defined in the TLS/DTLS specification are applicable to this profile. In general, there are two categories of errors (as defined in Section 7.2 of RFC 5246), namely fatal errors and warnings. Alert messages with a level of "fatal" result in the immediate termination of the connection. If possible, developers should try to develop strategies to react to those fatal errors, such as restarting the handshake or informing the user using the (often limited) user interface. Warnings may be ignored by the application since many IoT devices will have either limited ways to log errors or no ability at all. In any case, implementers have to carefully evaluate the impact of errors and ways to remedy the situation since a commonly used approach for delegating decision making to users is difficult (or impossible) to accomplish in a timely fashion.</t>

<t>All error messages marked as RESERVED are only supported for backwards compatibility with the Secure Socket Layer (SSL) and MUST NOT be used with this profile. Those include decryption_failed_RESERVED, no_certificate_RESERVED, and export_restriction_RESERVED.</t>

<t>A number of the error messages MUST only be used for certificate-based ciphersuites. Hence, the following error messages MUST NOT be used with PSK and raw public key authentication:</t>
<t><list style="symbols">
<t>bad_certificate,</t>
<t>unsupported_certificate,</t>
<t>certificate_revoked,</t>
<t>certificate_expired,</t>
<t>certificate_unknown,</t>
<t>unknown_ca, and</t>
<t>access_denied.</t>
</list>
</t>

<t>Since this profile does not make use of compression at the TLS layer, the decompression_failure error message MUST NOT be used either. </t>

<t>RFC 4279 introduced the new alert message "unknown_psk_identity" for PSK ciphersuites.

As stated in Section 2 of RFC 4279, the decrypt_error error message may also be used instead.
For this profile, the TLS server MUST return the decrypt_error error message instead of the unknown_psk_identity since the two mechanisms exist and provide the same functionality.</t>
 
<t>Furthermore, the following errors should not occur with devices and servers supporting this specification, but implementations MUST be prepared to process these errors to deal with servers that are not compliant to the profiles in this document: 
<list style="hanging"> 
<t hangText="protocol_version:">While this document focuses only on one version of the TLS/DTLS protocol, namely version 1.2, ongoing work on TLS/DTLS 1.3 is in progress at the time of writing.</t>
<t hangText="insufficient_security:">This error message indicates that the server requires ciphers to be more secure. This document specifies only one ciphersuite per profile, but it is likely that additional ciphersuites will get added over time.</t>
<t hangText="user_canceled:">Many IoT devices are unattended and hence this error message is unlikely to occur. </t>
</list> 
</t>

</section> 

<section title="Session Resumption"> 

<t>Session resumption is a feature of the core TLS/DTLS specifications that allows a client to continue with an earlier established session state. The resulting exchange is shown in <xref target="resumption"/>. In addition, the server may choose not to do a cookie exchange when a session is resumed. Still, clients have to be prepared to do a cookie exchange with every handshake. The cookie exchange is not shown in the figure.</t>

<t>
<figure title="DTLS Session Resumption" anchor="resumption">
            <artwork><![CDATA[
      Client                                               Server
      ------                                               ------

      ClientHello                   -------->
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    <--------             Finished
      [ChangeCipherSpec]
      Finished                      -------->
      Application Data              <------->     Application Data
]]></artwork>
          </figure>
	    </t>

<t>Constrained clients MUST implement session resumption to improve the performance of the handshake. This will lead to a reduced number of message exchanges, lower computational overhead (since only symmetric cryptography is used during a session resumption exchange), and session resumption requires less bandwidth.</t> 

<t>For cases where the server is constrained (but not the client), the client MUST implement RFC 5077 <xref target="RFC5077"/>. Note that the constrained server refers to a device that has limitations in terms of RAM and flash memory, which place restrictions on the amount of TLS/DTLS security state information that can be stored on such a device. RFC 5077 specifies a version of TLS/DTLS session resumption that does not require per-session state information to be maintained by the constrained server. This is accomplished by using a ticket-based approach.</t>

<t>If both the client and the server are constrained devices, both devices SHOULD implement RFC 5077 and MUST implement basic session resumption. Clients that do not want to use session resumption are always able to send a ClientHello message with an empty session_id to revert to a full handshake.</t>
</section> 

<section title="Compression"> 

<t>Section 3.3 of <xref target="RFC7525"/> recommends disabling TLS-/DTLS-level compression due to attacks, such as CRIME <xref target="CRIME"/>. For IoT applications, compression at the TLS/DTLS layer is not needed since application-layer protocols are highly optimized, and the compression algorithms at the DTLS layer increases code size and complexity.</t>

<t>TLS/DTLS layer compression is NOT RECOMMENDED by this TLS/DTLS profile.</t>

</section> 

<section anchor="pfs" title="Perfect Forward Secrecy"> 

<t>PFS is a property that preserves the confidentiality of past protocol interactions even in situations where the long-term secret is compromised.</t>

<t>The PSK ciphersuite recommended in <xref target="psk"/> does not offer this property since it does not utilize a DH exchange. New ciphersuites that support PFS for PSK-based authentication, such as proposed in <xref target="PSK-AES-CCM-TLS"/>, might become available as a standardized ciphersuite in the (near) future. The recommended PSK-based ciphersuite offers excellent performance, a very small memory  footprint, and has the lowest on the wire overhead at the expense of not using any public cryptography. For deployments where public key cryptography is acceptable, the use of raw public keys might offer a middle ground between the PSK ciphersuite in terms of out-of-band validation and the functionality offered by asymmetric cryptography.</t>

<t>Physical attacks create additional opportunities to gain access to the crypto material stored on IoT devices.  A PFS ciphersuite prevents an attacker from obtaining the communication content exchanged prior to a successful long-term key compromise; however, an implementation that (for performance or energy efficiency reasons) has been reusing the same ephemeral DH keys over multiple different sessions partially defeats PFS, thus increasing the damage extent.  For this reason, implementations SHOULD NOT reuse ephemeral DH keys over multiple protocol exchanges.</t>

<t>The impact of the disclosure of past communication interactions and the desire to increase the cost for pervasive monitoring (as demanded by <xref target="RFC7258"/>) has to be taken into account when selecting a ciphersuite that does not support the PFS property.</t>

<t>Client implementations claiming support of this profile MUST implement the ciphersuites listed in <xref target="credentials"/> according to the selected credential type.</t>

</section> 

<section title="Keep-Alive"> 

<t>Application-layer communication may create state at the endpoints, and this state may expire at some time. For this reason, applications define ways to refresh state, if necessary. While the application-layer exchanges are largely outside the scope of the underlying TLS/DTLS exchange, similar state considerations also play a role at the level of TLS/DTLS. While TLS/DTLS also creates state in the form of a security context (see the security parameter described in Appendix A.6 in RFC 5246) at the client and the server, this state information does not expire. However, network intermediaries may also allocate state and require this state to be kept alive. Failure to keep state alive at a stateful packet filtering firewall or at a NAT may result in the inability for one node to reach the other since packets will get blocked by these middleboxes. Periodic keep-alive messages exchanged between the TLS/DTLS client and server keep state at these middleboxes alive. According to measurements described in <xref target="HomeGateway"/>, there is some variance in state management practices used in residential gateways, but the timeouts are heavily impacted by the choice of the transport-layer protocol: timeouts for UDP are typically much shorter than those for TCP.</t>

<t>RFC 6520 <xref target="RFC6520"/> defines a heartbeat mechanism to test whether the other peer is still alive. As an additional feature, the same mechanism can also be used to perform Path Maximum Transmission Unit (MTU) Discovery.</t>

<t>A recommendation about the use of RFC 6520 depends on the type of message exchange an IoT device performs and the number of messages the application needs to exchange as part of their application functionality. There are three types of exchanges that need to be analyzed:</t>

 <t><list style="hanging">

 <t hangText="Client-Initiated, One-Shot Messages"><vspace blankLines="1"/>
 This is a common communication pattern where IoT devices upload data to
 a server on the Internet on an irregular basis. The communication may be 
 triggered by specific events, such as opening a door.
 <vspace blankLines="1"/> 
The DTLS handshake may need to be restarted (ideally using session resumption, if possible) in case of an IP address change.  
 <vspace blankLines="1"/> 
 In this case, there is no use for a keep-alive extension for this scenario.
 </t> 
 <t hangText="Client-Initiated, Regular Data Uploads"><vspace blankLines="1"/>
 This is a variation of the previous case whereby data gets uploaded on a 
 regular basis, for example, based on frequent temperature readings. 
 If neither NAT bindings nor IP
 address changes occurred, then the record layer will not notice any
 changes. For the case where the IP address and port number changes, it is necessary
 to recreate the record layer using session resumption.
 <vspace blankLines="1"/> 
 In this scenario, there is no use for a keep-alive extension. It is also very 
 likely that the device will enter a sleep cycle in between data transmissions 
 to keep power consumption low.</t>

 <t hangText="Server-Initiated Messages"><vspace blankLines="1"/>
 In the two previous scenarios, the client initiates the protocol interaction and maintains it. 
  Since messages to the 
 client may get blocked by middleboxes, the initial connection setup is triggered by the client 
 and then kept alive by the server. 
 <vspace blankLines="1"/> 
 For this message exchange pattern, the use of DTLS heartbeat messages is
 quite useful but may have to be coordinated with application exchanges (for example, when the 
CoAP resource directory is used) to avoid redundant keep-alive message exchanges. 
The MTU discovery mechanism, which is also part of <xref target="RFC6520"/>, is less
 likely to be relevant since for many IoT deployments, the most constrained
 link is the wireless interface between the IoT device and the network itself (rather than
 some links along the end-to-end path). Only in more complex network topologies, such as 
multi-hop mesh networks, path MTU discovery might be appropriate. It also has to be noted 
that DTLS itself already provides a basic path discovery mechanism (see Section 4.1.1.1 of 
RFC 6347) by using the fragmentation capability of the handshake protocol.</t>
</list> 
</t>

<t>For server-initiated messages, the heartbeat extension is RECOMMENDED.</t>
</section> 


<section anchor="timeouts" title="Timeouts">

<t>A variety of wired and wireless technologies are available to connect devices to the Internet. Many of the low-power radio technologies, such as IEEE 802.15.4 or Bluetooth Smart, only support small frame sizes (e.g., 127 bytes in case of IEEE 802.15.4 as explained in <xref target="RFC4919"/>). Other radio technologies, such as the Global System for Mobile Communications (GSM) using the short messaging service (SMS), have similar constraints in terms of payload sizes, such as 140 bytes without the optional segmentation and reassembly scheme known as "Concatenated SMS", but show higher latency. 
</t>

<t>The DTLS handshake protocol adds a fragmentation and reassembly mechanism to the TLS handshake protocol since each DTLS record must fit within a single transport layer datagram, as described in Section 4.2.3 of <xref target="RFC6347"/>. Since handshake messages are potentially bigger than the maximum record size, the mechanism fragments a handshake message over a number of DTLS records, each of which can be transmitted separately.</t>

<t>To deal with the unreliable message delivery provided by UDP, DTLS adds timeouts and "per-flight" retransmissions, as described in Section 4.2.4 of <xref target="RFC6347"/>. 

Although the timeout values are implementation specific, recommendations are provided in Section 4.2.4.1 of <xref target="RFC6347"/>, with an initial timer value of 1 second and double the value at each retransmission, up to no less than 60 seconds.</t>

<t>TLS protocol steps can take longer due to higher processing time on the constrained side.  On the other hand, the way DTLS handles retransmission, which is per-flight instead of per-segment, tends to interact poorly with low-bandwidth networks.</t>

<t>For these reasons, it's essential that the probability of a spurious retransmit is minimized and, on timeout, the sending endpoint does not react too aggressively.  The latter is particularly relevant when the Wireless Sensor Network (WSN) is temporarily congested: if lost packets are reinjected too quickly, congestion worsens.</t>

<t>An initial timer value of 9 seconds with exponential back off up to no less then 60 seconds is therefore RECOMMENDED.</t>

<t>This value is chosen big enough to absorb large latency variance due to either slow computation on constrained endpoints or intrinsic network characteristics (e.g., GSM-SMS), as well as to produce a low number of retransmission events and relax the pacing between them.  Its worst case wait time is the same as using 1s timeout (i.e., 63s), while triggering less than half of the retransmissions (2 instead of 5).</t>

<t>In order to minimize the wake time during DTLS handshake, sleepy nodes might decide to select a lower threshold and, consequently, a smaller initial timeout value.  If this is the case, the implementation MUST keep into account the considerations about network stability described in this section.</t>

</section>

<section anchor="random" title="Random Number Generation"> 

 <t>The TLS/DTLS protocol requires random numbers to be available during the protocol run. For example, during the ClientHello and the ServerHello exchange, the client and the server exchange random numbers. Also, the use of the DH exchange requires random numbers during the key pair generation.</t>

 <t>It is important to note that sources contributing to the randomness pool on laptops or desktop PCs are not available on many IoT devices, such as mouse movement, timing of keystrokes, air turbulence on the movement of hard drive heads, etc. Other sources have to be found or dedicated hardware has to be added.</t>
 
 <t>Lacking sources of randomness in an embedded system may lead to the same keys generated again and again.</t>


<t>
   The ClientHello and the ServerHello messages contain the "Random"
   structure, which has two components: gmt_unix_time and a sequence of
   28 random bytes. gmt_unix_time holds the current time and date in
   standard UNIX 32-bit format (seconds since the midnight starting Jan
   1, 1970, GMT). Since many IoT devices do not have access to an accurate clock, it is RECOMMENDED that the receiver of a ClientHello or ServerHello does not assume that the value in "Random.gmt_unix_time" is an accurate representation of the current time and instead treats it as an opaque random string.
</t>

<t>
   When TLS is used with certificate-based authentication, the
   availability of time information is needed to check the validity of
   a certificate. Higher-layer protocols may provide secure time
   information. The gmt_unix_time component of the ServerHello is not
   used for this purpose.
</t>

   
<t>IoT devices using TLS/DTLS must offer ways to generate quality random numbers. There are various implementation choices for integrating a hardware-based random number generator into a product: an implementation inside the microcontroller itself is one option, but dedicated crypto chips are also reasonable choices. The best choice will depend on various factors outside the scope of this document. Guidelines and requirements for random number generation can be found in RFC 4086 <xref target="RFC4086"/> and in the NIST Special Publication 800-90a <xref target="SP800-90A"/>.</t>

<t>Chip manufacturers are highly encouraged to provide sufficient documentation of their design for random number generators so that customers can have confidence about the quality of the generated random numbers. The confidence can be increased by providing information about the procedures that have been used to verify the randomness of numbers generated by the hardware modules. For example, NIST Special Publication 800-22b <xref target="SP800-22b"/> describes statistical tests that can be used to verify random number generators.</t>
</section> 

<section title="Truncated MAC and Encrypt-then-MAC Extension">

 <t>The truncated MAC extension was introduced in RFC 6066 <xref target="RFC6066"/> with the goal to reduce
  the size of the MAC used at the record layer. This extension was developed for TLS 
  ciphersuites that used older modes of operation where the MAC and the encryption 
  operation were performed independently.</t>

 <t>The recommended ciphersuites in this document use the newer AEAD construct, namely the CCM mode
  with 8-octet authentication tags, and are therefore not applicable to the truncated MAC extension.</t> 

<t>RFC 7366 <xref target="RFC7366"/> introduced the encrypt-then-MAC extension (instead of the previously used MAC-then-encrypt) since the MAC-then-encrypt mechanism has
   been the subject of a number of security vulnerabilities. RFC 7366 is, however, also not applicable to the AEAD ciphers recommended in this document.</t>

 <t>Implementations conformant to this specification MUST use AEAD ciphers.
RFC 7366 ("encrypt-then-MAC") and RFC 6066 ("truncated MAC extension") are not applicable to this
        specification and MUST NOT be used.</t>
 </section> 

    <section title="Server Name Indication (SNI)"> 

   <t>The SNI extension <xref target="RFC6066"/> defines a mechanism for a client to tell a TLS/DTLS server the name of the server it wants to contact. This is a useful extension for many hosting environments where multiple virtual servers are run on a single IP address.</t>

 <t>Implementing the Server Name Indication extension is REQUIRED unless it is known that a TLS/DTLS client does not interact with a server in a hosting environment.</t>

</section> 
 
<section title="Maximum Fragment Length Negotiation">

<t>This RFC 6066 extension lowers the maximum fragment length support needed for the
 record layer from 2^14 bytes to 2^9 bytes.</t>

 <t>This is a very useful extension that allows the client to indicate to the
 server how much maximum memory buffers it uses for incoming messages. 
 Ultimately, the main benefit of this extension is to allow client
 implementations to lower their RAM requirements since the client does not
 need to accept packets of large size (such as 16K packets as
 required by plain TLS/DTLS).</t>

 <t>Client implementations MUST support this extension.</t>

</section> 

<section title="Session Hash">

<t>In order to begin connection protection, the Record Protocol requires specification 
of a suite of algorithms, a master secret, and the client and server random values. The algorithm for computing the master secret is defined in Section 8.1 of RFC 5246, but it only includes a small number of parameters exchanged during the handshake and does not include parameters like the client and server identities. This can be utilized by an attacker to mount a man&nbhy;in&nbhy;the&nbhy;middle 
   attack since the  master secret is not guaranteed to be unique across sessions, as discovered in the "triple handshake" attack <xref target="Triple-HS"/>.</t>

<t><xref target="RFC7627"/> defines a TLS extension that binds the master secret 
   to a log of the full handshake that computes it, thus preventing such attacks. </t>
   
 <t>Client implementations SHOULD implement this extension
    even though the ciphersuites recommended by this profile are not vulnerable to this attack. For 
    DH-based ciphersuites, the keying material is contributed by both parties and in 
    case of the pre-shared secret key ciphersuite, both parties need to be in possession of the 
    shared secret to ensure that the handshake completes successfully. It is, however, possible 
    that some application-layer protocols will tunnel other authentication protocols on top of 
    DTLS making this attack relevant again.</t>

</section> 

<section title="Renegotiation Attacks"> 

<t>TLS/DTLS allows a client and a server that already have a TLS/DTLS connection to negotiate new parameters, generate new keys, etc., by using the renegotiation feature. Renegotiation happens in the existing connection, with the new handshake packets being encrypted along with application data. Upon completion of the renegotiation procedure, the new channel replaces the old channel.</t>

<t>As described in RFC 5746 <xref target="RFC5746"/>, there is no cryptographic binding between the two handshakes, although the new handshake is carried out
using the cryptographic parameters established by the original handshake.</t>

<t>To prevent the renegotiation attack <xref target="RFC5746"/>, this specification REQUIRES the TLS renegotiation feature to be disabled. Clients MUST respond to server-initiated renegotiation attempts with an alert message (no_renegotiation), and clients MUST NOT initiate them. </t>

</section> 

<section title="Downgrading Attacks"> 

<t>When a client sends a ClientHello with a version higher than the highest version known to the server, the server is supposed to reply with ServerHello.version equal to the highest version known to the server, and then the handshake can proceed. This behavior is known as version tolerance. Version intolerance is when the server (or a middlebox) breaks the handshake when it sees a ClientHello.version higher than what it knows about. This is the behavior that leads some clients to rerun the handshake with a lower version. As a result, a potential security vulnerability is introduced when a system is running an old TLS/SSL version (e.g., because of the need to integrate with legacy systems). In the worst case, this allows an attacker to downgrade the protocol handshake to SSL 3.0. SSL 3.0 is so broken that there is no secure cipher available for it (see <xref target="RFC7568"/>).</t>

<t>The above-described downgrade vulnerability is solved by the TLS Fallback Signaling Cipher Suite Value (SCSV) <xref target="RFC7507"/> extension. However, the solution is not applicable to implementations conforming to this profile since the version negotiation MUST use TLS/DTLS version 1.2 (or higher). More specifically, this implies: <list style="symbols">
<t>Clients MUST NOT send a TLS/DTLS version lower than version 1.2 in the ClientHello.</t>
<t>Clients MUST NOT retry a failed negotiation offering a TLS/DTLS version lower than 1.2.</t>
<t>Servers MUST fail the handshake by sending a protocol_version fatal alert if a TLS/DTLS version >= 1.2 cannot be negotiated. Note that the aborted connection is non-resumable.</t>
</list>
</t>

</section> 

<section title="Crypto Agility"> 

<t>This document recommends that software and chip manufacturers implement AES and the CCM mode of operation. This document references the CoAP-recommended ciphersuite choices, which have been selected based on implementation and deployment experience from the IoT community. Over time, the preference for algorithms will, however, change. Not all components of a ciphersuite are likely to change at the same speed. Changes are more likely expected for ciphers, the mode of operation, and the hash algorithms. The recommended key lengths have to be adjusted over time as well. Some deployment environments will also be impacted by local regulation, which might dictate a certain algorithm and key size combination. Ongoing discussions regarding the choice of specific ECC curves will also likely impact implementations. Note that this document does not recommend or mandate a specific ECC curve.</t>

<t>The following recommendations can be made to chip manufacturers:<list style="symbols"> 

<t>Make any AES hardware-based crypto implementation accessible to developers working on security implementations at higher layers in the protocol stack. Sometimes hardware implementations are added to microcontrollers to offer support for functionality needed at the link layer and are only available to the on-chip link-layer protocol implementation. Such a setup does not allow application developers to reuse the hardware-based AES implementation.</t> 

<t>Provide flexibility for the use of the crypto function with future extensibility in mind. For example, making an AES-CCM implementation available to developers is a first step but such an implementation may not be usable due to parameter differences between an AES-CCM implementation. AES-CCM in IEEE 802.15.4 and Bluetooth Smart use a nonce length of 13 octets while DTLS uses a nonce length of 12 octets. Hardware implementations of AES-CCM for IEEE 802.15.4 and Bluetooth Smart are therefore not reusable by a DTLS stack. </t> 

<t>Offer access to building blocks in addition (or as an alternative) to the complete functionality. For example, a chip manufacturer who gives developers access to the AES crypto function can use it to build an efficient AES-GCM implementation. Another example is to make a special instruction available that increases the speed of speed-up carryless multiplications.</t>

</list> 
</t>

<t>As a recommendation for developers and product architects, we suggest that sufficient headroom is provided to allow an upgrade to a newer cryptographic algorithm over the lifetime of the product. As an example, while AES-CCM is recommended throughout this specification, future products might use the ChaCha20 cipher in combination with the Poly1305 authenticator <xref target="RFC7539"/>. The assumption is made that a robust software update mechanism is offered.</t>

</section> 
    
<section title="Key Length Recommendations">

<t>RFC 4492 <xref target="RFC4492"/> gives approximate comparable key sizes for symmetric- and asymmetric-key cryptosystems based on the best-known algorithms for attacking them. While other publications suggest slightly different numbers, such as <xref target="Keylength"/>, the approximate relationship still holds true. <xref target="kl-table"/> illustrates the comparable key sizes in bits.</t>


<t>
<figure title="Comparable Key Sizes (in Bits) Based on RFC 4492" anchor="kl-table">
            <artwork><![CDATA[
                    Symmetric  |   ECC   |  DH/DSA/RSA
                   ------------+---------+-------------
                        80     |   163   |     1024
                       112     |   233   |     2048
                       128     |   283   |     3072
                       192     |   409   |     7680
                       256     |   571   |    15360
]]></artwork>
          </figure>
	    </t>

<t>At the time of writing, the key size recommendations for use with TLS-based ciphers found in <xref target="RFC7525"/> recommend DH key lengths of at least 2048 bits, which corresponds to a 112-bit symmetric key and a 233-bit ECC key. These recommendations are roughly in line with those from other organizations, such as the National Institute of Standards and Technology (NIST) or the European Network and Information Security Agency (ENISA). The authors of <xref target="ENISA-Report2013"/> add that a 80-bit symmetric key is sufficient for legacy applications for the coming years, but a 128-bit symmetric key is the minimum requirement for new systems being deployed. The authors further note that one needs to also take into account the length of time data needs to be kept secure for. The use of 80-bit symmetric keys for transactional data may be acceptable for the near future while one has to insist on 128-bit symmetric keys for long-lived data.</t>

<t>Note that the recommendations for 112-bit symmetric keys are chosen conservatively under the assumption that IoT devices have a long expected lifetime (such as 10+ years) and that this key length recommendation refers to the long-term keys used for device authentication. Keys, which are provisioned dynamically, for the protection of transactional data (such as ephemeral DH keys used in various TLS/DTLS ciphersuites) may be shorter considering the sensitivity of the exchanged data.</t>
  
</section> 

    <section title="False Start">
<t>A full TLS handshake as specified in <xref target="RFC5246"/> requires two full protocol rounds (four flights) before the handshake is complete and the protocol parties may begin to send application data.</t> 

<t>An abbreviated handshake (resuming an earlier TLS session) is complete after three flights, thus adding just one round-trip time if the client sends application data first.</t>
   
<t>If the conditions outlined in <xref target="TLS-FALSESTART"/> are met, application data can be transmitted when the sender has sent its own "ChangeCipherSpec" and "Finished" messages. This achieves an improvement of one round-trip time for full handshakes if the client sends application data first and for abbreviated handshakes if the server sends application data first.</t>
	  
<t>The conditions for using the TLS False Start mechanism are met by the public-key-based ciphersuites in this document. In summary, the conditions are: 
<list style="symbols">
<t>Modern symmetric ciphers with an effective key length of 128 bits, such as AES-128-CCM</t>
<t>Client certificate types, such as ecdsa_sign</t>
<t>Key exchange methods, such as ECDHE_ECDSA</t>
</list> 
</t>

<t>Based on the improvement over a full round-trip for the full TLS/DTLS exchange, this specification RECOMMENDS the use of the False Start mechanism when clients send application data first.</t>
</section> 

    <section title="Privacy Considerations" anchor="privacy">
      
      <t>The DTLS handshake exchange conveys various identifiers, which can be observed by an on-path eavesdropper. For example, 
      the DTLS PSK exchange reveals the PSK identity, the supported extensions, the session ID, algorithm parameters, etc. 
      When session resumption is used, then individual TLS sessions can be correlated by an on-path adversary. 
      With many IoT deployments, it is likely that keying material and their identifiers 
      are persistent over a longer period of time due to the cost of updating software on these devices.</t>
      
      <t>User participation poses a challenge in many IoT deployments since many of the IoT devices operate unattended, even though they are initially provisioned by a human. 
      The ability to control data sharing and to configure preferences will have to be provided at a system level rather than at the level of the DTLS exchange itself, which is the scope 
      of this document. Quite naturally, the use of DTLS with mutual authentication will allow a TLS server to collect authentication information about the IoT device (likely over a long period of time). While this strong form of authentication will prevent misattribution, it also allows strong identification. Device-related data collection (e.g., sensor recordings) associated with other data types will prove to be truly useful, but this extra data might include personal information about the owner of the device or data about the environment it senses. Consequently, the data stored on the server side will be vulnerable to stored data compromise. For the communication between the client and the server, this specification prevents eavesdroppers from gaining access to the communication content. While the PSK-based ciphersuite does not provide PFS, the asymmetric versions do. This prevents an adversary from obtaining past communication content when access to a long-term secret has been gained. Note that no extra effort to make traffic analysis more difficult is provided by the recommendations made in this document.</t>
      
<t>Note that the absence or presence of communication itself might reveal information to an adversary. For example, a presence sensor may initiate messaging when a person enters a building. While TLS/DTLS would offer confidentiality protection of the transmitted information, it does not help to conceal all communication patterns. Furthermore, the IP header, which is not protected by TLS/DTLS, additionally reveals information about the other communication endpoint. For applications where such privacy concerns exist, additional safeguards are required, such as injecting dummy traffic and onion routing. A detailed treatment of such solutions is outside the scope of this document and requires a system-level view.</t>
    </section>
 
    <section title="Security Considerations" anchor="security">
 
       <t>This entire document is about security.</t>
       
       <t>We would also like to point out that designing a software update mechanism into an IoT system is crucial to ensure that both functionality can be enhanced and that potential vulnerabilities can be fixed. This software update mechanism is important for changing configuration information, for example, trust anchors and other keying-related information. Such a suitable software update mechanism is available with the LWM2M protocol published by the OMA <xref target="LWM2M"/>.</t> 
    </section>
    
  </middle>

  <back>


    <references title="Normative References">
      &RFC5246;       
      &RFC5746; 
      &RFC6066; 
      &RFC6347; 
      &RFC6520; 
      &RFC4279; 
      &RFC6125; 
      &RFC2119; 

<!--draft-ietf-tls-cached-info-23; in AUTH48-DONE / part of C264-->
<reference anchor='RFC7924' target="http://www.rfc-editor.org/info/rfc7924">
<front>
<title>Transport Layer Security (TLS) Cached Information Extension</title>
<author initials='S' surname='Santesson' fullname='Stefan Santesson'>
    <organization />
</author>
<author initials='H' surname='Tschofenig' fullname='Hannes Tschofenig'>
    <organization />
</author>
<date month='July' year='2016' />
</front>
<seriesInfo name='RFC' value='7924' />
<seriesInfo name='DOI' value='10.17487/RFC7924' />
</reference>


      &RFC7627;
      &RFC7250; 
      &RFC7251; 
      
      <reference anchor="EUI64" target="https://standards.ieee.org/regauth/oui/tutorials/EUI64.html">
  	<front>
      <title>Guidelines for 64-bit Global Identifier (EUI-64)</title>
          <author>
           <organization>IEEE</organization>
          </author>
         <date/>
  	</front>
       <seriesInfo name="Registration" value="Authority"/>        
	  </reference>

      <reference anchor="WAP-WDP">
        <front>
      <title>Wireless Datagram Protocol</title>
          <author>
            <organization>Open Mobile Alliance</organization>
          </author>
          <date month="June" year="2001" />
        </front>
      <seriesInfo name='Wireless Application Protocol,' value='WAP-259-WDP' />
      </reference>

      <reference anchor="GSM-SMS">
        <front>
          <title>3rd Generation Partnership Project; Technical Specification Group Core Network and Terminals; Technical realization of the Short Message Service (SMS) (Release 13)</title>
          <author>
            <organization>ETSI</organization>
          </author>
          <date month="March" year="2016" />
        </front>
        <seriesInfo name='3GPP TS 23.040' value='V13.1.0' />
      </reference>
    </references> 

    <references title="Informative References">

      &RFC1981; 
      &RFC4492; 
      &RFC5077;  
      &RFC7252; 

<!--draft-tschofenig-core-coap-tcp-tls-05 replaced by draft-ietf-core-coap-tcp-tls-03; Active, AD is watching--> 
<reference anchor='COAP-TCP-TLS'>
<front>
<title>CoAP (Constrained Application Protocol) over TCP, TLS, and WebSockets</title>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>
<author initials='S' surname='Lemay' fullname='Simon Lemay'>
    <organization />
</author>
<author initials='H' surname='Tschofenig' fullname='Hannes Tschofenig'>
    <organization />
</author>
<author initials='K' surname='Hartke' fullname='Klaus Hartke'>
    <organization />
</author>
<author initials='B' surname='Silverajan' fullname='Bill Silverajan'>
    <organization />
</author>
<author initials='B' surname='Raymor' fullname='Brian Raymor'>
    <organization />
</author>
<date month='July' year='2016' />
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-core-coap-tcp-tls-03' />

</reference>


     <reference anchor="IANA-TLS" target="https://www.iana.org/assignments/tls-parameters">
        <front>
          <title>Transport Layer Security (TLS) Parameters</title>
          <author> 
            <organization>IANA</organization>
          </author>
          <date/>
        </front>  
     </reference>

      <reference anchor="CRIME" target="https://en.wikipedia.org/w/index.php?title=CRIME&amp;oldid=721665716">
        <front>
          <title>CRIME</title>
          <author>
            <organization>Wikipedia</organization>
          </author>
          <date month="May" year="2016" />
        </front>
      </reference>

     <reference anchor="LWM2M" target="http://openmobilealliance.org/about-oma/work-program/m2m-enablers">
        <front>
          <title>Lightweight Machine-to-Machine Requirements</title>
          <author>
            <organization>Open Mobile Alliance</organization>
          </author>
          <date month="December" year="2013" />
        </front>
        <seriesInfo name='Candidate Version 1.0,' value='OMA-RD-LightweightM2M-V1_0-20131210-C' />
      </reference>

      <reference anchor="HomeGateway" target="http://conferences.sigcomm.org/imc/2010/papers/p260.pdf">
        <front>
          <title>An Experimental Study of Home Gateway Characteristics</title>
               <author initials="L." surname="Eggert" fullname="Lars Eggert">
              <organization/>
            </author>
             <author initials="S." surname="Hatoen" fullname="Seppo Hatonen">
              <organization/>
            </author>
            <author initials="M." surname="Kojo" fullname="Markku Kojo">
              <organization/>
            </author>
            <author initials="A." surname="Nyrhinen" fullname="Aki Nyrhinen">
              <organization/>
            </author>
            <author initials="P." surname="Sarolahti" fullname="Pasi Sarolahti">
              <organization/>
            </author><author initials="S." surname="Strowes" fullname="Stephen Strowes">
              <organization/>
            </author>
          <date year="2010"/>
        </front>
        <seriesInfo name='In Proceedings of the' value='10th ACM SIGCOMM conference on Internet measurement'/>
        <seriesInfo name='DOI' value='10.1145/1879141.1879174'/>
      </reference>

      &RFC4086; 
      &RFC6090; 
      &RFC5934;  
      &RFC5280; 
      &RFC6961; 
      &RFC5116;  
      &RFC5758; 
      &RFC6655;

<!--draft-schmertmann-dice-ccm-psk-pfs-01; Expired-->
<reference anchor='PSK-AES-CCM-TLS'>
<front>
<title>ECDHE-PSK AES-CCM Cipher Suites with Forward Secrecy for Transport Layer Security (TLS)</title>
<author initials='L' surname='Schmertmann' fullname='Lars Schmertmann'>
    <organization />
</author>
<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>
<date month='August' year='2014' />
</front>
<seriesInfo name='Work in Progress,' value='draft-schmertmann-dice-ccm-psk-pfs-01' />
</reference>

      &RFC7258;

<!--draft-ietf-tls-negotiated-dl-dhe-00 replaced by draft-ietf-tls-negotiated-ff-dhe-10; Active, in AUTH48*R (RFC 7919/C255)-->
<reference anchor='FFDHE-TLS'>
<front>
<title>Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for TLS</title>
<author initials='D' surname='Gillmor' fullname='Daniel Kahn Gillmor'>
    <organization />
</author>
<date month='June' year='2015' />
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-tls-negotiated-ff-dhe-10' />
</reference>

      &RFC7507;
      &RFC7465;
      &RFC7452; 
 
<!--draft-ietf-tls-falsestart-02; Active, in AUTH48-DONE (RFC 7918/C255)-->
<reference anchor='TLS-FALSESTART'>
<front>
<title>Transport Layer Security (TLS) False Start</title>
<author initials='A' surname='Langley' fullname='Adam Langley'>
    <organization />
</author>
<author initials='N' surname='Modadugu' fullname='Nagendra Modadugu'>
    <organization />
</author>
<author initials='B' surname='Moeller' fullname='Bodo Moeller'>
    <organization />
</author>
<date month='May' year='2016' />
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-tls-falsestart-02' />
</reference>


      &RFC7366; 
      &RFC7228;  
      &RFC4919; 
      &RFC2104; 
      &RFC6024; 
      &RFC5480;  
      &RFC6234;
      &RFC3610; 
      &RFC5288; 
      &RFC7400; 
      &RFC5247; 
      &RFC5216; 
      &RFC7397; 
      &RFC7390; 
      &RFC6690;


<!--draft-ietf-core-resource-directory-08; Active, AD is watching-->
<reference anchor='CoRE-RD'>
<front>
<title>CoRE Resource Directory</title>
<author initials='Z' surname='Shelby' fullname='Zach Shelby'>
    <organization />
</author>
<author initials='M' surname='Koster' fullname='Michael Koster'>
    <organization />
</author>
<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>
<author initials='P' surname='Stok' fullname='Peter Van der Stok'>
    <organization />
</author>
<date month='July' year='2016' />
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-core-resource-directory-08' />
</reference>


      &RFC2865; 
      &RFC3748; 
      &RFC6733; 
      &RFC7748;


    <reference anchor="AES" target="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">
        <front>
          <title>Advanced Encryption Standard (AES)</title>
          <author> 
            <organization>National Institute of Standards and Technology</organization>
          </author>
          <date month="November" year="2001"/>
        </front>
       <seriesInfo name="NIST FIPS PUB" value="197"/>
     </reference>

  <reference anchor="SP800-22b" target="http://csrc.nist.gov/publications/nistpubs/800-22-rev1a/SP800-22rev1a.pdf">
        <front>
          <title>A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications</title>
          <author> 
            <organization>National Institute of Standards and Technology</organization>
          </author>
          <date month="April" year="2010"/>
        </front>
        <seriesInfo name="NIST Special Publication 800-22," value="Revision 1a"/>
     </reference>

  <reference anchor="CCM" target="http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf">
        <front>
          <title>Recommendation for Block Cipher Modes of Operation: The CCM Mode for Authentication and Confidentiality</title>
          <author> 
            <organization>National Institute of Standards and Technology</organization>
          </author>
          <date month="May" year="2004"/>
        </front>
       <seriesInfo name="NIST Special Publication" value="800-38C"/>
     </reference>

  <reference anchor="SP800-90A" target="http://csrc.nist.gov/publications/drafts/800-90/sp800-90a_r1_draft_november2014_ver.pdf">
        <front>
          <title>Recommendation for Random Number Generation Using Deterministic Random Bit Generators</title>
          <author> 
            <organization>National Institute of Standards and Technology</organization>
          </author>
          <date month="June" year="2015"/>
        </front>
       <seriesInfo name="NIST Special Publication 800-90A" value="Revision 1"/>
       <seriesInfo name="DOI" value="10.6028/NIST.SP.800-90Ar1"/>
     </reference>

  <reference anchor="SP800-107-rev1" target="http://csrc.nist.gov/publications/nistpubs/800-107-rev1/sp800-107-rev1.pdf">
        <front>
          <title>Recommendation for Applications Using Approved Hash Algorithms</title>
          <author> 
            <organization>National Institute of Standards and Technology</organization>
          </author>
          <date month="August" year="2012"/>
        </front>
       <seriesInfo name="NIST Special Publication" value="800-107, Revision 1"/>
      <seriesInfo name="DOI" value="10.6028/NIST.SP.800-107r1"/>
     </reference>

      &RFC7539; 
      &RFC7568; 
      &RFC7525;
      &RFC4821; 
      &RFC6943; 

     <reference anchor="Keylength" target="http://www.keylength.com">
        <front>
          <title>Cryptographic Key Length Recommendations</title>
          <author initials="D." surname="Giry" fullname="D. Giry"> 
            <organization/>
          </author>
          <date month="September" year="2015"/>
        </front>
     </reference>

     <reference anchor="ENISA-Report2013" target="https://www.enisa.europa.eu/activities/identity-and-trust/library/deliverables/algorithms-key-sizes-and-parameters-report">
        <front>
          <title>Algorithms, Key Sizes and Parameters Report - 2013</title>
          <author> 
            <organization>ENISA</organization>
          </author>
          <date month="October" year="2013"/>
        </front>
     </reference>


<reference anchor="Triple-HS">
<front>
<title>Triple Handshakes and Cookie Cutters: Breaking and Fixing Authentication over TLS</title>
<author initials="K" surname="Bhargavan" fullname="K. Bhargavan"> 
<organization/>
</author>
<author initials="C" surname="Delignat-Lavaud" fullname="C. Delignat-Lavaud">
<organization/>
</author>             
<author initials="A" surname="Pironti" fullname="A. Pironti">
<organization/>
</author>
<author initials="P" surname="Yves Strub" fullname="P. Yves Strub">
<organization/>
</author>
<date year="2014"/>
</front>
<seriesInfo name="In Proceedings of the" value="IEEE Symposium on Security and Privacy, Pages 98-113"/>
<seriesInfo name="DOI" value="10.1109/SP.2014.14"/>
</reference>

   <reference anchor="ImprintingSurvey" target="http://www.lix.polytechnique.fr/hipercom/SmartObjectSecurity/papers/EricRescorla.pdf">
        <front>
          <title>A Brief Survey of Imprinting Options for Constrained Devices</title>
          <author fullname="Eric Rescorla" initials="E" surname="Chilton">
          </author>
          <date month="March" year="2012"/>
        </front>
      </reference>
	 
   <reference anchor="ACE-WG" target="https://datatracker.ietf.org/wg/ace/charter">
        <front>
          <title>Authentication and Authorization for Constrained Environments (ACE) Working Group</title>
          <author> 
            <organization>IETF</organization>
          </author>
          <date/>
        </front>
      </reference>
    </references>
 

<section anchor="DTLSoSMS" title="Conveying DTLS over SMS">

<t>This section is normative for the use of DTLS over SMS. Timer recommendations are already outlined in <xref target="timeouts"/> and also applicable to the transport of DTLS over SMS.</t>

<t>This section requires readers to be familiar with the terminology
   and concepts described in <xref target="GSM-SMS"/> and <xref target="WAP-WDP"/>.</t>

<t>The remainder of this section assumes Mobile Stations are
   capable of producing and consuming Transport Protocol Data Units (TPDUs) encoded as 8-bit binary data.</t>

<section anchor="DTLSoSMSoverview" title="Overview">

<t>DTLS adds an additional round-trip to the TLS <xref target="RFC5246"/> handshake to
   serve as a return-routability test for protection against certain
   types of DoS attacks.  Thus, a full-blown DTLS handshake comprises up
   to 6 "flights" (i.e., logical message exchanges), each of which is then mapped on to one or more DTLS records using the segmentation and reassembly (SaR) scheme described in Section 4.2.3 of <xref target="RFC6347"/>. The overhead for said scheme is 6 bytes per handshake message which,
   given a realistic 10+ messages handshake, would amount to around 60
   bytes across the whole handshake sequence.</t>

<t>Note that the DTLS SaR scheme is defined for handshake messages
   only. In fact, DTLS records are never fragmented and MUST fit within a single transport layer datagram.</t>


<t>SMS provides an optional segmentation and reassembly scheme as well,
   known as Concatenated short messages (see Section 9.2.3.24.1 of
   <xref target="GSM-SMS"/>).  However, since the SaR scheme in DTLS cannot be
   circumvented, the Concatenated short messages mechanism SHOULD NOT be
   used during handshake to avoid redundant overhead.  Before starting
   the handshake phase (either actively or passively), the DTLS
   implementation MUST be explicitly configured with the Path MTU (PMTU) of the SMS
   transport in order to correctly instrument its SaR function.  The
   PMTU SHALL be 133 bytes if multiplexing based on the Wireless Datagram Protocol (WDP) is used (see
   <xref target="SAmux"/>); 140 bytes otherwise.</t>

<t>It is RECOMMENDED that the established security context over the
   longest possible period be used (possibly until a Closure Alert message is
   received or after a very long inactivity timeout) to avoid the
   expensive re-establishment of the security association.</t>
</section> 


<section title="Message Segmentation and Reassembly">

<t>The content of an SMS message is carried in the TP-UserData field,
   and its size may be up to 140 bytes.  As already mentioned in
   <xref target="DTLSoSMSoverview"/>, longer (i.e., up to 34170 bytes) messages can be sent
   using Concatenated SMS.</t>

<t>This scheme consumes 6-7 bytes (depending on whether the short or
   long segmentation format is used) of the TP-UserData field, thus
   reducing the space available for the actual content of the SMS
   message to 133-134 bytes per TPDU.</t>

<t>Though in principle a PMTU value higher than 140 bytes could be used,
   which may look like an appealing option given its more efficient use
   of the transport, there are disadvantages to
   consider. First, there is an additional overhead of 7 bytes per TPDU to be paid to
   the SaR function (which is in addition to the overhead introduced by the DTLS
SaR mechanism. Second, some networks only partially support the Concatenated SMS function, and 
others do not support it at all.</t>

<t>For these reasons, the Concatenated short messages mechanism SHOULD
   NOT be used, and it is RECOMMENDED to leave the same PMTU settings
   used during the handshake phase, i.e., 133 bytes if WDP-based
   multiplexing is enabled; 140 bytes otherwise.
</t>

<t>Note that, after the DTLS handshake has completed, any fragmentation and
   reassembly logic that pertains the application layer (e.g.,
   segmenting CoAP messages into DTLS records and reassembling them
   after the crypto operations have been successfully performed) needs
   to be handled by the application that uses the established DTLS
   tunnel.</t>

</section> 

<section anchor="SAmux" title="Multiplexing Security Associations">

<t>Unlike IPsec Encapsulating Security Payload (ESP) / Authentication Header (AH), DTLS records do not contain any association
   identifiers.  Applications must arrange to multiplex between
   associations on the same endpoint which, when using UDP/IP, is
   usually done with the host/port number.</t>

<t>If the DTLS server allows more than one client to be active at any
   given time, then the Wireless Application Protocol (WAP) User Datagram Protocol <xref target="WAP-WDP"/> can be used
   to achieve multiplexing of the different security associations.  (The
   use of WDP provides the additional benefit that upper-layer protocols
   can operate independently of the underlying wireless network, hence
   achieving application-agnostic transport handover.) </t>

<t>The total overhead cost for encoding the WDP source and
destination ports is either 5 or 7 bytes out of the total available for
the SMS content depending on if 1-byte or 2-byte port identifiers are
used, as shown in Figures <xref target="addressing8" format="counter"/> and <xref target="addressing16" format="counter"/>.</t>

<!-- [rfced] In Figures 13 and 14, what do "UDH" and "IEI" stand for?
Please add text to provide this information to the reader.
-->

<t>
<figure title="Application Port Addressing Scheme (8-Bit Address)" anchor="addressing8">
            <artwork><![CDATA[
0        1        2        3        4
+--------+--------+--------+--------+--------+
| ...    | 0x04   | 2      | ...    | ...    |
+--------+--------+--------+--------+--------+
  UDH      IEI      IE       Dest     Source
  Length            Length   Port     Port

Legend:
UDH = user data header
IEI = information element identifier

]]></artwork>
          </figure>
	    </t>

 <t>
<figure title="Application Port Addressing Scheme (16-Bit Address)" anchor="addressing16">
            <artwork><![CDATA[
0        1        2        3        4        5        6
+--------+--------+--------+--------+--------+--------+--------+
| ...    | 0x05   | 4      |       ...       |       ...       |
+--------+--------+--------+--------+--------+--------+--------+
  UDH      IEI      IE       Dest              Source
  Length            Length   Port              Port
]]></artwork>
          </figure>
	    </t>

<t>The receiving side of the communication gets the source address from
   the originator address (TP-OA) field of the SMS-DELIVER TPDU.  This
   way, a unique 4-tuple identifying the security association can be
   reconstructed at both ends.  
(When replying to its DTLS peer, the
   sender will swap the TP-OA and destination address (TP-DA) parameters and the source and
   destination ports in the WDP.)</t>

</section> 

<section title="Timeout">

<t>If SMS-STATUS-REPORT messages are enabled, their receipt is not to be
   interpreted as the signal that the specific handshake message has
   been acted upon by the receiving party.  Therefore, it MUST NOT be
   taken into account by the DTLS timeout and retransmission function.</t>

<t>Handshake messages MUST carry a validity period (TP-VP parameter in a
   SMS-SUBMIT TPDU) that is not less than the current value of the
   retransmission timeout.  In order to avoid persisting messages in the
   network that will be discarded by the receiving party, handshake
   messages SHOULD carry a validity period that is the same as, or just
   slightly higher than, the current value of the retransmission
   timeout.</t>

</section>

</section> 

<section title="DTLS Record Layer Per-Packet Overhead">

<t><xref target="Record-Layer-Overhead"/> shows the overhead for the DTLS record layer for protecting 
data traffic when AES-128-CCM with an 8-octet Integrity Check Value (ICV) is used. </t>

<t>
<figure title="AES-128-CCM-8 DTLS Record Layer Per-Packet Overhead" anchor="Record-Layer-Overhead">
<artwork><![CDATA[
DTLS Record Layer Header................13 bytes
Nonce (Explicit).........................8 bytes
ICV..................................... 8 bytes
------------------------------------------------
Overhead................................29 bytes
------------------------------------------------
]]></artwork>
</figure>
</t>

<t>The DTLS record layer header has 13 octets and consists of: 
<list style="symbols">
<t>1-octet content type field,</t>
<t>2-octet version field,</t>
<t>2-octet epoch field,</t>
<t>6-octet sequence number, and</t>
<t>2-octet length field.</t>
</list> 
</t>

<t>The "nonce" input to the AEAD algorithm is exactly that of <xref target="RFC5288"/>, 
i.e., 12 bytes long. It consists of two values, namely a 4-octet salt and an 8-octet nonce_explicit:

<list style="style"> 
<t>The salt is the "implicit" part and is not sent in the packet. Instead, the salt is generated as part of the handshake process.</t>

<t>The nonce_explicit value is 8 octets long and it is chosen by the sender and carried in each TLS record. RFC 6655 <xref target="RFC6655"/> allows the nonce_explicit to be a sequence number 
or something else. This document makes this use more restrictive for use with DTLS: 
the 64-bit none_explicit value MUST be the 16-bit epoch concatenated with the 48-bit seq_num.
The sequence number component of the nonce_explicit field at the AES-CCM  
layer is an exact copy of the sequence number in the record layer header
field. This leads to a duplication of 8-bytes per record.
<vspace blankLines="1"/>
To avoid this 8-byte duplication, RFC 7400 <xref target="RFC7400"/> 
provides help with the use of the generic header compression technique 
for IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs). 
Note that this header compression technique is not available when DTLS 
is exchanged over transports that do not use IPv6 or 6LoWPAN, such as 
the SMS transport described in <xref target="DTLSoSMS"/> of this document. </t>
</list> 
</t> 
</section> 

<section title="DTLS Fragmentation">

<t>Section 4.2.3 of <xref target="RFC6347"/> advises DTLS implementations to not produce overlapping fragments. However, it requires receivers to be able to cope with them.  The need for the latter requisite is explained in Section 4.1.1.1 of <xref target="RFC6347"/>: accurate PMTU estimation may be traded for shorter handshake completion time.</t>

<t>In many cases, the cost of handling fragment overlaps has proved to be unaffordable for constrained implementations, particularly because of the increased complexity in buffer management.</t>

<t>In order to reduce the likelihood of producing different fragment sizes and consequent overlaps within the same handshake, this document RECOMMENDs:
<list style="symbols">
<t>clients (handshake initiators) to use reliable PMTU information for the intended destination; and</t>
<t>servers to mirror the fragment size selected by their clients.</t>
</list>
</t>

<t>The PMTU information comes from either a "fresh enough" discovery performed by the client <xref target="RFC1981"/> <xref target="RFC4821"/> or some other reliable out-of-band channel.</t>

</section>

  <section title="Acknowledgments" anchor="acknowledgements" numbered="no">

      <t>Thanks to Derek Atkins,
Paul Bakker, 
Olaf Bergmann, 
Carsten Bormann, 
Ben Campbell, 
Brian Carpenter, 
Robert Cragie, 
Spencer Dawkins,
Russ Housley, 
Rene Hummen,
Jayaraghavendran K,
Sye Loong Keoh,
Matthias Kovatsch,
Sandeep Kumar,
Barry Leiba,
Simon Lemay,
Alexey Melnikov,
Gabriel Montenegro,
Manuel Pegourie-Gonnard,
Akbar Rahman, 
Eric Rescorla,
Michael Richardson, 
Ludwig Seitz,
Zach Shelby, 
Michael StJohns,
Rene Struik, 
Tina Tsou, and 
Sean Turner
        for their helpful comments and discussions that have shaped the document.</t>
      <t>A big thanks also to Klaus Hartke, who wrote the initial draft version of this document.</t>

<t>Finally, we would like to thank our area director (Stephen Farrell) and our working group chairs (Zach Shelby and Dorothy Gellert) for their support.</t>
    </section>


  </back>

</rfc>
