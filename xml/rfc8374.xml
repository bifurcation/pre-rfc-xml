<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY RFC6793 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6793.xml">
<!ENTITY RFC4271 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4271.xml">
<!ENTITY RFC2439 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2439.xml">
<!ENTITY RFC4724 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4724.xml">
<!ENTITY RFC6090 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6090.xml">
<!ENTITY RFC6472 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6472.xml">
<!ENTITY RFC6480 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6480.xml">
<!ENTITY RFC6482 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6482.xml">
<!ENTITY RFC6483 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6483.xml">
<!ENTITY RFC6487 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6487.xml">
<!ENTITY RFC6811 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6811.xml">
<!ENTITY RFC7132 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7132.xml">
<!ENTITY RFC7353 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7353.xml">
<!ENTITY RFC8205 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8205.xml">
<!ENTITY RFC8207 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8207.xml">
<!ENTITY RFC8208 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8208.xml">
<!ENTITY RFC8097 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8097.xml">
<!ENTITY RFC7606 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7606.xml">
<!ENTITY RFC4760 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4760.xml">
<!ENTITY RFC8209 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8209.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="info" number="8374" submissionType="independent">

 <front>

   <title abbrev="BGPsec Design Choices">BGPsec Design Choices and Summary of Supporting Discussions</title>

    <author fullname="Kotikalapudi Sriram" initials="K." role="editor" surname="Sriram">
      <organization abbrev="USA NIST">USA National Institute of Standards and Technology</organization>
      <address>
         <postal>
          <street>100 Bureau Drive</street>
          <city>Gaithersburg</city>
          <region>MD</region>
          <code>20899</code>
          <country>United States of America</country>
        </postal>
        <email>ksriram@nist.gov</email>
      </address>
    </author>

   <date month="April" year="2018" />

   <keyword>Internet Routing Security</keyword>

<abstract>
<t>
This document captures the design rationale of the initial draft version
of what became RFC 8205 (the BGPsec protocol specification). The designers
needed to balance many competing factors, and this document lists the
decisions that were made in favor of or against each design choice.  This
document also presents brief summaries of the arguments that aided the
decision process.  Where appropriate, this document also provides brief notes
on design decisions that changed as the specification was reviewed and updated
by the IETF SIDR Working Group and that resulted in RFC 8205. These notes
highlight the differences and provide pointers to details and rationale
regarding those design changes.
</t>
</abstract>
 </front>

 <middle>
 <section title="Introduction">
  <t>The goal of the BGPsec effort is to enhance the security of BGP by
  enabling full Autonomous System (AS) path validation based on
  cryptographic principles. Standards work on route origin validation based
  on a Resource PKI (RPKI) is already completed or nearing completion in the
  IETF SIDR WG <xref target="RFC6480"/> <xref target="RFC6482"/>
  <xref target="RFC6483"/> <xref target="RFC6487"/> <xref target="RFC6811"/>.
  The BGPsec effort is aimed at taking advantage of the same RPKI
  infrastructure developed in the SIDR WG to add cryptographic signatures to
  BGP updates, so that routers can perform full AS path validation <xref
  target="RFC7132"></xref> <xref target="RFC7353"></xref> <xref
  target="RFC8205"></xref>. The BGPsec protocol specification,
  <xref target="RFC8205"></xref>, was published recently. The key high-level
  design goals of the BGPsec protocol are as follows <xref
  target="RFC7353"></xref>:
  </t>

<t><list style="symbols">
<t>
Rigorous path validation for all announced prefixes -- not merely showing
that a path is not impossible.
</t>
<t>
Incremental deployment capability -- no flag-day requirement for global
deployment. 
</t>
<t>
Protection of AS paths only in inter-domain routing (External BGP (eBGP)) --
not applicable to Internal BGP (iBGP) (or to IGPs).
</t>
<t>
Aiming for no increase in a provider's data exposure (e.g., not requiring
any disclosure of peering relations).
</t>
</list> </t>

<t>
This document provides design justifications for the initial draft version
of the BGPsec protocol specification
<xref target="BGPsec-Initial"></xref>. The designers needed to balance many
competing factors, and this document lists the decisions that were made in
favor of or against each design choice.  This document also presents brief
summaries of the discussions that weighed in on the pros and cons and aided
the decision process. Where appropriate, this document provides brief notes
(starting with "Note:") on design decisions that changed from the approach
taken in the initial draft version of the BGPsec protocol specification as the
specification was reviewed and updated by the IETF SIDR WG.  (These
design decisions resulted in RFC&nbsp;8205 <xref target="RFC8205"></xref>.)
The notes provide pointers to the details and&wj;/or discussions about the
design changes.
</t>

<t>
The design choices and discussions are presented in the following sections
(under the following eight broad categories, with many subtopics within
each category):</t>

<t><list style="symbols">
<t><xref target="sec-2"/> ("Creating Signatures and the Structure of BGPsec
  Update Messages")</t>
<t><xref target="sec-3"/> ("Withdrawal Protection")</t>
<t><xref target="sec-4"/> ("Signature Algorithms and Router Keys")</t>
<t><xref target="sec-5"/> ("Optimizations and Resource Sizing")</t>
<t><xref target="sec-6"/> ("Incremental Deployment and Negotiation of
  BGPsec")</t>
<t><xref target="sec-7"/> ("Interaction of BGPsec with Common BGP
  Features")</t>
<t><xref target="sec-8"/> ("BGPsec Validation")</t>
<t><xref target="sec-9"/> ("Operational Considerations")</t>
</list></t>

</section>

<section title="Creating Signatures and the Structure of BGPsec Update
 Messages" anchor="sec-2">
<section title="Origin Validation Using ROAs">

  <section title="Decision">
<t>
Route origin validation using Route Origin Authorizations (ROAs) <xref
target="RFC6482"></xref> <xref target="RFC6811"></xref> is necessary and
complements AS path attestation based on signed updates. Thus, the
BGPsec design makes use of the origin validation capability facilitated by the
ROAs in the RPKI.
</t>
<t>
Note: In the finalized BGPsec protocol specification <xref
target="RFC8205"></xref>, BGPsec is synonymous with cryptographic AS path
attestation. Origin validation and BGPsec (path signatures) are the two key
pieces of the SIDR WG solution for BGP security.
</t>
  </section>
  <section title="Discussion">
<t>
Route origin validation using RPKI constructs, as developed in the IETF
SIDR WG, is a necessary component of BGP security. It provides cryptographic
validation that the first&nbhy;hop AS is authorized to originate a route for
the prefix in question.
</t>
  </section>
  </section>

   <section anchor = "sign" title="Attributes Signed by an Originating AS">

   <section anchor = "oas1" title="Decision">
<t>
An originating AS will sign over the Network Layer Reachability Information
(NLRI) length, NLRI prefix, its own AS number (ASN), the next ASN, the
signature algorithm suite ID, and a signature Expire&nbsp;Time (see <xref
target="mitig"></xref>) for the update. The update signatures will be carried
in a new optional, non&nbhy;transitive BGP attribute.
</t>
<t>
Note: The finalized BGPsec protocol specification <xref
target="RFC8205"></xref> differs from the above. There is no mention in
RFC&nbsp;8205 of a signature Expire Time field in the BGPsec update. Further,
there are some additional details concerning attributes signed by the origin
AS that can be found in Figure&nbsp;8 in Section&nbsp;4.2 of RFC&nbsp;8205
<xref target="RFC8205"></xref>. In particular, the signed data also includes
the Address Family Identifier (AFI) as described in RFC&nbsp;8205. By adding
the AFI in the data covered by a signature, a specific security concern was
alleviated; see <xref target="Mandelberg1"></xref> (post to the SIDR WG
Mailing List) and the discussion thread that followed on the topic. The AFI is
obtained from the MP_REACH_NLRI attribute in the BGPsec update. As stated in
Section&nbsp;4.1 of RFC&nbsp;8205, a BGPsec update message "MUST use the
MP_REACH_NLRI attribute <xref target="RFC4760"></xref> to encode the prefix."
</t>
</section>

  <section anchor = "oas2" title="Discussion">
<t>
The next-hop ASN is included in the data covered by the signature. Without
this inclusion, the AS path cannot be secured; for example, the path can be
shortened (by a MITM (man in the middle)) without being detected.
</t>
<t>
It was decided that only the originating AS needs to insert a signature
Expire Time in the update, as it is the originator of the route. The origin AS
also will re&nbhy;originate, i.e., beacon, the update prior to the Expire Time
of the advertisement (see <xref target="mitig"></xref>). (For an explanation
of why upstream ASes do not insert their respective signature Expire Times,
please see <xref target="ETdiscuss"></xref>.)
</t>
<t>
Note: Expire Time and beaconing were eventually replaced by router key
rollover. The BGPsec protocol <xref target="RFC8205"></xref> is expected to
make use of router key rollover to mitigate replay attacks and withdrawal
suppression <xref target="BGPsec-Rollover"></xref>
<xref target="Replay-Protection"></xref>.
</t>
<t>
It was decided that each signed update would include only one NLRI prefix.
If more than one NLRI prefix were included and an upstream AS elected to 
propagate the advertisement for a subset of the prefixes, then the signature(s)
on the update would break (see
Sections&nbsp;<xref target="pack" format="counter"></xref> and
<xref target="spp" format="counter"></xref>). If a mechanism were employed to
preserve prefixes that were dropped, this would reveal information to
subsequent ASes that is not revealed in normal BGP operation. Thus, a
trade&nbhy;off was made to preserve the level of route information exposure
that is intrinsic to BGP over the performance hit implied by limiting each
update to carry only one prefix.
</t>
<t>
The signature data is carried in an optional, non-transitive BGP
attribute. The attribute is optional because this is the standard mechanism
available in BGP to propagate new types of data. It was decided that the
attribute should be non&nbhy;transitive because of concern about the impact of
sending the (potentially large) signatures to routers that don't understand
them. Also, if a router that does not understand BGPsec somehow gets an update
message with path signatures (i.e., the update includes the BGPsec_PATH
attribute (see Section 3 of RFC 8205)), then it would be undesirable for that
router to forward the update to all of its neighbors, especially those who
do not understand BGPsec and may choke if they receive many updates with large
optional BGP attributes. It is envisioned that BGPsec and traditional BGP will
coexist while BGPsec is deployed incrementally.
</t>
</section>

  </section>
 

  <section anchor="cover" title="Attributes Signed by an Upstream AS">
<t>
In the context of BGPsec and throughout this document, an "upstream AS" simply
refers to an AS that is further along in an AS path (the origin AS being the
nearest to a prefix). In principle, an AS that is upstream from an originating
AS would digitally sign the combined information, including the NLRI length,
NLRI prefix, AS path, next ASN, signature algorithm suite ID, and Expire
Time. There are multiple choices regarding what is signed by an upstream AS,
as follows:</t>

<t><list style="symbols">
<t>Method 1: The signature protects the combination of the NLRI length,
NLRI prefix, AS path, next ASN, signature algorithm suite ID, and Expire Time,
</t>
<t>Method 2: The signature protects just the combination of the previous
signature (i.e., the signature of the neighbor AS who forwarded the update)
and the next ASN, or
</t>
<t>Method 3: The signature protects everything that was received from the
preceding AS plus the next (i.e., target) ASN; thus, ASi signs over the NLRI
length, NLRI prefix, signature algorithm suite ID, Expire Time, {ASi, AS(i-1),
AS(i-2), ..., AS2, AS1}, AS(i+1) (i.e., the next ASN), and {Sig(i-1), Sig(i-2),
..., Sig2, Sig1}.</t>
</list></t>

<t>
Note: Please see the notes in
Sections&nbsp;<xref target="oas1" format="counter"></xref> and
<xref target="oas2" format="counter"></xref> regarding the elimination of
the Expire Time field in the finalized BGPsec protocol specification
<xref target="RFC8205"></xref>.
</t>
   <section title="Decision">
<t>
It was decided that Method 2 will be used. Please see <xref
target="BGPsec-Initial"></xref> for additional protocol details
and syntax.  
</t>

<t>
Note: The finalized BGPsec protocol specification <xref
target="RFC8205"></xref> essentially uses Method 3 (except for Expire
Time). Additional details concerning attributes signed by an upstream AS can
be found in Figure&nbsp;8 in Section&nbsp;4.2 of RFC&nbsp;8205 <xref
target="RFC8205"></xref>. The decision to go with Method 3 (with suitable
additions to the data signed) was motivated by a security concern that was
associated with Method 2; see <xref target="Mandelberg2"></xref>
(post to the SIDR WG Mailing List) and the discussion thread that followed on
the topic. Also, there is a strong rationale for the sequence of octets to be
hashed (as shown in Figure&nbsp;8 in Section&nbsp;4.2 of RFC&nbsp;8205);
this sequencing of data is motivated by implementation efficiency
considerations. See <xref target="Borchert"></xref> (post to the SIDR WG
Mailing List) for an explanation.
</t>
</section>

  <section title="Discussion">
<t>
The rationale for this choice (Method 2) was as follows. Signatures are
performed over hash blocks. When the number of bytes to be signed exceeds one
hash block, the remaining bytes will overflow into a second hash block,
resulting in a performance penalty. So, it is advantageous to minimize the
number of bytes being hashed. Also, an analysis of the three options noted
above did not identify any vulnerabilities associated with this approach.
</t>
</section>
 </section>

<section anchor = "notsign" title="Attributes That Are Not Signed">
<section title="Decision">
<t>
Any attributes other than those identified in
Sections&nbsp;<xref target="sign" format="counter"></xref> and
<xref target="cover" format="counter"></xref> are not signed. Examples of such
attributes include the community attribute, the NO-EXPORT attribute, and
Local_Pref.
</t>
</section>
<section title="Discussion">
<t>
Any of the above-mentioned attributes that are not signed are viewed as local
(e.g., do not need to propagate beyond the next hop) or lack clear security
needs. NO&nbhy;EXPORT is sent over a secured next&nbsp;hop and does not need
signing. The BGPsec design should work with any transport-layer
protections. It is well understood that the transport layer must be protected 
hop by hop (if only to prevent malicious session termination).
</t>
</section>
</section>

<section anchor="act" title="Receiving Router Actions">

 <section title="Decision">
<t>
The following example describes the expected router actions on receipt of a
signed update. Consider an update that was originated by AS1 with NLRI
prefix&nbsp;p and has traversed the AS path [AS(i-1) AS(i-2) ... AS2 AS1]
before arriving at ASi. Let the Expire Time (inserted by AS1) for the
signature in this update be denoted as Te. Let AlgID represent the ID of the
signature algorithm suite that is in use. The update is to be processed at ASi
and possibly forwarded to AS(i+1). Let the attestations (signatures) inserted
by each router in the AS path be denoted by Sig1, Sig2, ..., Sig(i-2), and
Sig(i-1) corresponding to AS1, AS2, ..., AS(i-2), and AS(i-1), respectively.
</t>
<t>
The method (Method 2 in <xref target="cover"></xref>) selected for signing
requires a receiving router in ASi to perform the following actions:
</t>
<t><list style="symbols">
<t>
Validate the route origin pair (p, AS1) by performing a ROA match.</t>
<t>
Verify that Te is greater than the clock time at the router performing these
checks.</t>
 <t>
Check Sig1 with inputs {NLRI length, p, AlgID, Te, AS1, AS2}.</t>
 <t>
Check Sig2 with inputs {Sig1, AS3}.</t>
 <t>
Check Sig3 with inputs {Sig2, AS4}.</t>
 <t>... </t>
<t> ...</t>
<t>
Check Sig(i-2) with inputs {Sig(i-3), AS(i-1)}.</t>
 <t>
Check Sig(i-1) with inputs {Sig(i-2), ASi}.</t>
<t>
If the route that has been verified is selected as the best path (for
prefix p), then generate Sig(i) with inputs {Sig(i-1), AS(i+1)},
and generate an update including Sig(i) to AS(i+1). </t> 

</list> </t>

<t>
Note: The above description of BGPsec update validation and forwarding differs
in its details from the published BGPsec protocol specification <xref
target="RFC8205"></xref>. Please see Sections 4 and 5 of <xref
target="RFC8205"></xref>.
</t>
</section>
<section title= "Discussion">
<t>
See <xref target="seqn"></xref> for suggestions regarding efficient sequencing
of BGPsec validation processing in a receiving router. Some or all of the
validation actions may be performed by an off-board server (see <xref
target="offbd"></xref>).
</t>
</section>
</section>

<section title="Prepending of ASes in AS Path">
 <section title="Decision">
<t>
Prepending will be allowed. Prepending is defined as including more than one
instance of the AS number (ASN) of the router that is signing the update.
</t>
<t>
Note: The finalized BGPsec protocol specification
<xref target="RFC8205"></xref> uses a pCount field associated with each AS in
the path to indicate the number of prepends for that AS (see Figure&nbsp;5 in
Section&nbsp;3.1 of <xref target="RFC8205"></xref>).
</t>
</section>
<section title="Discussion">
<t>
The initial version <xref target="BGPsec-Initial"></xref> of the
BGPsec specification calls for a signature to be associated with each prepended
AS. The optimization of having just one signature for multiple prepended ASes
was pursued later. The pCount field is now used to represent AS prepends;
see Section&nbsp;3.1 in RFC&nbsp;8205.</t>
</section>
</section>

<section title="RPKI Data That Needs to Be Included in Updates">
<section title="Decision">
<t>
Concerning the inclusion of RPKI data in an update, it was decided that only
the Subject Key Identifier (SKI) of the router certificate must be included in
a signed update. This information identifies the router certificate, based on
the SKI generation criteria defined in <xref target="RFC6487"></xref>. 
</t>
</section>
<section title="Discussion">
<t>
Whether or not each router public key certificate should be included in a
signed update was discussed. Inclusion of this information might be helpful
for routers that do not have access to RPKI servers or temporarily lose
connectivity to them. It is safe to assume that in the majority of network
environments, intermittent connectivity would not be a problem.  So, it is best
to avoid this complexity, because the majority of the use environments do not
have connectivity constraints. Because the SKI of a router certificate is a
hash of the public key of that certificate, it suffices to select the public
key from that certificate. This design assumes that each BGPsec router has
access to a cache containing the relevant data from (validated) router
certificates.
</t>
</section>
</section>
</section>
<section title="Withdrawal Protection" anchor="sec-3">

<section anchor="sigw" title="Withdrawals Not Signed">
 <section title="Decision">
<t>
Withdrawals are not signed.
</t>
</section>
<section title="Discussion">
<t>
In the current BGP protocol, any AS can withdraw, at any time, any prefix it
previously announced.  The rationale for not signing withdrawals is that
BGPsec assumes the use of transport security between neighboring BGPsec
routers. Thus, no external entity can inject an update that withdraws a route
or replay a previously transmitted update containing a withdrawal. Because the
rationale for withdrawing a route is not visible to a neighboring BGPsec
router, there are residual vulnerabilities associated with withdrawals. For
example, a router that advertised a (valid) route may fail to withdraw that
route when it is no longer viable. A router also might re&nbhy;advertise a
route that it previously withdrew, before the route is again viable. This
latter vulnerability is mitigated by the Expire Time associated with the
origin AS's signature (see <xref target="mitig"></xref>).
</t>
<t>
Repeated withdrawals and announcements for a prefix can run up the
BGP Route Flap Damping (RFD) penalty <xref target="RFC2439"/> and may result
in unreachability for that prefix at upstream routers. But what can the
attacker gain from doing so? This phenomenon is intrinsic to the design and
operation of RFD.
</t>
</section>
</section>

<section anchor="mitig" title="Signature Expire Time for Withdrawal Protection (a.k.a. Mitigation of Replay Attacks)">
 <section title="Decision" anchor="sec3.2.1">
<t>
Note: As mentioned earlier (<xref target="oas2"></xref>), the
Expire&nbsp;Time approach to mitigation of replay attacks and withdrawal
suppression was subsequently changed to an approach based on router key
rollover <xref target="BGPsec-Rollover"></xref>
<xref target="Replay-Protection"></xref>.
</t>
<t>
Only the originating AS inserts a signature Expire Time in the update; all
other ASes along an AS path do not insert Expire Times associated with their
respective signatures.  Further, the originating AS will re&nbhy;originate a
route sufficiently in advance of the Expire Time of its signature so that
other ASes along an AS path will typically receive the re&nbhy;originated
route well ahead of the current Expire Time for that route.
</t>
<t>
It is recommended that the duration of the signature Expire Time be on the
order of days (preferably), but it may be on the order of hours (about 4 to
8&nbsp;hours) in some cases on the basis of perceived need for extra
protection from replay attacks (i.e., where extra replay protection is
perceived to be critical).
</t>
<t>
Each AS should stagger the Expire Time values in the routes it originates.
Re&nbhy;origination will be done, say, at time Tb after origination or the
last re&nbhy;origination, where Tb will equal a certain percentage of the
Expire Time, Te (for example, Tb = 0.75 x Te).  The percentage will
be configurable. Additional guidance can be provided via an operational
considerations document later. Further, the actual re&nbhy;origination time
should be jittered with a uniform random distribution over a short interval
{Tb1, Tb2} centered at Tb.
</t>
<t>
It is also recommended that a receiving BGPsec router detect that the
only attribute change in an announcement (relative to the current best path)
is the Expire Time (besides, of course, the signatures). In that case,
assuming that the update is found valid, the route processor should not
re&nbhy;announce the route to non&nbhy;BGPsec peers. (It should sign and
re&nbhy;announce the route to BGPsec speakers only.) This procedure will
reduce BGP chattiness for the non&nbhy;BGPsec border routers.
</t>
</section>
<section anchor="ETdiscuss" title="Discussion">
<t>
Mitigation of BGPsec update replay attacks can be thought of as 
protection against malicious re&nbhy;advertisements of withdrawn routes.  If 
each AS along a path were to insert its own signature Expire Time, then there
would be much additional BGP chattiness and an increase in BGP processing load
due to the need to detect and react to multiple (possibly redundant) signature
Expire Times.  Furthermore, there would be no extra benefit from the point of
view of mitigation of replay attacks as compared to having a single Expire Time
corresponding to the signature of the originating AS.
</t>
<t>
As noted in <xref target="sec3.2.1"/>, the recommended Expire Time value is on
the order of days, but 4 to 8&nbsp;hours may be used in some cases on the
basis of perceived need for extra protection from replay attacks. Thus,
different ASes may choose different values based on the perceived need to
protect against malicious route replays. (A shorter Expire Time reduces the
window during which an AS can maliciously replay the route. However, shorter
Expire Time values cause routes to be refreshed more often, thus causing
more BGP chatter.) Even a 4&nbhy;hour duration seems long enough to keep the
re&nbhy;origination workload manageable.  For example, if 500K routes are
re&nbhy;originated every 4&nbsp;hours, it amounts to an increase in BGP update
load of 35 updates per second; this can be considered reasonable. However,
further analysis is needed to confirm these recommendations. 
</t>
<t>
As stated in <xref target="sec3.2.1"/>, the originating AS will
re&nbhy;originate a route sufficiently in advance of its Expire Time. What is
considered "sufficiently in advance"? To answer this question, modeling should
be performed to determine the 95th&nbhy;percentile convergence time of update
propagation in a BGPsec-enabled Internet.
</t>
<t>
Each BGPsec router should stagger the Expire Time values in the updates it
originates, especially during table dumps to a neighbor or during its own
recovery from a BGP session failure. By doing this, the re&nbhy;origination
(i.e., beaconing) workload at the router will be dispersed.
</t>
</section>
</section>

<section title="Should Route Expire Time be Communicated in a Separate Message?">
 <section title="Decision">
<t>
The idea of sending a new signature Expire Time in a special message (rather
than retransmitting the entire update with signatures) was considered.
However, the decision was made to not do this. Re&nbhy;origination to
communicate a new signature Expire Time will be done by propagating a
normal update message; no special type of message will be required.
</t>
</section>
<section title="Discussion">
<t>
It was suggested that if the re-beaconing of the signature Expire&nbsp;Time
is carried in a separate special message, then any processing load related to
the update may be reduced. But it was recognized that such a re&nbhy;beaconing
message by necessity entails AS path and prefix information and, hence, cannot
be separated from the update.
</t>
<t>
It was observed that at the edge of the Internet, there are frequent updates
that may result from such simple situations as a BGP session being switched
from one interface to another (e.g., from primary to backup) between two
peering ASes (e.g., customer and provider). With traditional BGP, these
updates do not propagate beyond the two ASes involved. But with BGPsec, the
customer AS will put in a new signature Expire Time each time such an event
happens; hence, the update will need to propagate throughout the Internet
(limited only by the process of best-path selection). It was accepted that
this cost of added churn will be unavoidable.
</t>
</section>
</section>

<section anchor="rebcnrfd" title="Effect of Expire Time Updates in BGPsec on RFD">
 <section title="Decision">
<t>
With regard to the RFD protocol <xref target="RFC2439"></xref> <xref
target="JunOS"></xref> <xref target="CiscoIOS"></xref>, no differential
treatment is required for Expire&nbhy;Time-triggered (re&nbhy;beaconed) BGPsec
updates.
</t>
<t>
However, it was noted that it would be preferable if these updates
did not cause route churn (and perhaps did not even require any
RFD&nbhy;related processing), since they are identical except for the change
in the Expire Time value. This can be accomplished by not assigning an RFD
penalty to Expire&nbhy;Time-triggered updates. If the community agrees, this
could be accommodated, but a change to the BGP-RFD protocol will be
required.</t>
</section>
<section title="Discussion">

<t>
To summarize, this decision is supported by the following observations:</t>

<t><list style="numbers">
<t>Expire-Time-triggered updates are generally not preceded by withdrawals; hence, the path hunting and associated RFD exacerbation <xref
target="Mao02"></xref> <xref target="RIPE580"></xref> problems are not
anticipated.</t>
<t>Such updates would not normally change the best path (unless another
concurrent event impacts the best path).</t>
<t>Expire-Time-triggered updates would have a negligible impact on RFD penalty
accumulation because the re&nbhy;advertisement interval is much longer
relative to the half-time of RFD penalty decay.</t>
</list></t>

<t>Elaborating further on the third observation above, it may be noted that the
re&nbhy;advertisements (i.e., beacons) of a route for a given address prefix
from a given peer will be received at intervals of several hours (see
<xref target="mitig"></xref>). During that time period, any incremental
contribution to the RFD penalty due to an Expire-Time-triggered update
would decay sufficiently to have negligible (if any) impact on damping the
address prefix in question.</t>

<t>Additional details regarding this analysis and justification are as
follows:
</t>
<t>The frequency with which RFD penalty increments may be triggered for a
given prefix from a given peer is the same as the re&nbhy;beaconing frequency
for that prefix from its origin AS. The re&nbhy;beaconing frequency is on the
order of once every several hours (see <xref target="mitig"></xref>). The
incremental RFD penalty assigned to a prefix due to a re&nbhy;beaconed update
varies, depending on the implementation. For example, it appears that the
JunOS implementation <xref target="JunOS"></xref> would assign a penalty of
1000 or 500, depending on whether the re&nbhy;beaconed update is regarded as a
re&nbhy;advertisement or an attribute change, respectively. Normally, a
re&nbhy;beaconed update would be treated as an attribute change. On the other
hand, the Cisco implementation <xref target="CiscoIOS"></xref> assigns an RFD
penalty only in the case of an actual flap (i.e., a route is available, then
unavailable, or vice versa). So, it appears that Cisco's implementation of RFD
would not assign any penalty for a re&nbhy;beaconed update (i.e., a route was
already advertised previously and was not withdrawn, and the re&nbhy;beaconed
update is merely updating the Expire Time attribute). Even if one assumes that
an RFD penalty of 500 is assigned (corresponding to an attribute change
according to the JunOS RFD implementation), it can be illustrated that the
incremental effect it would have on damping the prefix in question would be
negligible: the half&nbhy;time of RFD penalty decay is normally set to
15&nbsp;minutes, whereas the re&nbhy;beaconing frequency is on the order of
once every several hours. An incremental penalty of 500 would decay to 31.25 in
1&nbsp;hour, 0.12 in 2&nbsp;hours, and 3x10^(-5) in 3&nbsp;hours. It may also
be noted that the threshold for route suppression is 3000 in JunOS and 2000 in
Cisco&nbsp;IOS. Based on the foregoing analysis, it may be concluded that
routine re&nbhy;beaconing by itself would not result in RFD suppression of
routes in the BGPsec protocol.
</t>
</section>
</section>
</section>

<section title="Signature Algorithms and Router Keys" anchor="sec-4">

<section anchor="sigalg" title="Signature Algorithms">

 <section title="Decision">
<t>
Initially, the Elliptic Curve Digital Signature Algorithm (ECDSA) with
curve P-256 and SHA-256 will be used for generating BGPsec path signatures.
One other signature algorithm, e.g., RSA-2048, will also be used during
prototyping and testing. The use of a second signature algorithm is needed to
verify the ability of the BGPsec implementations to change from a current
algorithm to the next algorithm.
</t>
<t>
Note: The BGPsec cryptographic algorithms document <xref
target="RFC8208"></xref> specifies only the ECDSA with curve P-256 and SHA-256.
</t>
</section>
<section title="Discussion">
<t>
Initially, the RSA-2048 algorithm for BGPsec update signatures was
considered as a choice because it is being used ubiquitously in the RPKI
system. However, the use of ECDSA P-256 was decided upon because it yields a
smaller signature size; hence, the update size and (in turn) the RIB size
needed in BGPsec routers would be much smaller <xref target="RIB_size"></xref>.
</t>
<t>  
Using two different signature algorithms (e.g., ECDSA P-256 and
RSA&nbhy;2048) to test the transition from one algorithm to the other will
increase confidence in prototype implementations.
</t>
<t>
Optimizations and specialized algorithms (e.g., for speedups) built
on Elliptic Curve Cryptography (ECC) algorithms may have active IPR
(intellectual property rights), but at the time of publication of
this document no IPR had been disclosed to the IETF for the basic
(unoptimized) algorithms. (To understand this better,
<xref target="RFC6090"></xref> can be useful as a starting point.)</t>
<t>
Note: Recently, even open-source implementations have incorporated certain
cryptographic optimizations and demonstrated significant performance speedup
<xref target="Gueron"></xref>. Researchers continue to devote significant
effort toward demonstrating substantial speedup for the ECDSA as part of BGPsec
implementations <xref target="Mehmet1"></xref> <xref target="Mehmet2"></xref>.
</t>
</section>
</section>

<section anchor="agil" title="Agility of Signature Algorithms">
 <section title="Decision">
<t>
During the transition period from one algorithm (i.e., the current algorithm)
to the next (new) algorithm, the updates will carry two sets of signatures
(i.e., two Signature_Blocks), one corresponding to each
algorithm. Each Signature_Block will be preceded by its type&nbhy;length
field and an algorithm suite identifier. A BGPsec speaker that has been
upgraded to handle the new algorithm should validate both
Signature_Blocks and then add its corresponding signature to each
Signature_Block for forwarding the update to the next AS. A BGPsec
speaker that has not been upgraded to handle the new algorithm will strip off
the Signature_Block of the new algorithm and then will forward the
update after adding its own signature to the Signature_Block of the
current algorithm.
</t>
<t>
It was decided that there will be at most two Signature_Blocks per
update.
</t>
<t>
Note: BGPsec path signatures are carried in the Signature_Block, which is an
attribute contained in the BGPsec_PATH attribute (see Section&nbsp;3.2 in
<xref target="RFC8205"></xref>).  The algorithm agility scheme described in
the published BGPsec protocol specification is consistent with the above;
see Section&nbsp;6.1 of <xref target="RFC8205"></xref>.
</t>
</section>
<section title="Discussion">
<t>
A length field in the Signature_Block allows for delineation of the two
signature blocks. Hence, a BGPsec router that doesn't know about a particular
algorithm suite (and, hence, doesn't know how long signatures were for that
algorithm suite) could still skip over the corresponding
Signature_Block when parsing the message.
</t>
<t>   
The overlap period between the two algorithms is expected to last
2&nbsp;to 4&nbsp;years. The RIB memory and cryptographic processing capacity
will have to be sized to cope with such overlap periods when updates would
contain two sets of signatures <xref target="RIB_size"></xref>.
</t>
<t>
The lifetime of a signature algorithm is anticipated to be much longer than the
duration of a transition period from the current algorithm to a new algorithm.
It is fully expected that all ASes will have converted to the required new
algorithm within a certain amount of time that is much shorter than
the interval in which a subsequent newer algorithm may be
investigated and standardized for BGPsec.  Hence, the need for more
than two Signature_Blocks per update is not envisioned.
</t>
</section>
</section>

<section anchor="aggr" title="Sequential Aggregate Signatures">
 <section title="Decision">
<t>
There is currently weak or no support for the Sequential Aggregate Signature
(SAS) approach. Please see <xref target="sec-4.3.2"/> for a brief
description of what the SAS is and what its pros and cons are.
</t>
</section>
<section title="Discussion" anchor="sec-4.3.2">
<t>
In the SAS method, there would be only one (aggregated) signature per
signature block, irrespective of the number of AS hops. For example, ASn
(the nth&nbsp;AS) takes as input the signatures of all previous ASes [AS1, ...,
AS(n-1)] and produces a single composite signature. This composite signature
has the property that a recipient who has the public keys for AS1, ..., ASn
can verify (using only the single composite signature) that all of the ASes
actually signed the message. The SAS could potentially result in savings in
bandwidth and in Protocol Data Unit (PDU) size, and maybe in RIB size, but
the signature generation and validation costs will be higher as compared
to one signature per AS hop.
</t>
<t>
SAS schemes exist in the literature, typically based on RSA or its equivalent.
For a SAS with RSA and for the cryptographic strength needed for BGPsec
signatures, a 2048-bit signature size (RSA-2048) would be required.
However, without a SAS, the ECDSA with a 512-bit signature (256-bit key)
would suffice for equivalent cryptographic strength.  The larger signature
size of RSA used with a SAS undermines the advantages of the SAS, because
the average hop count, i.e., the number of ASes, for a route is about 3.8.
In the end, it may turn out that the SAS has more complexity and does not
provide sufficient savings in PDU size or RIB size to merit its use.  Further
exploration of this is needed to better understand SAS properties and
applicability for BGPsec. There is also a concern that the SAS is not a
time-tested cryptographic technique, and thus its adoption is potentially
risky.
</t>
</section>
</section

><section anchor="protextn" title="Protocol Extensibility">
<t>
There is clearly a need to specify a transition path from a current
protocol specification to a new version.  When changes to the
processing of the BGPsec path signatures are required, a new version of
BGPsec will be required. Examples of this include changes to the data
that is protected by the BGPsec signatures or adoption of a signature
algorithm in which the number of signatures in the signature block may not
correspond to one signature per AS in the AS&nbsp;path (e.g., aggregate
signatures).
</t>

<section title="Decision">
<t>
This protocol-version transition mechanism is analogous to the algorithm
transition discussed in <xref target="agil"></xref>. During the transition
period from one protocol version (i.e., the current version) to the next (new)
version, updates will carry two sets of signatures (i.e., two
Signature_Blocks), one corresponding to each version. A
protocol-version identifier is associated with each
Signature_Block. Hence, each Signature_Block will be
preceded by its type&nbhy;length field and a protocol-version identifier. A
BGPsec speaker that has been upgraded to handle the new version should
validate both Signature_Blocks and then add its corresponding signature to each
Signature_Block for forwarding the update to the next AS. A BGPsec
speaker that has not been upgraded to handle the new protocol version will
strip off the Signature_Block of the new version and then will
forward the update with an attachment of its own signature to the
Signature_Block of the current version. 
</t>
<t>
Note: The details of protocol
extensibility (i.e., transition to a new version of BGPsec) in the published
BGPsec protocol specification (see Section&nbsp;6.3 in <xref
target="RFC8205"></xref>) differ somewhat from the above. In particular, the
protocol-version identifier is not part of the BGPsec update. Instead, it is
negotiated during the BGPsec capability exchange portion of BGPsec session
negotiation.
</t>
</section>
<section title="Discussion">
<t>
In the case that a change to BGPsec is deemed desirable, it is expected that a
subsequent version of BGPsec would be created and that this version of BGPsec
would specify a new BGP path attribute (let's call it "BGPsec_PATH_TWO")
that is designed to accommodate the desired changes to BGPsec. At this point,
a transition would begin that is analogous to the algorithm transition
discussed in <xref target="agil"></xref>.  During the transition period, all
BGPsec speakers will simultaneously include both the BGPsec_PATH (current)
attribute (see Section&nbsp;3 of RFC&nbsp;8205) and the new BGPsec_PATH_TWO
attribute.  Once the transition is complete, the use of BGPsec_PATH could then
be deprecated, at which point BGPsec speakers will include only the new
BGPsec_PATH_TWO attribute. Such a process could facilitate a transition
to new BGPsec semantics in a backwards-compatible fashion.
</t>
</section>
</section>

<section anchor="rogue" title="Key per Router (Rogue Router Problem)">
 <section title="Decision">
<t>
Within each AS, each individual BGPsec router can have a unique pair of
private and public keys <xref target="RFC8207"></xref>.
</t>
</section>
<section title="Discussion">
<t>
Given a unique key pair per router, if a router is compromised, its key pair
can be revoked independently, without disrupting the other routers in the AS.
Each per-router key pair will be represented in an end-entity certificate 
issued under the certification authority (CA) certificate of the AS.  The
Subject Key Identifier (SKI) in the signature points to the router certificate
(and thus the unique public key) of the router that affixed its signature, so
that a validating router can reliably identify the public key to use for
signature verification.
</t>
</section>
</section>

<section title="Router ID">
 <section title="Decision">
<t>
The router certificate subject name will be the string "ROUTER" followed by a
decimal representation of a 4-byte ASN followed by the router ID.
(Note: The details are specified in Section&nbsp;3.1 in
<xref target="RFC8209"/>.)
</t>
</section>

<section title="Discussion">
<t>
Every X.509 certificate requires a subject name <xref target="RFC6487"/>.
The stylized subject name adopted here is intended to facilitate debugging by
including the ASN and router ID.
</t>
</section>
</section>
</section>

<section title="Optimizations and Resource Sizing" anchor="sec-5">
<section anchor="pack" title="Update Packing and Repacking">
<t>
With traditional BGP <xref target="RFC4271"></xref>, an originating BGP router
normally packs multiple prefix announcements into one update if the prefixes
all share the same BGP attributes. When an upstream BGP router forwards eBGP
updates to its peers, it can also pack multiple prefixes (based on the
shared AS path and attributes) into one update. The update propagated by the
upstream BGP router may include only a subset of the prefixes that were packed
in a received update.
</t>
 <section title="Decision">
<t>
Each update contains exactly one prefix. This avoids a level of complexity
that would otherwise be inevitable if the origin had packed and signed
multiple prefixes in an update and an upstream AS decided to propagate an
update containing only a subset of the prefixes in that update. BGPsec
recommendations regarding packing and repacking may be revisited when
optimizations are considered in the future.
</t>
</section>
<section title="Discussion">
<t>
Currently, with traditional BGP, there are, on average, approximately
four&nbsp;prefixes announced per update <xref target="RIB_size"></xref>. So,
the number of BGP updates (carrying announcements) is about four&nbsp;times
fewer, on average, as compared to the number of prefixes announced.</t>
<t>
The current decision is to include only one prefix per secured update (see
<xref target="oas2"/>). When optimizations are considered in the future, the
possibility of packing multiple prefixes into an update can also be
considered.  (Please see <xref target="spp"></xref> for a discussion of
signature per prefix vs.&nbsp;signature per update.) Repacking could be
performed if signatures were generated on a per&nbhy;prefix basis. However,
one problem regarding this approach -- multiple prefixes in a BGP update but
with a separate signature for each prefix -- is that the resulting BGP update
violates the basic definition of a BGP update: the different prefixes will
have different signatures and Expire Time attributes, while a BGP update (by
definition) must have the same set of shared attributes for all prefixes it
carries.
</t>
</section>
</section>

<section anchor="spp" title="Signature per Prefix vs. Signature per Update">
 <section title="Decision">
<t>
The initial design calls for including exactly one prefix per update;
hence, there is only one signature in each secured update (modulo algorithm
transition conditions).
</t>
</section>
<section title="Discussion">
<t>
Some notes to assist in future optimization discussions follow:</t>

<t>In the general case of one signature per update, multiple prefixes may be
signed with one signature together with their shared AS path, next ASN, and
Expire Time. If the "signature per update" technique is used, then there are
potential savings in update PDU size as well as RIB memory size. But if there
are any changes made to the announced prefix set along the AS path, then the
AS where the change occurs would need to insert an Explicit Path Attribute
(EPA) <xref target="Secure-BGP"></xref>. The EPA conveys information regarding
what the prefix set contained prior to the change. There would be one EPA for
each AS that made such a modification, and there would be a way to associate
each EPA with its corresponding AS. This enables an upstream AS to know and
verify what was announced and signed by prior ASes in the AS path (in spite of
changes made to the announced prefix set along the way). The EPA adds
complexity to processing (signature generation and validation); further
increases the size of updates and, thus, of the RIB; and exposes data to
downstream ASes that would not otherwise be exposed. Not all of the pros and
cons of packing and repacking in the context of signature per prefix
vs.&nbsp;signature per update (with packing) have been evaluated.  But the
current recommendation is for having only one prefix per update (no packing),
so there is no need for the EPA.
</t>
</section>
</section>

<section anchor="pdu" title="Maximum BGPsec Update PDU Size">
<t>
The current BGP update message PDU size is limited to 4096 bytes <xref
target="RFC4271"></xref>. The question was raised as to whether or not
BGPsec would require a larger update PDU size. 
</t>
 <section title="Decision">
<t>
The current thinking is that the maximum PDU size should be increased to
64&nbsp;KB <xref target="BGP-Ext-Msg"></xref> so that there is sufficient room
to accommodate two Signature_Blocks (i.e., one block with a current
algorithm and another block with a new signature algorithm during a future
transition period) for long AS paths.
</t>

<t>
Note: RFC 8205 states the following: "All BGPsec UPDATE messages MUST conform
to BGP's maximum message size. If the resulting message exceeds the maximum
message size, then the guidelines in Section&nbsp;9.2 of RFC&nbsp;4271 <xref
target="RFC4271"></xref> MUST be followed."
</t>

</section>
<section title="Discussion">
<t>
The current maximum message size for BGP updates is 4096 octets.
An effort is underway in the IETF to extend it to a larger size
<xref target="BGP-Ext-Msg"></xref>. BGPsec will conform to whatever
maximum message size is available for BGP while adhering to the
guidelines in Section&nbsp;9.2 of RFC&nbsp;4271 <xref
target="RFC4271"></xref>.
</t>
<t>
Note: Estimates for the average and maximum sizes anticipated for BGPsec
update messages are provided in <xref target="MsgSize"></xref>.
</t>
</section>
</section>

<section anchor="susp" title="Temporary Suspension of Attestations and Validations">
 <section title="Decision">
<t>
If a BGPsec-capable router needs to temporarily suspend/defer signing and/or
validation of BGPsec updates during periods of route processor overload, the
router may do so even though such suspension/deferment is not desirable; the
specification does not forbid it. Following any temporary suspension, the
router should subsequently send signed updates corresponding to the updates
for which validation and signing were skipped. The router also may choose to
skip only validation but still sign and forward updates during periods of
congestion.
</t>
</section>
<section title="Discussion">
<t>
In some situations, a BGPsec router may be unable to keep up with the workload
of performing signing and/or validation. This can happen, for example, during
BGP session recovery when a router has to send the entire routing table to a
recovering router in a neighboring AS (see <xref
target="CPUworkload"></xref>). So, it is possible that a BGPsec router
temporarily pauses performing the validation or signing of updates. When the
workload eases, the BGPsec router should clear the validation or signing
backlog and send signed updates corresponding to the updates for which
validation and signing were skipped. During periods of overload, the router
may simply send unsigned updates (with signatures dropped) or may sign and
forward the updates with signatures (even though the router itself has not yet
verified the signatures it received).
</t>
<t>
A BGPsec-capable AS may request (out of band) that a BGPsec-capable peer AS
never downgrade a signed update to an unsigned update. However, in
partial-deployment scenarios, it is not possible for a BGPsec router to
require a BGPsec-capable eBGP peer to send only signed updates, except for
prefixes originated by the peer's AS.
</t>
<t>
Note: If BGPsec has not been negotiated with a peer, then a BGPsec router
forwards only unsigned updates to that peer; the sending router does so by
following the reconstruction procedure in Section&nbsp;4.4 of <xref
target="RFC8205"></xref> to generate an AS_PATH attribute corresponding to the
BGPsec_PATH attribute in a received signed update. If the above&nbhy;mentioned
temporary suspension is ever applied, then the same AS_PATH reconstruction
procedure should be utilized.
</t>
</section>
</section>
</section>

<section title="Incremental Deployment and Negotiation of BGPsec" anchor="sec-6">

<section anchor="downgr" title="Downgrade Attacks">
 <section title="Decision">
<t>
No attempt will be made in the BGPsec design to prevent downgrade attacks,
i.e., a BGPsec-capable router sending unsigned updates when it is capable of
sending signed updates.
</t>
</section>

<section title="Discussion">
<t>
BGPsec allows routers to temporarily suspend signing updates (see <xref
target="susp"></xref>). Therefore, it would be contradictory if we were to try
to incorporate in the BGPsec protocol a way to detect and reject downgrade
attacks.  One proposed way to detect downgrade attacks was considered,
based on signed peering registrations (see <xref target="regis"></xref>).
</t>
</section>
</section>

<section anchor="addrf" title="Inclusion of Address Family in Capability Advertisement">
 <section title="Decision">
<t>
It was decided that during capability negotiation, the address family for
which the BGPsec speaker is advertising support for BGPsec will be shared
using the Address Family Identifier (AFI). Initially, two address families
would be included, namely, IPv4 and IPv6.  BGPsec for use with other address
families may be specified in the future. Simultaneous use of the two (i.e.,
IPv4 and IPv6) address families for the same BGPsec session will require that
the BGPsec speaker include two instances of this capability (one for each
address family) during BGPsec capability negotiation.
</t>
</section>
<section title="Discussion">
<t>
If new address families are supported in the future, they will be added in
future versions of the specification. A comment was made that too many version
numbers are bad for interoperability. Renegotiation on the fly to add a new
address family (i.e., without changeover to a new version number) is desirable.
</t>
</section>
</section>

<section anchor="incrd" title="Incremental Deployment: Capability Negotiation">
 <section title="Decision">
<t>
BGPsec will be incrementally deployable.  BGPsec routers will use
capability negotiation to agree to run BGPsec between them.  If a
BGPsec router's peer does not agree to run BGPsec, then the BGPsec
router will run only traditional BGP with that peer, i.e., it will not
send BGPsec (i.e., signed) updates to the peer.

</t>
<t>
Note: See Section 7.9 of <xref target="RFC8205"></xref> for a discussion of
incremental / partial-deployment considerations. Also, Section&nbsp;6 of
<xref target="RFC8207"></xref> describes how edge sites (stub ASes) can sign
updates that they originate but can receive only unsigned updates. This
facilitates a less expensive upgrade to BGPsec in resource-limited stub ASes
and expedites incremental deployment.
</t>

</section>
<section title="Discussion">
<t>
The partial-deployment approach to incremental deployment will result in
"BGPsec islands". Updates that originate within a BGPsec island will generally
propagate with signed AS paths to the edges of that island. As BGPsec adoption
grows, the BGPsec islands will expand outward (subsuming non&nbhy;BGPsec
portions of the Internet) and/or pairs of islands may join to form larger
BGPsec islands.
</t>
</section>
</section>
<section anchor="partsign" title="Partial Path Signing">
<t>
"Partial path signing" means that a BGPsec AS can be permitted to sign an
update that was received unsigned from a downstream neighbor. That is, the AS
would add its ASN to the AS path and sign the (previously unsigned) update to
other neighboring (upstream) BGPsec&nbsp;ASes.
</t>
<section title="Decision">
<t>
It was decided that partial path signing in BGPsec will not be allowed. A
BGPsec update must be fully signed, i.e., each AS in the AS path must sign the
update. So, in a signed update, there must be a signature corresponding to
each AS in the AS path.
</t>
</section>
<section title="Discussion">
<t>
Partial path signing (as described above) implies that the AS path is not
rigorously protected. Rigorous AS path protection is a key requirement of
BGPsec <xref target="RFC7353"></xref>. Partial path signing clearly
reintroduces the following attack vulnerability: if a BGPsec speaker is
allowed to sign an unsigned update and if signed (i.e., partially or fully
signed) updates would be preferred over unsigned updates, then a faulty,
misconfigured, or subverted BGPsec speaker can manufacture any unsigned update
it wants (by inserting a valid origin AS) and add a signature to it to
increase the chance that its update will be preferred.
</t>
</section>
</section>

<section anchor="early_adop" title="Consideration of Stub ASes with Resource Constraints: Encouraging Early Adoption">
 <section anchor="asymmetry" title="Decision">
<t>
The protocol permits each pair of BGPsec-capable ASes to asymmetrically
negotiate the use of BGPsec. Thus, a stub AS (or downstream customer AS) can
agree to perform BGPsec only in the transmit direction and speak traditional
BGP in the receive direction.  In this arrangement, the ISP's (upstream) AS
will not send signed updates to this stub or customer AS.  Thus, the stub AS
can avoid the need to hardware&nbhy;upgrade its route processor and RIB memory
to support BGPsec update validation.
</t>
</section>
<section title="Discussion">
<t>
Various other options were also considered for accommodating a 
resource-constrained stub AS, as discussed below: 
</t>
<t><list style="numbers">
<t>
An arrangement that can be effected outside of the BGPsec specification is as
follows. Through a private arrangement (invisible to other ASes), an
ISP's AS (upstream AS) can truncate the stub AS (or downstream AS) from the
path and sign the update as if the prefix is originating from the ISP's AS
(even though the update originated unsigned from the customer AS).  This way,
the path will appear fully signed to the rest of the network. This alternative
will require the owner of the prefix at the stub AS to issue a ROA for the
upstream AS, so that the upstream AS is authorized to originate routes for the
prefix.
</t>
<t>
Another type of arrangement that can also be effected outside of the BGPsec
specification is as follows. The stub AS does not sign updates, but it
obtains an RPKI (CA) certificate and issues a router certificate under that
CA certificate. It passes on the private key for the router certificate to
its upstream provider. That ISP (i.e., the second&nbhy;hop AS) would insert
a signature on behalf of the stub AS using the private key obtained from the
stub AS. This arrangement is called "proxy signing" (see <xref
target="proxy_sig"></xref>).
</t>
<t>
An extended ROA is created that includes the stub AS as the originator
of the prefix and the upstream provider as the second&nbhy;hop AS, and partial
signatures would be allowed (i.e., the stub AS need not sign the updates).
It is recognized that this approach is also authoritative and not trust
based. It was observed that the extended ROA is not much different from what
is done with the ROA (in its current form) when a Provider-Independent (PI)
address is originated from a provider's AS. This approach was rejected due to
possible complications with the creation and use of a new RPKI object, namely,
the extended ROA. Also, the validating BGPsec router has to perform a level of
indirection with this approach, i.e., it must detect that an update is not
fully signed and then look for the extended ROA to validate.
</t>
<t>  
Another method, based on a different form of indirection, would be as follows.
The customer (stub) AS registers something like a Proxy Signer Authorization,
which authorizes the second&nbhy;hop (i.e., provider) AS to sign on behalf of
the customer AS using the provider's own key <xref
target="Dynamics"></xref>. This method allows for fully signed updates (unlike
the approach based on the extended ROA). But this approach also requires the
creation of a new RPKI object, namely, the Proxy Signer Authorization. In this
approach, the second&nbhy;hop AS and validating ASes have to perform a level
of indirection. This approach was also rejected.
</t>
</list> </t>
<t>
The various inputs regarding ISP preferences were taken into consideration,
and eventually the decision in favor of asymmetric BGPsec was reached (<xref
target="asymmetry"></xref>). An advantage for a stub AS that does asymmetric
BGPsec is that it only needs to minimally upgrade to BGPsec so it can sign
updates to its upstream AS while it receives only unsigned updates. Thus, it
can avoid the cost of increased processing and memory needed to perform update
validations and to store signed updates in the RIBs, respectively.
</t>
</section>
</section>

<section anchor="proxy_sig" title="Proxy Signing">
 <section title="Decision">
<t>
An ISP's AS (or upstream AS) can proxy-sign BGP announcements for a customer
(downstream) AS, provided that the customer AS obtains an RPKI (CA)
certificate, issues a router certificate under that CA certificate, and
passes on the private key for that certificate to its upstream provider. 
That ISP (i.e., the second&nbhy;hop AS) would insert a signature on behalf of
the customer AS using the private key provided by the customer AS. This is a
private arrangement between the two ASes and is invisible to other ASes. Thus,
this arrangement is not part of the BGPsec protocol specification.
</t>
<t>
BGPsec will not make any special provisions for an ISP to use its own private
key to proxy-sign updates for a customer's AS. This type of proxy signing is
considered a bad idea. 
</t>
</section>
<section title="Discussion">
<t>
Consider a scenario when a customer's AS (say, AS8) is multihomed to two
ISPs, i.e., AS8 peers with AS1 and AS2 of ISP-1 and ISP-2, respectively. In
this case, AS8 would have an RPKI (CA) certificate; it issues two separate
router certificates (corresponding to AS1 and AS2) under that CA certificate,
and it passes on the respective private keys for those two certificates to its
upstream providers AS1 and AS2. Thus, AS8 has a proxy-signing service from both
of its upstream ASes. In the future, if AS8 were to disconnect from ISP-2,
then it would revoke the router certificate corresponding to AS2.
</t>
</section>
</section>



<section anchor="multi" title="Multiple Peering Sessions between ASes">
 <section title="Decision">
<t>
No problems are anticipated when BGPsec-capable ASes have multiple
peering sessions between them (between distinct routers).
</t>
</section>
<section title="Discussion">
<t>
In traditional BGP, multiple peering sessions between different pairs of
routers (between two neighboring ASes) may be simultaneously used for load
sharing.  Similarly, BGPsec-capable ASes can also have multiple peering
sessions between them. Because routers in an AS can have distinct private
keys, the same update, when propagated over these multiple peering sessions,
will result in multiple updates that may differ in their signatures. The peer
(upstream) AS will apply its normal procedures for selecting a best path from
those multiple updates (and updates from other peers).
</t>
<t>
This decision regarding load balancing (vs.&nbsp;using one peering session
as the primary for carrying data and another as the backup) is entirely local
and is up to the two neighboring ASes.
</t>
</section>
</section>
</section>

<section title="Interaction of BGPsec with Common BGP Features" anchor="sec-7">
<section anchor="peergr" title="Peer Groups">
<t>

In traditional BGP, the idea of peer groups is used in BGP routers to save on
processing when generating and sending updates.  Multiple peers for whom the
same policies apply can be organized into peer groups. A peer group can
typically have tens of ASes (and maybe as many as 300) in it.
</t>
 <section title="Decision">
<t>
It was decided that BGPsec updates are generated to target unique AS peers, so
there is no support for peer groups in BGPsec.
</t>
</section>
<section title="Discussion">
<t>
BGPsec router processing can make use of peer groups preceding the signing of
updates to peers.  Some of the update processing prior to forwarding to
members of a peer group can be done only once per update, as is done in
traditional BGP.  Prior to forwarding the update, a BGPsec speaker adds the
peer's ASN to the data that needs to be signed and signs the update for each
peer AS in the group individually.
</t>
<t>
If updates were to be signed per peer group, information about the forward
AS set that constitutes a peer group would have to be divulged (since the ASN
of each peer would have to be included in the update).  Some ISPs do not
like to share this kind of information globally.
</t>
</section>
</section>

<section anchor="commun" title="Communities">
<t>
The need to provide protection in BGPsec for the community attribute was
discussed.
</t>
 <section title="Decision">
<t>
Community attribute(s) will not be included in any message that is signed in
BGPsec.
</t>
</section>
<section title="Discussion">
<t>
From a security standpoint, the community attribute, as currently defined,
may be inherently defective.  A substantial amount of work on the semantics
of the community attribute is needed, and additional work on its security
aspects also needs to be done.  The community attribute is not necessarily
transitive; it is often used only between neighbors. In those contexts,
transport-security mechanisms suffice to provide integrity and authentication.
(There is no need to sign data when it is passed only between peers.) It was
suggested that one could include only the transitive community attributes in
any message that is signed and propagated (across the AS path).  It was noted
that there is a flag available (i.e., unused) in the community attribute, and
it might be used by BGPsec (in some fashion). However, little information is
available at this point about the use and function of this flag.  It was
speculated that this flag could potentially be used to indicate to BGPsec
whether or not the community attribute needs protection.  For now, community
attributes will not be secured by BGPsec path signatures.
</t>
</section>
</section>

<section anchor="confd" title="Consideration of iBGP Speakers and Confederations">
 <section title="Decision">
<t>

An iBGP speaker that is also an eBGP speaker and that executes BGPsec will
by necessity carry BGPsec data and perform eBGPsec functions.
Confederations are eBGP clouds for administrative purposes and contain
multiple Member-ASes. A Member-AS is not required to sign updates sent to
another Member-AS within the same confederation. However, if BGPsec signing is
applied in eBGP within a confederation, i.e., each Member-AS signs to the next
Member-AS in the path within the confederation, then upon egress from the
confederation, the Member-AS at the boundary must remove any and all
signatures applied within the confederation. The Member-AS at the boundary
of the confederation will sign the update to an eBGPsec peer using
the public ASN of the confederation and its private key. The BGPsec
specification will not specify how to perform this process.
</t>
<t>
Note: In RFC 8205, signing a BGPsec update between Member-ASes within a
confederation is required if the update were to propagate with signatures
within the confederation. A Confed_Segment flag exists in each Secure_Path
segment, and when set, it indicates that the corresponding signature belongs
to a Member-AS. At the confederation boundary, all signatures with
Confed_Segment flags set are removed from the update. RFC&nbsp;8205 specifies
in detail how all of this is done. Please see Figure&nbsp;5 in
Section&nbsp;3.1 of <xref target="RFC8205"></xref>, as well as
Section&nbsp;4.3 of <xref target="RFC8205"></xref>, for details.
</t>
</section>
<section title="Discussion">
<t>
This topic may need to be revisited to flesh out the details carefully.
</t>
</section>
</section>

<section title="Consideration of Route Servers in IXPs">
 <section title="Decision">
<t>
<xref target="BGPsec-Initial"></xref> made no special provisions to
accommodate route servers in Internet Exchange Points (IXPs).
</t>
<t>
Note: The above decision subsequently changed: RFC 8205 allows the
accommodation of IXPs, especially for transparent route servers. The pCount
(AS prepend count) field is set to zero for transparent route servers (see
Section&nbsp;4.2 of <xref target="RFC8205"></xref>). The operational guidance
for preventing the misuse of pCount=0 is given in Section&nbsp;7.2 of
RFC&nbsp;8205. Also, see Section&nbsp;8.4 of RFC&nbsp;8205 for a
discussion of security considerations concerning pCount=0.
</t>

</section>
<section title="Discussion">
<t>
   There are basically three methods that an IXP may use to propagate routes:
   (A)&nbsp;direct bilateral peering through the IXP, (B)&nbsp;BGP peering
   between clients via peering with a route server at the IXP (without the IXP
   inserting its ASN in the path), and (C)&nbsp;BGP peering with an IXP route
   server, where the IXP inserts its ASN in the path.  (Note:&nbsp;The IXP's
   route server does not change the NEXT_HOP attribute even if it inserts its
   ASN in the path.)  It is very rare for an IXP to use Method C because it is
   less attractive for the clients if their AS path length increases by one
   due to the IXP.  A measure of the extent of the use of Method A
   vs.&nbsp;Method B is given in terms of the corresponding IP traffic load
   percentages.  As an example, at a major European IXP, these
   percentages are about 80% and 20% for Methods A and B, respectively (this
   data is based on private communication with IXPs circa 2011).
   However, as the IXP grows (in terms of number of clients), it
   tends to migrate more towards Method&nbsp;B because of the difficulties of
   managing up to n x (n-1)/2 direct interconnections between n peers
   in Method A.
</t>
<t>
   To the extent that an IXP is providing direct bilateral peering between
   clients (Method A), that model works naturally with BGPsec.  Also, if
   the route server in the IXP plays the role of a regular BGPsec
   speaker (minus the routing part for payload) and inserts its own ASN
   in the path (Method C), then that model would also work well in the
   BGPsec Internet and this case is trivially supported in BGPsec.  
</t>
</section>
</section>

<section anchor="proxy_agg" title="Proxy Aggregation (a.k.a.&nbsp;AS_SETs)">
 <section title="Decision">
<t>
Proxy aggregation (i.e., the use of AS_SETs in the AS path) will not be
supported in BGPsec.  There is no provision in BGPsec to sign an update when
an AS_SET is part of an AS path.  If a BGPsec-capable router receives an
update that contains an AS_SET and also finds that the update is signed, then
the router will consider the update malformed (i.e., a protocol error).
</t>
<t>
Note: Section 5.2 of RFC 8205 specifies that a receiving BGPsec router
"MUST handle any syntactical or protocol errors in the BGPsec_PATH
attribute by using the 'treat-as-withdraw' approach as defined in
RFC&nbsp;7606 <xref target="RFC7606"></xref>."

</t>
</section>
<section title="Discussion">
<t>
Proxy aggregation does occur in the Internet today, but it is very rare.
Only a very small fraction (about 0.1%) of observed updates contain
AS_SETs in the AS path <xref target="ASset"></xref>. Since traditional BGP
currently allows for proxy aggregation with the inclusion of AS_SETs in the
AS path, it is necessary that BGPsec specify what action a receiving router
must take if such an update is received with attestation.
BCP&nbsp;172 <xref target="RFC6472"></xref> recommends against the use of
AS_SETs in updates, so it is anticipated that the use of AS_SETs will diminish
over time.
</t>
</section>
</section>

<section anchor="fourb" title="4-Byte AS Numbers">
<t>
Not all (currently deployed) BGP speakers are capable of dealing with 4-byte
ASNs <xref target="RFC6793"></xref>. The standard mechanism used to
accommodate such speakers requires a peer AS to translate each 4-byte ASN in
the AS path to a reserved 2-byte ASN (23456) before forwarding the
update. This mechanism is incompatible with the use of BGPsec, since the ASN
translation is equivalent to a route modification attack and will cause
signatures corresponding to the translated 4-byte ASNs to fail validation.
</t>
 <section title="Decision">
<t>
BGP speakers that are BGPsec capable are required to process
4&nbhy;byte&nbsp;ASNs.
</t>
</section>
<section title="Discussion">
<t>
It is reasonable to assume that upgrades for 4-byte ASN support will be
in place prior to the deployment of BGPsec.
</t>
</section>
</section>
</section>

<section title="BGPsec Validation" anchor="sec-8">
<section anchor="seqn" title="Sequence of BGPsec Validation Processing in a Receiver">

<t>
It is natural to ask in what sequence a receiver must perform BGPsec update
validation so that if a failure were to occur (i.e., the update was determined
to be invalid) the processor would have spent the least amount of processing
or other resources.
</t>
 <section title="Decision">
<t>
There was agreement that the following sequence of receiver operations
is quite meaningful; the following steps are included in
<xref target="BGPsec-Initial"></xref>. However, the ordering of these
validation-processing steps is not a normative part of the BGPsec
specification.
</t>
<t> <list style="numbers">
<t>
Verify that the signed update is syntactically correct. For example, check
to see if the number of signatures matches the number of ASes in the AS
path (after duly accounting for AS prepending).
</t>
<t> 
Verify that the origin AS is authorized to advertise the prefix in question.
This verification is based on data from ROAs and does not require any
cryptographic operations.
</t>
<t> 
Verify that the advertisement has not yet expired.
</t>
<t> 
Verify that the target ASN in the signature data matches the ASN of the router
that is processing the advertisement. Note that the target-ASN check is also a
non&nbhy;cryptographic operation and is&nbsp;fast.
</t>
<t> 
Validate the signature data starting from the most recent AS to the origin. 
</t>
<t> 
Locate the public key for the router from which the advertisement was
received, using the SKI from the signature data.
</t>
<t> 
Hash the data covered by the signature algorithm. Invoke the signature
validation algorithm on the following three inputs: the locally computed hash,
the received signature, and the public key. There will be one output: valid or
invalid.
</t>
<t>
Repeat steps 5 and 6 for each preceding signature in the
Signature_Block until (a)&nbsp;the signature data for the origin AS
is encountered and processed or (b)&nbsp;either of these steps fails.
</t>
</list> </t>
<t>
Note: Significant refinements to the above list occurred in the progress
towards RFC&nbsp;8205. The detailed syntactic-error checklist is presented and
explained in Section&nbsp;5.2 of <xref target="RFC8205"></xref>. Also, a
logical sequence of steps to be followed in the validation of
Signature_Blocks is described in Section&nbsp;5.2 of <xref
target="RFC8205"></xref>.
</t>
</section>
<section title="Discussion">
<t>
If the goal is to minimize computational costs associated with cryptographic
operations, the sequence of receiver operations that is suggested above is
viewed as appropriate. One additional interesting suggestion was that when
there are two Signature_Blocks in an update, the validating router
can first verify which of the two algorithms is cheaper, to save on
processing.  If that Signature_Block verifies, then the router can
skip validating the other Signature_Block.
</t>
</section>
</section>

<section title="Signing and Forwarding Updates when Signatures Failed Validation">
 <section title="Decision">
<t>
A BGPsec router should sign and forward a signed update to upstream peers if
it selected the update as the best path, regardless of whether the update
passed or failed validation (at this router). 
</t>
</section>
<section title="Discussion">
<t>
The availability of RPKI data at different routers (in the same AS or
different ASes) may differ, depending on the sources used to acquire RPKI
data.  Hence, an update may fail validation in one AS, and the same update may
pass validation in another AS.  Also, an update may fail validation at one
router in an AS, and the same update may pass validation at another router in
the same AS.
</t> 
<t>
A BCP may be published later that will identify some update-failure
conditions that may present unambiguous cases for rejecting the update
(in which case the router would not select the AS path in the update).
These cases are "TBD" (to be determined).
</t>
</section>
</section>


<section anchor="econd" title="Enumeration of Error Conditions">
<t>
Enumeration of error conditions and the recommendations for how to react to
them are still under discussion.
</t>
 <section title="Decision">
<t>
TBD. Also, please see <xref target="syntx"></xref> for the decision and
discussion specifically related to syntactic errors in signatures. 
</t>
<t>
Note: Section 5.2 of RFC 8205 describes the detection of syntactic and protocol
errors in BGPsec updates as well as how the updates with such errors are to be
handled.
</t>
</section>
<section title="Discussion">
<t>
The following list is a first attempt to provide some possible error
conditions and recommended receiver reactions in response to the detection of
those errors. Refinements will follow after further discussions.
</t>
<t><list counter="errlist" hangIndent="4" style="format E%d">
<t>
Abnormalities where a peer (i.e., the preceding AS) should definitely not have
propagated to a receiving eBGPsec router. For example,
(A)&nbsp;the number of signatures does not match the number of ASes in the AS
path (after accounting for AS prepending), (B)&nbsp;there is an AS_SET in the
received update and the update has signatures, or (C)&nbsp;other syntactic
errors with signatures have occurred.
</t>
</list> </t>
<t> <list hangIndent="4" style="empty">
<t>
Reaction: See <xref target="syntx"></xref>.
</t>
</list> </t>
<t><list counter="errlist" hangIndent="4" style="format E%d">
<t>
Situations where a receiving eBGPsec router cannot find the
certificate for an AS in the AS path.
</t>
</list> </t>
<t><list hangIndent="4" style="empty">
<t>
Reaction: Mark the update as "Invalid". It is acceptable to consider the
update in the best-path selection. If it is chosen, then the router should
sign and propagate the update.
</t>
</list> </t>
<t><list counter="errlist" hangIndent="4" style="format E%d">
<t>
Situations where a receiving eBGPsec router cannot find a ROA for the
{prefix, origin} pair in the update.
</t>
</list> </t>
<t><list hangIndent="4" style="empty">
<t>
Reaction: Same as in (E2) above. 
</t>
</list> </t>
<t><list counter="errlist" hangIndent="4" style="format E%d">
<t>
Situations where the receiving eBGPsec router verifies signatures and finds
that the update is "Invalid" (even though its peer might not have known, e.g.,
due to RPKI skew).
</t>
</list> </t>
<t><list hangIndent="4" style="empty">
<t>
Reaction: Same as in (E2) above.
</t>
<t>
In some networks, the best-path-selection policy may specify choosing an
unsigned update over one with invalid signature(s). Hence, the signatures must
not be stripped even if the update is "Invalid". No evil bit is set in the
update (when it is "Invalid") because an upstream peer may not get that same
answer when it tries to validate.
</t>
</list> </t>
</section>
</section>

<section anchor="unsgn" title="Procedure for Processing Unsigned Updates">
<t>
An update may come in unsigned from an eBGP peer or internally (e.g., as an
iBGP update). In the latter case, the route is being originated from within
the AS in question.
</t>
 <section title="Decision">
<t>
If an unsigned route is received from an eBGP peer and if it is selected,
then the route will be forwarded unsigned to other eBGP peers -- even
BGPsec-capable peers.  If the route originated in this AS (IGP or iBGP) and
is unsigned, then it should be signed and announced to external
BGPsec-capable peers.  
</t>
</section>

<section title="Discussion">
<t>
It is also possible that an update received in IGP (or iBGP) may have
private ASNs in the AS path. These private ASNs would normally appear in the
rightmost portion of the AS path. It was noted that in this case the private
ASNs to the right would be removed (as done in traditional BGP), and then the
update will be signed by the originating AS and announced to BGPsec-capable
eBGP peers.
</t>
<t>
Note: See Section 7.5 of <xref target="RFC8205"></xref> for operational
considerations for BGPsec in the context of private ASNs.
</t>
</section>
</section>

<section anchor="syntx" title="Response to Syntactic Errors in Signatures and
 Recommendations for How to React to Them">
<t>
Note: The contents of this subsection (i.e., <xref target="syntx"></xref>)
differ substantially from the recommendations in RFC&nbsp;8205 regarding the
handling of syntactic errors and protocol errors. Hence, the reader may skip
this subsection and instead read Section&nbsp;5.2 of <xref
target="RFC8205"></xref>. This subsection (<xref target="syntx"></xref>) is
kept here for the sake of archival value concerning design discussions.
</t>
<t>
Different types of error conditions were discussed in <xref
target="econd"></xref>. Here, the focus is only on syntactic-error conditions
in signatures.
</t>

<section title="Decision">
<t>
If there are syntactic-error conditions such as (A) AS_SET and BGPsec_PATH
both appearing in an update, (B) the number of signatures not matching the
number of ASes (after accounting for any AS prepending), or (C) a parsing
issue occurring with the BGPsec_PATH attribute, then the update (with the
signatures stripped) will still be considered in the best-path-selection
algorithm.&nbsp; (**Note: This is not true in RFC&nbsp;8205**.) &nbsp;If the
update is selected as the best path, then the update will be propagated
unsigned. The error condition will be logged locally.
</t>
<t> 
A BGPsec router will follow whatever the current IETF (IDR WG)
recommendations are for notifying a peer that it is sending malformed
messages.
</t>
<t>
In the case when there are two Signature_Blocks in an update,
and one or more syntactic errors are found to occur within one of
them but the other one is free of any syntactic errors, then the update will
still be considered in the best-path-selection algorithm after the
syntactically bad Signature_Block has been removed.&nbsp; (**Note: This is
not true in RFC 8205**.) &nbsp;If the update is selected as the best path,
then the update will be propagated with only one (i.e., the error&nbhy;free)
Signature_Block.  The error condition will be logged locally.
</t>
</section>
<section title="Discussion">
<t>
As stated above, a BGPsec router will follow whatever the current IETF
(IDR WG) recommendations are for notifying a peer that it is sending malformed
messages. Question: If the error is persistent and a full BGP table dump
occurs, then would there be 500K such errors resulting in 500K "notify"
messages sent to the peer that is generating the errors? Answer: Rate limiting
would be applied to the notify messages and should prevent any overload due to
these messages.
</t>
</section>
</section>

<section anchor="enum" title="Enumeration of Validation States">
<t>
Various validation conditions are possible that can be mapped to validation
states for possible input to the BGPsec decision process. These conditions can
be related to whether an update is signed, Expire Time is checked, route origin
validation is checked against a ROA, signature verification passed, etc.
</t>

<section title="Decision">
<t>
It was decided that BGPsec validation outcomes will be mapped to one of only
two validation states: (1) Valid -- passed all validation checks (i.e.,
Expire Time check, route origin and Signature_Block validation) and
(2)&nbsp;Invalid -- all other possibilities. "Invalid" would include
situations such as the following:</t>

<t><list style="numbers">
<t>Due to a lack of RPKI data or insufficient RPKI data, validation
was not performed.</t>
<t>The signature Expire Time check failed.</t>
<t>Route origin validation failed.</t>
<t>Signature checks were performed, and one or more of them failed.</t>
</list></t>

<t>
Note: Expire Time is obsolete (see the notes in
Sections&nbsp;<xref target="oas1" format="counter"></xref> and
<xref target="oas2" format="counter"></xref>). RFC&nbsp;8205 uses the states
"Valid" and "Not Valid", but only with respect to AS path validation (i.e.,
not including the result of origin validation); see
Section&nbsp;5.1 of <xref target="RFC8205"></xref>. "Not&nbsp;Valid" includes
all conditions in which path validation was attempted but a "Valid" result
could not be reached. (Note: Path validation is not attempted in the case of
syntactic or protocol errors in a BGPsec update; see
Section&nbsp;5.2 of <xref target="RFC8205"></xref>.) Each Relying Party (RP)
is expected to devise its own policy to suitably factor the results of
origin validation <xref target="RFC6811"></xref> and path validation <xref
target="RFC8205"></xref> into its path-selection decision.</t>
</section>

<section title="Discussion">
<t>
It may be noted that the result of update validation is just an
additional input for the BGP decision process.  The router's local policy
ultimately has control over what action (regarding BGP path selection)
is taken.
</t>
<t>
Initially, four validation states were considered:
</t>

<t><list style="numbers">
<t>The update is not signed.</t>
<t>The update is signed, but the router does not have corresponding RPKI data
to perform a validation check.</t>
<t>The validation check was performed, and the check failed (Invalid).</t>
<t>The validation check was performed, and the check passed (Valid).</t>
</list></t>

<t>As stated above, it was later decided that BGPsec validation outcomes will
be mapped to one of only two validation states. It was observed that an update
can be invalid for many different reasons. To begin to differentiate these
numerous reasons and to try to enumerate different flavors of the Invalid state
will not likely be constructive in route-selection decisions and may even
introduce new vulnerabilities in the system. However, some questions remain,
such as the following:
</t>
<t>
Question: Is there a need to define a separate validation state for the case
when an update is not signed but the {prefix, origin} pair matches the ROA
information? After some discussion, a tentative conclusion was reached:
this is in principle similar to validation based on partial path signing
(which was ruled out; see <xref target="partsign"></xref>). So, there
is no need to add another validation state for this case; treat it as
"Invalid", considering that it is unsigned.</t>

<t>Another remaining question: Would the RP want to give the update a higher
preference over another unsigned update that failed origin validation or over
a signed update that failed both signature and ROA validation?
</t>
</section>
</section>

<section title="Mechanism for Transporting Validation State through iBGP">
 <section title="Decision">
 <t>
BGPsec validation need be performed only at eBGP edges.  The validation
status of a BGP signed/unsigned update may be conveyed via iBGP from an
ingress edge router to an egress edge router.  Local policy in the AS will
determine how the validation status is conveyed internally, using various
preexisting mechanisms, e.g., setting a BGP community, or modifying a
metric value such as Local_Pref or MED.  A signed update that cannot be
validated (except those with syntax errors) should be forwarded with
signatures from the ingress router to the egress router, where it is signed
when propagated towards other eBGPsec speakers in neighboring ASes.
Based entirely on local policy settings, an egress router may trust the
validation status conveyed by an ingress router, or it may perform its own
validation. The latter approach may be used at an operator's discretion, under
circumstances when RPKI skew is known to happen at different routers within
an AS.
</t>
<t>
Note: An extended community for carrying the origin validation state in iBGP
has been specified in RFC&nbsp;8097 <xref target="RFC8097"></xref>.
</t>
</section>
<section title="Discussion">
<t>
The attribute used to represent the validation state can be carried between
ASes, if desired. ISPs may like to carry it over their eBGP links between their
own ASes (e.g., sibling ASes). A peer (or customer) may receive it over an
eBGP link from a provider and may want to use it to shortcut their own
validation check. However, the peer (or customer) should be aware that this
validation-state attribute is just a preview of a neighbor's validation and
must perform their own validation check to be sure of the actual state of the
update's validation. Question: Should validation-state propagation be
protected by attestation in cases where it is useful for diagnostics purposes?
The decision was made to not protect the validation-state information using
signatures.
</t>

<t>
The following validation states may be needed for propagation via iBGP between
edge routers in an AS: 
</t>
<t> <list style="symbols">
<t>
Validation states communicated in iBGP for an unsigned update (route origin
validation result): (1) Valid, (2) Invalid, (3)&nbsp;NotFound (see
<xref target="RFC6811"></xref>), (4) Validation Deferred.
<list style="symbols">
<t>
An update could be unsigned for either of the following two reasons, but they
need not be distinguished: (a) it had no signatures (i.e., came in unsigned
from an eBGP peer) or (b)&nbsp;signatures were present but stripped.
</t>
</list>
</t>
<t>
Validation states communicated in iBGP for a signed update:
(1)&nbsp;Valid, (2) Invalid, (3) Validation Deferred.
</t>
</list></t>
<t>
The reason for conveying the additional "Validation Deferred" state may be
illustrated as follows. An ingress edge Router A receiving an update from an
eBGPsec peer may not attempt to validate signatures (e.g., in a
processor overload situation), and in that case Router A should convey
"Validation Deferred" state for that signed update (if selected for best path)
in iBGP to other edge routers. An egress edge Router&nbsp;B, upon
receiving the update from ingress Router A, would then be able to perform its
own validation (origin validation for an unsigned update or origin/signature
validation for a signed update). As stated before, the egress router
(Router&nbsp;B in this example) may always choose to perform its own
validation when it receives an update from iBGP (independently of the
update's validation status conveyed in iBGP) to account for the possibility
of RPKI data skew at different routers. These various choices are local and
entirely at the operator's discretion.
</t>
</section>
</section>
</section>
<section title="Operational Considerations" anchor="sec-9">
<t>
Note: Significant thought has been devoted to operations and management
considerations subsequent to the writing of
<xref target="BGPsec-Initial"></xref>. The reader is referred to
<xref target="RFC8207"></xref> and Section&nbsp;7 of <xref
target="RFC8205"></xref> for details.
</t>

<section anchor="grace" title="Interworking with BGP Graceful Restart">
<t>
BGP Graceful Restart (BGP-GR) <xref target="RFC4724"></xref> is a mechanism
currently used to facilitate nonstop packet forwarding when the control plane
is recovering from a fault (i.e., the BGP session is restarted) but the data
plane is functioning. Two questions were raised: Are there any special
concerns about how BGP-GR works while BGPsec is operational? Also, what
happens if the BGP router operation transitions from traditional BGP operation
to BGP-GR to BGPsec, in that order?
</t>
 <section title="Decision">
<t>
No decision was made relative to this issue (at the time that
<xref target="BGPsec-Initial"></xref> was written).
</t>
<t>
Note: See Section 7.7 of <xref target="RFC8205"></xref> for comments
concerning the operation of BGP-GR with BGPsec. They are consistent
with the discussion below.
</t>
</section>
<section title="Discussion">
<t>
BGP-GR can be implemented with BGPsec, just as it is currently implemented
with traditional BGP. The Restart State bit, Forwarding State bit, End-of-RIB
marker, staleness marker (in the Adj-RIB-In), and Selection_Deferral_Timer are
key parameters associated with BGP&nbhy;GR <xref target="RFC4724"></xref>.
These parameters would apply to BGPsec, just as they apply to traditional BGP.
</t>
<t>
Regarding what happens if the BGP router transitions from traditional BGP to
BGP-GR to BGPsec, the answer would simply be as follows. If there is a
software upgrade to BGPsec during BGP-GR (assuming that the upgrade is being
done on a live BGP speaker), then the BGP-GR session should be terminated
before a BGPsec session is initiated. Once the eBGPsec peering session
is established, the receiving eBGPsec speaker will see signed
updates from the sending (newly upgraded) eBGPsec speaker. There is no
apparent harm (it may, in fact, be desirable) if the receiving speaker
continues to use previously learned unsigned BGP routes from the sending
speaker until they are replaced by new BGPsec routes. However, if the
Forwarding State bit is set to zero by the sending speaker (i.e., the newly
upgraded speaker) during BGPsec session negotiation, then the receiving
speaker would mark all previously learned unsigned BGP routes from that
sending speaker as "stale" in its Adj-RIB-In. Then, as BGPsec updates are
received (possibly interspersed with unsigned BGP updates), the "stale" routes
will be replaced or refreshed.
</t>
</section>
</section>

<section anchor="expry" title="BCP Recommendations for Minimizing Churn: Certificate Expiry/Revocation and Signature Expire Time">
 <section title="Decision">
<t>
Work related to this topic is still in progress.
</t>
</section>
<section title="Discussion">
<t>
BCP recommendations for minimizing churn in BGPsec have been discussed. There
are various potential strategies on how routers should react to such events
as certificate expiry/revocation and signature Expire Time exhaustion
<xref target="Dynamics"></xref>. The details will be documented in
the near future after additional work is completed.
</t>
</section>
</section>

<section anchor="offbd" title="Outsourcing Update Validation">
 <section title="Decision">
<t>
Update signature validation and signing can be outsourced to an off&nbhy;board
server or processor.
</t>
</section>
<section title="Discussion">
<t>
Possibly, an off-router box (one or more per AS) can be used that performs path
validation. For example, these capabilities might be incorporated into a route
reflector. At an ingress router, one needs the Adj-RIB-In entries validated but
not the RIB-out entries. So, the off-router box is probably unlike the
traditional route reflector; it sits at the network edge and validates all
incoming BGPsec updates. Thus, it appears that each router passes each BGPsec
update it receives to the off-router box and receives a validation result
before it stores the route in the Adj-RIB-In. Question: What about failure
modes here? The failure modes would be dependent on the following:</t>
<t><list style="numbers">
<t>How much of the control plane is outsourced.</t>
<t>How reliable the off-router box is (or, equivalently, communication to
and from it).</t>
<t>How centralized vs.&nbsp;distributed this arrangement is.</t>
</list></t>

<t>When any kind of outsourcing is done, the user needs to be watchful and
ensure that the outsourcing does not cross trust/security boundaries. 
</t>
</section>
</section>
<section anchor="newhw" title="New Hardware Capability">
 <section title="Decision">
<t>
It is assumed that BGPsec routers (Provider Edge (PE) routers and route
reflectors) will require significantly upgraded hardware -- much more memory
for RIBs and hardware cryptographic assistance. However, stub ASes would not
need to make such upgrades because they can negotiate asymmetric BGPsec
capability with their upstream ASes, i.e., they sign updates to the upstream
AS but receive only unsigned BGP updates (see <xref
target="early_adop"></xref>).
</t>
</section>
<section title="Discussion">
<t>
It is accepted that it might take several years to go beyond test deployment
of BGPsec because of the need for additional route processor CPU and
memory. However, because BGPsec deployment will be incremental and because
signed updates are not sent outside of a set of contiguous BGPsec-enabled
ASes, it is not clear how much additional (RIB) memory will be required during
initial deployment. See <xref target="RIB_size"></xref> for preliminary
results on modeling and estimation of BGPsec RIB size and its projected
growth.   Hardware cryptographic support reduces the computation burden on the
route processor and offers good security for router private keys. However,
given the incremental-deployment model, it also is not clear how substantial a
cryptographic processing load will be incurred in the early phases of
deployment.
</t>
<t>
Note: There are recent detailed studies that considered software optimizations
for BGPsec. In <xref target="Mehmet1"></xref> and <xref
target="Mehmet2"></xref>, computational optimizations for cryptographic
processing (i.e., ECDSA speedup) are considered for BGPsec implementations on
general-purpose CPUs. In <xref target="V_Sriram"></xref>, software
optimizations at the level of update processing and path selection are
proposed and quantified for BGPsec implementations.
</t>
</section>
</section>


<section anchor="regis" title="Signed Peering Registrations">
 <section title="Decision">
<t>
The idea of signed BGP peering registrations (for the purpose of path
validation) was rejected. 
</t>
</section>
<section title="Discussion">
<t>
The idea of using a secure map of AS relationships to "validate" updates was
discussed and rejected: such solutions were not pursued because they cannot
provide strong guarantees regarding the validity of updates. Using these
techniques, one can say only that an update is "plausible"; one cannot say
that it is "definitely" valid (based on signed peering relations alone).
</t>
</section>
</section>
</section>

<section anchor="Security" title="Security Considerations">
<t>
This document requires no security considerations. See <xref
target="RFC8205"></xref> for security considerations for the BGPsec protocol.
</t>
</section>

<section anchor="IANA" title="IANA Considerations">
<t>This document has no IANA actions.</t>
</section>

      
 </middle>

  <back>
   
   
  <references title="Informative References">

  &RFC4271;
  &RFC6793;
  &RFC8205;
  &RFC8207;
  &RFC8208;
  &RFC8209;
  &RFC2439;
  &RFC4724;
  &RFC6090;
  &RFC6472;
  &RFC6480;
  &RFC6482;
  &RFC6483;
  &RFC6487;
  &RFC6811;
  &RFC7132;
  &RFC7353;
  &RFC8097;
  &RFC7606;
  &RFC4760;

<!-- draft-lepinski-bgpsec-protocol (replaced by RFC 8205) -->
<reference anchor='BGPsec-Initial'>
<front>
<title>BGPSEC Protocol Specification</title>
<author initials='M' surname='Lepinski' fullname='Matt Lepinski'>
    <organization />
</author>
<date month='March' year='2011' />
</front>
<seriesInfo name='Work in Progress,' value='draft-lepinski-bgpsec-protocol-00'/>
</reference>

<!-- draft-ietf-sidrops-bgpsec-rollover (MISSREF) -->
<reference anchor='BGPsec-Rollover'>
<front>
<title>BGPsec Router Certificate Rollover</title>
<author initials='B' surname='Weis' fullname='Brian Weis'>
    <organization />
</author>
<author initials='R' surname='Gagliano' fullname='Roque Gagliano'>
    <organization />
</author>
<author initials='K' surname='Patel' fullname='Keyur Patel'>
    <organization />
</author>
<date month='December' year='2017' />
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-sidrops-bgpsec-rollover-04'/>
</reference>

<!-- draft-ietf-idr-bgp-extended-messages (AD watching/WG Last Call) -->
<reference anchor='BGP-Ext-Msg'>
<front>
<title>Extended Message support for BGP</title>
<author initials='R' surname='Bush' fullname='Randy Bush'>
    <organization />
</author>
<author initials='K' surname='Patel' fullname='Keyur Patel'>
    <organization />
</author>
<author initials='D' surname='Ward' fullname='David Ward'>
    <organization />
</author>
<date month='November' year='2017' />
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-idr-bgp-extended-messages-24'/>
</reference>

<!-- draft-sriram-replay-protection-design-discussion (I-D Exists) -->
<reference anchor='Replay-Protection'>
<front>
<title>Design Discussion and Comparison of Protection Mechanisms for Replay Attack and Withdrawal Suppression in BGPsec</title>
<author initials='K' surname='Sriram' fullname='Kotikalapudi Sriram'>
    <organization />
</author>
<author initials='D' surname='Montgomery' fullname='Doug Montgomery'>
    <organization />
</author>
<date month='April' year='2018' />
</front>
<seriesInfo name='Work in Progress,' value='draft-sriram-replay-protection-design-discussion-10'/>
</reference>

<!-- draft-clynn-s-bgp-protocol (Expired) -->
  <reference anchor="Secure-BGP">
     <front>
       <title>Secure BGP (S-BGP)</title>
         <author initials="C" surname="Lynn">
         </author>
         <author initials="J" surname="Mikkelson">
         </author>
         <author initials="K" surname="Seo">
         </author>
         <date month="June" year="2003"/>
      </front>
   <seriesInfo name="Work in Progress," value="draft-clynn-s-bgp-protocol-01"/>
  </reference>

<reference anchor="RIPE580" target="http://www.ripe.net/ripe/docs/ripe-580">
   <front>
   <title>RIPE-580: RIPE Routing Working Group Recommendations on Route Flap Damping</title>
     <author fullname="Bush, R., et al.">
   <organization>Bush, R., et al.</organization>
     </author>
  <date month="January" year="2013" />
  </front>
 </reference>

 <reference anchor="Mao02" target="http://www.eecs.umich.edu/~zmao/Papers/sig02.pdf">
  <front>
   <title>Route Flap Damping Exacerbates Internet Routing Convergence</title>
   <author fullname="Mao, Z., et al.">
    <organization>Mao, Z., et al.</organization>
   </author>
   <date month="August" year="2002"/>
  </front>
 </reference>

   <reference anchor="JunOS" target="http://www.juniper.net/techpubs/en_US/junos10.4/topics/usage-guidelines/policy-using-routing-policies-to-damp-bgp-route-flapping.html">
      <front>
      <title>Juniper JunOS: Using Routing Policies to Damp BGP Route Flapping</title>
       <author initials="" surname="">
       </author>
       <date month="November" year="2010"/>
      </front>
   </reference>

   <reference anchor="CiscoIOS" target="https://www.cisco.com/c/en/us/td/docs/ios/12_2/ip/configuration/guide/fipr_c/1cfbgp.html">
        <front>
        <title>Cisco IOS: Configuring Route Dampening</title>
       <author initials="" surname="">
         </author>
         <date month="February" year="2014"/>
       </front>
   </reference>

     <reference anchor="RIB_size" target="http://www.nist.gov/itl/antd/upload/BGPSEC_RIB_Estimation.pdf">
     <front>
      <title>RIB Size Estimation for BGPSEC</title>
      <author fullname="Sriram, K., et al.">
       <organization>Sriram, K., et al.</organization>
      </author>
         <date month="May" year="2011" />
       </front>
     </reference>

 <reference anchor="CPUworkload" target="https://www.ietf.org/proceedings/83/slides/slides-83-sidr-7.pdf">
        <front>
        <title>Estimating CPU Cost of BGPSEC on a Router</title>
         <author initials="K" surname="Sriram">
           <organization></organization>
         </author>
 <author initials="R" surname="Bush">
           <organization></organization>
         </author>
         <date month="March" year="2012"/>
       </front>
<seriesInfo name="Presented at RIPE-63;" value="also at IETF 83 SIDR WG Meeting" />
     </reference>

    <reference anchor="Dynamics" target="https://www.nist.gov/file/448631">
     <front>
      <title>Potential Impact of BGPSEC Mechanisms on Global BGP Dynamics</title>
 <author initials="K" surname="Sriram">
           <organization></organization>
         </author>
 <author initials="D" surname="Montgomery">
           <organization></organization>
         </author>
 <author initials="O" surname="Borchert">
           <organization></organization>
         </author>
 <author initials="O" surname="Kim">
           <organization></organization>
         </author>
 <author initials="P" surname="Gleichmann">
           <organization></organization>
         </author>
      <date month="October " year="2009" />
     </front>
     <seriesInfo name="Presentation to the" value="BGPsec authors/designers team"/>
   </reference>

 <reference anchor="ASset" target="http://www.nist.gov/itl/antd/upload/AS_SET_Aggregator_Stats.pdf">
        <front>
          <title>Measurement Data on AS_SET and AGGREGATOR: Implications for
          {Prefix, Origin} Validation Algorithms</title>

          <author initials="K." surname="Sriram">
            <organization />
          </author>

          <author initials="D." surname="Montgomery">
            <organization />
          </author>

          <date month="July" year="2010" />
        </front>

        <seriesInfo name="IETF SIDR WG presentation," value="IETF 78" />
      </reference>

<reference anchor="MsgSize" target="https://www.ietf.org/proceedings/98/slides/slides-98-sidrops-decoupling-bgpsec-documents-and-extended-messages-draft-00.pdf">
        <front>
        <title>Decoupling BGPsec Documents and Extended Messages draft</title>
         <author initials="K" surname="Sriram">
           <organization></organization>
         </author>
          <date month="March" year="2017"/>
       </front>
<seriesInfo name="Presented at the IETF SIDROPS WG Meeting," value="IETF 98"/>
     </reference>

<reference anchor="Gueron" target="https://rt.openssl.org/Ticket/Display.html?id=3149&amp;user=guest&amp;pass=guest">
        <front>
        <title>Fast and side channel protected implementation of the NIST P-256 Elliptic Curve for x86-64 platforms</title>
         <author initials="S" surname="Gueron">
           <organization></organization>
         </author>
         <author initials="V" surname="Krasnov">
           <organization></organization>
         </author>
         <date month="October" year="2013"/>
       </front>
     <seriesInfo name="OpenSSL patch" value="ID 3149" />
     </reference>

<reference anchor="Mehmet1" target="http://csrc.nist.gov/groups/ST/ecc-workshop-2015/papers/session6-adalier-Mehmet.pdf">
        <front>
        <title>Efficient and Secure Elliptic Curve Cryptography Implementation of Curve P-256</title>
         <author initials="M" surname="Adalier">
           <organization></organization>
         </author>
         <date month="June" year="2015" />
       </front>
 <seriesInfo name="NIST Workshop on" value="ECC Standards"/>
     </reference>

<reference anchor="Mehmet2" target="https://www.nanog.org/meetings/abstract?id=3043">
        <front>
        <title>High Performance BGP Security: Algorithms and Architectures</title>
         <author initials="M" surname="Adalier">
           <organization></organization>
         </author>
 <author initials="K" surname="Sriram">
           <organization></organization>
         </author>
 <author initials="O" surname="Borchert">
           <organization></organization>
         </author>
 <author initials="K" surname="Lee">
           <organization></organization>
         </author>
 <author initials="D" surname="Montgomery">
           <organization></organization>
         </author>
         <date month="February" year="2017"/>
       </front>
  <seriesInfo name="North American Network Operators Group Meeting" value="NANOG69"/>
     </reference>

<reference anchor="Borchert" target="https://www.ietf.org/mail-archive/web/sidr/current/msg07509.html">
        <front>
        <title>Subject: Modifiation [sic] request: draft-ietf-sidr-bgpsec-protocol-14</title>
       <author initials="O." surname="Borchert">
         </author>
<author initials="M." surname="Baer">
         </author>
         <date month="10 February" year="2016" />
       </front>
      <seriesInfo name='message to the' value='IETF SIDR WG Mailing List'/>
     </reference>

<reference anchor="Mandelberg1" target="https://www.ietf.org/mail-archive/web/sidr/current/msg06930.html">
        <front>
    <title>Subject: wglc for draft-ietf-sidr-bgpsec-protocol-11 (Specific 
topic: Include Address Family Identifier in the data protected under 
signature -- to alleviate a security concern)</title>
       <author initials="D." surname="Mandelberg">
         </author>
         <date month="10 February" year="2015" />
       </front>
      <seriesInfo name='message to the' value='IETF SIDR WG Mailing List'/>
     </reference>

<reference anchor="Mandelberg2" target="https://www.ietf.org/mail-archive/web/sidr/current/msg07241.html">
     <front>
     <title>Subject: draft-ietf-sidr-bgpsec-protocol-13's security 
guarantees (Specific topic: Sign all of the preceding signed data 
(rather than just the immediate, previous signature) -- to alleviate a security concern)</title>
       <author initials="D." surname="Mandelberg">
         </author>
         <date month="26 August" year="2015" />
       </front>
      <seriesInfo name='message to the' value='IETF SIDR WG Mailing List'/>
     </reference>

<reference anchor="V_Sriram" target="https://www.sciencedirect.com/science/article/pii/S0140366417303365">
        <front>
        <title>Design and analysis of optimization algorithms to minimize cryptographic processing in BGP security protocols</title>
         <author initials="V" surname="Sriram">
           <organization></organization>
         </author>
         <author initials="D" surname="Montgomery">
           <organization></organization>
         </author>
         <date month="July" year="2017"/>
       </front>
   <seriesInfo name="Computer Communications," value="Vol. 106, pp. 75-85"/>
   <seriesInfo name="DOI" value="10.1016/j.comcom.2017.03.007"/>
     </reference>
   </references>

<section title="Acknowledgements" numbered="no"> 
<t>The author would like to thank Jeff Haas and Wes George for serving as
reviewers for this document for the Independent Submissions stream. The
author is grateful to Nevil Brownlee for shepherding this document through
the Independent Submissions review process. Many thanks are also due to
Michael Baer, Oliver Borchert, David Mandelberg, Sean Turner, Alvaro Retana,
Matthias Waehlisch, Tim Polk, Russ Mundy, Wes Hardaker, Sharon Goldberg,
Ed Kern, Chris Hall, Shane Amante, Luke Berndt, Doug Maughan,
Pradosh Mohapatra, Mark Reynolds, Heather Schiller, Jason Schiller,
Ruediger Volk, and David Ward for their review, comments, and suggestions
during the course of this&nbsp;work.
</t>
</section>

<section title="Contributors" numbered="no">

<t>
The following people made significant contributions to this document and
should be considered co-authors:
</t>

<figure><artwork><![CDATA[
Rob Austein
Dragon Research Labs
Email: sra@hactrn.net

Steven Bellovin
Columbia University
Email: smb@cs.columbia.edu

Russ Housley
Vigil Security, LLC
Email: housley@vigilsec.com

Stephen Kent
Independent
Email: kent@alum.mit.edu

Warren Kumari
Google
Email: warren@kumari.net

Matt Lepinski  
New College of Florida
Email: mlepinski@ncf.edu

Doug Montgomery
USA National Institute of Standards and Technology
Email: dougm@nist.gov

Chris Morrow
Google, Inc.
Email: morrowc@google.com

Sandy Murphy
Parsons, Inc.
Email: sandy@tislabs.com

Keyur Patel
Arrcus
Email: keyur@arrcus.com

John Scudder
Juniper Networks
Email: jgs@juniper.net

Samuel Weiler
W3C/MIT
Email: weiler@csail.mit.edu
]]></artwork></figure>

</section>

</back>

</rfc>
