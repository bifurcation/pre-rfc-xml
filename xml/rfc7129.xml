<?xml version='1.0' encoding='US-ASCII'?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

]>
<rfc ipr="trust200902" submissionType="independent" category="info" number="7129">
  <?rfc toc="yes"?>
  <?rfc tocdepth="6"?>
  <?rfc symrefs="yes"?>
  <?rfc sortrefs="yes" ?>
  <?rfc rfcedstyle="yes"?>
  <?rfc strict="yes"?>
  <?rfc autobreaks="yes"?>
  <?rfc compact="yes" ?>
  <?rfc subcompact="no" ?>

  <front>
    <title abbrev="Authenticated Denial in DNS">Authenticated Denial of Existence in the DNS</title>
    <author initials="R." surname="Gieben" fullname="R. (Miek) Gieben">
      <organization>Google</organization>
      <address>
        <email>miek@google.com</email>
      </address>
    </author>
    <author initials="W." surname="Mekking" fullname="W. (Matthijs) Mekking">
      <organization>NLnet Labs</organization>
      <address>
        <postal>
          <street>Science Park 400</street>
          <street/>
          <city>Amsterdam</city>
          <code>1098 XH</code>
          <country>NL</country>
        </postal>
        <email>matthijs@nlnetlabs.nl</email>
        <uri>http://www.nlnetlabs.nl/</uri>
      </address>
    </author>
    <date month="February" year="2014"/>
    <area>Internet</area>
    <keyword>DNSSEC</keyword>
    <keyword>Denial of Existance</keyword>
    <keyword>NSEC</keyword>
    <keyword>NSEC3</keyword>



<abstract>
<t>Authenticated denial of existence allows a resolver to validate that a certain domain name does not exist. It is also used to signal that a domain name exists but does not have the specific resource record (RR) type you were asking for. When returning a negative DNS Security Extensions (DNSSEC) response, a name server usually includes up to two NSEC records. With NSEC version 3 (NSEC3), this amount is three.  </t>

<t>This document provides additional background commentary and some context for the NSEC and NSEC3 mechanisms used by DNSSEC to provide authenticated denial-of-existence responses. </t> </abstract>
  </front>
  <middle><section title="Introduction" anchor="introduction" toc="default"><t>DNSSEC can be somewhat of a complicated matter, and there are certain areas of the specification that are more difficult to comprehend than others. One such area is "authenticated denial of existence".  </t>
<t>Denial of existence is a mechanism that informs a resolver that a certain domain name does not exist. It is also used to signal that a domain name exists but does not have the specific RR type you were asking for.  </t>

<t>The first is referred to as a nonexistent domain (NXDOMAIN) (<xref target="RFC2308" pageno="false" format="default"/>, Section 2.1) and the latter as a NODATA (<xref target="RFC2308" pageno="false" format="default"/>, Section 2.2) response. Both are also known as negative responses.  </t>

<t>Authenticated denial of existence uses cryptography to sign the negative response. However, if there is no answer, what is it that needs to be signed? To further complicate this matter, there is the desire to pre-generate negative responses that are applicable for all queries for nonexistent names in the signed zone. See <xref target="secure-denial-of-existence" pageno="false" format="default"/> for the details.  </t>

<t>In this document, we will explain how authenticated denial of existence works. We begin by explaining the current technique in the DNS and work our way up to DNSSEC. We explain the first steps taken in DNSSEC and describe how NSEC and NSEC3 work. The NXT, NO, NSEC2, and DNSNR records also briefly make their appearance, as they have paved the way for NSEC and NSEC3.  </t>

<t>To complete the picture, we also need to explain DNS wildcards as these complicate matters, especially when combined with CNAME records.  </t>
<t>Note: In this document, domain names in zone file examples will have a trailing dot, but in the running text they will not. This text is written for people who have a fair understanding of DNSSEC. The following RFCs are not required reading, but they help in understanding the problem space.  </t><t><list style="symbols">
<t><xref target="RFC5155"/> -- DNS Security (DNSSEC) Hashed Authenticated Denial of Existence; </t>
<t><xref target="RFC4592"/> -- The Role of Wildcards in the Domain Name System.  </t></list></t>
<t>And, these provide some general DNSSEC information.  </t>
<t><list style="symbols">
<t><xref target="RFC4033"/>, <xref target="RFC4034"/>, and <xref target="RFC4035"/> -- DNSSEC specifications; </t>
<t><xref target="RFC4956"/> -- DNS Security (DNSSEC) Opt-In. This RFC has an Experimental status but is a good read.  </t></list></t><t>These three documents give some background information on the NSEC3 development.  </t>
<t><list style="symbols">
<t>The NO record <xref target="DNSEXT" pageno="false" format="default"/>; 
</t>
<t>The NSEC2 record <xref target="DNSEXT-NSEC2" pageno="false" format="default"/>; </t>
<t>The DNSNR record <xref target="DNSNR-RR" pageno="false" format="default"/>.  </t></list></t></section>

<section title="Denial of Existence" anchor="denial-of-existence" toc="default"><t>We start with the basics and take a look at NXDOMAIN handling in the DNS. To make it more visible, we are going to use a small DNS zone with three names (<spanx style="verb" xml:space="preserve">example.org</spanx>, <spanx style="verb" xml:space="preserve">a.example.org</spanx>, and <spanx style="verb" xml:space="preserve">d.example.org</spanx>) and four types (SOA, NS, A, and TXT). For brevity, the class is not shown (defaults to IN) and the SOA record is shortened, resulting in the following zone file: </t>

<figure anchor="fig:the-unsigned" align="center" title="The Unsigned &quot;example.org&quot; Zone" suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
example.org.        SOA ( ... )
example.org.        NS  a.example.org.
a.example.org.      A 192.0.2.1
                    TXT "a record"
d.example.org.      A 192.0.2.1
                    TXT "d record"
</artwork></figure><t></t><section title="NXDOMAIN Responses" anchor="nxdomain-responses" toc="default"><t>If a resolver asks the name server serving this zone for the TXT type belonging to <spanx style="verb" xml:space="preserve">a.example.org</spanx>, it sends the following question: <spanx style="verb" xml:space="preserve">a.example.org TXT</spanx>. </t>

<t>The name server looks in its zone data and generates an answer. In this case, a positive one: "Yes, it exists and this is the data", resulting in this reply: </t>

<figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
;; status: NOERROR, id: 28203

;; ANSWER SECTION:
a.example.org.      TXT "a record"

;; AUTHORITY SECTION:
example.org.        NS a.example.org.
</artwork></figure><t>The <spanx style="verb" xml:space="preserve">status: NOERROR</spanx> signals that everything is OK, and the <spanx style="verb" xml:space="preserve">id</spanx> is an integer used to match questions and answers. In the ANSWER section, we find our answer. The AUTHORITY section holds the names of the name servers that have information concerning the <spanx style="verb" xml:space="preserve">example.org</spanx> zone.  Note that including this information is optional.  </t>

<t>If a resolver asks for <spanx style="verb" xml:space="preserve">b.example.org TXT</spanx>, it gets an answer that this name does not exist: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
;; status: NXDOMAIN, id: 7042

;; AUTHORITY SECTION:
example.org.        SOA ( ... )
</artwork></figure><t>In this case, we do not get an ANSWER section, and the status is set to NXDOMAIN. From this, the resolver concludes that <spanx style="verb" xml:space="preserve">b.example.org</spanx> does not exist. The AUTHORITY section holds the SOA record of <spanx style="verb" xml:space="preserve">example.org</spanx> that the resolver can use to cache the negative response.  </t></section>

<section title="NODATA Responses" anchor="nodata-responses" toc="default"><t>It is important to realize that NXDOMAIN is not the only type of does-not-exist response. A name may exist, but the type you are asking for may not. This occurrence of nonexistence is called a NODATA response. Let us ask our name server for <spanx style="verb" xml:space="preserve">a.example.org AAAA</spanx> and look at the answer: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
;; status: NOERROR, id: 7944

;; AUTHORITY SECTION:
example.org.        SOA ( ... )
</artwork></figure><t>The status NOERROR shows that the <spanx style="verb" xml:space="preserve">a.example.org</spanx> name exists, but the reply does not contain an ANSWER section.  This differentiates a NODATA response from an NXDOMAIN response; the rest of the packet is very similar. The resolver has to put these pieces of information together and conclude that <spanx style="verb" xml:space="preserve">a.example.org</spanx> exists, but it does not have a <spanx style="verb" xml:space="preserve">AAAA</spanx> record.  </t></section></section>

<section title="Secure Denial of Existence" anchor="secure-denial-of-existence" toc="default"><t>The above has to be translated to the security-aware world of DNSSEC. But, there are a few principles DNSSEC brings to the table: </t>

<t><list style="numbers"><t>A name server is free to compute the answer and signature(s) on&nbhy;the-fly, but the protocol is written with a "first sign, then load" attitude in mind. It is rather asymmetrical, but a lot of the design in DNSSEC stems from fact that you need to accommodate authenticated denial of existence. If the DNS did not have NXDOMAIN, DNSSEC would be a lot simpler, but a lot less useful! </t>

<t>The DNS packet header is not signed. This means that a <spanx style="verb" xml:space="preserve">status: NXDOMAIN</spanx> cannot be trusted. In fact, the entire header may be forged, including the AD bit (AD stands for Authentic Data; see <xref target="RFC3655" pageno="false" format="default"/>), which may give some food for thought; </t>

<t>DNS wildcards and CNAME records complicate matters significantly. See more about this later in Sections <xref target="wildcards-in-the-dns" format="counter"/> and <xref target="cname-records" format="counter"/>.  </t></list></t>

<t>The first principle implies that all denial-of-existence answers need to be precomputed, but it is impossible to precompute (all conceivable) nonexistence answers.  </t>


<t>A generic denial record that can be used in all denial-of-existence proofs is not an option: such a record is susceptible to replay attacks. When you are querying a name server for any record that actually exists, a man in the middle could replay that generic denial record that is unlimited in its scope, and it would be impossible to tell whether the response was genuine or spoofed. In other words, the generic record can be replayed to falsely deny <spanx style="emph" xml:space="preserve">all</spanx> possible responses.  </t>

<t>We could also use the QNAME in the answer and sign that, essentially signing an NXDOMAIN response. While this approach could have worked technically, it is incompatible with offline signing.  </t>

<t>The way this has been solved is by introducing a record that defines an interval between two existing names. Or, to put it another way, it defines the holes (nonexisting names) in the zone. This record can be signed beforehand and given to the resolver.  Appendices <xref target="on-line-signing-minimally-covering-nsec-records" format="counter"/> and <xref target="on-line-signing-nsec3-white-lies" format="counter"/> describe online signing techniques that are compatible with this scheme.  </t>

<t><list style="empty"><t>Given all these troubles, why didn't the designers of DNSSEC go for the easy route and allow for online signing? Well, at that time (pre 2000), online signing was not feasible with the then-current hardware. Keep in mind that the larger servers get between 2000 and 6000 queries per second (qps), with peaks up to 20,000 qps or more. Scaling signature generation to these kind of levels is always a challenge. Another issue was (and is) key management.  For online signing to work, <spanx style="emph" xml:space="preserve">each</spanx> authoritative name server needs access to the private key(s). This is considered a security risk. Hence, the protocol is required not to rely on on&nbhy;line signing.  </t></list></t>

<t>The road to the current solution (NSEC/NSEC3) was long. It started with the NXT (next) record. The NO (not existing) record was introduced, but it never made it into an RFC. Later on, NXT was superseded by the NSEC (next secure) record. From there, it went through NSEC2/DNSNR to finally reach NSEC3 (Next SECure version 3) in RFC 5155.  </t>

<section title="NXT" anchor="nxt" toc="default"><t>The first attempt to specify authenticated denial of existence was NXT (<xref target="RFC2535" pageno="false" format="default"/>). Section 5.1 of RFC 2535 introduces the record: </t>

<t><list style="empty"><t>The NXT resource record is used to securely indicate that RRs with an owner name in a certain name interval do not exist in a zone and to indicate what RR types are present for an existing name.</t></list></t>

<t>By specifying what you do have, you implicitly tell what you don't have. NXT is superseded by NSEC. In the next section, we explain how NSEC (and thus NXT) works.  </t></section>

<section title="NSEC" anchor="nsec" toc="default"><t>In <xref target="RFC3755"/>, all the DNSSEC types were given new names: SIG was renamed RRSIG, KEY became DNSKEY, and NXT was renamed NSEC, and a minor issue was fixed in the process, namely the type bitmap was redefined to allow more than 127 types to be listed (<xref target="RFC2535"/>, Section 5.2).  </t>

<t>Just as NXT, NSEC is used to describe an interval between names: it indirectly tells a resolver which names do not exist in a zone.  </t>

<t>For this to work, we need our <spanx style="verb" xml:space="preserve">example.org</spanx> zone to be sorted in canonical order (<xref target="RFC4034" pageno="false" format="default"/>, Section 6.1), and then create the NSECs. We add three NSEC records, one for each name, and each one covers a certain interval. The last NSEC record points back to the first as required by RFC 4034 and depicted in <xref target="fig:the-nsec-r" pageno="false" format="default"/>.  </t>

<t><list style="numbers"><t>The first NSEC covers the interval between <spanx style="verb" xml:space="preserve">example.org</spanx> and <spanx style="verb" xml:space="preserve">a.example.org</spanx>; </t><t>The second NSEC covers <spanx style="verb" xml:space="preserve">a.example.org</spanx> to <spanx style="verb" xml:space="preserve">d.example.org</spanx>; </t>

<t>The third NSEC points back to <spanx style="verb" xml:space="preserve">example.org</spanx> and covers <spanx style="verb" xml:space="preserve">d.example.org</spanx> to <spanx style="verb" xml:space="preserve">example.org</spanx> (i.e., the end of the zone).  </t></list></t>

<t>As we have defined the intervals and put those in resource records, we now have something that can be signed.  </t><figure anchor="fig:the-nsec-r" align="center" title="The NSEC records of &quot;example.org&quot;. The arrows represent NSEC records, starting from the apex." suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
                    example.org
                       **
                   +-- ** &lt;--+
              (1) /  .    .   \ (3)
                 /  .      .   \
                |  .        .  |
                v .          . |
                **    (2)     **
  a.example.org ** ---------&gt; ** d.example.org
</artwork></figure><t></t>

<t>This signed zone is loaded into the name server. It looks like this: </t><figure anchor="fig:the-signed" align="center" title="The signed and sorted &quot;example.org&quot; zone with the added NSEC records (and signatures). For brevity, the class is not shown (defaults to IN) and the SOA, DNSKEY, and RRSIG records are shortened." suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
example.org.        SOA ( ... )
                    DNSKEY ( ... )
                    NS  a.example.org.
                    NSEC a.example.org. NS SOA RRSIG NSEC DNSKEY
                    RRSIG(NS) ( ... )
                    RRSIG(SOA) ( ... )
                    RRSIG(NSEC) ( ... )
                    RRSIG(DNSKEY) ( ... )
a.example.org.      A 192.0.2.1
                    TXT "a record"
                    NSEC d.example.org. A TXT RRSIG NSEC
                    RRSIG(A) ( ... )
                    RRSIG(TXT) ( ... )
                    RRSIG(NSEC) ( ... )
d.example.org.      A 192.0.2.1
                    TXT "d record"
                    NSEC example.org. A TXT RRSIG NSEC
                    RRSIG(A) ( ... )
                    RRSIG(TXT) ( ... )
                    RRSIG(NSEC) ( ... )
</artwork></figure><t></t>

<t>If a DNSSEC-aware resolver asks for <spanx style="verb" xml:space="preserve">b.example.org</spanx>, it gets back a <spanx style="verb" xml:space="preserve">status: NXDOMAIN</spanx> packet, which by itself is meaningless (remember that the DNS packet header is not signed and thus can be forged). To be able to securely detect that <spanx style="verb" xml:space="preserve">b</spanx> does not exist, there must also be a signed NSEC record that covers the name space where <spanx style="verb" xml:space="preserve">b</spanx> lives. The record: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
a.example.org.      NSEC d.example.org. A TXT RRSIG NSEC
</artwork></figure>

<t>does precisely that: <spanx style="verb" xml:space="preserve">b</spanx> should come after <spanx style="verb" xml:space="preserve">a</spanx>, but the next owner name is <spanx style="verb" xml:space="preserve">d.example.org</spanx>, so <spanx style="verb" xml:space="preserve">b</spanx> does not exist.  </t>

<t>Only by making that calculation is a resolver able to conclude that the name <spanx style="verb" xml:space="preserve">b</spanx> does not exist. If the signature of the NSEC record is valid, <spanx style="verb" xml:space="preserve">b</spanx> is proven not to exist. We have authenticated denial of existence. A similar NSEC record needs to be included to deny wildcard expansion, see <xref target="wildcards-in-the-dns"/>. </t>

<t>Note that a man in the middle may still replay this NXDOMAIN response when you're querying for, say, <spanx style="verb" xml:space="preserve">c.example.org</spanx>. But, it would not do any harm since it is provable that this is the proper response to the query.  </t></section>


<section title="NODATA Responses" anchor="nodata-responses-1" toc="default">
<t>NSEC records are also used in NODATA responses. In that case, we need to look more closely at the type bitmap. The type bitmap in an NSEC record tells which types are defined for a name. If we look at the NSEC record of <spanx style="verb" xml:space="preserve">a.example.org</spanx>, we see the following types in the bitmap: A, TXT, NSEC, and RRSIG. So, for the name <spanx style="verb" xml:space="preserve">a</spanx>, this indicates we must have an A, TXT, NSEC, and RRSIG record in the zone.  </t>

<t>With the type bitmap of the NSEC record, a resolver can establish that a name is there, but the type is not. For example, if a resolver asks for <spanx style="verb" xml:space="preserve">a.example.org AAAA</spanx>, the reply that comes back is: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
;; status: NOERROR, id: 44638

;; AUTHORITY SECTION:
example.org.        SOA ( ... )
example.org.        RRSIG(SOA) ( ... )
a.example.org.      NSEC d.example.org. A TXT RRSIG NSEC
a.example.org.      RRSIG(NSEC) ( ... )
</artwork></figure>

<t>The resolver should check the AUTHORITY section and conclude that: </t>

<t><list style="format (%d)"><t><spanx style="verb" xml:space="preserve">a.example.org</spanx> exists (because of the NSEC with that owner name); and </t>

<t>the type (AAAA) does not exist as it is not listed in the type bitmap.  </t></list></t>

<t>The techniques used by NSEC form the basics of authenticated denial of existence in DNSSEC.  </t></section>

<section title="Drawbacks of NSEC" anchor="drawbacks-of-nsec" toc="default">
<t>There were two issues with NSEC (and NXT). The first is that it allows for zone walking. NSEC records point from one name to another; in our example: <spanx style="verb" xml:space="preserve">example.org</spanx> points to <spanx style="verb" xml:space="preserve">a.example.org</spanx>, which points to <spanx style="verb" xml:space="preserve">d.example.org</spanx>, which points back to <spanx style="verb" xml:space="preserve">example.org</spanx>. So, we can reconstruct the entire <spanx style="verb" xml:space="preserve">example.org</spanx> zone, thus defeating attempts to administratively block zone transfers (<xref target="RFC2065"/>, Section 5.5).  </t>

<t>The second issue is that when a large, delegation-centric (<xref target="RFC5155"/>, Section 1.1) zone deploys DNSSEC, every name in the zone gets an NSEC plus RRSIG. So, this leads to a huge increase in the zone size (when signed). This would in turn mean that operators of such zones who are deploying DNSSEC face up-front costs. This could hinder DNSSEC adoption.  </t>

<t>These two issues eventually lead to NSEC3, which: </t>

<t><list style="symbols"><t>Adds a way to garble the owner names thus thwarting zone walking; </t>

<t>Makes it possible to skip names for the next owner name. This feature is called Opt-Out (see <xref target="opt-out" pageno="false" format="default"/>). It means not all names in your zone get an NSEC3 plus ditto signature, making it possible to "grow into" your DNSSEC deployment.  </t></list></t>

<t>Note that there are other ways to mitigate zone walking.  RFC 4470 [RFC4470] prevents zone walking by introducing minimally covering NSEC records. This technique is described in <xref target="on-line-signing-minimally-covering-nsec-records" pageno="false" format="default"/>.  </t>

<t>Before we delve into NSEC3, let us first take a look at its predecessors: NO, NSEC2, and DNSNR.  </t></section></section>

<section title="Experimental and Deprecated Mechanisms: NO, NSEC2, and DNSNR" anchor="experimental-and-deprecated-mechanisms-no-nsec2-and-dnsnr" toc="default"><t>Long before NSEC was defined, the NO record was introduced. It was the first record to use the idea of hashed owner names to fix the issue of zone walking that was present with the NXT record. It also fixed the type bitmap issue of the NXT record, but not in a space-efficient way. At that time (around 2000), zone walking was not considered important enough to warrant the new record. People were also worried that DNSSEC deployment would be hindered by developing an alternate means of denial of existence. Thus, the effort was shelved and NXT remained.  </t>

<t>When the new DNSSEC specification <xref target="RFC4034" pageno="false" format="default"/> was written, people were still not convinced that zone walking was a problem that should be solved. So, NSEC saw the light and inherited the two issues from NXT.  </t>

<t>Several years after, NSEC2 was introduced as a way to solve the two issues of NSEC. The NSEC2 document <xref target="DNSEXT-NSEC2"/> contains the following paragraph: </t>

<t><list style="empty"><t>This document proposes an alternate scheme which hides owner names while permitting authenticated denial of existence of non-existent names. The scheme uses two new RR types: NSEC2 and EXIST. </t></list></t>

<t>When an authenticated denial-of-existence scheme starts to talk about EXIST records, it is worth paying extra attention. The EXIST record was defined as a record without RDATA that would be used to signal the presence of a domain name. From <xref target="DNSEXT-NSEC2"/>: </t>

<t><list style="empty"><t>In order to prove the nonexistence of a record that might be covered by a wildcard, it is necessary to prove the existence of its closest encloser. This record does that. Its owner is the closest encloser. It has no RDATA. If there is another RR that proves the existence of the closest encloser, this SHOULD be used instead of an EXIST record. </t></list></t>

<t>The introduction of this record led to questions about what wildcards actually mean (especially in the context of DNSSEC). It is probably not a coincidence that "The Role of Wildcards in the Domain Name System" <xref target="RFC4592" pageno="false" format="default"/> was standardized before NSEC3 was.  </t>

<t>NSEC2 solved the zone-walking issue by hashing (with SHA1 and a salt) the "next owner name" in the record, thereby making it useless for zone walking. But, it did not have Opt-Out.  </t>

<t>The DNSNR record was another attempt that used hashed names to foil zone walking, and it also introduced the concept of opting out (called "Authoritative Only Flag"), which limited the use of DNSNR in delegation-centric zones.  </t>

<t>All of these proposals didn't make it, but they did provide valuable insights. To summarize: </t><t><list style="symbols"><t>The NO record introduced hashing, but this idea lingered in the background for a long time; </t>

<t>The NSEC2 record made it clear that wildcards were not completely understood; </t>

<t>The DNSNR record used a new flag field in the RDATA to signal Opt-Out. </t></list></t></section>

<section title="NSEC3" anchor="nsec3" toc="default"><t>From the experience gained with NSEC2 and DNSNR, NSEC3 was forged.  It incorporates both Opt-Out and the hashing of names. NSEC3 solves any issues people might have with NSEC, but it introduces some additional complexity.  </t>

<t>NSEC3 did not supersede NSEC; they are both defined for DNSSEC. So, DNSSEC is blessed with two different means to perform authenticated denial of existence: NSEC and NSEC3. In NSEC3, every name is hashed, including the owner name. This means that the NSEC3 chain is sorted in hash order, instead of canonical order. Because the owner names are hashed, the next owner name for <spanx style="verb" xml:space="preserve">example.org</spanx> is unlikely to be <spanx style="verb" xml:space="preserve">a.example.org</spanx>. Because the next owner name is hashed, zone walking becomes more difficult.  </t>

<t>To make it even more difficult to retrieve the original names, the hashing can be repeated several times, each time taking the previous hash as input. To prevent the reuse of pre-generated hash values between zones, a (per-zone) salt can also be added. In the NSEC3 for <spanx style="verb" xml:space="preserve">example.org</spanx>, we have hashed the names thrice (<xref target="RFC5155" pageno="false" format="default"/>, Section 5) and used the salt <spanx style="verb" xml:space="preserve">DEAD</spanx>. Let's look at a typical NSEC3 record: </t>

<figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
15bg9l6359f5ch23e34ddua6n1rihl9h.example.org. (
   NSEC3 1 0 2 DEAD A6EDKB6V8VL5OL8JNQQLT74QMJ7HEB84
        NS SOA RRSIG DNSKEY NSEC3PARAM )
</artwork></figure>

<t>On the first line, we see the hashed owner name: <spanx style="verb" xml:space="preserve">15bg9l6359f5ch23e34ddua6n1rihl9h.example.org</spanx>; this is the hashed name of the fully qualified domain name (FQDN) <spanx style="verb" xml:space="preserve">example.org</spanx> encoded as Base32 <xref target="RFC4648" pageno="false" format="default"/>. Note that even though we hashed <spanx style="verb" xml:space="preserve">example.org</spanx>, the zone's name is added to make it look like a domain name again. In our zone, the basic format is <spanx style="verb" xml:space="preserve">Base32(SHA1(FQDN)).example.org</spanx>. The next hashed owner name <spanx style="verb" xml:space="preserve">A6EDKB6V8VL5OL8JNQQLT74QMJ7HEB84</spanx> (line 2) is the hashed version of <spanx style="verb" xml:space="preserve">d.example.org</spanx>, represented as Base32. Note that <spanx style="verb" xml:space="preserve">d.example.org</spanx> is used as the next owner name because in the hash ordering, its hash comes after the hash of the zone's apex. Also, note that <spanx style="verb" xml:space="preserve">.example.org</spanx> is not added to the next hashed owner name, as this name always falls in the current zone.  </t>


<t>The "1 0 2 DEAD" segment of the NSEC3 states: </t>

<t><list style="symbols"><t>Hash Algorithm = 1 (SHA1 is the default; no other hash algorithms are currently defined for use in NSEC3; see Section 3.1.1 of <xref target="RFC5155"/>); </t><t>Opt-Out = 0 (disabled; see Section 6 of <xref target="RFC5155"/>); </t>
<t>Hash Iterations = 2 (this yields three iterations, as a zero value is already one iteration; see Section 3.1.3 of <xref target="RFC5155"/>); </t><t>Salt = "DEAD" (see Section 3.1.5 of <xref target="RFC5155"/>.  </t></list></t>

<t>At the end, we see the type bitmap, which is identical to NSEC's bitmap, that lists the types present at the original owner name.  Note that the type NSEC3 is absent from the list in the example above. This is due to the fact that the original owner name (<spanx style="verb" xml:space="preserve">example.org</spanx>) does not have the NSEC3 type. It only exists for the hashed name.  </t>

<t>Names like <spanx style="verb" xml:space="preserve">1.h.example.org</spanx> hash to one label in NSEC3 and "1.h.example.org" becomes: <spanx style="verb" xml:space="preserve">117gercprcjgg8j04ev1ndrk8d1jt14k.example.org</spanx> when used as an owner name. This is an important observation. By hashing the names, you lose the depth of a zone -- hashing introduces a flat space of names, as opposed to NSEC.  </t>

<t>The name used above (<spanx style="verb" xml:space="preserve">1.h.example.org</spanx>) creates an empty non-terminal. Empty non-terminals are domain names that have no RRs associated with them and exist only because they have one or more subdomains that do (<xref target="RFC5155" pageno="false" format="default"/>, Section 1.3). The record: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
    1.h.example.org.    TXT "1.h record"
</artwork></figure><t>creates two names: </t>

<t><list style="numbers"><t><spanx style="verb" xml:space="preserve">1.h.example.org</spanx> that has the type: TXT; </t>

<t><spanx style="verb" xml:space="preserve">h.example.org</spanx>, which has no types. This is the empty non-terminal.  </t></list></t>

<t>An empty non-terminal will get an NSEC3 record but not an NSEC record. In <xref target="the-closest-encloser-nsec3-record"/>, how the resolver uses these NSEC3 records to validate the denial-of-existence proofs is shown.  </t>

<t>Note that NSEC3 might not always be useful. For example, highly structured zones, like the reverse zones ip6.arpa and in-addr.arpa, can be walked even with NSEC3 due to their structure. Also, the names in small, trivial zones can be easily guessed. In these cases, it does not help to defend against zone walking, but it does add the computational load on authoritative servers and validators.  </t>

<section title="Opt-Out" anchor="opt-out" toc="default"><t>Hashing mitigates the zone-walking issue of NSEC. The other issue, the high costs of securing a delegation to an insecure zone, is tackled with Opt-Out.  When using Opt-Out, names that are an insecure delegation (and empty non-terminals that are only derived from insecure delegations) don't require an NSEC3 record. For each insecure delegation, the zone size can be decreased (compared with a fully signed zone without using Opt-Out) with at least two records: one NSEC3 record and one corresponding RRSIG record. If the insecure delegation would introduce empty non-terminals, even more records can be omitted from the zone.  </t>

<t>Opt-Out NSEC3 records are not able to prove or deny the existence of the insecure delegations. In other words, those delegations do not benefit from the cryptographic security that DNSSEC provides.  </t>

<t>A recently discovered corner case (see RFC Errata ID 3441 <xref target="Err3441"/>) shows that not only those delegations remain insecure but also the empty non-terminal space that is derived from those delegations. Because the names in this empty non-terminal space do exist according to the definition in <xref target="RFC4592" pageno="false" format="default"/>, the server should respond to queries for these names with a NODATA response.  However, the validator requires an NSEC3 record proving the NODATA response (<xref target="RFC5155" pageno="false" format="default"/>, Section 8.5): </t>

<t><list style="empty"><t>The validator MUST verify that an NSEC3 RR that matches QNAME is present and that both the QTYPE and the CNAME type are not set in its Type Bit Maps field.</t></list></t>

<t>A way to resolve this contradiction in the specification is to always provide empty non-terminals with an NSEC3 record, even if it is only derived from an insecure delegation.  </t></section>

<section title="Loading an NSEC3 Zone" anchor="loading-an-nsec3-zone" toc="default"><t>Whenever an authoritative server receives a query for a non-existing record, it has to hash the incoming query name to determine into which interval between two existing hashes it falls. To do that, it needs to know the zone's specific NSEC3 parameters (hash iterations and salt).  </t>

<t>One way to learn them is to scan the zone during loading for NSEC3 records and glean the NSEC3 parameters from them. However, it would need to make sure that there is at least one complete set of NSEC3 records for the zone using the same parameters. Therefore, it would need to inspect all NSEC3 records.  </t>

<t>A more graceful solution was designed. The solution was to create a new record, NSEC3PARAM, which must be placed at the apex of the zone. Its role is to provide a fixed place where an authoritative name server can directly see the NSEC3 parameters used, and by putting it in the zone, it allows for easy transfer to the secondaries. </t></section>

<section title="Wildcards in the DNS" anchor="wildcards-in-the-dns" toc="default"><t>So far, we have only talked about denial of existence in negative responses. However, denial of existence may also occur in positive responses, i.e., where the ANSWER section of the response is not empty. This can happen because of wildcards.  </t>

<t>Wildcards have been part of the DNS since the first DNS RFCs. They allow to define all names for a certain type in one go. In our <spanx style="verb" xml:space="preserve">example.org</spanx> zone, we could, for instance, add a wildcard record: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
*.example.org.      TXT "wildcard record"
</artwork></figure>

<t>For completeness, our (unsigned) zone now looks like this: </t><figure anchor="fig:the-exampl" align="center" title="The example.org Zone with a Wildcard Record" suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
example.org.        SOA ( ... )
example.org.        NS  a.example.org.
*.example.org.      TXT "wildcard record"
a.example.org.      A 192.0.2.1
                    TXT "a record"
d.example.org.      A 192.0.2.1
                    TXT "d record"
</artwork></figure><t></t><t>If a resolver asks for <spanx style="verb" xml:space="preserve">z.example.org TXT</spanx>, the name server will respond with an expanded wildcard instead of an NXDOMAIN: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
;; status: NOERROR, id: 13658

;; ANSWER SECTION:
z.example.org.      TXT "wildcard record"
</artwork></figure><t>Note, however, that the resolver cannot detect that this answer came from a wildcard. It just sees the answer as is. How will this answer look with DNSSEC? </t>

<figure anchor="fig:a-response" align="center" title="A Response with an Expanded Wildcard and DNSSEC" suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
;; status: NOERROR, id: 51790

;; ANSWER SECTION:
z.example.org.      TXT "wildcard record"
z.example.org.      RRSIG(TXT) ( ... )

;; AUTHORITY SECTION:
d.example.org.      NSEC example.org. A TXT RRSIG NSEC
d.example.org.      RRSIG(NSEC) ( ... )
</artwork></figure><t></t>

<t>The RRSIG of the <spanx style="verb" xml:space="preserve">z.example.org</spanx> TXT record indicates there is a wildcard configured. The RDATA of the signature lists a label count, <xref target="RFC4034" pageno="false" format="default"/>, Section 3.1.3., of two (not visible in the figure above), but the owner name of the signature has three labels. This mismatch indicates there is a wildcard <spanx style="verb" xml:space="preserve">*.example.org</spanx> configured.  </t>

<t><list style="empty"><t>An astute reader may notice that it appears as if a <spanx style="verb" xml:space="preserve">z.example.org</spanx> RRSIG(TXT) is created out of thin air. This is not the case. The signature for <spanx style="verb" xml:space="preserve">z.example.org</spanx> does not exist. The signature you are seeing is the one for <spanx style="verb" xml:space="preserve">*.example.org</spanx>, which does exist; only the owner name is switched to <spanx style="verb" xml:space="preserve">z.example.org</spanx>. So, even with wildcards, no signatures have to be created on the fly.  </t></list></t>

<t>The DNSSEC standard mandates that an NSEC (or NSEC3) is included in such responses. If it wasn't, an attacker could mount a replay attack and poison the cache with false data.  Suppose that the resolver has asked for <spanx style="verb" xml:space="preserve">a.example.org TXT</spanx>. An attacker could modify the packet in such way that it looks like the response was generated through wildcard expansion, even though a record exists for <spanx style="verb" xml:space="preserve">a.example.org TXT</spanx>.  </t>

<t>The tweaking simply consists of adjusting the ANSWER section to: </t><figure anchor="fig:a-forged-r" align="center" title="A Forged Response without the Expanded Wildcard" suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
;; status: NOERROR, id: 31827

;; ANSWER SECTION:
a.example.org.      TXT "wildcard record"
a.example.org.      RRSIG(TXT) ( ... )
</artwork></figure><t></t><t>Note the subtle difference from <xref target="fig:a-response" pageno="false" format="default"/> in the owner name. In this response, we see a <spanx style="verb" xml:space="preserve">a.example.org TXT</spanx> record for which a record with different RDATA (see <xref target="fig:the-exampl" pageno="false" format="default"/>) exists in the zone.  </t>

<t>That would be a perfectly valid answer if we would not require the inclusion of an NSEC or NSEC3 record in the wildcard answer response. The resolver believes that <spanx style="verb" xml:space="preserve">a.example.org TXT</spanx> is a wildcard record, and the real record is obscured. This is bad and defeats all the security DNSSEC can deliver. Because of this, the NSEC or NSEC3 must be present.  </t>


<t>Another way of putting this is that DNSSEC is there to ensure the name server has followed the steps as outlined in <xref target="RFC1034" pageno="false" format="default"/>, Section 4.3.2 for looking up names in the zone. It explicitly lists wildcard lookup as one of these steps (3c), so with DNSSEC this must be communicated to the resolver: hence, the NSEC or NSEC3 record.  </t></section>

<section title="CNAME Records" anchor="cname-records" toc="default"><t>So far, the maximum number of NSEC records a response will have is two: one for the denial of existence and another for the wildcard.  We say maximum because sometimes a single NSEC can prove both.  With NSEC3, this is three (as to why, we will explain in the next section).  </t>

<t>When we take CNAME wildcard records into account, we can have more NSEC or NSEC3 records. For every wildcard expansion, we need to prove that the expansion was allowed. Let's add some CNAME wildcard records to our zone: </t><figure anchor="fig:a-wildcard-" align="center" title="A Wildcard CNAME Chain Added to the &quot;example.org&quot; Zone" suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">

example.org.        SOA ( ... )
example.org.        NS  a.example.org.
*.example.org.      TXT "wildcard record"
a.example.org.      A 192.0.2.1
                    TXT "a record"
*.a.example.org.    CNAME w.b
*.b.example.org.    CNAME w.c
*.c.example.org.    A 192.0.2.1
d.example.org.      A 192.0.2.1
                    TXT "d record"
w.example.org.      CNAME w.a
</artwork></figure><t></t>

<t>A query for <spanx style="verb" xml:space="preserve">w.example.org A</spanx> will result in the following response: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
;; status: NOERROR, id: 4307

;; ANSWER SECTION:
w.example.org.      CNAME w.a.example.org.
w.example.org.      RRSIG(CNAME) ( ... )
w.a.example.org.    CNAME w.b.example.org.
w.a.example.org.    RRSIG(CNAME) ( ... )
w.b.example.org.    CNAME w.c.example.org.
w.b.example.org.    RRSIG(CNAME) ( ... )
w.c.example.org.    A 192.0.2.1
w.c.example.org.    RRSIG(A) ( ... )

;; AUTHORITY SECTION:
*.a.example.org.    NSEC *.b.example.org. CNAME RRSIG NSEC
*.a.example.org.    RRSIG(NSEC) ( ... )
*.b.example.org.    NSEC *.c.example.org. CNAME RRSIG NSEC
*.b.example.org.    RRSIG(NSEC) ( ... )
*.c.example.org.    NSEC d.example.org. A RRSIG NSEC
*.c.example.org.    RRSIG(NSEC) ( ... )
</artwork></figure>

<t>The NSEC record <spanx style="verb" xml:space="preserve">*.a.example.org</spanx> proves that wildcard expansion to <spanx style="verb" xml:space="preserve">w.a.example.org</spanx> was appropriate: <spanx style="verb" xml:space="preserve">w.a.</spanx> falls in the gap <spanx style="verb" xml:space="preserve">*.a</spanx> to <spanx style="verb" xml:space="preserve">*.b</spanx>. Similarly, the NSEC record <spanx style="verb" xml:space="preserve">*.b.example.org</spanx> proves that there was no direct match for <spanx style="verb" xml:space="preserve">w.b.example.org</spanx> and <spanx style="verb" xml:space="preserve">*.c.example.org</spanx> denies the direct match for <spanx style="verb" xml:space="preserve">w.c.example.org</spanx>.  </t>

<t>DNAME records and wildcard names should not be used as reiterated in <xref target="RFC6672" pageno="false" format="default"/>, Section 3.3.  </t></section>

<section title="The Closest Encloser NSEC3 Record" anchor="the-closest-encloser-nsec3-record" toc="default"><t>We can have one or more NSEC3 records that deny the existence of the requested name and one NSEC3 record that denies wildcard synthesis. What do we miss? </t>

<t>The short answer is that due to the hashing in NSEC3, you lose the depth of your zone and everything is hashed into a flat plane. To make up for this loss of information, you need an extra record.  </t>

<t>To understand NSEC3, we will need two definitions: </t>

<t><list style="hanging"><t hangText="Closest encloser:">Introduced in <xref target="RFC4592" pageno="false" format="default"/> as: 
<vspace blankLines="1"/>The closest encloser is the node in the zone's tree of existing domain names that has the most labels matching the query name (consecutively, counting from the root label downward).
<vspace blankLines="1" /> In our example, if the query name is <spanx style="verb" xml:space="preserve">x.2.example.org</spanx>, then <spanx style="verb" xml:space="preserve">example.org</spanx> is the <spanx style="verb" xml:space="preserve">closest encloser</spanx>; </t>

<t hangText="Next closer name:">Introduced in <xref target="RFC5155" pageno="false" format="default"/>, this is the closest encloser with one more label added to the left. So, if <spanx style="verb" xml:space="preserve">example.org</spanx> is the closest encloser for the query name <spanx style="verb" xml:space="preserve">x.2.example.org</spanx>, <spanx style="verb" xml:space="preserve">2.example.org</spanx> is the <spanx style="verb" xml:space="preserve">next closer name</spanx>.  </t></list></t>

<t>An NSEC3 <spanx style="verb" xml:space="preserve">closest encloser proof</spanx> consists of: </t>

<t><list style="numbers"><t>An NSEC3 record that <spanx style="strong" xml:space="preserve">matches</spanx> the <spanx style="verb" xml:space="preserve">closest encloser</spanx>. This means the unhashed owner name of the record is the closest encloser. This bit of information tells a resolver: "The name you are asking for does not exist; the closest I have is this".  </t>

<t>An NSEC3 record that <spanx style="strong" xml:space="preserve">covers</spanx> the <spanx style="verb" xml:space="preserve">next closer name</spanx>. This means it defines an interval in which the <spanx style="verb" xml:space="preserve">next closer name</spanx> falls. This tells the resolver: "The next closer name falls in this interval, and therefore the name in your question does not exist. In fact, the closest encloser is indeed the closest I have".  </t></list></t>

<t>These two records already deny the existence of the requested name, so we do not need an NSEC3 record that covers the actual queried name.  By denying the existence of the next closer name, you also deny the existence of the queried name.  </t>

<t>Note that with NSEC, the existence of all empty non-terminals between the two names are denied, hence it implicitly contains the closest encloser.  </t>

<t>For a given query name, there is one (and only one) place where wildcard expansion is possible. This is the <spanx style="verb" xml:space="preserve">source of synthesis</spanx> and is defined (<xref target="RFC4592" pageno="false" format="default"/>, Sections 2.1.1 and 3.3.1) as: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
&lt;asterisk label&gt;.&lt;closest encloser&gt;
</artwork></figure>

<t>In other words, to deny wildcard synthesis, the resolver needs to know the hash of the source of synthesis. Since it does not know beforehand what the closest encloser of the query name is, it must be provided in the answer.  </t>

<t> Take the following example.  We have a zone with two TXT records
 to it.  The records added are "1.h.example.org" and
 "3.3.example.org".  It is signed with NSEC3, resulting in the
 following unsigned zone:</t>

<figure anchor="fig:the-added-txt" align="center" title="The TXT records in example.org. These records create two empty non-terminals: h.example.org and 3.example.org." suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
 example.org.        SOA ( ... )
 example.org.        NS  a.example.org.
 1.h.example.org.    TXT "1.h record"
 3.3.example.org.    TXT "3.3 record"
</artwork></figure><t></t>

<t>The resolver asks the following: <spanx style="verb" xml:space="preserve">x.2.example.org TXT</spanx>. This leads to an NXDOMAIN response from the server, which contains three NSEC3 records. A list of hashed owner names can be found in <xref target="list-of-hashed-owner-names" pageno="false" format="default"/>. Also, see <xref target="fig:x.2.exampl"/>; the numbers in that figure correspond with the following NSEC3 records: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
15bg9l6359f5ch23e34ddua6n1rihl9h.example.org. (
 NSEC3 1 0 2 DEAD 1AVVQN74SG75UKFVF25DGCETHGQ638EK NS SOA RRSIG
        DNSKEY NSEC3PARAM )

1avvqn74sg75ukfvf25dgcethgq638ek.example.org. (
    NSEC3 1 0 2 DEAD 75B9ID679QQOV6LDFHD8OCSHSSSB6JVQ )

75b9id679qqov6ldfhd8ocshsssb6jvq.example.org. (
 NSEC3 1 0 2 DEAD 8555T7QEGAU7PJTKSNBCHG4TD2M0JNPJ TXT RRSIG )
</artwork></figure>

<t>If we would follow the NSEC approach, the resolver is only interested in one thing. Does the hash of <spanx style="verb" xml:space="preserve">x.2.example.org</spanx> fall in any of the intervals of the NSEC3 records it got? </t>

<figure anchor="fig:x.2.exampl" align="center" title="&quot;x.2.example.org&quot; does not exist. The five arrows represent the NSEC3 records; the ones numbered (1), (2), and (3) are the NSEC3s returned in our answer. &quot;2.example.org&quot; is covered by (3) and &quot;x.2.example.org&quot; is covered by (4)." suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
                    example.org
                       **
                   +-- ** . . . . . . . . . . .
              (1) /  . ^ .                     .
                 /  .  |   .                    .
                |  .   |    .                    .
                v .    |     .                    .
                **     | (2)  **                  ++
  h.example.org ** ----+----&gt; ** 3.example.org    ++ 2.example.org
                .     /        . |                .
                .    / (5)     . | (3)            .
                .   /          . |                .
                .  /           . v                .
1.h.example.org **            **                  ++
                ** &lt;--------- ** 3.3.example.org  ++ x.2.example.org
                         (4)
</artwork></figure><t></t>

<t>The hash of <spanx style="verb" xml:space="preserve">x.2.example.org</spanx> is <spanx style="verb" xml:space="preserve">ndtu6dste50pr4a1f2qvr1v31g00i2i1</spanx>. 


Checking this hash on the first NSEC3 yields that it does not fall in between the interval: <spanx style="verb" xml:space="preserve">15bg9l6359f5ch23e34ddua6n1rihl9h</spanx> to <spanx style="verb" xml:space="preserve">1avvqn74sg75ukfvf25dgcethgq638ek</spanx>. For the second NSEC3, the answer is also negative: the hash sorts outside the interval described by <spanx style="verb" xml:space="preserve">1avvqn74sg75ukfvf25dgcethgq638ek</spanx> and <spanx style="verb" xml:space="preserve">75b9id679qqov6ldfhd8ocshsssb6jvq</spanx>. And, the third NSEC3, with interval <spanx style="verb" xml:space="preserve">75b9id679qqov6ldfhd8ocshsssb6jvq</spanx> to <spanx style="verb" xml:space="preserve">8555t7qegau7pjtksnbchg4td2m0jnpj</spanx> also isn't of any help.  </t><t>What is a resolver to do? It has been given the maximum amount of NSEC3s and they all seem useless.  </t>

<t>So, this is where the closest encloser proof comes into play. And, for the proof to work, the resolver needs to know what the closest encloser is. There must be an existing ancestor in the zone: a name must exist that is shorter than the query name. The resolver keeps hashing increasingly shorter names from the query name until an owner name of an NSEC3 matches. This owner name is the closest encloser.  </t>

<t>When the resolver has found the closest encloser, the next step is to construct the next closer name. This is the closest encloser with the last chopped label from the query name prepended to it: "&lt;last chopped label&gt;.&lt;closest encloser&gt;".  The hash of this name should be covered by the interval set in any of the NSEC3 records.  </t>

<t>Then, the resolver needs to check the presence of a wildcard. It creates the wildcard name by prepending the asterisk label to the closest encloser, "*.&lt;closest encloser&gt;", and uses the hash of that.  </t>

<t>Going back to our example, the resolver must first detect the NSEC3 that matches the closest encloser. It does this by chopping up the query name, hashing each instance (with the same number of iterations and hash as the zone it is querying), and comparing that to the answers given. So, it has the following hashes to work with: </t>

<t><list style="hanging"><t hangText="x.2.example.org:"><spanx style="verb" xml:space="preserve">ndtu6dste50pr4a1f2qvr1v31g00i2i1</spanx>, last chopped label: "&lt;empty&gt;"; </t>

<t hangText="2.example.org:"><spanx style="verb" xml:space="preserve">7t70drg4ekc28v93q7gnbleopa7vlp6q</spanx>, last chopped label: "x"; </t>

<t hangText="example.org:"><spanx style="verb" xml:space="preserve">15bg9l6359f5ch23e34ddua6n1rihl9h</spanx>, last chopped label: "2". </t></list></t>

<t>Of these hashes, only one matches the owner name of one of the NSEC3 records: <spanx style="verb" xml:space="preserve">15bg9l6359f5ch23e34ddua6n1rihl9h</spanx>. This must be the closest encloser (unhashed: <spanx style="verb" xml:space="preserve">example.org</spanx>).  That's the main purpose of that NSEC3 record: tell the resolver what the closest encloser is.  </t>

<t>When using Opt-Out, it is possible that the actual closest encloser to the QNAME does not have an NSEC3 record. If so, we will have to do with the closest provable encloser, which is the closest enclosing authoritative name that does have an NSEC3 record. In the worst case, this is the NSEC3 record corresponding to the apex; this name must always have an NSEC3 record.  </t>

<t>With the closest (provable) encloser, the resolver constructs the next closer, which in this case is: <spanx style="verb" xml:space="preserve">2.example.org</spanx>; <spanx style="verb" xml:space="preserve">2</spanx> is the last label chopped when <spanx style="verb" xml:space="preserve">example.org</spanx> is the closest encloser. The hash of this name should be covered in any of the other NSEC3s.  And, it is -- <spanx style="verb" xml:space="preserve">7t70drg4ekc28v93q7gnbleopa7vlp6q</spanx> falls in the interval set by <spanx style="verb" xml:space="preserve">75b9id679qqov6ldfhd8ocshsssb6jvq</spanx> and <spanx style="verb" xml:space="preserve">8555t7qegau7pjtksnbchg4td2m0jnpj</spanx> (this is our second NSEC3).  </t>

<t>So, what does the resolver learn from this? </t>

<t><list style="symbols"><t><spanx style="verb" xml:space="preserve">example.org</spanx> exists; </t>
<t><spanx style="verb" xml:space="preserve">2.example.org</spanx> does not exist.  </t></list></t>

<t>And, if <spanx style="verb" xml:space="preserve">2.example.org</spanx> does not exist, there is also no direct match for <spanx style="verb" xml:space="preserve">x.2.example.org</spanx>. The last step is to deny the existence of the source of synthesis to prove that no wildcard expansion was possible.  </t>

<t>The resolver hashes <spanx style="verb" xml:space="preserve">*.example.org</spanx> to <spanx style="verb" xml:space="preserve">22670trplhsr72pqqmedltg1kdqeolb7</spanx> and checks that it is covered.  In this case, by the last NSEC3 (see <xref target="fig:x.2.exampl" pageno="false" format="default"/>), the hash falls in the interval set by <spanx style="verb" xml:space="preserve">1avvqn74sg75ukfvf25dgcethgq638ek</spanx> and <spanx style="verb" xml:space="preserve">75b9id679qqov6ldfhd8ocshsssb6jvq</spanx>. This means there is no wildcard record directly below the closest encloser, and <spanx style="verb" xml:space="preserve">x.2.example.org</spanx> definitely does not exist.  </t>

<t>When we have validated the signatures, we have reached our goal: authenticated denial of existence.  </t></section>

<section title="Three to Tango" anchor="three-to-tango" toc="default"><t>One extra NSEC3 record plus an additional signature may seem like a lot just to deny the existence of the wildcard record, but we cannot leave it out. If the standard would not mandate the closest encloser NSEC3 record but instead required two NSEC3 records -- one to deny the query name and one to deny the wildcard record -- an attacker could fool the resolver that the source of synthesis does not exist, while it in fact does.  </t>

<t>Suppose the wildcard record does exist, so our unsigned zone looks like this: </t>

<figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
example.org.        SOA ( ... )
example.org.        NS  a.example.org.
*.example.org.      TXT "wildcard record"
1.h.example.org.    TXT "1.h record"
3.3.example.org.    TXT "3.3 record"
</artwork></figure><t>The query <spanx style="verb" xml:space="preserve">x.2.example.org TXT</spanx> should now be answered with: </t>

<figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
x.2.example.org.    TXT "wildcard record"
</artwork></figure>

<t>An attacker can deny this wildcard expansion by calculating the hash for the wildcard name <spanx style="verb" xml:space="preserve">*.2.example.org</spanx> and searching for an NSEC3 record that covers that hash. The hash of <spanx style="verb" xml:space="preserve">*.2.example.org</spanx> is <spanx style="verb" xml:space="preserve">fbq73bfkjlrkdoqs27k5qf81aqqd7hho</spanx>. Looking through the NSEC3 records in our zone, we see that the NSEC3 record of <spanx style="verb" xml:space="preserve">3.3</spanx> covers this hash: </t>

<figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
8555t7qegau7pjtksnbchg4td2m0jnpj.example.org. (
    NSEC3 1 0 2 DEAD 15BG9L6359F5CH23E34DDUA6N1RIHL9H TXT RRSIG )
</artwork></figure><t>This record also covers the query name <spanx style="verb" xml:space="preserve">x.2.example.org</spanx> (<spanx style="verb" xml:space="preserve">ndtu6dste50pr4a1f2qvr1v31g00i2i1</spanx>).  </t>

<t>Now an attacker adds this NSEC3 record to the AUTHORITY section of the reply to deny both <spanx style="verb" xml:space="preserve">x.2.example.org</spanx> and any wildcard expansion. The net result is that the resolver determines that <spanx style="verb" xml:space="preserve">x.2.example.org</spanx> does not exist, while in fact it should have been synthesized via wildcard expansion. With the NSEC3 matching the closest encloser <spanx style="verb" xml:space="preserve">example.org</spanx>, the resolver can be sure that the wildcard expansion should occur at <spanx style="verb" xml:space="preserve">*.example.org</spanx> and nowhere else.  </t>

<t>Coming back to the original question: Why do we need up to three NSEC3 records to deny a requested name? The resolver needs to be explicitly told what the <spanx style="verb" xml:space="preserve">closest encloser</spanx> is, and this takes up a full NSEC3 record. Then, the next closer name needs to be covered in an NSEC3 record.  Finally, an NSEC3 must say something about whether wildcard expansion was possible. That makes three to tango.  </t></section></section>

<section title="Security Considerations" anchor="security-considerations" toc="default">
<t>DNSSEC does not protect against denial-of-service attacks, nor does it provide confidentiality. For more general security considerations related to DNSSEC, please see <xref target="RFC4033"/>, <xref target="RFC4034"/>, <xref target="RFC4035"/>, and <xref target="RFC5155"/>. </t>

<t>These RFCs are concise about why certain design choices have been made in the area of authenticated denial of existence.  Implementations that do not correctly handle this aspect of DNSSEC create a severe hole in the security DNSSEC adds. This is specifically troublesome for secure delegations.  If an attacker is able to deny the existence of a Delegation Signer (DS) record, the resolver cannot establish a chain of trust, and the resolver has to fall back to insecure DNS for the remainder of the query resolution.  </t>

<t>This document aims to fill this "documentation gap" and provide would-be implementors and other interested parties with enough background knowledge to better understand authenticated denial of existence.  </t></section>

<section title="Acknowledgments" anchor="acknowledgments" toc="default"><t>This document would not be possible without the help of Ed Lewis, Roy Arends, Wouter Wijngaards, Olaf Kolkman, Carsten Strotmann, Jan-Piet Mens, Peter van Dijk, Marco Davids, Esther Makaay, Antoin Verschuren, Lukas Wunner, Joe Abley, Ralf Weber, Geoff Huston, Dave Lawrence, Tony Finch, and Mark Andrews. Also valuable was the source code of Unbound (<spanx style="verb" xml:space="preserve">validator/val_nsec3.c</spanx>) <xref target="Unbound" pageno="false" format="default"/>.  </t>

<t>Extensive feedback for early versions of this document was received from Karst Koymans.  </t></section> </middle>
 
 <back><references title="Normative References">
<?rfc include="reference.RFC.1034" ?>
<?rfc include="reference.RFC.2065" ?>
<?rfc include="reference.RFC.2308" ?>
<?rfc include="reference.RFC.4033" ?>
<?rfc include="reference.RFC.4034" ?>
<?rfc include="reference.RFC.4035" ?>
<?rfc include="reference.RFC.4592" ?>
<?rfc include="reference.RFC.4648" ?>
<?rfc include="reference.RFC.5155" ?>
<?rfc include="reference.RFC.6672" ?>


 </references>

<references title="Informative References">
<?rfc include="reference.RFC.2535" ?>
<?rfc include="reference.RFC.3655" ?>
<?rfc include="reference.RFC.3755" ?>
<?rfc include="reference.RFC.4470" ?>
<?rfc include="reference.RFC.4956" ?>

<!--draft-arends-dnsnr-00, Expired-->
<reference anchor="DNSNR-RR"><front>
<title>DNSSEC Non-Repudiation Resource Record</title>
<author initials="R"
surname="Arends" fullname="Roy Arends"></author>
<date month="June" year="2004"/></front>
<seriesInfo name="Work in" value="Progress"/></reference>

<!--draft-laurie-dnsext-nsec2v2-00, Expired-->
<reference anchor="DNSEXT-NSEC2"><front><title>DNSSEC
NSEC2 Owner and RDATA Format</title><author initials="B"
surname="Laurie" fullname="Ben Laurie"></author><date
month="October" year="2004"/></front><seriesInfo
name="Work in" value="Progress"/></reference>

<!--draft-ietf-dnsext-not-existing-rr-01.txt, Expired-->
<reference anchor="DNSEXT"><front><title>Authenticating
denial of existence in DNS with minimum disclosure</title><author
initials="S" surname="Josefsson" fullname="Simon
Josefsson"></author><date month="November" day="29"
year="2000"/></front><seriesInfo name="Work in"
value="Progress"/></reference>

<reference anchor="Err3441" target="http://www.rfc-editor.org">
<front>
<title>Errata ID 3441</title>
<author>
<organization>RFC Errata</organization>
</author>
<date></date>
</front>
<seriesInfo name="RFC" value="5155"/>
</reference>


<reference anchor="Unbound" target="http://unbound.net"><front><title abbrev="Unbound Resolver">Unbound: a validating, recursive, and caching DNS resolver</title><author><organization>NLnet Labs</organization></author>
<date year="2006"/></front></reference> 


<reference anchor="phreebird" target="http://dankaminsky.com/phreebird/"><front><title
abbrev="Phreebird">Phreebird: a DNSSEC proxy</title><author
initials="D" surname="Kaminsky" fullname="Dan
Kaminsky"></author><date month="January"
year="2011"/></front></reference> </references>


<section title="Online Signing: Minimally Covering NSEC Records" anchor="on-line-signing-minimally-covering-nsec-records" toc="default"><t>An NSEC record lists the next existing name in a zone and thus makes it trivial to retrieve all the names from the zone. This can also be done with NSEC3, but an adversary will then retrieve all the hashed names. With DNSSEC online signing, zone walking can be prevented by faking the next owner name.  </t>

<t>To prevent retrieval of the next owner name with NSEC, a different, non-existing (according to the existence rules in [RFC4592], Section 2.2) name is used. However, not just any name can be used because a validator may make assumptions about the size of the span the NSEC record covers. The span must be large enough to cover the QNAME but not too large that it covers existing names.  </t>

<t><xref target="RFC4470" pageno="false" format="default"/> introduces a scheme for generating minimally covering NSEC records. These records use a next owner name that is lexically closer to the NSEC owner name than the actual next owner name, ensuring that no existing names are covered. The next owner name can be derived from the QNAME with the use of so-called epsilon functions.  </t>

<t>For example, to deny the existence of <spanx style="verb" xml:space="preserve">b.example.org</spanx> in the zone from <xref target="nsec" pageno="false" format="default"/>, the following NSEC record could have been generated: </t>

<figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
a.example.org.      NSEC c.example.org. RRSIG NSEC
</artwork></figure>

<t>This record also proves that <spanx style="verb" xml:space="preserve">b.example.org</spanx> also does not exist, but an adversary <spanx style="emph" xml:space="preserve">cannot</spanx> use the next owner name in a zone-walking attack. Note the type bitmap only has the RRSIG and NSEC set because <xref target="RFC4470" pageno="false" format="default"/> states: </t><t><list style="empty">

<t>The generated NSEC record's type bitmap MUST have the RRSIG and NSEC bits set and SHOULD NOT have any other bits set.  </t></list></t>

<t>This is because the NSEC records may appear at names that did not exist before the zone was signed. In this case, however, <spanx style="verb" xml:space="preserve">a.example.org</spanx> exists with other RR types, and we could have also set the A and TXT types in the bitmap.  </t>

<t>Because DNS ordering is very strict, the span should be shortened to a minimum. In order to do so, the last character in the leftmost label of the NSEC owner name needs to be decremented, and the label must be filled with octets of value 255 until the label length reaches the maximum of 63 octets. The next owner name is the QNAME with a leading label with a single null octet added. This gives the following minimally covering record for <spanx style="verb" xml:space="preserve">b.example.org</spanx>: </t>

<figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
a\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255
 \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255
 \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255
 \255\255\255\255\255\255\255\255\255\255\255.example.org. (
   NSEC \000.b.example.org. RRSIG NSEC )
</artwork></figure></section>

<section title="Online Signing: NSEC3 White Lies" anchor="on-line-signing-nsec3-white-lies" toc="default"><t>The same principle of minimally covering spans can be applied to NSEC3 records. This mechanism has been dubbed "NSEC3 White Lies" when it was implemented in Phreebird <xref target="phreebird" pageno="false" format="default"/>. Here, the NSEC3 owner name is the hash of the QNAME minus one, and the next owner name is the hash of the QNAME plus one.  </t>

<t>The following NSEC3 white lie denies <spanx style="verb" xml:space="preserve">b.example.org</spanx> (recall that this hashes to <spanx style="verb" xml:space="preserve">iuu8l5lmt76jeltp0bir3tmg4u3uu8e7</spanx>): </t>

<figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
iuu8l5lmt76jeltp0bir3tmg4u3uu8e6.example.org. (
   NSEC3 1 0 2 DEAD IUU815LMT76JELTP0BIR3TMG4U3UU8E8 )
</artwork></figure>

<t>The type bitmap is empty in this case. If the hash of <spanx style="verb" xml:space="preserve">b.example.org</spanx> - 1 is a collision with an existing name, the bitmap should have been filled with the RR types that exist at that name. This record actually denies the existence of the next closer name (which is conveniently <spanx style="verb" xml:space="preserve">b.example.org</spanx>). Of course, the NSEC3 records to match the closest encloser and the one to deny the wildcard are still required. These can be generated too: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
# Matching `example.org`: `15bg9l6359f5ch23e34ddua6n1rihl9h`
15bg9l6359f5ch23e34ddua6n1rihl9h.example.org. (
   NSEC3 1 0 2 DEAD 15BG9L6359F5CH23E34DDUA6N1RIHL9I NS SOA RRSIG
        DNSKEY NSEC3PARAM )

# Covering `*.example.org`: `22670trplhsr72pqqmedltg1kdqeolb7`
22670trplhsr72pqqmedltg1kdqeolb6.example.org.(
   NSEC3 1 0 2 DEAD 22670TRPLHSR72PQQMEDLTG1KDQEOLB8 )
</artwork></figure></section>

<section title="List of Hashed Owner Names" anchor="list-of-hashed-owner-names" toc="default"><t>The following owner names are used in this document. The origin for these names is <spanx style="verb" xml:space="preserve">example.org</spanx>.  </t>

<texttable anchor="tab:hashed-owner" align="center" title="Hashed Owner Names for &quot;example.org&quot; in Hash Order" suppress-title="false" style="full"><ttcol align="left">Original Name </ttcol><ttcol align="left">Hashed Name </ttcol><c><spanx style="verb" xml:space="preserve">a</spanx> </c><c><spanx style="verb" xml:space="preserve">04sknapca5al7qos3km2l9tl3p5okq4c</spanx> </c><c><spanx style="verb" xml:space="preserve">1.h</spanx> </c><c><spanx style="verb" xml:space="preserve">117gercprcjgg8j04ev1ndrk8d1jt14k</spanx> </c><c><spanx style="verb" xml:space="preserve">@</spanx> </c><c><spanx style="verb" xml:space="preserve">15bg9l6359f5ch23e34ddua6n1rihl9h</spanx> </c><c><spanx style="verb" xml:space="preserve">h</spanx> </c><c><spanx style="verb" xml:space="preserve">1avvqn74sg75ukfvf25dgcethgq638ek</spanx> </c><c><spanx style="verb" xml:space="preserve">*</spanx> </c><c><spanx style="verb" xml:space="preserve">22670trplhsr72pqqmedltg1kdqeolb7</spanx> </c><c><spanx style="verb" xml:space="preserve">3</spanx> </c><c><spanx style="verb" xml:space="preserve">75b9id679qqov6ldfhd8ocshsssb6jvq</spanx> </c><c><spanx style="verb" xml:space="preserve">2</spanx> </c><c><spanx style="verb" xml:space="preserve">7t70drg4ekc28v93q7gnbleopa7vlp6q</spanx> </c><c><spanx style="verb" xml:space="preserve">3.3</spanx> </c><c><spanx style="verb" xml:space="preserve">8555t7qegau7pjtksnbchg4td2m0jnpj</spanx> </c><c><spanx style="verb" xml:space="preserve">d</spanx> </c><c><spanx style="verb" xml:space="preserve">a6edkb6v8vl5ol8jnqqlt74qmj7heb84</spanx> </c><c><spanx style="verb" xml:space="preserve">*.2</spanx> </c><c><spanx style="verb" xml:space="preserve">fbq73bfkjlrkdoqs27k5qf81aqqd7hho</spanx> </c><c><spanx style="verb" xml:space="preserve">b</spanx> </c><c><spanx style="verb" xml:space="preserve">iuu8l5lmt76jeltp0bir3tmg4u3uu8e7</spanx> </c><c><spanx style="verb" xml:space="preserve">x.2</spanx> </c><c><spanx style="verb" xml:space="preserve">ndtu6dste50pr4a1f2qvr1v31g00i2i1</spanx> </c></texttable><t></t></section>
 </back>
</rfc>
