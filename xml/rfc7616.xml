<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<!DOCTYPE rfc PUBLIC "" "rfc2629.dtd" [
<!ENTITY rfc2119 SYSTEM "reference.RFC.2119.xml">
<!ENTITY rfc2978 SYSTEM "reference.RFC.2978.xml">
<!ENTITY rfc3629 SYSTEM "reference.RFC.3629.xml">
<!ENTITY rfc3986 SYSTEM "reference.RFC.3986.xml">
<!ENTITY rfc4086 SYSTEM "reference.RFC.4086.xml">
<!ENTITY rfc5198 SYSTEM "reference.RFC.5198.xml">
<!ENTITY rfc5234 SYSTEM "reference.RFC.5234.xml">
<!ENTITY rfc5987 SYSTEM "reference.RFC.5987.xml">
<!ENTITY rfc6454 SYSTEM "reference.RFC.6454.xml">
<!ENTITY rfc7230 SYSTEM "reference.RFC.7230.xml">
<!ENTITY rfc7231 SYSTEM "reference.RFC.7231.xml">
<!ENTITY rfc7234 SYSTEM "reference.RFC.7234.xml">
<!ENTITY rfc7235 SYSTEM "reference.RFC.7235.xml">
<!ENTITY rfc2195 SYSTEM "reference.RFC.2195.xml">
<!ENTITY rfc2617 SYSTEM "reference.RFC.2617.xml">
<!ENTITY rfc2818 SYSTEM "reference.RFC.2818.xml">
<!ENTITY rfc4513 SYSTEM "reference.RFC.4513.xml">
<!ENTITY rfc5226 SYSTEM "reference.RFC.5226.xml">
]>

<rfc number="7616" ipr="pre5378Trust200902" category="std" consensus="yes"
     obsoletes="2617" submissionType="IETF">

<front>
  <title>HTTP Digest Access Authentication</title>
  <author initials="R." surname="Shekh-Yusef" fullname="Rifaat Shekh-Yusef" role="editor">
    <organization>Avaya</organization>
    <address>
      <postal>
        <street>250 Sidney Street</street>
        <city>Belleville</city><region>Ontario</region>
        <country>Canada</country>
      </postal>
      <phone>+1-613-967-5267</phone>
      <email>rifaat.ietf@gmail.com</email>
    </address>
  </author>
  <author initials="D." surname="Ahrens" fullname="David Ahrens">
    <organization>Independent</organization>
    <address>
      <postal>
        <street/>
        <region>California</region>
        <country>United States</country>
      </postal>
      <email>ahrensdc@gmail.com</email>
    </address>
  </author>
  <author initials="S." surname="Bremer" fullname="Sophie Bremer">
    <organization>Netzkonform</organization>
    <address>
      <postal>
        <street/>
        <country>Germany</country>
      </postal>
      <email>sophie.bremer@netzkonform.de</email>
    </address>
  </author>

  <date month="September" year="2015"/>

  <area>Security</area>
  <workgroup>HTTPAuth</workgroup>
  <keyword>HTTP</keyword>
  <keyword>authentication scheme</keyword>

  <abstract>
    <t>
      The Hypertext Transfer Protocol (HTTP) provides a simple
      challenge-response authentication mechanism that
      may be used by a server to challenge a client request and by a client
      to provide authentication information. This document defines the HTTP
      Digest Authentication scheme that can be used with the HTTP
      authentication mechanism.
    </t>
  </abstract>
</front>

<middle>
<section title="Introduction" anchor="introduction">
<t>
HTTP provides a simple challenge-response authentication mechanism that may be used by a server to challenge a client request and by a client to provide authentication information. This document defines the HTTP Digest Authentication scheme that can be used with the HTTP authentication mechanism.
</t>
<t>
This document extends but is generally backward compatible with <xref target="RFC2617"/>. See <xref target="rfc2617.changes"/> for the new capabilities introduced by this specification.
</t>
<t>
The details of the challenge-response authentication mechanism are specified in the "Hypertext Transfer Protocol (HTTP/1.1): Authentication" <xref target="RFC7235"/>.
</t>
<t>
The combination of this document with the definition of the "Basic"
authentication scheme <xref target="RFC7617"/>, "HTTP Authentication-Info and
Proxy-Authentication-Info Response Header Fields" <xref target="RFC7615"/>,
and "Hypertext Transfer Protocol (HTTP/1.1): Authentication" <xref target="RFC7235"/> obsolete <xref target="RFC2617"/>.
</t>
<section title="Terminology" anchor="terminology">
<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
</section>
</section>
<section title="Syntax Convention" anchor="syntax.convention">
<section title="Examples" anchor="examples">
<t>
In the interest of clarity and readability, the extended parameters or the header fields and parameters in the examples in this document might be broken into multiple lines. Any line that is indented in this document is a continuation of the preceding line.
</t>
</section>
<section title="ABNF" anchor="abnf">
<t>
This specification uses the Augmented Backus-Naur Form (ABNF) notation of <xref target="RFC5234"/> and the ABNF List Extension of <xref target="RFC7230"/>.
</t>
</section>
</section>

<section title="Digest Access Authentication Scheme" anchor="digest.access.authentication.scheme">
<section title="Overall Operation" anchor="overall.operation">
<t>
The Digest scheme is based on a simple challenge-response paradigm. The Digest scheme challenges using a nonce value and might indicate that username hashing is supported. A valid response contains an unkeyed digest of the username, the password, the given nonce value, the HTTP method, and the requested URI. In this way, the password is never sent in the clear, and the username can be hashed, depending on the indication received from the server. The username and password must be prearranged in some fashion not addressed by this document.
</t>
</section>
<section title="Representation of Digest Values" anchor="representation.of.digest.values">

<t>
An optional header field allows the server to specify the algorithm used to create the unkeyed digest or digest. This document adds SHA-256 and SHA-512/256 algorithms. To maintain backwards compatibility with <xref target="RFC2617"/>, the MD5 algorithm is still supported but NOT RECOMMENDED.
</t>
<t>
The size of the digest depends on the algorithm used. The bits in the digest
are converted from the most significant to the least significant bit, four
bits at a time, to the ASCII representation as follows. Each sequence of four bits is represented by its familiar hexadecimal notation from the characters 0123456789abcdef; that is, binary 0000 is represented by the character '0', 0001 by '1' and so on up to the representation of 1111 as 'f'. If the MD5 algorithm is used to calculate the digest, then the MD5 digest will be represented as 32 hexadecimal characters, while SHA-256 and SHA-512/256 are represented as 64 hexadecimal characters.
</t>
</section>
<section title="The WWW-Authenticate Response Header Field"
	 anchor="www-authenticate.response.header">



<t>
If a server receives a request for an access-protected object, and an acceptable Authorization header field is not sent, the server responds with a "401 Unauthorized" status code and a WWW-Authenticate header field with Digest scheme as per the framework defined above. The value of the header field can include parameters from the following list:
</t>
<t>realm
<list><t>
A string to be displayed to users so they know which username and password to
use. This string should contain at least the name of the host performing the
authentication and might additionally indicate the collection of users who
might have access.



An example is "registered_users@example.com". (See Section 2.2 of <xref target="RFC7235"/> for more details.)
</t></list></t>
<t>domain
<list><t>
A quoted, space-separated list of URIs, as specified in <xref target="RFC3986"/>, that define the protection space. If a URI is a path-absolute, it is relative to the canonical root URL. (See Section 2.2 of <xref target="RFC7235"/>.) An absolute-URI in this list may refer to a different server than the web-origin <xref target="RFC6454"/>. The client can use this list to determine the set of URIs for which the same authentication information may be sent: any URI that has a URI in this list as a prefix (after both have been made absolute) MAY be assumed to be in the same protection space. If this parameter is omitted or its value is empty, the client SHOULD assume that the protection space consists of all URIs on the web-origin.
</t>
<t>
This parameter is not meaningful in Proxy-Authenticate header fields, for which the protection space is always the entire proxy; if present, it MUST be ignored.
</t></list></t>
<t>nonce

<list><t>
A server-specified string which should be uniquely generated each time a 401 response is made. It is advised that this string be Base64 or hexadecimal data. Specifically, since the string is passed in the header field lines as a quoted string, the double-quote character is not allowed, unless suitably escaped.
</t>


<t>
The contents of the nonce are implementation dependent. The quality of the
implementation depends on a good choice. A nonce might, for example, be
constructed as the Base64 encoding of

<figure><artwork>
         timestamp H(timestamp ":" ETag ":" secret-data)
</artwork></figure>
</t>
<t>
where timestamp is a server-generated time, which preferably includes micro-
or nanoseconds, or other non-repeating values; ETag is the value of the HTTP
ETag header field associated with the requested entity; and secret-data is
data known only to the server. With a nonce of this form, a server would
recalculate the hash portion after receiving the client authentication header
field and reject the request if it did not match the nonce from that header
field or if the timestamp value is not recent enough. In this way, the server
can limit the time of the nonce's validity. The inclusion of the ETag prevents
a replay request for an updated version of the resource. Including the IP
address of the client in the nonce would appear to offer the server the
ability to limit the reuse of the nonce to the same client that originally got
it.


However, that would break because requests from a single user often go through different proxies. Also, IP address spoofing is not that hard.
</t>
<t>
An implementation might choose not to accept a previously used nonce or a previously used digest, in order to protect against a replay attack. Or, an implementation might choose to use one-time nonces or digests for POST or PUT requests and a timestamp for GET requests. For more details on the issues involved, see <xref target="security.considerations"/> of this document.
</t>
<t>
The nonce is opaque to the client.
</t></list>
</t>
<t>opaque
<list><t>
A string of data, specified by the server, that SHOULD be returned by the client unchanged in the Authorization header field of subsequent requests with URIs in the same protection space. It is RECOMMENDED that this string be Base64 or hexadecimal data.
</t></list>
</t>
<t>stale
<list><t>
A case-insensitive flag indicating that the previous request from the client was rejected because the nonce value was stale. If stale is true, the client may wish to simply retry the request with a new encrypted response, without re-prompting the user for a new username and password. The server SHOULD only set stale to true if it receives a request for which the nonce is invalid. If stale is false, or anything other than true, or the stale parameter is not present, the username and/or password are invalid, and new values MUST be obtained.
</t></list>
</t>
<t>algorithm
<list><t>
A string indicating an algorithm used to produce the digest and an unkeyed digest. If this is not present, it is assumed to be "MD5". If the algorithm is not understood, the challenge SHOULD be ignored (and a different one used, if there is more than one).
</t>
<t>
When used with the Digest mechanism, each one of the algorithms has two variants: Session variant and non-Session variant. The non-Session variant is denoted by "&lt;algorithm>", e.g., "SHA-256", and the Session variant is denoted by "&lt;algorithm>-sess", e.g., "SHA-256-sess".
</t>
<t>
In this document, the string obtained by applying the digest algorithm to the data "data" with secret "secret" will be denoted by KD(secret, data), and the string obtained by applying the unkeyed digest algorithm to the data "data" will be denoted H(data). KD stands for Keyed Digest, and the notation unq(X) means the value of the quoted-string X without the surrounding quotes and with quoting slashes removed.

<figure><artwork>
     For "&lt;algorithm>" and "&lt;algorithm>-sess"

         H(data) = &lt;algorithm>(data)

     and

         KD(secret, data) = H(concat(secret, ":", data))
</artwork></figure>
</t>

<t>
For example:
<figure><artwork>
     For the "SHA-256" and "SHA-256-sess" algorithms

         H(data) = SHA-256(data)
</artwork></figure>
</t>
<t>
i.e., the digest is the "&lt;algorithm>" of the secret concatenated with a colon concatenated with the data.
The "&lt;algorithm>-sess" is intended to allow efficient third-party authentication servers; for the difference in usage, see the description in <xref target="a1"/>.
</t>
</list>
</t>

<t>qop
<list><t>
      This parameter MUST be used by all implementations. It is a quoted
      string of one or more tokens indicating the "quality of
      protection" values supported by the server. The value "auth"
      indicates authentication; the value "auth-int" indicates
      authentication with integrity protection. See the descriptions
      below for calculating the response parameter value for the
      application of this choice. Unrecognized options MUST be ignored.
</t></list>
</t>

<t>charset
<list><t>
This is an OPTIONAL parameter that is used by the server to indicate the
encoding scheme it supports. The only allowed value is "UTF-8".
</t></list>
</t>
<t>
userhash
<list>
<t>
This is an OPTIONAL parameter that is used by the server to indicate that it supports username hashing. Valid values are: "true" or "false". Default value is "false".
</t>
</list>
</t>

<t>
For historical reasons, a sender MUST only generate the quoted string syntax values for the following parameters: realm, domain, nonce, opaque, and qop.
</t>


<t>
For historical reasons, a sender MUST NOT generate the quoted string syntax values for the following parameters: stale and algorithm.
</t>


</section>
<section title="The Authorization Header Field" anchor="authorization.request.header.field">
<t>
The client is expected to retry the request, passing an Authorization header field line with Digest scheme, which is defined according to the framework above. The values of the opaque and algorithm fields must be those supplied in the WWW-Authenticate response header field for the entity being requested.
</t>
<t>
The request can include parameters from the following list:
</t>
<t>response
<list><t>
A string of the hex digits computed as defined below; it proves that the user knows a password.
</t></list>
</t>



<t>username
<list><t>
      The user's name in the specified realm. The quoted string contains
      the name in plaintext or the hash code in hexadecimal notation.
      If the username contains characters not allowed inside the ABNF
      quoted-string production, the username* parameter can be used.
      Sending both username and username* in the same header option
      MUST be treated as an error.
</t></list>
</t>

<t>username*
<list><t>
 If the userhash parameter value is set "false" and the username
      contains characters not allowed inside the ABNF quoted-string
      production, the user's name can be sent with this parameter, using
      the extended notation defined in <xref target="RFC5987"/>.
</t></list>
</t>

<t>realm
<list><t>
See "realm" definition in <xref target="www-authenticate.response.header"/>.
</t></list>
</t>


<t>uri
<list><t>
The Effective Request URI (Section 5.5 of <xref target="RFC7230"/>) of the HTTP request; duplicated here because proxies are allowed to change the request target ("request-target", Section 3.1.1 of <xref target="RFC7230"/>) in transit.
</t></list>
</t>
<t>qop
<list><t>
Indicates what "quality of protection" the client has applied to the message. Its value MUST be one of the alternatives the server indicated it supports in the WWW-Authenticate header field. These values affect the computation of the response. Note that this is a single token, not a quoted list of alternatives as in WWW-Authenticate.
</t></list>
</t>
<t>cnonce
<list><t>
This parameter MUST be used by all implementations. The cnonce value is an opaque quoted ASCII-only string value provided by the client and used by both client and server to avoid chosen plaintext attacks, to provide mutual authentication, and to provide some message integrity protection. See the descriptions below of the calculation of the rspauth and response values.
</t></list>
</t>
<t>nc
<list><t>
This parameter MUST be used by all implementations. The nc parameter stands for "nonce count". The nc value is the hexadecimal count of the number of requests (including the current request) that the client has sent with the nonce value in this request. For example, in the first request sent in response to a given nonce value, the client sends "nc=00000001". The purpose of this parameter is to allow the server to detect request replays by maintaining its own copy of this count -- if the same nc value is seen twice, then the request is a replay. See the description below of the construction of the response value.
</t></list>
</t>
<t>
<vspace blankLines="3" />
</t>

<t>userhash
<list><t>
This OPTIONAL parameter is used by the client to indicate that the username has been hashed. Valid values are: "true" or "false". Default value is "false".
</t></list>
</t>

<t>
For historical reasons, a sender MUST only generate the quoted string
syntax for the following parameters: username, realm, nonce, uri,
response, cnonce, and opaque.
</t>

<t>
For historical reasons, a sender MUST NOT generate the quoted string
syntax for the following parameters: algorithm, qop, and nc.
</t>


<t>
If a parameter or its value is improper, or required parameters are missing, the proper response is a 4xx error code. If the response is invalid, then a login failure SHOULD be logged, since repeated login failures from a single client may indicate an attacker attempting to guess passwords. The server implementation SHOULD be careful with the information being logged so that it won't put a cleartext password (e.g., entered into the username field) into the log.
</t>


<t>
The definition of the response above indicates the encoding for its value. The following definitions show how the value is computed.
</t>
<section title="Response" anchor="response">
<t>
If the qop value is "auth" or "auth-int":
</t>
<figure><artwork>
      response = &lt;"> &lt; KD ( H(A1), unq(nonce)
                                   ":" nc
                                   ":" unq(cnonce)
                                   ":" unq(qop)
                                   ":" H(A2)
                          ) &lt;">
</artwork></figure>
<t>
See below for the definitions for A1 and A2.
</t>
</section>
<section title="A1" anchor="a1">

<t>
If the algorithm parameter's value is "&lt;algorithm>", e.g., "SHA&nbhy;256", then A1 is:
</t>
<figure><artwork>
      A1       = unq(username) ":" unq(realm) ":" passwd
</artwork></figure>
<t>
   where
</t>
<figure><artwork>
      passwd   = &lt; user's password >
</artwork></figure>
<t>
If the algorithm parameter's value is "&lt;algorithm>-sess", e.g., "SHA-256-sess", then A1 is calculated using the nonce value provided in the challenge from the server, and cnonce value from the request by the client following receipt of a WWW-Authenticate challenge from the server. It uses the server nonce from that challenge, herein called nonce-prime, and the client nonce value from the response, herein called cnonce-prime, to construct A1 as follows:
</t>
<figure><artwork>
      A1       = H( unq(username) ":" unq(realm) ":" passwd )
                     ":" unq(nonce-prime) ":" unq(cnonce-prime)
</artwork></figure>
<t>
This creates a "session key" for the authentication of subsequent requests and responses that is different for each "authentication session", thus limiting the amount of material hashed with any one key. (Note: see further discussion of the authentication session in <xref target="digest.operation"/>.) Because the server needs only use the hash of the user credentials in order to create the A1 value, this construction could be used in conjunction with a third-party authentication service so that the web server would not need the actual password value. The specification of such a protocol is beyond the scope of this specification.
</t>
</section>
<section title="A2">
<t>
If the qop parameter's value is "auth" or is unspecified, then A2 is:
</t>
<figure><artwork>
      A2       = Method ":" request-uri
</artwork></figure>
<t>
   If the qop value is "auth-int", then A2 is:
</t>
<figure><artwork>
      A2       = Method ":" request-uri ":" H(entity-body)
</artwork></figure>
</section>
<section title="Username Hashing" anchor="username.hashing">
<t>
To protect the transport of the username from the client to the server, the server SHOULD set the userhash parameter with the value of "true" in the WWW-Authentication header field.
</t>
<t>
If the client supports the userhash parameter, and the userhash parameter value in the WWW-Authentication header field is set to "true", then the client MUST calculate a hash of the username after any other hash calculation and include the userhash parameter with the value of "true" in the Authorization header field. If the client does not provide the username as a hash value or the userhash parameter with the value of "true", the server MAY reject the request.
</t>
<t>
The following is the operation that the client will perform to hash the username, using the same algorithm used to hash the credentials:
</t>
<figure><artwork>
   username = H( unq(username) ":" unq(realm) )
</artwork></figure>
</section>
<section title="Parameter Values and Quoted-String">
<t>
Note that the value of many of the parameters, such as username value, are defined as a "quoted-string". However, the "unq" notation indicates that surrounding quotation marks are removed in forming the string A1. Thus, if the Authorization header field includes the fields
</t>
<figure><artwork type="example">
   username="Mufasa", realm="myhost@example.com"
</artwork></figure>
<t>
and the user Mufasa has password "Circle Of Life", then H(A1) would be H(Mufasa:myhost@example.com:Circle Of Life) with no quotation marks in the digested string.
</t>
<t>
No white space is allowed in any of the strings to which the digest function H() is applied, unless that white space exists in the quoted strings or entity body whose contents make up the string to be digested. For example, the string A1 illustrated above must be
</t>
<figure><artwork type="example">
   Mufasa:myhost@example.com:Circle Of Life
</artwork></figure>
<t>
with no white space on either side of the colons, but with the white space between the words used in the password value. Likewise, the other strings digested by H() must not have white space on either side of the colons that delimit their fields, unless that white space was in the quoted strings or entity body being digested.
</t>
<t>
Also, note that if integrity protection is applied (qop=auth-int), the H(entity-body) is the hash of the entity body, not the message body -- it is computed before any transfer encoding is applied by the sender and after it has been removed by the recipient. Note that this includes multipart boundaries and embedded header fields in each part of any multipart content-type.
</t>
</section>
<section title="Various Considerations">
<t>
The "Method" value is the HTTP request method, in US-ASCII letters, as specified in Section 3.1.1 of <xref target="RFC7230"/>. The "request-target" value is the request-target from the request line as specified in Section 3.1.1 of <xref target="RFC7230"/>. This MAY be "*", an "absolute-URI", or an "absolute-path" as specified in Section 2.7 of <xref target="RFC7230"/>, but it MUST agree with the request-target. In particular, it MUST be an "absolute-URI" if the request-target is an "absolute-URI". The cnonce value is a client-chosen value whose purpose is to foil chosen plaintext attacks.
</t>
<t>
The authenticating server MUST assure that the resource designated by the "uri" parameter is the same as the resource specified in the Request-Line; if they are not, the server SHOULD return a 400 Bad Request error. (Since this may be a symptom of an attack, server implementers may want to consider logging such errors.) The purpose of duplicating information from the request URL in this field is to deal with the possibility that an intermediate proxy may alter the client's Request-Line. This altered (but presumably semantically equivalent) request would not result in the same digest as that calculated by the client.
</t>
<t>
Implementers should be aware of how authenticated transactions need to interact with shared caches (see <xref target="RFC7234"/>).
</t>
</section>
</section>
<section title="The Authentication-Info and Proxy-Authentication-Info Header Fields" anchor="authenticaion-info.header.field">
<t>
The Authentication-Info header field and the Proxy-Authentication-Info header field <xref target="RFC7615"/> are generic fields that MAY be used by a server to communicate some information regarding the successful authentication of a client response.
</t>
<t>
The Digest Authentication scheme MAY add the Authentication-Info header field in the confirmation request and include parameters from the following list:
</t>
<t>nextnonce
<list><t>
The value of the nextnonce parameter is the nonce the server wishes the client
to use for a future authentication response.


The server MAY send the Authentication-Info header field with a nextnonce
field as a means of implementing one-time nonces or otherwise changing nonces. If the nextnonce field is present, the client SHOULD use it when constructing the Authorization header field for its next request. Failure of the client to do so MAY result in a request to re-authenticate from the server with the "stale=true".
<list><t>
Server implementations SHOULD carefully consider the performance implications of the use of this mechanism; pipelined requests will not be possible if every response includes a nextnonce parameter that MUST be used on the next request received by the server. Consideration SHOULD be given to the performance vs. security tradeoffs of allowing an old nonce value to be used for a limited time to permit request pipelining. Use of the nc parameter can retain most of the security advantages of a new server nonce without the deleterious effects on pipelining.
</t></list>
</t></list>
</t>
<t>qop
<list><t>
Indicates the "quality of protection" options applied to the response by the server. The value "auth" indicates authentication; the value "auth-int" indicates authentication with integrity protection. The server SHOULD use the same value for the qop parameter in the response as was sent by the client in the corresponding request.
</t></list>
</t>
<t>rspauth
<list><t>
The optional response digest in the rspauth parameter supports mutual
authentication -- the server proves that it knows the user's secret, and with
qop=auth-int also provides limited integrity protection of the response. The
rspauth value is calculated as for the response in the Authorization header
field, except that if qop is set to "auth" or is not specified in the Authorization header field for the request, A2 is
</t>
<t>
<figure><artwork>
      A2       = ":" request-uri
</artwork></figure>

   and if "qop=auth-int", then A2 is

<figure><artwork>
      A2       = ":" request-uri ":" H(entity-body)
</artwork></figure>
</t></list>
</t>


<t>cnonce and nc
<list><t>
The cnonce value and nc value MUST be the ones for the client request to which this message is the response. The rspauth, cnonce, and nc parameters MUST be present if "qop=auth" or "qop=auth-int" is specified.
</t></list>
</t>
<t>
The Authentication-Info header field is allowed in the trailer of an HTTP
message transferred via chunked transfer coding.
</t>

<t>
For historical reasons, a sender MUST only generate the quoted string
syntax for the following parameters: nextnonce, rspauth, and cnonce.
</t>

<t>
For historical reasons, a sender MUST NOT generate the quoted string
syntax for the following parameters: qop and nc.
</t>

<t>
For historical reasons, the nc value MUST be exactly 8 hexadecimal digits.
</t>

</section>

<section title="Digest Operation" anchor="digest.operation">
<t>
Upon receiving the Authorization header field, the server MAY check its validity by looking up the password that corresponds to the submitted username. Then, the server MUST perform the same digest operation (e.g., MD5, SHA-256) performed by the client and compare the result to the given response value.
</t>
<t>
Note that the HTTP server does not actually need to know the user's cleartext password. As long as H(A1) is available to the server, the validity of an Authorization header field can be verified.
</t>
<t>
The client response to a WWW-Authenticate challenge for a protection space
starts an authentication session with that protection space. The
authentication session lasts until the client receives another
WWW-Authenticate challenge from any server in the protection space. A client
SHOULD remember the username, password, nonce, nonce count, and opaque values
associated with an authentication session to use to construct the
Authorization header field in future requests within that protection
space. The Authorization header field MAY be included preemptively; doing so
improves server efficiency and avoids extra round trips for authentication
challenges. The server MAY choose to accept the old Authorization header field
information, even though the nonce value included might not be
fresh. Alternatively, the server MAY return a 401 response with a new nonce
value in the WWW-Authenticate header field, causing the client to retry the request; by specifying "stale=true" with this response, the server tells the client to retry with the new nonce, but without prompting for a new username and password.
</t>
<t>
Because the client is required to return the value of the opaque parameter given to it by the server for the duration of a session, the opaque data can be used to transport authentication session state information. (Note that any such use can also be accomplished more easily and safely by including the state in the nonce.) For example, a server could be responsible for authenticating content that actually sits on another server. It would achieve this by having the first 401 response include a domain parameter whose value includes a URI on the second server, and an opaque parameter whose value contains the state information. The client will retry the request, at which time the server might respond with "HTTP Redirection" (Section 6.4 of <xref target="RFC7231"/>), pointing to the URI on the second server. The client will follow the redirection and pass an Authorization header field, including the &lt;opaque> data.
</t>
<t>
Proxies MUST be completely transparent in the Digest access authentication scheme. That is, they MUST forward the WWW-Authenticate, Authentication-Info, and Authorization header fields untouched. If a proxy wants to authenticate a client before a request is forwarded to the server, it can be done using the Proxy-Authenticate and Proxy-Authorization header fields described in <xref target="proxy-auth"/> below.
</t>
</section>
<section title="Security Protocol Negotiation">
<t>
It is useful for a server to be able to know which security schemes a client is capable of handling.
</t>
<t>
It is possible that a server wants to require Digest as its authentication method, even if the server does not know that the client supports it. A client is encouraged to fail gracefully if the server specifies only authentication schemes it cannot handle.
</t>
<t>
When a server receives a request to access a resource, the server might challenge the client by responding with "401 Unauthorized" response and include one or more WWW-Authenticate header fields. If the server responds with multiple challenges, then each one of these challenges MUST use a different digest algorithm. The server MUST add these challenges to the response in order of preference, starting with the most preferred algorithm, followed by the less preferred algorithm.
</t>
<t>
This specification defines the following algorithms:
<list style="symbols">
<t>SHA2-256 (mandatory to implement)</t>
<t>SHA2-512/256 (as a backup algorithm)</t>
<t>MD5 (for backward compatibility).</t>
</list>
</t>
<t>
When the client receives the first challenge, it SHOULD use the first challenge it supports, unless a local policy dictates otherwise.
</t>
</section>
<section title="Proxy-Authenticate and Proxy-Authorization" anchor="proxy-auth">
<t>
The Digest Authentication scheme can also be used for authenticating users to
proxies, proxies to proxies, or proxies to origin servers by use of the
Proxy-Authenticate and Proxy-Authorization header fields.



These header fields are instances of the Proxy-Authenticate and Proxy-Authorization header fields specified in Sections 4.3 and 4.4 of the HTTP/1.1 specification <xref target="RFC7235"/>, and their behavior is subject to restrictions described there. The transactions for proxy authentication are very similar to those already described. Upon receiving a request that requires authentication, the proxy/server MUST issue the "407 Proxy Authentication Required" response with a "Proxy-Authenticate" header field. The digest-challenge used in the Proxy-Authenticate header field is the same as that for the WWW-Authenticate header field as defined above in <xref target="www-authenticate.response.header"/>.
</t>

<!-- [rfced] Are these terms equivalent?
"Authorization header field" and "Authorization Request header field"
The reason for the question is comparing the following text with
the title of Section 3.4 ("Authorization Request Header Field").

Original:
   The client/proxy MUST then re-issue the request with a Proxy-
   Authorization header field, with parameters as specified for the
   Authorization header field in Section 3.4 above.
-->

<t>
The client/proxy MUST then reissue the request with a Proxy-Authorization header field, with parameters as specified for the Authorization header field in <xref target="authorization.request.header.field"/> above.
</t>
<t>
On subsequent responses, the server sends Proxy-Authentication-Info with parameters the same as those for the Authentication-Info header field.
</t>
<t>
Note that, in principle, a client could be asked to authenticate itself to both a proxy and an end-server, but never in the same response.
</t>
</section>
<section title="Examples">
<section title="Example with SHA-256 and MD5">
<t>
The following example assumes that an access-protected document is being requested from the server via a GET request. The URI of the document is "http://www.example.org/dir/index.html". Both client and server know that the username for this document is "Mufasa" and the password is "Circle of Life" (with one space between each of the three words).
</t>
<t>
The first time the client requests the document, no Authorization header field is sent, so the server responds with:
</t>
<figure><artwork type="message/http; msgtype=&#34;response&#34;">
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Digest
    realm="http-auth@example.org",
    qop="auth, auth-int",
    algorithm=SHA-256,
    nonce="7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v",
    opaque="FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS"
WWW-Authenticate: Digest
    realm="http-auth@example.org",
    qop="auth, auth-int",
    algorithm=MD5,
    nonce="7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v",
    opaque="FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS"
</artwork></figure>
<t>
The client can prompt the user for their username and password, after which it will respond with a new request, including the following Authorization header field if the client chooses MD5 digest:
</t>
<figure><artwork type="example">
Authorization: Digest username="Mufasa",
    realm="http-auth@example.org",
    uri="/dir/index.html",
    algorithm=MD5,
    nonce="7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v",
    nc=00000001,
    cnonce="f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ",
    qop=auth,
    response="8ca523f5e9506fed4657c9700eebdbec",
    opaque="FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS"
</artwork></figure>

<t>
If the client chooses to use the SHA-256 algorithm for calculating the response, the client responds with a new request including the following Authorization header field:
</t>
<figure><artwork type="example">
Authorization: Digest username="Mufasa",
    realm="http-auth@example.org",
    uri="/dir/index.html",
    algorithm=SHA-256,
    nonce="7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v",
    nc=00000001,
    cnonce="f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ",
    qop=auth,
    response="753927fa0e85d155564e2e272a28d1802ca10daf449
       6794697cf8db5856cb6c1",
    opaque="FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS"
</artwork></figure>
</section>
<section title="Example with SHA-512-256, Charset, and Userhash">
<t>
The following example assumes that an access-protected document is
being requested from the server via a GET request.  The URI for the
request is "http://api.example.org/doe.json".  Both client and server
know the userhash of the username, support the UTF-8 character
encoding scheme, and use the SHA-512-256 algorithm. The username for
the request is a variation of "Jason Doe", where the 'a' actually
is Unicode code point U+00E4 ("LATIN SMALL LETTER A WITH DIAERESIS"),
and the first 'o' is Unicode code point U+00F8 ("LATIN SMALL LETTER O
WITH STROKE"), leading to the octet sequence using the UTF-8 encoding scheme:
</t>

<t>
<figure><artwork type="username">
   J  U+00E4 s  U+00F8 n      D  o  e
   4A C3A4   73 C3B8   6E 20 44  6F 65
</artwork></figure>
</t>


<t>
The password is "Secret, or not?".
</t>
<t>
The first time the client requests the document, no Authorization header field is sent, so the server responds with:
</t>
<figure><artwork type="message/http; msgtype=&#34;response&#34;">
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Digest
    realm="api@example.org",
    qop="auth",
    algorithm=SHA-512-256,
    nonce="5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK",
    opaque="HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS",
    charset=UTF-8,
    userhash=true
</artwork></figure>
<t>
The client can prompt the user for the required credentials and send a new request with following Authorization header field:
</t>
<figure><artwork type="example">
Authorization: Digest
    username="488869477bf257147b804c45308cd62ac4e25eb717
       b12b298c79e62dcea254ec",
    realm="api@example.org",
    uri="/doe.json",
    algorithm=SHA-512-256,
    nonce="5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK",
    nc=00000001,
    cnonce="NTg6RKcb9boFIAS3KrFK9BGeh+iDa/sm6jUMp2wds69v",
    qop=auth,
    response="ae66e67d6b427bd3f120414a82e4acff38e8ecd9101d
       6c861229025f607a79dd",
    opaque="HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS",
    userhash=true
</artwork></figure>
<t>
If the client cannot provide a hashed username for any reason, the client can try a request with this Authorization header field:
</t>
<figure><artwork type="example">
Authorization: Digest
    username*=UTF-8''J%C3%A4s%C3%B8n%20Doe,
    realm="api@example.org",
    uri="/doe.json",
    algorithm=SHA-512-256,
    nonce="5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK",
    nc=00000001,
    cnonce="NTg6RKcb9boFIAS3KrFK9BGeh+iDa/sm6jUMp2wds69v",
    qop=auth,
    response="ae66e67d6b427bd3f120414a82e4acff38e8ecd9101d
       6c861229025f607a79dd",
    opaque="HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS",
    userhash=false
</artwork></figure>
</section>
</section>
</section>

<section title="Internationalization Considerations">
<t>
In challenges, servers SHOULD use the "charset" authentication parameter (case-insensitive) to express the character encoding they expect the user agent to use when generating A1 (see <xref target="a1"/>) and username hashing (see <xref target="username.hashing"/>).
</t>
<t>
The only allowed value is "UTF-8", to be matched case-insensitively (see
Section 2.3 in <xref
target="RFC2978"/>). It indicates that the server expects the username and password to be converted to Unicode Normalization Form C ("NFC", see Section 3 of <xref target="RFC5198"/>) and to be encoded into octets using the UTF-8 character encoding scheme <xref target="RFC3629"/>.
</t>
<t>
For the username, recipients MUST support all characters defined in the "UsernameCasePreserved" profile defined in Section 3.3 of <xref target="RFC7613"/>, with the exception of the colon (":") character.
</t>
<t>
For the password, recipients MUST support all characters defined in the "OpaqueString" profile defined in Section 4.2 of <xref target="RFC7613"/>.
</t>
<t>
If the user agent does not support the encoding indicated by the server, it can fail the request.
</t>
<t>
When usernames cannot be sent hashed and include non-ASCII characters, clients can include the username* parameter instead (using the value encoding defined in <xref target="RFC5987"/>).
</t>
</section>

<section title="Security Considerations" anchor="security.considerations">
<section title="Limitations">
<t>
HTTP Digest Authentication, when used with human-memorable passwords,
is vulnerable to dictionary attacks. Such attacks are much easier
than cryptographic attacks on any widely used algorithm, including
those that are no longer considered secure. In other words, algorithm
agility does not make this usage any more secure.
</t>
<t>
As a result, Digest Authentication SHOULD be used only with passwords
that have a reasonable amount of entropy, e.g., 128-bit or more. Such
passwords typically cannot be memorized by humans but can be used for
automated web services.
</t>
<t>
If Digest Authentication is being used, it SHOULD be over a secure channel like HTTPS <xref target="RFC2818"/>.
</t>
</section>
<section title="Storing Passwords">
<t>
Digest Authentication requires that the authenticating agent (usually
the server) store some data derived from the user's name and password
in a "password file" associated with a given realm. Normally, this
might contain pairs consisting of username and H(A1), where H(A1) is
the digested value of the username, realm, and password as described
above.
</t>
<t>
The security implications of this are that if this password file is
compromised, then an attacker gains immediate access to documents on
the server using this realm. Unlike, say, a standard UNIX password
file, this information needs not be decrypted in order to access
documents in the server realm associated with this file. On the other
hand, decryption, or more likely a brute-force attack, would be
necessary to obtain the user's password. This is the reason that the
realm is part of the digested data stored in the password file. It
means that if one Digest Authentication password file is compromised,
it does not automatically compromise others with the same username
and password (though it does expose them to brute-force attack).
</t>
<t>
There are two important security consequences of this. First, the
password file must be protected as if it contained unencrypted
passwords, because, for the purpose of accessing documents in its
realm, it effectively does.
</t>
<t>
A second consequence of this is that the realm string SHOULD be
unique among all realms that any single user is likely to use. In
particular, a realm string SHOULD include the name of the host doing
the authentication. The inability of the client to authenticate the
server is a weakness of Digest Authentication.
</t>
</section>
<section title="Authentication of Clients Using Digest Authentication">
<t>
Digest Authentication does not provide a strong authentication
mechanism, when compared to public-key-based mechanisms, for example.
</t>
<t>
However, it is significantly stronger than, e.g., CRAM-MD5, which has been
proposed for use with Lightweight Directory Access Protocol (LDAP) <xref target="RFC4513"/> and IMAP/POP (see <xref target="RFC2195"/>). It was intended to replace the much weaker and even more
dangerous Basic mechanism.
</t>
<t>
Digest Authentication offers no confidentiality protection beyond protecting the actual username and password. All of the rest of the request and response are available to an eavesdropper.
</t>
<t>
Digest Authentication offers only limited integrity protection for the
messages in either direction. If the "qop=auth-int" mechanism is used, those parts of the message used in the calculation of the WWW-Authenticate and Authorization header field response parameter values (see <xref target="representation.of.digest.values"/> above) are protected. Most header fields and their values could be modified as a part of a man-in-the-middle attack.
</t>
<t>
Many needs for secure HTTP transactions cannot be met by Digest
Authentication. For those needs, TLS is a more appropriate protocol. In particular, Digest Authentication cannot be used for any transaction requiring confidentiality protection. Nevertheless, many functions remain for which Digest Authentication is both useful and appropriate.
</t>
</section>

<section title="Limited-Use Nonce Values">
<t>
The Digest scheme uses a server-specified nonce to seed the
generation of the response value (as specified in <xref target="response"/> above).
As shown in the example nonce in <xref target="www-authenticate.response.header"/>, the
server is free to construct the nonce such that it MAY only be used
from a particular client, for a particular resource, for a limited
period of time or number of uses, or any other restrictions. Doing
so strengthens the protection provided against, for example, replay
attacks (see <xref target="replay_attacks"/>). However, it should be noted that the method
chosen for generating and checking the nonce also has performance and
resource implications. For example, a server MAY choose to allow
each nonce value to be used only once by maintaining a record of
whether or not each recently issued nonce has been returned and
sending a next-nonce parameter in the Authentication-Info header
field of every response. This protects against even an immediate
replay attack, but it has a high cost due to checking nonce values; perhaps
more important, it will cause authentication failures for any pipelined
requests (presumably returning a stale nonce indication). Similarly,
incorporating a request-specific element such as the ETag value for a
resource limits the use of the nonce to that version of the resource
and also defeats pipelining. Thus, it MAY be useful to do so for
methods with side effects but have unacceptable performance for those
that do not.
</t>
</section>
<section title="Replay Attacks" anchor="replay_attacks">


<t>
A replay attack against Digest Authentication would usually be
pointless for a simple GET request since an eavesdropper would
already have seen the only document he could obtain with a replay.
This is because the URI of the requested document is digested in the
client request, and the server will only deliver that document. By
contrast, under Basic Authentication, once the eavesdropper has the
user's password, any document protected by that password is open to
him.
</t>
<t>
Thus, for some purposes, it is necessary to protect against replay
attacks. A good Digest implementation can do this in various ways.
The server-created "nonce" value is implementation dependent, but if
it contains a digest of the client IP, a timestamp, the resource
ETag, and a private server key (as recommended above), then a replay
attack is not simple. An attacker must convince the server that the
request is coming from a false IP address and must cause the server
to deliver the document to an IP address different from the address
to which it believes it is sending the document. An attack can only
succeed in the period before the timestamp expires. Digesting the
client IP and timestamp in the nonce permits an implementation that
does not maintain state between transactions.
</t>
<t>
For applications where no possibility of replay attack can be
tolerated, the server can use one-time nonce values that will not be
honored for a second use. This requires the overhead of the server remembering which nonce values have been used until the nonce timestamp (and hence the digest built with it) has expired, but it
effectively protects against replay attacks.
</t>
<t>
An implementation must give special attention to the possibility of
replay attacks with POST and PUT requests.



Unless the server employs
one-time or otherwise limited-use nonces and/or insists on the use of
the integrity protection of "qop=auth-int", an attacker could replay
valid credentials from a successful request with counterfeit
data or other message body. Even with the use of integrity protection,
most metadata in header fields is not protected.

Proper nonce
generation and checking provides some protection against replay of
previously used valid credentials, but see <xref target="mitm"/>.
</t>
</section>
<section title="Weakness Created by Multiple Authentication Schemes">

<t>
An HTTP/1.1 server MAY return multiple challenges with a 401
(Authenticate) response, and each challenge MAY use a different
auth-scheme. A user agent MUST choose to use the strongest auth-scheme it understands and request credentials from the user based
upon that challenge.
</t>
<t>
When the server offers choices of authentication schemes using the
WWW-Authenticate header field, the strength of the resulting authentication
is only as good as that of the of the weakest of the authentication
schemes. See <xref target="online.dictionary.attacks"/> below for discussion of particular attack
scenarios that exploit multiple authentication schemes.
</t>
</section>
<section title="Online Dictionary Attacks" anchor="online.dictionary.attacks">
<t>
If the attacker can eavesdrop, then it can test any overheard
nonce/response pairs against a list of common words. Such a list is
usually much smaller than the total number of possible passwords. The
cost of computing the response for each password on the list is paid
once for each challenge.
</t>
<t>
The server can mitigate this attack by not allowing users to select
passwords that are in a dictionary.
</t>
</section>
<section title="Man-in-the-Middle Attacks" anchor="mitm">
<t>
Digest Authentication is vulnerable to man-in-the-middle (MITM) attacks, for example, from a hostile or compromised proxy. Clearly, this would present all the problems of eavesdropping. But, it also offers some additional opportunities to the attacker.
</t>
<t>
A possible man-in-the-middle attack would be to add a weak
authentication scheme to the set of choices, hoping that the client
will use one that exposes the user's credentials (e.g., password). For
this reason, the client SHOULD always use the strongest scheme that
it understands from the choices offered.
</t>
<t>
An even better MITM attack would be to remove all offered choices,
replacing them with a challenge that requests only Basic
authentication, then uses the cleartext credentials from the Basic
authentication to authenticate to the origin server using the
stronger scheme it requested. A particularly insidious way to mount
such a MITM attack would be to offer a "free" proxy caching service
to gullible users.
</t>
<t>
User agents should consider measures such as presenting a visual
indication at the time of the credentials request of what
authentication scheme is to be used, or remembering the strongest
authentication scheme ever requested by a server and producing a
warning message before using a weaker one. It might also be a good
idea for the user agent to be configured to demand Digest
authentication in general or from specific sites.
</t>
<t>
Or, a hostile proxy might spoof the client into making a request the
attacker wanted rather than one the client wanted. Of course, this is
still much harder than a comparable attack against Basic
Authentication.
</t>
</section>
<section title="Chosen Plaintext Attacks">
<t>
With Digest Authentication, a MITM or a malicious server can
arbitrarily choose the nonce that the client will use to compute the
response. This is called a "chosen plaintext" attack. The ability to
choose the nonce is known to make cryptanalysis much easier.
</t>
<t>
However, a method to analyze the one-way functions used by Digest
using chosen plaintext is not currently known.
</t>
<t>
The countermeasure against this attack is for clients to use the cnonce parameter; this allows the client to vary the input to the hash in a way not chosen by the attacker.
</t>
</section>
<section title="Precomputed Dictionary Attacks">
<t>
With Digest Authentication, if the attacker can execute a chosen
plaintext attack, the attacker can precompute the response for many
common words to a nonce of its choice and store a dictionary of
response/password pairs. Such precomputation can often be done in
parallel on many machines. It can then use the chosen plaintext
attack to acquire a response corresponding to that challenge and
just look up the password in the dictionary. Even if most passwords
are not in the dictionary, some might be. Since the attacker gets to
pick the challenge, the cost of computing the response for each
password on the list can be amortized over finding many passwords. A
dictionary with 100 million password/response pairs would take about
3.2 gigabytes of disk storage.

</t>
<t>
The countermeasure against this attack is for clients to use the cnonce parameter.
</t>
</section>
<section title="Batch Brute-Force Attacks">
<t>
With Digest Authentication, a MITM can execute a chosen plaintext
attack and can gather responses from many users to the same nonce.
It can then find all the passwords within any subset of password
space that would generate one of the nonce/response pairs in a single
pass over that space. It also reduces the time to find the first
password by a factor equal to the number of nonce/response pairs
gathered. This search of the password space can often be done in
parallel on many machines, and even a single machine can search large
subsets of the password space very quickly -- reports exist of
searching all passwords with six or fewer letters in a few hours.
</t>
<t>
The countermeasure against this attack is for clients to use the cnonce parameter.
</t>
</section>

<section title="Parameter Randomness">
<t>
The security of this protocol is critically dependent on the randomness of the randomly chosen parameters, such as client and server nonces. These should be generated by a strong random or properly seeded pseudorandom source (see <xref target="RFC4086"/>).
</t>
</section>


<section title="Summary">
<t>
By modern cryptographic standards, Digest Authentication is weak. But,
for a large range of purposes, it is valuable as a replacement for
Basic Authentication. It remedies some, but not all, weaknesses of
Basic Authentication. Its strength may vary depending on the
implementation. In particular, the structure of the nonce (which is
dependent on the server implementation) may affect the ease of
mounting a replay attack. A range of server options is appropriate
since, for example, some implementations may be willing to accept the
server overhead of one-time nonces or digests to eliminate the
possibility of replay. Others may be satisfied with a nonce like the one
recommended above, i.e., restricted to a single IP address and a single ETag
or with a limited lifetime.
</t>
<t>
The bottom line is that *any* compliant implementation will be
relatively weak by cryptographic standards, but *any* compliant
implementation will be far superior to Basic Authentication.
</t>
</section>

</section>

<section title="IANA Considerations" anchor="iana.considerations">
<section title="Hash Algorithms for HTTP Digest Authentication ">
<t>
This specification creates a new IANA registry named "Hash Algorithms
for HTTP Digest Authentication" under the existing "Hypertext Transfer Protocol
(HTTP) Digest Algorithm Values" category.
This registry lists the hash algorithms that can be used in HTTP Digest Authentication.
</t>

<t>
When registering a new hash algorithm, the following information MUST be provided:
</t>
<t>Hash Algorithm
<list><t>
     The textual name of the hash algorithm.
</t></list></t>
<t>Digest Size
<list><t>
     The size of the algorithm's output in bits.
</t></list></t>
<t>Reference
<list><t>
     A reference to the specification adding the algorithm to this registry.
</t></list></t>
<t>
The update policy for this registry shall be Specification Required <xref target="RFC5226"/>.
</t>
<t>
The initial registry contains the following entries:
</t>
<texttable>
  <ttcol>Hash Algorithm</ttcol>
  <ttcol>Digest Size</ttcol>
  <ttcol>Reference</ttcol>
  <c>"MD5"</c><c>128</c><c>RFC 7616</c>
  <c>"SHA-512-256"</c><c>256</c><c>RFC 7616</c>
  <c>"SHA-256"</c><c>256</c><c>RFC 7616</c>
</texttable>
<t>
Each one of the algorithms defined in the registry might have a "-sess" variant, e.g., MD5-sess, SHA-256-sess, etc.
</t>

<t>
To clarify the purpose of the existing "HTTP Digest Algorithm Values" registry and
to avoid confusion between the two registries, IANA has added the following
description to the existing "HTTP Digest Algorithm Values" registry:

<list><t>
   This registry lists the algorithms that can be used when creating
   digests of an HTTP message body, as specified in RFC 3230.
</t></list>
</t>


</section>
<section title="Digest Scheme Registration">
<t>
This specification updates the existing entry of the Digest scheme in
the "Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry" and adds a
new reference to this specification.
</t>
<t><list>
  <t>Authentication Scheme Name: Digest</t>
  <t>Pointer to specification text: RFC 7616</t>
</list></t>
</section>
</section>


  </middle>
  <back>

<references title="Normative References">
&rfc2119;
&rfc2978;
&rfc3629;
&rfc3986;
&rfc4086;
&rfc5198;
&rfc5234;
&rfc5987;
&rfc6454;
&rfc7230;
&rfc7231;
&rfc7234;
&rfc7235;

<!-- draft-ietf-precis-saslprepbis - RFC 7613 -->

<reference  anchor='RFC7613' target='http://www.rfc-editor.org/info/rfc7613'>
<front>
<title>Preparation, Enforcement, and Comparison of Internationalized Strings Representing Usernames and Passwords</title>
<author initials='P.' surname='Saint-Andre' fullname='P. Saint-Andre'><organization /></author>
<author initials='A.' surname='Melnikov' fullname='A. Melnikov'><organization /></author>
<date year='2015' month='August' />
<abstract><t>This document describes updated methods for handling Unicode strings representing usernames and passwords.  The previous approach was known as SASLprep (RFC 4013) and was based on stringprep (RFC 3454). The methods specified in this document provide a more sustainable approach to the handling of internationalized usernames and passwords.  The preparation, enforcement, and comparison of internationalized strings (PRECIS) framework, RFC 7564, obsoletes RFC 3454, and this document obsoletes RFC 4013.</t></abstract>
</front>
<seriesInfo name='RFC' value='7613'/>
<seriesInfo name='DOI' value='10.17487/RFC7613'/>
</reference>


<!-- draft-ietf-httpbis-auth-info - RFC 7615 -->
  <reference anchor="RFC7615" target="http://www.rfc-editor.org/info/rfc7615">
    <front>
      <title>HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields</title>
      <author initials="J." surname="Reschke" fullname="Julian Reschke"/>
      <date year="2015" month="September"/>
    </front>
    <seriesInfo name="RFC" value="7615"/>
    <seriesInfo name="DOI" value="10.17487/RFC7615"/>
  </reference>

</references>

<references title="Informative References">

&rfc2195;
&rfc2617;
&rfc2818;
&rfc4513;
&rfc5226;

<!-- draft-ietf-httpauth-basicauth-update - RFC 7617 -->
  <reference anchor="RFC7617" target="http://www.rfc-editor.org/info/rfc7617">
    <front>
      <title>The 'Basic' HTTP Authentication Scheme</title>
      <author initials="J." surname="Reschke" fullname="Julian Reschke"/>
      <date month="September" year="2015"/>
    </front>
    <seriesInfo name="RFC" value="7617"/>
    <seriesInfo name="DOI" value="10.17487/RFC7617"/>
  </reference>

</references>

<section title="Changes from RFC 2617" anchor="rfc2617.changes">
<t>

This document introduces the following changes:
<list style="symbols">

<t>
Adds support for two new algorithms, SHA2-256 as mandatory and SHA2-512/256 as a backup, and defines the proper algorithm negotiation.
The document keeps the MD5 algorithm support but only for backward compatibility.
</t>

<t>
Introduces the username hashing capability and the parameter associated with that, mainly for privacy reasons.
</t>

<t>
Adds various internationalization considerations that impact the A1 calculation and username and password encoding.
</t>
<t>
  Introduces a new IANA registry, "Hash Algorithms for HTTP Digest Authentication",
  that lists the hash algorithms that can be used in HTTP Digest
  Authentication.
</t>
<t>
Deprecates backward compatibility with RFC 2069.
</t>

</list>
</t>

</section>

<section title="Acknowledgments" numbered="no">
<t>
To provide a complete description for the Digest mechanism and its operation, this document
borrows text heavily from <xref target="RFC2617"/>. The authors of this document would like to
thank John Franks, Phillip M.&nbsp;Hallam-Baker, Jeffery L.&nbsp;Hostetler, Scott D.&nbsp;Lawrence, Paul J.&nbsp;Leach,
Ari Luotonen, and Lawrence C.&nbsp;Stewart for their work on that specification.
</t>
<t>
Special thanks to Julian Reschke for his many reviews, comments, suggestions, and text provided to various areas in this document.
</t>
<t>
The authors would like to thank Stephen Farrell, Yoav Nir, Phillip Hallam-Baker, Manu Sporny, Paul Hoffman, Yaron Sheffer, Sean Turner,
Geoff Baskwill, Eric Cooper, Bjoern Hoehrmann, Martin Durst, Peter Saint-Andre, Michael Sweet,
Daniel Stenberg, Brett Tate, Paul Leach, Ilari Liusvaara, Gary Mort, Alexey Melnikov, Benjamin Kaduk,
Kathleen Moriarty, Francis Dupont, Hilarie Orman, and Ben Campbell for their careful review and comments.
</t>
<t>
The authors would like to thank Jonathan Stoke, Nico Williams, Harry Halpin, and Phil Hunt for their comments on the mailing list when discussing various aspects of this document.
</t>
<t>
The authors would like to thank Paul Kyzivat and Dale Worley for their careful review and feedback on some aspects of this document.
</t>
<t>
The authors would like to thank Barry Leiba for his help with the registry.
</t>

</section>


  </back>


</rfc>
