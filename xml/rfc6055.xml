<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY rfc821 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.0821.xml'>
<!ENTITY rfc952 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.0952.xml'>
<!ENTITY rfc1001 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1001.xml'>
<!ENTITY rfc1002 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1002.xml'>
<!ENTITY rfc1034 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1034.xml'>
<!ENTITY rfc1123 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1123.xml'>
<!ENTITY rfc1468 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1468.xml'>
<!ENTITY rfc1535 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1535.xml'>
<!ENTITY rfc1536 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1536.xml'>
<!ENTITY rfc2119 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
<!ENTITY rfc2130 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2130.xml'>
<!ENTITY rfc2136 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2136.xml'>
<!ENTITY rfc2181 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2181.xml'>
<!ENTITY rfc2277 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2277.xml'>
<!ENTITY rfc2492 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2492.xml'>
<!ENTITY rfc2616 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml'>
<!ENTITY rfc2781 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2781.xml'>
<!ENTITY rfc3397 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3397.xml'>
<!ENTITY rfc3490 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3490.xml'>
<!ENTITY rfc3492 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3492.xml'>
<!ENTITY rfc3493 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3493.xml'>
<!ENTITY rfc3629 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml'>
<!ENTITY rfc3646 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3646.xml'>
<!ENTITY rfc4343 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4343.xml'>

<!ENTITY rfc4690 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4690.xml'>
<!ENTITY rfc4795 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4795.xml'>
<!ENTITY rfc4952 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4952.xml'>
<!ENTITY rfc5198 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5198.xml'>
<!ENTITY rfc5321 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5321.xml'>
<!ENTITY rfc5731 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5731.xml'>
<!ENTITY rfc5890 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5890.xml'>
<!ENTITY rfc5891 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5891.xml'>

]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc compact="yes"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments='yes' ?>
<?rfc inline='yes' ?>
<?rfc rfcedstyle="yes" ?>

<rfc category="info" number="6055" ipr="trust200902"
	 updates="2130" submissionType="IAB">

<!-- [rfced] Please insert any keywords (beyond those that appear in
the title) for use on http://www.rfc-editor.org/rfcsearch.html. -->

<!-- [SC] Not clear to me if this is supposed to be a comma-separated list,
or one tag per keyword. I used the latter. Please correct if wrong.
Also I put keywords in the "front" section where I believe xml2rfc expects to find them. -->

<!-- <keyword>example</keyword> -->


<front>
    <title abbrev="IDN Encodings">
      IAB Thoughts on Encodings for Internationalized Domain Names
    </title>
    <author initials="D." surname="Thaler" fullname="Dave Thaler">
        <organization abbrev="Microsoft">
            Microsoft Corporation
        </organization>
        <address>
            <postal>
                <street>One Microsoft Way</street>
                <city>Redmond</city> <region>WA</region> <code>98052</code>
                <country>USA</country>
            </postal>
            <phone>+1 425 703 8835</phone>
            <email>dthaler@microsoft.com</email>
        </address>
    </author>
    <author initials="J." surname="Klensin" fullname="John C Klensin">
        <organization/>
        <address>
            <postal>
                <street>1770 Massachusetts Ave, Ste 322</street>
                <city>Cambridge</city> <region>MA</region> <code>02140</code>
            </postal>
            <phone>+1 617 245 1457</phone>
            <email>john+ietf@jck.com</email>
        </address>
    </author>
    <author initials="S." surname="Cheshire" fullname="Stuart Cheshire">
        <organization abbrev="Apple">
            Apple Inc.
        </organization>
        <address>
            <postal>
                <street>1 Infinite Loop</street>
                <city>Cupertino</city> <region>CA</region> <code>95014</code>
            </postal>
            <phone>+1 408 974 3207</phone>
            <email>cheshire@apple.com</email>
        </address>
    </author>
    <date month="February" year="2011"/>

    <keyword>Unicode</keyword>
    <keyword>UTF-8</keyword>

    <abstract>
        <t> This document explores issues with Internationalized
            Domain Names (IDNs) that result from the use of various
            encoding schemes such as UTF-8 and the ASCII-Compatible
            Encoding produced by the Punycode algorithm.  It
            focuses on the importance of agreeing on a single 
            encoding and how complicated the state of affairs ends up being as a result of using
            different encodings today.
        </t>
    </abstract>
</front>

<middle>

<section title="Introduction">
    <t> The goal of this document is to explore what can be learned from some 
        current difficulties in implementing Internationalized Domain Names
        (IDNs).
    </t>
    <t> A domain name consists of a
        sequence of labels, conventionally written separated by dots.
        An IDN is a domain name that
        contains one or more labels that, in turn, contain 
        one or more non-ASCII characters.  
        Just as with plain ASCII domain names, each IDN label must be encoded
        using some mechanism before it can be transmitted in network packets,
        stored in memory, stored on disk, etc. These encodings need to be
        reversible, but they need not store domain names the same way humans
        conventionally write them on paper. For example, when transmitted over
        the network in DNS packets, domain name labels are *not* separated 
        with dots.
    </t>
    
    <t>Internationalized Domain Names for Applications (IDNA),
       discussed later in this document, is the standard that
       defines the use and coding of internationalized domain names
       for use on the public Internet <xref target="RFC5890"/>.
       An <xref target="RFC3490">earlier version of IDNA</xref> is
       now being phased out.  Except where noted, the two versions
       are approximately the same 
       with regard to the issues discussed in this document.  However,
       some explanations appeared in the earlier documents that were
       no longer considered useful when the later revision was created; they are quoted
       here from the documents in which they appear.  In addition, the
       terminology of the two versions differ somewhat; this document
       reflects the terminology of the current version.</t>

    <t> Unicode <xref target="Unicode" /> is a list of characters
        (including non-spacing marks that are used to form some other
        characters),
        where each character is assigned an integer value, called a code point.
        In simple terms a Unicode string is a string of integer code point
        values in the range 0 to 1,114,111 (10FFFF in base 16).
        These integer code points must be encoded using some mechanism
        before they can be transmitted in network packets, stored in memory,
        stored on disk, etc. Some common ways of encoding these integer code
        point values in computer systems include UTF-8, UTF-16, and
        UTF-32.  In addition to the material below, those forms and
        the tradeoffs among them are discussed in Chapter 2 of
        <xref target="Unicode">The Unicode Standard</xref>.
    </t>

    <t> UTF-8 is a mechanism for encoding a
        Unicode code point in a variable number of 8-bit octets, where an
        ASCII code point is preserved as-is.
        Those octets encode a string of integer code
        point values, which represent a string of Unicode characters.
        The authoritative definition of UTF-8 is in Sections 3.9 and 3.10 of
        <xref target="Unicode">The Unicode Standard</xref>, but a description of UTF-8
        encoding can also be found in <xref target="RFC3629">RFC 3629</xref>.  Descriptions and
        formulae can also be found in Annex D of ISO/IEC 10646-1 <xref target="10646"/>.
    </t>

    <t> UTF-16 
        is a mechanism for encoding a 
        Unicode code point in one or two 16-bit integers, described in
        detail in Sections 3.9 and 3.10 of
        <xref target="Unicode">The Unicode Standard</xref>.
        A UTF-16 string encodes a string of integer code
        point values that represent a string of Unicode characters.
    </t>

    <t> UTF-32 (formerly UCS-4), also described in Sections 3.9 and 3.10 of
        <xref target="Unicode">The Unicode Standard</xref>,
        is a mechanism for encoding a Unicode code point in a single 32-bit 
        integer.  A UTF-32 string is thus a string of 32-bit integer code
        point values, which represent a string of Unicode characters.
    </t>

    <t> Note that UTF-16 results in some all-zero octets when code
        points occur early in the Unicode sequence, and UTF-32 always
        has all-zero octets.
    </t>

    <t> IDNA specifies validity of a label, such as what characters it
        can contain, relationships among them, and so on, in Unicode
        terms.  Valid labels can be in either "U-label" or "A-label" form, with the
        appropriate one determined by particular protocols or by
        context.  U-label form is a direct
        representation of the Unicode characters using one of the
        encoding forms discussed above.  This document discusses UTF-8
        strings in many places.  While all U-labels can be represented
        by UTF-8 strings, not all UTF-8 strings are valid U-labels
        (see Section 2.3.2 of the IDNA Definitions document <xref target="RFC5890"/> for a
        discussion of these distinctions).  A-label form
        uses a compressed, ASCII-compatible encoding (an "ACE" in IDNA
        and other terminology) produced by an algorithm called
        Punycode.  U-labels and A-labels 
        are duals of each other: transformations from one to the other
        do not lose information.  The transformation mechanisms are
        specified in the IDNA Protocol document <xref target="RFC5891"/>.
    </t>

    <t> Punycode <xref target="RFC3492" /> is thus a mechanism for encoding a 
        Unicode string in an ASCII-compatible encoding, i.e., using
        only letters, digits, and hyphens from the ASCII character
        set.  When a Unicode label that is valid under the IDNA rules
        (a U-label) is encoded with Punycode for IDNA
        purposes, it is prefixed with "xn--"; the result is called an
        A-label.  The prefix convention
        assumes that no other DNS labels (at least no other DNS
        labels in IDNA-aware applications) are allowed to start with these
        four characters.
        Consequently, when A-label encoding is assumed, any DNS labels
        beginning with "xn--" now have a different meaning (the Punycode
        encoding of a label containing one or more non-ASCII characters)
        or no defined meaning at all (in the case of labels that
        are not IDNA-compliant, i.e., are not well-formed A-labels).
    </t>

    <t> ISO-2022-JP <xref target="RFC1468" /> is a mechanism for encoding 
        a string of ASCII
        and Japanese characters, where an ASCII character is
        preserved as-is.  ISO-2022-JP is stateful: special 
        sequences are used to switch between character coding tables.
        As a result, if there are lost or mangled characters in
        a character stream, it is extremely difficult to recover
        the original stream after such a lost character encoding shift.
    </t>

    <t> Comparison of Unicode strings is not as easy as comparing
        ASCII strings. First, there are a multitude of
        ways to represent a string of Unicode characters. 
        Second, in many languages and scripts, the actual definition of 
        "same" is very context-dependent. Because of this, comparison of 
        two Unicode strings must take into account how the Unicode strings 
        are encoded.  Regardless of the encoding, however, comparison 
        cannot simply be done by comparing the encoded Unicode strings 
        byte by byte. The only time that is possible is when the
        strings are both mapped into some canonical form and encoded the same 
        way.
    </t>

    <t> In 1996 the IAB sponsored a workshop on character sets and encodings
        <xref target="RFC2130" />.  This document adds to
        that discussion and focuses on the importance of agreeing on a single 
        encoding and how complicated the state of affairs ends up being as a result 
        of using different encodings today.
    </t>

    <t> Different applications, APIs, and protocols use different encoding 
        schemes today.  Many of them were originally defined 
        to use only ASCII.  <xref target="RFC5890">Internationalizing
        Domain Names in Applications (IDNA)</xref> defines a mechanism that
        requires changes to applications, but in an attempt not to change
        APIs or servers, specifies that the A-label format is to be
        used in many contexts. In some
        ways this could be seen as not changing the existing APIs, in the
        sense that the strings being passed to and from the APIs are still
        apparently ASCII strings. In other ways it is a very profound 
        change to the
        existing APIs, because while those strings are still syntactically
        valid ASCII strings, they no longer mean the same thing that they 
        used to.
        What looks like a plain ASCII string to one piece of software or
        library could be seen by another piece of software or library
        (with the application of out-of-band information)
        to be in fact an encoding of a Unicode string.
    </t>

    <t> <?rfc needLines="8" ?>
        Section 1.3 of the original IDNA specification
        <xref target="RFC3490"/> states:
    </t>

    <t>
    <list style="empty">
        <t> The IDNA protocol is contained completely within applications.  It
            is not a client-server or peer-to-peer protocol: everything is 
            done inside the application itself.  When used with a DNS 
            resolver library, IDNA is inserted as a "shim" between the 
            application and the resolver library.  When used for writing 
            names into a DNS zone, IDNA is used just before the name is 
            committed to the zone.
        </t>
    </list>
    </t>

    <t> Figure 1 depicts a simplistic architecture that a naive reader
        might assume from the paragraph quoted above.  (A variant of
        this same picture appears in
        Section 6 of the original IDNA specification <xref target="RFC3490"/>,
        further strengthening this assumption.)
    </t>

    <figure align="center" anchor="SimplisticArchitecture">
        <artwork align="center"><![CDATA[
+-----------------------------------------+
|Host                                     |
|             +-------------+             |
|             | Application |             |
|             +------+------+             |
|                    |                    |
|               +----+----+               |
|               |   DNS   |               |
|               | Resolver|               |
|               | Library |               |
|               +----+----+               |
|                    |                    |
+-----------------------------------------+
                     |
            _________|_________
           /                   \
          /                     \
         /                       \
        |         Internet        |
         \                       /
          \                     /
           \___________________/
]]></artwork>
        <postamble>Simplistic Architecture
        </postamble>
    </figure>

    <t> There are, however, two problems with this simplistic architecture 
        that cause it to differ from reality.
    </t>
    <t> First, resolver APIs on Operating Systems (OSs) today
        (Mac OS, Windows, Linux, etc.) are not DNS-specific. They typically
        provide a layer of indirection so that the application can work
        independent of the name resolution mechanism, which could be DNS,
        <xref target="DNS-MULTICAST">mDNS</xref>,
        <xref target="RFC4795">LLMNR</xref>,
        <xref target="RFC1001">NetBIOS-over-TCP</xref><xref target="RFC1002"/>,
        <xref target="RFC0952">hosts table </xref>,
        <xref target="NIS">NIS</xref>, or anything else.  For example, 
        <xref target="RFC3493">"Basic Socket Interface Extensions for
        IPv6"</xref> specifies the 
        getaddrinfo() API and contains many phrases like "For example, 
        when using the DNS" and "any type of name resolution service 
        (for example, the DNS)".  Importantly, DNS is mentioned only as
        an example, and the application has no knowledge as to whether
        DNS or some other protocol will be used.
    </t>
    <t> Second, even with the DNS protocol, private namespaces 
        (sometimes including private uses of the DNS) do not
        necessarily use the  
        same character set encoding scheme as the public Internet
        namespace.
    </t>

    <t> We will discuss each of the above issues in subsequent sections.
        For reference, Figure 2 depicts a more realistic architecture on
        typical hosts today (which don't have IDNA inserted as a shim
        immediately above the DNS resolver library).  More generally, 
        the host may be attached
        to one or more local networks, each of which may or may not be
        connected to the public Internet and may or may not have a private 
        namespace.
    </t>

    <figure align="center" anchor="RealisticArchitecture">
        <artwork align="center"><![CDATA[
+-----------------------------------------+
|Host                                     |
|             +-------------+             |
|             | Application |             |
|             +------+------+             |
|                    |                    |
|             +------+------+             |
|             |   Generic   |             |
|             |    Name     |             |
|             |  Resolution |             |
|             |     API     |             |
|             +------+------+             |
|                    |                    |
|   +-----+------+---+--+-------+-----+   |
|   |     |      |      |       |     |   |
| +-+-++--+--++--+-++---+---++--+--++-+-+ |
| |DNS||LLMNR||mDNS||NetBIOS||hosts||...| |
| +---++-----++----++-------++-----++---+ |
|                                         |
+-----------------------------------------+
                     |
               ______|______
              /             \
             /               \
            /      local      \
            \     network     /
             \               /
              \_____________/
                     |
            _________|_________
           /                   \
          /                     \
         /                       \
        |         Internet        |
         \                       /
          \                     /
           \___________________/
]]></artwork>
        <postamble>Realistic Architecture
        </postamble>
    </figure>

<?rfc needLines="12" ?>
    <section title="APIs">
        <t> Section 6.2 of the original IDNA specification
            <xref target="RFC3490"/> states (where ToASCII and ToUnicode 
            below refer to conversions using the Punycode algorithm):
        </t>
        <t>
        <list style="empty">
            <t> It is expected that new versions of the resolver libraries 
                in the future will be able to accept domain names in other 
                charsets than ASCII, and application developers might one 
                day pass not only domain names in Unicode, but also in local 
                script to a new API for the resolver libraries in the 
                operating system.  Thus the ToASCII and ToUnicode operations
                might be performed inside these new versions of the resolver 
                libraries.
            </t>
        </list>
        </t>
        <t> Resolver APIs such as getaddrinfo() and its predecessor 
            gethostbyname() were defined to accept C-Language "char *" arguments,
            meaning they accept a string of bytes, terminated with
            a NULL (0) byte.  Because of the use of a NULL octet as
            a string terminator, this is sufficient for ASCII strings
            (including A-labels) and even ISO-2022-JP <xref target="RFC1468" />
and UTF-8 strings 
            (unless an implementation artificially precludes them), but 
            not UTF-16 or UTF-32 strings because a NULL octet could appear 
            in the middle of strings using these encodings.  Several 
            operating systems 
            historically used in Japan will accept (and expect) ISO-2022-JP 
            strings in such APIs.  Some platforms used worldwide also
            have new versions of the APIs (e.g., GetAddrInfoW() on Windows) 
            that accept other encoding schemes such as UTF-16.
        </t>
        <t> It is worth noting that an API using C-Language "char *" arguments can
            distinguish between conventional ASCII "hostname"
            labels, A-labels, ISO-2022-JP, and UTF-8 labels in names
            if the coding is known to be one of those four, and the
            label is intact (no lost or mangled characters).
            If a stateful encoding like ISO-2022-JP is used,
            applications extracting labels from text must take
            special precautions to be sure that the appropriate
            state-setting characters are included in the string
            passed to the API.
        </t>
        <t> <?rfc needLines="13" ?>
            An example method for distinguishing among such codings is 
            as follows:
            <list style="symbols">
            <t> if the label contains an ESC (0x1B) byte, the label is
                ISO-2022-JP; otherwise,
            </t>
            <t> if any byte in the label has the high bit set, the label 
                is UTF-8; otherwise,
            </t>
            <t> if the label starts with "xn--", then it is presumed to
                be an A-label; otherwise,
            </t>
            <t> the label is ASCII (and therefore, by definition,
                the label is also UTF-8, since ASCII is a subset of UTF-8).
            </t>
            </list>
            Again this assumes that ASCII labels never start 
            with "xn--", 
            and also that UTF-8 strings never contain an ESC character.
            Also the above is merely an illustration; UTF-8 can be detected
            and distinguished from other 8-bit encodings with good
            accuracy <xref target="MJD" />.
        </t>
        <t> It is more difficult or impossible to distinguish
            the ISO 8859 character sets <xref target="ISO8859" /> from each other, because they 
            differ in up to about 90 characters that have exactly 
            the same encodings, and a short string is very unlikely to 
            contain enough 
            characters to allow a receiver to deduce the character set.
            Similarly, it is not possible in general
            to distinguish between ISO-2022-JP and any other encoding
            based on ISO 2022 code table switching.
        </t>
        <t> Although it is possible (as in the example above) to 
            distinguish some encodings 
            when not explicitly specified, it is cleaner to have the 
            encodings specified explicitly, such as specifying UTF-16 for 
            GetAddrInfoW(), or specifying explicitly which APIs
            expect UTF-8 strings.
        </t>
    </section>
</section>

<section title="Use of Non-DNS Protocols">
    <t> As noted earlier, typical name resolution libraries are not 
        DNS-specific.  Furthermore, some protocols are defined to use
        encoding forms other than IDNA A-labels.  For example,
        <xref target="DNS-MULTICAST">mDNS</xref> specifies 
        that UTF-8 be used.  Indeed,
        the IETF policy on character sets and languages 
        <xref target="RFC2277" /> (which followed the 1996 IAB-sponsored workshop
        <xref target="RFC2130" />) states:
    </t>
    <t>
    <list style="empty">
        <t> Protocols MUST be able to use the UTF-8 charset, which consists 
            of the ISO 10646 coded character set combined with the UTF-8 
            character encoding scheme, as defined in [10646] Annex R (published 
            in Amendment 2), for all text.</t>

        <t> Protocols MAY specify, in addition, how to use other charsets or
            other character encoding schemes for ISO 10646, such as UTF-16, but
            lack of an ability to use UTF-8 is a violation of this policy; 
            such a violation would need a variance procedure ([BCP9] 
            section 9) with clear and solid justification in the protocol 
            specification document before being entered into or advanced 
            upon the standards track.</t>

        <t> For existing protocols or protocols that move data from existing
            datastores, support of other charsets, or even using a default 
            other than UTF-8, may be a requirement. This is acceptable, 
            but UTF-8 support MUST be possible.
        </t>
    </list>
    </t>

    <t> Applications that convert an IDN to A-label form before 
        calling getaddrinfo() will result in name resolution failures
        if the Punycode name is directly used in such protocols.
        Having libraries or protocols to convert from A-labels to
        the encoding scheme defined by the protocol (e.g., UTF-8) 
        would require changes to APIs and/or servers, which IDNA was
        intended to avoid.
    </t>
    <t> As a result, applications that assume that non-ASCII names are 
        resolved using the public DNS and blindly convert them to
        A-labels
        without knowledge of what protocol will be selected by the name
        resolution library, have problems.  Furthermore, name resolution
        libraries often try multiple protocols until one succeeds,
        because they are defined to use a common namespace.  For example,
        <xref target="RFC0952">the hosts file</xref>,
        <xref target="RFC1001">NetBIOS-over-TCP</xref>, and
        <xref target="RFC1034">DNS</xref>, are all defined 
        to be able to share a common syntax.
        This means that when
        an application passes a name to be resolved, resolution may in fact
        be attempted using multiple protocols, each with a potentially
        different encoding scheme.  For this to work successfully, the name
        must be converted to the appropriate encoding scheme only after the
        choice is made to use that protocol.  In general, this cannot be done
        by the application since the choice of protocol is not made by the
        application.
    </t>
</section>

<section title="Use of Non-ASCII in DNS">
    <t> A common misconception is that DNS only supports names that
        can be expressed using letters, digits, and hyphens.
    </t>
    <t> This misconception originally stems from the 1985 definition of an 
        "Internet hostname" (and net, gateway, and domain name) 
        for use in the "hosts" file 
        <xref target="RFC0952"/>.  An Internet hostname was defined
        therein as including only letters, digits, and hyphens, where
        uppercase and lowercase letters were to be treated as identical.  
        The DNS specification <xref target="RFC1034"/>, Section 3.5 entitled 
        "Preferred
        name syntax" then repeated this definition in 1987, saying that
        this "syntax will result in fewer problems with many
        applications that use domain names (e.g., mail, TELNET)".
    </t>
    <t> The confusion was thus left as to whether the "preferred"
        name syntax was a mandatory restriction in DNS, or merely "preferred".
    </t>
    <t> The definition of an Internet hostname was updated in 1989 (<xref
target="RFC1123"/>, Section 2.1) to allow names starting with a digit. However,
it did not address the increasing confusion as to whether all names in DNS are
"hostnames", or whether a "hostname" is merely a special case of a DNS name.
    </t>
    <t> By 1997, things had progressed to a state where it was necessary
        to clarify these areas of confusion. 
        <xref target="RFC2181">"Clarifications to the DNS Specification"</xref>,
        Section 11 states:
    </t>
    <t>
    <list style="empty">
        <t> The DNS itself places only one restriction on the particular 
            labels that can be used to identify resource records.  That one 
            restriction relates to the length of the label and the full 
            name.  The length of any one label is limited to between 1 and 
            63 octets.  A full domain name is limited to 255 octets 
            (including the separators).  The zero length full name is 
            defined as representing the root of the DNS tree, and is 
            typically written and displayed as ".".  Those restrictions 
            aside, any binary string whatever can be used as the label of any 
            resource record.  Similarly, any binary string can serve as 
            the value of any record that includes a domain name as some 
            or all of its value (SOA, NS, MX, PTR, CNAME, and any others 
            that may be added).  Implementations of the DNS protocols must 
            not place any restrictions on the labels that can be used.
    </t>
    </list>
    </t>
    <t> Hence, it clarified that the restriction to letters, digits, and 
        hyphens does not apply to DNS names in general, nor to records 
        that include "domain names".  Hence, the "preferred" name syntax 
        described in the original DNS specification <xref target="RFC1034"/>
        is indeed merely "preferred", not mandatory.
    </t>
    <t> Since there is no restriction even to ASCII, let alone 
        letter-digit-hyphen use, DNS does not violate the subsequent 
        IETF requirement to allow UTF-8 <xref target="RFC2277"/>.
    </t>
    <t> Using UTF-16 or UTF-32 encoding, however, would not be ideal for use
        in DNS packets or C-Language "char *" APIs because existing software 
        already uses ASCII,
        and UTF-16 and UTF-32 strings can contain all-zero octets that
        existing software will interpret as the end of the string.
        To use UTF-16 or
        UTF-32, one would need some way of knowing whether the string was
        encoded using ASCII, UTF-16, or UTF-32, and indeed for UTF-16 or
        UTF-32 whether it was big-endian or little-endian encoding. In
        contrast, UTF-8 works well because any 7-bit ASCII string is
        also a UTF-8 string representing the same characters.
    </t>
    <t> If a private namespace is defined to use UTF-8 (and not
        other encodings such as UTF-16 or UTF-32), 
        there's no need for a mechanism to know whether a string was
        encoded using ASCII or UTF-8, because (for any string that can be
        represented using ASCII) the representations are exactly the same. In
        other words, for any string that can be represented using ASCII, it
        doesn't matter whether it is interpreted as ASCII or UTF-8 because both
        encodings are the same, and for any string that can't be represented
        using ASCII, it's obviously UTF-8. In addition, unlike UTF-16 
        and UTF-32,
        ASCII and UTF-8 are both byte-oriented encodings so the question of
        big-endian or little-endian encoding doesn't apply.
    </t>

    <t> While implementations of the DNS protocol must not place any
        restrictions on the labels that can be used, applications that use the
        DNS are free to impose whatever restrictions they like, and many
        have.  The above rules permit a domain name label that contains
        unusual characters, such as embedded spaces, which many applications
        consider a bad idea.  For example, the original
        specification <xref target="RFC0821"/> of the SMTP protocol
        <xref target="RFC5321" />
        constrains the character set usable in email addresses. 
There is now an effort underway to define an extension to SMTP to support
internationalized email addresses and headers.  See the EAI framework <xref
target="RFC4952"/> for more discussion on this topic.
    </t>

    <t> Shortly after the DNS Clarifications <xref target="RFC2181"/> and
        IETF character sets and languages policy <xref target="RFC2277"/>
        were published, the need for internationalized names within
        private namespaces (i.e., within enterprises) arose.
        The current (and past, predating IDNA and the prefixed ACE
        conventions) practice within enterprises that support other 
        languages is to put UTF-8 names in their internal DNS 
        servers in a private namespace.  For example, 
        "Using the UTF-8 Character Set in the Domain Name System"
        <xref target="UTF8-DNS"/> was first written in 1997,
        and was then widely deployed in Windows.  The use of UTF-8 names
        in DNS was similarly implemented and deployed in Mac OS, simply
        by virtue of the fact that applications blindly passed UTF-8
        strings to the name resolution APIs, the name resolution APIs
        blindly passed those UTF-8 strings to the DNS servers, and the
        DNS servers correctly answered those queries.  From the user's
        point of view, everything worked properly without any special new
        code being written,
        except that ASCII is matched case-insensitively whereas UTF-8 
        is not (although some enterprise DNS servers reportedly attempt
        to do case-insensitive matching on UTF-8 within private namespaces, an
action that causes other problems and violates a subsequent prohibition <xref target="RFC4343"/>).
        Within a private namespace, and especially in light of
        the IETF UTF-8 policy <xref target="RFC2277"/>, it was reasonable 
        to assume that binary strings were encoded in UTF-8.
    </t>
    <t> As implied earlier, there are also issues with mapping strings
        to some canonical form, independent of the encoding.  Such issues
        are not discussed in detail in this document.  They are
        discussed to some extent in, for example,
        Section 3 of "Unicode Format for Network Interchange" <xref target="RFC5198"/>, and are left as
        opportunities for elaboration in other documents.
    </t>
    <t> A few years after UTF-8 was already in use in private namespaces
        in DNS, the strategy of using a reserved prefix and an
        ASCII-compatible encoding (ACE) was developed for IDNA.  That
        strategy included the Punycode algorithm, which began to be
        developed (during the period from 2002
        <xref target="IDN-PUNYCODE" />
        to 2003 <xref target="RFC3492"/>)
        for use in the public DNS namespace.  
        There were a number of reasons for this. One such reason
        the prefixed ACE strategy was selected for the public DNS
        namespace had to do with the fact that other encodings 
        such as ISO 8859-1 were also in use in DNS and the various
        encodings were not necessarily distinguishable from each other.
        Another reason 
        had to do with concerns about whether the details of IDNA,
        including the use of the Punycode algorithm, were an adequate
        solution to the problems that were posed. If either the
        Punycode algorithm or fundamental aspects of character
        handling were wrong, and had to be changed to something
        incompatible, it would be possible to switch to a new prefix
        or adopt another model entirely.  Only the part 
        of the public DNS namespace that starts a label with "xn--" would
        be polluted.
    </t>
    <t> Today the algorithm is seen as being about as good as it can 
        realistically be, so moving to a different encoding (UTF-8 as 
        suggested in this document) that can be viewed as "native" would 
        not be as risky as it would have been in 2002.
    </t>
    <t> In any case, the publication of Punycode <xref target="RFC3492"/> and the 
        dependencies
        on it in the IDNA Protocol document <xref target="RFC5891"/> and the
earlier IDNA specification <xref target="RFC3490"/>
        thus resulted in having to use different encodings for different
        namespaces (where UTF-8 for private namespaces was already 
        deployed).  Hence, referring back to Figure 2, a different encoding
        scheme may be in use on the Internet vs. a local network.
    </t>
    <t> In general, a host may be connected to zero or more networks using
        private namespaces, plus potentially the public namespace.
        Applications that convert a U-label form IDN to an A-label before 
        calling getaddrinfo() will incur name resolution failures
        if the name is actually registered in a private namespace
        in some other encoding (e.g., UTF-8).  Having libraries or 
        protocols convert 
        from A-labels to the encoding used by a private namespace
        (e.g., UTF-8) would require changes to APIs and/or servers, 
        which IDNA was intended to avoid.
    </t>
    <t> Also, a fully-qualified domain name (FQDN) to be resolved may
        be obtained directly from an application, or it may be composed 
        by the DNS resolver itself from a single label obtained from an 
        application by using a configured suffix search list, and the 
        resulting FQDN may use multiple encodings in different labels.  
        For more information on the suffix search list,
        see Section 6 of
        "Common DNS Implementation Errors and Suggested Fixes"
        <xref target="RFC1536" />,
        the DHCP Domain Search Option <xref target="RFC3397" />,
        and Section 4 of "DNS Configuration options for DHCPv6"
        <xref target="RFC3646" />.
    </t>
    <t> As noted in Section 6 of
        "Common DNS Implementation Errors and Suggested Fixes"
        <xref target="RFC1536" />, the community
        has had bad experiences (e.g., security problems <xref target="RFC1535" />) 
        with "searching" for domain names by
        trying multiple variations or appending different suffixes.
        Such searching can yield inconsistent results depending on the
        order in which alternatives are tried.  
        Nonetheless, the practice is widespread and must be considered.
    </t>
    <t> The practice of searching for names, whether by the use
        of a suffix search list or by searching in different namespaces,
        can yield inconsistent results.  For example, even when a 
        suffix search list is only used when an application provides
        a name containing no dots, two clients with different configured 
        suffix search lists can get different answers, and the same
        client could get different answers at different times if
        it changes its configuration (e.g., when moving to another network).
        A deeper discussion of this topic is outside the scope of this
        document.
    </t>

    <section title="Examples">
    <t> Some examples of cases that can happen in existing implementations 
        today (where {non-ASCII} below represents some user-entered non-ASCII
        string) are:
        <list style="symbols">
        <t> User types in {non-ASCII}.{non-ASCII}.com, and the application 
            passes it, in the form of a UTF-8 string, to getaddrinfo() or
            gethostbyname() or equivalent.
            <list style="numbers">
            <t> The DNS resolver passes the (UTF-8) string unmodified to a
                DNS server.
            </t>
            </list>
        </t>
        <t> User types in {non-ASCII}.{non-ASCII}.com, and the application 
            passes it to a name resolution API that accepts strings in
            some other encoding such as UTF-16, e.g., GetAddrInfoW() on
            Windows.
            <list style="numbers">
            <t> The name resolution API decides to pass the string to DNS
                (and possibly other protocols).
            </t>
            <t> The DNS resolver converts the name from UTF-16 to UTF-8 
                and passes the query to a DNS server.
            </t>
            </list>
        </t>
        <t> User types in {non-ASCII}.{non-ASCII}.com, but the application 
            first converts it to A-label form such that the 
            name that is passed to name resolution APIs
            is (say) xn&nbhy;&nbhy;e1afmkfd.xn&nbhy;&nbhy;80akhbyknj4f.com.
            <list style="numbers">
            <t> The name resolution API decides to pass the string to DNS
                (and possibly other protocols).
            </t>
            <t> The DNS resolver passes the string unmodified to a
                DNS server.
            </t>
            <t> If the name is not found in DNS, the name resolution API
                decides to try another protocol, say mDNS.
            </t>
            <t> The query goes out in mDNS, but since mDNS specified that names 
                are to be registered in UTF-8, the name isn't found since 
                it was encoded as an A-label in the query. 
            </t>
            </list>
        </t>
        <t> User types in {non-ASCII}, and the application passes it, in
            the form of a UTF-8 string, to getaddrinfo() or equivalent.
            <list style="numbers">
            <t> The name resolution API decides to pass the string to DNS
                (and possibly other protocols). 
            </t>
            <t> The DNS resolver will append suffixes in the suffix 
                search list, which may contain UTF-8 characters if the
                local network uses a private namespace.
            </t>
            <t> Each FQDN in turn will then be sent in a query to a DNS
                server, until one succeeds. 
            </t>
            </list>
        </t>
        <t> User types in {non-ASCII}, but the application first 
            converts it to an A-label, such that the name that is 
            passed to getaddrinfo() or equivalent is (say) xn&nbhy;&nbhy;e1afmkfd.
            <list style="numbers">
            <t> The name resolution API decides to pass the string to DNS
                (and possibly other protocols).
            </t>
            <t> The DNS stub resolver will append suffixes in the suffix 
                search list, which may contain UTF-8 characters if the
                local network uses a private namespace,
                resulting in (say) xn&nbhy;&nbhy;e1afmkfd.{non&nbhy;ASCII}.com 
            </t>
            <t> Each FQDN in turn will then be sent in a query to a DNS
                server, until one succeeds. 
            </t>
            <t> Since the private namespace in this case uses UTF-8,
                the above queries fail, since the A-label version of the
                name was not registered in that namespace.
            </t>
            </list>
        </t>
        <t> User types in {non-ASCII1}.{non-ASCII2}.{non-ASCII3}.com, where
            {non-ASCII3}.com is a public namespace using IDNA and
            A-labels, but {non-ASCII2}.{non-ASCII3}.com
            is a private namespace using UTF-8,
            which is accessible to the user.  The application passes the
            name, in the form of a UTF-8 string, to getaddrinfo() or
            equivalent.
            <list style="numbers">
            <t> The name resolution API decides to pass the string to DNS (and
                possibly other protocols).
            </t>
            <t> The DNS resolver tries to locate the authoritative server, but
                fails the lookup because it cannot find a server for the UTF-8
                encoding of {non-ASCII3}.com, even though it would have access
                to the private namespace.  (To make this work, the private
                namespace would need to include the UTF-8 encoding of {non-
                ASCII3}.com.)
            </t>
            </list>
        </t>
        </list>
    </t>
    <t> When users use multiple applications, some of which do A-label
        conversion prior to passing a name to name resolution APIs,
        and some of which do not, odd behavior can result which at best
        violates the Principle of Least Surprise, and at worst can result
        in security vulnerabilities. 
    </t>
    <t> First consider two competing applications, such as web browsers,
        that are designed to achieve the same task.  If the user types
        the same name into each browser, one may successfully resolve
        the name (and hence access the desired content) because the 
        encoding scheme is correct, while the other may fail name resolution 
        because the encoding scheme is incorrect.  Hence the issue
        can incent users to switch to another application (which in
        some cases means switching to an IDNA application, and in other
        cases means switching away from an IDNA application).
    </t>
    <t> Next consider two separate applications where one is designed to
        be launched from the other, for example a web browser launching
        a media player application when the link to a media file is clicked.
        If both types of content (web pages and media files in this example)
        are hosted at the same IDN in a private namespace, but one 
        application converts to A-labels
        before calling name resolution APIs and the other does not,
        the user may be able to access a web page, click on the media file
        causing the media player to launch and attempt to retrieve the media
        file, which will then fail because the IDN encoding scheme was
        incorrect.  Or even worse, if an attacker is able to register
        the same name in the other encoding scheme, the user may get the content
        from the attacker's machine.  This is similar to a normal phishing
        attack, except that the two names represent exactly the same
        Unicode characters.
    </t>
    </section>
</section>

<section title="Recommendations">
    <t> On many platforms, the name resolution library will automatically
        use a variety of protocols to search a variety of namespaces,
        which might be using UTF-8 or other encodings.  In addition,
        even when only the DNS protocol is used, in many operational 
        environments, a private DNS namespace using UTF-8 is also 
        deployed and is automatically searched by the name resolution library.
    </t>
    <t> As explained earlier, using multiple canonical formats, and multiple
        encodings in different protocols or even in different places in the
        same namespace creates problems. Because of this, and the fact that
        both IDNA A-labels and UTF-8 are in use as encoding mechanisms for 
        domain names today, we make the recommendations described below.
    </t>
    <t> It is inappropriate for an application 
        that calls a general-purpose name resolution library
        to convert a name to an A-label unless the application
        is absolutely certain that, in all environments where the
        application might be used, only the global DNS that uses IDNA A-labels
        actually will be used to resolve the name.  
    </t>
    <t> Instead, conversion to A-label form, or any other special encoding
        required by a particular name-lookup protocol,
        should be done only by an entity that knows which protocol will be used 
        (e.g., the DNS resolver, or getaddrinfo() upon deciding to pass the 
        name to DNS), rather than by general applications that call 
        protocol-independent name resolution APIs.  (Of course, applications
        that store strings internally in a different format than that required
        by those APIs, need to convert strings from their own internal format
        to the format required by the API.)
        Similarly, even if an application can know that
        DNS is to be used, the conversion to A-labels should be done only by
        an entity that knows which part of the DNS namespace will be used.
    </t>
    <t> That is, a more intelligent DNS resolver would be more liberal in 
        what it would accept from an application and be able to query for 
        both a name in A-label form (e.g., over the Internet) and a UTF-8 name 
        (e.g., over a corporate network with a private namespace) in case 
        the server only recognizes one.  However, we might also take into
        account that the various resolution behaviors discussed earlier
        could also occur with record updates (e.g., with Dynamic Update
        <xref target="RFC2136" />),
        resulting in some names being registered in a local network's 
        private namespace by applications doing conversion to
        A-labels,
        and other names being registered using UTF-8.  Hence, a
        name might have to be queried with both encodings to be sure to
        succeed without changes to DNS servers.
    </t>
    <t> Similarly, a more intelligent stub resolver would also be more 
        liberal in what it would accept from a response as the value of 
        a record (e.g., PTR) in that it would accept either UTF-8
        (U-labels in the case of IDNA) or A-labels and convert them
        to whatever encoding is used by  
        the application APIs to return strings to applications.
    </t>
    <t> Indeed the choice of conversion within the resolver libraries is 
        consistent with the quote from Section 6.2 of the original
        IDNA specification <xref target="RFC3490"/>
        stating that conversion using the Punycode algorithm (i.e., to
        A-labels) "might be performed 
        inside these new versions of the resolver libraries".
    </t>
    <t> That said, some application-layer protocols (e.g., EPP Domain Name
Mapping <xref target="RFC5731" />) are defined to
        use A-labels rather than simply using UTF-8 as recommended by the
        IETF character sets and languages policy
        <xref target="RFC2277" />. 
        In this case, an application may
        receive a string containing A-labels and want to pass it to name 
        resolution
        APIs.  Again the recommendation that a resolver library be more
        liberal in what it would accept from an application would mean
        that such a name would be accepted and re-encoded as needed,
        rather than requiring the application to do so.
    </t>
    <t> It is important that any APIs used by applications to pass names
        specify what encoding(s) the API uses.  For example,
        GetAddrInfoW() on Windows specifies that it accepts UTF-16 and only UTF-16.
        In contrast, the original specification of getaddrinfo()
        <xref target="RFC3493" /> does not, and hence platforms vary in
        what they use (e.g., Mac OS uses UTF-8 whereas Windows uses 
        Windows code pages).
    </t>
    <t> Finally, the question remains about what, if anything, 
        a DNS server should do
        to handle cases where some existing applications or hosts do
        IDNA queries using A-labels within the local network using a
        private namespace,  
        and other existing applications or hosts send UTF-8 queries.
        It is undesirable to store different records for different 
        encodings of the same name, since this introduces the 
        possibility for inconsistency between them.  Instead, a new DNS 
        server serving a private namespace using UTF-8
        could potentially treat encoding-conversion in the same way as 
        case-insensitive comparison which a DNS server is already required
        to do, as long the DNS server has some way to know what the 
        encoding is.
        Two encodings are, in this sense, two representations of 
        the same name, just as two case-different strings are.  However,
        whereas case comparison of non-ASCII characters is complicated 
        by ambiguities (as explained in the IAB's
        Review and Recommendations for Internationalized Domain Names
        <xref target="RFC4690"/>), encoding conversion 
        between A-labels and U-labels is unambiguous.
    </t>
</section>

<section title="Security Considerations">
    <t> Having applications convert names to prefixed ACE format (A-labels)
        before calling 
        name resolution can result in security vulnerabilities.
        If the name is resolved by protocols or in zones for which 
        records are registered using other encoding schemes, an attacker
        can claim the A-label version of the same name and hence trick
        the victim into accessing a different destination.  This can
        be done for any non-ASCII name, even when there is no possible
        confusion due to case, language, or other issues.  Other
        types of confusion beyond those resulting simply from the choice 
        of encoding scheme are discussed in "Review and Recommendations 
        for IDNs"
        <xref target="RFC4690"/>.
    </t>
    <t> Designers and users of encodings that represent Unicode strings 
        in terms of ASCII should also consider whether trademark protection
        or phishing
        are issues, e.g., if one name would be encoded in a way that 
        would be naturally associated with another organization or product.
    </t>
</section>

<section title="Acknowledgements">
    <t> The authors wish to thank Patrik Faltstrom, Martin Duerst,
        JFC Morfin, Ran Atkinson, S. Moonesamy, Paul Hoffman, and
        Stephane Bortzmeyer for their careful review and helpful suggestions.
        It is also interesting to note that none of the first three 
        individuals' names above can be spelled out and written correctly 
        in ASCII text.  Furthermore, one of the IAB member's names below
        (Andrei Robachevsky) cannot be written in the script as it 
        appears on his birth certificate.
    </t>
</section>

<section title="IAB Members at the Time of Approval">
    <figure>
        <artwork>
Bernard Aboba 
Marcelo Bagnulo
Ross Callon 
Spencer Dawkins
Vijay Gill
Russ Housley
John Klensin
Olaf Kolkman
Danny McPherson
Jon Peterson
Andrei Robachevsky 
Dave Thaler
Hannes Tschofenig 
        </artwork>
    </figure>
</section>

</middle>

<back>

<?rfc needLines="5" ?>
<references title="Normative References">
   <reference anchor="10646">
      <front>
      <title>
        Information Technology - Universal Multiple-octet coded
        Character Set (UCS)
             </title>
        <author>
        <organization>International Organization for Standardization</organization>
        <address />
        </author>
        <date year="" />
        </front>
        <annotation>
            ISO/IEC Standard 10646, comprised
            of ISO/IEC 10646-1:2000, "Information technology --
            Universal Multiple-Octet Coded Character Set (UCS) --
            Part 1: Architecture and Basic Multilingual Plane",
            ISO/IEC 10646-2:2001, "Information technology --
            Universal Multiple-Octet Coded Character Set (UCS) --
            Part 2:  Supplementary Planes" and ISO/IEC 10646-
            1:2000/Amd 1:2002, "Mathematical symbols and other
            characters".
        </annotation>
   </reference>

   <reference anchor="Unicode">
      <front>
      <title abbrev="Unicode 5.1">
         The Unicode Standard, Version 5.1.0
             </title>
        <author>
        <organization>The Unicode Consortium</organization>
        <address />
        </author>
        <date year="2008" />
        </front>
        <annotation>defined by: The Unicode Standard, Version 5.0,
           Boston, MA, Addison-Wesley, 2007, ISBN 0-321-48091-0, as
           amended by Unicode 5.1.0
           (http://www.unicode.org/versions/Unicode5.1.0/).</annotation>
   </reference>

</references>

<references title="Informative References">

<reference anchor='ISO8859'>
      <front>
      <title>
Information technology -- 8-bit single-byte coded graphic character sets
             </title>
        <author>
        <organization>International Organization for Standardization</organization>
        <address />
        </author>
        <date year="" />
        </front>
        <annotation>
          ISO/IEC Standard 8859, comprised of 
ISO/IEC 8859-1:1998, Part 1: Latin alphabet No. 1 - 
ISO/IEC 8859-2:1999, Part 2: Latin alphabet No. 2 - 
ISO/IEC 8859-3:1999, Part 3: Latin alphabet No. 3 - 
ISO/IEC 8859-4:1998, Part 4: Latin alphabet No. 4 - 
ISO/IEC 8859-5:1999, Part 5: Latin/Cyrillic alphabet - 
ISO/IEC 8859-6:1999, Part 6: Latin/Arabic alphabet - 
ISO/IEC 8859-7:2003, Part 7: Latin/Greek alphabet - 
ISO/IEC 8859-8:1999, Part 8: Latin/Hebrew alphabet - 
ISO/IEC 8859-9:1999, Part 9: Latin alphabet No. 5 - 
ISO/IEC 8859-10:1998, Part 10: Latin alphabet No. 6 - 
ISO/IEC 8859-11:2001, Part 11: Latin/Thai alphabet - 
ISO/IEC 8859-13:1998, Part 13: Latin alphabet No. 7 - 
ISO/IEC 8859-14:1998, Part 14: Latin alphabet No. 8 (Celtic) - 
ISO/IEC 8859-15:1999, Part 15: Latin alphabet No. 9 - 
ISO/IEC 8859-16:2001, Part 16: Latin alphabet No. 10.
        </annotation>
   </reference>




<!-- I-D.cheshire-dnsext-multicastdns -->

<reference anchor='DNS-MULTICAST'>
<front>
<title>Multicast DNS</title>

<author initials='S' surname='Cheshire' fullname='Stuart Cheshire'>
    <organization />
</author>

<author initials='M' surname='Krochmal' fullname='Marc Krochmal'>
    <organization />
</author>

<date month='February' day='14' year='2011' />

<abstract><t>As networked devices become smaller, more portable, and more ubiquitous, the ability to operate with less configured infrastructure is increasingly important. In particular, the ability to look up DNS resource record data types (including, but not limited to, host names) in the absence of a conventional managed DNS server can be useful.  Multicast DNS (mDNS) provides the ability to perform DNS-like operations on the local link in the absence of any conventional unicast DNS server. In addition, mDNS designates a portion of the DNS namespace to be free for local use, without the need to pay any annual fee, and without the need to set up delegations or otherwise configure a conventional DNS server to answer for those names.  The primary benefits of mDNS names are that (i) they require little or no administration or configuration to set them up, (ii) they work when no infrastructure is present, and (iii) they work during infrastructure failures.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-cheshire-dnsext-multicastdns-12.txt' />
</reference>


    &rfc821;
    &rfc952;
    &rfc1001;
    &rfc1002;
    &rfc1034;
    &rfc1123;
    &rfc1468;
    &rfc1535;
    &rfc1536;
    &rfc2130;
    &rfc2136;
    &rfc2181;
    &rfc2277;
    &rfc3397;
    &rfc3490;
    &rfc3492;
    &rfc3493;
    &rfc3629;
    &rfc3646;
    &rfc4343;
    &rfc4690;
    &rfc4795;
    &rfc4952;
    &rfc5198;
    &rfc5321;
    &rfc5731;

    <reference anchor="NIS">
    <front>
    <title>System and Network Administration</title> 
    <author initials="" surname="" fullname="">
    <organization>Sun Microsystems</organization>
    </author>
    <date month="March" year="1990" /> 
    </front>
    </reference>


<!-- I-D.skwan-utf8-dns-00 -->
    <reference anchor="UTF8-DNS"> 
    <front>
    <title>Using the UTF-8 Character Set in the Domain Name System</title> 
    <author initials="S" surname="Kwan" fullname="Stuart Kwan">
    <organization /> 
    </author>
    <author initials="J" surname="Gilroy" fullname="James Gilroy">
    <organization /> 
    </author>
    <date month="November" year="1997" /> 
    </front>
    <seriesInfo name="Work in" value="Progress" /> 
    <format type="TXT" 
        target="http://tools.ietf.org/id/draft-skwan-utf8-dns-00.txt" /> 
    </reference>

<!-- I-D.ietf-idn-punycode-00 -->
    <reference anchor="IDN-PUNYCODE">

    <front>
    <title>Punycode version 0.3.3</title> 
    <author initials="A" surname="Costello" fullname="Adam M. Costello">
    <organization /> 
    </author>
    <date month="January" day="6" year="2002" /> 
    </front>
    <seriesInfo name="Work in" value="Progress" /> 
    <format type="TXT" 
        target="http://tools.ietf.org/id/draft-ietf-idn-punycode-00.txt" /> 
    </reference>

    <reference anchor="MJD"
       target="http://www.ifi.unizh.ch/mml/mduerst/papers/PDF/IUC11-UTF-8.pdf"> 
    <front>
    <title>The Properties and Promizes of UTF-8</title> 
    <author initials="M" surname="Duerst" fullname="Martin J. Duerst">
    <organization>University of Zurich</organization> 
    </author>
    <date month="September" day="" year="1997" /> 
    </front>
    <seriesInfo name="11th International Unicode Conference, San Jose" 
        value="" /> 
    </reference>


&rfc5890;
&rfc5891;

</references> 
<?rfc needLines="26" ?>
</back>
</rfc>
