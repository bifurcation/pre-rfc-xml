<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC2119 SYSTEM "reference.RFC.2119.xml">
  <!ENTITY RFC5681 SYSTEM "reference.RFC.5681.xml">
  <!ENTITY RFC5348 SYSTEM "reference.RFC.5348.xml">
  <!ENTITY RFC3649 SYSTEM "reference.RFC.3649.xml">
  <!ENTITY RFC6582 SYSTEM "reference.RFC.6582.xml">
  <!ENTITY RFC4960 SYSTEM "reference.RFC.4960.xml">
  <!ENTITY RFC5033 SYSTEM "reference.RFC.5033.xml">
  <!ENTITY RFC7567 SYSTEM "reference.RFC.7567.xml">
  <!ENTITY RFC6675 SYSTEM "reference.RFC.6675.xml">
  <!ENTITY RFC3742 SYSTEM "reference.RFC.3742.xml">
  <!ENTITY RFC3168 SYSTEM "reference.RFC.3168.xml">
  <!ENTITY RFC8174 SYSTEM "reference.RFC.8174.xml">

]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="3"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc number="8312" category="info" ipr="trust200902" submissionType="IETF" consensus="yes">

	<front>
		<title abbrev='CUBIC'>CUBIC for Fast Long-Distance Networks</title>

		<author initials='I.' surname='Rhee' fullname='Injong Rhee'>
			<organization abbrev='NCSU'>North Carolina State University</organization>
			<address>
				<postal>
					<street>Department of Computer Science</street>
					<city>Raleigh</city>
					<region>NC</region>
					<code>27695-7534</code>
					<country>United States of America</country>
				</postal>
				<email>rhee@ncsu.edu</email>
			</address>
		</author>

		<author initials='L.' surname='Xu' fullname='Lisong Xu'>
			<organization abbrev='UNL'>University of Nebraska-Lincoln</organization>
			<address>
				<postal>
					<street>Department of Computer Science and Engineering</street>
					<city>Lincoln</city>
					<region>NE</region>
					<code>68588-0115</code>
					<country>United States of America</country>
				</postal>
				<email>xu@unl.edu</email>
			</address>
		</author>

		<author initials='S.' surname='Ha' fullname='Sangtae Ha'>
			<organization abbrev='Colorado'>University of Colorado at Boulder</organization>
			<address>
				<postal>
					<street>Department of Computer Science</street>
					<city>Boulder</city>
					<region>CO</region>
					<code>80309-0430</code>
					<country>United States of America</country>
				</postal>
				<email>sangtae.ha@colorado.edu</email>
			</address>
		</author>

		<author initials='A.' surname='Zimmermann' fullname='Alexander Zimmermann'>
			<address>
				<phone>+49 175 5766838</phone>
				<email>alexander.zimmermann@rwth-aachen.de</email>
			</address>
		</author>

		<author initials='L.' surname='Eggert' fullname='Lars Eggert'>
			<organization>NetApp</organization>
			<address>
				<postal>
					<street>Sonnenallee 1</street>
					<city>Kirchheim</city>
					<code>85551</code>
					<country>Germany</country>
				</postal>
				<phone>+49 151 12055791</phone>
				<email>lars@netapp.com</email>
			</address>
		</author>

		<author initials='R.' surname='Scheffenegger' fullname='Richard Scheffenegger'>
			<organization>NetApp</organization>
<address><postal>
<street>Am Europlatz 2</street>
<city>Vienna</city>
<code>1120</code>
<country>Austria</country></postal>
				<email>rs.ietf@gmx.at</email>
			</address>
		</author>

		<date month="February" year="2018"/>


		<area>Transport</area>

		<workgroup>TCP Maintenance and Minor Extensions (TCPM) WG</workgroup>

		<keyword>TCP Congestion Control</keyword>

		<abstract>
			<t>CUBIC is an extension to the current TCP standards. It
			differs from the current TCP standards only in the congestion
			control algorithm on the sender side. In particular, it
			uses a cubic function instead of a linear window increase function of the
			current TCP standards to improve scalability and stability under
			fast and long-distance networks.  CUBIC and its predecessor algorithm have been adopted as 
   defaults by Linux and have been used for many years. This document provides a
   specification of CUBIC to enable third-party implementations and 
   to solicit community feedback through experimentation on the
   performance of CUBIC.</t>
		</abstract>

	</front>


	<middle>

		<section title='Introduction'>
			<t>The low utilization problem of TCP in fast long-distance networks
			is well documented in <xref target="K03"/> and <xref target="RFC3649"/>.
			This problem arises from a slow increase of the congestion window
			following a congestion event in a network with a large
			bandwidth-delay product (BDP). 

<xref target="HKLRX06"/> indicates that this problem is frequently observed
even in the range of congestion window sizes over several hundreds of packets. This problem is
			equally applicable to all Reno-style TCP standards and their
			variants, including TCP-RENO <xref target="RFC5681"/>, TCP-NewReno
			<xref target="RFC6582"/> <xref target="RFC6675"/>, SCTP
			<xref target="RFC4960"/>, and TFRC <xref target="RFC5348"/>, which use
			the same linear increase function for window growth, which we refer
			to collectively as "Standard TCP" below.</t>

            <t> CUBIC, originally proposed in <xref target="HRX08"/>, is a modification to the congestion
			control algorithm of Standard TCP to remedy this problem. This document describes the most recent specification of CUBIC.
    Specifically, CUBIC uses a cubic function instead of a linear window increase function of 
			Standard TCP to improve scalability and stability under
			fast and long-distance networks. </t>

    <t>Binary Increase Congestion Control (BIC-TCP) <xref target="XHR04"/>, a predecessor of CUBIC, was
    selected as the default TCP congestion control algorithm by Linux in the
    year 2005 and has been used for several years
   by the Internet community at large. CUBIC uses a similar window increase function
   as BIC-TCP and is designed to be less aggressive and fairer to Standard TCP in
   bandwidth usage than BIC-TCP while maintaining the strengths of BIC-TCP 
   such as stability, window scalability, and RTT fairness.
   CUBIC has already replaced BIC-TCP as the default TCP congestion control algorithm in Linux
    and has been deployed globally by Linux. Through
   extensive testing in various Internet scenarios, we believe that
   CUBIC is safe for testing and deployment in the global Internet.</t>

			<t>In the following sections, we first briefly explain the design principles of CUBIC, 
then provide the exact specification of
			CUBIC, and finally discuss the safety features of CUBIC following the
			guidelines specified in <xref target="RFC5033"/>.</t>

		</section>


		<section title='Conventions'>

        <t>
    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
    "MAY", and "OPTIONAL" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>

		</section>

		<section title='Design Principles of CUBIC'>

            <t> CUBIC is designed according to the following design principles:
					<list style='hanging'>
						<t>Principle 1: For better network utilization and stability, CUBIC uses both the concave and convex profiles of a cubic function 
            to increase the congestion window size, instead of using just a convex function. </t>
						<t>Principle 2: To be TCP-friendly, CUBIC is designed to behave like Standard TCP in networks 
            with short RTTs and small bandwidth where Standard TCP performs well. </t>
						<t>Principle 3: For RTT-fairness, CUBIC is designed to achieve linear bandwidth sharing among flows with different RTTs. </t>
						<t>Principle 4: CUBIC
						appropriately sets its
						multiplicative window decrease
						factor in order to 
balance between the scalability and convergence speed. </t>
					</list>
            </t>

 
			<t>Principle 1: For better network utilization and stability, 
CUBIC <xref target="HRX08"/> uses a cubic window increase function 
in terms of the elapsed time from
			the last congestion event. While most alternative congestion control algorithms to
			Standard TCP increase the congestion window using convex functions, CUBIC uses both
			the concave and convex profiles of a cubic function for window
			growth. After a window reduction in response to a
			congestion event is detected by 
duplicate ACKs or Explicit Congestion Notification-Echo (ECN-Echo) ACKs <xref target="RFC3168"/>,
CUBIC			registers the congestion window size where it got the congestion event as W_max and
			performs a multiplicative decrease of congestion window. After it
			enters into congestion avoidance, it starts to
			increase the congestion window using the concave profile of the cubic
			function. The cubic function is set to have its plateau at W_max
			so that the concave window increase continues until the window size becomes
			W_max. After that, the cubic function turns into a convex profile
			and the convex window increase begins. This style of window
			adjustment (concave and then convex) improves the algorithm
			stability while maintaining high network utilization <xref
				target="CEHRX07"/>. This is because the window size remains
			almost constant, forming a plateau around W_max where network
			utilization is deemed highest. Under steady state, most window
			size samples of CUBIC are close to W_max, thus promoting high
			network utilization and stability. Note that those congestion control algorithms
			using only convex functions to increase the congestion window size have the maximum increments around
			W_max, and thus introduce a large number of packet bursts around the
			saturation point of the network, likely causing frequent global
			loss synchronizations.</t>

			<t>Principle 2: CUBIC promotes per-flow fairness to Standard TCP. Note
			that Standard TCP performs well under short RTT and small bandwidth
			(or small BDP) networks. There is only a scalability
			problem in networks with long
			RTTs and large bandwidth (or large BDP).
			An alternative congestion control algorithm to Standard TCP designed to be friendly to
			Standard TCP on a per-flow basis must operate to increase its congestion
			window less aggressively in small BDP networks than in large
			BDP networks. 
The aggressiveness of CUBIC mainly depends on the maximum window size before a window reduction, 
which is smaller in small BDP networks than in large BDP networks. Thus, CUBIC increases its congestion
			window less aggressively in small BDP networks than in large
			BDP networks. 
Furthermore, in cases when the cubic function of CUBIC increases its congestion window less aggressively than Standard TCP, 
CUBIC simply follows the window size of	Standard TCP to ensure that CUBIC
   achieves at least the same throughput as Standard TCP in small BDP
			networks. We call this region where CUBIC behaves like Standard TCP,
			the "TCP-friendly region".</t>

			<t>Principle 3: Two CUBIC flows with different RTTs have their throughput ratio 
linearly proportional to the inverse of their RTT ratio, where the throughput
of a flow is approximately the size of its congestion window divided by its
RTT. Specifically, CUBIC maintains a window increase rate independent of RTTs
			outside of the TCP-friendly region, and thus flows with different RTTs
			have similar congestion window sizes under steady state when they operate
			outside the TCP-friendly region.            
            This notion of a linear throughput ratio is similar to that of Standard TCP under high statistical multiplexing 
            environments where packet losses are independent of individual flow 
            rates. However, under low statistical multiplexing environments, 
            the throughput ratio of Standard TCP flows with different RTTs 
            is quadratically  proportional to the inverse of their RTT ratio <xref 
            target="XHR04"/>. CUBIC always ensures the linear throughput ratio independent of the 
            levels of statistical multiplexing.  This is an improvement over 
            Standard TCP. While there is no consensus on particular throughput ratios of different RTT flows, we believe that under wired 
            Internet, use of a linear throughput ratio seems more reasonable than 
            equal throughputs (i.e., the same throughput for flows with
	    different RTTs) or a higher-order throughput ratio
             (e.g., a quadratical throughput ratio of Standard TCP under low statistical multiplexing environments). </t>

			<t>Principle 4: To balance between the scalability and convergence speed, 
CUBIC sets the multiplicative window decrease factor to 0.7 while
			Standard TCP uses 0.5. While this improves the scalability of CUBIC,
 a side effect of this decision is slower convergence, especially under low statistical multiplexing environments. This
			design choice is following the observation that the
			author of HighSpeed TCP (HSTCP)
			<xref target="RFC3649"/> has made along with other researchers
			(e.g., <xref target="GV02"/>): the current Internet becomes more
			asynchronous with less frequent loss synchronizations with high
			statistical multiplexing. Under this environment, even 
strict Multiplicative-Increase Multiplicative-Decrease (MIMD)
			can converge. CUBIC flows with the same RTT always converge to the
			same throughput independent of statistical multiplexing,
			thus achieving intra-algorithm fairness. We also find that under the
			environments with sufficient statistical multiplexing, the
			convergence speed of CUBIC flows is reasonable.</t>


		</section>


		<section title="CUBIC Congestion Control">

				<t>The unit of all window sizes in this document is segments of 
				the maximum segment size (MSS), and the unit of all times is 
				seconds. Let cwnd denote the congestion window size of a flow,
 and ssthresh denote the slow-start threshold.</t>


			<section title="Window Increase Function">
				<t>CUBIC maintains the acknowledgment (ACK) clocking of Standard
				TCP by increasing the congestion window only at
				the reception of an ACK.  It does not make any change to the fast
				recovery and retransmit of TCP, such as TCP-NewReno <xref target="RFC6582"/>
				<xref target="RFC6675"/>. During congestion
				avoidance after a congestion event where a packet loss is detected by duplicate ACKs or a 
network congestion is detected by ACKs with ECN-Echo flags <xref target="RFC3168"/>, 
CUBIC changes the window increase
				function of Standard TCP. Suppose that W_max is the window
				size just before the window is reduced in the last congestion event.</t>

				<t>CUBIC uses the following window increase	function:</t>

				<t><figure>
<artwork>
    W_cubic(t) = C*(t-K)^3 + W_max (Eq. 1)
</artwork>
					</figure></t>

				<t>where C is a constant fixed to determine the aggressiveness
				of window increase in high BDP networks, t is the elapsed time
				from the beginning of the current congestion avoidance, and K is the time period that
				the above function takes to increase the current window size 
			to W_max if there are no further congestion events and is calculated
				using the following equation:</t>

				<t><figure>
<artwork>
    K = cubic_root(W_max*(1-beta_cubic)/C) (Eq. 2)
</artwork>
					</figure></t>

				<t>where beta_cubic is the CUBIC multiplication decrease factor, 
				that is, when a congestion event is detected, 
CUBIC reduces its cwnd to W_cubic(0)=W_max*beta_cubic. We discuss how we set
beta_cubic in <xref target="multi"/> and how we set C 
				in <xref target="discuss"/>.</t>

				<t>Upon receiving an ACK during congestion avoidance, CUBIC
				computes the window increase rate during the next RTT period
				using Eq.&nbsp;1. It sets W_cubic(t+RTT) as the candidate target 
				value of the congestion window, where RTT is the weighted average RTT calculated by Standard TCP. </t>


				<t> Depending on the value of the current congestion window size cwnd, 
				CUBIC runs in three
				different modes. 
					<list style='numbers'>
		<t>The TCP-friendly region, which ensures that 
                CUBIC achieves at least the same throughput as Standard TCP. </t>
		<t>The concave region, if CUBIC is not in the TCP-friendly
		region and cwnd is less than W_max.</t> 
                <t>The convex region, if CUBIC is not in the TCP-friendly
		region and cwnd is greater than W_max.</t> 
					</list>
                 Below, we describe the exact actions taken by CUBIC in each region.</t>
			</section>

			<section title="TCP-Friendly Region">

                <t>Standard TCP performs well in certain types of networks, for example, under short RTT and small bandwidth (or
   small BDP) networks. In these networks, we use the TCP-friendly region to ensure that
   CUBIC achieves at least the same throughput as Standard TCP.  </t>
   

                <t>The TCP-friendly region is designed according to the analysis described in <xref target="FHP00"/>. 
                The analysis studies the performance of an Additive Increase and Multiplicative 
                Decrease (AIMD) algorithm with an additive factor of alpha_aimd (segments per RTT)
                and a multiplicative factor of beta_aimd, denoted by AIMD(alpha_aimd, beta_aimd). 
                Specifically, the average congestion window size
                of AIMD(alpha_aimd, beta_aimd) can be calculated using Eq.&nbsp;3. The analysis 
                shows that AIMD(alpha_aimd, beta_aimd) with alpha_aimd=3*(1-beta_aimd)/(1+beta_aimd) 
                achieves the same average window size as
                Standard TCP that uses AIMD(1, 0.5). </t>
                
				<t><figure>
<artwork>
    AVG_W_aimd = [ alpha_aimd * (1+beta_aimd) / 
                   (2*(1-beta_aimd)*p) ]^0.5 (Eq. 3)
</artwork>
					</figure>
				</t>

                
                <t>Based on the above analysis, CUBIC uses Eq.&nbsp;4 to estimate the window size W_est of
                 AIMD(alpha_aimd, beta_aimd) with alpha_aimd=3*(1-beta_cubic)/(1+beta_cubic) and beta_aimd=beta_cubic, 
                 which achieves the same average window size as Standard TCP.
                When receiving an ACK in congestion avoidance (cwnd could be greater than or less than W_max), CUBIC checks
				whether W_cubic(t) is less than W_est(t). If so, CUBIC is in the
				TCP-friendly region and cwnd SHOULD be set to W_est(t) at each
				reception of an ACK.</t>
                
				<t><figure>
<artwork>
    W_est(t) = W_max*beta_cubic + 
                [3*(1-beta_cubic)/(1+beta_cubic)] * (t/RTT) (Eq. 4)
</artwork>
					</figure>
				</t>



			</section>


			<section title="Concave Region">
				<t>When receiving an ACK in congestion avoidance, if CUBIC
				is not in the TCP-friendly region and cwnd is less than W_max,
				then CUBIC is in the concave region. In this region,
				cwnd MUST be incremented by (W_cubic(t+RTT) - cwnd)/cwnd 
				for each received ACK, where W_cubic(t+RTT) is calculated using Eq.&nbsp;1.</t>
			</section>


			<section title="Convex Region">
				<t>When receiving an ACK in congestion avoidance, if CUBIC
				is not in the TCP-friendly region and cwnd is larger than or equal to W_max,
				then CUBIC is in the convex region. The convex region indicates that the
				network conditions might have been perturbed since the last
				congestion event, possibly implying more available bandwidth after
				some flow departures. Since the Internet is highly
				asynchronous, some amount of perturbation is always possible
				without causing a major change in available bandwidth. In this
				region, CUBIC is being very careful by very slowly increasing
				its window size. The convex profile ensures that the window
				increases very slowly at the beginning and gradually increases
				its increase rate. 
We also call this region the "maximum probing
				phase" since CUBIC is searching for a new W_max. In this region,
				cwnd MUST be incremented by (W_cubic(t+RTT) - cwnd)/cwnd for 
				each received ACK, where W_cubic(t+RTT) is calculated using Eq.&nbsp;1.</t>
			</section>


			<section anchor="multi" title="Multiplicative Decrease">
				<t>When a packet loss is detected by duplicate ACKs or a network congestion is 
detected by ECN-Echo ACKs, CUBIC updates its W_max, cwnd, and ssthresh as follows.
                Parameter beta_cubic SHOULD be set to 0.7.</t>

				<t><figure>
<artwork>
   W_max = cwnd;                 // save window size before reduction
   ssthresh = cwnd * beta_cubic; // new slow-start threshold
   ssthresh = max(ssthresh, 2);  // threshold is at least 2 MSS
   cwnd = cwnd * beta_cubic;     // window reduction
</artwork>
					</figure></t>

				<t>A side effect of setting beta_cubic to a
				value bigger than 0.5 is
				slower convergence. We believe that while a more adaptive
				setting of beta_cubic could result in faster convergence, it will
				make the analysis of CUBIC much harder. This adaptive
				adjustment of beta_cubic is an item for the next version of
				CUBIC. </t>


			</section>


			<section title="Fast Convergence">
				<t>To improve the convergence speed of CUBIC, we add a heuristic
				in CUBIC. When a new flow joins the network, existing
				flows in the network need to give up some of their bandwidth to
				allow the new flow some room for growth if the existing flows have
				been using all the bandwidth of the network. To speed up this
				bandwidth release by existing flows, the following mechanism
				called "fast convergence" SHOULD be implemented.</t>

				<t>With fast convergence, when a congestion event occurs, before the
				window reduction of the congestion window, a flow remembers the
				last value of W_max before it updates W_max for the current
				congestion event. Let us call the last value of W_max to be
				W_last_max.</t>

				<t><figure>
<artwork>
   if (W_max &lt; W_last_max){ // should we make room for others
       W_last_max = W_max;             // remember the last W_max
       W_max = W_max*(1.0+beta_cubic)/2.0; // further reduce W_max
   } else {                            
       W_last_max = W_max              // remember the last W_max
   }
</artwork>
					</figure></t>

            <t>At a congestion event, if the current value of W_max is less than W_last_max, this indicates 
            that the saturation point experienced by this flow is getting reduced because of the 
            change in available bandwidth. Then we allow this flow to release more bandwidth
by reducing W_max further. This action effectively lengthens the time for this flow to  
increase its congestion window because the reduced W_max forces the flow to have the plateau earlier. 
This allows more time for the new flow to catch up to its congestion window size.</t>


                <t>The fast convergence is designed for network environments with multiple CUBIC flows. In network environments 
                with only a single CUBIC flow and without any other traffic, the fast convergence SHOULD be disabled. </t>
			</section>


			<section title="Timeout">
				<t>In case of timeout, CUBIC follows Standard TCP to reduce cwnd <xref target="RFC5681"/>, 
but sets ssthresh using beta_cubic (same as in <xref target="multi"/>) that is different from Standard TCP <xref target="RFC5681"/>. </t>

                <t>During the first congestion avoidance after a timeout, CUBIC increases its congestion window size 
                using Eq.&nbsp;1, where t is the elapsed time since the beginning of the current congestion avoidance, 
                K is set to 0, and W_max is set to the congestion window size at the beginning of the current congestion avoidance.</t>
			</section>


			<section title="Slow Start">
				<t>CUBIC MUST employ a slow-start algorithm, when the cwnd is no more than ssthresh. 
Among the slow-start algorithms, CUBIC MAY choose the standard TCP slow start <xref target="RFC5681"/> in general networks, 
or the limited slow start <xref target="RFC3742"/> or hybrid slow start <xref target="HR08"/> for fast and long-distance networks.</t>

                <t>In the case when CUBIC runs the hybrid slow start <xref target="HR08"/>, it may exit the first slow start 
                without incurring any packet loss and thus W_max is undefined. In this special case, CUBIC switches to congestion avoidance 
                and increases its congestion window size 
                using Eq.&nbsp;1,
                where t is the elapsed time since the beginning of the current congestion avoidance,
                K is set to 0, and W_max is set to the congestion window size at the beginning of the current congestion avoidance.</t>

			</section>

		</section>


		<section anchor="discuss" title="Discussion">

            <t>In this section, we further discuss the safety features of CUBIC following the
			guidelines specified in <xref target="RFC5033"/>.</t>

			<t>With a deterministic loss model where the number of packets
			between two successive packet losses is always 1/p, CUBIC always
			operates with the concave window profile, which greatly simplifies
			the performance analysis of CUBIC.  The average window size of CUBIC
			can be obtained by the following function:</t>

					<t><figure>
<artwork>
    AVG_W_cubic = [C*(3+beta_cubic)/(4*(1-beta_cubic))]^0.25 * 
                    (RTT^0.75) / (p^0.75) (Eq. 5)
</artwork>
					</figure></t>

				<t>With beta_cubic set to 0.7, the above formula is reduced to:</t>

					<t><figure>
<artwork>
    AVG_W_cubic = (C*3.7/1.2)^0.25 * (RTT^0.75) / (p^0.75) (Eq. 6)
</artwork>
					</figure></t>

				<t>We will determine the value of C in the following subsection
				using Eq.&nbsp;6.</t>


			<section title="Fairness to Standard TCP">

				<t>In environments where Standard TCP is able to make reasonable
				use of the available bandwidth, CUBIC does not significantly
				change this state.</t>

				<t>Standard TCP performs well in the following two types of
				networks:
					<list style='numbers'>
						<t>networks with a small bandwidth-delay product
						(BDP)</t>
						<t>networks with a short RTTs, but not necessarily a
						small BDP</t>
					</list>
				</t>

				<t>CUBIC is designed to behave very similarly to Standard TCP
				in the above two types of networks. The following two tables
				show the average window sizes of Standard TCP, HSTCP, and CUBIC.
				The average window sizes of Standard TCP and HSTCP are from <xref
					target="RFC3649"/>. The average window size of CUBIC is
				calculated using Eq.&nbsp;6 and the CUBIC TCP-friendly region for three
				different values of C.</t>

				<texttable anchor='table1'>
					<ttcol align='right'>Loss Rate P</ttcol>
					<ttcol align='right'>Average TCP W</ttcol>
					<ttcol align='right'>Average HSTCP W</ttcol>
					<ttcol align='right'>CUBIC (C=0.04)</ttcol>
					<ttcol align='right'>CUBIC (C=0.4)</ttcol>
					<ttcol align='right'>CUBIC (C=4)</ttcol>

					<c>10^-2</c><c>12</c><c>12</c><c>12</c><c>12</c><c>12</c>
					<c>10^-3</c><c>38</c><c>38</c><c>38</c><c>38</c><c>59</c>
					<c>10^-4</c><c>120</c><c>263</c><c>120</c><c>187</c><c>333</c>
					<c>10^-5</c><c>379</c><c>1795</c><c>593</c><c>1054</c><c>1874</c>
					<c>10^-6</c><c>1200</c><c>12279</c><c>3332</c><c>5926</c><c>10538</c>
					<c>10^-7</c><c>3795</c><c>83981</c><c>18740</c><c>33325</c><c>59261</c>
					<c>10^-8</c><c>12000</c><c>574356</c><c>105383</c><c>187400</c><c>333250</c>

				</texttable>
<t>Table 1 describes the response function of Standard TCP, HSTCP, and           
                                        CUBIC in networks with RTT = 0.1
					seconds. The average window size  
                                         is in MSS-sized segments.</t>

				<texttable anchor='table2'>
					<ttcol align='right'>Loss Rate P</ttcol>
					<ttcol align='right'>Average TCP W</ttcol>
					<ttcol align='right'>Average HSTCP W</ttcol>
					<ttcol align='right'>CUBIC (C=0.04)</ttcol>
					<ttcol align='right'>CUBIC (C=0.4)</ttcol>
					<ttcol align='right'>CUBIC (C=4)</ttcol>

					<c>10^-2</c><c>12</c><c>12</c><c>12</c><c>12</c><c>12</c>
					<c>10^-3</c><c>38</c><c>38</c><c>38</c><c>38</c><c>38</c>
					<c>10^-4</c><c>120</c><c>263</c><c>120</c><c>120</c><c>120</c>
					<c>10^-5</c><c>379</c><c>1795</c><c>379</c><c>379</c><c>379</c>
					<c>10^-6</c><c>1200</c><c>12279</c><c>1200</c><c>1200</c><c>1874</c>
					<c>10^-7</c><c>3795</c><c>83981</c><c>3795</c><c>5926</c><c>10538</c>
					<c>10^-8</c><c>12000</c><c>574356</c><c>18740</c><c>33325</c><c>59261</c>

				</texttable>

				<t>Table 2 describes the response function of Standard TCP,
				HSTCP, and CUBIC in networks with RTT = 0.01
		                seconds. The average window size is in MSS-sized segments.</t>


				<t>Both tables show that CUBIC with any of these three C values
				is more friendly to TCP than HSTCP, especially in networks with
				a short RTT where TCP performs reasonably well. For example, in
				a network with RTT = 0.01 seconds and p=10^-6, TCP has an average
				window of 1200 packets. If the packet size is 1500 bytes, then
				TCP can achieve an average rate of 1.44 Gbps. In this case,
				CUBIC with C=0.04 or C=0.4 achieves exactly the same rate as
				Standard TCP, whereas HSTCP is about ten times more aggressive
				than Standard TCP.</t>

				<t>We can see that C determines the aggressiveness of CUBIC in
				competing with other congestion control algorithms for bandwidth. CUBIC is more
				friendly to Standard TCP, if the value of C is lower.
				However, we do not recommend setting C to a very low value like
				0.04, since CUBIC with a low C cannot efficiently use the
				bandwidth in long RTT and high-bandwidth networks. Based on
				these observations and our experiments, we find C=0.4 gives a good balance between
				TCP-friendliness and aggressiveness of window increase.


				Therefore, C SHOULD be set to 0.4. With C set to 0.4, Eq.&nbsp;6 is
				reduced to:

					<list>
						<t>AVG_W_cubic = 1.054 * (RTT^0.75) / (p^0.75) (Eq. 7)</t>
					</list>

				Eq.&nbsp;7 is then used in the next subsection to show the
				scalability of CUBIC.</t>
			</section>


			<section title="Using Spare Capacity">
				<t>CUBIC uses a more aggressive window increase function than
				Standard TCP under long RTT and high-bandwidth networks.</t>

				<t>The following table shows that to achieve
				the 10 Gbps rate,
				Standard TCP requires a packet loss rate of 2.0e-10, while
				CUBIC requires a packet loss rate of 2.9e-8.</t>

				<texttable anchor='table3'>
					<ttcol align='right'>Throughput(Mbps)</ttcol>
					<ttcol align='right'>Average W</ttcol>
					<ttcol align='left'>TCP P</ttcol>
					<ttcol align='left'>HSTCP P</ttcol>
					<ttcol align='left'>CUBIC P</ttcol>

					<c>1</c><c>8.3</c><c>2.0e-2</c><c>2.0e-2</c><c>2.0e-2</c>
					<c>10</c><c>83.3</c><c>2.0e-4</c><c>3.9e-4</c><c>2.9e-4</c>
					<c>100</c><c>833.3</c><c>2.0e-6</c><c>2.5e-5</c><c>1.4e-5</c>
					<c>1000</c><c>8333.3</c><c>2.0e-8</c><c>1.5e-6</c><c>6.3e-7</c>
					<c>10000</c><c>83333.3</c><c>2.0e-10</c><c>1.0e-7</c><c>2.9e-8</c>

				</texttable>

<t>Table 3 describes the required packet loss rate for Standard TCP, HSTCP,      
                                        and CUBIC to achieve a certain
					throughput. We use 1500-byte        
                                        packets and an RTT of 0.1 seconds.</t>

				<t>Our test results in <xref target="HKLRX06"/> indicate that
				CUBIC uses the spare bandwidth left unused by existing Standard
				TCP flows in the same bottleneck link without taking away much
				bandwidth from the existing flows.</t>
			</section>


			<section title="Difficult Environments">
				<t>CUBIC is designed to remedy the poor performance of TCP in
				fast and long-distance networks.</t>
			</section>


			<section title="Investigating a Range of Environments">
				<t>CUBIC has been extensively studied by using both NS-2
				simulation and test-bed experiments covering a wide range of
				network environments. More information can be found in <xref
				 target="HKLRX06"/>.</t>

                <t>Same as Standard TCP, CUBIC is a loss-based congestion control algorithm.
                Because  CUBIC is designed to be more aggressive (due to a faster window increase function and 
                bigger multiplicative decrease factor) 
                than Standard TCP in fast and long-distance networks, 
                it can fill large drop-tail buffers more quickly than Standard TCP and 
                increase the risk of a standing queue <xref target='KWAF17'/>. 
                In this case, 
                proper queue sizing and management <xref target="RFC7567"/> 
                could be used to reduce the packet queuing delay.</t>


			</section>


			<section title="Protection against Congestion Collapse">
				<t>With regard to the potential of causing congestion collapse, CUBIC behaves
				like Standard TCP since CUBIC modifies only the window
				adjustment algorithm of TCP. Thus, it does not modify the ACK
				clocking and Timeout behaviors of Standard TCP.</t>
			</section>


			<section title="Fairness within the Alternative Congestion Control Algorithm">
				<t>CUBIC ensures convergence of competing CUBIC flows with the
				same RTT in the same bottleneck links to an equal throughput.  
When competing flows have different RTTs, their
				throughput ratio is linearly proportional to the inverse of
				their RTT ratios. This is true independent of the level of
				statistical multiplexing in the link.</t>
			</section>


			<section title="Performance with Misbehaving Nodes and Outside Attackers">
				<t>This is not considered in the current CUBIC.</t>
			</section>

			<section title="Behavior for Application-Limited Flows">
				<t> CUBIC does not raise its congestion window size if the 
                flow is currently limited by the application instead of the 
                congestion window.  In case of long periods when cwnd has not been  
                updated due to the application rate limit, such as idle periods, t in Eq.&nbsp;1 
                MUST NOT include these periods; otherwise, W_cubic(t) might
                be very high after restarting from these periods.</t>
			</section>


			<section title="Responses to Sudden or Transient Events">
				<t>If there is a sudden congestion, a routing change,
				or a mobility event, CUBIC behaves the same as Standard
				TCP.</t>
			</section>


			<section title="Incremental Deployment">

				<t>CUBIC requires only the change of TCP senders, and it does not make any changes to 
TCP receivers. That is, a CUBIC sender works correctly with the Standard TCP receivers. In addition, CUBIC does not
				require any changes to the routers and does not require any assistance from the routers.</t>
			</section>
		</section>


		<section title="Security Considerations">
			<t>This proposal makes no changes to the underlying security of TCP. More information about
TCP security concerns can be found in <xref target="RFC5681"/>.</t>
		</section>


		<section title="IANA Considerations">

<t>This document does not require any IANA actions.</t>

		</section>


	</middle>


	<back>

		<references title='Normative References'>
			&RFC2119;
			&RFC5681;
			&RFC5348;
			&RFC3649;
			&RFC6582;
			&RFC4960;
			&RFC5033;
			&RFC7567;
			&RFC6675;
			&RFC3742;
			&RFC3168;
                        &RFC8174;
		</references>

		<references title='Informative References'>
			<reference anchor='FHP00'>
				<front>
					<title>A Comparison of Equation-Based and AIMD Congestion Control</title>
					<author initials='S.' surname='Floyd' fullname=''></author>
					<author initials='M.' surname='Handley' fullname=''></author>
					<author initials='J.' surname='Padhye' fullname=''></author>
					<date month='May' year='2000' />
				</front>
			</reference>

			<reference anchor='GV02'>
				<front>
					<title>Extended Analysis of Binary Adjustment Algorithms</title>
					<author initials='S.' surname='Gorinsky' fullname=''></author>
					<author initials='H.' surname='Vin' fullname=''></author>
					<date month='August' year='2002' />
				</front>
				<seriesInfo name="Technical Report" value="TR2002-29"/>
				<seriesInfo name="Department of" value="Computer Sciences"/>
				<seriesInfo name="The University of Texas" value="at Austin"/>
					</reference>

			<reference anchor='K03' >
				<front>
					<title>Scalable TCP: Improving Performance in HighSpeed Wide
					Area Networks</title>
					<author initials='T.' surname='Kelly' fullname=''></author>
					<date month='April' year='2003' />
				</front>
				<seriesInfo name="ACM SIGCOMM Computer"
					    value="Communication Review"/>
<seriesInfo name="DOI" value="10.1145/956981.956989"/>

			</reference>

			<reference anchor='XHR04'>
				<front>
					<title>Binary Increase Congestion Control for Fast, Long
					Distance Networks</title>
					<author initials='L.' surname='Xu' fullname=''></author>
					<author initials='K.' surname='Harfoush' fullname=''></author>
					<author initials='I.' surname='Rhee' fullname=''></author>
					<date month='March' year='2004' />
				</front>
				<seriesInfo name="In Proceedings" value="of IEEE INFOCOM"/>
<seriesInfo name="DOI" value="10.1109/INFCOM.2004.1354672"/>
			</reference>


			<reference anchor='HKLRX06'>
				<front>
					<title>A Step toward Realistic Performance Evaluation of
					High-Speed TCP Variants</title>
					<author initials='S.' surname='Ha' fullname=''></author>
					<author initials='Y.' surname='Kim' fullname=''></author>
					<author initials='L.' surname='Le' fullname=''></author>
					<author initials='I.' surname='Rhee' fullname=''></author>
					<author initials='L.' surname='Xu' fullname=''></author>
					<date />
				</front>
				<seriesInfo name="International Workshop" value="on Protocols for Fast
				Long-Distance Networks"/>
			</reference>

			<reference anchor='HR08'>
				<front>
					<title>Hybrid Slow Start for High-Bandwidth and Long-Distance Networks</title>
					<author initials='S.' surname='Ha' fullname=''></author>
					<author initials='I.' surname='Rhee' fullname=''></author>
					<date />
				</front>
				<seriesInfo name="International Workshop on
						  Protocols" value="for Fast
				Long-Distance Networks"/>
			</reference>

			<reference anchor='HRX08'>
				<front>
					<title>CUBIC: A New TCP-Friendly High-Speed TCP Variant</title>
					<author initials='S.' surname='Ha' fullname=''></author>
					<author initials='I.' surname='Rhee' fullname=''></author>
					<author initials='L.' surname='Xu' fullname=''></author>
					<date month='July' year='2008' />
				</front>
				<seriesInfo name="ACM SIGOPS" value="Operating
								 System Review"/>
<seriesInfo name="DOI" value="10.1145/1400097.1400105"/>
			</reference>

<!-- draft-ietf-tcpm-alternativebackoff-ecn-05 IESG state: I-D Exists -->
<reference anchor='KWAF17'>
<front>
<title>TCP Alternative Backoff with ECN (ABE)</title>

<author initials='N' surname='Khademi' fullname='Naeem Khademi'>
    <organization />
</author>

<author initials='M' surname='Welzl' fullname='Michael Welzl'>
    <organization />
</author>

<author initials='G' surname='Armitage' fullname='Grenville Armitage'>
    <organization />
</author>

<author initials='G' surname='Fairhurst' fullname='Gorry Fairhurst'>
    <organization />
</author>

<date month='December' day='11' year='2017' />

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-tcpm-alternativebackoff-ecn-05' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-tcpm-alternativebackoff-ecn-05.txt' />
</reference>


			<reference anchor='CEHRX07'>
				<front>
					<title>Stochastic Ordering for Internet Congestion Control
					and its Applications</title>
					<author initials='H.' surname='Cai' fullname=''></author>
					<author initials='D.' surname='Eun' fullname=''></author>
					<author initials='S.' surname='Ha' fullname=''></author>
					<author initials='I.' surname='Rhee' fullname=''></author>
					<author initials='L.' surname='Xu' fullname=''></author>
					<date month='May' year='2007' />
				</front>
				<seriesInfo name="In Proceedings of" value="IEEE INFOCOM"/>
<seriesInfo name="DOI" value="10.1109/INFCOM.2007.111"/>
			</reference>
		</references>

		<section title="Acknowledgements" numbered="no">
			<t>Alexander Zimmermann and Lars Eggert have received funding from
			the European Union's Horizon 2020 research and innovation program
			2014-2018 under grant agreement No. 644866 (SSICLOPS). This
			document reflects only the authors' views and the European
			Commission is not responsible for any use that may be made of the
			information it contains.</t>

<t>The work of Lisong Xu was partially supported by the National Science
Foundation (NSF) under Grant No. 1526253. Any opinions, findings, and
conclusions or recommendations expressed in this material are those of the
authors and do not necessarily reflect the views of the NSF.</t>

		</section>

	</back>
</rfc>
