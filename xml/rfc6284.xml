<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY __reference.RFC.3550 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3550.xml">
<!ENTITY __reference.RFC.2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY __reference.RFC.4566 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4566.xml">
<!ENTITY __reference.RFC.3388 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3388.xml">
<!ENTITY __reference.RFC.4585 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4585.xml">
<!ENTITY __reference.RFC.4588 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4588.xml">
<!ENTITY __reference.RFC.4086 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4086.xml">
<!ENTITY __reference.RFC.2104 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml">
<!ENTITY __reference.RFC.5760 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5760.xml">
<!ENTITY __reference.RFC.5761 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5761.xml">
<!ENTITY __reference.RFC.5888 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5888.xml">
<!ENTITY __reference.RFC.5506 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5506.xml">
<!ENTITY __reference.RFC.4145 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4145.xml">
<!ENTITY __reference.RFC.5234 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml">
<!ENTITY __reference.RFC.5226 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY __reference.RFC.2827 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2827.xml">
<!ENTITY __reference.RFC.4648 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY __reference.RFC.5905 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5905.xml">
<!ENTITY __reference.RFC.5751 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5751.xml">
<!ENTITY __reference.RFC.0793 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0793.xml">
<!ENTITY __reference.I-D.ietf-avt-rapid-acquisition-for-rtp SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-avt-rapid-acquisition-for-rtp.xml">
<!ENTITY __reference.RFC.3264 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3264.xml">
<!ENTITY __reference.I-D.ietf-avt-app-rtp-keepalive SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-avt-app-rtp-keepalive.xml">
<!ENTITY __reference.RFC.6222 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6222.xml">
<!ENTITY __reference.RFC.4607 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4607.xml">
<!ENTITY __reference.RFC.4787 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4787.xml">
<!ENTITY __reference.RFC.5389 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5389.xml">
<!ENTITY __reference.RFC.5652 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5652.xml">
<!ENTITY __reference.RFC.2818 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml">
<!ENTITY __reference.RFC.2974 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2974.xml">
<!ENTITY __reference.RFC.5104 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5104.xml">
<!ENTITY __reference.RFC.3711 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3711.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc sortrefs="yes" ?>
<?rfc rfcedstyle="yes"?>

<rfc number="6284" category="std" ipr="trust200902" submissionType="IETF" consensus="yes">
  <front>
    <title abbrev="Port Mapping">Port Mapping between Unicast and Multicast
    RTP Sessions</title>

    <author fullname="Ali Begen" initials="A." surname="Begen">
      <organization abbrev="Cisco">Cisco</organization>

      <address>
        <postal>
          <street>181 Bay Street</street>

          <city>Toronto</city>

          <region>ON</region>

          <code>M5J 2T3</code>

          <country>Canada</country>
        </postal>

        <email>abegen@cisco.com</email>
      </address>
    </author>

    <author fullname="Dan Wing" initials="D." surname="Wing">
      <organization abbrev="Cisco">Cisco</organization>

      <address>
        <postal>
          <street>170 West Tasman Dr.</street>

          <city>San Jose</city>

          <region>CA</region>

          <code>95134</code>

          <country>USA</country>
        </postal>

        <email>dwing@cisco.com</email>
      </address>
    </author>

    <author fullname="Tom Van Caenegem" initials="T." surname="Van Caenegem">
      <organization>Alcatel-Lucent</organization>

      <address>
        <postal>
          <street>Copernicuslaan 50</street>

          <region>Antwerpen</region>

          <code>2018</code>

          <country>Belgium</country>
        </postal>

        <email>Tom.Van_Caenegem@alcatel-lucent.com</email>
      </address>
    </author>

    <date month="June" year="2011" />

    <workgroup>AVT</workgroup>

<keyword>Port mapping</keyword>
<keyword>port translation</keyword>
<keyword>RTP</keyword>
<keyword>multicast</keyword>
<keyword>NAT</keyword>


    <abstract>
      <t>This document presents a port mapping solution that allows RTP
      receivers to choose their own ports for an auxiliary unicast session in
      RTP applications using both unicast and multicast services. The solution
      provides protection against denial-of-service or packet amplification
      attacks that could be used to cause one or more RTP packets to be sent
      to a victim client.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="sec_introduction" title="Introduction">
      <t>In (any-source or source-specific) multicast RTP applications,
      destination ports (i.e., the ports on which the multicast receivers
      receive the RTP and RTP Control Protocol (RTCP) packets) are defined declaratively. In other
      words, the receivers cannot choose their receive ports, and the sender(s)
      use the predefined ports.</t>

      <t>In unicast RTP applications, the receiving end needs to choose its
      ports for RTP and RTCP since these ports are local resources and only
      the receiving end can determine which ports are available to use. In
      addition, Network Address Port Translation (NAPT, hereafter simply
      called NAT) devices are commonly deployed in networks; thus, static port
      assignments cannot be used. The receiving end may convey its request to
      the sending end through different ways, one of which is the Offer/Answer
      Model <xref target="RFC3264"></xref> for the Session Description
      Protocol (SDP) <xref target="RFC4566"></xref>. However, the Offer/Answer
      Model requires offer/answer exchange(s) between the endpoints, and the
      resulting delay may not be desirable in delay-sensitive real-time
      applications. Furthermore, the Offer/Answer Model may be burdensome for
      the endpoints that are concurrently running a large number of unicast
      sessions with other endpoints.</t>

      <t>In this specification, we consider an RTP application that uses one
      or more unicast and multicast RTP sessions together. While the
      declaration and selection of the ports are well defined and work well
      for multicast and unicast RTP applications, respectively, the usage of
      the ports introduces complications when a receiving end mixes unicast
      and multicast RTP sessions within the same RTP application.</t>

      <t>An example scenario is where the RTP packets are distributed through
      source-specific multicast (SSM) <xref target="RFC4607"></xref> and a
      receiver sends unicast RTCP NACK feedback <xref target="RFC4585"></xref> to a local repair server (also
      functioning as a unicast RTCP feedback target) <xref
      target="RFC5760"></xref> asking for a retransmission of the packets it
      is missing, and the local repair server sends the retransmission packets
      over a unicast RTP session <xref target="RETRANSMISSION-FOR-SSM"></xref>.</t>

      <t>Another scenario is where a receiver wants to rapidly acquire a new
      primary multicast RTP session and receives one or more RTP burst packets
      over a unicast session before joining the SSM session; see 
      <xref target="RFC6285"></xref> regarding Rapid
Acquisition of Multicast RTP Sessions (RAMS). Similar
      scenarios exist in applications where some part of the content is
      distributed through multicast while the receivers get additional and/or
      auxiliary content through one or more unicast connections, as illustrated
      in <xref target="fig_network"></xref>.</t>

      <t>In this document, we discuss this problem and introduce a solution
      that we refer to as port mapping. This solution allows receivers to
      choose their desired UDP ports for RTP and RTCP in every unicast session
      when they are running RTP applications using both unicast and multicast
      services and offer/answer exchange is not available. The solution
      includes a Token-based protection mechanism against denial-of-service
      (DoS) or packet amplification attacks that could be used to cause one or
      more RTP packets to be sent to a victim client. This solution is not
      applicable in cases where TCP is used as the transport protocol in the
      unicast sessions. For such scenarios, refer to <xref
      target="RFC4145"></xref>.</t>

      <figure anchor="fig_network"
          title="RTP Applications Simultaneously Using Both Unicast and Multicast Services">
          <artwork align="center"><![CDATA[
 -----------        
|  Unicast  |................
|  Source   |.............  :
| (Server)  |            :  :
 -----------             :  :
                         v  v               
 -----------          ----------             ----------- 
| Multicast |------->|  Router  |---------->|Client RTP |
|  Source   |        |          |..........>|Application|
 -----------          ----------             -----------
                          | :
                          | :                -----------
                          | :..............>|Client RTP |
                          +---------------->|Application|
                                             -----------  


-------> Multicast RTP Flow
.......> Unicast RTP Flow
]]></artwork>
        </figure>

      <t>In the remainder of this document, we refer to the RTP endpoints that
      serve other RTP endpoints over a unicast session as the Servers. The
      receiving RTP endpoints are referred to as Clients. This terminology
      also reflects the fact that when port mapping is used, the RTP packets
      can only flow in one direction (from the server to the client) in the
      unicast sessions.</t>
    </section>

    <section title="Requirements Notation">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in <xref
      target="RFC2119"></xref>.</t>
    </section>


    <section anchor="sec_proposal" title="Token-Based Port Mapping">
      <t>Token-based port mapping consists of the server providing the client
      a Token that can be used to establish a unicast session without the
      possibility of an attacker redirecting traffic to an unsuspecting third
      party to create a DoS attack. The Token is essentially an opaque
      encapsulation that is based on the client's IP address (as seen by the
      server), a time-to-live value, and a random nonce provided by the
      client.</t>

      <t>Token-based port mapping consists of two steps: (i) Token request and
      retrieval, and (ii) unicast session establishment.</t>

      <t>When a Token request is received, the server creates a Token for this
      particular client and sends it back to the client.</t>

      <t>Once a Token is retrieved from a particular server, it can be used
      for all the unicast sessions the client will be running with this
      particular server until the Token expires. By default, Tokens are server
      specific. However, the client can use the same Token to communicate with
      different servers if these servers are provided with the same secret key
      and algorithm used to generate the Token and are at least loosely
      clock-synchronized.</t>

      <t>The Token becomes invalid if the client's IP address (as seen by the
      server) changes (note that the client cannot necessarily detect this in
      a timely manner) or if the server expires the Token. In these cases,
      the client has to request a new Token.</t>

      <t>As the second step, when the client wants to establish a unicast
      session, the client includes the Token with its RTCP feedback message.
      The server validates the Token, making sure that the IP address
      information matches. This is effective against DoS attacks, e.g., an
      attacker cannot simply spoof another client's IP address and start a
      unicast transmission towards random clients. If the validation passes,
      the unicast session gets established. Otherwise, the server notifies the
      client that the validation has failed, and in this case, the unicast
      session will not be established.</t>

      <t>Upon successful validation and once the unicast session is
      established, all the RTP and RTCP rules specified in <xref
      target="RFC3550"></xref> and other relevant specifications also apply in
      this session until it is terminated. During the lifetime of a unicast
      session, a client might need to send RTCP messages that require
      authorization. Since such messages require a valid Token for
      authorization, the client needs to include the Token along with such
      RTCP messages as explained in detail in later sections of this
      document.</t>

      <t>Below, we first present a motivating scenario for port mapping and
      then describe the normative behavior and requirements.</t>

      <section title="Motivating Scenario">
        <t>Consider an SSM distribution network where a distribution source
        multicasts RTP packets to a large number of clients, and one or more
        retransmission servers function as feedback targets to collect unicast
        RTCP feedback from these clients <xref target="RFC5760"></xref>. The
        retransmission servers also join the multicast session to receive the
        multicast packets and cache them for a certain time period. When a
        client detects missing packets in the multicast session, it requests a
        retransmission from one of the retransmission servers by using an RTCP
        NACK message <xref target="RFC4585"></xref>. The retransmission server
        pulls the requested packet(s) out of the cache and retransmits them to
        the requesting client <xref target="RETRANSMISSION-FOR-SSM"></xref>.</t>

        <t>The RTP and RTCP flows pertaining to the scenario described above
        are illustrated in <xref target="fig_example"></xref>. Between the client
        and server, we assume there exists at least one NAT device <xref
        target="RFC4787"></xref>. (If there are no NAT devices between the
        server and client, the method still works in the same fashion.)  The
        multicast and unicast sessions are clearly identified with their
        individual RTP and RTCP flows and port numbers.</t>

        <figure anchor="fig_example"
                title="Example Scenario Showing an SSM Distribution with Support for Retransmissions from a Server">
          <artwork align="center"><![CDATA[

 --------------                                 ---     ----------
|              |-------------------------------|   |-->|P1        |
|              |-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-|   |.->|P2        |
|              |                               |   |   |          |
| Distribution |      ----------------         |   |   |          |      
|    Source    |     |                |        |   |   |          |
|              |---->|P1              |        |   |   |          |
|              |.-.->|P2              |        |   |   |          |
|              |     |                |        |   |   |          |
 --------------      |              P3|<.=.=.=.|   |=.=|*c0       |
                     |              P3|<~~~~~~~|   |~~~|*c1       |
MULTICAST RTP        |                |        |   |   |          |
SESSION with         |                |        | N |   |          |
UNICAST FEEDBACK     |                |        | A |   |          |
                     | Retransmission |        | T |   |  Client  |
- - - - - - - - - - -| - - - - - - - -| - - - -| - |- -| - - - - -|-   
                     |     Server     |        |   |   |          |
                     |                |        |   |   |          |
PORT MAPPING         |              PT|<~~~~~~~|   |~~>|*cT       |
                     |                |        |   |   |          |
- - - - - - - - - - -| - - - - - - - -| - - - -| - |- -| - - - - -|- 
                     |                |        |   |   |          |                 
AUXILIARY UNICAST    |                |        |   |   |          |
RTP SESSION          |                |        |   |   |          |
                     |              P3|........|   |..>|*c1       |
                     |              P3|=.=.=.=.|   |=.>|*c1       |
                     |              P4|<.=.=.=.|   |=.=|*c2       |
                     |                |        |   |   |          |
                      ----------------          ---     ----------


-------> Multicast RTP Flow
.-.-.-.> Multicast RTCP Flow
.=.=.=.> Unicast RTCP Reports
~~~~~~~> Unicast RTCP (Feedback) Messages
.......> Unicast RTP Flow
]]></artwork>
        </figure>

        <t></t>

        <t>In <xref target="fig_example"></xref>, we have the following
        multicast and unicast ports:</t>

        <t><list style="symbols">
            <t>Ports P1 and P2 denote the destination RTP and RTCP ports in
            the multicast session, respectively. The clients listen to these
            ports to receive the multicast RTP and RTCP packets. Ports P1 and
            P2 are defined declaratively.</t>

            <t>Port P3 denotes the RTCP port on the feedback target running on
            the retransmission server to collect any RTCP packet sent by the
            clients, including feedback messages and RTCP receiver and
            extended reports. This is also the port that the retransmission
            server uses to send the RTP packets and RTCP sender reports in the
            unicast session. Port P3 is defined declaratively.</t>

            <t>Port P4 denotes the RTCP port on the retransmission server used
            to collect the RTCP receiver and extended reports for the unicast
            session. Port P4 is defined declaratively.</t>

            <t>Ports *c0, *c1, and *c2 are chosen by the client. (Note: "*"
            indicates that the port can be chosen randomly; once chosen,
            the "*" is no longer used.)  *c0 denotes
            the port on the client used to send the RTCP reports for the
            multicast session. *c1 denotes the port on the client used to send
            the unicast RTCP feedback messages in the multicast session and to
            receive the RTP packets and RTCP sender reports in the unicast
            session. *c2 denotes the port on the client used to send the RTCP
            receiver and extended reports in the unicast session. Ports c0, c1,
            and c2 could be the same port or different ports. There are two
            advantages of using the same port for both c0 and c1:

                <list style="numbers">
                <t>Some NATs only keep bindings active when a packet goes from
                the inside to the outside of the NAT (see REQ-6 of Section 4.3
                of <xref target="RFC4787"></xref>). When the gap between the
                packets sent from the client to the server is long, this can
                exceed the timeout limit. If c0=c1, the occasional (periodic) RTCP
                receiver reports sent from port c0 (for the multicast
                session's RTCP port P3) will ensure the NAT does not time out
                the public port associated with the incoming unicast traffic
                to port c1.</t>

                <t>Having c0=c1 conserves NAT port bindings.</t>
              </list></t>

            <t>Ports PT and *cT denote the ports through which the Token
            request and retrieval occur at the server and client sides,
            respectively. Port PT is declared on a per-unicast-session basis,
            although the same port could be used for two or more unicast
            sessions sourced by the server. A Token once requested and
            retrieved by a client from port PT remains valid until its
            expiration time.</t>
          </list></t>

        <t>We assume that the information declaratively defined is available
        as part of the session description information and is provided to the
        clients. The Session Description Protocol (SDP) <xref
        target="RFC4566"></xref> and other session description methods can be
        used for this purpose.</t>
      </section>

      <section anchor="sec_normative"
               title="Normative Behavior and Requirements">
        <t>In this section, we describe the normative behavior and
        requirements. To simplify the presentation, we refer to the port
        numbers described in the example presented in <xref
        target="fig_example"></xref>. However, the behavior and requirements
        described here are not specific to that particular example and can be
        applied to any scenario where analogous ports can be identified.</t>

        <t>First of all, a client compliant with this specification MUST be
        able to include a Token with any type of RTCP message (as described
        below) when it is needed.</t>

        <t>Second, the solution provided in this specification is not
        applicable in cases where there is RTP traffic flowing from the client
        to the server in the unicast session. In other words, the direction of
        RTP traffic MUST be only from the server to the client in the unicast
        session. If the client wants to send RTP traffic back to the server,
        the regular session establishment methods such as <xref
        target="RFC3264"></xref> need to be used.</t>

        <t>The following steps summarize the Token-based solution:</t>

        <t><list style="numbers">
            <t>The client ascertains server address and port numbers (P3, P4
            and PT) from the session description. Port P4 MUST be different
            from port P3. Port PT MAY be equal to port P3.</t>

            <t>The client selects its local port numbers (*c0, *c1, *c2 and
            *cT). It is strongly RECOMMENDED that the client uses the same
            port for c0 and c1. Port cT MAY be equal to ports c0 and c1.</t>

            <t>If the client does not have a Token (or the existing Token has
            expired):<list style="letters">

                <t>The client first sends a Port Mapping Request message
                (<xref target="sec_pmreq"></xref>) to port PT. This message is
                sent from port cT on the client side. The server learns
                the client's IP address from the received message. The client can
                send this message anytime it wants (e.g., during
                initialization) and does not normally ever need to resend
                this message (see <xref
                target="sec_token_validate"></xref>).</t>

                <t>The server generates an opaque encapsulation (i.e., the
                Token) based on certain information, including the client's IP
                address.</t>

                <t>The server sends the Token back to the client using a Port
                Mapping Response message (<xref target="sec_pmres"></xref>).
                This message MUST be sent from port PT towards port cT.</t>
              </list></t>

            <t>The client needs to provide the Token to the server using a
            Token Verification Request message (<xref
            target="sec_verificationrequest"></xref>) whenever the client
            sends an RTCP feedback message for triggering or controlling a
            unicast session (see <xref
            target="sec_verificationrequest1"></xref>). If the Token is
            invalid or missing, the server sends a Token Verification Failure
            message (<xref target="sec_pmfailure"></xref>) to the client.
            <vspace blankLines="1" />Note that the unicast session is only
            established after the server has received a feedback message
            (along with a valid Token) from the client for which it needs to
            react by sending unicast data. Until a unicast session is
            established, neither the server nor the client needs to send RTCP
            reports for the unicast session.</t>

            <t>Normal flows ensue as shown in <xref
            target="fig_example"></xref>. It is strongly RECOMMENDED that the
            client uses the same port for both c0 and c1, as this causes the
            periodic RTCP reports to keep the NAT mapping alive. However, if
            the client uses different ports for c0 and c1, the client MUST
            keep its own NAT mapping alive for the P3-&gt;c1 session (see
            <xref target="RFC6263"></xref> for
            additional information).<vspace blankLines="1" />In the unicast
            session, traffic from the server to the client (i.e., both the RTP
            and RTCP packets sent from port P3 towards port c1) MUST be
            multiplexed on the same port <xref target="RFC5761"></xref>.
            <vspace blankLines="1" />The client sends the RTCP receiver and
            extended reports in the unicast session from port c2 towards port
            P4. The server correlates these reports with the reports received
            in the multicast session based on the client's RTCP Canonical Name
            (CNAME). Thus, the client MUST use the same RTCP CNAME in both
            sessions, and its RTCP CNAME MUST be unique <xref
            target="RFC6222"></xref>.</t>
          </list></t>

        <t>A unicast session on a particular receive port c1 can last as long
        as the associated multicast session lasts. However, a client cannot
        keep using the same receive port c1 for different subsequent unicast
        sessions since there could be packet leakage when switching from one
        unicast session to another unless each received unicast stream has its
        own distinct Synchronization Source (SSRC) identifier to allow the
        client to filter out the undesired packets. Unless this is guaranteed
        (which is not often easy), a client SHOULD use separate receive ports
        for subsequent unicast sessions. After a sufficient time (two minutes
        is RECOMMENDED, similar to one TCP Maximum Segment Lifetime specified
        in <xref target="RFC0793"></xref>), a previously used receive port
        can be used again.</t>

        <t>The established unicast session can be explicitly terminated by the
        procedures specified by an application or extension using the
port mapping 
approach described in this document. In addition, the unicast
        session can also be terminated by the procedure defined below, which
        is based on timing all participants out following the timeout rules of
        <xref target="RFC3550"></xref>. Both the server and client
        periodically check the liveness of the other peer, and if there is no
        RTCP traffic from the other peer for a certain amount of time (Section 6.3.5 of
        <xref target="RFC3550"></xref> suggests five RTCP reporting
        intervals), the unicast session SHOULD be considered terminated, and no
        further RTP and/or RTCP packets SHOULD be sent in that session. The
        client can attempt to establish a new unicast session if needed. If
        no explicit procedure for session termination exists, the client MAY
        stop sending RTCP to the server to accomplish session termination.
        However, the server SHALL NOT stop sending RTCP until the unicast
        session is terminated. If Token-based authentication is also signaled
        to be allowed in the unicast session, i.e., in the RTCP messages sent
        from port c2 towards port P4, the client SHOULD terminate the unicast
        session by sending an RTCP BYE message for each SSRC it has used in
        that unicast session.</t>
      </section>
    </section>

    <section title="Message Formats">
      <t>This section defines the formats of the RTCP messages that are
      exchanged between a server and a client for the purpose of port mapping.
      A new RTCP control packet type is introduced, and four port mapping
      messages using this control packet are defined:</t>

      <t><list style="numbers">
          <t>Port Mapping Request</t>

          <t>Port Mapping Response</t>

          <t>Token Verification Request</t>

          <t>Token Verification Failure</t>
        </list></t>

      <t>Each message has a fixed-length field for version (V), padding (P),
      sub-message type (SMT), packet type (PT), length, and SSRC of packet
      sender. Messages have other fields as defined below. In all messages
      defined in this section, the PT field is set to TOKEN (210). Individual
      messages are identified by the SMT field. The length field indicates the
      message size in 32-bit words minus one, including the header and any
      padding. This definition is in line with the definition of the Length
      field used in RTCP sender and receiver reports. In all messages, any
      Reserved field SHALL be set to zero and ignored.</t>

      <t>Following the rules specified in <xref target="RFC3550"></xref>, all
      integer fields in the messages defined below are carried in network-byte
      order, that is, most significant byte (octet) first, also known as
      big-endian. Unless otherwise stated, numeric constants are in decimal
      (base 10).</t>

      <t>Note that RTCP is not a timely or reliable protocol. The RTCP packets
      might get lost or reordered in the network, and it is not easy to detect
      these events. When sending a new Port Mapping Request message, the
      scheduling rules that apply to sending initial RTCP messages <xref
      target="RFC4585"></xref> apply. When a client sends a Port Mapping
      Request or Token Verification Request message but it does not receive a
      response back from the server (either a Port Mapping Response or Token
      Verification Failure message), it MAY resend its request by following
      the timer rules defined for RTCP feedback messages in Section 3.5 of
      <xref target="RFC4585"></xref> as a good practice. However,
      implementations are advised to avoid sending spurious RTCP messages just
      because the timer rules (based on some RTCP configuration parameters)
      allow. Reasonably safe practices are to be used to detect RTCP message
      loss. When sending an RTCP (feedback) message bundled with a Token
      Verification Request message, the timer rules of <xref
      target="RFC4585"></xref> apply as usual.</t>

      <section anchor="sec_pmreq" title="Port Mapping Request">
        <t>The Port Mapping Request message is identified by SMT=1. This
        message is transmitted by the client to a dedicated server port (and
        possibly a dedicated address) to request a Token. In the Port Mapping
        Request message, the packet sender's SSRC is set to the client's SSRC,
        which is chosen randomly by the client. The packet format has the
        structure depicted in <xref
        target="FCI_PortMappingRequest"></xref>.</t>

        <figure anchor="FCI_PortMappingRequest"
                title="Packet Format for the Port Mapping Request Message">
          <artwork align="center"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|  SMT=1  |    PT=TOKEN   |         Length=3              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      SSRC of Packet Sender                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Random                            |
|                             Nonce                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>

        <t><list style="symbols">
            <t>Random Nonce (64 bits): Field that contains a random value
            generated by the client following the procedures of <xref
            target="RFC4086"></xref>. This nonce is taken into account by the
            server when generating a Token for the client to enable better
            security for clients that share the same IP address (such clients
            need to produce a random value extremely unlikely to collide with
            other clients sharing the same IP address). If the same Port
            Mapping Request message is transmitted multiple times for
            redundancy reasons, the random nonce value MUST remain the same in
            these duplicated messages. However, the client MUST generate a new
            random nonce for every new Port Mapping Request message.</t>
          </list></t>
      </section>

      <section anchor="sec_pmres" title="Port Mapping Response">
        <t>The Port Mapping Response message is identified by SMT=2. This
        message is sent by the server and delivers the Token to the client as
        a response to the Port Mapping Request message. In the Port Mapping
        Response message, the packet sender's SSRC is set to the server's SSRC.
        The packet format has the structure depicted in <xref
        target="FCI_PortMappingResponse"></xref>.</t>

        <figure anchor="FCI_PortMappingResponse"
                title="Packet Format for the Port Mapping Response Message">
          <artwork align="center"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|  SMT=2  |    PT=TOKEN   |          Length               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      SSRC of Packet Sender                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    SSRC of Requesting Client                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Associated                          |
|                             Nonce                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:                         Token Element                         :
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Absolute                           |
|                         Expiration Time                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Relative Expiration Time                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:                       Packet Types Element                    :
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>

        <t><list style="symbols">
            <t>SSRC of Requesting Client (32 bits): Field that contains the
            SSRC of the client who sent the request.</t>

            <t>Associated Nonce (64 bits): Field that contains the nonce
            received in the Port Mapping Request message and used in Token
            construction.</t>

            <t>Token Element (variable size): Element that is used to carry
            the Token generated by the server. This element is a 32-bit
            aligned Length-Value element. The Length field, which is 16 bits,
            indicates the length (in octets) of the Value field that follows
            the Length field. While a 16-bit length allows for Tokens with a
            size of up to 65535 bytes, using Tokens of sizes that make the
            RTCP compound packet larger than the MTU might have a negative
            impact on functionality because of IP fragmentation. Some NATs or
            other middleboxes do not pass IP fragments; thus, a large Token can
            cause the whole mechanism to fail. In addition, fragmentation
            increases the risk for packet loss. <vspace blankLines="1" />The
            length does not include any padding that is required for
            alignment. The Value field carries the Token (or more accurately,
            the output of the encoding process on the server). If the Token
            element does not fall on a 32-bit boundary, the last word MUST be
            padded to the boundary using further bits set to zero.</t>

            <t>Absolute Expiration Time (64 bits): Field that contains the
            absolute expiration time of the Token. The absolute expiration
            time is expressed as a Network Time Protocol (NTP) timestamp value
            in seconds since the year 1900 <xref target="RFC5905"></xref>. The
            client does not need to use this element directly and thus does not
            need to synchronize its clock with the server. However, the client
            needs to send this element back to the server along with the
            associated nonce in the Token Verification Request message and thus
            needs to keep it associated with the Token.</t>

            <t>Relative Expiration Time (32 bits): Field that contains the
            relative expiration time of the Token. The relative expiration
            time is expressed in seconds from the time the Token was
            generated. Whenever a server decides to not grant a Token to a
            requesting client, the relative expiration time will be set to
            zero (and hence, the accompanying Token will be invalid).<vspace
            blankLines="1" />The server conveys the relative expiration time
            in the clear to the client to allow the client to request a new
            Token well before the expiration time.</t>

            <t>Packet Types Element (variable size): Element that is used to
            signal which RTCP packet types require Token-based authentication.
            This element is a 32-bit aligned Length-Value element. The Length
            field, which is 8 bits, indicates the length (in octets) of the
            Value field that follows the Length field. This length does not
            include any padding that is required for alignment. The Value
            field carries zero or more 8-bit sub-fields, each carrying an RTCP
            packet type. If the Packet Types element does not fall on a 32&nbhy;bit
            boundary, the last word MUST be padded to the boundary using
            further bits set to zero. An example Packet Types element is shown
            in <xref target="FCI_typeselement"></xref>.<vspace
            blankLines="1" />A server MAY change its policy on which RTCP
            packet types would require Token-based authentication based on
            observations, configuration, or other policies. However, upon such
            a change, the server SHALL NOT send a new Port Mapping Response
            message to the clients who requested a Token earlier. A client
            learns about this change when and if it gets a Token Verification
            Failure message.<vspace blankLines="1" />

<figure
                anchor="FCI_typeselement" title="Example Packet Types Element">
                <artwork align="center"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Length=4   |      205      |      206      |      203      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      204      |                  Padding                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
              </figure></t>
          </list></t>
      </section>

      <section anchor="sec_verificationrequest"
               title="Token Verification Request">
        <t>The Token Verification Request message is identified by SMT=3. This
        message contains the Token and accompanies any RTCP message that would
        trigger a new unicast session or control an existing unicast session. For a list of
        such messages, see <xref
        target="sec_verificationrequest1"></xref>.</t>

        <t>In the Token Verification Request message, the packet sender's SSRC
        is set to the client's SSRC. The client MUST NOT send a Token
        Verification Request message with a Token that has expired. The packet
        format has the structure depicted in <xref
        target="FCI_TokenVerification"></xref>.</t>

        <figure anchor="FCI_TokenVerification"
                title="Packet Format for the Token Verification Request Message">
          <artwork align="center"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|  SMT=3  |    PT=TOKEN   |          Length               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      SSRC of Packet Sender                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Associated                          |
|                             Nonce                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:                         Token Element                         :
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Associated Absolute                     |
|                         Expiration Time                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>

        <t><list style="symbols">
            <t>Associated Nonce (64 bits): Field that contains the nonce
            associated with the Token below.</t>

            <t>Token Element (variable size): Token element that was
            previously received in the Port Mapping Response message.</t>

            <t>Associated Absolute Expiration Time (64 bits): Field that
            contains the absolute expiration time associated with the Token
            above.</t>
          </list></t>

        <section anchor="sec_verificationrequest1"
                 title="Where to Include Token">
          <t>This section provides guidelines about which RTCP packet types
          would need to be accompanied by a Token Verification Request
          message. However, since a server might determine in real time that
          other RTCP messages also need to be authenticated by a Token, a
          client MUST act according to the up-to-date list provided to the
          client in the Port Mapping Response message (in the Packet Types
          element). Clients need to support the use of Token-based authentication
          with any necessary RTCP message (see <xref
          target="sec_normative"></xref>).</t>

          <t>As a general rule, when the Token capability is declared in the
          session description, the RTCP messages that trigger transmission of
          RTP packets in a port mapped unicast session are REQUIRED to be
          authenticated by using a Token. Such messages include but are not
          limited to:</t>

          <t><list style="symbols">
              <t>NACK messages <xref target="RFC4585"></xref></t>

              <t>RAMS Request (RAMS&nbhy;R) messages <xref
              target="RFC6285"></xref></t>
            </list></t>

          <t>Additionally, some RTCP messages might directly or indirectly
          control an existing unicast session associated with a multicast
          session. Unless another authentication method as described in their
          respective specifications is used, implementations MUST support
          authenticating such RTCP messages by using a Token.</t>

          <t>Examples are:</t>

          <t><list style="symbols">
              <t>BYE messages <xref target="RFC3550"></xref></t>

              <t>RAMS Termination (RAMS&nbhy;T) messages <xref
              target="RFC6285"></xref></t>

              <t>Codec Control Messages (CCMs) <xref target="RFC5104"></xref></t>
            </list></t>

          <t>Note that even if a packet type is listed to require Token-based
          authentication, it does not need to be authenticated when it does
          not control the unicast session. For example, if BYE (203) is listed
          in the Port Mapping Response message as one of the packet types that
          requires authentication, the client does not need to bundle the RTCP
          BYE message with a Token when it is sending it for the multicast
          session.</t>

          <t>The Token Verification Request message might also be bundled with
          packets carrying RTCP receiver and/or extended reports. While such
          packets do not have a strong security impact, a specific application
          might desire to have a more controlled reporting scheme from the
          clients. In this case, the server lists the packet types for the
          receiver (201) and/or extended reports (207) in the Port Mapping
          Response message.</t>
        </section>
      </section>

      <section anchor="sec_pmfailure" title="Token Verification Failure">
        <t>The Token Verification Failure message is identified by SMT=4. This
        message is sent by the server and notifies the client that the Token
        was invalid or that the client did not include a Token Verification
        Request message in the RTCP packet although it was supposed to (the
        message is sent from port P3 towards port c1). The packet format has
        the structure depicted in <xref target="FCI_TokenFailure"></xref>.</t>

        <figure anchor="FCI_TokenFailure"
                title="Packet Format for the Token Verification Failure Message">
          <artwork align="center"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|  SMT=4  |    PT=TOKEN   |         Length=5              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      SSRC of Packet Sender                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    SSRC of Requesting Client                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Failed PT   |   FMT   |              Reserved               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Associated                          |
|                             Nonce                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>

        <t><list style="symbols">
            <t>SSRC of Packet Sender: This is the server's SSRC, which equals the
            SSRC of the respective multicast stream. Note that this SSRC value
            is from a different SSRC space than the one used in the unicast
            session.</t>

            <t>SSRC of Requesting Client (32 bits): Field that contains the
            SSRC of the client.</t>

            <t>Failed PT (8 bits): Field that indicates the type of the RTCP
            packet that caused this failure message.</t>

            <t>FMT (5 bits): Field that indicates the feedback message type
            (FMT) value of the RTCP packet that caused this failure. Together
            with the field above, the client can infer which RTCP message it
            had previously sent caused this failure message to be sent by the
            server. For example, if the client did not include a valid Token
            with an RTCP NACK message, the Failed PT field will indicate 205
            (RTPFB) and the FMT field will indicate 1 (Generic NACK). If the
            RTCP message did not have an associated FMT value (such as an RTCP
            BYE message), the FMT field SHALL be set to zero.</t>

            <t>Associated Nonce (64 bits): Field that contains the nonce
            received in the Token Verification Request message. If there was
            no Token Verification Request message included by the client, this
            field is set to zero.</t>
          </list></t>
      </section>
    </section>

    <section anchor="sec_token_construction"
             title="Procedures for Token Construction">
      <t>The Token encoding is known to the server but opaque to the client.
      Implementations MUST encode the following information into the Token as
      a minimum, in order to provide adequate security:</t>

      <t><list style="symbols">
          <t>Client's IP address as seen by the server (32/128 bits for
          IPv4/IPv6 addresses)</t>

          <t>The nonce generated and inserted in the Port Mapping Request
          message by the client (64 bits)</t>

          <t>The absolute expiration time chosen by the server indicated as an
          NTP timestamp value in seconds since the year 1900 <xref
          target="RFC5905"></xref> (64 bits, to protect against replay
          attacks)</t>
        </list></t>

      <t>The RECOMMENDED way for constructing Tokens is to perform HMAC-SHA1
      <xref target="RFC2104"></xref> on the concatenated values of the
      information listed above (implementations might adopt different
      approaches). If HMAC-SHA1 is used, the Hashed Message Authentication Code
(HMAC) key MUST be at least 160
      bits long and generated using a cryptographically secure random source
      <xref target="RFC4086"></xref>.</t>

      <t>In addition to the information listed above, implementations are
      encouraged to encode whatever additional information is deemed necessary
      or useful. For example, key rollover is simplified by encoding a key-id
      into the Token. As another example, a cluster of anycast servers could
      find advantage by encoding a server identifier into the Token. As
      another example, while HMAC-SHA1 provides a level of security that is
      widely regarded as being more than sufficient for providing message
      authentication and it is secure against all known cryptanalytic attacks
      that use computational resources that are currently economically
      feasible, a replacement HMAC
      algorithm (e.g., HMAC-SHA256) could be used instead if HMAC-SHA1 has been compromised.</t>

      <t>To protect from offline attacks, the server SHOULD occasionally
      choose a new HMAC key. To ease implementation, a key-id can be assigned
      to each HMAC key. This can be encoded as simply as one bit (where the
      new key is X (e.g., 1) and the old key is the inverted value of X (e.g.,
      0)), or if several keys are supported at once, the key-id could be encoded into
      several bits. As the encoding of the Token is entirely private to the
      server and opaque to the clients, any encoding can be used. By encoding
      the key-id into the Token element, the server can reject an old key
      without bothering to do HMAC validation (saving CPU cycles). The key-id
      can be encoded into the Value field of the Token element by simply
      concatenating the (plaintext) key-id with the hashed information (i.e.,
      the Token itself).</t>

      <t>For example, the Value field in the Token element can be computed
      as:</t>

      <t><figure align="center">
          <artwork><![CDATA[key-id || mac-alg (client-ip | nonce | abs-expiration) 
]]></artwork>
        </figure></t>

      <t>During Token construction, the expiration time has to be chosen
      carefully based on the intended service duration. Tokens that are valid
      for an unnecessarily long period of time (e.g., several hours) might
      impose security risks. Depending on the application and use cases, a
      reasonable value needs to be chosen by the server. Note that using
      shorter lifetimes requires the clients to acquire Tokens more
      frequently. However, since a client can acquire a new Token well before
      it will need to use it, the client will not necessarily be penalized for
      the acquisition delay.</t>

      <t>Finally, be aware that NTP timestamps will wrap around in the year 2036.
      Refer to Section 6 of <xref target="RFC5905"></xref> for further
      details.</t>
    </section>

    <section anchor="sec_token_validate" title="Validating Tokens">
      <t>The server MUST validate the Token upon receipt of an RTCP feedback message along with the Token
      Verification Request message that contains a Token, nonce, and absolute
      expiration time.</t>

      <t>The server first applies its own procedure for constructing the
      Tokens by using the client's IP address from the received Token Verification
      Request message and the nonce and absolute expiration time values
      reported in the received Token Verification Request message. The server
      then compares the resulting output with the Token sent by the client in
      the Token Verification Request message. If they match and the absolute
      expiration time has not passed yet, the server declares that the Token
      is valid.</t>

      <t>Note that if the client's IP address changes, the Token will not
      validate. Similarly, if the client inserts an incorrect nonce or
      absolute expiration time value in the Token Verification Request
      message, validation will fail. It is also possible that the server wants
      to expire the Token prematurely. In these cases, the server MUST reply
      back to the client with a Token Verification Failure message (that goes
      from port P3 on the server towards port c1 on the client).</t>

      <t>In addition to the Token Verification Failure message, it is
      RECOMMENDED that applications define an application-specific error
      response to be sent by the server when the server detects that the Token
      is invalid. For applications using <xref
      target="RFC6285"></xref>, this document
      defines a new 4xx-level response code in the RAMS Response Code Space
      Registry. A client that receives a Token Verification Failure message
      can request a new Token from the server.</t>

      <t>If a client receives a Port Mapping Response message with an invalid
      Token (i.e., the relative expiration time is set to zero) two or more
      times for a particular Port Mapping Request message or the client
      receives a Token Verification Failure message two or more times for the
      same Token Verification Request message, the client SHOULD do the
      following:</t>

      <t><list style="numbers">
          <t>Check whether or not the session description has been updated. If
          it was updated, act according to the new session description.</t>

          <t>Exponentially back off for the third and subsequent attempts.
          Exponential back-off does not apply when the client sends a Port
          Mapping Request or Token Verification Request message to a new
          address and/or port.</t>
        </list></t>
    </section>

    <section anchor="sec_scenario" title="SDP Signaling">
      <section title="The 'portmapping-req' Attribute">
        <t>This attribute is used declaratively in any media block that
        describes an RTP session that uses Token-based authentication for one
        or more RTCP messages relating to that session. It indicates the port
        and optionally the address for obtaining a Token.</t>

        <t>The presence of the 'portmapping-req' attribute indicates that (i)
        a Token MUST be included in certain RTCP messages sent to the server
        triggering or controlling a unicast session (see <xref
        target="sec_verificationrequest1"></xref>) and (ii) the client MUST
        receive the unicast session's RTP and RTCP packets from the server on
        the port from which it sent the RTCP message triggering the unicast
        session.</t>

        <t><list style="empty">
            <t>Note: This does not imply that Token Verification Request
            messages always need to be sent in the unicast session. Token
            Verification Request messages accompany RTCP messages that trigger
            or control this unicast session and are sent either in the
            multicast session or the unicast session, depending on the RTCP
            message (see <xref target="sec_verificationrequest1"></xref>).</t>
          </list></t>

        <section title="ABNF Definition of 'portmapping-req'">
          <t>The formal description of the 'portmapping-req' attribute is
          defined by the following ABNF <xref target="RFC5234"></xref>
          syntax:</t>

          <figure align="center">
            <artwork><![CDATA[
portmapping-req-attr = "a=portmapping-req:" port [SP nettype SP
                         addrtype SP connection-address] CRLF
]]></artwork>
          </figure>

          <t>Here, 'port', 'nettype', 'addrtype', and 'connection-address' are
          defined as specified in Section 9 of <xref
          target="RFC4566"></xref>.</t>

          <t>The 'portmapping-req' attribute SHALL only be used as a
          media-level attribute.</t>

          <t>In the optional address value, only unicast addresses SHOULD be
          used unless one wants to use a multicast address after evaluating
          the additional security risks such as non-legit servers generating
          fake Tokens. If the address is not specified, the (source) address
          in the "c" line applicable to the media description SHALL be
          used.</t>
        </section>

        <section title="Offer/Answer Model Considerations">
          <t>When using the 'portmapping-req' attribute in SDP offer/answer
          exchanges <xref target="RFC3264"></xref>, the following
          considerations apply. When an offerer sends an answerer an offer of
          an SDP description making use of the Token approach described in
          this specification, the 'portmapping-req' attribute is included
          declaratively. There will not be offer/answer exchanges between the
          answerer and the actual server providing the unicast service(s).</t>

          <t>When the answerer supports the Token approach, it MUST echo in
          its answer back to the offerer the 'portmapping-req' attribute from
          the offer including the same port number and address (if any). If
          the answerer does not implement this specification, it follows
          normal SDP parsing of unknown attributes (they are ignored and are
          not sent in the answer). This means that the answerer can still join
          the multicast session but will not be able to use the unicast
          service(s) that require the use of Tokens.</t>
        </section>
      </section>

      <section title="Requirements">
        <t>The use of SDP for the port mapping solution normatively requires
        support for:</t>

        <t><list style="symbols">
            <t>The SDP grouping framework and flow identification (FID)
            semantics <xref target="RFC5888"></xref></t>

            <t>The RTP/Audio-Visual Profile with Feedback (AVPF) profile <xref target="RFC4585"></xref></t>

            <t>The 'rtcp-mux' attribute (to multiplex RTP and RTCP on a single
            port on both endpoints in the unicast session <xref
            target="RFC5761"></xref>)</t>
          </list></t>
      </section>

      <section title="Example and Discussion ">
        <t>The declarative SDP describing the scenario given in <xref
        target="fig_example"></xref> is written as:</t>

        <figure anchor="fig_sdp"
            title="SDP Describing an SSM Distribution with Support for Retransmissions from a Local Server">

            <artwork><![CDATA[
     v=0
     o=ali 1122334455 1122334466 IN IP4 nack.example.com
     s=Local Retransmissions
     t=0 0
     a=group:FID 1 2
     a=rtcp-unicast:rsi
     m=video 41000 RTP/AVPF 98
     i=Multicast Stream
     c=IN IP4 233.252.0.2/255
     a=source-filter:incl IN IP4 233.252.0.2 198.51.100.1   ; Note 1
     a=rtpmap:98 MP2T/90000
     a=multicast-rtcp:41500                                 ; Note 1
     a=rtcp:42000 IN IP4 192.0.2.1                          ; Note 2
     a=rtcp-fb:98 nack                                      ; Note 2
     a=portmapping-req:30000 IN IP4 192.0.2.1               ; Note 3
     a=mid:1
     m=video 42000 RTP/AVPF 99                              ; Note 4
     i=Unicast Retransmission Stream
     c=IN IP4 192.0.2.1
     a=sendonly
     a=rtpmap:99 rtx/90000
     a=rtcp-mux                                             ; Note 5
     a=rtcp:42500                                           ; Note 6
     a=fmtp:99 apt=98; rtx-time=5000
     a=portmapping-req:30001                                ; Note 3 
     a=mid:2
]]></artwork>

          </figure>

        <t>In this description, we highlight the following notes:</t>

        <t>Note 1: The source stream is multicast from a distribution source
        with a source IP address of 198.51.100.1 to the multicast destination
        address of 233.252.0.2 and port 41000 (P1). The associated RTCP
        packets are multicast in the same group to port 41500 (P2).</t>

        <t>Note 2: A retransmission server including feedback target
        functionality with an IP address of 192.0.2.1 and port of 42000 (P3)
        is specified with the 'rtcp' attribute. The feedback functionality is
        enabled for the RTP stream with payload type 98 through the 'rtcp-fb'
        attribute <xref target="RFC4585"></xref>.</t>

        <t>Note 3: The "a=portmapping-req" line indicates that one or more
        RTCP messages relating to the RTP session described in this media
        block uses Token-based authentication, and a Token needs to be
        retrieved first from the designated port (PT) before the unicast
        session can be established. In the first appearance, an explicit
        address is provided. In the second appearance, there is no address
        indicated in this line and the client needs to send the Token request
        to the address specified in the "c" line in the unicast media
        block.</t>

        <t>Note 4: The port specified in the second "m" line (for the unicast
        stream) does not mean anything in this scenario as the client does not
        send any RTP traffic back to the server.</t>

        <t>Note 5: The server multiplexes RTP and RTCP packets sent towards c1 on the
        same port.</t>

        <t>Note 6: The server uses port 42500 (P4) for the unicast
        session.</t>
      </section>
    </section>

    <section title="Address Pooling NATs">
      <t>Large-scale NAT devices have a pool of public IPv4 addresses and map
      internal hosts to one of those public IPv4 addresses. As long as an
      internal host maintains an active mapping in the NAT, the same IPv4
      address is assigned to new connections. However, once all of the host's
      mappings have been deleted (e.g., because of timeout), it is possible
      that a new connection from that same host will be assigned a different
      IPv4 address from the pool. When that occurs, the Token will be
      considered invalid by the server, causing an additional round trip for
      the client to acquire a fresh Token.</t>

      <t>Any traffic from the host that traverses the NAT will prevent this
      problem. As the host is sending RTCP receiver reports at least every 5
      seconds (Section 6.2 of <xref target="RFC3550"></xref>) for the
      multicast session it is receiving, those RTCP messages will be
      sufficient to prevent this problem.</t>
    </section>

    <section anchor="sec_security_considerations"
             title="Security Considerations">
      <t></t>

      <section title="Tokens">
        <t>The Token, which is generated based on a client's IP address and
        expiration date, provides protection against off-path
        denial-of-service (DoS) attacks. An attacker using a certain IP
        address cannot cause one or more RTP packets to be sent to a victim
        client who has a different IP address. However, if the attacker
        acquires a valid Token for a victim and can spoof the victim's source
        address, this approach becomes vulnerable to replay attacks. This is
        especially easy if the attacker and victim are behind a large-scale
        NAT and share the same IP address.</t>

        <t>Multicast is deployed on managed networks, not the Internet. These
        managed networks will choose whether or not to enable network ingress filtering <xref
        target="RFC2827"></xref>. If ingress filtering is enabled on a
        network, an attacker cannot spoof a victim's IP address to use a Token
        to initiate an attack against a victim. However, if ingress filtering
        is not enabled on a network, an attacker could obtain a Token and
        spoof the victim's address, causing traffic to flood the victim. On
        such a network, the server can reduce the time period for such an
        attack by expiring a Token in a short period of time. In the extreme
        case, the server can expire the Token in such a short period of time
        that the client will have to acquire a new Token immediately
        before using it in a Token Verification Request message. One should,
        however, note that such a behavior might have an adverse effect on the
        delay in establishing or controlling a unicast session.</t>

        <t>RTCP messages could be subject to on-path or man-in-the-middle
        attacks. For example, an attacker can modify a value in one or more
        fields in the Port Mapping Response or the Token Verification Request
        message that are used in Token construction. This will result in Token
        validation failure. Consequently, the client ends up asking the server
        to generate a new Token. The resulting delay and extra processing on
        the server is undesirable.</t>

        <t>Alternatively, the attacker can modify a value in a field that is
        not used in Token construction. For example, the attacker can reduce
        the value in the Relative Expiration Time field in the Port Mapping
        Response message from two hours to two minutes. While the Token will
        still validate, this attack will result in more frequent requests to
        the server for a new Token. Oppositely, the attacker can increase the
        value in the Relative Expiration Time field and make the client think
        the Token will be valid for a longer time. This attack can be only
        detected by monitoring the activity on the server. Note that using the
        relative expiration time in Token construction does not necessarily
        make this attack easier to detect since the attacker might revert the
        modified value back to its original value in the Token Verification
        Request message. This allows the Token to still validate on the
        server. In this case, the attack is still only detectable by
        monitoring the server activity.</t>

        <t>If there is a risk or concern for on-path or man-in-the-middle
        attacks, RTCP messages SHOULD be protected by Secure RTCP (SRTCP)
        <xref target="RFC3711"></xref>.</t>

        <t>To minimize the risk of
        cross-protocol attacks, a server MUST NOT use the same secret key it used for Token
        construction for other purposes.</t>
      </section>

      <section title="The 'portmapping-req' Attribute">
        <t>The 'portmapping-req' attribute is not believed to introduce any
        significant security risk to multimedia applications. A malevolent
        third party could use this attribute to redirect the Port Mapping
        Request messages by altering the port number or cause the unicast
        session establishment to fail by removing it from the SDP description.
        However, this requires intercepting and rewriting the packets carrying the
        SDP description, and if an interceptor can do that, many more attacks
        are possible, including a wholesale change of the addresses and port
        numbers at which the media will be sent.</t>

        <t>In order to avoid attacks of this sort, the SDP description needs
        to be integrity protected and provided with source authentication.
        This can, for example, be achieved on an end-to-end basis using
Secure/Multipurpose Internet Mail Extensions (S/MIME)
        <xref target="RFC5652"></xref> <xref target="RFC5751"></xref> when SDP
        is used in a signaling packet using MIME types (application/sdp).
        Alternatively, HTTPS <xref target="RFC2818"></xref> or the
        authentication method in the Session Announcement Protocol (SAP) <xref
        target="RFC2974"></xref> could be used as well.</t>
      </section>
    </section>

    <section anchor="sec_iana_considerations" title="IANA Considerations">

      <t>The following contact information is used for all registrations
      in this document:</t>

      <t>Ali Begen
<vspace />
abegen@cisco.com
</t>

      <section title="Registration of SDP Attributes">
        <t>This document registers one new attribute name in SDP.</t>

        <t><figure>

            <artwork><![CDATA[
     SDP Attribute ("att-field"):
     Attribute name:     portmapping-req
     Long form:          Port and address for requesting Token
     Type of name:       att-field
     Type of attribute:  Media level
     Subject to charset: No
     Purpose:            See this document
     Reference:          [RFC6284]
     Values:             See this document]]></artwork>

          </figure></t>
      </section>

      <section title="Registration of RTCP Control Packet Types">
        <t>In accordance with Section 15 of <xref target="RFC3550"></xref>,
        this specification adds the following value to the RTCP Control Packet
        types sub-registry in the Real-Time Transport Protocol (RTP)
        Parameters registry:</t>

        <figure>

            <artwork><![CDATA[
Value     Abbrev.    Name                                   Reference
--------  ---------  -------------------------------------  ---------
210       TOKEN      Port Mapping                           [RFC6284]                  
]]></artwork>
          </figure>

      </section>

      <section anchor="sec_sfmt_registry"
               title="SMT Values for TOKEN Packet Type Registry">
        <t>This document creates a new sub-registry for the sub-message type
        (SMT) values to be used with the TOKEN packet type. The registry is
        called the SMT Values for TOKEN Packet Type Registry. This registry is
        managed by the IANA according to the IETF Review policy of <xref
        target="RFC5226"></xref>.</t>

        <t>The length of the SMT field is five bits, allowing 32 values. The
        registry is initialized with the following entries:</t>


        <figure>
            <artwork><![CDATA[
Value Name                                               Reference
----- -------------------------------------------------- ------------
0     Reserved                                           [RFC6284]
1     Port Mapping Request                               [RFC6284]
2     Port Mapping Response                              [RFC6284]
3     Token Verification Request                         [RFC6284]
4     Token Verification Failure                         [RFC6284]
5-30  Unassigned                                         IETF Review
31    Reserved                                           [RFC6284]
]]></artwork>
          </figure>

        <t>The SMT values 0 and 31 are reserved for future use.</t>
      </section>

      <section anchor="sec_codes_registry"
               title="RAMS Response Code Space Registry">
        <t>This document adds the following entry to the RAMS Response Code
        Space Registry.</t>

        <figure>
            <artwork><![CDATA[
Code  Description                                        Reference
----- -------------------------------------------------- ------------
405   Invalid Token                                      [RFC6284]
]]></artwork>
          </figure>

        <t>This response code is used when the Token included by the RTP_Rx in
        the RAMS-R message is invalid.</t>
      </section>
    </section>

    <section title="Acknowledgments">
      <t>The approach presented in this document came out after discussions
      with various individuals in the AVT and MMUSIC WGs and the breakout
      session held at the Anaheim meeting. We thank each of these individuals,
      particularly Magnus Westerlund and Colin Perkins.</t>
    </section>
  </middle>

  <back>
<?rfc rfcedstyle="no"?>
    <references title="Normative References">
      &__reference.RFC.3550;

      &__reference.RFC.2119;

      &__reference.RFC.4566;

      &__reference.RFC.4585;

      &__reference.RFC.5760;

      &__reference.RFC.5234;

      &__reference.RFC.4086;

      &__reference.RFC.5905;

      &__reference.RFC.2104;

      &__reference.RFC.5888;

      &__reference.RFC.5761;

      &__reference.RFC.3711;

      &__reference.RFC.6222;
    </references>

    <references title="Informative References">
      &__reference.RFC.4607;

      &__reference.RFC.3264;

      &__reference.RFC.4145;

<reference anchor='RFC6285'>
<front>
<title>Unicast-Based Rapid Acquisition of Multicast RTP Sessions</title>

<author initials='B' surname='Ver Steeg' fullname='Bill Ver Steeg'>
    <organization />
</author>

<author initials='A' surname='Begen' fullname='Ali Begen'>
    <organization />
</author>

<author initials='T' surname='Van Caenegem' fullname='Tom Van Caenegem'>
    <organization />
</author>

<author initials='Z' surname='Vax' fullname='Zeev Vax'>
    <organization />
</author>

<date month='June' year='2011' />

</front>

<seriesInfo name='RFC' value='6285' />

</reference>


      &__reference.RFC.4787;




<reference anchor='RETRANSMISSION-FOR-SSM'>
<front>
<title>Retransmission for Source-Specific Multicast (SSM) Sessions</title>

<author initials='T' surname='Van Caenegem' fullname='Tom Van Caenegem'>
    <organization />
</author>

<author initials='B' surname='Ver Steeg' fullname='Bill Ver Steeg'>
    <organization />
</author>

<author initials='A' surname='Begen' fullname='Ali Begen'>
    <organization />
</author>

<date month='May' day='26' year='2011' />

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>






<reference anchor='RFC6263'>
<front>
<title>Application Mechanism for Keeping Alive the NAT Mappings Associated with
RTP / RTP Control Protocol (RTCP) Flows</title>

<author initials='X' surname='Marjou' fullname='Xavier Marjou'>
    <organization />
</author>

<author initials='A' surname='Sollaud' fullname='Aurelien Sollaud'>
    <organization />
</author>

<date month='June' year='2011' />

</front>

<seriesInfo name='RFC' value='6263' />

</reference>

      &__reference.RFC.2827;

      &__reference.RFC.5226;

      &__reference.RFC.5104;

      &__reference.RFC.5652;

      &__reference.RFC.2818;

      &__reference.RFC.2974;

      &__reference.RFC.0793;

      &__reference.RFC.5751;
    </references>
<?rfc rfcedstyle="yes"?>
  </back>
</rfc>
