<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<!--  USED xml2rfc v2 -->

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc rfcedstyle="yes"?>
<?rfc compact="yes"?>  
<?rfc subcompact="no"?>

<rfc number="7019" category="exp" consensus="yes" submissionType="IRTF">

  <front>


    <title abbrev="ALM Extensions to RELOAD">Application-Layer Multicast
    Extensions to REsource LOcation And Discovery (RELOAD)</title>


    <author fullname="John Buford" initials="J.F." surname="Buford">
      <organization>Avaya Labs Research</organization>

      <address>
        <postal>
          <street>211 Mt. Airy Rd.</street>
          <city>Basking Ridge</city>
          <region>New Jersey</region>
          <code>07920</code>
          <country>USA</country>
        </postal>

        <phone>+1 908 848 5675</phone>

        <email>buford@avaya.com</email>


      </address>
    </author>

    <author fullname="Mario Kolberg" initials="M." role="editor"
            surname="Kolberg">
      <organization>University of Stirling</organization>

      <address>
        <postal>
          <street>Dept. of Computing Science and Mathematics</street>
          <city>Stirling</city>
          <region></region>
          <code>FK9 4LA</code>
          <country>UK</country>
        </postal>

        <phone>+44 1786 46 7440</phone>
        <email>mkolberg@ieee.org</email>
        <uri>http://www.cs.stir.ac.uk/~mko</uri>
      </address>
    </author>

    <date month="September" year="2013" />

    <area>IRTF</area>
    <workgroup>Scalable Adaptive Multicast</workgroup>
    <keyword>application-layer multicast</keyword>

    <abstract>
      <t>
      We define a REsource LOcation And Discovery (RELOAD) Usage for
      Application-Layer Multicast (ALM) as well as 
      a mapping to the RELOAD experimental message type to support ALM.
      The ALM Usage is intended to support a variety of ALM control algorithms
      in an overlay-independent way.
      Two example algorithms are defined, based on Scribe and P2PCast.
      </t>

<t>This document is a product of the Scalable Adaptive Multicast Research Group
(SAM RG).
</t>
    </abstract>

 </front>

  <middle>
    <section title="Introduction">
      <t>The concept of scalable adaptive multicast includes both scaling
      properties and adaptability properties. Scalability is intended to
      cover: <list style="symbols">
          <t>large group size</t>

          <t>large numbers of small groups</t>

          <t>rate of group membership change</t>

          <t>admission control for QoS</t>

          <t>use with network-layer QoS mechanisms</t>

          <t>varying degrees of reliability</t>

          <t>trees connecting nodes over the global Internet</t>
        </list> 
        
        Adaptability includes <list style="symbols">
          <t>use of different control mechanisms for different multicast trees
          depending on initial application parameters or application classes</t>

          <t>changing multicast tree structure depending on changes in
          application requirements, network conditions, and membership</t>


        </list> </t>

        <t>Application-Layer Multicast (ALM) has been demonstrated to be a viable
        multicast technology where native multicast isn't available.  
        Many ALM designs have been proposed.  This ALM Usage focuses on:

        <list style="symbols">
          <t>ALM implemented in RELOAD-based overlays </t>
          <t>Support for a variety of ALM control algorithms </t>
          <t>Providing a basis for defining a separate hybrid ALM RELOAD Usage </t>
        </list>

        RELOAD <xref target="RELOAD"></xref> has an 
        application extension mechanism in which a new type of application defines a Usage.
        A RELOAD Usage defines a set of data types and rules for their use.
        In addition, this document describes additional message types and a new ALM
        algorithm plugin architectural component.</t>

<t>This document represents the consensus of the SAM RG. It was repeatedly
discussed within the research group, as well as with other Application-Layer
Multicast experts.
</t>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119">RFC 2119</xref>.</t>
      </section>

    </section>

    <section anchor="definitions" title="Definitions">

      <t>We adopt the terminology defined in Section 3 of <xref target="RELOAD"></xref>,
      specifically the distinction between "node", "peer", and "client".</t>

      <section title="Overlay Network">
        <t>Overlay network:  An application-layer virtual or logical network
     with addressable end points that provides connectivity,
     routing, and messaging between end points.
Overlay networks are
        frequently used as a substrate for deploying new network services or
        for providing a routing topology not available from the underlying
        physical network. Many peer-to-peer systems are overlay networks that
        run on top of the Internet. In <xref target="overlay"/>, "P" indicates overlay
        peers, and peers are connected in a logical address space. The links
        shown in the figure represent predecessor/successor links. Depending
        on the overlay routing model, additional or different links may be
        present.</t>

        <figure align="center" anchor="overlay" title="Overlay Network Example">
          <artwork align="left"><![CDATA[
          P    P    P   P     P
        ..+....+....+...+.....+...
       .                          +P
     P+                            .
       .                          +P
        ..+....+....+...+.....+...
          P    P    P   P     P
            ]]></artwork>
        </figure>

      </section>

      <section title="Overlay Multicast">
        <t>Overlay Multicast (OM): Hosts participating in a multicast session
        form an overlay network and utilize unicast connections among pairs of
        hosts for data dissemination <xref target="BUFORD2009"/> <xref
target="KOLBERG2010"/> <xref target="BUFORD2008"/>. The hosts in overlay
multicast
        exclusively handle group management, routing, and tree construction,
        without any support from Internet routers. This is also commonly known
        as Application-Layer Multicast (ALM) or End-System Multicast (ESM). We
        call systems that use proxies connected in an overlay multicast
        backbone "proxied overlay multicast" or POM.</t>
      </section>

      <section title="Source-Specific Multicast (SSM)">
      <t>SSM tree: The creator of the tree is the source. It sends
        data messages to the tree root that are forwarded down the
       tree.</t>
       </section>

      <section title="Any-Source Multicast (ASM)">
      <t>ASM tree: A node sending a data message sends the message to
       its parent and its children. Each node receiving a data
       message from one edge forwards it to the remaining tree edges to which it
       is connected.</t>
       </section>

      <section title="Peer">
        <t>Peer: An autonomous end system that is connected to the physical
        network and participates in and contributes resources to overlay
        construction, routing, and maintenance. Some peers may also perform
        additional roles such as connection relays, super nodes, NAT
        traversal assistance, and data storage.</t>
      </section>


    </section>

    <section anchor="Assumptions" title="Assumptions">
      <section title="Overlay">
        <t>Peers connect in a large-scale overlay, which may be used for a
        variety of peer-to-peer applications in addition to multicast
        sessions. Peers may assume additional roles in the overlay beyond
        participation in the overlay and in multicast trees. We assume a
        single-structured overlay routing algorithm is used. Any of a variety
        of multi-hop, one-hop, or variable-hop overlay algorithms could be
        used.</t>

        <t>Castro, et al.&nbsp;<xref target="CASTRO2003"/> compared multi-hop
        overlays and found that tree-based construction in a single overlay
        outperformed using separate overlays for each multicast session. We
        use a single overlay rather than separate overlays per multicast
        session. </t>

        <t>An overlay multicast algorithm may leverage the overlay's mechanism
        for maintaining overlay state in the face of churn. For example, a
        peer may store a number of DHT (Distributed Hash Table) entries. When
        the peer gracefully leaves the overlay, it transfers those entries to
        the nearest peer. When another peer joins that is closer to some of
        the entries than the current peer that holds those entries, than
        those entries are migrated. Overlay churn affects multicast trees as
        well; remedies include automatic migration of the tree state and
        automatic rejoin operations for dislocated child nodes.</t>
      </section>

      <section title="Overlay Multicast">
        <t>The overlay supports concurrent multiple multicast trees. The limit
        on the number of concurrent trees depends on peer and network resources
        and is not an intrinsic property of the overlay. </t>
      </section>

      <section title="RELOAD">
        <t>We use RELOAD <xref target="RELOAD"></xref> as 
        the peer-to-peer (P2P) overlay for data storage and the mechanism by
        which the peers interconnect and route messages. RELOAD is a
        generic P2P overlay, and application support is defined by
        profiles called Usages.
        </t>

      </section>

      <section title="NAT">
        <t>Some nodes in the overlay may be in a private address space and
        behind firewalls. We use the RELOAD mechanisms for NAT traversal. We
        permit clients to be leaf nodes in an ALM tree.</t>
      </section>

      <section title="Tree Topology">
        <t>All tree control messages are routed in the overlay.
        Two types of data or media topologies are envisioned:  1) tree edges
are paths in the overlay, and 
        2) tree edges are direct connections between a parent and child peer in the tree,
        formed using the RELOAD AppAttach method.  
        </t>
      </section>
    </section>

    <section title="Architecture Extensions to RELOAD">
      <t>There are two changes as depicted in <xref target="ALMUsage"/>.
      New ALM messages are mapped to RELOAD Message Transport using the RELOAD experimental message type.
      A plugin for ALM algorithms handles the ALM state and control.
      The ALM algorithm is under control of the application
      via the Group API <xref target="COMMON-API"></xref>.
      </t>
        <figure align="center" anchor="ALMUsage" title="RELOAD Architecture Extensions">
          <artwork align="left"><![CDATA[
                                                 +---------+
                                                 |Group API|
                                                 +---------+
                                                      |
    ------------------- Application  ------------------------
        +-------+                                     |
        | ALM   |                                     |
        | Usage |                                     |
        +-------+                                     |
     -------------- Messaging Service Boundary --------------
                                                      |
       +--------+      +-----------+---------+    +---------+
       | Storage|<---> | RELOAD    | ALM     |<-->| ALM Alg |
       +--------+      | Message   | Messages|    +---------+
               ^       | Transport |         |
               |       +-----------+---------+
               v          |    |
              +-------------+  |
              | Topology    |  |
              | Plugin      |  |
              +-------------+  |
                 ^             |
                 v             v
              +-------------------+
              | Forwarding &      |
              | Link Management   |
              +-------------------+
    
     ---------- Overlay Link Service Boundary --------------
            ]]></artwork>
        </figure>


      <t>The ALM components interact with RELOAD as follows: 
         <list style="symbols">
          <t>ALM uses the RELOAD data storage functionality to
          store an ALMTree instance when a new ALM tree is created in the overlay and
          to retrieve ALMTree instance(s) for existing ALM trees.</t>

          <t>ALM applications and management tools may use the RELOAD data storage
          functionality to store diagnostic information about the operation of
          trees, including average number of trees, delay from source to leaf
          nodes, bandwidth use, and packet loss rate. In addition, diagnostic
          information may include statistics specific to the tree root or to
          any node in the tree.</t>
        </list> 
       </t>
    </section>

    <section title="RELOAD ALM Usage" anchor="reload-alm-usage">
      <t>Applications of RELOAD are restricted in the data types that can be
      stored in the DHT. The profile of accepted data types for an application
      is referred to as a Usage. RELOAD is designed so that new applications
      can easily define new Usages. New RELOAD Usages are needed for 
      multicast applications since the data types in base RELOAD and existing
      Usages are not sufficient.</t>

      <t>We define an ALM Usage in RELOAD. This ALM
      Usage is sufficient for applications that require ALM
      functionality in the overlay. <xref target="ALMUsage"/> shows the internal structure
      of the ALM Usage. This contains the Group API (<xref
      target="COMMON-API"></xref>),
      an ALM algorithm plugin (e.g., Scribe), and the ALM messages that are then 
      sent out to the RELOAD network.</t>

      <t>A RELOAD Usage is required <xref
      target="RELOAD"></xref> to define the following: 
      <list style="symbols">
          <t>Kind-ID and code points</t>

          <t>data structures for each Kind</t>

          <t>access control rules for each Kind</t>

          <t>the Resource Name used to hash to the Resource ID that determines where
          the Kind is stored</t>

          <t>address restoration after recovery from a network
          partition (to form a single coherent network)</t>

          <t>the types of connections that can be initiated using AppConnect</t>
        </list>
        </t>

           <t>An ALM group_id is a RELOAD node_id. The owner of an ALM group creates
        a RELOAD node_id as specified in <xref
        target="RELOAD"></xref>. This means that a group_id is
        used as a RELOAD Destination for overlay routing purposes.</t>
   
    </section>

    <section title="ALM Tree Control Signaling">
      <t>Peers use the overlay to support ALM operations such as: 
        <list style="symbols">
          <t>CreateALMTree</t>
          <t>Join</t>
          <t>Leave</t>
          <t>Reform or optimize tree</t>
        </list>

      There are a variety of algorithms for peers to form multicast
      trees in the overlay. 
    The approach presented here permits multiple
     such algorithms to be supported
     in the overlay since different algorithms may be more suitable for
     certain application requirements; the approach also supports
     experimentation.
Therefore, overlay messaging corresponding to the set
      of overlay multicast operations MUST carry algorithm identification
      information.</t>

      <t>For example, for small groups, the join point might be directly
      assigned by the rendezvous point, while for large trees the Join request
      might be propagated down the tree with candidate parents forwarding
      their position directly to the new node.</t>

      <t>Here is a simplistic notation for forming a multicast tree in the
        overlay. Its main advantage is the use of the overlay for routing 
        both control and data messages. The group creator does not
        have to be the root of the tree or even in the tree. It does not
        consider per-node load, admission control, or alternative paths. 
        After the creation of a tree, the group_id is expected to be 
        advertised or distributed out of band, 
        perhaps by publishing in the DHT. Similarly, joining peers will discover 
        the group_id out of band, perhaps by a lookup in the tree.
</t>

        <t>As stated earlier, multiple algorithms will coexist in the
        overlay. <list style="numbers">
            <t>Peer that initiates multicast group: 

<figure align="left">
<artwork align="left"><![CDATA[
       group_id = create();  // Allocate a unique group_id. 
                            // The root is the nearest
                            // peer in the overlay.
]]></artwork>
              </figure></t>

            <t>Any joining peer: 
            
<figure align="left">
<artwork align="left"><![CDATA[
       joinTree(group_id); // sends "join group_id" message]]></artwork></figure>
The overlay routes the Join
            request using the overlay routing mechanism toward the peer with
            the nearest ID to the group_id. This peer is the root. Peers on the
            path to the root join the tree as forwarding points.</t>

            <t>Leave Tree: <vspace blankLines="1" /> leaveTree(group_id); //
            removes this node from the tree <vspace blankLines="1" />
            Propagates a Leave request to each child node and to the parent
            node. If the parent node is a forwarding node and this is its last
            child, then it propagates a Leave request to its parent. A child
            node receiving a Leave request from a parent sends a Join request
            to the group_id.</t>

            <t>Message forwarding: <vspace blankLines="1" />
            multicastMsg(group_id, msg);<vspace blankLines="1" />

            For message forwarding, both Any-Source Multicast (ASM) and 
            Source-Specific Multicast (SSM) approaches may be used.</t>
          </list></t>
      </section>


    <section anchor="sec-protocol" title="ALM Messages Mapped to RELOAD"> 
     <section title="Introduction">
        <t>In this document, we define messages for overlay multicast
        tree creation, using an existing protocol (RELOAD) in the P2P-SIP WG
        <xref target="RELOAD"></xref> for a universal structured
        peer-to-peer overlay protocol. RELOAD provides the mechanism to
        support a number of overlay topologies. Hence, the overlay
        multicast framework defined in this document can be
        used with P2P-SIP and makes the Scalable Adaptive Multicast (SAM) framework overlay agnostic.</t>

        <t>As discussed in the SAM requirements 
        document <xref target="SAM-GENERIC"></xref>, there are a variety of
        ALM tree formation and tree maintenance algorithms. The intent of this
        specification is to be algorithm agnostic, similar to how RELOAD is
        overlay algorithm agnostic. We assume that all control messages are
        propagated using overlay routed messages.</t>

        <t>The message types needed for ALM behavior are divided into the
        following categories: <list style="symbols">
            <t>Tree lifecycle (Create, Join, Leave, Reform, Heartbeat)</t>

            <t>Peer region and multicast properties</t>
          </list></t>

        <t>The message codes are defined in <xref target="MessageCodeIANA"></xref> of this document.  
        Messages are mapped to the RELOAD experimental message type.</t>
        <t>In the following sections, the protocol messages as mapped to RELOAD are discussed. Detailed example message 
        flows are provided in <xref target="MessageFlows"></xref>.</t>
        <t>In the following descriptions, we use the datatype Dictionary, which is a set of
        opaque  values indexed by an opaque key with one value for each key.  A single dictionary entry is represented
        by a DictionaryEntry as defined in Section 7.2.3 of the RELOAD document <xref target="RELOAD"></xref>. 
        The Dictionary datatype is defined as follows:</t>

        <figure>
            <artwork align="left"><![CDATA[
struct {
  DictionaryEntry elements<0..2^16-1>;
  } Dictionary;
]]></artwork> </figure>
  
      </section>

      <section title="Tree Lifecycle Messages">
        <t>Peers use the overlay to transmit ALM
        operations defined in this section.</t>

        <section anchor="CreateALMTree" title="CreateALMTree">
          <t>A new ALM tree is created in the overlay with the identity
          specified by group_id. The common interpretation in a DHT-based overlay 
          of group_id is that the peer with a peer_id closest to and less than 
          the group_id is the root of the tree. However, other overlay types 
          are supported. The tree has no children at the time it is
          created.</t>

          <t>The group_id is generated from a well-known session key to be used
          by other peers to address the multicast tree in the overlay. The
          generation of the group_id from the session_key MUST be done using the
          overlay's ID-generation mechanism.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        node_id peer_id;
        opaque session_key<0..2^32-1>;
        node_id group_id;
        Dictionary options;
      } ALMTree;
]]></artwork>
          </figure>

          <t>peer_id: overlay address of the peer that creates the
          multicast tree.</t>

          <t>session_key: a well-known string that when hashed using the overlay's
          ID-generation algorithm produces the group_id.</t>

          <t>group_id: overlay address of the root of the tree.</t>

          <t>options: name-value list of properties to be associated with the
          tree, such as the maximum size of the tree, restrictions on peers
          joining the tree, latency constraints, preference for distributed or
          centralized tree formation and maintenance, and Heartbeat interval.</t>

         <t>Tree creation is subject to access control since it involves a Store operation.
         The NODE-MATCH access policy defined in Section 7.3.2 of <xref
target="RELOAD"></xref> is used.

         </t>

         <t>A successful CreateALMTree causes an ALMTree structure to be stored in the overlay
         at the node G responsible for the group_id.  This node G performs the
         RELOAD-defined StoreReq operation as a side effect of performing the CreateALMTree. 
         If the StoreReq fails, the CreateALMTree fails too.
         </t>
  
         <t>After a successful CreateALMTree, peers can 
         use the RELOAD Fetch method to retrieve the ALMTree struct at address group_id.
         The ALMTree Kind is defined in <xref target="ALMTreeKind"></xref>.
         </t>

       </section>

    <section title="CreateALMTreeResponse">
      <t>After receiving a CreateALMTree message from node S, the peer sends a CreateALMTreeResponse to node S.</t>

      <figure>
            <artwork align="left"><![CDATA[
        struct {  
          Dictionary options;
        } CreateALMTreeResponse;
]]></artwork>
          </figure>

      <t>options: A node may provide algorithm-dependent parameters about the created tree to the
       requesting node.</t>

     </section>


        <section title="Join">
          <t>Join causes the distributed algorithm for peer join of a specific ALM
          group to be invoked. The definition of the Join request is shown below. 
          If successful, the joining peer is notified of one or
          more candidate parent peers in one or more JoinAccept messages. The
          particular ALM join algorithm is not specified in this protocol.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        node_id peer_id;
        node_id group_id;
        Dictionary options;
      } Join;
]]></artwork>
          </figure>

          <t>peer_id: overlay address of joining/leaving peer</t>

          <t>group_id: overlay address of the root of the tree</t>

          <t>options: name-value list of options proposed by joining peer</t>
          
<t>RELOAD is a request-response protocol. Consequently, the messages JoinAccept
and JoinReject (defined below) are matching responses for Join. If
JoinReject is received, then no further action on this request is
carried out. If JoinAccept is received, then either a JoinConfirm or a JoinDecline 
message (see below) is sent.  The matching response for JoinConfirm
is JoinConfirmResponse.  The matching response for JoinDecline is
JoinDeclineResponse.</t>

<t>The following list shows the matching request-responses according to the request-response
mechanism defined in <xref target="RELOAD"></xref>.</t>

<t><list>
<t>Join -- JoinAccept:  Node C sends a Join request to node P.  If node P accepts, it responds with JoinAccept.</t>
<t>Join -- JoinReject:  Node C sends a Join request to node P.  If node P does not accept the Join request, it responds with JoinReject.</t>
<t>JoinConfirm -- JoinConfirmResponse: If node P sent node C a JoinAccept and
node C confirms with a JoinConfirm request, then node P responds with a
JoinConfirmResponse.   </t>

<t>JoinDecline -- JoinDeclineResponse: If node P sent node C a JoinAccept and
node C declines with a JoinDecline request, then node P responds with a
JoinDeclineResponse. </t>

</list></t>

<t>Thus, Join, JoinConfirm, and JoinDecline are treated as requests as defined in
RELOAD, are mapped to the RELOAD exp_a_req message, and are therefore retransmitted until 
either a retry limit is reached or a matching response received.
JoinAccept, JoinReject, JoinConfirmResponse, and JoinDeclineResponse are treated
as message responses as defined above and are mapped to the RELOAD exp_a_ans message.
</t>

<t>The Join behavior can be described as follows:</t>

          <figure>
<artwork align="left"><![CDATA[
if(checkAccept(msg)) {
    recvJoins.add(msg.source, msg.group_id)
    SEND(JoinAccept(node_id, msg.source, msg.group_id))
}
]]></artwork>
          </figure>

        </section>

        <section title="JoinAccept (Join Response)">
          <t>JoinAccept tells the requesting joining peer that the indicated peer is
          available to act as its parent in the ALM tree specified by group_id,
          with the corresponding options specified. A peer MAY receive more
          than one JoinAccept from different candidate parent peers in the
          group_id tree. The peer accepts a peer as parent using a JoinConfirm
          message. A JoinAccept that receives neither a JoinConfirm nor
          JoinDecline message MUST expire. RELOAD implementations are able to 
          read a local configuration file for settings. It is assumed that 
          this file  contains the timeout value to be used.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        node_id parent_peer_id;
        node_id child_peer_id;
        node_id group_id;
        Dictionary options;
      } JoinAccept;
]]></artwork>
          </figure>

          <t>parent_peer_id: overlay address of a peer that accepts the joining
          peer</t>

          <t>child_peer_id: overlay address of joining peer</t>

          <t>group_id: overlay address of the root of the tree</t>

          <t>options: name-value list of options accepted by parent peer</t>
          
        </section>

        <section title="JoinReject (Join Response)">
          <t>A peer receiving a Join request responds with a JoinReject response to indicate the request is rejected.</t>
        </section>

        <section title="JoinConfirm">
          <t>A peer receiving a JoinAccept message that it wishes to accept
          MUST explicitly accept it using a JoinConfirm message before the
expiration of a timer for the JoinAccept message. The joining peer MUST include
only
          those options from the JoinAccept that it also accepts, completing
          the negotiation of options between the two peers.</t>

<figure>
<artwork align="left"><![CDATA[
      struct {  
        node_id child_peer_id;
        node_id parent_peer_id;
        node_id group_id;
        Dictionary options;
      } JoinConfirm;
]]></artwork>
</figure>

          <t>child_peer_id: overlay address of joining peer that is a child of
          the parent peer</t>

          <t>parent_peer_id: overlay address of the peer that is the parent of
          the joining peer</t>

          <t>group_id: overlay address of the root of the tree</t>

          <t>options: name-value list of options accepted by both peers</t>

<t>The JoinConfirm message behavior is described below:</t>

          <figure>
<artwork align="left"><![CDATA[
if(recvJoins.contains(msg.source,msg.group_id)){
   if !(groups.contains(msg.group_id)) {
      groups.add(msg.group_id)
      SEND(msg,msg.group_id)
   }
   groups[msg.group_id].children.add(msg.source)
   recvJoins.del(msg.source, msg.group_id)
}
]]></artwork>
          </figure>
        </section>


        <section title="JoinConfirmResponse">
          <t>A peer receiving a JoinConfirm message responds with a JoinConfirmResponse message.</t>
        </section>

        <section title="JoinDecline">
          <t>A peer receiving a JoinAccept message that it does not wish to
          accept MAY explicitly decline it using a JoinDecline message.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        node_id peer_id;
        node_id parent_peer_id;
        node_id group_id;
      } JoinDecline;
]]></artwork>
          </figure>

          <t>peer_id: overlay address of joining peer that declines the
          JoinAccept</t>

          <t>parent_peer_id: overlay address of the peer that issued a
          JoinAccept to this peer</t>

          <t>group_id: overlay address of the root of the tree</t>

<t>The behavior of the JoinDecline message is described as follows:</t>

          <figure>
<artwork align="left"><![CDATA[
if(recvJoins.contains(msg.source,msg.group_id))
   recvJoins.del(msg.source, msg.group_id)
]]></artwork>
          </figure>
        </section>


        <section title="JoinDeclineResponse">
          <t>A peer receiving a JoinConfirm message responds with a JoinDeclineResponse message.</t>
        </section>

        <section title="Leave">
          <t>A peer that is part of an ALM tree identified by group_id that
          intends to detach from either a child or parent peer SHOULD send a
          Leave request to the peer from which it wishes to detach. A peer receiving
          a Leave request from a peer that is neither in its parent nor child
          lists SHOULD ignore the message.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        node_id peer_id;
        node_id group_id;
        Dictionary options;
      } Leave;
]]></artwork>
          </figure>

          <t>peer_id: overlay address of leaving peer</t>

          <t>group_id: overlay address of the root of the tree</t>

          <t>options: name-value list of options</t>

<t>The behavior of the Leave request can be described as: </t>

          <figure>
<artwork align="left"><![CDATA[
groups[msg.group_id].children.remove(msg.source)
if (groups[msg.group].children = 0)
      SEND(msg,groups[msg.group_id].parent)
]]></artwork>
          </figure>
        </section>


        <section title="LeaveResponse">
          <t>A peer receiving a Leave request responds with a LeaveResponse message.</t>
        </section>

        <section title="Reform or Optimize Tree">
          <t>This triggers a reorganization of either the entire tree or only
          a subtree. It MAY include hints to specific peers of recommended
          parent or child peers to which to reconnect. A peer receiving this message
          MAY ignore it, MAY propagate it to other peers in its subtree, and
          MAY invoke local algorithms for selecting preferred parent and/or
          child peers.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        node_id group_id;
        node_id peer_id;
        Dictionary options;
      } Reform;
]]></artwork>
          </figure>

          <t>group_id: overlay address of the root of the tree</t>

          <t>peer_id: if omitted, then the tree is reorganized starting from
          the root; otherwise, it is reorganized only at the subtree
          identified by peer_id.</t>

          <t>options: name-value list of options</t>
        </section>

        <section title="ReformResponse">
          <t>A peer receiving a Reform message responds with a ReformResponse.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        Dictionary options;
      } ReformResponse;
]]></artwork>
          </figure>

         <t>options: algorithm-dependent information about the results of the Reform operation</t>
        </section>

        <section title="Heartbeat">
          <t>A child node signals to its adjacent parent nodes in the tree that it is
          alive. If a parent node does not receive a Heartbeat message within N
          Heartbeat time intervals, it MUST treat this as an explicit Leave
          request from the unresponsive peer. N is configurable. RELOAD implementations 
          are able to read a local configuration file for settings. It is assumed that 
          this file  contains the value for N to be used.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        node_id peer_id_src;
        node_id peer_id_dst;
        node_id group_id;
        Dictionary options;
      } Heartbeat;
]]></artwork>
          </figure>

          <t>peer_id_src: source of Heartbeat</t>
          <t>peer_id_dst: destination of Heartbeat</t>
          <t>group_id: overlay address of the root of the tree</t>
          <t>options: an algorithm may use the Heartbeat message to provide state information to adjacent nodes in the tree</t>
       </section>

        <section title="Heartbeat Response">
          <t>A parent node responds with a HeartbeatResponse to a Heartbeat from a child node indicating
          that it has received the Heartbeat message.
         </t>
       </section>

      <section title="NodeQuery">

       <t>The NodeQuery message is used to obtain information about the state and performance 
       of the tree on a per-node basis.  A set of nodes could be queried to construct a centralized 
       view of the multicast trees, similar to a web crawler.</t>

      <figure>
       <artwork align="left"><![CDATA[
        struct {  
          node_id peer_id_src;
          node_id peer_id_dst;
        } NodeQuery;
]]></artwork>
      </figure>

          <t>peer_id_src: source of query</t>
          <t>peer_id_dst: destination of query</t>
       </section>

<section title="NodeQueryResponse">
<t>The response to a NodeQuery message contains a NodeStatistics instance for this node.</t>

<figure>
<artwork align="left"><![CDATA[
public struct {
   uint32        node_lifetime;
   uint32        total_number_trees;
   uint16        number_algorithms_supported;
   uint8         algorithms_supported[32];
   TreeData      max_tree_data;
   uint16        number_active_trees;
   TreeData      tree_data<0..2^8-1>;
   ImplementationInfo impl_info;
}  NodeStatistics;
]]></artwork>
          </figure>

<t><list>
<t>node_lifetime:  time the node has been alive in seconds since last restart</t>
<t>total_number_trees:   total number of trees this node has been part of during the node lifetime</t>
<t>number_algorithms_supported:  value between 0..2^16-1 corresponding to the number of algorithms supported</t>
<t>algorithms_supported:   list of algorithms, each byte encoded using the corresponding algorithm code</t>
<t>max_tree_data:  data about tree with largest number of nodes that this node was part of. 
NodeQuery can be used to crawl all the nodes in an ALM tree to fill this field. This is intended to 
support monitoring, algorithm design, and general experimentation with ALM in RELOAD.
</t>
<t>number_active_trees:  current number of trees that the node is part of</t>
<t>tree_data:  details of each active tree; the number of such is specified by
number_active_trees</t>
<t>impl_info:  information about the implementation of this Usage</t>
</list></t>

<figure>
<artwork align="left"><![CDATA[
public struct {
  uint32       tree_id;
  uint8        algorithm;
  node_id       tree_root;
  uint8        number_parents;
  node_id       parent<0..2^8-1>;
  uint16       number_child_nodes;
  node_id       children<0..2^16-1>;
  uint32       path_length_to_root;
  uint32       path_delay_to_root;
  uint32       path_delay_to_child;
} TreeData;
]]></artwork>
          </figure>

<t><list>
<t>tree_id:  the ID of the tree</t>
<t>algorithm:  code identifying the multicast algorithm used by this tree</t>
<t>tree_root:  node_id of tree root, or 0 if unknown</t>
<t>number_parents:   0 .. 2^8-1 indicates number of parent nodes for this node</t>
<t>parent:  the RELOAD node_id of each parent node</t>
<t>number_child_nodes:    0..2^16-1 indicates number of children</t>
<t>children:  the RELOAD node_id of each child node</t>
<t>path_length_to_root:  number of overlay hops to the root of the tree</t>
<t>path_delay_to_root:  RTT in milliseconds to root node</t>
<t>path_delay_to_child:  last measured RTT in milliseconds to child node with largest RTT</t>
</list></t>


<figure>
<artwork align="left"><![CDATA[
public struct {
  uint32       join_confirm_timeout;
  uint32       heartbeat_interval;
  uint32       heartbeat_response_timeout;
  uint16       info_length;
  uint8        info<0..2^16-1>;
} ImplementationInfo;
]]></artwork>
</figure>

<t><list>
<t>join_confirm_timeout: The default time for JoinConfirm/JoinDecline, intended to provide sufficient
time for a Join request to receive all responses and confirm the best choice.  Default value is 5000 msec.
An implementation can change this value.</t>
<t>heartbeat_interval: The default Heartbeat interval is 2000 msec. Different interoperating implementations could use different intervals.</t>
<t>heartbeat_response_timeout: The default Heartbeat timeout is 5000 msec and
is the max time between Heartbeat reports from an adjacent node in the tree at
which point the Heartbeat is missed.</t>
<t>info_length: length of the info field</t>
<t>info: implementation-specific information, such as name of implementation,
build version, and implementation-specific features</t>
</list></t>

 </section>   

<section title="Push">
          <t>A peer sends arbitrary multicast data to other peers in the tree.
Nodes in the tree forward this message to adjacent nodes in the tree in an
algorithm-dependent way.</t>


      <figure>
            <artwork align="left"><![CDATA[
      struct {  
        node_id group_id;
        uint8  priority;
        uint32 length;
        uint8  data<0..2^32-1>;
      } Push;
]]></artwork>
          </figure>

          <t>group_id: overlay address of root of the ALM tree</t>
          <t>priority: the relative priority of the message; highest priority is 255. A node may ignore this field.</t>
          <t>length: length of the data field in bytes</t>

          <t>data: the data</t>

<t>In pseudocode, the behavior of Push can be described as:</t>

          <figure>
<artwork align="left"><![CDATA[
foreach(groups[msg.group_id].children as node_id)
     SEND(msg,node_id)
if memberOf(msg.group_id)
     invokeMessageHandler(msg.group_id, msg)
]]></artwork>
          </figure>

        </section>


    <section title="PushResponse">
      <t>After receiving a Push message from node S, the receiving peer sends a PushResponse to node S.</t>

      <figure>
            <artwork align="left"><![CDATA[
      struct {  
        Dictionary options;
      } PushResponse;
]]></artwork>
          </figure>

      <t>options: A node may provide feedback to the sender about previous Push messages in some window,
      for example, the last N Push messages.  The feedback could include, for each Push message received,
      the number of adjacent nodes that were forwarded the Push message and the number of adjacent nodes
      from which a PushResponse was received.</t>

     </section>
 
</section>   
    </section>

    <section anchor="Scribe" title="Scribe Algorithm">

    <section title="Overview">
      <t>
     <xref target="ScribeMapping"/> shows a mapping between RELOAD ALM  messages (as defined in 
     <xref target="reload-alm-usage"/> of this document) and Scribe messages as defined in <xref target="CASTRO2002"></xref>. </t>

    
        <figure align="center" anchor="ScribeMapping" title="Mapping to Scribe Messages">
          <artwork align="left"><![CDATA[
   +---------+-------------------+-----------------+
   | Section |RELOAD ALM Message | Scribe Message  |
   +---------+-------------------+-----------------+
   | 7.2.1   | CreateALMTree     | Create          |
   +---------+-------------------+-----------------+
   | 7.2.3   | Join              | Join            |
   +---------+-------------------+-----------------+
   | 7.2.4   | JoinAccept        |                 |
   +---------+-------------------+-----------------+
   | 7.2.6   | JoinConfirm       |                 |
   +---------+-------------------+-----------------+
   | 7.2.8   | JoinDecline       |                 |
   +---------+-------------------+-----------------+
   | 7.2.10  | Leave             | Leave           |
   +---------+-------------------+-----------------+
   | 7.2.12  | Reform            |                 |
   +---------+-------------------+-----------------+
   | 7.2.14  | Heartbeat         |                 |
   +---------+-------------------+-----------------+
   | 7.2.16  | NodeQuery         |                 |
   +---------+-------------------+-----------------+
   | 7.2.18  | Push              | Multicast       |
   +---------+-------------------+-----------------+
   |         | Note 1            | deliver         |
   +---------+-------------------+-----------------+
   |         | Note 1            | forward         |
   +---------+-------------------+-----------------+
   |         | Note 1            | route           |
   +---------+-------------------+-----------------+
   |         | Note 1            | send            |
   +---------+-------------------+-----------------+
            ]]></artwork>
        </figure>
    
     <t>Note 1: These Scribe messages are handled by RELOAD messages.</t>

      <t>The following sections describe the Scribe algorithm in more detail.</t>
      
    </section>
      
        <section title="Create">

<t>
This message will create a group with group_id. This message MUST be delivered 
to the node whose node_id is closest to the group_id. This node becomes the 
rendezvous point and root for the new multicast tree. 
Groups MAY have multiple sources of multicast messages.
</t>
</section>

<section title="Join">
<t>
To join a multicast tree, a node SHOULD send a Join request with the group_id as the key. This message
gets routed by the overlay to the rendezvous point of the tree. If an intermediate node is already
a forwarder for this tree, it SHOULD add the joining node as a child. Otherwise, the node SHOULD create
a child table for the group and add the joining node. It SHOULD then send the Join request towards the 
rendezvous point terminating the Join request from the child.
</t>
<t>
To adapt the Scribe algorithm to the ALM Usage proposed here, after a Join
request is accepted, a JoinAccept message MUST be returned to the joining node.
</t>

 </section>


        <section title="Leave">

<t>
When leaving a multicast group, a node SHOULD change its local state to indicate that it left the group.
If the node has no children in its table, it MUST send a Leave request to its parent, from where it SHOULD travel
up the multicast tree and stop at a node that still has children remaining
after removing the leaving node.
</t>
        </section>


<section title="JoinConfirm">
<t>
This message is not part of the Scribe protocol but is required by the basic 
protocol proposed in this document. Thus, the Usage MUST send this message to confirm a
joining node accepting its parent node.
</t>
</section>

        <section title="JoinDecline">
<t>
Like JoinConfirm, this message is not part of the Scribe protocol. Thus, the
Usage MUST send this message if a peer receiving a JoinAccept message
wishes to decline it.
</t>
        </section>

        <section title="Multicast">
<t>
A message to be multicast to a group MUST be sent to the rendezvous node from where it is 
forwarded down the tree. If a node is a member of the tree rather than just a forwarder,
it SHOULD pass the multicast data up to the application.
</t>
       </section>
   </section>


    <section anchor="P2PCast" title="P2PCast Algorithm">

    <section title="Overview">

<t>
P2PCast <xref target="P2PCAST"/> creates a forest of related trees to increase load balancing. 
P2PCast is independent of the underlying P2P substrate. Its goals and approach 
are similar to SplitStream <xref target="SPLITSTREAM"/> (which assumes Pastry as the P2P overlay).
In P2PCast, the content provider splits the stream of data into f stripes. 
Each tree in the forest of multicast trees is an (almost) full tree of arity
f.&nbsp; These trees are conceptually separate: every node of the system appears 
once in each tree, with the content provider being the source in all
of them. To ensure that each peer contributes as much bandwidth as it 
receives, every node is a leaf in all the trees except for one, in which the
node will serve as an internal node (proper tree of this node). 
To reduce the complexity of the discussion that follows, the remainder of this
section will assume that f = 2. However, the algorithm scales for any number f.
</t>

<t>P2PCast distinguishes the following types of nodes:</t>

<t><list style="symbols">
<t>Incomplete Node: A node with less than f children in its proper stripe</t>
<t>Only-Child Node: A node whose parent (in any multicast tree) is an incomplete
node</t>
<t>Complete Node: A node with exactly f children in its proper stripe </t>
<t>Special Node: A single node that is a leaf in all multicast trees of the forest </t>
</list>
</t>
</section>

    <section title="Message Mapping">
      <t>
     <xref target="P2PCastMapping"/> shows a mapping between RELOAD ALM  messages (as defined in 
     <xref target="reload-alm-usage"/> of this document) and P2PCast messages as defined in <xref target="P2PCAST"></xref>. </t>

    
        <figure align="center" anchor="P2PCastMapping" title="Mapping to P2PCast Messages">
          <artwork align="left"><![CDATA[
    +---------+-------------------+-----------------+
    | Section |RELOAD ALM Message | P2PCast Message |
    +---------+-------------------+-----------------+
    | 7.2.1   | CreateALMTree     | Create          |
    +---------+-------------------+-----------------+
    | 7.2.3   | Join              | Join            |
    +---------+-------------------+-----------------+
    | 7.2.4   | JoinAccept        |                 |
    +---------+-------------------+-----------------+
    | 7.2.6   | JoinConfirm       |                 |
    +---------+-------------------+-----------------+
    | 7.2.8   | JoinDecline       |                 |
    +---------+-------------------+-----------------+
    | 7.2.10  | Leave             | Leave           |
    +---------+-------------------+-----------------+
    | 7.2.12  | Reform            | Takeon          |
    |         |                   | Substitute      |
    |         |                   | Search          |
    |         |                   | Replace         |
    |         |                   | Direct          |
    |         |                   | Update          |
    +---------+-------------------+-----------------+
    | 7.2.14  | Heartbeat         |                 |
    +---------+-------------------+-----------------+
    | 7.2.16  | NodeQuery         |                 |
    +---------+-------------------+-----------------+
    | 7.2.18  | Push              | Multicast       |
    +---------+-------------------+-----------------+
            ]]></artwork>
        </figure>
    
      <t>The following sections describe the mapping of the P2PCast messages in more detail.</t>
      
    </section>


<section title="Create">

<t>
This message will create a group with group_id. This message MUST be delivered 
to the node whose node_id is closest to the group_id. This node becomes the 
rendezvous point and root for the new multicast tree. The rendezvous point will maintain f subtrees.
</t>

</section>

<section title="Join">
<t>
To join a multicast tree, a joining node N MUST send a Join request to a random node A already part of the tree.
Depending on the type of A, the joining algorithm continues as follows:</t>

<t><list style="symbols">
<t>Incomplete Node: Node A will arbitrarily select for which tree it wants to serve as an internal node
and adopt N in that tree. In the other tree, node N will adopt node A as a child (taking node A's place in the tree),
thus becoming an internal node in the stripe that node A didn't choose.</t>

<t>Only-Child Node: As this node has a parent that is an incomplete node, the joining node will be 
redirected to the parent node and will handle the request as detailed above.</t>

<t>Complete Node: The contacted node A must be a leaf in the other tree. If node A is a leaf node in Stripe 1,
node N will become an internal node in Stripe 1, taking the place of node A and
adopting it at the
same time. To find a place for itself in the other stripe, node N starts a random walk
down the subtree rooted at the sibling of node A (if node A is the root and thus does not have siblings, 
node N is sent directly to a leaf in that tree), which ends as soon as node N finds an incomplete
node or a leaf. In this case, node N is adopted by the incomplete node. </t>

<t>Special Node: as this node is a leaf in all subtrees, the joining node MAY adopt the node 
in one tree and become a child in the other.</t>
</list>
</t>
<t>
P2PCast uses defined messages for communication between nodes during reorganization. To use P2PCast in this context, 
these messages are encapsulated by the message type Reform. In doing so, the P2PCast message is to be included in 
the options parameter of Reform. The following reorganization messages are defined by P2PCast:
</t>

<t><list>
<t>Takeon: To take another peer as a child</t>
<t>Substitute: To take the place of a child of some peer</t>
<t>Search: To obtain the child of a node in a particular stripe</t>
<t>Replace: Different from Substitute in that the calling node that makes a
node its child sheds off a random child
</t>

<t>Direct: To direct a node to its would-be parent</t>
<t>Update: A node sends its updated state to its children</t>
</list></t>

<t>To adapt the P2PCast algorithm to the ALM Usage proposed here, after a Join
request is accepted, a JoinAccept message MUST be returned to the joining node
(one for every subtree).</t>

</section>

<section title="Leave">

<t>
When leaving a multicast group, a node will change its local state to indicate that it left the group.
Disregarding the case where the leaving node is the root of the tree, the leaving node must be 
complete or incomplete in its proper tree. In the other trees, the node is a leaf and can just 
disappear by notifying its parent.

For the proper tree, if the node is incomplete, it is replaced by its child. However, if the node is 
complete, a gap is created that is filled by a random child. If this child is incomplete, it can 
simply fill the gap. However, if it is complete, it needs to shed a random child. This child is directed to 
its sibling, which sheds a random child. This process ripples down the tree until the next-to-last level 
is reached. The shed node is then taken as a child by the parent of the deleted node in the other stripe.
</t>

<t>Again, for the reorganization of the tree, the Reform message type is used as defined in the previous section.</t>

</section>


<section title="JoinConfirm">

<t>
This message is not part of the P2PCast protocol but is required by the basic 
protocol defined in this document. Thus, the Usage MUST send this message to
confirm a joining node accepting its parent node. As with Join and
JoinAccept, this MUST be carried out for every subtree.
</t>
        </section>

        <section title="Multicast">

<t>
A message to be multicast to a group MUST be sent to the rendezvous node from where it is 
forwarded down the tree by being split into k stripes. Each stripe is then sent via a subtree. 
If a receiving node is a member of the tree rather than just a forwarder,
it MAY pass the multicast data up to the application.
</t>

</section>
</section>

<section anchor="MessageCodes" title="Message Format">

<t>
All messages are mapped to the RELOAD experimental message type.
The mapping is shown in <xref target="MessageCodes2"/>.  The message codes are listed
in <xref target="MessageCodeIANA"/>.
The format of the body of a message is provided in <xref target="RELOAD"/>.
</t>

        <figure align="center" anchor="MessageCodes2" title="RELOAD Message Code Mapping">
          <artwork align="left"><![CDATA[
   +-------------------------+------------------+
   | Message                 |RELOAD Code Point |
   +-------------------------+------------------+
   | CreateALMTree           | exp_a_req        |
   +-------------------------+------------------+
   | CreateALMTreeResponse   | exp_a_ans        |
   +-------------------------+------------------+
   | Join                    | exp_a_req        |
   +-------------------------+------------------+
   | JoinAccept              | exp_a_ans        |
   +-------------------------+------------------+
   | JoinReject              | exp_a_ans        |
   +-------------------------+------------------+
   | JoinConfirm             | exp_a_req        |
   +-------------------------+------------------+
   | JoinConfirmResponse     | exp_a_ans        |
   +-------------------------+------------------+
   | JoinDecline             | exp_a_req        |
   +-------------------------+------------------+
   | JoinDeclineResponse     | exp_a_ans        |
   +-------------------------+------------------+
   | Leave                   | exp_a_req        |
   +-------------------------+------------------+
   | LeaveResponse           | exp_a_ans        |
   +-------------------------+------------------+
   | Reform                  | exp_a_req        |
   +-------------------------+------------------+
   | ReformResponse          | exp_a_ans        |
   +-------------------------+------------------+
   | Heartbeat               | exp_a_req        |
   +-------------------------+------------------+
   | HeartbeatResponse       | exp_a_ans        |
   +-------------------------+------------------+
   | NodeQuery               | exp_a_req        |
   +-------------------------+------------------+
   | NodeQueryResponse       | exp_a_ans        |
   +-------------------------+------------------+
   | Push                    | exp_a_req        |
   +-------------------------+------------------+
   | PushResponse            | exp_a_ans        |
   +-------------------------+------------------+
]]></artwork>
        </figure>

 <t>For Data Kind-IDs, the RELOAD specification <xref target="RELOAD"></xref>
states: "Code points in the range 0xF0000001 to
0xFFFFFFFE are reserved for private use".  
ALM Usage Kind-IDs are defined in the private use
range.</t>

     
    <t>All ALM Usage messages map to the RELOAD Message Extension mechanism.</t>

      <t>Code points for the Kinds defined in this document MUST NOT conflict with any defined code points for RELOAD. 
      RELOAD defines exp_a_req and exp_a_ans for experimental purposes.  This specification uses only these message types 
      for all ALM messages. RELOAD defines the MessageContents data structure. The ALM mapping uses the fields as follows:</t>

<t><list style="symbols">
  <t>message_code:  exp_a_req  for requests and exp_a_ans for responses</t>
  <t>message_body:  contains one instance of ALMHeader followed by one instance of ALMMessageContents</t>
  <t>extensions: unused</t>
</list></t>

<section anchor="ALMHeaderDef" title="ALMHeader Definition">

<figure>
<artwork align="left"><![CDATA[
 struct {
    uint32           sam_token;
    uint16           alm_algorithm_id;
    uint8            version;
 } ALMHeader;
]]></artwork>
          </figure>

<t>The fields in ALMHeader are used as follows:</t>

<t><list>
<t>sam_token:   The first four bytes identify this message as an ALM message.
This field MUST contain the value 0xD3414D42 (the string "SAMB" with the high bit
of the first byte set).</t>

<t>alm_algorithm_id:  The ALM Algorithm ID of the ALM algorithm being used.  Each multicast tree uses only one algorithm.
Trees with different ALM algorithms can coexist and can share the same nodes.  ALM Algorithm ID
codes are defined in <xref target="ALMAlgorithmTypesIANA"/>.</t>

<t>version:  The version of the ALM protocol being used.   This is a fixed-point
integer between 0.1 and 25.4.  This document describes version 1.0 with a value of 0xA.</t>
</list>
</t>
</section>

<section anchor="ALMMessageContents" title="ALMMessageContents Definition">

<figure>
<artwork align="left"><![CDATA[
struct {
   uint16       alm_message_code;
   opaque       alm_message_body;
} ALMMessageContents;
]]></artwork>
          </figure>

<t>The fields in ALMMessageContents are used as follows:</t>

<t><list>
<t>alm_message_code: This indicates the message being sent.  The message codes are listed in 
<xref target="MessageCodeIANA"></xref>.</t>

<t>alm_message_body: The message body itself, represented as a variable-length string of bytes. The
bytes themselves are dependent on the code value. See Sections <xref
target="Scribe" format="counter"></xref> and 
<xref target="P2PCast" format="counter"></xref>, which describe the various ALM
methods for the definitions of the payload contents.</t>
</list></t>
</section>

<section anchor="ResponseCodes" title="Response Codes">

<t>Response codes are defined in Section 6.3.3.1 of <xref
target="RELOAD"></xref>. This specification maps to RELOAD
ErrorResponse as follows:</t>

<t>ErrorResponse.error_code = Error_Exp_A;</t>

<t>Error_info contains an ALMErrorResponse instance.</t>

<figure>
<artwork align="left"><![CDATA[
public struct {
   uint16   alm_error_code;
   opaque   alm_error_info<0..2^16-1>;
} ALMErrorResponse;
]]></artwork>
          </figure>
 

<t>alm_error_code: The following error code values are defined.    
Numeric values for these are defined in <xref target="ErrorCodeIANA"/>.</t>

<t><list>
<t>Error_Unknown_Algorithm:  The multicast algorithm is not known or not supported.</t>
<t>Error_Child_Limit_Reached:    The maximum number of child nodes has been reached for this node.</t>
<t>Error_Node_Bandwidth_Reached:  The overall data bandwidth limit through this node has been reached.</t>
<t>Error_Node_Conn_Limit_Reached:  The total number of connections to this node has been reached.</t>
<t>Error_Link_Cap_Limit_Reached:  The capacity of a link has been reached.</t>
<t>Error_Node_Mem_Limit_Reached:    An internal memory capacity of the node has been reached.</t>
<t>Error_Node_CPU_Cap_Limit_Reached:  An internal processing capacity of the node has been reached.</t>
<t>Error_Path_Limit_Reached:  The maximum path length in hop count over the multicast tree has been reached.</t>
<t>Error_Path_Delay_Limit_Reached:  The maximum path length in message delay over the multicast tree has been reached.</t>
<t>Error_Tree_Fanout_Limit_Reached:  The maximum fanout of a multicast tree has been reached.</t>
<t>Error_Tree_Depth_Limit_Reached:  The maximum height of a multicast tree has been reached.</t>
<t>Error_Other:   A human-readable description is placed in the alm_error_info field.</t>
</list></t>
</section>

 </section>


    <section title="Examples" anchor="MessageFlows">
      <t>All peers in the examples are assumed to have completed bootstrapping.  "Pn" refers to peer N.  
        "group_id" refers to a peer responsible for storing the ALMTree instance with group_id.
      </t>
      <section title="Create Tree">

      <t>A node with "NODE-MATCH" rights sends a CreateALMTree request to the group_id node,
      which also has NODE-MATCH rights for its own address.
      The group_id node determines whether to create the new tree and, if so, performs a
      local StoreReq.  If the CreateALMTree succeeds, the ALMTree instance can be retrieved using Fetch. An example
      message flow for creating a tree is depicted in <xref target="CreateALMTreeExample"/>.</t>

        <figure align="center" anchor="CreateALMTreeExample" title="Message Flow Example for CreateALMTree">
          <artwork align="left"><![CDATA[
     P1      P2      P3       P4      group_id
     |       |       |        |       |
     |       |       |        |       |
     |       |       |        |       |
     | CreateALMTree |        |       |
     |------------------------------->|
     |       |       |        |       |
     |       |       |        |       | StoreReq
     |       |       |        |       |--+
     |       |       |        |       |  |
     |       |       |        |       |  |
     |       |       |        |       |<-+
     |       |       |        |       | StoreResponse
     |       |       |        |       |--+
     |       |       |        |       |  |
     |       |       |        |       |  |
     |       |       |        |       |<-+
     |       |       |        |       |
     |       |       |        |       |
     |       | CreateALMTreeResponse  |
     |<-------------------------------|
     |       |       |        |       |
     |       |       |        |       |
     | Fetch         |        |       |
     |------------------------------->|
     |       |       |        |       |
     |       |       |        |       |
     |       |         FetchResponse  |
     |<-------------------------------|
     |       |       |        |       |
]]></artwork>
        </figure>
      </section>


      <section title="Join Tree">
     <t>P1 joins node group_id as child node. P2 joins the tree as a child of P1.
     P4 joins the tree as a child of P1. The corresponding message flow is shown in <xref target="JoinTreeExample"/>.</t>

        <figure align="center" anchor="JoinTreeExample" title="Message Flow Example for Tree Join">
          <artwork align="left"><![CDATA[
     P1      P2      P3       P4      group_id
     |       |       |        |       |
     |       |       |        |       |
     | Join                           |
     |------------------------------->|
     |       |       |        |       |
     | JoinAccept                     |
     |<-------------------------------|
     |       |       |        |       |
     |       |       |        |       |
     |       |Join                    |
     |       |----------------------->|
     |       |       |        |       |
     |                            Join|
     |<-------------------------------|
     |       |       |        |       |
     |JoinAccept     |        |       |
     |------>|       |        |       |
     |       |       |        |       |
     |JoinConfirm    |        |       |
     |<------|       |        |       |
     |       |       |        |       |
     |       |       |        |Join   |
     |       |       |        |------>|
     |       |       |        |  Join |
     |<-------------------------------|
     |       |       |        |       |
     | Join  |       |        |       |
     |------>|       |        |       |
     |       |       |        |       |
     | JoinAccept    |        |       |
     |----------------------->|       |
     |       |       |        |       |
     |       | JoinAccept     |       |
     |       |--------------->|       |
     |       |       |        |       |
     |       |       |        |       |
     |       |   JoinConfirm  |       |
     |<-----------------------|       |
     |       |       |        |       |
     |       |   JoinDecline  |       |
     |       |<---------------|       |
     |       |       |        |       |
     |       |       |        |       |
]]></artwork>
        </figure>
      </section>

      <section title="Leave Tree">
      
      
        <figure align="center" anchor="LeaveTreeExample" title="Message Flow Example for Leave Tree">
          <artwork align="left"><![CDATA[
     P1      P2      P3       P4      group_id
     |       |       |        |       |
     |       |       |        |       |
     |       |       |  Leave |       |
     |<-----------------------|       |
     |       |       |        |       |
     | LeaveResponse |        |       |
     |----------------------->|       |
     |       |       |        |       |
     |       |       |        |       |
]]></artwork>
        </figure>
      </section>

       <section title="Push Data">

      <t>The multicast data is pushed recursively P1 => group_id => P1 => P2, P4
         following the tree topology created in the Join example above.
         An example 
         message flow is shown in <xref target="PushDataExample"/>.</t>

        <figure align="center" anchor="PushDataExample" title="Message Flow Example for Pushing Data">
          <artwork align="left"><![CDATA[
     P1      P2      P3       P4      group_id
     |       |       |        |       |
     | Push  |       |        |       |
     |------------------------------->|
     |       |       |        |       |
     |       |       |    PushResponse|
     |<-------------------------------|
     |       |       |        |       |
     |       |       |        |   Push|
     |<-------------------------------|
     |       |       |        |       |
     | PushResponse  |        |       |
     |------------------------------->|
     |       |       |        |       |
     |Push   |       |        |       |
     |------>|       |        |       |
     |       |       |        |       |
     |PushResponse   |        |       |
     |<------|       |        |       |
     |       |       |        |       |
     | Push  |       |        |       |
     |----------------------->|       |
     |       |       |        |       |
     |       |   PushResponse |       |
     |<-----------------------|       |
     |       |       |        |       |
     |       |       |        |       |
     |       |       |        |       |
            ]]></artwork>
        </figure>
      </section>

    </section>

    <section title="Kind Definitions">
       <section anchor="ALMTreeKind" title="ALMTree Kind Definition">
        <t>This section defines the ALMTree Kind per Section 7.4.5 of
<xref target="RELOAD"></xref>.  An instance of the ALMTree Kind is stored in
the overlay for each ALM tree instance. It is stored at the address
group_id.</t>
        <t>Kind-ID: 0xF0000001.  (This is a private-use code point per Section
14.6 of <xref target="RELOAD"></xref>.)  The Resource Name for the ALMTree Kind-ID is the session_key used to identify the ALM tree.</t>
        <t>Data Model: The data model is the ALMTree structure. </t>
        <t>Access Control: NODE-MATCH.  The node performing the store operation is required to have NODE-MATCH access. </t>
        <t>Meaning: The meaning of the fields is given in <xref target="CreateALMTree"></xref>.</t>
          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        node_id peer_id;
        opaque session_key<0..2^32-1>;
        node_id group_id;
        Dictionary options;
      } ALMTree;
]]></artwork>
          </figure>
      </section>
    </section>

    <section title="RELOAD Configuration File Extensions">
      <t>There are no ALM parameters defined for the RELOAD configuration file.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This section contains the new code points registered by this
document. 
      </t> 
      <section anchor="ALMAlgorithmTypesIANA" title="ALM Algorithm Types">
       <t>IANA has created the "SAM ALM Algorithm IDs" registry.
          Entries in this registry are 16-bit integers denoting Application-Layer Multicast algorithms
          as described in <xref target="ALMHeaderDef" /> of this document. 
          Code points in the range 0x0003 to 0x7FFF SHALL be registered via
RFC&nbsp;5226 <xref target="RFC5226" /> Expert Review.
          Code points in the range 0x8000 to 0xFFFF are reserved for private
use.
          The initial contents of this registry are:
       </t>
        <figure align="center" anchor="ALMAlgorithmTypes2" title="&quot;SAM ALM Algorithm IDs&quot; Registry Allocations">
          <artwork align="left"><![CDATA[
   +----------------+-------------------+-----------+
   | Algorithm Name | ALM Algorithm ID  | RFC       |
   +----------------+-------------------+-----------+
   | INVALID-ALG    |            0x0000 | RFC 7019  |
   | SCRIBE-SAM     |            0x0001 | RFC 7019  |
   | P2PCAST-SAM    |            0x0002 | RFC 7019  |
   | Reserved       |     0x8000-0xFFFF | RFC 7019  |
   +----------------+-------------------+-----------+
]]></artwork>
        </figure>

       <t>These values have been made available for the purposes of experimentation.
       These values are not meant for vendor-specific use of any sort and MUST NOT be used for operational deployments.
       </t>
      </section>

      <section anchor="MessageCodeIANA" title="Message Code Registration">
       <t>IANA has created the "SAM ALM Message Codes" registry.
        Entries in this registry are 16-bit integers denoting message codes as 
        described in <xref target="ALMMessageContents"/> of this document.
        Code points in the range 0x0014 to 0x7FFF SHALL be registered via
        RFC&nbsp;5226 <xref target="RFC5226" /> Expert Review.
        Code points in the range 0x8000 to 0xFFFF are reserved for private use.
        The initial contents of this registry are:
       </t>
        <figure align="center" anchor="MessageCodes3" title="&quot;SAM ALM
Message Codes&quot; Registry Allocations">
          <artwork align="left"><![CDATA[
   +-------------------------+----------------------+-----------+
   | Message Code Name       | Message Code Value   | RFC       |
   +-------------------------+----------------------+-----------+
   | InvalidMessageCode      |               0x0000 | RFC 7019  |
   | CreateALMTree           |               0x0001 | RFC 7019  |
   | CreateALMTreeResponse   |               0x0002 | RFC 7019  |
   | Join                    |               0x0003 | RFC 7019  |
   | JoinAccept              |               0x0004 | RFC 7019  |
   | JoinReject              |               0x0005 | RFC 7019  |
   | JoinConfirm             |               0x0006 | RFC 7019  |
   | JoinConfirmResponse     |               0x0007 | RFC 7019  |
   | JoinDecline             |               0x0008 | RFC 7019  |
   | JoinDeclineResponse     |               0x0009 | RFC 7019  |
   | Leave                   |               0x000A | RFC 7019  |
   | LeaveResponse           |               0x000B | RFC 7019  |
   | Reform                  |               0x000C | RFC 7019  |
   | ReformResponse          |               0x000D | RFC 7019  |
   | Heartbeat               |               0x000E | RFC 7019  |
   | HeartbeatResponse       |               0x000F | RFC 7019  |
   | NodeQuery               |               0x0010 | RFC 7019  |
   | NodeQueryResponse       |               0x0011 | RFC 7019  |
   | Push                    |               0x0012 | RFC 7019  |
   | PushResponse            |               0x0013 | RFC 7019  |
   | Reserved                |        0x8000-0xFFFF | RFC 7019  |
   +-------------------------+----------------------+-----------+
]]></artwork>
        </figure>
       <t>These values have been made available for the purposes of experimentation.
       These values are not meant for vendor-specific use of any sort and MUST NOT be used for operational deployments.
       </t>

      </section>

      <section anchor="ErrorCodeIANA" title="Error Code Registration">
       <t>IANA has created the "SAM ALM Error Codes" registry.
        Entries in this registry are 16-bit integers denoting error codes as 
        described in <xref target="ResponseCodes"/> of this document.
        Code points in the range 0x000D to 0x7FFF SHALL be registered via
        RFC&nbsp;5226 <xref target="RFC5226" /> Expert Review.
        Code points in the range 0x8000 to 0xFFFF are reserved for private use.
        The initial contents of this registry are:
       </t>
        <figure align="center" anchor="ErrMessageCodes2" title="&quot;SAM ALM Error Codes&quot; Registry Allocations">

          <artwork align="left"><![CDATA[
  +----------------------------------+---------------+-----------+
  | Error Code Name                  | Code Value    | RFC       |
  +----------------------------------+---------------+-----------+
  | InvalidErrorCode                 |       0x0000  | RFC 7019  |
  | Error_Unknown_Algorithm          |       0x0001  | RFC 7019  |
  | Error_Child_Limit_Reached        |       0x0002  | RFC 7019  |
  | Error_Node_Bandwidth_Reached     |       0x0003  | RFC 7019  |
  | Error_Node_Conn_Limit_Reached    |       0x0004  | RFC 7019  |
  | Error_Link_Cap_Limit_Reached     |       0x0005  | RFC 7019  |
  | Error_Node_Mem_Limit_Reached     |       0x0006  | RFC 7019  |
  | Error_Node_CPU_Cap_Limit_Reached |       0x0007  | RFC 7019  |
  | Error_Path_Limit_Reached         |       0x0008  | RFC 7019  |
  | Error_Path_Delay_Limit_Reached   |       0x0009  | RFC 7019  |
  | Error_Tree_Fanout_Limit_Reached  |       0x000A  | RFC 7019  |
  | Error_Tree_Depth_Limit_Reached   |       0x000B  | RFC 7019  |
  | Error_Other                      |       0x000C  | RFC 7019  |
  | Reserved                         | 0x8000-0xFFFF | RFC 7019  |
  +----------------------------------+---------------+-----------+
]]></artwork>
        </figure>
       <t>These values have been made available for the purposes of experimentation.
       These values are not meant for vendor-specific use of any sort and MUST NOT be used for operational deployments.
       </t>

      </section>


    </section>

    <section anchor="Security" title="Security Considerations">
      <t>Overlays are vulnerable to DoS and collusion attacks. We are not
      solving overlay security issues. We assume that the node authentication
model as defined in <xref target="RELOAD"></xref> will be used.</t>
      <t>Security issues specific to ALM Usage include the following: <list style="symbols">
          <t>The right to create group_id at some node_id </t>
          <t>The right to store Tree info at some location in the DHT </t>
          <t>A limit on number of messages per second and bandwidth use </t>
          <t>The right to join an ALM tree </t>
         </list></t>
    </section>
    <section title="Acknowledgements">
        <t>Marc Petit-Huguenin, Michael Welzl, Joerg Ott, and Lars Eggert provided important comments on earlier versions of this document.</t>
   </section>
  </middle>

  <back>

   <references title="Normative Reference">

      <?rfc include="reference.RFC.2119"?>


</references>

    <references title="Informative References">


      <?rfc include="reference.RFC.5226"?>

<!-- draft-ietf-p2psip-base  (AUTH48/RFC 6940)  -->

<reference anchor='RELOAD'>
<front>
<title>REsource LOcation And Discovery (RELOAD) Base Protocol</title>
<author initials='C' surname='Jennings' fullname='Cullen Jennings'>
    <organization />
</author>
<author initials='B' surname='Lowekamp' fullname='Bruce Lowekamp' role="editor">
    <organization />
</author>
<author initials='E' surname='Rescorla' fullname='Eric Rescorla'>
    <organization />
</author>
<author initials='S' surname='Baset' fullname='Salman Baset'>
    <organization />
</author>
<author initials='H' surname='Schulzrinne' fullname='Henning Schulzrinne'>
    <organization />
</author>
<date month='February' year='2013' />
</front>
<seriesInfo name='Work in' value='Progress' />
</reference>


<!--  draft-irtf-samrg-common-api  (I-D Exists/IESG Review) -->

<reference anchor='COMMON-API'>
<front>
<title>A Common API for Transparent Hybrid Multicast</title>
<author initials='M' surname='Waehlisch' fullname='Matthias Waehlisch'>
    <organization />
</author>
<author initials='T' surname='Schmidt' fullname='Thomas Schmidt'>
    <organization />
</author>
<author initials='S' surname='Venaas' fullname='Stig Venaas'>
    <organization />
</author>
<date month='April' year='2013' />
</front>
<seriesInfo name='Work in' value='Progress' />
</reference>


<!-- draft-muramoto-irtf-sam-generic-require  EXPIRED -->

<reference anchor='SAM-GENERIC'>
<front>
<title>Requirements for Scalable Adaptive Multicast Framework in Non-GIG Networks</title>
<author initials='E' surname='Muramoto' fullname='Eiichi Muramoto'>
    <organization />
</author>
<author initials='Y' surname='Imai' fullname='Yuji Imai'>
    <organization />
</author>
<author initials='N' surname='Kawaguchi' fullname='Nobuo Kawaguchi'>
    <organization />
</author>
<date month='November' year='2006' />
</front>
<seriesInfo name='Work in' value='Progress' />
</reference>


      <reference anchor="CASTRO2002"
                 target="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&amp;arnumber=1038579">
        <front>
          <title>SCRIBE: A large-scale and decentralized application-level multicast infrastructure</title>
          <author initials="M." surname="Castro"></author>
          <author initials="P." surname="Druschel"></author>
          <author initials="A.-M." surname="Kermarrec"></author>
          <author initials="A." surname="Rowstron"></author>
          <date month="October" year="2002" />
        </front>
        <seriesInfo name="IEEE Journal on Selected Areas in Communications,"
                    value="Vol. 20, No. 8" />
      </reference>

      <reference anchor="CASTRO2003"
                 target="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&amp;arnumber=1208986">
        <front>
          <title>An Evaluation of Scalable Application-level Multicast Built Using Peer-to-peer Overlays</title>
          <author initials="M." surname="Castro"></author>
          <author initials="M." surname="Jones"></author>
          <author initials="A.-M." surname="Kermarrec"></author>
          <author initials="A." surname="Rowstron"></author>
          <author initials="M." surname="Theimer"></author>
          <author initials="H." surname="Wang"></author>
          <author initials="A." surname="Wolman"></author>
          <date month="April" year="2003" />
        </front>
        <seriesInfo name="Proceedings of IEEE INFOCOM" value="2003" />
      </reference>

      <reference anchor="SPLITSTREAM"
                 target="http://dl.acm.org/citation.cfm?id=945474">
        <front>
          <title>SplitStream: High-Bandwidth Multicast in a Cooperative Environment</title>
          <author initials="M." surname="Castro"></author>
          <author initials="P." surname="Druschel"></author>
          <author initials="A." surname="Nandi"></author>
          <author initials="A.-M." surname="Kermarrec"></author>
          <author initials="A." surname="Rowstron"></author>
          <author initials="A." surname="Singh"></author>
          <date month="October" year="2003" />
        </front>
        <seriesInfo name="SOSP '03," value="Lake Bolton, New York"/>
      </reference>

      <reference anchor="P2PCAST" target="http://www.scs.stanford.edu/~reddy/research/p2pcast/report.pdf">
        <front>
          <title>P2PCast: A Peer-to-Peer Multicast Scheme for Streaming Data</title>
          <author initials="A." surname="Nicolosi" />
          <author initials="S." surname="Annapureddy" />
          <date month="May" year="2003" />
        </front>
        <seriesInfo name="Stanford Secure Computer Systems" value="Group Report" />
      </reference>

      <reference anchor="BUFORD2009" target="http://www.sciencedirect.com/science/book/9780123742148">
        <front>
          <title>P2P Networking and Applications (Chapter 9)</title>
          <author initials="J." surname="Buford"></author>
          <author initials="H." surname="Yu"></author>
          <author initials="E.K." surname="Lua"></author>
          <date year="2009" />
        </front>
        <seriesInfo name="Morgan" value="Kaufman" />
      </reference>

      <reference anchor="KOLBERG2010" target="http://link.springer.com/content/pdf/10.1007%2F978-0-387-09751-0_30.pdf">
        <front>
          <title>Employing Multicast in P2P Overlay Networks</title>
          <author initials="M." surname="Kolberg"></author>
          <date year="2010" />
        </front>
        <seriesInfo name="Handbook of" value="Peer-to-Peer Networking" />
      </reference>

      <reference anchor="BUFORD2008" target="http://www.tandfonline.com/doi/abs/10.1081/E-EWMC-120043583">
        <front>
          <title>P2P: Overlay Multicast</title>
          <author initials="J." surname="Buford"></author>
          <author initials="H." surname="Yu"></author>
          <date year="2008" />
        </front>
        <seriesInfo name="Encyclopedia of" value="Wireless and Mobile Communications" />
      </reference>
    </references>

  </back>
</rfc>
