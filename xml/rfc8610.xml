<?xml version="1.0" encoding="US-ASCII"?>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc comments="yes"?>

<rfc ipr="trust200902" number="8610" category="std" submissionType="IETF" consensus="yes">

  <front>
    <title abbrev="CDDL">Concise Data Definition Language (CDDL): A Notational
    Convention to&nbsp;Express Concise Binary Object Representation (CBOR) and&nbsp;JSON&nbsp;Data&nbsp;Structures</title>

    <author initials="H." surname="Birkholz" fullname="Henk Birkholz">
      <organization abbrev="Fraunhofer SIT">Fraunhofer SIT</organization>
      <address>
        <postal>
          <street>Rheinstrasse 75</street>
          <city>Darmstadt</city>
          <code>64295</code>
          <country>Germany</country>
        </postal>
        <email>henk.birkholz@sit.fraunhofer.de</email>
      </address>
    </author>
    <author initials="C." surname="Vigano" fullname="Christoph Vigano">
      <organization abbrev="Universitaet Bremen">Universitaet Bremen</organization>
      <address>
        <email>christoph.vigano@uni-bremen.de</email>
      </address>
    </author>
    <author initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Bibliothekstr. 1</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </author>

    <date year="2019" month="June"/>

<keyword>binary format, data interchange format, description language, schema
language, tree grammar</keyword>

    <abstract>

<t>This document proposes a notational convention to express
Concise Binary Object Representation (CBOR) data structures (RFC 7049).
Its main goal is to provide an easy and unambiguous way to express structures
for protocol messages and data formats that use CBOR or JSON.</t>

    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>In this document, a notational convention to express 
Concise Binary Object Representation (CBOR) data structures
<xref target="RFC7049"/> is defined.</t>

<t>The main goal for the convention is to provide a unified notation that can
be used when defining protocols that use CBOR.  We term the convention
"Concise Data Definition Language", or CDDL.</t>

<t>The CBOR notational convention has the following goals:</t>

<t><list style="format (G%d)">
  <t>Provide an unambiguous description of the overall structure of a CBOR data item.</t>
  <t>Be flexible in expressing the multiple ways in which data can be
represented in the CBOR data format.</t>
  <t>Be able to express common CBOR datatypes and structures.</t>
  <t>Provide a single format that is both readable and editable for
humans and processable by a machine.</t>
  <t>Enable automatic checking of CBOR data items for data format compliance.</t>
  <t>Enable extraction of specific elements from CBOR data for further processing.</t>
</list></t>

<t>Not an original goal per se, but a convenient side effect of the JSON
generic data model being a subset of the CBOR generic data model, is the fact
that CDDL can also be used for describing JSON data structures
(see <xref target="sec-json"/>).</t>

<t>This document has the following structure:</t>

<t>The syntax of CDDL is defined in <xref target="syntax"/>.
Examples of CDDL and a related CBOR data item ("instance"), some of which
use the JSON form, are described in <xref target="examples"/>.
<xref target="usage"/> discusses usage of CDDL.
Examples are provided throughout the text to better illustrate concept
definitions. A formal definition of CDDL using ABNF grammar <xref
target="RFC5234"/> is provided in <xref target="abnf"/>.
Finally, a _prelude_ of standard CDDL definitions that is
automatically prepended to, and thus available in, every
CDDL specification is listed in <xref target="prelude"/>.</t>

<section anchor="requirements-notation" title="Requirements Notation">

    <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
    "SHALL&nbsp;NOT", "SHOULD", "SHOULD&nbsp;NOT", "RECOMMENDED",
    "NOT&nbsp;RECOMMENDED", "MAY", and "OPTIONAL" in this document
    are to be interpreted as described in BCP&nbsp;14
    <xref target="RFC2119"/> <xref target="RFC8174"/> when,
    and only when, they appear in all capitals, as shown here.</t>

</section>
<section anchor="terminology" title="Terminology">

<t>New terms are introduced in _cursive_, which is rendered in plain text
as the new term surrounded by underscores.
CDDL text in the running text is in "typewriter", which is rendered in
plain text as the CDDL text in double quotes (double quotes are also
used in the usual English sense; the reader is expected to
disambiguate this by context).</t>

<t>In this specification, the term "byte" is used in its now-customary
sense as a synonym for "octet".</t>

</section>
</section>
<section anchor="the-style-of-data-structure-specification" title="The Style of Data Structure Specification">

<t>CDDL focuses on styles of specification that are in use in the
community employing the data model as pioneered by JSON and now
refined in CBOR.</t>

<t>There are a number of more or less atomic elements of a CBOR data
model, such as numbers, simple values (false, true, nil), text strings, and
byte strings; CDDL does not focus on specifying their structure.
CDDL of course also allows adding a CBOR tag to a data item.</t>

<t>Beyond those atomic elements, further components of a
data structure definition language
are the datatypes used for composition: arrays and maps in CBOR
(called "arrays" and "objects" in JSON).  While these are only two
representation formats, they are used to specify four loosely
distinguishable styles of composition:</t>

<t><list style="symbols">
  <t>A _vector_: an array of elements that are mostly of the same
semantics.  The set of signatures associated with a signed data item
is a typical application of a vector.</t>
  <t>A _record_: an array the elements of which have different,
positionally defined semantics, as detailed in the data structure
definition.  A 2D point, specified as an array of an x coordinate
(which comes first) and a y coordinate (coming second), is an example
of a record, as is the pair of exponent (first) and mantissa
(second) in a CBOR decimal fraction.</t>
  <t>A _table_: a map from a domain of map keys to a domain of map
values, that are mostly of the same semantics.  A set of language
tags, each mapped to a text string translated to that specific language,
is an example of a table.  The key domain is usually not limited to
a specific set by the specification but is open for the
application, e.g., in a table mapping IP addresses to Media Access Control
(MAC) addresses, the specification does not attempt to foresee all possible IP
addresses. In a language such as JavaScript, a "Map" (as opposed to a plain
"Object") would often be employed to achieve the generality of the
key domain.</t>
  <t>A _struct_: a map from a domain of map keys as defined by the
specification to a domain of map values the semantics of each of
which is bound to a specific map key.  This is what many people have
in mind when they think about JSON objects; CBOR adds the ability to
use map keys that are not just text strings.  Structs can be used to
solve problems similar to those records are used for; the use of explicit
map keys facilitates optionality and extensibility.</t>
</list></t>

<t>Two important concepts provide the foundation for CDDL:</t>

<t><list style="numbers">
  <t>Instead of defining all four types of composition in CDDL separately,
or even defining one kind for arrays (vectors and records) and one
kind for maps (tables and structs), there is only one kind of
composition in CDDL: the _group_ (<xref target="group"/>).</t>
  <t>The other important concept is that of a _type_.  The entire CDDL
specification defines a type (the one defined by its first _rule_),
which formally is the set of CBOR data items that are acceptable as
"instances" for
this specification.  CDDL predefines a number of basic types such as
"uint" (unsigned integer) or "tstr" (text string), often making use of
a simple formal notation for CBOR data items.  Each value that
can be expressed as a CBOR data item is also a type in its own right,
e.g., "1".  A type can be built as a _choice_ of other types, e.g., an
"int" is either a "uint" or a "nint" (negative integer).
Finally, a type can be built as an array or a map from a group.</t>
</list></t>

<t>The rest of this section introduces a number of basic concepts of
CDDL, and <xref target="syntax"/> defines additional syntax.
<xref target="matching"/> gives a concise summary of the semantics of CDDL.</t>

<section anchor="group" title="Groups and Composition in CDDL">

<t>CDDL groups are lists of group _entries_, each of which can be a
name/value pair or a more complex group expression (which then in turn
stands for a sequence of name/value pairs).  A CDDL group is a
production in a grammar that matches certain sequences of name/value pairs but not others.
The grammar is based on the concepts of Parsing Expression Grammars (PEGs)
(see <xref target="sec-peg"/>).</t>

<t>In an array context, only the value of the name/value pair is represented; the name is
annotation only (and can be left off from the group specification if not needed).
In a map context, the names become the map keys ("member keys").</t>

<t>In an array context, the actual sequence of elements in the group is
important, as that sequence is the information that allows associating actual
array elements with entries in the group.
In a map context, the sequence of entries in a group is not relevant
(but there is still a need to write down group entries in a sequence).</t>

<t>An array matches a specification given as a group when the group
matches a sequence of name/value pairs the value parts of which
exactly match the elements of the array in order.</t>

<t>A map matches a specification given as a group when the group
matches a sequence of name/value pairs such that all of these
name/value pairs are present in the map and the map has no name/value
pair that is not covered by the group.</t>

<t>A simple example of using a group directly in a map definition is:</t>

<figure title="Using a Group Directly in a Map" anchor="group-in-map"><artwork type="CDDL" align="center"><![CDATA[
person = {
  age: int,
  name: tstr,
  employer: tstr,
}
]]></artwork></figure>

<t>The three entries of the group are written between the curly braces
that create the map:
here, "age", "name", and "employer" are the names that turn into the
map key text strings, and "int" and "tstr" (text string) are the types
of the map values under these keys.</t>

<t>A group by itself (without creating a map around it) can be placed in
(round) parentheses and given a name by using it in a rule:</t>

<figure title="A Basic Group" anchor="basic-group"><artwork type="CDDLx" align="center"><![CDATA[
pii = (
  age: int,
  name: tstr,
  employer: tstr,
)
]]></artwork></figure>

<t>This separate, named group definition allows us to rephrase
<xref target="group-in-map"/>&nbsp;as:</t>

<figure title="Using a Group by Name" anchor="group-by-name"><artwork type="CDDLx" align="center"><![CDATA[
person = {
  pii
}
]]></artwork></figure>

<t>Note that the (curly) braces signify the creation of a map; the groups
themselves are neutral as to whether they will be used in a map or an array.</t>

<t>As shown in <xref target="group-in-map"/>, the parentheses for groups are optional
when there is some other set of brackets present.  Note that they can
still be used, leading to this not-so-realistic, but perfectly valid,
example:</t>

<figure title="Using a Parenthesized Group in a Map" anchor="paren-group-in-map"><artwork type="CDDL" align="center"><![CDATA[
person = {(
  age: int,
  name: tstr,
  employer: tstr,
)}
]]></artwork></figure>

<t>Groups can be used to factor out common parts of structs, e.g.,
instead of writing specifications in copy/paste style, such as in
<xref target="group_redundancy"/>, one can factor out the common subgroup, choose a
name for it, and write only the specific parts into the individual
maps (<xref target="group_factorization"/>).</t>

<figure title="Maps with Copy/Paste" anchor="group_redundancy"><artwork type="CDDL" align="center"><![CDATA[
person = {
  age: int,
  name: tstr,
  employer: tstr,
}

dog = {
  age: int,
  name: tstr,
  leash-length: float,
}
]]></artwork></figure>

<figure title="Using a Group for Factorization" anchor="group_factorization"><artwork type="CDDL" align="center"><![CDATA[
person = {
  identity,
  employer: tstr,
}

dog = {
  identity,
  leash-length: float,
}

identity = (
  age: int,
  name: tstr,
)
]]></artwork></figure>

<t>Note that the lists inside the braces in the above definitions
constitute (anonymous) groups, while "identity" is a named group,
which can then be included as part of other groups (anonymous as in
the example, or themselves named).</t>

<section anchor="composition_usage" title="Usage">

<t>Groups are the instrument used in composing data structures with
CDDL. It is a matter of style in defining those structures whether to
define groups (anonymously) right in their contexts or whether to
define them in a separate rule and to reference them with their
respective name (possibly more than once).</t>

<t>With this, one is allowed to define all small parts of their data structures
and compose bigger protocol data units with those or to have only one big
protocol data unit that has all definitions ad hoc where needed.</t>

</section>
<section anchor="composition_syntax" title="Syntax">

<t>The composition syntax is intended to be concise and easy to read:</t>

<t><list style="symbols">
  <t>The start and end of a group can be marked by "(" and ")".</t>
  <t>Definitions of entries inside of a group are noted as follows:
_keytype =&gt; valuetype,_ (read "keytype maps to valuetype").
The comma is actually optional (not just in the final entry), but it is
considered good style to set it.  The double arrow can be replaced by a colon
in the common case of directly using a text string or integer literal as a
key; see <xref target="structs"/>. This is also the common way of naming elements
of an array just for documentation; see <xref target="arrays"/>.</t>
</list></t>

<t>A basic entry consists of a _keytype_ and a _valuetype_, both of which
are types (<xref target="types"/>); this entry matches any name/value pair
the name of which is in the keytype and the value of which is in the valuetype.</t>

<t>A group defined as a sequence of group entries matches any
sequence of name/value pairs that is composed by concatenation in
order of what the entries match.</t>

<t>A group definition can also contain choices between groups;
see <xref target="choices"/>.</t>

</section>
</section>
<section anchor="types" title="Types">

<section anchor="values" title="Values">

<t>Values such as numbers and strings can be used in place of a type.
(For instance, this is a very common thing to do for a key type, common
enough that CDDL provides additional convenience syntax for this.)</t>

<t>The value notation is based on the C language, but does not offer all
the syntactic variations (see <xref target="abnf"/> for details).  The value notation for numbers
inherits from C the distinction between integer values (no fractional
part or exponent given -- NR1 <xref target="ISO6093"/>; "NR"&nbsp;stands for
"numerical representation") and floating-point values (where a fractional
part, an exponent, or both are present -- NR2 or NR3), so the type "1" does
not include any floating-point numbers while the types "1e3" and "1.5" are
both floating-point numbers and do not include any integer numbers.</t>

</section>
<section anchor="choices" title="Choices">

<t>Many places that allow a type also allow a choice between types,
delimited by a "/" (slash).  The entire choice construct can be put
into parentheses if this is required to make the construction
unambiguous (please see <xref target="abnf"/> for details of the
CDDL grammar).</t>

<t>Choices of values can be used to express enumerations:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
attire = "bow tie" / "necktie" / "Internet attire"
protocol = 6 / 17
]]></artwork></figure>

<t>Analogous to types, CDDL also allows choices between groups,
delimited by a "//" (double slash).  Note that the "//" operator
binds much more weakly than the other CDDL operators, so each line
within "delivery" in
the following example is its own alternative in the group choice:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
address = { delivery }

delivery = (
street: tstr, ? number: uint, city //
po-box: uint, city //
per-pickup: true )

city = (
name: tstr, zip-code: uint
)
]]></artwork></figure>

<t>A group choice matches the union of the sets of name/value pair
sequences that the alternatives in the choice can.</t>

<t>For both type choices and group choices, additional alternatives
can be added to a rule later in separate rules by using "/=" and "//=",
respectively, instead of "=":</t>

<figure><artwork align="center"><![CDATA[
attire /= "swimwear"

delivery //= (
lat: float, long: float, drone-type: tstr
)
]]></artwork></figure>

<t>It is not an error if a name is first used with a "/=" or "//="
(there is no need to "create it" with "=").</t>

<section anchor="ranges" title="Ranges">

<t>Instead of naming all the values that make up a choice, CDDL allows
building a _range_ out of two values that are in an ordering
relationship: a lower bound (first value) and an upper bound (second value).
A range can be inclusive of both bounds given (denoted by joining two
values by ".."), or it can include the lower bound and exclude the upper bound
(denoted by instead using "...").
If the lower bound exceeds the upper bound, the resulting type is
the empty set (this behavior can be desirable when generics
(<xref target="generics"/>) are being used).</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
device-address = byte
max-byte = 255
byte = 0..max-byte ; inclusive range
first-non-byte = 256
byte1 = 0...first-non-byte ; byte1 is equivalent to byte
]]></artwork></figure>

<t>CDDL currently only allows ranges between integers (matching integer
values) or between floating-point values (matching floating-point
values).  If both are needed in a type, a type choice between the two
kinds of ranges can be (clumsily) used:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
int-range = 0..10 ; only integers match
float-range = 0.0..10.0 ; only floats match
BAD-range1 = 0..10.0 ; NOT DEFINED
BAD-range2 = 0.0..10 ; NOT DEFINED
numeric-range = int-range / float-range
]]></artwork></figure>

<t>(See also the control operators .lt/.ge and .le/.gt in <xref target="fortran"/>.)</t>

<t>Note that the dot is a valid name continuation character in CDDL, so</t>

<t><list style='empty'>
  <t>min..max</t>
</list></t>

<t>is not a range expression but a single name.  When using a
name as the left&nbhy;hand side of a range operator, use spacing as in</t>

<t><list style='empty'>
  <t>min .. max</t>
</list></t>

<t>to separate off the range operator.</t>

</section>
<section anchor="turning-a-group-into-a-choice" title="Turning a Group into a Choice">

<t>Some choices are built out of large numbers of values, often integers,
each of which is best given a semantic name in the specification.
Instead of naming each of these integers and then accumulating them
into a choice, CDDL allows building a choice from a group by prefixing
it with an "&amp;" character:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
terminal-color = &basecolors
basecolors = (
  black: 0,  red: 1,  green: 2,  yellow: 3,
  blue: 4,  magenta: 5,  cyan: 6,  white: 7,
)
extended-color = &(
  basecolors,
  orange: 8,  pink: 9,  purple: 10,  brown: 11,
)
]]></artwork></figure>

<t>As with the use of groups in arrays (<xref target="arrays"/>), the member names have
only documentary value (in particular, they might be used by a tool
when displaying integers that are taken from that choice).</t>

</section>
</section>
<section anchor="representation-types" title="Representation Types">

<t>CDDL allows the specification of a data item type by referring to the
CBOR representation (specifically, to major types and additional information;
see Section&nbsp;2 of <xref target="RFC7049"/>).  How this is used
should be evident from the prelude (<xref target="prelude"/>): a hash mark
("#") optionally followed by a number from 0 to 7 identifying the major
type, which then can be followed by a dot and a number specifying the
additional information.  This construction specifies the set of values that can be
serialized in CBOR (i.e., "any"), by the given major type if one is
given, or by the given major type with the additional information if
both are given.  Where a major type of 6 (Tag) is used, the type of
the tagged item can be specified by appending it in parentheses.</t>

<t>Note that although this notation is based on the CBOR
serialization, it is about a set of values at the data model level,
e.g., "#7.25" specifies the set of values that can be represented as
half-precision floats; it does not mandate that these values also do
have to be serialized as half-precision floats: CDDL does not provide
any language means to restrict the choice of serialization variants.
This also enables the use of CDDL with JSON, which uses a
fundamentally different way of serializing (some of) the same values.</t>

<t>It may be necessary to make use of representation types outside the
prelude, e.g., a specification could start by making use of an
existing tag in a more specific way or could define a new tag not defined
in the prelude:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
my_breakfast = #6.55799(breakfast)   ; cbor-any is too general!
breakfast = cereal / porridge
cereal = #6.998(tstr)
porridge = #6.999([liquid, solid])
liquid = milk / water
milk = 0
water = 1
solid = tstr
]]></artwork></figure>

</section>
<section anchor="root-type" title="Root Type">

<t>There is no special syntax to identify the root of a CDDL data
structure definition: that role is simply taken by the first rule
defined in the file.</t>

<t>This is motivated by the usual top-down approach for defining data
structures, decomposing a big data structure unit into smaller parts;
however, except for the root type, there is no need to strictly follow
this sequence.</t>

<t>(Note that there is no way to use a group as a root -- it must be a
type.)</t>

</section>
</section>
</section>
<section anchor="syntax" title="Syntax">

<t>In this section, the overall syntax of CDDL is shown, alongside some
examples just illustrating syntax.
(The definition does not attempt to be overly formal; refer to
<xref target="abnf"/> for details.)</t>

<section anchor="general-conventions" title="General Conventions">

<t>The basic syntax is inspired by ABNF <xref target="RFC5234"/>, with
the following:</t>

<t><list style="symbols">
  <t>Rules, whether they define groups or types, are defined with a name,
followed by an equals sign "=" and the actual definition according
to the respective syntactic rules of that definition.</t>
  <t>A name can consist of any of the characters from the set
{"A" to "Z", "a" to "z", "0" to "9", "_", "-", "@", ".",
"$"}, starting with
an alphabetic character (including "@", "_", "$") and ending in
such a character or a digit.
  <list style="symbols">
      <t>Names are case sensitive.</t>
      <t>It is preferred style to start a name with a lowercase letter.</t>
      <t>The hyphen is preferred over the underscore (except in a
"bareword" (<xref target="structs"/>), where the semantics may actually require an underscore).</t>
      <t>The period may be useful for larger specifications, to express
some module structure (as in "tcp.throughput" vs. "udp.throughput").</t>
      <t>A number of names are predefined in the CDDL prelude, as listed in <xref target="prelude"/>.</t>
      <t>Rule names (types or groups) do not appear in the actual CBOR encoding, but
names used as "barewords" in member keys do.</t>
    </list></t>
  <t>Comments are started by a ";" (semicolon) character and finish at the end of a line
(LF or CRLF).</t>
  <t>Except within strings, whitespace (spaces, newlines, and comments) is used
to separate syntactic elements for readability (and to separate
identifiers, range operators, or numbers that follow each other); it is
otherwise completely optional.</t>
  <t>Hexadecimal numbers are preceded by "0x" (without quotes) and are
case insensitive.  Similarly, binary numbers are preceded by "0b".</t>
  <t>Text strings are enclosed by double quotation '"' characters.
They follow the conventions for strings as defined in Section&nbsp;7
of <xref target="RFC8259"/>.
(ABNF users may want to note that there is no support in CDDL for the
concept of case insensitivity in text strings; if necessary, regular
expressions can be used (<xref target="regexp"/>).)</t>
  <t>Byte strings are enclosed by single quotation "'" characters and may
be prefixed by "h" or "b64".  If unprefixed, the string is interpreted
as with a text string, except that single quotes must be escaped and
that the resulting UTF-8 bytes are marked as a byte string (major
type&nbsp;2).
If prefixed as "h" or "b64", the string is interpreted as a sequence
of pairs of hex digits (base16; see Section&nbsp;8 of
<xref target="RFC4648"/>) or a base64(url) string (Section&nbsp;4 or
Section&nbsp;5 of <xref target="RFC4648"/>), respectively (as with the
diagnostic notation in Section&nbsp;6 of <xref target="RFC7049"/>; cf. <xref
target="textbin"/>); any whitespace present within the string (including
comments) is ignored in the prefixed case.</t>

  <t>CDDL uses UTF-8 <xref target="RFC3629"/> for its encoding.  Processing of CDDL
does not involve Unicode normalization processes.</t>

</list></t>

<t>Example:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
; This is a comment
person = { g }

g = (
  "name": tstr,
  age: int,  ; "age" is a bareword
)
]]></artwork></figure>

</section>
<section anchor="occurrence" title="Occurrence">

<t>An optional _occurrence_ indicator can be given in front of a
group entry. It is either (1) one of the characters "?" (optional), "*"
(zero or more), or "+" (one or more) or (2) of the form n*m, where n and m
are optional unsigned integers and n is the lower limit (default 0)
and m is the upper limit (default no limit) of occurrences.</t>

<t>If no occurrence indicator is specified, the group entry is to occur exactly
once (as if 1*1 were specified).
A group entry with an occurrence indicator matches sequences of
name/value pairs that are composed by concatenating a number of sequences that the basic
group entry matches, where the number needs to be allowed by the
occurrence indicator.</t>

<t>Note that CDDL, outside any directives/annotations that could possibly
be defined, does not make any
prescription as to whether arrays or maps use definite-length or
indefinite-length encoding.  That is, there is no correlation between
leaving the size of an array "open" in the spec and the fact that it
is then interchanged with definite or indefinite length.</t>

<t>Please also note that CDDL can describe flexibility that the data
model of the target representation does not have.  This is rather
obvious for JSON but is also relevant for CBOR:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
apartment = {
  kitchen: size,
  * bedroom: size,
}
size = float ; in m2
]]></artwork></figure>

<t>The previous specification does not mean that CBOR is changed to allow
using the key "bedroom" more than once.  In other words, due to the
restrictions imposed by the data model, the third line pretty much turns
into:</t>

<figure><artwork type="CDDLx" align="center"><![CDATA[
? bedroom: size,
]]></artwork></figure>

<t>(Occurrence indicators beyond one are still useful in maps for groups
that allow a variety of keys.)</t>

</section>
<section anchor="predefined-names-for-types" title="Predefined Names for Types">

<t>CDDL predefines a number of names.
This subsection summarizes these names, but please see <xref target="prelude"/> for
the exact definitions.</t>

<t>The following keywords for primitive datatypes are defined:</t>

<t><list style="hanging">
  <t hangText='"bool"'>
  Boolean value (major type 7, additional information 20 or&nbsp;21).</t>
  <t hangText='"uint"'>
  An unsigned integer (major type 0).</t>
  <t hangText='"nint"'>
  A negative integer (major type 1).</t>
  <t hangText='"int"'>
  An unsigned integer or a negative integer.</t>
  <t hangText='"float16"'>
  A number representable as a half-precision float <xref target="IEEE754"/>
  (major type 7, additional information 25).</t>
  <t hangText='"float32"'>
  A number representable as a single-precision float <xref target="IEEE754"/>
  (major type 7, additional information 26).</t>
  <t hangText='"float64"'>
  A number representable as a double-precision float <xref target="IEEE754"/>
  (major type 7, additional information 27).</t>
  <t hangText='"float"'>
  One of float16, float32, or float64.</t>
  <t hangText='"bstr" or "bytes"'>
  A byte string (major type 2).</t>
  <t hangText='"tstr" or "text"'>
  Text string (major type 3).</t>
</list></t>

<t>(Note that there are no predefined names for arrays or maps; these are
defined with the syntax given below.)</t>

<t>In addition, a number of types are defined in the prelude that are
associated with CBOR tags, such as "tdate", "bigint", "regexp", etc.</t>

</section>
<section anchor="arrays" title="Arrays">

<t>Array definitions surround a group with square brackets.</t>

<t>For each entry, an occurrence indicator as specified in <xref target="occurrence"/> is permitted.</t>

<t>For example:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
unlimited-people = [* person]
one-or-two-people = [1*2 person]
at-least-two-people = [2* person]
person = (
    name: tstr,
    age: uint,
)
]]></artwork></figure>

<t>The group "person" is defined in such a way that repeating it in the
array each time generates alternating names and ages, so these are four valid
values for a data item of type "unlimited-people":</t>

<figure><artwork type="CBORdiag" align="center"><![CDATA[
["roundlet", 1047, "psychurgy", 2204, "extrarhythmical", 2231]
[]
["aluminize", 212, "climograph", 4124]
["penintime", 1513, "endocarditis", 4084, "impermeator", 1669,
 "coextension", 865]
]]></artwork></figure>

</section>
<section anchor="maps" title="Maps">

<t>The syntax for specifying maps merits special attention, as well as a
number of optimizations and conveniences, as it is likely to be the
focal point of many specifications employing CDDL.  While the syntax
does not strictly distinguish struct and table usage of maps, it
caters specifically to each of them.</t>

<t>But first, let's reiterate a feature of CBOR that it has inherited
from JSON: the key/value pairs in CBOR maps have no fixed ordering.
(One could imagine situations where fixing the ordering may be of use.
For example, a decoder could look for values related with integer keys
1, 3, and 7.  If the order were fixed and the decoder encounters the
key 4 without having encountered key 3, it could conclude that key 3
is not available without doing more complicated bookkeeping.
Unfortunately, neither JSON nor CBOR supports this, so no attempt was
made to support this in CDDL either.)</t>

<section anchor="structs" title="Structs">

<t>The "struct" usage of maps is similar to the way JSON objects are used
in many JSON applications.</t>

<t>A map is defined in the same way as that for defining an array (see <xref target="arrays"/>), except
for using curly braces "{}" instead of square brackets "[]".</t>

<t>An occurrence indicator as specified in <xref target="occurrence"/> is permitted for each
group entry.</t>

<t>The following is an example of a record with a structure embedded:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
Geography = [
  city           : tstr,
  gpsCoordinates : GpsCoordinates,
]

GpsCoordinates = {
  longitude      : uint,            ; degrees, scaled by 10^7
  latitude       : uint,            ; degrees, scaled by 10^7
}
]]></artwork></figure>

<t>When encoding, the Geography record is encoded using a CBOR array with
two members (the keys for the group entries are ignored), whereas the
GpsCoordinates structure is encoded as a CBOR map with two key/value
pairs.</t>

<t>Types used in a structure can be defined in separate rules or just in
place (potentially placed inside parentheses, such as for choices).
For example:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
located-samples = {
  sample-point: int,
  samples: [+ float],
}
]]></artwork></figure>

<t>where "located-samples" is the datatype to be used when referring to the struct,
and "sample-point" and "samples" are the keys to be used.
This is actually a complete example: an identifier that is followed by a
colon can be directly used as the text string for a member key (we speak of a
"bareword" member key), as can a double-quoted string or a number.
(When other types -- in particular, types that contain more than one value --
are used as the types of keys, they are followed by a double arrow; see
below.)</t>

<t>If a text string key does not match the syntax for an identifier (or
if the specifier just happens to prefer using double quotes), the text
string syntax can also be used in the member key position, followed by
a colon.  The above example could therefore have been written with
quoted strings in the member key positions.</t>

<t>More generally, types specified in ways other than those listed for the
cases described above can be used in a key-type position by following them with
a double arrow -- in particular, the double arrow is necessary if a type
is named by an identifier (which, when followed by a colon, would
be interpreted as a "bareword" and turned into a text string).
A literal text string also gives rise to a type (which contains a single
value only -- the given string), so another
form for this example is:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
located-samples = {
  "sample-point" => int,
  "samples" => [+ float],
}
]]></artwork></figure>

<t>See <xref target="cuts-in-maps"/> below for how the colon (":") shortcut
described here also adds some implied semantics.</t>

<t>A better way to demonstrate the use of the double arrow may be:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
located-samples = {
  sample-point: int,
  samples: [+ float],
  * equipment-type => equipment-tolerances,
}
equipment-type = [name: tstr, manufacturer: tstr]
equipment-tolerances = [+ [float, float]]
]]></artwork></figure>

<t>The example below defines a struct with optional entries: display name
(as a text string), the name components first name and family name (as
text strings), and age information (as an unsigned integer).</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
PersonalData = {
  ? displayName: tstr,
  NameComponents,
  ? age: uint,
}

NameComponents = (
  ? firstName: tstr,
  ? familyName: tstr,
)
]]></artwork></figure>

<t>Note that the group definition for NameComponents does not generate
another map; instead, all four keys are directly in the struct built
by PersonalData.</t>

<t>In this example, all key/value pairs are optional from the perspective of CDDL.
With no occurrence indicator, an entry is mandatory.</t>

<t>If the addition of more entries not specified by the current
specification is desired, one can add this possibility explicitly:</t>

<figure title="Personal Data: Example for Extensibility" anchor="xmp-personaldata"><artwork type="CDDL" align="center"><![CDATA[
PersonalData = {
  ? displayName: tstr,
  NameComponents,
  ? age: uint,
  * tstr => any
}

NameComponents = (
  ? firstName: tstr,
  ? familyName: tstr,
)
]]></artwork></figure>

<t>The CDDL tool described in <xref target="tool"/> generated the following
as one acceptable instance for this specification:</t>

<figure><artwork type="CBORdiag" align="center"><![CDATA[
{"familyName": "agust", "antiforeignism": "pretzel",
 "springbuck": "illuminatingly", "exuviae": "ephemeris",
 "kilometrage": "frogfish"}
]]></artwork></figure>

<t>(See <xref target="socketplug"/> for one way to explicitly identify an extension point.)</t>

</section>
<section anchor="tables" title="Tables">

<t>A table can be specified by defining a map with entries where the
key&nbsp;type allows more than just a single value; for example:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
square-roots = {* x => y}
x = int
y = float
]]></artwork></figure>

<t>Here, the key in each key/value pair has datatype x (defined as int),
and the value has datatype y (defined as float).</t>

<t>If the specification does not need to restrict one of x or y (i.e., the application is free to
choose per entry), it can be replaced by the predefined name "any".</t>

<t>As another example,
the following could be used as a conversion table converting from an integer
or float to a string:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
tostring = {* mynumber => tstr}
mynumber = int / float
]]></artwork></figure>

</section>
<section anchor="non-deterministic-order" title="Non-deterministic Order">

<t>While the way arrays are matched is fully determined by the PEG
formalism (see <xref target="sec-peg"/>), matching is more complicated for
maps, as maps do not have an inherent order.
For each candidate name/value pair that the PEG algorithm would try, a
matching member is picked out of the entire map.  For certain group expressions,
more than one member in the map may match.  Most often, this is
inconsequential, as the group expression tends to consume all matches:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
labeled-values = {
  ? fritz: number,
  * label => value
}
label = text
value = number
]]></artwork></figure>

<t>Here, if any member with the key "fritz" is present, this
will be picked by the first entry of the group; all remaining
text/number members will be picked by the second entry (and if anything
remains unpicked, the map does not match).</t>

<t>However, it is possible to construct group expressions where what is
actually picked is indeterminate, but does matter:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
do-not-do-this = {
  int => int,
  int => 6,
}
]]></artwork></figure>

<t>When this expression is matched against "{3: 5, 4: 6}", the first
group entry might pick off the "3: 5", leaving "4: 6" for matching the
second one.  Or it might pick off "4: 6", leaving nothing for the
second entry.  This pathological non-determinism is caused by
specifying "more general" before "more specific" and by having a general
rule that only consumes a subset of the map key/value pairs that it is able to
match -- both tend not to occur in real-world specifications of maps.  At the time
of writing, CDDL tools cannot detect such cases automatically, and for
the present version of the CDDL specification, the
specification writer is simply urged to not write pathologically
non-deterministic specifications.</t>

<t>(The astute reader will be reminded of what was called "ambiguous
content models" in the Standard Generalized Markup Language (SGML) and
"non&nbhy;deterministic content models" in XML.
That problem is related to the one described here, but the problem
here is specifically caused by the lack of order in maps, something
that the XML schema languages do not have to contend with.  Note that
RELAX&nbsp;NG's "interleave" pattern handles lack of order explicitly on the
specification side, while the instances in XML always have determinate
order.)</t>

</section>
<section anchor="cuts-in-maps" title="Cuts in Maps">

<t>The extensibility idiom discussed above for structs has one problem:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
extensible-map-example = {
  ? "optional-key" => int,
  * tstr => any
}
]]></artwork></figure>

<t>In this example, there is one optional key "optional-key", which, when
present, maps to an integer.  There is also a wildcard for any future
additions.</t>

<t>Unfortunately, the data item</t>

<figure><artwork type="CBORdiag" align="center"><![CDATA[
{ "optional-key": "nonsense" }
]]></artwork></figure>

<t>does match this specification: while the first entry of the group
does not match, the second one (the wildcard) does.  This may very
well be desirable (e.g., if a future extension is to be allowed to extend
the type of "optional-key"), but in many cases it isn't.</t>

<t>In anticipation of a more general potential feature called "cuts",
CDDL allows inserting a cut "^" into the definition of the map entry:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
extensible-map-example = {
  ? "optional-key" ^ => int,
  * tstr => any
}
]]></artwork></figure>

<t>A cut in this position means that once the member key matches the name
part of an entry that carries a cut,
other potential matches for the key of the member that occur in
later entries in the group of the map are no longer allowed.
In other words, when a group entry would pick a key/value pair based
on just a matching key, it "locks in" the pick -- this rule applies,
independently of whether the value matches as well, so when it does not,
the entire map fails to match.
In summary, the
example above no longer matches the specification as modified with the cut.</t>

<t>Since the desire for this kind of exclusive matching is so frequent,
the ":" shortcut is actually defined to include the cut semantics.  So,
the preceding example (including the cut) can be written more simply
as:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
extensible-map-example = {
  ? "optional-key": int,
  * tstr => any
}
]]></artwork></figure>

<t>or even shorter, using a bareword for the key:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
extensible-map-example = {
  ? optional-key: int,
  * tstr => any
}
]]></artwork></figure>

</section>
</section>
<section anchor="tagsec" title="Tags">

<t>A type can make use of a CBOR tag (major type 6) by using the
representation type notation, giving #6.nnn(type) where nnn is an
unsigned integer giving the tag number and "type" is the type of the
data item being tagged.</t>

<t>For example, the following line from the CDDL prelude (<xref target="prelude"/>) defines "biguint" as
a type name for an unsigned bignum N:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
biguint = #6.2(bstr)
]]></artwork></figure>

<t>The tags defined by <xref target="RFC7049"/> are included in the prelude.
Additional tags registered since <xref target="RFC7049"/> was written need to
be added to a CDDL specification as needed; e.g., a binary Universally Unique
Identifier (UUID) tag could be referenced as "buuid" in a specification after
defining</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
buuid = #6.37(bstr)
]]></artwork></figure>

<t>In the following example, usage of tag 32 for URIs is optional:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
my_uri = #6.32(tstr) / tstr
]]></artwork></figure>

</section>
<section anchor="unwrapping" title="Unwrapping">

<t>The group that is used to define a map or an array can often be reused
in the definition of another map or array.  Similarly, a type defined
as a tag carries an internal data item that one would like to refer
to.
In these cases, it is expedient to simply use the name of the map,
array, or tag type as a handle for the group or type defined inside it.</t>

<t>The "unwrap" operator (written by preceding a name by a tilde
character "~") can be used to strip the type defined for a name by one
layer, exposing the underlying group (for maps and arrays) or type
(for tags).</t>

<t>For example, an application might want to define a basic header and an
advanced header.  Without unwrapping, this might be done as follows:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
basic-header-group = (
  field1: int,
  field2: text,
)

basic-header = [ basic-header-group ]

advanced-header = [
  basic-header-group,
  field3: bytes,
  field4: number, ; as in the tagged type "time"
]
]]></artwork></figure>

<t>Unwrapping simplifies this to:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
basic-header = [
  field1: int,
  field2: text,
]

advanced-header = [
  ~basic-header,
  field3: bytes,
  field4: ~time,
]
]]></artwork></figure>

<t>(Note that leaving out the first unwrap operator in the latter example
would lead to nesting the basic-header in its own array inside the
advanced-header, while, with the unwrapped basic-header, the
definition of the group inside basic-header is essentially repeated
inside advanced-header, leading to a single array.  This can be used for
various applications often solved by inheritance in programming
languages.  The effect of unwrapping can also be described as
"threading in" the group or type inside the referenced type, which
suggested the thread-like "~" character.)</t>

</section>
<section anchor="controls" title="Controls">

<t>A _control_ allows relating a _target_ type with a _controller_ type
via a _control operator_.</t>

<t>The syntax for a control type is "target .control-operator controller",
where control operators are special identifiers prefixed by a dot.
(Note that _target_ or _controller_ might need to be parenthesized.)</t>

<t>A number of control operators are defined at this point.
Further control operators may be defined by new
versions of this specification or by registering them according to the
procedures in <xref target="sec-controlreg"/>.</t>

<section anchor="control-operator-size" title="Control Operator .size">

<t>A ".size" control controls the size of the target in bytes by the
control type.  The control is defined for text and byte strings, where
it directly controls the number of bytes in the string.  It is also
defined for unsigned integers (see below).
<xref target="control-size"/> shows example usage for byte strings.</t>

<figure title="Control for Size in Bytes" anchor="control-size"><artwork type="CDDL" align="center"><![CDATA[
full-address = [[+ label], ip4, ip6]
ip4 = bstr .size 4
ip6 = bstr .size 16
label = bstr .size (1..63)
]]></artwork></figure>

<t>When applied to an unsigned integer, the ".size" control restricts
the range of that integer by giving a maximum number of bytes that
should be needed in a computer representation of that unsigned integer.
In other words, "uint .size N" is equivalent to "0...BYTES_N", where
BYTES_N == 256**N.</t>

<figure title="Control for Integer Size in Bytes" anchor="control-int-size"><artwork type="CDDL" align="center"><![CDATA[
audio_sample = uint .size 3 ; 24-bit, equivalent to 0...16777216
]]></artwork></figure>

<t>Note that, as with value restrictions in CDDL, this control is not
a representation constraint; a number that fits into fewer bytes can
still be represented in that form, and an inefficient implementation
could use a longer form (unless that is restricted by some format
constraints outside of CDDL, such as the rules in Section&nbsp;3.9 of
<xref target="RFC7049"/>).</t>

</section>
<section anchor="control-operator-bits" title="Control Operator .bits">

<t>A ".bits" control on a byte string indicates that, in the
target, only the bits numbered by a number in the control type are
allowed to be set.  (Bits are counted the usual way, bit number "n"
being set in "str" meaning that "(str[n &gt;&gt; 3] &amp; (1 &lt;&lt; (n &amp; 7))) != 0".)
Similarly, a ".bits" control on an unsigned integer "i" indicates
that for all unsigned integers "n" where "(i &amp; (1 &lt;&lt; n)) != 0", "n"
must be in the control type.</t>

<figure title="Control for What Bits Can Be Set" anchor="control-bits"><artwork type="CDDL" align="center"><![CDATA[
tcpflagbytes = bstr .bits flags
flags = &(
  fin: 8,
  syn: 9,
  rst: 10,
  psh: 11,
  ack: 12,
  urg: 13,
  ece: 14,
  cwr: 15,
  ns: 0,
) / (4..7) ; data offset bits

rwxbits = uint .bits rwx
rwx = &(r: 2, w: 1, x: 0)
]]></artwork></figure>

<t>The CDDL tool described in <xref target="tool"/> generates the following ten example instances for "tcpflagbytes":</t>

<figure><artwork type="CBORdiags" align="center"><![CDATA[
h'906d' h'01fc' h'8145' h'01b7' h'013d' h'409f' h'018e' h'c05f'
h'01fa' h'01fe'
]]></artwork></figure>

<t>These examples do not illustrate that the above CDDL specification
does not explicitly specify a size of two bytes: a valid all-clear
instance of flag bytes could be "h''" or "h'00'" or even "h'000000'"
as well.</t>

</section>
<section anchor="regexp" title="Control Operator .regexp">

<t>A ".regexp" control indicates that the text string given as a target
needs to match the XML Schema Definition (XSD) regular expression given as a
value in the control type.
XSD regular expressions are defined in Appendix&nbsp;F of
<xref target="W3C.REC-xmlschema-2-20041028"/>.</t>

<figure title="Control with an XSD regexp" anchor="control-regexp"><artwork type="CDDL" align="center"><![CDATA[
nai = tstr .regexp "[A-Za-z0-9]+@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)+"
]]></artwork></figure>

<t>An example matching this regular expression:</t>

<figure><artwork type="CBORdiag" align="center"><![CDATA[
"N1@CH57HF.4Znqe0.dYJRN.igjf"
]]></artwork></figure>

<section anchor="usage-considerations" title="Usage Considerations">

<t>Note that XSD regular expressions do not support the usual \x or \u
escapes for hexadecimal expression of bytes or Unicode code points.
However, in CDDL the XSD regular expressions are contained in text
strings, the literal notation for which provides \u escapes; this should
suffice for most applications that use regular expressions for text
strings.
(Note that this also means that there is one level of string escaping
before the XSD escaping rules are applied.)</t>

<t>XSD regular expressions support character class subtraction, a feature
often not found in regular expression libraries; specification writers
may want to use this feature sparingly.
Similar considerations apply to Unicode character classes; where these
are used, the specification that employs CDDL SHOULD identify which
Unicode versions are addressed.</t>

<t>Other surprises for infrequent users of XSD regular expressions may
include the following:</t>

<t><list style="symbols">
  <t>No direct support for case insensitivity.  While case insensitivity
has gone mostly out of fashion in protocol design, it is sometimes
needed and then needs to be expressed manually as in
"[Cc][Aa][Ss][Ee]".</t>
  <t>The support for popular character classes such as \w and \d is based
on Unicode character properties; this is often not what is desired
in an ASCII-based protocol and thus might lead to surprises.  (\s
and \S do have their more conventional meanings, and "." matches any
character but the line-ending characters \r or&nbsp;\n.)</t>
</list></t>

</section>
<section anchor="discussion" title="Discussion">

<t>There are many flavors of regular expression in use in the programming
community.
For instance, Perl-Compatible Regular Expressions (PCREs) are widely
used and probably are more useful than XSD regular expressions.
However, there is no normative reference for PCREs that could be used
in the present document.
Instead, we opt for XSD regular expressions for now.
There is precedent for that choice in the IETF, e.g., in YANG <xref target="RFC7950"/>.</t>

<t>Note that CDDL uses controls as its main extension point.
This creates the opportunity to add further regular expression formats
in addition to the one referenced here, if desired.
As an example, a proposal for a ".pcre" control is defined in <xref
target="CDDL-Freezer"/>.</t>

</section>
</section>
<section anchor="control-operators-cbor-and-cborseq" title="Control Operators .cbor and .cborseq">

<t>A ".cbor" control on a byte string indicates that
the byte string carries a CBOR&nbhy;encoded data item.  Decoded, the
data item matches the type given as the right&nbhy;hand&nbhy;side argument
(type1 in the following example).</t>

<t><list style='empty'>
  <t>"bytes .cbor type1"</t>
</list></t>

<t>Similarly, a ".cborseq" control on a byte string indicates that
the byte string carries a sequence of CBOR&nbhy;encoded data items.
When the data items are taken as an array, the array matches the type
given as the right&nbhy;hand&nbhy;side argument (type2 in the following example).</t>

<t><list style='empty'>
  <t>"bytes .cborseq type2"</t>
</list></t>

<t>(The conversion of the encoded sequence to an array can be effected,
for instance, by wrapping the byte string between the two bytes 0x9f
and 0xff and decoding the wrapped byte string as a CBOR&nbhy;encoded data
item.)</t>

</section>
<section anchor="control-operators-within-and-and" title="Control Operators .within and .and">

<t>A ".and" control on a type indicates that the data item matches
both the left&nbhy;hand&nbhy;side type and the type given as the
right&nbhy;hand side. (Formally, the resulting type is the intersection of the
two types given.)</t>

<t><list style='empty'>
  <t>"type1 .and type2"</t>
</list></t>

<t>A variant of the ".and" control is the ".within" control, which
expresses an additional intent: the left&nbhy;hand&nbhy;side type is meant to
be a subset of the right&nbhy;hand&nbhy;side type.</t>

<t><list style='empty'>
  <t>"type1 .within type2"</t>
</list></t>

<t>While both forms have the identical formal semantics (intersection),
the intention of the ".within" form is that the right&nbhy;hand side gives
guidance to the types allowed on the left&nbhy;hand side, which typically
is a socket (<xref target="socketplug"/>):</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
message = $message .within message-structure
message-structure = [message_type, *message_option]
message_type = 0..255
message_option = any

$message /= [3, dough: text, topping: [* text]]
$message /= [4, noodles: text, sauce: text, parmesan: bool]
]]></artwork></figure>

<t>For ".within", a tool might flag an error if type1 allows data items
that are not allowed by type2.  In contrast, for ".and", there is no
expectation that type1 is already a subset of type2.</t>

</section>
<section anchor="fortran" title="Control Operators .lt, .le, .gt, .ge, .eq, .ne, and .default">

<t>The controls .lt, .le, .gt, .ge, .eq, and .ne specify a constraint
on&nbsp;the left&nbhy;hand&nbhy;side type to be a value less than, less than
or equal to, greater than, greater than or equal to, equal to, or not equal to
a value given as a right&nbhy;hand&nbhy;side type (containing just that single
value). In the present specification, the first four controls (.lt, .le,
.gt, and .ge) are defined only for numeric types, as these have a natural
ordering relationship.</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
speed = number .ge 0  ; unit: m/s
]]></artwork></figure>

<t>.ne and .eq are defined for both numeric values and values of other types.
If one of the values is not of a numeric type, equality is determined as
follows: text strings are equal (satisfy .eq / do not satisfy .ne) if
they are bytewise identical; the same applies for byte strings.
Arrays are equal if they have the same number
of elements, all of which are equal pairwise in order between the arrays.
Maps are equal if they have the same number of key/value pairs, and there
is pairwise equality between the key/value pairs between the two maps.
Tagged values are equal if they both have the same tag and the values
are equal.
Values of simple types match if they are the same values.
Numeric types that occur within arrays, maps, or tagged values are
equal if their numeric value is equal and they are both integers or
both floating-point values.
All other cases are not equal (e.g., comparing a text string with a
byte string).</t>

<t>A variant of the ".ne" control is the ".default" control, which
expresses an additional intent: the value specified by the
right&nbhy;hand&nbhy;side type is intended as a default value for the
left&nbhy;hand&nbhy;side type given, and the implied .ne control is there to
prevent this value from being sent over the wire.
This control is only meaningful when the control type is used in
an optional context; otherwise, there would be no way to make use of
the default value.</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
timer = {
  time: uint,
  ? displayed-step: (number .gt 0) .default 1
}
]]></artwork></figure>

</section>
</section>
<section anchor="socketplug" title="Socket/Plug">

<t>For both type choices and group choices, a mechanism is defined that
facilitates starting out with empty choices and assembling them later,
potentially in separate files that are concatenated to build the full
specification.</t>

<t>Per convention, CDDL extension points are marked with a leading dollar
sign (types) or two leading dollar signs (groups).  Tools honor that
convention by not raising an error if such a type or group is not
defined at all; the symbol is then taken to be an empty type choice
(group choice), i.e., no choice is available.</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
tcp-header = {seq: uint, ack: uint, * $$tcp-option}

; later, in a different file

$$tcp-option //= (
sack: [+(left: uint, right: uint)]
)

; and, maybe in another file

$$tcp-option //= (
sack-permitted: true
)
]]></artwork></figure>

<t>Names that start with a single "$" are "type sockets",
starting out as an empty type, and intended to be extended via "/=".
Names that start with a double "$$" are "group sockets", starting out
as an empty group choice, and intended to be extended via "//=".
In either case, it is not an error if there is no
definition for a socket at all; this then means there is no way to
satisfy the rule (i.e., the choice is empty).</t>

<t>As a convention, all definitions (plugs) for socket names must be augmentations, i.e., they
must be using "/=" and "//=", respectively.</t>

<t>To pick up the example illustrated in <xref target="xmp-personaldata"/>, the
socket/plug mechanism could be used as shown in
<xref target="xmp-personaldata-sp"/>:</t>

<figure title="Personal Data Example: Using Socket/Plug Extensibility" anchor="xmp-personaldata-sp"><artwork type="CDDL" align="center"><![CDATA[
PersonalData = {
  ? displayName: tstr,
  NameComponents,
  ? age: uint,
  * $$personaldata-extensions
}

NameComponents = (
  ? firstName: tstr,
  ? familyName: tstr,
)

; The above already works as is.
; But then, we can add later:

$$personaldata-extensions //= (
  favorite-salsa: tstr,
)

; and again, somewhere else:

$$personaldata-extensions //= (
  shoesize: uint,
)
]]></artwork></figure>

</section>
<section anchor="generics" title="Generics">

<t>Using angle brackets, the left&nbhy;hand side of a rule can add formal
parameters after the name being defined, as in:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
messages = message<"reboot", "now"> / message<"sleep", 1..100>
message<t, v> = {type: t, value: v}
]]></artwork></figure>

<t>When using a generic rule, the formal parameters are bound to the
actual arguments supplied (also using angle brackets), within the
scope of the generic rule (as if there were a rule of the form
parameter = argument).</t>

<t>Generic rules can be used for establishing names for both types and
groups.</t>

<t>(At this time, there are some limitations to the nesting of generics
in the CDDL tool described in <xref target="tool"/>.)</t>

</section>
<section anchor="operator-precedence" title="Operator Precedence">

<t>As with any language that has multiple syntactic features such as
prefix and infix operators, CDDL has operators that bind more tightly
than others.  This is becoming more complicated than, say, in ABNF, as
CDDL has both types and groups, with operators that are specific to
these concepts.  Type operators (such as "/" for type choice) operate on
types, while group operators (such as "//" for group choice) operate
on groups.  Types can simply be used in groups, but groups need to be
bracketed (as arrays or maps) to become types.  So, type operators
naturally bind closer than group operators.</t>

<t>For instance, in</t>

<figure><artwork><![CDATA[
   t = [group1]
   group1 = (a / b // c / d)
   a = 1 b = 2 c = 3 d = 4
]]></artwork></figure>

<t>group1 is a group choice between the type choice of a and b and the
type choice of c and d.  This becomes more relevant once member keys
and/or occurrences are added in:</t>

<figure><artwork><![CDATA[
   t = {group2}
   group2 = (? ab: a / b // cd: c / d)
   a = 1 b = 2 c = 3 d = 4
]]></artwork></figure>

<t>is a group choice between the optional member "ab" of type a or b and
the member "cd" of type c or d.  Note that the optionality is attached
to the first choice ("ab"), not to the second choice.</t>

<t>Similarly, in</t>

<figure><artwork><![CDATA[
   t = [group3]
   group3 = (+ a / b / c)
   a = 1 b = 2 c = 3
]]></artwork></figure>

<t>group3 is a repetition of a type choice between a, b, and c; if just
a is to be repeatable, a group choice is needed to focus the occurrence:</t>

<figure><artwork><![CDATA[
   t = [group4]
   group4 = (+ a // b / c)
   a = 1 b = 2 c = 3
]]></artwork></figure>

<t>group4 is a group choice between a repeatable a and a single b or c.</t>

<t>A comment has been that the semantics of group3 could be counterintuitive.
In general, as with many other languages with operator precedence rules,
the specification writer is encouraged not to rely on them, but to insert
parentheses liberally to guide readers that are not familiar with CDDL
precedence rules:</t>

<figure><artwork><![CDATA[
   t = [group4a]
   group4a = ((+ a) // (b / c))
   a = 1 b = 2 c = 3
]]></artwork></figure>

<t>The operator precedences, in sequence of loose to tight binding, are
defined in <xref target="abnf"/> and summarized in <xref target="prec"/>.  (Arities given are 1
for unary prefix operators and 2 for binary infix operators.)</t>

<texttable title="Summary of Operator Precedences" anchor="prec">
      <ttcol align='center'>Operator</ttcol>
      <ttcol align='center'>Arity</ttcol>
      <ttcol align='left'>Operates on</ttcol>
      <ttcol align='center'>Precedence</ttcol>
      <c>=</c>
      <c>2</c>
      <c>name = type, name = group</c>
      <c>1</c>
      <c>/=</c>
      <c>2</c>
      <c>name /= type</c>
      <c>1</c>
      <c>//=</c>
      <c>2</c>
      <c>name //= group</c>
      <c>1</c>
      <c>//</c>
      <c>2</c>
      <c>group // group</c>
      <c>2</c>
      <c>,</c>
      <c>2</c>
      <c>group, group</c>
      <c>3</c>
      <c>*</c>
      <c>1</c>
      <c>* group</c>
      <c>4</c>
      <c>n*m</c>
      <c>1</c>
      <c>n*m group</c>
      <c>4</c>
      <c>+</c>
      <c>1</c>
      <c>+ group</c>
      <c>4</c>
      <c>?</c>
      <c>1</c>
      <c>? group</c>
      <c>4</c>
      <c>=&gt;</c>
      <c>2</c>
      <c>type =&gt; type</c>
      <c>5</c>
      <c>:</c>
      <c>2</c>
      <c>name: type</c>
      <c>5</c>
      <c>/</c>
      <c>2</c>
      <c>type / type</c>
      <c>6</c>
      <c>..</c>
      <c>2</c>
      <c>type..type</c>
      <c>7</c>
      <c>...</c>
      <c>2</c>
      <c>type...type</c>
      <c>7</c>
      <c>.ctrl</c>
      <c>2</c>
      <c>type .ctrl type</c>
      <c>7</c>
      <c>&amp;</c>
      <c>1</c>
      <c>&amp;group</c>
      <c>8</c>
      <c>~</c>
      <c>1</c>
      <c>~type</c>
      <c>8</c>
</texttable>

</section>
</section>
<section anchor="usage" title="Making Use of CDDL">

<t>In this section, we discuss several potential ways to employ CDDL.</t>

<section anchor="as-a-guide-to-a-human-user" title="As a Guide for a Human User">

<t>CDDL can be used to efficiently define the layout of CBOR data,
such that a human implementer can easily see how data is supposed to be encoded.</t>

<t>Since CDDL maps parts of the CBOR data to human-readable names,
tools could be built that use CDDL to provide a human-friendly representation
of the CBOR data and allow them to edit such data while remaining compliant
with its CDDL definition.</t>

</section>
<section anchor="for-automated-checking-of-cbor-data-structure" title="For Automated Checking of CBOR Data Structures">

<t>CDDL has been specified such that a machine can handle the CDDL definition
and related CBOR data (and, thus, also JSON data).
For example, a machine could use CDDL to check whether or not CBOR data is
compliant with its definition.</t>

<t>The need for thoroughness of such compliance checking depends on the
application. For example, an application may decide not to check the data
structure at all and use the CDDL definition solely as a means to indicate the
structure of the data to the programmer.</t>

<t>On the other hand, the application may also implement a checking mechanism
that goes as far as checking that all mandatory map members are available.</t>

<t>The matter of how far the data description must be enforced by an
application is left to the designers and implementers of that application,
keeping in mind related security considerations.</t>

<t>In no case is it intended that a CDDL tool would be "writing code" for
an implementation.</t>

</section>
<section anchor="for-data-analysis-tools" title="For Data Analysis Tools">

<t>In the long run,
it can be expected that more and more data will be stored using the CBOR
data format.</t>

<t>Where there is data, there is data analysis and the need to process such
data automatically.
CDDL can be used for such automated data processing,
allowing tools to verify data, clean it,
and extract particular parts of interest from it.</t>

<t>Since CBOR is designed with constrained devices in mind,
a likely use of it would be small sensors.
An interesting use would thus be automated analysis of sensor data.</t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">

<t>This document presents a content rules language for expressing CBOR data
structures.
As such,
it does not bring any security issues on itself,
although specifications of protocols that use CBOR naturally need security
analyses when defined. General guidelines for writing security considerations
are defined in <xref target="RFC3552"/> (BCP 72). Specifications using CDDL to
define CBOR structures in protocols need to follow those guidelines.
Additional topics that could be considered in a security
considerations section for a specification that uses CDDL to define
CBOR structures include the following:</t>

<t><list style="symbols">
  <t>Where could the language maybe cause confusion in a way that will
enable security issues?</t>
  <t>Where a CDDL matcher is part of the implementation of a system, the
security of the system ought not depend on the correctness of the
CDDL specification or CDDL implementation without any further
defenses in place.</t>
  <t>Where the CDDL specification includes extension points, the impact of
  extensions on the security of the system needs to be carefully considered.</t>
</list></t>

<t>Writers of CDDL specifications are strongly encouraged to value
clarity and transparency of the specification over its elegance.
Keep it as simple as possible while still expressing the needed
data model.</t>

<t>A related observation about formal description techniques in general
that is strongly recommended to be kept in mind by writers of CDDL
specifications: just because CDDL makes it easier to handle complexity
in a specification, that does not make that complexity somehow less
bad (except maybe on the level of the humans having to grasp the
complex structure while reading the spec).</t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<section anchor="sec-controlreg" title="CDDL Control Operators Registry">

<t>IANA has created a registry for control operators
(<xref target="controls"/>).  The "CDDL Control
Operators" registry has been created within the "Concise Data Definition
Language (CDDL)" registry.</t>

<t>Each entry in the subregistry must include the name of the control
operator (by convention given with the leading dot) and a reference to
its documentation.  Names must be composed of the leading dot followed
by a text string conforming to the production "id" in <xref target="abnf"/>.</t>

<t>Initial entries in this registry are as follows:</t>

<texttable>
      <ttcol align='left'>Name</ttcol>
      <ttcol align='left'>Documentation</ttcol>
      <c>.size</c>
      <c>RFC 8610</c>
      <c>.bits</c>
      <c>RFC 8610</c>
      <c>.regexp</c>
      <c>RFC 8610</c>
      <c>.cbor</c>
      <c>RFC 8610</c>
      <c>.cborseq</c>
      <c>RFC 8610</c>
      <c>.within</c>
      <c>RFC 8610</c>
      <c>.and</c>
      <c>RFC 8610</c>
      <c>.lt</c>
      <c>RFC 8610</c>
      <c>.le</c>
      <c>RFC 8610</c>
      <c>.gt</c>
      <c>RFC 8610</c>
      <c>.ge</c>
      <c>RFC 8610</c>
      <c>.eq</c>
      <c>RFC 8610</c>
      <c>.ne</c>
      <c>RFC 8610</c>
      <c>.default</c>
      <c>RFC 8610</c>
</texttable>

<t>All other control operator names are Unassigned.</t>

<t>The IANA policy for additions to this registry is "Specification
Required" as defined in <xref target="RFC8126"/> (which involves an Expert
Review) for names that do not include an internal dot and "IETF
Review" for names that do include an internal dot.
The expert reviewer is specifically instructed that other Standards Development
Organizations (SDOs) may want to define control operators that are
specific to their fields (e.g., based on a binary syntax already in
use at the SDO); the review process should strive to facilitate such
an undertaking.</t>

</section>
</section>

  </middle>

  <back>

    <references title='Normative References'>

<reference  anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>

<reference  anchor='RFC3552' target='https://www.rfc-editor.org/info/rfc3552'>
<front>
<title>Guidelines for Writing RFC Text on Security Considerations</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<author initials='B.' surname='Korver' fullname='B. Korver'><organization /></author>
<date year='2003' month='July' />
</front>
<seriesInfo name='BCP' value='72'/>
<seriesInfo name='RFC' value='3552'/>
<seriesInfo name='DOI' value='10.17487/RFC3552'/>
</reference>

<reference  anchor='RFC3629' target='https://www.rfc-editor.org/info/rfc3629'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'><organization /></author>
<date year='2003' month='November' />
</front>
<seriesInfo name='STD' value='63'/>
<seriesInfo name='RFC' value='3629'/>
<seriesInfo name='DOI' value='10.17487/RFC3629'/>
</reference>

<reference  anchor='RFC4648' target='https://www.rfc-editor.org/info/rfc4648'>
<front>
<title>The Base16, Base32, and Base64 Data Encodings</title>
<author initials='S.' surname='Josefsson' fullname='S. Josefsson'><organization /></author>
<date year='2006' month='October' />
</front>
<seriesInfo name='RFC' value='4648'/>
<seriesInfo name='DOI' value='10.17487/RFC4648'/>
</reference>

<reference  anchor='RFC5234' target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>

<reference  anchor='RFC7049' target='https://www.rfc-editor.org/info/rfc7049'>
<front>
<title>Concise Binary Object Representation (CBOR)</title>
<author initials='C.' surname='Bormann' fullname='C. Bormann'><organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'><organization /></author>
<date year='2013' month='October' />
</front>
<seriesInfo name='RFC' value='7049'/>
<seriesInfo name='DOI' value='10.17487/RFC7049'/>
</reference>

<reference  anchor='RFC7493' target='https://www.rfc-editor.org/info/rfc7493'>
<front>
<title>The I-JSON Message Format</title>
<author initials='T.' surname='Bray' fullname='T. Bray' role='editor'><organization /></author>
<date year='2015' month='March' />
</front>
<seriesInfo name='RFC' value='7493'/>
<seriesInfo name='DOI' value='10.17487/RFC7493'/>
</reference>

<reference  anchor='RFC8126' target='https://www.rfc-editor.org/info/rfc8126'>
<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='M.' surname='Cotton' fullname='M. Cotton'><organization /></author>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<author initials='T.' surname='Narten' fullname='T. Narten'><organization /></author>
<date year='2017' month='June' />
</front>
<seriesInfo name='BCP' value='26'/>
<seriesInfo name='RFC' value='8126'/>
<seriesInfo name='DOI' value='10.17487/RFC8126'/>
</reference>

<reference  anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>

<reference  anchor='RFC8259' target='https://www.rfc-editor.org/info/rfc8259'>
<front>
<title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
<author initials='T.' surname='Bray' fullname='T. Bray' role='editor'><organization /></author>
<date year='2017' month='December' />
</front>
<seriesInfo name='STD' value='90'/>
<seriesInfo name='RFC' value='8259'/>
<seriesInfo name='DOI' value='10.17487/RFC8259'/>
</reference>

<reference anchor="W3C.REC-xmlschema-2-20041028"
           target='https://www.w3.org/TR/2004/REC-xmlschema-2-20041028'>
<front>
<title>XML Schema Part 2: Datatypes Second Edition</title>
<author initials='P.' surname='Biron' fullname='Paul V. Biron'>
    <organization />
</author>
<author initials='A.' surname='Malhotra' fullname='Ashok Malhotra'>
    <organization />
</author>
<date month='October' day='28' year='2004' />
</front>
<seriesInfo name='World Wide Web Consortium Recommendation' value='REC-xmlschema-2-20041028' />
<format type='HTML' target='http://www.w3.org/TR/2004/REC-xmlschema-2-20041028' />
</reference>

<reference anchor="ISO6093" >
  <front>
    <title>Information processing -- Representation of numerical values in character strings for information interchange</title>
    <author >
      <organization>ISO</organization>
    </author>
    <date year="1985"/>
  </front>
  <seriesInfo name="ISO" value="6093"/>
</reference>

    </references>

    <references title='Informative References'>

<reference anchor="IEEE754" >
<front>
  <title>IEEE Standard for Floating-Point Arithmetic</title>
  <author >
    <organization>IEEE</organization>
  </author>
<!--  <date year="2008" month="August"/> -->
  <date/>
</front>
<seriesInfo name="IEEE Std" value="754-2008"/>
</reference>

<reference anchor="RELAXNG" >
  <front>
    <title>Information technology -- Document Schema Definition Language (DSDL) -- Part 2: Regular-grammar-based validation -- RELAX NG</title>
    <author >
      <organization>ISO/IEC</organization>
    </author>
    <date year="2008" month="December" day="15"/>
  </front>
  <seriesInfo name="ISO/IEC" value="19757-2"/>
</reference>

<!-- draft-newton-json-content-rules (Expired) -->
<reference anchor="JCR">
<front>
<title>A Language for Rules Describing JSON Content</title>
<author initials='A' surname='Newton' fullname='Andrew Newton'>
    <organization />
</author>
<author initials='P' surname='Cordell' fullname='Pete Cordell'>
    <organization />
</author>
<date month='September' year='2017' />
</front>
<seriesInfo name='Work in Progress,' value='draft-newton-json-content-rules-09' />
</reference>

<!-- draft-ietf-anima-grasp (MISSREF) -->
<reference anchor="GRASP">
<front>
<title>A Generic Autonomic Signaling Protocol (GRASP)</title>
<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>
<author initials='B' surname='Carpenter' fullname='Brian Carpenter' role="editor">
    <organization />
</author>
<author initials='B' surname='Liu' fullname='Bing Liu' role="editor">
    <organization />
</author>
<date month='July' year='2017' />
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-anima-grasp-15' />
</reference>

<!-- draft-bormann-cbor-cddl-freezer (Expired) -->
<reference anchor="CDDL-Freezer">
<front>
<title>A feature freezer for the Concise Data Definition Language (CDDL)</title>
<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>
<date month='August' year='2018' />
</front>
<seriesInfo name='Work in Progress,' value='draft-bormann-cbor-cddl-freezer-01' />
</reference>

<reference anchor="PEG" >
  <front>
    <title>Parsing expression grammars: a recognition-based syntactic foundation</title>
    <author initials="B." surname="Ford" fullname="Bryan Ford">
      <organization></organization>
    </author>
    <date month="January" year="2004"/>
  </front>
  <seriesInfo name="Proceedings of the 31st ACM SIGPLAN-SIGACT symposium on Principles of programming languages - POPL" value="'04"/>
  <seriesInfo name="DOI" value="10.1145/964001.964011"/>
</reference>

<reference  anchor='RFC7071' target='https://www.rfc-editor.org/info/rfc7071'>
<front>
<title>A Media Type for Reputation Interchange</title>
<author initials='N.' surname='Borenstein' fullname='N. Borenstein'><organization /></author>
<author initials='M.' surname='Kucherawy' fullname='M. Kucherawy'><organization /></author>
<date year='2013' month='November' />
</front>
<seriesInfo name='RFC' value='7071'/>
<seriesInfo name='DOI' value='10.17487/RFC7071'/>
</reference>

<reference  anchor='RFC7950' target='https://www.rfc-editor.org/info/rfc7950'>
<front>
<title>The YANG 1.1 Data Modeling Language</title>
<author initials='M.' surname='Bjorklund' fullname='M. Bjorklund' role='editor'><organization /></author>
<date year='2016' month='August' />
</front>
<seriesInfo name='RFC' value='7950'/>
<seriesInfo name='DOI' value='10.17487/RFC7950'/>
</reference>

<reference  anchor='RFC8007' target='https://www.rfc-editor.org/info/rfc8007'>
<front>
<title>Content Delivery Network Interconnection (CDNI) Control Interface / Triggers</title>
<author initials='R.' surname='Murray' fullname='R. Murray'><organization /></author>
<author initials='B.' surname='Niven-Jenkins' fullname='B. Niven-Jenkins'><organization /></author>
<date year='2016' month='December' />
</front>
<seriesInfo name='RFC' value='8007'/>
<seriesInfo name='DOI' value='10.17487/RFC8007'/>
</reference>

<reference  anchor='RFC8152' target='https://www.rfc-editor.org/info/rfc8152'>
<front>
<title>CBOR Object Signing and Encryption (COSE)</title>
<author initials='J.' surname='Schaad' fullname='J. Schaad'><organization /></author>
<date year='2017' month='July' />
</front>
<seriesInfo name='RFC' value='8152'/>
<seriesInfo name='DOI' value='10.17487/RFC8152'/>
</reference>

<reference  anchor='RFC8428' target='https://www.rfc-editor.org/info/rfc8428'>
<front>
<title>Sensor Measurement Lists (SenML)</title>
<author initials='C.' surname='Jennings' fullname='C. Jennings'><organization /></author>
<author initials='Z.' surname='Shelby' fullname='Z. Shelby'><organization /></author>
<author initials='J.' surname='Arkko' fullname='J. Arkko'><organization /></author>
<author initials='A.' surname='Keranen' fullname='A. Keranen'><organization /></author>
<author initials='C.' surname='Bormann' fullname='C. Bormann'><organization /></author>
<date year='2018' month='August' />
</front>
<seriesInfo name='RFC' value='8428'/>
<seriesInfo name='DOI' value='10.17487/RFC8428'/>
</reference>

<reference anchor="YAML" target="https://yaml.org/spec/1.2/spec.html">
<front>
<title>YAML Ain't Markup Language (YAML[TM]) Version 1.2</title>
<author initials='O.' surname='Ben-Kiki' fullname='O. Ben-Kiki'><organization /></author>
<author initials='C.' surname='Evans' fullname='C. Evans'><organization /></author>
<author initials='I.' surname='Net' fullname='I. Net'><organization /></author>
<date year='2009' month='October' />
</front>
<seriesInfo name='3rd' value='Edition'/>
</reference>

    </references>

<section anchor="sec-peg" title="Parsing Expression Grammars (PEGs)">

<t>This appendix is normative.</t>

<t>Since the 1950s, many grammar notations are based on Backus-Naur Form
(BNF), a notation for context-free grammars (CFGs) within Chomsky's
generative system of grammars.  The Augmented Backus-Naur Form (ABNF)
<xref target="RFC5234"/>, widely used in IETF specifications and also
inspiring the syntax of CDDL, is an example of this.</t>

<t>Generative grammars can express ambiguity well, but this very property
may make them hard to use in recognition systems, spawning a number of
subdialects that pose constraints on generative grammars to be used
with parser generators; this scenario may be hard for the specification writer
to manage.</t>

<t>PEGs <xref target="PEG"/> provide an alternative formal
foundation for describing grammars that emphasizes recognition over
generation and resolves what would have been ambiguity in generative
systems by introducing the concept of "prioritized choice".</t>

<t>The notation for PEGs is quite close to BNF,
with the usual "Extended BNF" features, such as repetition, added.
However, where BNF uses the unordered (symmetrical) choice operator
"|" (incidentally notated as "/" in ABNF), PEG provides a prioritized
choice operator "/".  The two alternatives listed are to be tested in
left-to-right order, locking in the first successful match and
disregarding any further potential matches within the choice (but not
disabling alternatives in choices containing this choice, as a cut
(<xref target="cuts-in-maps"/>) would).</t>

<t>For example, the ABNF expressions</t>

<figure><artwork><![CDATA[
   A = "a" "b" / "a"    (1)
]]></artwork></figure>

<t>and</t>

<figure><artwork><![CDATA[
   A = "a" / "a" "b"    (2)
]]></artwork></figure>

<t>are equivalent in ABNF's original generative framework but are
very different in PEG: in (2), the second alternative will never match,
as any input string starting with an "a" will already succeed in the first
alternative, locking in the match.</t>

<t>Similarly, the occurrence indicators ("?", "*", "+") are "greedy" in
PEG, i.e., they consume as much input as they match (and, as a
consequence, "a* a" in PEG notation or "*a a" in CDDL syntax
never can match anything, as all input matching "a" is already consumed
by the initial "a*", leaving nothing to match the second "a").</t>

<t>Incidentally, the grammar of CDDL itself, as written in ABNF in
<xref target="abnf"/>, can be interpreted both (1)&nbsp;in the generative
framework on which RFC 5234 is based and (2)&nbsp;as a PEG.  This was made
possible by ordering the choices in the grammar such that a successful match
made on the left&nbhy;hand side of a "/" operator is always the intended match,
instead of relying on the power of symmetrical choices (for example,
note the sequence of alternatives in the rule for "uint", where the
lone zero is behind the longer match alternatives that start with a
zero).</t>

<t>The syntax used for expressing the PEG component of CDDL is based on
ABNF, interpreted in the obvious way with PEG semantics.  The ABNF
convention of notating occurrence indicators before the controlled
primary, and of allowing numeric values for minimum and maximum
occurrence around a "*" sign, is copied.  While PEG is only about
characters, CDDL has a richer set of elements, such as types and
groups.  Specifically, the following constructs map:</t>

<texttable>
      <ttcol align='left'>CDDL</ttcol>
      <ttcol align='left'>PEG</ttcol>
      <ttcol align='left'>Remark</ttcol>
      <c>"="</c>
      <c>"&lt;-"</c>
      <c>/= and //= are abbreviations</c>
      <c>"//"</c>
      <c>"/"</c>
      <c>prioritized choice</c>
      <c>"/"</c>
      <c>"/"</c>
      <c>prioritized choice, limited to types only</c>
      <c>"?" P</c>
      <c>P "?"</c>
      <c>zero or one</c>
      <c>"*" P</c>
      <c>P "*"</c>
      <c>zero or more</c>
      <c>"+" P</c>
      <c>P "+"</c>
      <c>one or more</c>
      <c>A B</c>
      <c>A B</c>
      <c>sequence</c>
      <c>A, B</c>
      <c>A B</c>
      <c>sequence, comma is decoration only</c>
</texttable>

<t>The literal notation and the use of square brackets, curly braces,
tildes, ampersands, and hash marks are specific to CDDL and unrelated
to the conventional PEG notation.  The DOT (".") from PEG is replaced by the
unadorned "#" or its alias "any".  Also, CDDL does not provide the
syntactic predicate operators NOT ("!") or AND ("&amp;") from PEG,
reducing expressiveness as well as complexity.</t>

<t>For more details about PEG's theoretical foundation and interesting
properties of the operators such as associativity and distributivity,
the reader is referred to <xref target="PEG"/>.</t>

</section>
<section anchor="abnf" title="ABNF Grammar">

<t>This appendix is normative.</t>

<t>The following is a formal definition of the CDDL syntax in ABNF
<xref target="RFC5234"/>.  Note that, as is defined in
ABNF, the quote-delimited strings below are case insensitive (while
string values and names are case sensitive in CDDL).</t>

<figure title="CDDL ABNF" anchor="fig-abnf"><artwork type="ABNF" align="center"><![CDATA[
cddl = S 1*(rule S)
rule = typename [genericparm] S assignt S type
     / groupname [genericparm] S assigng S grpent

typename = id
groupname = id

assignt = "=" / "/="
assigng = "=" / "//="

genericparm = "<" S id S *("," S id S ) ">"
genericarg = "<" S type1 S *("," S type1 S ) ">"

type = type1 *(S "/" S type1)

type1 = type2 [S (rangeop / ctlop) S type2]
; space may be needed before the operator if type2 ends in a name

type2 = value
      / typename [genericarg]
      / "(" S type S ")"
      / "{" S group S "}"
      / "[" S group S "]"
      / "~" S typename [genericarg]
      / "&" S "(" S group S ")"
      / "&" S groupname [genericarg]
      / "#" "6" ["." uint] "(" S type S ")"
      / "#" DIGIT ["." uint]                ; major/ai
      / "#"                                 ; any

rangeop = "..." / ".."

ctlop = "." id

group = grpchoice *(S "//" S grpchoice)

grpchoice = *(grpent optcom)

grpent = [occur S] [memberkey S] type
       / [occur S] groupname [genericarg]  ; preempted by above
       / [occur S] "(" S group S ")"

memberkey = type1 S ["^" S] "=>"
          / bareword S ":"
          / value S ":"

bareword = id

optcom = S ["," S]

occur = [uint] "*" [uint]
      / "+"
      / "?"

uint = DIGIT1 *DIGIT
     / "0x" 1*HEXDIG
     / "0b" 1*BINDIG
     / "0"

value = number
      / text
      / bytes

int = ["-"] uint

; This is a float if it has fraction or exponent; int otherwise
number = hexfloat / (int ["." fraction] ["e" exponent ])
hexfloat = ["-"] "0x" 1*HEXDIG ["." 1*HEXDIG] "p" exponent
fraction = 1*DIGIT
exponent = ["+"/"-"] 1*DIGIT

text = %x22 *SCHAR %x22
SCHAR = %x20-21 / %x23-5B / %x5D-7E / %x80-10FFFD / SESC
SESC = "\" (%x20-7E / %x80-10FFFD)

bytes = [bsqual] %x27 *BCHAR %x27
BCHAR = %x20-26 / %x28-5B / %x5D-10FFFD / SESC / CRLF
bsqual = "h" / "b64"

id = EALPHA *(*("-" / ".") (EALPHA / DIGIT))
ALPHA = %x41-5A / %x61-7A
EALPHA = ALPHA / "@" / "_" / "$"
DIGIT = %x30-39
DIGIT1 = %x31-39
HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
BINDIG = %x30-31

S = *WS
WS = SP / NL
SP = %x20
NL = COMMENT / CRLF
COMMENT = ";" *PCHAR CRLF
PCHAR = %x20-7E / %x80-10FFFD
CRLF = %x0A / %x0D.0A
]]></artwork></figure>

<t>Note that this ABNF does not attempt to reflect the detailed rules of
what can be in a prefixed byte string.</t>

</section>
<section anchor="matching" title="Matching Rules">

<t>This appendix is normative.</t>

<t>In this appendix, we go through the ABNF syntax rules defined in
<xref target="abnf"/> and briefly describe the matching semantics of each syntactic
feature.  In this context, an instance (data item) "matches" a CDDL specification
if it is allowed by the CDDL specification; this is then broken down
into parts of specifications (type and group expressions) and parts of
instances (data items).</t>

<figure><artwork type="abnf"><![CDATA[
cddl = S 1*(rule S)
]]></artwork></figure>

<t>A CDDL specification is a sequence of one or more rules.  Each rule
gives a name to a right&nbhy;hand&nbhy;side expression, either a CDDL type or a
CDDL group.  Rule names can be used in the rule itself and/or other
rules (and tools can output warnings if that is not the case).  The
order of the rules is significant only in two cases:</t>

<t><list style="numbers">
  <t>The first rule defines the semantics of the entire specification;
hence, there is no need to give that root rule a special name or
special syntax in the language (as, for example, with "start" in
RELAX&nbsp;NG); its name can therefore be chosen to be descriptive.
(As with all other rule names, the name of the initial rule may be
used in itself or in other rules.)</t>
  <t>Where a rule contributes to a type or group choice (using "/=" or
"//="), that choice is populated in the order the rules are given;
see below.</t>
</list></t>

<figure><artwork type="abnf"><![CDATA[
rule = typename [genericparm] S assignt S type
     / groupname [genericparm] S assigng S grpent

typename = id
groupname = id
]]></artwork></figure>

<t>A rule defines a name for a type expression (production "type") or for
a group expression (production "grpent"), with the intention that the
semantics does not change when the name is replaced by its
(parenthesized if needed) definition.  Note that whether the name
defined by a rule stands for a type or a group isn't always determined
by syntax alone: e.g., "a = b" can make "a" a type if "b" is a type, or a
group if "b" is a group.  More subtly, in "a = (b)", "a" may be used as a
type if "b" is a type, or as a group both when "b" is a group and when
"b" is a type (a good convention to make the latter case stand out to
the human reader is to write "a = (b,)").  (Note that the same dual
meaning of parentheses applies within an expression but often can be
resolved by the context of the parenthesized expression.  On the more
general point, it may not
be clear immediately either whether "b" stands for a group or a type --
this semantic processing may need to span several levels of rule
definitions before a determination can be made.)</t>

<figure><artwork type="abnf"><![CDATA[
assignt = "=" / "/="
assigng = "=" / "//="
]]></artwork></figure>

<t>A plain equals sign defines the rule name as the equivalent of the
expression to the right; it is an error if the name was already
defined with a different expression.  A "/=" or "//=" extends a named type or a
group by additional choices; a number of these could be replaced by
collecting all the right&nbhy;hand sides and creating a single rule with a
type choice or a group choice built from the right&nbhy;hand sides in the
order of the rules given.  (It is
not an error to extend a rule name that has not yet been defined; this
makes the right&nbhy;hand side the first entry in the choice being
created.)</t>

<figure><artwork type="abnf"><![CDATA[
genericparm = "<" S id S *("," S id S ) ">"
genericarg = "<" S type1 S *("," S type1 S ) ">"
]]></artwork></figure>

<t>Rule names can have generic parameters, which cause temporary
assignments within the right&nbhy;hand sides to the parameter names from
the arguments given when citing the rule name.</t>

<figure><artwork type="abnf"><![CDATA[
type = type1 *(S "/" S type1)
]]></artwork></figure>

<t>A type can be given as a choice between one or more types.  The choice
matches a data item if the data item matches any one of the types given
in the choice.  The choice uses PEG semantics
as discussed in <xref target="sec-peg"/>:
the first choice that matches wins.  (As a result, the order of rules
that contribute to a single rule name can very well matter.)</t>

<figure><artwork type="abnf"><![CDATA[
type1 = type2 [S (rangeop / ctlop) S type2]
]]></artwork></figure>

<t>Two types can be combined with a range operator (see below) or a
control operator (see <xref target="controls"/>).</t>

<figure><artwork type="abnf"><![CDATA[
type2 = value
]]></artwork></figure>

<t>A type can be just a single value (such as 1 or "icecream" or
h'0815'), which matches only a data item with that specific value (no
conversions defined),</t>

<figure><artwork type="abnf"><![CDATA[
   / typename [genericarg]
]]></artwork></figure>

<t>or be defined by a rule giving a meaning to a name (possibly after
supplying generic arguments as required by the generic parameters),</t>

<figure><artwork type="abnf"><![CDATA[
   / "(" S type S ")"
]]></artwork></figure>

<t>or be defined in a parenthesized type expression (parentheses may be
necessary to override some operator precedence), or</t>

<figure><artwork type="abnf"><![CDATA[
   / "{" S group S "}"
]]></artwork></figure>

<t>a map expression, which matches a valid CBOR map the key/value pairs
of which can be ordered in such a way that the resulting sequence
matches the group expression, or</t>

<figure><artwork type="abnf"><![CDATA[
   / "[" S group S "]"
]]></artwork></figure>

<t>an array expression, which matches a CBOR array the elements of which --
when taken as values and complemented by a wildcard (matches anything)
key each -- match the group, or</t>

<figure><artwork type="abnf"><![CDATA[
   / "~" S typename [genericarg]
]]></artwork></figure>

<t>an "unwrapped" group (see <xref target="unwrapping"/>), which matches the group
inside a type defined as a map or an array by wrapping the group, or</t>

<figure><artwork type="abnf"><![CDATA[
   / "&" S "(" S group S ")"
   / "&" S groupname [genericarg]
]]></artwork></figure>

<t>an enumeration expression, which matches any value that is within
the set of values that the values of the group given can take, or</t>

<figure><artwork type="abnf"><![CDATA[
   / "#" "6" ["." uint] "(" S type S ")"
]]></artwork></figure>

<t>a tagged data item, tagged with the "uint" given and containing the
type given as the tagged value, or</t>

<figure><artwork type="abnf"><![CDATA[
   / "#" DIGIT ["." uint]                ; major/ai
]]></artwork></figure>

<t>a data item of a major type (given by the DIGIT), optionally
constrained to the additional information given by the uint, or</t>

<figure><artwork type="abnf"><![CDATA[
   / "#"                                 ; any
]]></artwork></figure>

<t>any data item.</t>

<figure><artwork type="abnf"><![CDATA[
rangeop = "..." / ".."
]]></artwork></figure>

<t>A range operator can be used to join two type expressions that stand
for either two integer values or two floating-point values; it matches
any value that is between the two values, where the first value is
always included in the matching set and the second value is included
for ".." and excluded for "...".</t>

<figure><artwork type="abnf"><![CDATA[
ctlop = "." id
]]></artwork></figure>

<t>A control operator ties a _target_ type to a _controller_ type as
defined in <xref target="controls"/>.  Note that control operators are an extension
point for CDDL; additional documents may want to define additional
control operators.</t>

<figure><artwork type="abnf"><![CDATA[
group = grpchoice *(S "//" S grpchoice)
]]></artwork></figure>

<t>A group matches any sequence of key/value pairs that matches any of
the choices given (again using PEG semantics).</t>

<figure><artwork type="abnf"><![CDATA[
grpchoice = *(grpent optcom)
]]></artwork></figure>

<t>Each of the component groups is given as a sequence of group entries.
For a match, the sequence of key/value pairs given needs to match the sequence of
group entries in the sequence given.</t>

<figure><artwork type="abnf"><![CDATA[
grpent = [occur S] [memberkey S] type
]]></artwork></figure>

<t>A group entry can be given by a value type, which needs to be matched by
the value part of a single element; and, optionally, a memberkey type, which
needs to be matched by the key part of the element, if the memberkey
is given.
If the memberkey is not given, the entry can only be used for matching
arrays, not for maps.
(See below for how that is modified by the occurrence indicator.)</t>

<figure><artwork type="abnf"><![CDATA[
    / [occur S] groupname [genericarg]  ; preempted by above
]]></artwork></figure>

<t>A group entry can be built from a named group, or</t>

<figure><artwork type="abnf"><![CDATA[
    / [occur S] "(" S group S ")"
]]></artwork></figure>

<t>from a parenthesized group, again with a possible occurrence indicator.</t>

<figure><artwork type="abnf"><![CDATA[
memberkey = type1 S ["^" S] "=>"
          / bareword S ":"
          / value S ":"
]]></artwork></figure>

<t>Key types can be given by a type expression, a bareword (which stands
for a type that just contains a string value created from this bareword), or a value (which stands
for a type that just contains this value).  A key value matches its
key type if the key value is a member of the key type, unless a cut
preceding it in the group applies (see <xref target="cuts-in-maps"/> for how
map matching is influenced by the presence of the cuts denoted by "^" or
":" in previous entries).</t>

<figure><artwork type="abnf"><![CDATA[
bareword = id
]]></artwork></figure>

<t>A bareword is an alternative way to write a type with a single text
string value; it can only be used in the syntactic context given above.</t>

<figure><artwork type="abnf"><![CDATA[
optcom = S ["," S]
]]></artwork></figure>

<t>(Optional commas do not influence the matching.)</t>

<figure><artwork type="abnf"><![CDATA[
occur = [uint] "*" [uint]
      / "+"
      / "?"
]]></artwork></figure>

<t>An occurrence indicator modifies the group given to its right by
requiring the group to match the sequence to be matched exactly for a
certain number of times (see <xref target="occurrence"/>) in sequence,
i.e., it acts as a (possibly infinite) group choice that contains choices with
the group repeated each of the occurrences times.</t>

<t>The rest of the ABNF describes syntax for value notation that should
be familiar to readers from programming languages, with the possible exception
of h'..' and b64'..' for byte strings, as well as syntactic elements such
as comments and line ends.</t>

</section>
<section anchor="prelude" title="Standard Prelude">

<t>This appendix is normative.</t>

<t>The following prelude is automatically added to each CDDL file.
(Note that technically, it is a postlude, as it does not disturb the
selection of the first rule as the root of the definition.)</t>

<figure title="CDDL Prelude" anchor="fig-prelude"><artwork type="CDDL" align="center"><![CDATA[
any = #

uint = #0
nint = #1
int = uint / nint

bstr = #2
bytes = bstr
tstr = #3
text = tstr

tdate = #6.0(tstr)
time = #6.1(number)
number = int / float
biguint = #6.2(bstr)
bignint = #6.3(bstr)
bigint = biguint / bignint
integer = int / bigint
unsigned = uint / biguint
decfrac = #6.4([e10: int, m: integer])
bigfloat = #6.5([e2: int, m: integer])
eb64url = #6.21(any)
eb64legacy = #6.22(any)
eb16 = #6.23(any)
encoded-cbor = #6.24(bstr)
uri = #6.32(tstr)
b64url = #6.33(tstr)
b64legacy = #6.34(tstr)
regexp = #6.35(tstr)
mime-message = #6.36(tstr)
cbor-any = #6.55799(any)

float16 = #7.25
float32 = #7.26
float64 = #7.27
float16-32 = float16 / float32
float32-64 = float32 / float64
float = float16-32 / float64

false = #7.20
true = #7.21
bool = false / true
nil = #7.22
null = nil
undefined = #7.23
]]></artwork></figure>

<t>Note that the prelude is deemed to be fixed.  This means, for instance,
that additional tags beyond those defined in <xref target="RFC7049"/>, as
registered, need to be defined in each CDDL file that is using them.</t>

<t>A common stumbling point is that the prelude does not define a type
"string".  CBOR has byte strings ("bytes" in the prelude) and text
strings ("text"), so a type that is simply called "string" would be
ambiguous.</t>

</section>
<section anchor="sec-json" title="Use with JSON">

<t>This appendix is normative.</t>

<t>The JSON generic data model (implicit in <xref target="RFC8259"/>) is a subset of the
generic data model of CBOR.  So, one can use CDDL with JSON by limiting
oneself to what can be represented in JSON.  Roughly speaking, this
means leaving out byte strings, tags, and simple values other than
"false", "true", and "null", leading to the following limited prelude:</t>

<figure title="JSON-Compatible Subset of CDDL Prelude" anchor="fig-json-prelude"><artwork type="CDDL" align="center"><![CDATA[
any = #

uint = #0
nint = #1
int = uint / nint

tstr = #3
text = tstr

number = int / float

float16 = #7.25
float32 = #7.26
float64 = #7.27
float16-32 = float16 / float32
float32-64 = float32 / float64
float = float16-32 / float64

false = #7.20
true = #7.21
bool = false / true
nil = #7.22
null = nil
]]></artwork></figure>

<t>(The major types given here do not have a direct meaning in JSON, but
they can be interpreted as CBOR major types translated through
Section&nbsp;4 of <xref target="RFC7049"/>.)</t>

<t>There are a few fine points in using CDDL with JSON.  First, JSON does
not distinguish between integers and floating-point numbers; there is
only one kind of number (which may happen to be integral).  In this
context, specifying a type as "uint", "nint", or "int" then becomes a
predicate that the number be integral.  As an example, this means that
the following JSON numbers are all matching "uint":</t>

<figure><artwork><![CDATA[
   10 10.0 1e1 1.0e1 100e-1
]]></artwork></figure>

<t>(The fact that these are all integers may be surprising to users
accustomed to the long tradition in programming languages of using
decimal points or exponents in a number to indicate a floating-point
literal.)</t>

<t>CDDL distinguishes the various CBOR number types, but there is only
one number type in JSON.  The effect of specifying a floating-point
precision (float16/float32/float64) is only to restrict the set of
permissible values to those expressible with
binary16/binary32/binary64; this is unlikely to be very useful when
using CDDL for specifying JSON data structures.</t>

<t>Fundamentally, the number system of JSON itself is based on decimal
numbers and decimal fractions and does not have limits to its
precision or range.  In practice, JSON numbers are often parsed into a
number type that is called "float64" here, creating a number of
limitations to the generic data model <xref target="RFC7493"/>.  In particular,
this means that integers can only be expressed with interoperable
exactness when they lie in the range [-(2**53)+1, (2**53)-1] -- a
smaller range than that covered by CDDL "int".</t>

<t>JSON applications that want to stay compatible with I-JSON
("Internet JSON"; see <xref target="RFC7493"/>) may therefore want to define
integer types with more limited ranges, such as in
<xref target="fig-json-types"/>.  Note that the types given here are not part
of the prelude; they need to be copied into the CDDL specification if
needed.</t>

<figure title="I-JSON Types for CDDL (Not Part of Prelude)" anchor="fig-json-types"><artwork type="CDDL" align="center"><![CDATA[
ij-uint = 0..9007199254740991
ij-nint = -9007199254740991..-1
ij-int = -9007199254740991..9007199254740991
]]></artwork></figure>

<t>JSON applications that do not need to stay compatible with I-JSON and
that actually may need to go beyond the 64-bit unsigned and negative
integers supported by "int" (= "uint"/"nint") may want to use the
following additional types from the standard prelude, which are
expressed in terms of tags but can straightforwardly be mapped into
JSON (but not I-JSON) numbers:</t>

<figure><artwork type="CDDL"><![CDATA[
   biguint = #6.2(bstr)
   bignint = #6.3(bstr)
   bigint = biguint / bignint
   integer = int / bigint
   unsigned = uint / biguint
]]></artwork></figure>

<t>CDDL at this point does not have a way to express the unlimited
floating-point precision that is theoretically possible with JSON;
at the time of writing, this is rarely used in protocols in practice.</t>

<t>Note that a data model described in CDDL is always restricted by what
can be expressed in the serialization; e.g., floating-point values
such as NaN (not a number) and the infinities cannot be represented in
JSON even if they are allowed in the CDDL generic data model.</t>

</section>
<section anchor="tool" title="A CDDL Tool">

<t>This appendix is for information only.</t>

<t>A rough CDDL tool is available.  For CDDL specifications, it can check
the syntax, generate one or more instances
(expressed in CBOR diagnostic notation or in pretty-printed JSON), and
validate an existing instance against the specification:</t>

<figure title="CDDL Tool Usage" anchor="tool-usage"><artwork align="center"><![CDATA[
Usage:
cddl spec.cddl generate [n]
cddl spec.cddl json-generate [n]
cddl spec.cddl validate instance.cbor
cddl spec.cddl validate instance.json
]]></artwork></figure>

<t>Install on a system with a modern Ruby via:</t>

<figure title="CDDL Tool Installation" anchor="tool-install"><artwork type="shell" align="center"><![CDATA[
gem install cddl
]]></artwork></figure>

<t>The accompanying CBOR diagnostic tools (which are automatically
installed by the above) are described in
&lt;https://github.com/cabo/cbor-diag&gt;; they can be used to convert between
binary CBOR, a pretty-printed hexadecimal form of binary CBOR, CBOR diagnostic
notation, JSON, and YAML <xref target="YAML"/>.</t>

</section>
<section anchor="extended-diagnostic-notation" title="Extended Diagnostic Notation">

<t>This appendix is normative.</t>

<t>Section 6 of <xref target="RFC7049"/> defines a "diagnostic notation" in order to
be able to converse about CBOR data items without having to resort to
binary data.  Diagnostic notation is based on JSON, with extensions
for representing CBOR constructs such as binary data and tags.</t>

<t>(Standardizing this together with the actual interchange format does
not serve to create another interchange format but enables the use of
a shared diagnostic notation in tools for and documents about CBOR.)</t>

<t>This appendix discusses a few extensions to the diagnostic notation
that have turned out to be useful since RFC 7049 was written.
We refer to the result as Extended Diagnostic Notation (EDN).</t>

<section anchor="white-space-in-byte-string-notation" title="Whitespace in Byte String Notation">

<t>Examples often benefit from some whitespace (spaces, line breaks) in
byte strings.  In EDN, whitespace is ignored in prefixed byte strings; for
instance, the following are equivalent:</t>

<figure><artwork><![CDATA[
   h'48656c6c6f20776f726c64'
   h'48 65 6c 6c 6f 20 77 6f 72 6c 64'
   h'4 86 56c 6c6f
     20776 f726c64'
]]></artwork></figure>

</section>
<section anchor="textbin" title="Text in Byte String Notation">

<t>Diagnostic notation notates byte strings in one of the
base encodings per <xref target="RFC4648"/>, enclosed in single quotes,
prefixed by &gt;h&lt; for base16, &gt;b32&lt; for base32, &gt;h32&lt; for
base32hex, or &gt;b64&lt; for base64 or base64url.  Quite often, byte strings
carry bytes that are meaningfully interpreted as UTF-8 text.  EDN
allows the use of single quotes without a prefix to express byte
strings with UTF-8 text; for instance, the following are equivalent:</t>

<figure><artwork><![CDATA[
   'hello world'
   h'68656c6c6f20776f726c64'
]]></artwork></figure>

<t>The escaping rules of JSON strings are applied equivalently for
text&nbhy;based byte strings, e.g., "\" stands for a single backslash and
"'" stands for a single quote.  Whitespace is included literally,
i.e., the previous section does not apply to text-based byte strings.</t>

</section>
<section anchor="embedded-cbor-and-cbor-sequences-in-byte-strings" title="Embedded CBOR and CBOR Sequences in Byte Strings">

<t>Where a byte string is to carry an embedded CBOR-encoded item, or more
generally a sequence of zero or more such items, the diagnostic
notation for these zero or more CBOR data items, separated by commas,
can be enclosed in &lt;&lt;&nbsp;and&nbsp;&gt;&gt; to notate the byte string
resulting from encoding the data items and concatenating the result.  For
instance, each pair of columns in the following are equivalent:</t>

<figure><artwork><![CDATA[
   <<1>>              h'01'
   <<1, 2>>           h'0102'
   <<"foo", null>>    h'63666F6FF6'
   <<>>               h''
]]></artwork></figure>

</section>
<section anchor="concatenated-strings" title="Concatenated Strings">

<t>While the ability to include whitespace enables line-breaking of
encoded byte strings, a mechanism is needed to be able to include
text strings as well as byte strings in direct UTF-8 representation
into line-based documents (such as RFCs and source code).</t>

<t>We extend the diagnostic notation by allowing multiple text strings or
multiple byte strings to be notated separated by whitespace; these
are then concatenated into a single text or byte string, respectively.
Text strings and byte strings do not mix within such a
concatenation, except that byte string notation can be used inside a
sequence of concatenated text string notation to encode characters
that may be better represented in an encoded way.  The following four
values are equivalent:</t>

<figure><artwork><![CDATA[
   "Hello world"
   "Hello " "world"
   "Hello" h'20' "world"
   "" h'48656c6c6f20776f726c64' ""
]]></artwork></figure>

<t>Similarly, the following byte string values are equivalent:</t>

<figure><artwork><![CDATA[
   'Hello world'
   'Hello ' 'world'
   'Hello ' h'776f726c64'
   'Hello' h'20' 'world'
   '' h'48656c6c6f20776f726c64' '' b64''
   h'4 86 56c 6c6f' h' 20776 f726c64'
]]></artwork></figure>

<t>(Note that the approach of separating by whitespace, while familiar
from the C language, requires some attention -- a single comma makes a
big difference here.)</t>

</section>
<section anchor="hexadecimal-octal-and-binary-numbers" title="Hexadecimal, Octal, and Binary Numbers">

<t>In addition to JSON's decimal numbers, EDN provides hexadecimal, octal,
and binary numbers in the usual C-language notation (octal with 0o
prefix present only).</t>

<t>The following are equivalent:</t>

<figure><artwork><![CDATA[
   4711
   0x1267
   0o11147
   0b1001001100111
]]></artwork></figure>

<t>As are:</t>

<figure><artwork><![CDATA[
   1.5
   0x1.8p0
   0x18p-4
]]></artwork></figure>

</section>
<section anchor="comments" title="Comments">

<t>Longer pieces of diagnostic notation may benefit from comments.
JSON famously does not provide for comments, and basic diagnostic notation
per RFC&nbsp;7049 inherits this property.</t>

<t>In EDN, comments can be included, delimited
by slashes ("/").  Any text within and including a pair of slashes is
considered a comment.</t>

<t>Comments are considered whitespace.  Hence, they are allowed in
prefixed byte strings; for instance, the following are equivalent:</t>

<figure><artwork><![CDATA[
   h'68656c6c6f20776f726c64'
   h'68 65 6c /doubled l!/ 6c 6f /hello/
     20 /space/
     77 6f 72 6c 64' /world/
]]></artwork></figure>

<t>This can be used to annotate a CBOR structure as in:</t>

<figure><artwork type="CBORdiag"><![CDATA[
   /grasp-message/ [/M_DISCOVERY/ 1, /session-id/ 10584416,
                    /objective/ [/objective-name/ "opsonize",
                                 /D, N, S/ 7, /loop-count/ 105]]
]]></artwork></figure>

<t>(There are currently no end-of-line comments.  If we want to add them,
"//" sounds like a reasonable delimiter given that we already use
slashes for comments, but we could also go, for example, for&nbsp;"#".)</t>

</section>
</section>
<section anchor="examples" title="Examples">

<t>This appendix is for information only.</t>

<t>This appendix contains a few examples of structures defined
using&nbsp;CDDL. The theme for the examples is taken from <xref
target="RFC7071"/>, which defines certain JSON structures in English.  For a
similar example, it may also be of interest to examine Appendix&nbsp;A of
<xref target="RFC8007"/>, which contains a CDDL definition for a JSON
structure defined in the main body of that RFC.</t>

<t>These examples all happen to describe data that is interchanged in
JSON.  Examples for CDDL definitions of data that is interchanged in
CBOR can be found in <xref target="RFC8152"/>, <xref target="GRASP"/>,
and <xref target="RFC8428"/>.</t>

<t><xref target="RFC7071"/> defines the "reputon" structure for JSON using
somewhat formalized English text. Here is a (somewhat verbose) equivalent
definition using the same terms, but notated in CDDL:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
reputation-object = {
  reputation-context,
  reputon-list
}

reputation-context = (
  application: text
)

reputon-list = (
  reputons: reputon-array
)

reputon-array = [* reputon]

reputon = {
  rater-value,
  assertion-value,
  rated-value,
  rating-value,
  ? conf-value,
  ? normal-value,
  ? sample-value,
  ? gen-value,
  ? expire-value,
  * ext-value,
}

rater-value = ( rater: text )
assertion-value = ( assertion: text )
rated-value = ( rated: text )
rating-value = ( rating: float16 )
conf-value = ( confidence: float16 )
normal-value = ( normal-rating: float16 )
sample-value = ( sample-size: uint )
gen-value = ( generated: uint )
expire-value = ( expires: uint )
ext-value = ( text => any )
]]></artwork></figure>

<t>An equivalent, more compact form of this example would be:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
reputation-object = {
  application: text
  reputons: [* reputon]
}

reputon = {
  rater: text
  assertion: text
  rated: text
  rating: float16
  ? confidence: float16
  ? normal-rating: float16
  ? sample-size: uint
  ? generated: uint
  ? expires: uint
  * text => any
}
]]></artwork></figure>

<!-- Quoted phrase is DNE. -->
<t>Note how this rather clearly delineates the structure somewhat
shrouded by so many words in Section&nbsp;6.2.2 of <xref target="RFC7071"/>.
Also, this definition makes it clear that several ext-values are
allowed (by definition with different member names); RFC 7071 could be
read to forbid the repetition of ext-value ("A specific
reputon-element MUST&nbsp;NOT appear more than once" is ambiguous).</t>

<t>The CDDL tool described in <xref target="tool"/> generates as one example:</t>

<figure><artwork type="JSON" align="center"><![CDATA[
   {
     "application": "conchometry",
     "reputons": [
       {
         "rater": "Ephthianura",
         "assertion": "codding",
         "rated": "sphaerolitic",
         "rating": 0.34133473256800795,
         "confidence": 0.9481983064298332,
         "expires": 1568,
         "unplaster": "grassy"
       },
       {
         "rater": "nonchargeable",
         "assertion": "raglan",
         "rated": "alienage",
         "rating": 0.5724646875815566,
         "sample-size": 3514,
         "Aldebaran": "unchurched",
         "puruloid": "impersonable",
         "uninfracted": "pericarpoidal",
         "schorl": "Caro"
       },
       {
         "rater": "precollectable",
         "assertion": "Merat",
         "rated": "thermonatrite",
         "rating": 0.19164006323936977,
         "confidence": 0.6065252103391268,
         "normal-rating": 0.5187773690879303,
         "generated": 899,
         "speedy": "solidungular",
         "noviceship": "medicine",
         "checkrow": "epidictic"
       }
     ]
   }
]]></artwork></figure>

</section>

<section numbered="no" anchor="acknowledgements" title="Acknowledgements">

<t>Inspiration was taken from the C and Pascal languages, MPEG's
conventions for describing structures in the ISO base media file
format, RELAX&nbsp;NG and its compact syntax <xref target="RELAXNG"/>, and,
in particular, Andrew Lee Newton's early proposals on JSON Content Rules
(JCR) as found in draft version four (-04) of <xref target="JCR"/>.</t>

<t>Lots of highly useful feedback came from members of the IETF CBOR WG --
in particular, Ari Keranen,
Brian Carpenter,
Burt Harris,
Jeffrey Yasskin,
Jim Hague,
Jim Schaad,
Joe Hildebrand,
Max Pritikin,
Michael Richardson,
Pete Cordell,
Sean Leonard,
and
Yaron Sheffer.
Also, Francesca Palombini and Joe volunteered to chair the WG when it
was created, providing the framework for generating and processing this
feedback, with Barry Leiba having taken over from Joe since then.
Chris Lonvick and Ines Robles provided additional reviews during IESG
processing, and Alexey Melnikov steered the process as the responsible
Area Director.</t>

<t>The CDDL tool described in <xref target="tool"/> was written by Carsten Bormann,
building on previous work by Troy Heninger and Tom Lord.</t>

</section>

<section numbered="no" anchor="contributors" title="Contributors">

<t>CDDL was originally conceived by Bert Greevenbosch, who also wrote the
original five draft versions of this document.</t>

</section>

  </back>

</rfc>
