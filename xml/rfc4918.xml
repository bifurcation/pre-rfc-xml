<?xml version="1.0"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY rfc2119 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
  <!ENTITY rfc2277 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2277.xml'>
  <!ENTITY rfc2291 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2291.xml'>
  <!ENTITY rfc2518 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2518.xml'>
  <!ENTITY rfc2616 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml'>
  <!ENTITY rfc2617 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml'>
  <!ENTITY rfc2781 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2781.xml'>
  <!ENTITY rfc3023 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3023.xml'>
  <!ENTITY rfc3253 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3253.xml'>
  <!ENTITY rfc3339 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339.xml'>
  <!ENTITY rfc3629 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml'>
  <!ENTITY rfc3648 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3648.xml'>
  <!ENTITY rfc3744 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3744.xml'>
  <!ENTITY rfc3864 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3864.xml'>
  <!ENTITY rfc3986 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml'>
  <!ENTITY rfc4122 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4122.xml'>
]>
<?rfc toc="yes"?>
<?rfc strict="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc subcompact="no"?>

<rfc number="4918" category="std" obsoletes="2518">

<front>

<title abbrev="WebDAV">
 HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)
</title>


<author initials="L.M." surname="Dusseault" fullname="Lisa Dusseault" role="editor" >
  <organization abbrev="CommerceNet">CommerceNet</organization>
  <address>
    <postal>
      <street>2064 Edgewood Dr.</street>
      <city>Palo Alto</city> <region>CA</region>
      <code>94303</code>
      <country>US</country>
    </postal>
    <email>ldusseault@commerce.net</email>
  </address>
</author>

<date month="June" year="2007" />

<area>Applications</area>
<workgroup>WebDAV</workgroup>

<keyword>webdav</keyword>
<keyword>http</keyword>
<keyword>authoring</keyword>
<keyword>web</keyword>
<keyword>locks</keyword>
<keyword>propfind</keyword>
<keyword>proppatch</keyword>
<keyword>mkcol</keyword>

<abstract>
  <t>Web Distributed Authoring and Versioning (WebDAV) consists of a set of methods, headers, and content-types 
   ancillary to HTTP/1.1 for the management of resource properties, 
   creation and management of resource collections, URL namespace 
   manipulation, and resource locking (collision avoidance). 
  </t>
  <t>
   RFC 2518 was published in February 1999, and this specification
   obsoletes RFC 2518 with minor
   revisions mostly due to interoperability experience. 
  </t>
</abstract>

</front>

<middle>

<section title="Introduction" anchor="intro" >

  <t>
   This document describes an extension to the HTTP/1.1 protocol that 
   allows clients to perform remote Web content authoring operations.  
   This extension provides a coherent set of methods, headers, request 
   entity body formats, and response entity body formats that provide 
   operations for: 
  </t>
  <t>
   Properties: The ability to create, remove, and query information 
   about Web pages, such as their authors, creation dates, etc. 
  </t>
  <t>
   Collections: The ability to create sets of documents and to retrieve 
   a hierarchical membership listing (like a directory listing in a 
   file system). 
  </t>
  <t>
   Locking: The ability to keep more than one person from working on a 
   document at the same time. This prevents the "lost update problem", 
   in which modifications are lost as first one author, then another, 
   writes changes without merging the other author's changes. 
  </t>
  <t>
   Namespace Operations: The ability to instruct the server to copy and 
   move Web resources, operations that change the mapping from URLs to
    resources. 
  </t>
  <t>
   Requirements and rationale for these operations are described in a 
   companion document, "Requirements for a Distributed Authoring and 
   Versioning Protocol for the World Wide Web" <xref target="RFC2291"/>. 
  </t>
  <t>
   This document does not specify the versioning operations suggested 
   by <xref target="RFC2291"/>. That work was done in a separate document, 
   "Versioning Extensions to WebDAV" <xref target="RFC3253"/>. 
  </t>
  <t>
   The sections below provide a detailed introduction to various WebDAV abstractions: 
   <xref target="properties">resource properties</xref>, 
    <xref target="collections">collections of resources</xref>, 
   <xref target="locking">locks</xref> in general, and 
    <xref target="write-lock">write locks</xref> specifically.  
  </t>
  
  <t>
    These abstractions are manipulated by the 
    <xref target="methods">WebDAV-specific HTTP methods</xref> 
    and the <xref target="headers">extra HTTP headers</xref> used with WebDAV methods. 
    General considerations for handling HTTP requests and responses in WebDAV are
    found in <xref target="response-handling"/>.
  </t>
  <t>
   While the status codes provided by HTTP/1.1 are sufficient to 
   describe most error conditions encountered by WebDAV methods, there 
   are some errors that do not fall neatly into the existing 
   categories.  This specification defines <xref target="webdav-status-codes">extra status
   codes developed for WebDAV methods</xref> and describes 
   <xref target="http-status-codes">existing HTTP status codes</xref> as used in 
   WebDAV. Since some WebDAV methods may operate over many resources, the 
   <xref target="multi-status">Multi-Status response</xref> has been 
   introduced to return status information for multiple resources. Finally, this 
   version of WebDAV introduces <xref target="pre_post">precondition and postcondition</xref> 
   XML elements in error response bodies.
  </t>
  <t>
   WebDAV uses XML (<xref target="REC-XML"/>) for property names and some values, and also uses
    XML to marshal complicated requests and responses. This specification contains
   DTD and text definitions of
    all <xref target="property-definitions">properties</xref> 
    and all other <xref target="xml-elements">XML elements</xref> used in marshalling.
   WebDAV includes a few special rules on <xref target="xml-extensibility">extending 
     WebDAV XML marshalling in backwards-compatible ways</xref>. 
  </t>
  <t>
   Finishing off the specification are sections on what it means for a resource to be 
   <xref target="compliance-classes">compliant with this specification</xref>, on 
   <xref target="i18n">internationalization support</xref>, and on 
   <xref target="security">security</xref>. 
  </t>
</section>
  
<section title="Notational Conventions">

  <t>
   Since this document describes a set of extensions to the HTTP/1.1 
   protocol, the augmented BNF used herein to describe protocol 
   elements is exactly the same as described in Section 2.1 of 
   <xref target="RFC2616"/>, including the rules about 
    implied linear whitespace.  
   Since this augmented BNF uses the basic production rules provided in 
   Section 2.2 of <xref target="RFC2616"/>, these rules apply to this document as 
   well.  Note this is not the standard BNF syntax used in other RFCs.

<!-- [rfced] 1. Should a reference be added to RFC 4234 for ABNF?   
	LMD:  I don't think so
	
             2. We received an error when trying to check the ABNF
                within this document (using Bill Fenner's ABNF checker
                -- http://rtg.ietf.org/~fenner/abnf.cgi).  It seems as
                though "/" should be used as the alternation character
                instead of "|".   Please check your ABNF and make any
                necessary updates. 
	LMD: I'd rather not change all that.  WebDAV follows HTTP model in that respect.  Sorry.
-->
  </t>
  <t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", 
   "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in 
   this document are to be interpreted as described in <xref target="RFC2119"/>. 
  </t>
  <t>
     Note that in natural language, a property like the 
   "creationdate" property in the "DAV:" XML namespace is sometimes 
   referred to as "DAV:creationdate" for brevity. 
  </t>

</section>

<section title="Terminology">

  <t>
   URI/URL - A Uniform Resource Identifier and Uniform Resource 
   Locator, respectively. These terms (and the distinction between 
   them) are defined in <xref target="RFC3986"/>. 
  </t>
  <t>URI/URL Mapping - A relation between an absolute URI and a resource.  Since 
    a resource can represent items that are not network retrievable, as well 
    as those that are, it is possible for a resource to have zero, one, or many 
    URI mappings. Mapping a resource to an "http" scheme URI makes it possible
    to submit HTTP protocol requests to the resource using the URI.
  </t>
  <t>
    Path Segment - Informally, the characters found between slashes ("/") in a URI.
    Formally, as defined in Section 3.3 of <xref target="RFC3986"/>.  
  </t>
  <t>
    Collection - Informally, a resource that also acts as a container of	
    references to child resources. Formally, a resource that contains a	
    set of mappings between path segments and resources and meets the	
    requirements defined in <xref target="collections"/>.
  </t>
  <t>
    Internal Member (of a Collection) - Informally, a child resource of a	
    collection. Formally, a resource referenced by a path segment	mapping
    contained in the collection.	
  </t>
  <t>
    Internal Member URL (of a Collection) - A URL of an internal member,	
    consisting of the URL of the collection (including trailing slash)	
    plus the path segment identifying the internal member.	
  </t>
  <t>
    Member (of a Collection) - Informally, a "descendant" of a	
    collection. Formally, an internal member of the collection, or,	
    recursively, a member of an internal member.	
  </t>
  <t>
    Member URL (of a Collection) - A URL that is either an internal	
    member URL of the collection itself, or is an internal member URL of	
    a member of that collection.
  </t>
  
  <t>
   Property - A name/value pair that contains descriptive information 
   about a resource. 
  </t>
  <t>
   Live Property - A property whose semantics and syntax are enforced 
   by the server.  For example, the live property DAV:getcontentlength 
   has its value, the length of the entity returned by a GET request, 
   automatically calculated by the server. 
  </t>
  <t>
   Dead Property - A property whose semantics and syntax are not 
   enforced by the server.  The server only records the value of a dead 
   property; the client is responsible for maintaining the consistency 
   of the syntax and semantics of a dead property. 
  </t>
  
  <t>Principal - 
      A distinct human or computational actor that
      initiates access to network resources. 
  </t>
    
  <t>State Token -
    A URI that represents a state of a resource.  Lock tokens are the 
      only state tokens defined in this specification. 
  </t>
    
</section>

<section title="Data Model for Resource Properties" anchor="properties">
    
  <section title="The Resource Property Model">
    
   <t>
   Properties are pieces of data that describe the state of a resource.  
   Properties are data about data. 
  </t>
  <t>
   Properties are used in distributed authoring environments to provide 
   for efficient discovery and management of resources.  For example, a 
   'subject' property might allow for the indexing of all resources by 
   their subject, and an 'author' property might allow for the 
   discovery of what authors have written which documents. 
  </t>
  <t>
   The DAV property model consists of name/value pairs.  The name of a 
   property identifies the property's syntax and semantics, and 
   provides an address by which to refer to its syntax and semantics. 
  </t>
  <t>
   There are two categories of properties: "live" and "dead".  A live 
   property has its syntax and semantics enforced by the server. Live 
   properties include cases where a) the value of a property is
   protected and
   maintained by the server, and b) the value of the property is 
   maintained by the client, but the server performs syntax checking on 
   submitted values. All instances of a given live property MUST comply 
   with the definition associated with that property name.  A dead 
   property has its syntax and semantics enforced by the client; the 
   server merely records the value of the property verbatim. 
  </t>

  </section>
  
  <section title="Properties and HTTP Headers">
    <t>
   Properties already exist, in a limited sense, in HTTP message 
   headers.  However, in distributed authoring environments, a 
   relatively large number of properties are needed to describe the 
   state of a resource, and setting/returning them all through HTTP 
   headers is inefficient.  Thus, a mechanism is needed that allows a 
   principal to identify a set of properties in which the principal is 
   interested and to set or retrieve just those properties. 
    </t>
  </section>
  
  <section title="Property Values" anchor="property_values"> 
    <t>
   The value of a property is always a (well-formed) XML fragment. 
  </t>
  <t>
   XML has been chosen because it is a flexible, self-describing, 
   structured data format that supports rich schema definitions, and 
   because of its support for multiple character sets.  XML's self-describing
   nature allows any property's value to be extended by 
   adding elements.  Clients will not break when they 
   encounter extensions because they will still have the data specified 
   in the original schema and MUST ignore elements they do not 
   understand.  
  </t>
    <t>
    XML's support for multiple character sets allows any 
   human-readable property to be encoded and read in a character set 
   familiar to the user.  XML's support for multiple human languages, 
   using the "xml:lang" attribute, handles cases where the same 
   character set is employed by multiple human languages. Note that 
   xml:lang scope is recursive, so an xml:lang attribute on any element 
   containing a property name element applies to the property value 
   unless it has been overridden by a more locally scoped attribute. 
    Note that a property only has
    one value, in one language (or language MAY be left undefined); a property
	does not have
    multiple values in different languages or a single value in multiple languages.
  </t>
  <t>
   A property is always represented with an XML element 
   consisting of the property name, called the "property name element". 
    The simplest example is an empty 
   property, which is different from a property that does not exist: 
  </t>
  <figure>
    <artwork>
   &lt;R:title xmlns:R="http://www.example.com/ns/"&gt;&lt;/R:title&gt;
    </artwork>
  </figure>
    
  <t>
   The value of the property appears inside the property name element.  
   The value may be any kind of well-formed XML content, including both 
   text-only and mixed content.  Servers MUST preserve the following XML Information
    Items (using the terminology from <xref target="REC-XML-INFOSET"/>)
    in storage and transmission of dead properties: </t>

   <t>For the property name Element Information Item itself:</t>
    <t><list>
      <t>[namespace name]</t>
      <t>[local name]</t>
      <t>[attributes] named "xml:lang" or any such attribute in scope</t>
      <t>[children] of type element or character</t>
    </list></t>

    <t>On all Element Information Items in the property value:</t>
    <t><list>
      <t>[namespace name]</t>
      <t>[local name]</t>
      <t>[attributes]</t>
      <t>[children] of type element or character</t>
    </list></t>

    <t>On Attribute Information Items in the property value:</t>
    <t><list>
      <t>[namespace name]</t>
      <t>[local name]</t>
      <t>[normalized value]</t>
    </list></t>

    <t>On Character Information Items in the property value:</t>
    <t><list>
      <t>[character code]</t>
    </list></t>

    <t>Since prefixes are used in some XML vocabularies (XPath and
      XML Schema, for example), servers 
    SHOULD preserve, for any Information Item in the value:</t>
    <t><list>
      <t>[prefix]</t>
    </list></t>
        
  <t>
   XML Infoset attributes not listed above MAY be preserved by the
   server, but clients MUST NOT rely on them being preserved. The above
    rules would also apply by default to live properties, unless defined
    otherwise.  
  </t>

  <t>  
    Servers MUST ignore the XML attribute xml:space if present 
    and never use it to change whitespace 
    handling.  Whitespace in property values is significant.  
  </t>
    
    <section title="Example - Property with Mixed Content">
      <t>Consider a dead property 'author' created by the client as follows:</t>
      <figure
        >
        <artwork><![CDATA[
  <D:prop xml:lang="en" xmlns:D="DAV:">
    <x:author xmlns:x='http://example.com/ns'>
      <x:name>Jane Doe</x:name>
      <!-- Jane's contact info -->
      <x:uri type='email' 
             added='2005-11-26'>mailto:jane.doe@example.com</x:uri>
      <x:uri type='web' 
             added='2005-11-27'>http://www.example.com</x:uri>
      <x:notes xmlns:h='http://www.w3.org/1999/xhtml'>
        Jane has been working way <h:em>too</h:em> long on the  ]]>
        long-awaited revision of &lt;![CDATA[&lt;RFC2518&gt;]]&gt;.<![CDATA[
      </x:notes>
    </x:author>
  </D:prop> 
]]>        </artwork>
      </figure>
      
      <t>When this property is requested, a server might return:</t>

      <figure>
        <artwork><![CDATA[
  <D:prop xmlns:D='DAV:'><author 
          xml:lang='en'
          xmlns:x='http://example.com/ns' 
          xmlns='http://example.com/ns'
          xmlns:h='http://www.w3.org/1999/xhtml'>
      <x:name>Jane Doe</x:name>
      <x:uri   added="2005-11-26" type="email"
        >mailto:jane.doe@example.com</x:uri>
      <x:uri   added="2005-11-27" type="web" 
        >http://www.example.com</x:uri>
      <x:notes>
        Jane has been working way <h:em>too</h:em> long on the  
        long-awaited revision of &lt;RFC2518&gt;.
      </x:notes>
    </author>
  </D:prop>
        ]]></artwork>
        
      </figure>
      <t>Note in this example:</t>
      <t><list style="symbols">
        <t>The [prefix] for the property name itself was not preserved, being
        non-significant, whereas all other [prefix] values have been preserved,</t>
        <t>attribute values have been rewritten with double quotes instead of
        single quotes (quoting style is not significant), and attribute
        order has not been preserved,</t>
        <t>the xml:lang attribute has been returned on the property name element
        itself (it was in scope when the property was set, but the exact
        position in the response is not considered significant as long as it
        is in scope),</t>
        <t>whitespace between tags has been preserved everywhere (whitespace
          between attributes not so),</t>
        <t>CDATA encapsulation was replaced with character escaping (the reverse
         would also be legal),</t>
        <t>the comment item was stripped (as would have been a processing
      instruction item).
       </t>
    </list>
      </t>
      <t>
      Implementation note: there are cases such as editing scenarios where clients may
      require that XML content is preserved character by character (such
      as attribute ordering or quoting style).  In this case, clients
      should consider using a text-only property value by escaping all
      characters that have a special meaning in XML parsing.      
      </t>
    </section>
    
  </section>
  
  <section title="Property Names">
    <t>    
   A property name is a universally unique identifier that is 
   associated with a schema that provides information about the syntax 
   and semantics of the property. 
  </t>
  <t>
   Because a property's name is universally unique, clients can depend 
   upon consistent behavior for a particular property across multiple 
   resources, on the same and across different servers, so long as that 
   property is "live" on the resources in question, and the 
   implementation of the live property is faithful to its definition. 
  </t>
  <t>
   The XML namespace mechanism, which is based on URIs (<xref target="RFC3986"/>), is 
   used to name properties because it prevents namespace collisions and 
   provides for varying degrees of administrative control. 
  </t>
  <t>
   The property namespace is flat; that is, no hierarchy of properties 
   is explicitly recognized.  Thus, if a property A and a property A/B 
   exist on a resource, there is no recognition of any relationship 
   between the two properties.  It is expected that a separate 
   specification will eventually be produced that will address issues 
   relating to hierarchical properties. 
  </t>
  <t>
   Finally, it is not possible to define the same property twice on a 
   single resource, as this would cause a collision in the resource's 
   property namespace. 
    </t>
  </section>
  
  <section title="Source Resources and Output Resources">
    <t>Some HTTP resources are dynamically generated by the server.  For these resources,
      there presumably exists source code somewhere governing how that resource
      is generated.  The relationship of source files to output HTTP resources
      may be one to one, one to many, many to one, or many to many.  There is
      no mechanism in HTTP to determine whether a resource is even dynamic, let
       alone where its source files exist or how to author them.  
   Although this problem would usefully be solved, interoperable WebDAV 
   implementations have been widely deployed without actually solving 
   this problem, by dealing only with static resources. Thus, the 
      source vs. output problem is not solved in 
   this specification and has been deferred to a separate document. 
    </t>
  </section>
  
</section>

<section title="Collections of Web Resources" anchor="collections">
  <t>
   This section provides a description of a type of Web resource, 
   the collection, and discusses its interactions with the HTTP URL 
   namespace and with HTTP methods. The purpose of a collection resource is to model 
   collection-like objects (e.g., file system directories) within a 
   server's namespace.  
  </t>
  <t>
   All DAV-compliant resources MUST support the HTTP URL namespace 
   model specified herein. 
  </t>
  
  <section title="HTTP URL Namespace Model" anchor="http.url.namespace.model">
    <t>
   The HTTP URL namespace is a hierarchical namespace where the 
   hierarchy is delimited with the "/" character.    
    </t>
    <t>
   An HTTP URL namespace is said to be consistent if it meets the 
   following conditions: for every URL in the HTTP hierarchy there 
   exists a collection that contains that URL as an internal member URL. 
   The root, or top-level collection of the namespace under 
   consideration, is exempt from the previous rule.   The top-level
      collection of the namespace under consideration is not necessarily
      the collection identified by the absolute path '/' -- it may be 
      identified by one or more path segments (e.g., /servlets/webdav/...)
    </t>
    <t>
   Neither HTTP/1.1 nor WebDAV requires that the entire HTTP URL 
   namespace be consistent -- a WebDAV-compatible resource may
      not have a parent collection.  However, certain WebDAV methods are 
   prohibited from producing results that cause namespace 
   inconsistencies. 
    </t>
    <t>
   As is implicit in <xref target="RFC2616"/> and  <xref target="RFC3986"/>, any resource, 
   including collection resources, MAY be identified by more than one 
   URI. For example, a resource could be identified by multiple HTTP 
   URLs. 
    </t>
  </section>
  
  <section title="Collection Resources" anchor="collection-resources">
    <t>
      Collection resources differ from other resources in that they also
      act as containers.  Some HTTP methods apply only to a collection, but
      some apply to some or all of the resources inside the container defined
      by the collection.  When the scope of a method is not
      clear, the client can specify what depth to apply.  Depth can be either 
      zero levels (only the collection), one level (the collection and directly contained resources),
      or infinite levels (the collection and all contained resources recursively).
    </t>
    
    <t>A collection's state consists of at least a
      set of mappings between path segments and resources, 
      and a set of properties on the collection itself.  In this document, a resource B will be said	
      to be contained in the collection resource A if there is a path	
      segment mapping that maps to B and that is contained in A.
      &nbsp;A collection MUST contain at most one mapping for a given path
      segment, i.e., it is illegal to have the same path segment mapped to
      more than one resource.  
    </t>
    
    <t>
      Properties defined on collections behave exactly 
      as do properties on non-collection resources.  A collection MAY
      have additional state such as entity bodies returned by GET.      
    </t>
    <t>
      For all WebDAV-compliant resources A and B, identified by URLs "U"
      and "V", respectively, such that "V" is equal to "U/SEGMENT", A MUST	
      be a collection that contains a mapping from "SEGMENT" to B. &nbsp;So, if
      resource B with URL "http://example.com/bar/blah" is WebDAV compliant
      and if resource A with URL "http://example.com/bar/" is WebDAV	
      compliant, then resource A must be a collection and must contain exactly
      one mapping from "blah" to B.  
    </t>
    <t>
      Although commonly a mapping consists of a single segment and a	
      resource, in general, a mapping consists of a set of segments and a	
      resource. This allows a server to treat a set of segments as	
      equivalent (i.e., either all of the segments are mapped to the same	
      resource, or none of the segments are mapped to a resource). For	
      example, a server that performs case-folding on segments will treat	
      the segments "ab", "Ab", "aB", and "AB" as equivalent. A client can	
      then use any of these segments to identify the resource. Note that a	
      PROPFIND result will select one of these equivalent segments to	
      identify the mapping, so there will be one PROPFIND response element	
      per mapping, not one per segment in the mapping.
    </t>
    <t>
      Collection resources MAY have mappings to non-WebDAV-compliant	
      resources in the HTTP URL namespace hierarchy but are not required to	
      do so. For example, if resource X with URL "http://example.com/bar/blah" 
      is not WebDAV compliant and resource A with "URL http://example.com/bar/" 
      identifies a WebDAV collection, then A may or may not have a mapping from "blah" to X.    
    </t>
    <t>
   If a WebDAV-compliant resource has no WebDAV-compliant internal members in 
   the HTTP URL namespace hierarchy, then the WebDAV-compliant resource 
   is not required to be a collection. 
    </t>
    <t>
   There is a standing convention that when a collection is referred to 
   by its name without a trailing slash, the server MAY handle the 
   request as if the trailing slash were present.  In this case, it 
   SHOULD return a Content-Location header in the response, pointing to 
   the URL ending with the "/".  For example, if a client invokes a 
   method on http://example.com/blah (no trailing slash), the server 
   may respond as if the operation were invoked on 
   http://example.com/blah/ (trailing slash), and should return a 
   Content-Location header with the value http://example.com/blah/. 
   Wherever a server produces a URL referring to a collection, the 
   server SHOULD include the trailing slash. In general, clients SHOULD 
   use the trailing slash form of collection names.  If clients do not use 
   the trailing slash form the client needs to be prepared to see a redirect response.
   Clients will find the DAV:resourcetype property more reliable than the URL 
   to find out if a resource is a collection.
    </t>
    <t>
   Clients MUST be able to support the case where WebDAV resources are 
   contained inside non-WebDAV resources.  For example, if an OPTIONS 
   response from "http://example.com/servlet/dav/collection" indicates 
   WebDAV support, the client cannot assume that 
   "http://example.com/servlet/dav/" or its parent necessarily are 
   WebDAV collections. 
    </t>
  
    <t>
      A typical scenario in which mapped URLs do not appear as members of	
      their parent collection is the case where a server allows links or redirects
      to non-WebDAV resources. For instance, "/col/link" might not appear as a member of	
      "/col/", although the server would respond with a 302 status to a GET	
      request to "/col/link"; thus, the URL "/col/link" would indeed be	
      mapped.	Similarly, a dynamically-generated page might have a URL
      mapping from "/col/index.html", thus this resource might respond with
      a 200 OK to a GET request yet not appear as a member of "/col/".
    </t>
    
    <t>
      Some mappings to even WebDAV-compliant resources might not appear in the
      parent collection.
      An example for this case are servers that support multiple alias URLs	
      for each WebDAV-compliant resource. A server may	
      implement case-insensitive URLs, thus "/col/a" and "/col/A" identify	
      the same resource, yet only either "a" or "A" is reported upon	
      listing the members of "/col".  In cases where a server treats a set of segments
      as equivalent, the server MUST expose only one preferred segment per mapping, 
      consistently chosen, in PROPFIND responses.
    </t>
    
  </section>
  
</section>

<section title="Locking" anchor="locking">
  <t>
   The ability to lock a resource provides a mechanism for serializing 
   access to that resource.  Using a lock, an authoring client can 
   provide a reasonable guarantee that another principal will not 
   modify a resource while it is being edited.  In this way, a client 
   can prevent the "lost update" problem. 
  </t>
  <t>
   This specification allows locks to vary over two client-specified 
   parameters, the number of principals involved (exclusive vs. shared) 
   and the type of access to be granted. This document defines locking 
   for only one access type, write. However, the syntax is extensible, 
   and permits the eventual specification of locking for other access 
   types. 
  </t>
  
  <section title="Lock Model" anchor="lock-model">
    
    <t>This section provides a concise model for how locking behaves.
      Later sections will provide more detail on some of the concepts and
      refer back to these model statements.  Normative statements related to
      LOCK and UNLOCK method handling can be found in the sections on those methods,
      whereas normative statements that cover any method are gathered here.
    </t>

    <t><list style="numbers">
      
      <t>A lock either directly or indirectly locks a resource.</t>
      
      <t>A resource becomes directly locked when a LOCK request to
        a URL of that resource creates a new lock.
        The "lock-root" of the new lock is that URL. If at the time of
        the request, the URL is not mapped to a resource, a new
        empty resource is created and directly locked.</t>
      
      <t>An <xref target="exclusive-lock">exclusive lock</xref> conflicts 
        with any other kind of lock on the same resource,
        whether either lock is direct or indirect. A server MUST NOT create
       conflicting locks on a resource.</t>
      
      <t>For a collection that is locked with a depth-infinity lock L, all member
        resources are indirectly locked.  Changes in membership of such a collection
        affect the set of indirectly locked resources:
        <list style="symbols">
          <t>If a member resource is added to the collection,
            the new member resource MUST NOT already have a conflicting lock,
            because the new resource MUST become indirectly locked by L.  </t>
          <t>If a member resource stops being a member of the collection, 
            then the resource MUST no longer be indirectly locked by L.</t>
        </list>
      </t>
      
      <t>Each lock is identified by a single globally unique <xref 
        target="lock-tokens">lock token</xref>.</t>
      
      <t>An UNLOCK request deletes the lock with the specified lock token.
        After a lock is deleted, no resource is locked by that lock.
      </t>
      
      <t>A lock token is "submitted" in a request when it appears in an "If"
        header (<xref target="write-lock" />, "<xref target="write-lock" format="title" />", discusses when
        token submission is required for write locks).  </t>
            
      <t>If a request causes the lock-root of any lock to become an
        unmapped URL, then the lock MUST also be deleted by that request.</t>
      
    </list></t>

  
  </section>
  
  <section title="Exclusive vs. Shared Locks" anchor="exclusive-lock">
    <t>
   The most basic form of lock is an exclusive lock.  Exclusive locks avoid having to
      deal with content change conflicts, without requiring any coordination other than 
      the methods described in this specification. 
    </t>
    <t>
   However, there are times when the goal of a lock is not to exclude 
   others from exercising an access right but rather to provide a 
   mechanism for principals to indicate that they intend to exercise 
   their access rights.  Shared locks are provided for this case.  A 
   shared lock allows multiple principals to receive a lock.  Hence any 
   principal that has both access privileges and a valid lock can use the locked resource. 
    </t>
    <t>
   With shared locks, there are two trust sets that affect a resource.  
   The first trust set is created by access permissions.  Principals 
   who are trusted, for example, may have permission to write to the 
   resource.  Among those who have access permission to write to the 
   resource, the set of principals who have taken out a shared lock 
   also must trust each other, creating a (typically) smaller trust set 
   within the access permission write set. 
    </t>
    <t>
   Starting with every possible principal on the Internet, in most 
   situations the vast majority of these principals will not have write 
   access to a given resource.  Of the small number who do have write 
   access, some principals may decide to guarantee their edits are free 
   from overwrite conflicts by using exclusive write locks.  Others may 
   decide they trust their collaborators will not overwrite their work 
   (the potential set of collaborators being the set of principals who 
   have write permission) and use a shared lock, which informs their 
   collaborators that a principal may be working on the resource. 
    </t>
    <t>
   The WebDAV extensions to HTTP do not need to provide all of the 
   communications paths necessary for principals to coordinate their 
   activities.  When using shared locks, principals may use any out-of-band communication channel to coordinate their work (e.g., face-to-face
   interaction, written notes, post-it notes on the screen, 
   telephone conversation, email, etc.)  The intent of a shared lock is 
   to let collaborators know who else may be working on a resource. 
    </t>
    <t>
   Shared locks are included because experience from Web-distributed 
   authoring systems has indicated that exclusive locks are often too 
   rigid.  An exclusive lock is used to enforce a particular editing 
   process: take out an exclusive lock, read the resource, perform 
   edits, write the resource, release the lock.  This editing process 
   has the problem that locks are not always properly released, for 
   example, when a program crashes or when a lock creator leaves without 
      unlocking a resource.  While both <xref target="lock-timeout">timeouts</xref> 
      and administrative action 
   can be used to remove an offending lock, neither mechanism may be 
   available when needed; the timeout may be long or the administrator 
   may not be available. 
    </t>
    <t>
      A successful request for a new shared lock MUST 
      result in the generation of a unique lock associated with the 
      requesting principal.  Thus, if five principals have taken out shared write 
      locks on the same resource, there will be five locks and five lock tokens, one for 
      each principal. 
    </t>
  </section>
  
  <section title="Required Support">
   <t>
   A WebDAV-compliant resource is not required to support locking in 
   any form.  If the resource does support locking, it may choose to 
   support any combination of exclusive and shared locks for any access 
   types. 
    </t>
    <t>
   The reason for this flexibility is that locking policy strikes to 
   the very heart of the resource management and versioning systems 
   employed by various storage repositories.  These repositories 
   require control over what sort of locking will be made available.  
   For example, some repositories only support shared write locks, while 
   others only provide support for exclusive write locks, while yet 
   others use no locking at all.  As each system is sufficiently 
   different to merit exclusion of certain locking features, this 
   specification leaves locking as the sole axis of negotiation within 
   WebDAV. 
   </t>
  </section>
  
  <section title="Lock Creator and Privileges" anchor="lock-creator">
    <t>The creator of a lock has special privileges to use the lock to modify the resource.  
      When a locked resource is modified, a server MUST check that the 
        authenticated principal matches the lock creator (in addition to checking
        for valid lock token submission). </t>
    <t>The server MAY allow privileged users other than the lock creator to destroy a lock
      (for example, the resource owner or an administrator).  The 'unlock' privilege
     in <xref target="RFC3744"/> was defined to provide that permission.</t>
    <t>There is no requirement for servers to accept LOCK requests from all users
      or from anonymous users.</t>
    <t>
      Note that having a lock does not confer full privilege to modify the locked resource. 
      Write access and other privileges MUST be enforced through normal 
      privilege or authentication mechanisms, not based on the possible
      obscurity of lock token values. 
    </t>
  </section>
  
  
  <section title="Lock Tokens" anchor="lock-tokens">
    <t>
   A lock token is a type of state token that 
   identifies a particular lock.  Each lock has exactly one unique lock
      token generated by the server.  
    Clients MUST NOT attempt to interpret lock tokens in any way.</t>
    <t>
   Lock token URIs MUST be unique across all resources for all time. 
   This uniqueness constraint allows lock tokens to be submitted across 
   resources and servers without fear of confusion.  Since lock tokens are unique, a client 
    MAY submit a lock token in an If header on a resource other 
   than the one that returned it. 

    </t>
    <t> When a LOCK operation creates a new lock, the new lock token is 
      returned in the Lock-Token response header defined in 
      <xref target="lock-token-header"/>,
      and also in the body of the response.  
    </t>   
      
    <t>
      Servers MAY make lock tokens publicly readable (e.g., in the DAV:lockdiscovery 
      property).  One use case for making lock tokens readable is so that a long-lived
      lock can be removed by the resource owner (the client that obtained the lock might have
      crashed or disconnected before cleaning up the lock).  Except for the case of using UNLOCK
      under user guidance, a client SHOULD NOT use a lock token created by another
      client instance.
    </t>
     <t>
   This specification encourages servers to create Universally Unique
      Identifiers (UUIDs) for lock tokens,
      and to use the URI form defined by "A Universally Unique 
   Identifier (UUID) URN  Namespace" (<xref target="RFC4122"/>).  However, 
   servers are free to use any URI (e.g., from another scheme) so long as it meets the 
   uniqueness requirements.  For example, a valid lock token might be constructed
      using the "opaquelocktoken" scheme defined in <xref target="opaquelocktoken"/>.
    </t>
    <t>Example: "urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6"</t>
    
  </section>
  
  <section title="Lock Timeout" anchor="lock-timeout">
    <t>A lock MAY have a limited lifetime.  The lifetime is suggested by the
      client when creating or refreshing the lock, but the server
      ultimately chooses the timeout value.    Timeout is measured in seconds 
      remaining until lock expiration. 
    </t>
    <t>
      The timeout counter MUST be restarted if a refresh lock request is
      successful (see <xref target="refreshing-locks"/>).  The timeout counter 
      SHOULD NOT be restarted at any other time.
    </t>
    <t>
      If the timeout expires, then the lock SHOULD be removed.  In this case the server
      SHOULD act as if an UNLOCK method was executed by the server on the
      resource using the lock token of the timed-out lock, performed with
      its override authority.  
    </t>
    <t>
      Servers are advised to pay close attention to the values submitted by
      clients, as they will be indicative of the type of activity the
      client intends to perform.  For example, an applet running in a
      browser may need to lock a resource, but because of the instability
      of the environment within which the applet is running, the applet may
      be turned off without warning.  As a result, the applet is likely to
      ask for a relatively small timeout value so that if the applet dies,
      the lock can be quickly harvested.  However, a document management
      system is likely to ask for an extremely long timeout because its
      user may be planning on going offline.
    </t>
    <t>
      A client MUST NOT assume that just because the timeout has expired,
      the lock has immediately been removed.  
    </t>
    <t>      
      Likewise, a client MUST NOT assume that just
      because the timeout has not expired, the lock still exists.
      Clients MUST assume that locks can arbitrarily disappear at any 
      time, regardless of the value given in the Timeout header.  The 
      Timeout header only indicates the behavior of the server if 
      extraordinary circumstances do not occur.  For example, a 
      sufficiently privileged user may remove a lock at any time, or the 
      system may crash in such a way that it loses the record of the 
      lock's existence. 
    </t>
  </section>
  
  <section title="Lock Capability Discovery">
    <t>
   Since server lock support is optional, a client trying to lock a 
   resource on a server can either try the lock and hope for the best, 
   or perform some form of discovery to determine what lock 
   capabilities the server supports.  This is known as lock capability 
   discovery.  A client can determine what lock types the server 
   supports by retrieving the DAV:supportedlock property. 
    </t>
    <t>
   Any DAV-compliant resource that supports the LOCK method MUST 
   support the DAV:supportedlock property. 
    </t>
  </section>
  
  <section title="Active Lock Discovery"> 
    <t>
   If another principal locks a resource that a principal wishes to 
   access, it is useful for the second principal to be able to find out 
   who the first principal is.  For this purpose the DAV:lockdiscovery 
   property is provided.  This property lists all outstanding locks, 
   describes their type, and MAY even provide the lock tokens. 
    </t>
    <t>
   Any DAV-compliant resource that supports the LOCK method MUST 
   support the DAV:lockdiscovery property. 
    </t>
  </section>
    
</section>
  


<section title="Write Lock" anchor="write-lock">
  <t>
   This section describes the semantics specific to the write lock 
   type.  The write lock is a specific instance of a lock type, and is 
   the only lock type described in this specification. 
  </t>
  <t>
   An exclusive write lock protects a resource: it prevents changes by
    any principal other than the lock creator and in any case where the
    lock token is not submitted (e.g., by a client process other than the one 
    holding the lock).
  </t>
  <t>
    Clients MUST submit a lock-token they are authorized to use
    in any request that modifies a write-locked resource.  The list of 
    modifications covered by a write-lock include:
  </t>
  <t><list style="numbers">
    <t>
      A change to any of the following aspects of any write-locked resource:
      <list style="symbols">
        <t>any variant,</t>
        <t>any dead property,</t>
 <t>any live property that is lockable (a live property is lockable
          unless otherwise defined.)</t>
      </list>
    </t>
    <t>For collections, any modification of an internal member URI. 
      An internal member URI of a collection is considered to be modified 
      if it is added, removed, or identifies a different resource.  More
      discussion on write locks and collections is found in <xref target="depth-locks"/>.
    </t>
    <t>
      A modification of the mapping of the root 
      of the write lock, either to another resource or to no resource (e.g., DELETE).
    </t>
  </list>
  </t>
  
  <t>Of the methods defined in HTTP and WebDAV, PUT, POST, PROPPATCH, LOCK, UNLOCK, 
    MOVE, COPY (for the destination resource), DELETE, and MKCOL are affected by
    write locks.  All other HTTP/WebDAV methods defined so far --
    GET in particular -- function independently of a write lock.
  </t>
  
  <t>
   The next few sections describe in more specific terms how write 
   locks interact with various operations. 
  </t>
  
  
  
  
  <section title="Write Locks and Properties">
    <t>
   While those without a write lock may not alter a property on a 
   resource it is still possible for the values of live properties to 
   change, even while locked, due to the requirements of their schemas.  
   Only dead properties and live properties defined as lockable 
   are guaranteed not to change while write locked. 
    </t>
  </section>
  

  <section title="Avoiding Lost Updates">
    <t>
   Although the write locks provide some help in 
   preventing lost updates, they cannot guarantee that updates will 
   never be lost.  Consider the following scenario: 
    </t>
    <t>
   Two clients A and B are interested in editing the resource 
   'index.html'.  Client A is an HTTP client rather than a WebDAV 
   client, and so does not know how to perform locking. 
    </t>
    <t>
   Client A doesn't lock the document, but does a GET, and begins 
   editing. 
    </t>
    <t>
   Client B does LOCK, performs a GET and begins editing. 
    </t>
    <t>
   Client B finishes editing, performs a PUT, then an UNLOCK. 
    </t>
    <t>
   Client A performs a PUT, overwriting and losing all of B's changes. 
    </t>
    <t>
   There are several reasons why the WebDAV protocol itself cannot 
   prevent this situation.  First, it cannot force all clients to use 
   locking because it must be compatible with HTTP clients that do not 
   comprehend locking.  Second, it cannot require servers to support 
   locking because of the variety of repository implementations, some 
   of which rely on reservations and merging rather than on locking.  
   Finally, being stateless, it cannot enforce a sequence of operations 
   like LOCK / GET / PUT / UNLOCK.  
    </t>
    <t>
   WebDAV servers that support locking can reduce the likelihood that 
   clients will accidentally overwrite each other's changes by 
   requiring clients to lock resources before modifying them.  Such 
   servers would effectively prevent HTTP 1.0 and HTTP 1.1 clients from 
   modifying resources. 
    </t>
    <t>
   WebDAV clients can be good citizens by using a lock / retrieve / 
   write /unlock sequence of operations (at least by default) whenever 
   they interact with a WebDAV server that supports locking. 
    </t>
    <t>
   HTTP 1.1 clients can be good citizens, avoiding overwriting other 
   clients' changes, by using entity tags in If-Match headers with any 
   requests that would modify resources.  
    </t>
    <t>
   Information managers may attempt to prevent overwrites by 
   implementing client-side procedures requiring locking before 
   modifying WebDAV resources. 
    </t>
    
  </section>  
  
  <section title="Write Locks and Unmapped URLs" anchor="lock-unmapped-urls">
    <t>
   WebDAV provides the ability to send a LOCK request to an unmapped URL in order to reserve the name for 
   use.  This is a simple way to avoid the lost-update problem on the 
   creation of a new resource (another way is to use If-None-Match 
      header specified in Section 14.26 of <xref target="RFC2616"/>).  It has the side benefit of locking 
   the new resource immediately for use of the creator.
    </t>
    <t>
   Note that the lost-update problem is not an issue for collections because 
   MKCOL can only be used to create a collection, not to overwrite an 
   existing collection.  When trying to lock a collection upon 
   creation, clients can attempt to increase the likelihood of getting the lock by 
      pipelining the MKCOL and LOCK requests together (but because this 
      doesn't convert two separate operations into one atomic operation, 
      there's no guarantee this will work).   
    </t>
    <t>
   A successful lock request to an unmapped URL MUST result in the creation of a 
   locked (non-collection) resource with empty content.  Subsequently, a successful PUT request 
   (with the correct lock token) provides the content for the resource.  Note that
      the LOCK request has no mechanism for the client to provide Content-Type or 
        Content-Language, thus the server will use defaults or empty values and rely
        on the subsequent PUT request for correct values.  
    </t>
    
    <t>
      A resource created with a LOCK is empty but otherwise behaves in every way as a normal 
      resource.  It behaves the same way as a resource created by a PUT
      request with an empty body (and where a Content-Type and Content-Language 
      was not specified), followed by a LOCK request to the same resource.  
      Following from this model, a locked empty resource: 
    </t>
    
    <t><list style="symbols">
      <t>Can be read, deleted, moved, and copied, and in all ways behaves as a 
        regular non-collection resource. </t>
      <t>Appears as a member of its parent collection. </t>
      <t>SHOULD NOT disappear when its lock goes away (clients must 
        therefore be responsible for cleaning up their own mess, as with 
        any other operation or any non-empty resource). </t>
      <t>MAY NOT have values for properties like DAV:getcontentlanguage that 
        haven't been specified yet by the client. </t>
      <t>Can be updated (have content added) with a PUT request.  </t>
      <t>MUST NOT be converted into a collection.  The server MUST fail a MKCOL request 
        (as it would with a MKCOL request to any existing non-collection resource). </t>
      <t>MUST have defined values for DAV:lockdiscovery and DAV:supportedlock 
        properties.</t> 
      <t>The response MUST indicate that a resource was created, by use of 
        the "201 Created" response code (a LOCK request to an existing 
        resource instead will result in 200 OK).  The body must still 
        include the DAV:lockdiscovery property, as with a LOCK request to an 
        existing resource. </t>
    </list></t>
    <t>
      The client is expected to update the locked empty resource shortly 
      after locking it, using PUT and possibly PROPPATCH.  
    </t>
    
    <t>Alternatively and for backwards compatibility to <xref target="RFC2518"/>, servers	
      MAY implement Lock-Null Resources (LNRs) instead (see definition in	
      <xref target="lock-null"/>). Clients can easily interoperate both with servers that	
      support the old model LNRs and the recommended model of "locked empty	
      resources" by only attempting PUT after a LOCK to an unmapped URL,	
      not MKCOL or GET, and by not relying on specific properties of LNRs.
    </t>
    
  </section>
  
  <section title="Write Locks and Collections" anchor="depth-locks">
    <t>
      There are two kinds of collection write locks.  A depth-0 write
      lock on a collection protects the collection properties plus the internal
      member URLs of that one collection, while not protecting the content or properties
      of member resources (if the collection itself has any entity bodies, those 
      are also protected).   A depth-infinity write lock on a collection 
      provides the same protection on that collection and also provides write lock
      protection on every member resource. </t>
    <t>
      Expressed otherwise, a write lock of either kind protects any request that would create a new 
      resource in a write locked collection, any request that would remove 
      an internal member URL of a write locked collection, and 
      any request that would change the segment name of any internal member. 
    </t>
    <t>
     Thus, a collection write lock protects all the following actions:
    </t>
    <t><list style="symbols">
      <t>DELETE a collection's direct internal member, </t>
      <t> MOVE an internal member out of the collection,</t>
      <t>MOVE an internal member into the collection,</t>
      <t>MOVE to rename an internal member within a collection,</t>
      <t>COPY an internal member into a collection, and</t>
      <t>PUT or MKCOL request that would create a new internal member.</t>
    </list></t>
    <t>
   The collection's lock token is required in addition to the lock 
   token on the internal member itself, if it is locked separately. 
    </t>
    <t>
     In addition, a depth-infinity lock affects all write operations to 
     all members of the locked collection.  With a depth-infinity 
     lock, the resource identified by the root of the lock is directly locked, and all its 
     members are indirectly locked.   
    </t>
    <t><list style="symbols">
      <t> Any new resource added as a descendant of a depth-infinity locked 
       collection becomes indirectly locked.  </t>
      <t>Any indirectly locked resource moved out of the locked collection 
       into an unlocked collection is thereafter unlocked. </t>
      <t>Any indirectly locked resource moved out of a locked source 
       collection into a depth-infinity locked target collection remains 
       indirectly locked but is now protected by the lock on the 
       target collection (the target collection's lock token will 
       thereafter be required to make further changes). </t>
    </list></t>
    <t>
    
   If a depth-infinity write LOCK request is issued to a collection 
   containing member URLs identifying resources that are currently 
      locked in a manner that conflicts with the new lock (see <xref target="lock-model"/>,
      point 3), the request 
   MUST fail with a 423 (Locked) status code, and the response SHOULD
   contain the 'no-conflicting-lock' precondition.  
    </t>
    <t>
   If a lock request causes the URL of a resource to be added as an 
   internal member URL of a depth-infinity locked collection, then the 
   new resource MUST be automatically protected by the lock.    
   For example, if the collection /a/b/ is write locked and the 
   resource /c is moved to /a/b/c, then resource /a/b/c will be added to 
   the write lock. 
    </t>
  </section>
  
  <section title="Write Locks and the If Request Header" anchor="submit-lock-token">
    <t>    
   A user agent has to demonstrate knowledge of a lock when 
   requesting an operation on a locked resource.  Otherwise, the following scenario 
   might occur.  In the scenario, program A, run by User A, takes out a write lock on a 
   resource.  Program B, also run by User A, has no knowledge of the 
   lock taken out by program A, yet performs a PUT to the locked 
   resource.  In this scenario, the PUT succeeds because locks are 
   associated with a principal, not a program, and thus program B, 
   because it is acting with principal A's credential, is allowed to 
   perform the PUT.  However, had program B known about the lock, it 
   would not have overwritten the resource, preferring instead to 
   present a dialog box describing the conflict to the user.  Due to 
   this scenario, a mechanism is needed to prevent different programs 
   from accidentally ignoring locks taken out by other programs with 
   the same authorization. 
    </t>
    <t>
   In order to prevent these collisions, a lock token MUST be submitted 
   by an authorized principal for all locked resources that a method 
   may change or the method MUST fail.  A lock token is submitted when 
   it appears in an If header.  For example, if a resource is to be 
   moved and both the source and destination are locked, then two lock 
   tokens must be submitted in the If header, one for the source and 
   the other for the destination. 
    </t>

    <section title="Example - Write Lock and COPY">
    	<figure>
    	  <preamble>&gt;&gt;Request</preamble>
    	  <artwork><![CDATA[
  COPY /~fielding/index.html HTTP/1.1 
  Host: www.example.com 
  Destination: http://www.example.com/users/f/fielding/index.html 
  If: <http://www.example.com/users/f/fielding/index.html> 
      (<urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6>) 
  	  ]]></artwork>
    	</figure>
      <figure>
        <preamble>&gt;&gt;Response</preamble>
        <artwork><![CDATA[
  HTTP/1.1 204 No Content 
        ]]></artwork>
      </figure>
      
      <t>
     In this example, even though both the source and destination are 
     locked, only one lock token must be submitted (the one for the lock on the 
     destination).  This is because the source resource is not modified by 
     a COPY, and hence unaffected by the write lock. In this example, 
     user agent authentication has previously occurred via a mechanism 
     outside the scope of the HTTP protocol, in the underlying transport 
     layer. 
      </t>
    
    </section>
    
    <section title="Example - Deleting a Member of a Locked Collection">
      <t>Consider a collection "/locked" with an exclusive, depth-infinity write lock, 
        and an attempt to delete an internal member "/locked/member":
      </t>
      <figure>
        <preamble>&gt;&gt;Request</preamble>
        <artwork><![CDATA[
  DELETE /locked/member HTTP/1.1
  Host: example.com          
        ]]></artwork>
      </figure>
      <figure>
        <preamble>&gt;&gt;Response</preamble>
        <artwork><![CDATA[
  HTTP/1.1 423 Locked
  Content-Type: application/xml; charset="utf-8"
  Content-Length: xxxx

  <?xml version="1.0" encoding="utf-8" ?>
  <D:error xmlns:D="DAV:">
    <D:lock-token-submitted>
      <D:href>/locked/</D:href>
    </D:lock-token-submitted>
  </D:error>
        ]]></artwork>
      </figure>
      <t>
        Thus, the client would need to submit the lock token with the request
        to make it succeed.  To do that, various forms of the If header (see
        <xref target="if-header"/>) could be used.
      </t>
      
      <t>  
        "No-Tag-List" format:
      </t>
      <figure>
        <artwork><![CDATA[
  If: (<urn:uuid:150852e2-3847-42d5-8cbe-0f4f296f26cf>)
        ]]></artwork>
      </figure>

      <t>
          "Tagged-List" format, for "http://example.com/locked/":
      </t>
      <figure>
        <artwork><![CDATA[      
  If: <http://example.com/locked/>
      (<urn:uuid:150852e2-3847-42d5-8cbe-0f4f296f26cf>)      
        ]]></artwork>
      </figure>
      <t>
      "Tagged-List" format, for "http://example.com/locked/member":
      </t>
      <figure>
        <artwork><![CDATA[      
  If: <http://example.com/locked/member>
      (<urn:uuid:150852e2-3847-42d5-8cbe-0f4f296f26cf>)
        ]]></artwork>
      </figure>
      <t>
        Note that, for the purpose of submitting the lock token, the actual
        form doesn't matter; what's relevant is that the lock token appears
        in the If header, and that the If header itself evaluates to true.
                
      </t>
    </section>
  </section>
  
  <section title="Write Locks and COPY/MOVE">
    <t>
   A COPY method invocation MUST NOT duplicate any write locks active 
   on the source.  However, as previously noted, if the COPY copies the 
   resource into a collection that is locked with a depth-infinity lock, 
   then the resource will be added to the lock. 
    </t>
    <t>
   A successful MOVE request on a write locked resource MUST NOT move 
   the write lock with the resource. However, if there is an existing lock at the 
   destination, the server MUST add the moved resource to the destination lock scope. 
   For example, if the MOVE makes the resource a child 
   of a collection that has a depth-infinity lock, then the 
   resource will be added to that collection's lock. Additionally, if a 
   resource with a depth-infinity lock is moved to a destination 
   that is within the scope of the same lock (e.g., within the 
   URL namespace tree covered by the lock), the moved resource will again 
   be added to the lock. In both these examples, as specified in 
   <xref target="submit-lock-token"/>, an If header must be submitted containing a lock token 
   for both the source and destination.  
    </t>
  </section>
  
  <section title="Refreshing Write Locks">
    <t>
   A client MUST NOT submit the same write lock request twice.  Note 
   that a client is always aware it is resubmitting the same lock 
   request because it must include the lock token in the If header in 
   order to make the request for a resource that is already locked. 
    </t>
    <t>
   However, a client may submit a LOCK request with an If header but 
   without a body.  A server receiving a LOCK request with no body MUST 
   NOT create a new lock -- this form of the LOCK request is only to be used to "refresh" an 
   existing lock (meaning, at minimum, that any timers associated with the lock 
   MUST be reset). 
    </t>

    <t>
      Clients may submit Timeout headers of arbitrary value with their 
      lock refresh requests. Servers, as always, may ignore Timeout headers 
      submitted by the client, and a server MAY refresh a lock with a timeout
      period that is 
   different than the previous timeout period used for the lock, provided it
      advertises the new value in the LOCK refresh response.   
    </t>
    <t>
   If an error is received in response to a refresh LOCK request, the 
   client MUST NOT assume that the lock was refreshed. 
    </t>
  </section>
  
</section>


<section title="General Request and Response Handling" anchor="response-handling">

  <section title="Precedence in Error Handling" anchor="error-precedence">
    <t>Servers MUST return authorization errors in preference to other errors.
      This avoids leaking information about protected resources (e.g., a client
      that finds that a hidden resource exists by seeing a 423 Locked response
      to an anonymous request to the resource).
    </t>
  </section>
     
  <section title="Use of XML">
    <t>
      In HTTP/1.1, method parameter information was exclusively encoded in 
      HTTP headers. Unlike HTTP/1.1, WebDAV encodes method parameter 
      information either in an XML (<xref target="REC-XML"/>) 
      request entity body, or in an HTTP header.  The use of XML to encode 
      method parameters was motivated by the ability to add extra XML 
      elements to existing structures, providing extensibility; and by 
      XML's ability to encode information in ISO 10646 character sets, 
      providing internationalization support.  
    </t>
    <t>
      In addition to encoding method parameters, XML is used in WebDAV to 
      encode the responses from methods, providing the extensibility and 
      internationalization advantages of XML for method output, as well as 
      input. 
    </t>
    <t>
      When XML is used for a request or response body, the Content-Type type 
      SHOULD be application/xml. Implementations MUST accept both text/xml and 
      application/xml in request and response bodies. Use of text/xml is 
      deprecated.
    </t>
    <t>
     All DAV-compliant clients and resources MUST use 
     XML parsers that are compliant with <xref target="REC-XML"/> 
     and <xref target="REC-XML-NAMES"/>.  All 
     XML used in either requests or responses MUST be, at minimum, well 
     formed and use namespaces correctly.  If a server receives XML that is not 
     well-formed, then the server MUST reject the entire request with a 
     400 (Bad Request).  If a client receives XML that is not well-formed in a 
     response, then the client MUST NOT assume anything about the outcome of the 
     executed method and SHOULD treat the server as malfunctioning. 
    </t>
    <t>
      Note that processing XML submitted by an untrusted source may cause risks
      connected to privacy, security, and service quality (see <xref target="security"/>). Servers
      MAY reject questionable requests (even though they consist of well-formed XML),
      for instance, with a 400 (Bad Request) status code and an optional response body
      explaining the problem.
    </t>
    
  </section>
  
  <section title="URL Handling" anchor="url-handling">
    <t>URLs appear in many places in requests and responses.  Interoperability 
      experience with <xref target="RFC2518"/> showed that many clients parsing 
      Multi-Status responses did not fully implement the full Reference Resolution 
      defined in Section 5 of <xref target="RFC3986"/>.  Thus, servers in particular
      need to be careful in handling URLs in responses, to ensure that clients
      have enough context to be able to interpret all the URLs.  The rules in this 
      section apply not only to resource URLs in the 'href' element in Multi-Status responses,
      but also to the Destination and If header resource URLs.
    </t>
    
    <t>The sender has a choice between two approaches: using a relative reference, 
      which is resolved against the Request-URI, or a full URI.  A
      server MUST ensure that every 'href' value within a Multi-Status
      response uses the same format.
    </t>
    
    <t>WebDAV only uses one form of relative reference in its extensions, 
      the absolute path.</t>
    
    <figure>
      <artwork type="abnf2616">
   Simple-ref = absolute-URI | ( path-absolute [ "?" query ] )      
      </artwork>
    </figure>
    
    <t>The absolute-URI, path-absolute and query productions are defined in 
      Sections 4.3, 3.3, and 3.4 of <xref target="RFC3986"/>. 
    </t>
    
    <t>Within Simple-ref productions, senders MUST NOT:
      <list style="symbols">
        <t>use dot-segments ("." or ".."), or</t>
        <t>have prefixes that do not match the Request-URI (using the
          comparison rules defined in Section 3.2.3 of <xref target="RFC2616"/>).</t>
      </list>
    </t>
    
    <t>Identifiers for collections SHOULD end in a '/' character. 
    </t>
    
    <section title="Example - Correct URL Handling">
      <t>Consider the collection http://example.com/sample/ with the internal
        member URL http://example.com/sample/a%20test and the PROPFIND
        request below:</t>
      <figure>
        <preamble>&gt;&gt;Request: </preamble>
        <artwork><![CDATA[
  PROPFIND /sample/ HTTP/1.1
  Host: example.com
  Depth: 1          
        ]]></artwork>
      </figure>
      <t>In this case, the server should return two 'href' elements containing either
        <list style="symbols">
          <t>'http://example.com/sample/' and 'http://example.com/sample/a%20test', or</t>
          <t>'/sample/' and '/sample/a%20test'</t>
        </list>
      </t>
      
      <t>Note that even though the server may be storing the member resource
        internally as 'a test', it has to be percent-encoded when used inside a
        URI reference (see Section 2.1 of <xref target="RFC3986"/>).  Also note that a legal
        URI may still contain characters that need to be escaped within XML
        character data, such as the ampersand character.</t>   
    </section>
  </section>   
  <section title="Required Bodies in Requests">
    <t>
   Some of these new methods do not define bodies.  Servers MUST 
   examine all requests for a body, even when a body was not expected.  
   In cases where a request body is present but would be ignored by a 
   server, the server MUST reject the request with 415 (Unsupported 
   Media Type).  This informs the client (which may have been 
   attempting to use an extension) that the body could not be processed 
   as the client intended. 
    </t>
  </section>  
    
    
  <section title="HTTP Headers for Use in WebDAV" anchor="http-headers">
    <t>
      HTTP defines many headers that can be used in WebDAV requests and
      responses.  Not all of these are appropriate in all situations and
      some interactions may be undefined. 

   Note that HTTP 1.1 requires the Date header in all responses if 
   possible (see Section 14.18, <xref target="RFC2616"></xref>). 
      </t>
    <t>The server MUST do authorization checks before checking any
      HTTP conditional header. </t>
      
  </section>
  
  <section title="ETag" anchor="etag">
    <t>    
   HTTP 1.1 recommends the use of ETags rather than modification dates, for
      cache control, and there are even stronger reasons to prefer ETags
      for authoring. Correct use of ETags is even more important in a 
   distributed authoring environment, because ETags are necessary along 
   with locks to avoid the lost-update problem.  A client might fail to 
   renew a lock, for example, when the lock times out and the client is 
   accidentally offline or in the middle of a long upload.  When a 
   client fails to renew the lock, it's quite possible the resource can 
   still be relocked and the user can go on editing, as long as no 
   changes were made in the meantime. ETags are required for the client 
   to be able to distinguish this case. Otherwise, the client is forced 
   to ask the user whether to overwrite the resource on the server 
   without even being able to tell the user if it has changed. 
   Timestamps do not solve this problem nearly as well as ETags. 
      </t>
      <t>
       Strong ETags are much more useful for authoring use cases than weak ETags
        (see Section 13.3.3 of <xref target="RFC2616"/>).
        Semantic equivalence can be a useful concept but that depends on the 
        document type and the application type, and interoperability might require 
        some agreement or standard outside the scope of this specification and HTTP.
        Note also that weak ETags have certain restrictions in HTTP, e.g., these
        cannot be used in If-Match headers.  
      </t>
    <t>
      Note that the meaning of an ETag in a PUT response is not
      clearly defined either in this document or in RFC 2616 (i.e., whether
      the ETag means that the resource is octet-for-octet equivalent to the 
      body of the PUT request, or whether the server could have made minor
      changes in the formatting or content of the document upon storage).
     This is an HTTP issue, not purely a WebDAV issue.
    </t>
    
      <t>
   Because clients may be forced to prompt users or throw away changed 
   content if the ETag changes, a WebDAV server SHOULD NOT change the 
   ETag (or the Last-Modified time) for a resource that has an unchanged  
   body and location. The ETag represents the state of the body or contents of the 
   resource. There is no similar way to tell if properties have 
   changed. 
      </t>
    </section>
    
    <section title="Including Error Response Bodies" anchor="error-body-intro">
      <t>
   HTTP and WebDAV did not use the bodies of most error responses for 
   machine-parsable information until the specification for Versioning 
        Extensions to WebDAV introduced a mechanism to 
   include more specific information in the body of an error response 
   (Section 1.6 of <xref target="RFC3253"/>). The error body mechanism is 
   appropriate to use with 
   any error response that may take a body but does not already have a 
   body defined. The mechanism is particularly appropriate when a 
   status code can mean many things (for example, 400 Bad Request can 
   mean required headers are missing, headers are incorrectly 
   formatted, or much more).  This error body mechanism is covered in 
        <xref target="pre_post"/>.
      </t>
    </section>
    
    <section title="Impact of Namespace Operations on Cache Validators" 
              anchor="cache-control">
      <t>Note that the HTTP response headers "Etag" and "Last-Modified" (see
      <xref target="RFC2616"/>, Sections 14.19 and 14.29) are defined per URL (not per
      resource), and are used by clients for caching.  Therefore servers
      must ensure that executing any operation that affects the URL
      namespace (such as COPY, MOVE, DELETE, PUT, or MKCOL) does preserve
      their semantics, in particular:
      </t>
      
      <t><list style="symbols">
        <t>For any given URL, the "Last-Modified" value MUST increment every
          time the representation returned upon GET changes (within the
          limits of timestamp resolution).</t>
        <t>For any given URL, an "ETag" value MUST NOT be reused for
          different representations returned by GET.</t>
      </list>
      </t>
      
      <t>In practice this means that servers</t>
      
      <t><list style="symbols">
        <t>might have to increment "Last-Modified" timestamps for every
          resource inside the destination namespace of a namespace
          operation unless it can do so more selectively, and</t>
        <t>similarly, might have to re-assign "ETag" values for these
          resources (unless the server allocates entity tags in a way so
          that they are unique across the whole URL namespace managed by the
          server).</t>
      </list>
      </t>
      
      <t>Note that these considerations also apply to specific use cases, such
      as using PUT to create a new resource at a URL that has been mapped
      before, but has been deleted since then.</t>
      
      <t>Finally, WebDAV properties (such as DAV:getetag and DAV:
      getlastmodified) that inherit their semantics from HTTP headers must
      behave accordingly.</t>
      
    </section>
  </section>
  
<section title="HTTP Methods for Distributed Authoring" anchor="methods">
    
  <section title="PROPFIND Method" anchor="PROPFIND">
    <t>     
   The PROPFIND method retrieves properties defined on the resource 
   identified by the Request-URI, if the resource does not have any 
   internal members, or on the resource identified by the Request-URI 
   and potentially its member resources, if the resource is a 
   collection that has internal member URLs.  All DAV-compliant 
   resources MUST support the PROPFIND method and the propfind XML 
   element (<xref target="propfind-element"/>) along with all XML elements defined for use 
   with that element. 
    </t>
    <t>
   A client MUST submit a Depth header with a value of "0", "1", or 
   "infinity" with a PROPFIND request.  Servers MUST 
   support "0" and "1" depth requests on WebDAV-compliant 
      resources and SHOULD support "infinity" requests. In practice, support for 
      infinite-depth requests MAY be disabled, due to the performance and security concerns
      associated with this behavior.
      Servers SHOULD treat a request without a Depth header as if a "Depth: infinity" header was included. 
    </t>
    <t>
   A client may submit a 'propfind' XML element in the body of the 
   request method describing what information is being requested.  It 
   is possible to: 
    </t>
    <t><list style="symbols">
      <t>Request particular property values, by naming the properties 
     desired within the 'prop' element (the ordering of properties in 
     here MAY be ignored by the server), </t>
      <t>Request property values for those properties defined in this 
     specification (at a minimum) plus dead properties, by using the 'allprop' element        
        (the 'include' element can be used with 'allprop' to instruct 
        the server to also include additional live properties that may 
        not have been returned otherwise),
      </t>
      <t>Request a list of names of all the properties defined on the 
     resource, by using the 'propname' element.  </t>
    </list></t>
    <t>
   A client may choose not to submit a request body.  An empty PROPFIND 
   request body MUST be treated as if it were an 'allprop' request.   
    </t>
    <t>
   Note that 'allprop' does not return values for all live properties. 
   WebDAV servers increasingly have expensively-calculated or lengthy 
   properties (see <xref target="RFC3253"/> and 
   <xref target="RFC3744"/>) 
   and do not return all properties already.  Instead, WebDAV clients 
   can use propname requests to discover what live properties exist, 
   and request named properties when retrieving values.  For a live property
      defined elsewhere, that definition can specify whether or not
      that live property would be returned in 'allprop' requests.
    </t>
    <t>
   All servers MUST support returning a response of content type 
   text/xml or application/xml that contains a multistatus XML element 
   that describes the results of the attempts to retrieve the various 
   properties.  
    </t>
    <t>
   If there is an error retrieving a property, then a proper error 
   result MUST be included in the response.  A request to retrieve the 
   value of a property that does not exist is an error and MUST be 
   noted with a 
   'response' XML element that contains a 404 (Not Found) status value. 
    </t>
    <t>
   Consequently, the 'multistatus' XML element for a collection resource 
   MUST include a 'response' XML element for each member 
   URL of the collection, to whatever depth was requested. It SHOULD NOT 
      include any 'response' elements for resources that are not WebDAV-compliant.
      Each 'response' element MUST contain an 'href' element that contains the 
   URL of the resource on which the properties in the prop XML element 
   are defined.  Results for a PROPFIND on a collection 
   resource are returned as a flat list whose 
      order of entries is not significant.   Note that a resource may have only 
      one value for a property of a given name, so
      the property may only show up once in PROPFIND responses.
    </t>
    <t>
   Properties may be subject to access control. In the case of 'allprop'
   and 'propname' requests, if a principal does not have the right to know whether 
   a particular property exists, then the property MAY be silently 
   excluded from the response. 
    </t>
    <t>
   Some PROPFIND results MAY be cached, with care, as there is no cache validation
      mechanism for most properties.  This method is both 
   safe and idempotent (see Section 9.1 of <xref target="RFC2616"/>).
    </t>

    <section title="PROPFIND Status Codes">
      <t>This section, as with similar sections for other methods, provides some
        guidance on error codes and preconditions or postconditions (defined 
        in <xref target="pre_post"/>) that might be particularly useful with
        PROPFIND.
      </t>
      
      <t>
   403 Forbidden  - A server MAY reject 
   PROPFIND requests on collections with depth header of "Infinity", in 
   which case it SHOULD use this error with the precondition code
   'propfind-finite-depth' inside the error body. 
      </t>

    </section>
    
    <section title="Status Codes for Use in 'propstat' Element" anchor="PROPFIND-multistatus">
      <t>
        In PROPFIND responses, information about individual properties is	
        returned inside 'propstat' elements (see <xref target="propstat"/>), each	
        containing an individual 'status' element containing information	
        about the properties appearing in it. The list below summarizes the	
        most common status codes used inside 'propstat'; however, clients	
        should be prepared to handle other 2/3/4/5xx series status codes as	
        well.
      </t>

    <t>200 OK - A property exists and/or its value is successfully returned.</t>
    
    <t>401 Unauthorized - The property cannot be viewed without appropriate authorization.</t>
    
    <t>403 Forbidden - The property cannot be viewed regardless of authentication.</t>
    
    <t>404 Not Found - The property does not exist.</t>

    </section>
    
    <section title="Example - Retrieving Named Properties">
      <figure>
        <preamble>&gt;&gt;Request</preamble>
        <artwork><![CDATA[
  PROPFIND /file HTTP/1.1 
  Host: www.example.com 
  Content-type: application/xml; charset="utf-8" 
  Content-Length: xxxx 
    
  <?xml version="1.0" encoding="utf-8" ?> 
  <D:propfind xmlns:D="DAV:"> 
    <D:prop xmlns:R="http://ns.example.com/boxschema/"> 
      <R:bigbox/> 
      <R:author/> 
      <R:DingALing/> 
      <R:Random/> 
    </D:prop> 
  </D:propfind> 
  ]]>
        </artwork>
      </figure>
      <figure>
        <preamble>&gt;&gt;Response</preamble>
        <artwork><![CDATA[
  HTTP/1.1 207 Multi-Status 
  Content-Type: application/xml; charset="utf-8" 
  Content-Length: xxxx 
    
  <?xml version="1.0" encoding="utf-8" ?> 
  <D:multistatus xmlns:D="DAV:"> 
    <D:response xmlns:R="http://ns.example.com/boxschema/"> 
      <D:href>http://www.example.com/file</D:href> 
      <D:propstat> 
        <D:prop> 
          <R:bigbox> 
            <R:BoxType>Box type A</R:BoxType> 
          </R:bigbox> 
          <R:author> 
            <R:Name>J.J. Johnson</R:Name> 
          </R:author> 
        </D:prop> 
        <D:status>HTTP/1.1 200 OK</D:status> 
      </D:propstat> 
      <D:propstat> 
        <D:prop><R:DingALing/><R:Random/></D:prop> 
        <D:status>HTTP/1.1 403 Forbidden</D:status> 
        <D:responsedescription> The user does not have access to the 
   DingALing property. 
        </D:responsedescription> 
      </D:propstat> 
    </D:response> 
    <D:responsedescription> There has been an access violation error.
    </D:responsedescription> 
  </D:multistatus> 
          ]]>
        </artwork>
      </figure>
      
      <t>
   In this example, PROPFIND is executed on a non-collection resource 
   http://www.example.com/file.  The propfind XML element specifies the 
   name of four properties whose values are being requested. In this 
   case, only two properties were returned, since the principal issuing 
   the request did not have sufficient access rights to see the third 
   and fourth properties. 
      </t>
    </section>
    

    
    <section title="Example - Using 'propname' to Retrieve All Property Names">
    
      <figure>
        <preamble>&gt;&gt;Request</preamble>
        <artwork><![CDATA[
  PROPFIND /container/ HTTP/1.1 
  Host: www.example.com 
  Content-Type: application/xml; charset="utf-8" 
  Content-Length: xxxx 
      
  <?xml version="1.0" encoding="utf-8" ?> 
  <propfind xmlns="DAV:"> 
    <propname/> 
  </propfind> 
    ]]>
        </artwork>
      </figure>
      <figure>
        <preamble>&gt;&gt;Response</preamble>
        <artwork><![CDATA[
  HTTP/1.1 207 Multi-Status 
  Content-Type: application/xml; charset="utf-8" 
  Content-Length: xxxx 
      
  <?xml version="1.0" encoding="utf-8" ?> 
  <multistatus xmlns="DAV:"> 
    <response> 
      <href>http://www.example.com/container/</href> 
      <propstat> 
        <prop xmlns:R="http://ns.example.com/boxschema/"> 
          <R:bigbox/> 
          <R:author/> 
          <creationdate/> 
          <displayname/> 
          <resourcetype/> 
          <supportedlock/> 
        </prop> 
        <status>HTTP/1.1 200 OK</status> 
      </propstat> 
    </response> 
    <response> 
      <href>http://www.example.com/container/front.html</href> 
      <propstat> 
        <prop xmlns:R="http://ns.example.com/boxschema/"> 
          <R:bigbox/> 
          <creationdate/> 
          <displayname/> 
          <getcontentlength/> 
          <getcontenttype/> 
          <getetag/> 
          <getlastmodified/> 
          <resourcetype/> 
          <supportedlock/> 
        </prop> 
        <status>HTTP/1.1 200 OK</status> 
      </propstat> 
    </response> 
  </multistatus> 
        ]]></artwork>
      </figure>

      <t>
   In this example, PROPFIND is invoked on the collection resource 
   http://www.example.com/container/, with a propfind XML element 
   containing the propname XML element, meaning the name of all 
   properties should be returned.  Since no Depth header is present, it 
   assumes its default value of "infinity", meaning the name of the 
   properties on the collection and all its descendants should be 
   returned. 
      </t>
      <t>
   Consistent with the previous example, resource 
   http://www.example.com/container/ has six properties defined on it: 
   bigbox and author in the "http://ns.example.com/boxschema/" 
   namespace, and creationdate, displayname, resourcetype, and 
   supportedlock in the "DAV:" namespace.   
      </t>
      <t>
   The resource http://www.example.com/container/index.html, a member 
   of the "container" collection, has nine properties defined on it, 
   bigbox in the "http://ns.example.com/boxschema/" namespace and 
   creationdate, displayname, getcontentlength, getcontenttype, 
   getetag, getlastmodified, resourcetype, and supportedlock in the 
   "DAV:" namespace. 
      </t>
      <t>
   This example also demonstrates the use of XML namespace scoping and 
   the default namespace.  Since the "xmlns" attribute does not contain 
   a prefix, the namespace applies by default to all enclosed elements.  
   Hence, all elements that do not explicitly state the namespace to 
   which they belong are members of the "DAV:" namespace. 
      </t>
    </section>
    
    <section title="Example - Using So-called 'allprop'">
      <t>Note that 'allprop', despite its name, which remains for backward-compatibility,
        does not return every property, but only dead properties and the live properties
        defined in this specification.</t>
    
      <figure>
        <preamble>&gt;&gt;Request</preamble>
        <artwork><![CDATA[
  PROPFIND /container/ HTTP/1.1
  Host: www.example.com
  Depth: 1
  Content-Type: application/xml; charset="utf-8"
  Content-Length: xxxx

  <?xml version="1.0" encoding="utf-8" ?>
  <D:propfind xmlns:D="DAV:">
    <D:allprop/>
  </D:propfind>
]]>
        </artwork>
      </figure>
      <figure>
        <preamble>&gt;&gt;Response</preamble>
        <artwork><![CDATA[
  HTTP/1.1 207 Multi-Status
  Content-Type: application/xml; charset="utf-8"
  Content-Length: xxxx

  <?xml version="1.0" encoding="utf-8" ?>
  <D:multistatus xmlns:D="DAV:">
    <D:response>
      <D:href>/container/</D:href>
      <D:propstat>
        <D:prop xmlns:R="http://ns.example.com/boxschema/">
          <R:bigbox><R:BoxType>Box type A</R:BoxType></R:bigbox>
          <R:author><R:Name>Hadrian</R:Name></R:author>
          <D:creationdate>1997-12-01T17:42:21-08:00</D:creationdate>
          <D:displayname>Example collection</D:displayname>
          <D:resourcetype><D:collection/></D:resourcetype>
          <D:supportedlock>
            <D:lockentry>
              <D:lockscope><D:exclusive/></D:lockscope>
              <D:locktype><D:write/></D:locktype>
            </D:lockentry>
            <D:lockentry>
              <D:lockscope><D:shared/></D:lockscope>
              <D:locktype><D:write/></D:locktype>
            </D:lockentry>
          </D:supportedlock>
        </D:prop>
        <D:status>HTTP/1.1 200 OK</D:status>
      </D:propstat>
    </D:response>
    <D:response>
      <D:href>/container/front.html</D:href>
      <D:propstat>
        <D:prop xmlns:R="http://ns.example.com/boxschema/">
          <R:bigbox><R:BoxType>Box type B</R:BoxType>
          </R:bigbox>
          <D:creationdate>1997-12-01T18:27:21-08:00</D:creationdate>
          <D:displayname>Example HTML resource</D:displayname>
          <D:getcontentlength>4525</D:getcontentlength>
          <D:getcontenttype>text/html</D:getcontenttype>
          <D:getetag>"zzyzx"</D:getetag>
          <D:getlastmodified
            >Mon, 12 Jan 1998 09:25:56 GMT</D:getlastmodified>
          <D:resourcetype/>
          <D:supportedlock>
            <D:lockentry>
              <D:lockscope><D:exclusive/></D:lockscope>
              <D:locktype><D:write/></D:locktype>
            </D:lockentry>
            <D:lockentry>
              <D:lockscope><D:shared/></D:lockscope>
              <D:locktype><D:write/></D:locktype>
            </D:lockentry>
          </D:supportedlock>
        </D:prop>
        <D:status>HTTP/1.1 200 OK</D:status>
      </D:propstat>
    </D:response>
  </D:multistatus>
        ]]></artwork>
      </figure>
      <t>
   In this example, PROPFIND was invoked on the resource
   http://www.example.com/container/ with a Depth header of 1, meaning the
   request applies to the resource and its children, and a propfind XML
   element containing the allprop XML element, meaning the request
   should return the name and value of all the dead properties defined 
   on the resources, plus the name and value of all the properties defined
   in this specification.  This example illustrates the use of relative references
   in the 'href' elements of the response.
      </t>
      <t>
   The resource http://www.example.com/container/ has six properties defined
   on it:
   'bigbox' and 'author in the "http://ns.example.com/boxschema/" namespace,
   DAV:creationdate, DAV:displayname, DAV:resourcetype, and DAV:supportedlock.
      </t>
      <t>
   The last four properties are WebDAV-specific, defined in <xref target="property-definitions"/>.
   Since GET is not supported on this resource, the get* properties
   (e.g., DAV:getcontentlength) are not defined on this resource. The WebDAV-specific 
   properties assert that "container" was created on December
   1, 1997, at 5:42:21PM, in a time zone 8 hours west of GMT
   (DAV:creationdate), has a name of "Example collection" (DAV:displayname), a
   collection resource type (DAV:resourcetype), and supports exclusive write
   and shared write locks (DAV:supportedlock).
      </t>
      <t>
   The resource http://www.example.com/container/front.html has nine
   properties defined on it:
      </t>
      <t>
   'bigbox' in the "http://ns.example.com/boxschema/" namespace (another instance of the "bigbox"
   property type), DAV:creationdate, DAV:displayname,
   DAV:getcontentlength, DAV:getcontenttype, DAV:getetag,
   DAV:getlastmodified, DAV:resourcetype, and DAV:supportedlock.
      </t>
      <t>
   The DAV-specific properties assert that "front.html" was created on
   December 1, 1997, at 6:27:21PM, in a time zone 8 hours west of GMT
   (DAV:creationdate), has a name of "Example HTML resource" (DAV:displayname),
   a content length of 4525 bytes (DAV:getcontentlength), a MIME type of
   "text/html" (DAV:getcontenttype), an entity tag of "zzyzx" (DAV:getetag), was
   last modified on Monday, January 12, 1998, at 09:25:56 GMT
   (DAV:getlastmodified), has an empty resource type, meaning that it is not
   a collection (DAV:resourcetype), and supports both exclusive write and
   shared write locks (DAV:supportedlock).

      </t>
    </section>
    
    <section title="Example - Using 'allprop' with 'include'">
      
      <figure>
        <preamble>&gt;&gt;Request</preamble>
        <artwork><![CDATA[
  PROPFIND /mycol/ HTTP/1.1 
  Host: www.example.com 
  Depth: 1 
  Content-Type: application/xml; charset="utf-8" 
  Content-Length: xxxx 
      
  <?xml version="1.0" encoding="utf-8" ?> 
  <D:propfind xmlns:D="DAV:"> 
    <D:allprop/>
    <D:include> 
      <D:supported-live-property-set/> 
      <D:supported-report-set/> 
    </D:include> 
  </D:propfind> 
        ]]></artwork>
      </figure>
      <t>
        In this example, PROPFIND is executed on the resource 
        http://www.example.com/mycol/ and its internal member resources.  The client requests the values of 
        all live properties defined in this specification, plus all dead properties, plus two
        more live properties defined in <xref target="RFC3253"/>. The response is not shown. 
      </t>
    </section>
    
  </section>
  
  <section title="PROPPATCH Method" anchor="PROPPATCH">
    <t>
   The PROPPATCH method processes instructions specified in the request 
   body to set and/or remove properties defined on the resource 
   identified by the Request-URI. 
    </t>
    <t>
   All DAV-compliant resources MUST support the PROPPATCH method and 
   MUST process instructions that are specified using the 
   propertyupdate, set, and remove XML elements.  Execution of the 
   directives in this method is, of course, subject to access control 
   constraints.  DAV-compliant resources SHOULD support the setting of 
   arbitrary dead properties. 
    </t>
    <t>
   The request message body of a PROPPATCH method MUST contain the 
   propertyupdate XML element.  </t>
      
      <t>Servers MUST process PROPPATCH instructions in 
   document order (an exception to the normal rule that ordering is 
   irrelevant). Instructions MUST either all be executed or none 
   executed. Thus, if any error occurs during processing, all executed 
   instructions MUST be undone and a proper error result returned. 
   Instruction processing details can be found in the definition of the 
   set and remove instructions in Sections
   <xref target="remove-element" format="counter"/> and
   <xref target="set-element" format="counter"/>. 
      </t>
    <t>
    If a server attempts to make any of the property changes in a PROPPATCH request
      (i.e., the request is not rejected for high-level errors before processing the body),
      the response MUST be a Multi-Status response as described in <xref target="PROPPATCH-status"/>.
    </t>
    <t>
      This method is idempotent, but not safe (see Section 9.1 of 
      <xref target="RFC2616"/>). Responses to this method MUST NOT be cached.
    </t>    
    
    
    <section title="Status Codes for Use in 'propstat' Element" anchor="PROPPATCH-status">
      <t>
        In PROPPATCH responses, information about individual properties is	
        returned inside 'propstat' elements (see <xref target="propstat"/>), each	
        containing an individual 'status' element containing information	
        about the properties appearing in it. The list below summarizes the	
        most common status codes used inside 'propstat'; however, clients	
        should be prepared to handle other 2/3/4/5xx series status codes as	
        well.
      </t>
      <t>
   200 (OK) - The property set or change succeeded.   Note that if this
   appears for one property, it appears for every property in the response,
        due to the atomicity of PROPPATCH.
      </t>
      <t>
   403 (Forbidden) - The client, for reasons the server chooses not to 
   specify, cannot alter one of the properties. 
      </t>
      <t>
   403 (Forbidden): The client has attempted to set a protected
   property, such as DAV:getetag.  If returning this error, the server
   SHOULD use the precondition code 'cannot-modify-protected-property' inside the response body.
      </t>
      <t>
   409 (Conflict) - The client has provided a value whose semantics are 
   not appropriate for the property.   
      </t>
      <t>
   424 (Failed Dependency) - The property change could not be made because
   of another property change that failed.
      </t>
      <t>
   507 (Insufficient Storage) - The server did not have sufficient 
   space to record the property. 
      </t>
    </section>
    
    <section title="Example - PROPPATCH">
    
      <figure>
        <preamble>&gt;&gt;Request</preamble>
        <artwork><![CDATA[
  PROPPATCH /bar.html HTTP/1.1 
  Host: www.example.com 
  Content-Type: application/xml; charset="utf-8" 
  Content-Length: xxxx 

  <?xml version="1.0" encoding="utf-8" ?> 
  <D:propertyupdate xmlns:D="DAV:"   
          xmlns:Z="http://ns.example.com/standards/z39.50/">
    <D:set> 
      <D:prop> 
        <Z:Authors> 
          <Z:Author>Jim Whitehead</Z:Author> 
          <Z:Author>Roy Fielding</Z:Author> 
        </Z:Authors> 
      </D:prop> 
    </D:set> 
    <D:remove> 
      <D:prop><Z:Copyright-Owner/></D:prop> 
    </D:remove> 
  </D:propertyupdate> 
    ]]>
        </artwork>
      </figure>
      <figure>
        <preamble>&gt;&gt;Response</preamble>
        <artwork><![CDATA[
  HTTP/1.1 207 Multi-Status 
  Content-Type: application/xml; charset="utf-8" 
  Content-Length: xxxx 
  
  <?xml version="1.0" encoding="utf-8" ?> 
  <D:multistatus xmlns:D="DAV:" 
          xmlns:Z="http://ns.example.com/standards/z39.50/"> 
    <D:response> 
      <D:href>http://www.example.com/bar.html</D:href> 
      <D:propstat> 
        <D:prop><Z:Authors/></D:prop> 
        <D:status>HTTP/1.1 424 Failed Dependency</D:status> 
      </D:propstat> 
      <D:propstat> 
        <D:prop><Z:Copyright-Owner/></D:prop> 
        <D:status>HTTP/1.1 409 Conflict</D:status> 
      </D:propstat> 
      <D:responsedescription> Copyright Owner cannot be deleted or 
        altered.</D:responsedescription> 
    </D:response> 
  </D:multistatus> 
        ]]></artwork>
      </figure>
      <t>
   In this example, the client requests the server to set the value of 
   the "Authors" property in the "http://ns.example.com/standards/z39.50/" 
   namespace, and to remove the property "Copyright-Owner" in the 
   same namespace.  Since the 
   Copyright-Owner property could not be removed, no property 
   modifications occur.  The 424 (Failed Dependency) status code for 
   the Authors property indicates this action would have succeeded if 
   it were not for the conflict with removing the Copyright-Owner 
   property. 
      </t>
    </section>
  </section>
  
  <section title="MKCOL Method">
    <t>
   MKCOL creates a new collection resource at the location specified by 
   the Request-URI.  If the Request-URI is already mapped to a resource,
   then the MKCOL MUST fail.  During MKCOL processing, a 
   server MUST make the Request-URI an internal member of its parent collection, 
   unless the Request-URI is "/".  If no such ancestor exists, the 
   method MUST fail.  When the MKCOL operation creates a new collection 
   resource, all ancestors MUST already exist, or the method MUST fail 
   with a 409 (Conflict) status code.  For example, if a request to 
   create collection /a/b/c/d/ is made, and /a/b/c/ does not exist, the 
   request must fail. 
    </t>
    <t>
   When MKCOL is invoked without a request body, the newly created 
   collection SHOULD have no members. 
    </t>
    <t>
   A MKCOL request message may contain a message body.  The precise behavior of 
   a MKCOL request when the body is present is undefined, but limited to creating 
   collections, members of a collection, bodies of members, and 
   properties on the collections or members.  If the server receives a 
   MKCOL request entity type it does not support or understand, it MUST 
   respond with a 415 (Unsupported Media Type) status code.  If the 
   server decides to reject the request based on the presence of an 
   entity or the type of an entity, it should use the 415 (Unsupported 
   Media Type) status code. 
    </t>
    <t>
      This method is idempotent, but not safe (see Section 9.1 of 
      <xref target="RFC2616"/>). Responses to this method MUST NOT be cached.
    </t>    
    
    <section title="MKCOL Status Codes">
      <t> In addition to the general status codes possible, the following
        status codes have specific applicability to MKCOL:

      </t>
      <t>
   201 (Created) - The collection was created. 
      </t>
      <t>
   403 (Forbidden) - This indicates at least one of two conditions: 1) 
   the server does not allow the creation of collections at the given 
   location in its URL namespace, or 2) the parent collection of the 
   Request-URI exists but cannot accept members. 
      </t>
      <t>
   405 (Method Not Allowed) - MKCOL can only be executed on an unmapped 
   URL. 
      </t>
      <t>
   409 (Conflict) - A collection cannot be made at the Request-URI 
   until one or more intermediate collections have been created.  The 
   server MUST NOT create those intermediate collections automatically. 
      </t>
      <t>
   415 (Unsupported Media Type) - The server does not support the 
      request body type (although bodies are legal on MKCOL requests,
        since this specification doesn't define any, the server is likely
        not to support any given body type).
      </t>
      <t>
   507 (Insufficient Storage) - The resource does not have sufficient 
   space to record the state of the resource after the execution of 
   this method. 
      </t>
    </section>
    
    <section title="Example - MKCOL">
      <t>
   This example creates a collection called /webdisc/xfiles/ on the 
   server www.example.com. 
      </t>
      
      <figure>
        <preamble>&gt;&gt;Request</preamble>
        <artwork><![CDATA[
  MKCOL /webdisc/xfiles/ HTTP/1.1 
  Host: www.example.com 
  ]]>
        </artwork>
      </figure>
      <figure>
        <preamble>&gt;&gt;Response</preamble>
        <artwork><![CDATA[
  HTTP/1.1 201 Created 
        ]]></artwork>
      </figure>
    </section>
  </section>
  
  
  <section title="GET, HEAD for Collections">
    <t>
   The semantics of GET are unchanged when applied to a collection, 
   since GET is defined as, "retrieve whatever information (in the form 
   of an entity) is identified by the Request-URI" <xref target="RFC2616"/>.  GET, when 
   applied to a collection, may return the contents of an "index.html" 
   resource, a human-readable view of the contents of the collection, 
   or something else altogether. Hence, it is possible that the result 
   of a GET on a collection will bear no correlation to the membership 
   of the collection. 
    </t>
    <t>
   Similarly, since the definition of HEAD is a GET without a response 
   message body, the semantics of HEAD are unmodified when applied to 
   collection resources. 
    </t>
  </section>
  
  <section title="POST for Collections">
    <t>
   Since by definition the actual function performed by POST is 
   determined by the server and often depends on the particular 
   resource, the behavior of POST when applied to collections cannot be 
   meaningfully modified because it is largely undefined.  Thus, the 
   semantics of POST are unmodified when applied to a collection. 
    </t>
  </section>
  
  <section title="DELETE Requirements"> 
    <t>
      DELETE is defined in <xref target="RFC2616"/>, Section 9.7, to "delete the resource
      identified by the Request-URI".  However, WebDAV
      changes some DELETE handling requirements.</t>

    
    <t>
        A server processing a successful DELETE request:
      <list><t>
     MUST destroy locks rooted on the deleted resource 
        </t>
        <t>
   MUST remove the mapping from the Request-URI to any resource.  
          
        </t>
      </list>
          Thus, after a successful DELETE operation 
   (and in the absence of other actions), a subsequent GET/HEAD/PROPFIND 
   request to the target Request-URI MUST return 404 (Not Found). 
    </t>    
      
    <section title="DELETE for Collections" anchor="delete-collections">
      <t>
   The DELETE method on a collection MUST act as if a "Depth: infinity" 
   header was used on it.  A client MUST NOT submit a Depth header with 
   a DELETE on a collection with any value but infinity. 
      </t>
      <t>
   DELETE instructs that the collection specified in the Request-URI 
   and all resources identified by its internal member URLs are to be 
   deleted. 
      </t>
      <t>
   If any resource identified by a member URL cannot be deleted, then 
   all of the member's ancestors MUST NOT be deleted, so as to maintain 
   URL namespace consistency.        
      </t>
      <t>
   Any headers included with DELETE MUST be applied in processing every 
   resource to be deleted. 
      </t>
      <t>
   When the DELETE method has completed processing, it MUST result in a 
   consistent URL namespace. 
      </t>
      <t>
   If an error occurs deleting a member resource (a resource other 
   than the resource identified in the Request-URI), then the response 
   can be a 207 (Multi-Status). Multi-Status is used here to indicate 
   which internal resources could NOT be deleted, including an error 
   code, which should help the client understand which resources caused 
   the failure.  For example, the Multi-Status body could include a 
   response with status 423 (Locked) if an internal resource was 
   locked.   
      </t>
      <t>
   The server MAY return a 4xx status response, rather than a 207,
   if the request failed completely. 
      </t>
      <t>
   424 (Failed Dependency) status codes SHOULD NOT be in the 207 (Multi-Status)
   response for DELETE.  They can be safely left out because the client will know 
   that the ancestors of a resource could not be deleted when the 
   client receives an error for the ancestor's progeny.  Additionally, 
   204 (No Content) errors SHOULD NOT be returned in the 207 (Multi-Status).  The
   reason for this prohibition is that 204 (No Content) 
   is the default success code. 
      </t>
    </section>
    
    <section title="Example - DELETE" anchor="DELETE-example">
      <figure>
        <preamble>&gt;&gt;Request</preamble>
        <artwork><![CDATA[
  DELETE  /container/ HTTP/1.1 
  Host: www.example.com 
  ]]>
        </artwork>
      </figure>
      <figure>
        <preamble>&gt;&gt;Response</preamble>
        <artwork><![CDATA[
  HTTP/1.1 207 Multi-Status 
  Content-Type: application/xml; charset="utf-8" 
  Content-Length: xxxx 
      
  <?xml version="1.0" encoding="utf-8" ?> 
  <d:multistatus xmlns:d="DAV:"> 
    <d:response> 
      <d:href>http://www.example.com/container/resource3</d:href> 
      <d:status>HTTP/1.1 423 Locked</d:status> 
      <d:error><d:lock-token-submitted/></d:error>
    </d:response> 
  </d:multistatus> 
        ]]></artwork>
      </figure>

      <t>
   In this example, the attempt to delete 
   http://www.example.com/container/resource3 failed because it is 
   locked, and no lock token was submitted with the request. 
   Consequently, the attempt to delete 
   http://www.example.com/container/ also failed. Thus, the client knows 
   that the attempt to delete http://www.example.com/container/ must 
   have also failed since the parent cannot be deleted unless its 
   child has also been deleted.  Even though a Depth header has not 
   been included, a depth of infinity is assumed because the method is 
   on a collection. 
      </t>
    </section>
  </section>
  
  <section title="PUT Requirements">
  
    <section title="PUT for Non-Collection Resources" anchor="put-resources">
      <t>
   A PUT performed on an existing resource replaces the GET response 
   entity of the resource.  Properties defined on the resource may be 
   recomputed during PUT processing but are not otherwise affected.  
   For example, if a server recognizes the content type of the request 
   body, it may be able to automatically extract information that could 
   be profitably exposed as properties. 
      </t>
      <t>
   A PUT that would result in the creation of a resource without an 
   appropriately scoped parent collection MUST fail with a 409 
   (Conflict). 
      </t>
      <t>
        A PUT request allows a client to indicate what media type an entity body has,
        and whether it should change if overwritten.  Thus, a client SHOULD provide a Content-Type for a new
   resource if any is known.  If the client does not provide a Content-Type for a new 
        resource, the server MAY create a resource with no Content-Type assigned, 
        or it MAY attempt to assign a Content-Type.  
      </t>
      <t>
        Note that although a recipient ought generally to treat metadata supplied with an
        HTTP request as authoritative, in practice there's no guarantee that a
        server will accept client-supplied metadata (e.g., any request header beginning 
        with "Content-").  Many servers 
        do not allow configuring the Content-Type on a per-resource basis in 
        the first place.  Thus, clients can't always rely on
        the ability to directly influence the content type by including a
        Content-Type request header.
      </t>
    </section>
    
    <section title="PUT for Collections">
      <t>
        This specification does not define the behavior of the PUT method 
        for existing collections.  A PUT request to an existing collection MAY 
        be treated as an error (405 Method Not Allowed).
      </t>
      <t>
        The MKCOL method is defined to create collections.
     </t>
    </section>
    
  </section>
  
  <section title="COPY Method" anchor="COPY"> 
     <t>
   The COPY method creates a duplicate of the source resource
   identified by the Request-URI, in the destination resource 
   identified by the URI in the Destination header.  The Destination 
   header MUST be present.  The exact behavior of the COPY method 
   depends on the type of the source resource.  
    </t>
    <t>
   All WebDAV-compliant resources MUST support the COPY method.  
   However, support for the COPY method does not guarantee the ability 
   to copy a resource. For example, separate programs may control 
   resources on the same server.  As a result, it may not be possible 
   to copy a resource to a location that appears to be on the same 
   server. 
    </t>
    <t>
      This method is idempotent, but not safe (see Section 9.1 of 
      <xref target="RFC2616"/>). Responses to this method MUST NOT be cached.
    </t>    
    <section title="COPY for Non-collection Resources">
      <t>
   When the source resource is not a collection, the result of the COPY 
   method is the creation of a new resource at the destination whose 
   state and behavior match that of the source resource as closely as 
   possible.  Since the environment at the destination may be different 
   than at the source due to factors outside the scope of control of 
   the server, such as the absence of resources required for correct 
   operation, it may not be possible to completely duplicate the 
   behavior of the resource at the destination. Subsequent alterations 
   to the destination resource will not modify the source resource.  
   Subsequent alterations to the source resource will not modify the 
   destination resource. 
      </t>
    </section>
    
    <section title="COPY for Properties" anchor="copy-properties">
      <t>
   After a successful COPY invocation, all dead properties on the 
   source resource SHOULD be duplicated on the destination resource.  Live properties described 
   in this document SHOULD be duplicated as identically behaving live 
   properties at the destination resource, but not necessarily with the 
   same values.  Servers SHOULD NOT convert live properties into dead
   properties on the destination resource, because clients may then draw
   incorrect conclusions about the state or functionality of a resource. 
        Note that some live properties are defined such that the absence of the property
        has a specific meaning (e.g., a flag with one meaning if present, and the opposite if 
        absent), and in these cases, a successful COPY might result in the 
        property being reported as "Not Found" in subsequent requests.        
      </t>
      <t>
   When the destination is an unmapped URL, a COPY operation creates a new resource much like a PUT operation 
   does.  Live properties that are related to resource creation (such 
   as DAV:creationdate) should have their values set accordingly. 
      </t>
    </section>
    
    <section title="COPY for Collections" anchor="copy-collections">
      <t>
   The COPY method on a collection without a Depth header MUST act as 
   if a Depth header with value "infinity" was included.  A client may 
   submit a Depth header on a COPY on a collection with a value of "0" 
   or "infinity".  Servers MUST support the "0" and "infinity" Depth 
   header behaviors on WebDAV-compliant resources. 
      </t>
      <t>
   An infinite-depth COPY instructs that the collection resource 
   identified by the Request-URI is to be copied to the location 
   identified by the URI in the Destination header, and all its 
   internal member resources are to be copied to a location relative to 
   it, recursively through all levels of the collection hierarchy. Note
   that an infinite-depth COPY of /A/ into /A/B/ could lead to infinite
   recursion if not handled correctly.
      </t>
      <t>
   A COPY of "Depth: 0" only instructs that the collection and its 
   properties, but not resources identified by its internal member URLs, 
   are to be copied. 
      </t>
      <t>
   Any headers included with a COPY MUST be applied in processing every 
   resource to be copied with the exception of the Destination header. 
      </t>
      <t>
   The Destination header only specifies the destination URI for the 
   Request-URI. When applied to members of the collection identified by 
   the Request-URI, the value of Destination is to be modified to 
   reflect the current location in the hierarchy.  So, if the Request-URI 
   is /a/ with Host header value http://example.com/ and the 
   Destination is http://example.com/b/, then when 
   http://example.com/a/c/d is processed, it must use a Destination of 
   http://example.com/b/c/d. 
      </t>
      <t>
   When the COPY method has completed processing, it MUST have created a 
   consistent URL namespace at the destination 
   (see <xref target="http.url.namespace.model"/> for the 
   definition of namespace consistency).  However, if an error occurs 
   while copying an internal collection, the server MUST NOT copy any 
   resources identified by members of this collection (i.e., the server 
   must skip this subtree), as this would create an inconsistent 
   namespace. After detecting an error, the COPY operation SHOULD try 
   to finish as much of the original copy operation as possible (i.e., 
   the server should still attempt to copy other subtrees and their 
   members that are not descendants of an error-causing collection).  
      </t>
      <t>
   So, for example, if an infinite-depth copy operation is performed on 
   collection /a/, which contains collections /a/b/ and /a/c/, and an 
   error occurs copying /a/b/, an attempt should still be made to copy 
   /a/c/. Similarly, after encountering an error copying a non-collection
   resource as part of an infinite-depth copy, the server 
   SHOULD try to finish as much of the original copy operation as 
   possible. 
      </t>
      <t>
   If an error in executing the COPY method occurs with a resource 
   other than the resource identified in the Request-URI, then the 
   response MUST be a 207 (Multi-Status), and the URL of the resource 
   causing the failure MUST appear with the specific error.  
      </t>
      <t>
   The 424 (Failed Dependency) status code SHOULD NOT be returned in 
   the 207 (Multi-Status) response from a COPY method.  These responses 
   can be safely omitted because the client will know that the progeny 
   of a resource could not be copied when the client receives an error 
   for the parent.  Additionally, 201 (Created)/204 (No Content) status 
   codes SHOULD NOT be returned as values in 207 (Multi-Status) 
   responses from COPY methods.  They, too, can be safely omitted 
   because they are the default success codes. 
      </t>
    </section>
    
    <section title="COPY and Overwriting Destination Resources">
      <t>If a COPY request has an Overwrite header with a value of "F",
        and a resource exists at the Destination URL, the server MUST fail
        the request.
      </t>
      
      <t>
        When a server executes a COPY request and overwrites a destination
        resource, the exact behavior MAY depend on many factors, including
        WebDAV extension capabilities (see particularly <xref target="RFC3253"/>).
        For example, when an ordinary resource is overwritten, the server could
          delete the target resource before doing the copy, or could 
          do an in-place overwrite to preserve live properties.
      </t>
      <t>
        When a collection is overwritten, the membership of the destination
        collection after the successful COPY request MUST be the same membership
        as the source collection immediately before the COPY.  Thus, merging
        the membership of the source and destination collections together in
        the destination is not a compliant behavior.
      </t>
      <t>
        In general, if clients require the state of the destination URL to be
        wiped out prior to a COPY (e.g., to force live properties to be reset), 
        then the client could send a
        DELETE to the destination before the COPY request to ensure this reset.
      </t>
      
    </section>
    
    <section title="Status Codes">
      <t>In addition to the general status codes possible, the following
        status codes have specific applicability to COPY:
      </t>
      
      <t>
   201 (Created) - The source resource was successfully copied.  The 
   COPY operation resulted in the creation of a new resource. 
      </t>
      <t>
   204 (No Content) - The source resource was successfully copied to a 
   preexisting destination resource. 
      </t>
      <t>
   207 (Multi-Status) - Multiple resources were to be affected by the 
   COPY, but errors on some of them prevented the operation from taking 
   place.  Specific error messages, together with the most appropriate 
   of the source and destination URLs, appear in the body of the multi-status
   response. For example, if a destination resource was locked and could 
   not be overwritten, then the destination resource URL appears with 
   the 423 (Locked) status. 
      </t>
      <t>
   403 (Forbidden) - The operation is forbidden.  A special case for COPY  
   could be that the source and destination resources are the same resource. 
      </t>
      <t>
   409 (Conflict) - A resource cannot be created at the destination 
   until one or more intermediate collections have been created.  The 
   server MUST NOT create those intermediate collections automatically. 
      </t>
      <t>
   412 (Precondition Failed) - A precondition header check failed, e.g., the 
   Overwrite header is "F" and the destination URL is already mapped to a resource. 
      </t>
      <t>
   423 (Locked) - The destination resource, or resource within the destination
   collection, was locked. This response SHOULD
   contain the 'lock-token-submitted' precondition element.
      </t>
      <t>
   502 (Bad Gateway) - This may occur when the destination is on 
   another server, repository, or URL namespace.  Either the source 
   namespace does not support copying to the destination namespace, or 
   the destination namespace refuses to accept the resource. The client 
   may wish to try GET/PUT and PROPFIND/PROPPATCH instead. 
      </t>
      <t>
   507 (Insufficient Storage) - The destination resource does not have 
   sufficient space to record the state of the resource after the 
   execution of this method. 
      </t>
    </section>
    
    <section title="Example - COPY with Overwrite">
      <t>
   This example shows resource 
   http://www.example.com/~fielding/index.html being copied to the 
   location http://www.example.com/users/f/fielding/index.html.  The 
   204 (No Content) status code indicates that the existing resource at the 
   destination was overwritten. 
      </t>
      <figure>
        <preamble>&gt;&gt;Request</preamble>
        <artwork><![CDATA[
  COPY /~fielding/index.html HTTP/1.1 
  Host: www.example.com 
  Destination: http://www.example.com/users/f/fielding/index.html 
        ]]></artwork>
      </figure>
      <figure>
        <preamble>&gt;&gt;Response</preamble>
        <artwork><![CDATA[
  HTTP/1.1 204 No Content 
        ]]></artwork>
      </figure>
    </section>

    <section title="Example - COPY with No Overwrite">

      <t>
   The following example shows the same copy operation being performed, 
   but with the Overwrite header set to "F."  A response of 412 
   (Precondition Failed) is returned because the destination URL is already mapped to a resource. 
      </t>
      
      <figure>
        <preamble>&gt;&gt;Request</preamble>
        <artwork><![CDATA[
  COPY /~fielding/index.html HTTP/1.1 
  Host: www.example.com 
  Destination: http://www.example.com/users/f/fielding/index.html 
  Overwrite: F 
        ]]></artwork>
      </figure>
      <figure>
        <preamble>&gt;&gt;Response</preamble>
        <artwork><![CDATA[
  HTTP/1.1 412 Precondition Failed 
        ]]></artwork>
      </figure>
    </section>
    
    <section title="Example - COPY of a Collection">
      <figure>
        <preamble>&gt;&gt;Request</preamble>
        <artwork><![CDATA[
  COPY /container/ HTTP/1.1 
  Host: www.example.com 
  Destination: http://www.example.com/othercontainer/ 
  Depth: infinity 
        ]]></artwork>
      </figure>
      
      <figure>
        <preamble>&gt;&gt;Response</preamble>
        <artwork><![CDATA[
  HTTP/1.1 207 Multi-Status 
  Content-Type: application/xml; charset="utf-8" 
  Content-Length: xxxx 
  
  <?xml version="1.0" encoding="utf-8" ?> 
  
  <d:multistatus xmlns:d="DAV:"> 
    <d:response> 
      <d:href>http://www.example.com/othercontainer/R2/</d:href> 
      <d:status>HTTP/1.1 423 Locked</d:status> 
      <d:error><d:lock-token-submitted/></d:error>
    </d:response> 
  </d:multistatus> 
        ]]></artwork>
      </figure>
      
      <t>
   The Depth header is unnecessary as the default behavior of COPY on a 
   collection is to act as if a "Depth: infinity" header had been 
   submitted.  In this example, most of the resources, along with the 
   collection, were copied successfully. However, the collection R2 
   failed because the destination R2 is locked.  Because there was an 
   error copying R2, none of R2's members were copied.  However, no 
   errors were listed for those members due to the error minimization 
   rules.
      </t>
    </section>
  </section>
    
  <section title="MOVE Method" anchor="MOVE">
    <t>
   The MOVE operation on a non-collection resource is the logical 
   equivalent of a copy (COPY), followed by consistency maintenance 
   processing, followed by a delete of the source, where all three 
   actions are performed in a single operation.  The consistency maintenance step 
   allows the server to perform updates caused by the move, such as 
   updating all URLs, other than the Request-URI that identifies the 
   source resource, to point to the new destination resource.  
    </t>
    <t>
      The Destination header MUST be present on all MOVE 
   methods and MUST follow all COPY requirements for the COPY part of 
   the MOVE method.  All WebDAV-compliant resources MUST support the 
   MOVE method.
    </t>
    <t>
      Support for the MOVE method does not 
   guarantee the ability to move a resource to a particular 
   destination.  
   For example, separate programs may actually control different sets 
   of resources on the same server.  Therefore, it may not be possible 
   to move a resource within a namespace that appears to belong to the 
   same server. 
    </t>
    <t>
   If a resource exists at the destination, the destination resource 
   will be deleted as a side-effect of the MOVE operation, subject to 
   the restrictions of the Overwrite header. 
    </t>
    <t>
      This method is idempotent, but not safe (see Section 9.1 of 
      <xref target="RFC2616"/>). Responses to this method MUST NOT be cached.
    </t>    
    
    <section title="MOVE for Properties" anchor="move-properties">
      <t>
   Live properties described in this document SHOULD be moved along with 
   the resource, such that the resource has identically behaving live 
   properties at the destination resource, but not necessarily with the 
   same values.   
        Note that some live properties are defined such that the absence of the property
        has a specific meaning (e.g., a flag with one meaning if present, and the opposite if 
        absent), and in these cases, a successful MOVE might result in the 
        property being reported as "Not Found" in subsequent requests.        
        If the live properties will not work the same way at 
   the destination, the server MAY fail the request. 
      </t>
      <t>
   MOVE is frequently used by clients to rename a file without changing 
   its parent collection, so it's not appropriate to reset all live 
   properties that are set at resource creation. For example, the 
   DAV:creationdate property value SHOULD remain the same after a MOVE. 
      </t>
      <t>
   Dead properties MUST be moved along with the resource. 
      </t>
    </section>
    
    <section title="MOVE for Collections" anchor="move-collections">
      <t>
   A MOVE with "Depth: infinity" instructs that the collection 
   identified by the Request-URI be moved to the address specified in 
   the Destination header, and all resources identified by its internal 
   member URLs are to be moved to locations relative to it, recursively 
   through all levels of the collection hierarchy. 
      </t>
      <t>
   The MOVE method on a collection MUST act as if a "Depth: infinity" 
   header was used on it.  A client MUST NOT submit a Depth header on a 
   MOVE on a collection with any value but "infinity". 
      </t>
      <t>
   Any headers included with MOVE MUST be applied in processing every 
   resource to be moved with the exception of the Destination header. 
   The behavior of the Destination header is the same as given for COPY 
   on collections.  
      </t>
      <t>
   When the MOVE method has completed processing, it MUST have created a 
   consistent URL namespace at both the source and destination (see <xref
   target="http.url.namespace.model"/> for the definition of namespace consistency). However, if an 
   error occurs while moving an internal collection, the server MUST 
   NOT move any resources identified by members of the failed 
   collection (i.e., the server must skip the error-causing subtree), 
   as this would create an inconsistent namespace. In this case, after 
   detecting the error, the move operation SHOULD try to finish as much 
   of the original move as possible (i.e., the server should still 
   attempt to move other subtrees and the resources identified by their 
   members that are not descendants of an error-causing collection).  
   So, for example, if an infinite-depth move is performed on 
   collection /a/, which contains collections /a/b/ and /a/c/, and an 
   error occurs moving /a/b/, an attempt should still be made to try 
   moving /a/c/. Similarly, after encountering an error moving a non-collection
   resource as part of an infinite-depth move, the server 
   SHOULD try to finish as much of the original move operation as 
   possible. 
      </t>
      <t>
   If an error occurs with a resource other than the resource 
   identified in the Request-URI, then the response MUST be a 207 
   (Multi-Status), and the errored resource's URL MUST appear with the 
   specific error. 
      </t>
      <t>
   The 424 (Failed Dependency) status code SHOULD NOT be returned in 
   the 207 (Multi-Status) response from a MOVE method.  These errors 
   can be safely omitted because the client will know that the progeny 
   of a resource could not be moved when the client receives an error 
   for the parent.  Additionally, 201 (Created)/204 (No Content) 
   responses SHOULD NOT be returned as values in 207 (Multi-Status) 
   responses from a MOVE.  These responses can be safely omitted 
   because they are the default success codes. 
      </t>
      
    </section>
    
    <section title="MOVE and the Overwrite Header">
      <t>
   If a resource exists at the destination and the Overwrite header is 
   "T", then prior to performing the move, the server MUST perform a 
   DELETE with "Depth: infinity" on the destination resource.  If the 
   Overwrite header is set to "F", then the operation will fail. 
      </t>
    </section>
    
    <section title="Status Codes">
      <t>In addition to the general status codes possible, the following
        status codes have specific applicability to MOVE:
      </t>
      <t>
   201 (Created) - The source resource was successfully moved, and a 
   new URL mapping was created at the destination. 
      </t>
      <t>
   204 (No Content) - The source resource was successfully moved to a URL
        that was already mapped.
      </t>
      <t>
   207 (Multi-Status) - Multiple resources were to be affected by the 
   MOVE, but errors on some of them prevented the operation from taking 
   place.  Specific error messages, together with the most appropriate 
   of the source and destination URLs, appear in the body of the multi-status
   response. For example, if a source resource was locked and could not 
   be moved, then the source resource URL appears with the 423 (Locked) 
   status. 
      </t>
      <t>
   403 (Forbidden) - Among many possible reasons for forbidding a MOVE operation,
        this status code is recommended for use when the source and destination 
        resources are the same. 
      </t>
      <t>
   409 (Conflict) - A resource cannot be created at the destination 
   until one or more intermediate collections have been created.  The 
   server MUST NOT create those intermediate collections automatically. 
   Or, the server was unable to 
   preserve the behavior of the live properties and still move the 
   resource to the destination (see 'preserved-live-properties' postcondition).
      </t>
      <t>
   412 (Precondition Failed) - A condition header failed.  Specific to MOVE, this could
        mean that the Overwrite 
   header is "F" and the destination URL is already mapped to a resource. 
      </t>
      <t>
   423 (Locked) - The source or the destination resource, the source or destination
        resource parent, or some resource 
   within the source or destination collection, was locked. This response SHOULD
   contain the 'lock-token-submitted' precondition element.
      </t>
      <t>
   502 (Bad Gateway) - This may occur when the destination is on 
   another server and the destination server refuses to accept the 
   resource.  This could also occur when the destination is on another 
   sub-section of the same server namespace.
      </t>
    </section>
    
    <section title="Example - MOVE of a Non-Collection">
      <t>
   This example shows resource 
   http://www.example.com/~fielding/index.html being moved to the 
   location http://www.example.com/users/f/fielding/index.html. The 
   contents of the destination resource would have been overwritten if 
   the destination URL was already mapped to a resource.  In this case, since 
   there was nothing at the destination resource, the response code is 
   201 (Created). 
     </t>
     
     <figure>
       <preamble>&gt;&gt;Request</preamble>
       <artwork><![CDATA[
  MOVE /~fielding/index.html HTTP/1.1 
  Host: www.example.com 
  Destination: http://www.example/users/f/fielding/index.html 
        ]]></artwork>
      </figure>
      
      <figure>
        <preamble>&gt;&gt;Response</preamble>
        <artwork><![CDATA[
  HTTP/1.1 201 Created 
  Location: http://www.example.com/users/f/fielding/index.html 
        ]]></artwork>
      </figure>
    </section>
    
    <section title="Example - MOVE of a Collection">
      <figure>
        <preamble>&gt;&gt;Request</preamble>
        <artwork><![CDATA[
  MOVE /container/ HTTP/1.1 
  Host: www.example.com 
  Destination: http://www.example.com/othercontainer/ 
  Overwrite: F 
  If: (<urn:uuid:fe184f2e-6eec-41d0-c765-01adc56e6bb4>) 
     (<urn:uuid:e454f3f3-acdc-452a-56c7-00a5c91e4b77>) 
        ]]></artwork>
      </figure>
      
      <figure>
        <preamble>&gt;&gt;Response</preamble>
        <artwork><![CDATA[
  HTTP/1.1 207 Multi-Status 
  Content-Type: application/xml; charset="utf-8" 
  Content-Length: xxxx 
  
  <?xml version="1.0" encoding="utf-8" ?> 
  <d:multistatus xmlns:d='DAV:'> 
    <d:response> 
      <d:href>http://www.example.com/othercontainer/C2/</d:href> 
      <d:status>HTTP/1.1 423 Locked</d:status> 
      <d:error><d:lock-token-submitted/></d:error>
    </d:response> 
  </d:multistatus> 
        ]]></artwork>
        <postamble>      
   In this example, the client has submitted a number of lock tokens 
   with the request.  A lock token will need to be submitted for every 
   resource, both source and destination, anywhere in the scope of the 
   method, that is locked.  In this case, the proper lock token was not 
   submitted for the destination 
   http://www.example.com/othercontainer/C2/. This means that the 
   resource /container/C2/ could not be moved.  Because there was an 
   error moving /container/C2/, none of /container/C2's members were 
   moved.  However, no errors were listed for those members due to the 
   error minimization rules.  User agent authentication has previously 
   occurred via a mechanism outside the scope of the HTTP protocol, in 
   an underlying transport layer. 
        </postamble>
      </figure>
    </section>
  </section>
  
  
  <section title="LOCK Method" anchor="LOCK">
    <t>
   The following sections describe the LOCK method, which is used to 
   take out a lock of any access type and to refresh an existing lock.  
   These sections on the LOCK method describe only those semantics that 
   are specific to the LOCK method and are independent of the access 
   type of the lock being requested. 
    </t>
    <t>
   Any resource that supports the LOCK method MUST, at minimum, 
   support the XML request and response formats defined herein. 
    </t>
    <t>
      This method is neither idempotent nor safe (see Section 9.1 of 
      <xref target="RFC2616"/>). Responses to this method MUST NOT be cached.
    </t>    
    
    <section title="Creating a Lock on an Existing Resource">
      <t>
     A LOCK request to an existing resource will create a lock on the resource 
        identified by the Request-URI, provided the resource is not already 
        locked with a conflicting lock.  The resource identified in the Request-URI 
     becomes the root of the lock.  LOCK method requests to create a new 
     lock MUST have an XML request body. The server MUST preserve the 
     information provided by the client in the 'owner' element in the LOCK request.  
	The LOCK request MAY have a Timeout 
     header. 
      </t>
      <t>
     When a new lock is created, the LOCK response: </t>
        <t><list style="symbols">
          <t>MUST contain a body with the value of the 
          DAV:lockdiscovery property in a prop XML element.  This MUST
          contain the full information about the lock just granted, while
          information about other (shared) locks is OPTIONAL.</t>
          <t>MUST include the Lock-Token response header with the 
          token associated with the new lock.</t>
        </list></t>
    </section>

    
    <section title="Refreshing Locks" anchor="refreshing-locks">
      <t>
   A lock is refreshed by sending a LOCK request to the URL of a resource within 
   the scope of the lock. This request MUST NOT have a body and it MUST specify which lock
   to refresh by using the 'If' header with a single lock token (only one
   lock may be refreshed at a time). The request MAY contain a Timeout header, which a
   server MAY accept to change the duration remaining on the lock to the new value.
   A server MUST ignore the Depth header on a LOCK refresh.
      </t>
      <t>
   If the resource has other (shared) locks, those locks are unaffected 
   by a lock refresh.  Additionally, those locks do not prevent the 
   named lock from being refreshed. 
      </t>
      <t>
   The Lock-Token header is not returned in the response for a 
   successful refresh LOCK request, but the LOCK response body MUST
   contain the new value for the DAV:lockdiscovery property. 
    </t>
    </section>

   
    <section title="Depth and Locking">
      <t>
   The Depth header may be used with the LOCK method.  Values other 
   than 0 or infinity MUST NOT be used with the Depth header on a LOCK 
   method.  All resources that support the LOCK method MUST support the 
   Depth header. 
      </t>
      <t>
   A Depth header of value 0 means to just lock the resource specified 
   by the Request-URI. 
      </t>
      <t>
   If the Depth header is set to infinity, then the resource specified 
   in the Request-URI along with all its members, all the way 
   down the hierarchy, are to be locked.  A successful result MUST 
   return a single lock token.  Similarly, if an UNLOCK is successfully executed on this 
   token, all associated resources are unlocked.  
        Hence, partial success is not an option for LOCK or UNLOCK.  Either the 
   entire hierarchy is locked or no resources are locked. 
      </t>
      <t>If the lock cannot be granted to all resources, the server MUST return 
        a Multi-Status response with a 'response' element for
        at least one resource that prevented the lock from being granted, 
        along with a suitable status code for that failure (e.g., 403 (Forbidden) or 
        423 (Locked)).  Additionally, if the resource causing the failure was not the 
        resource requested, then the server SHOULD include a 'response' element
        for the Request-URI as well, with a 'status' element containing 424 Failed Dependency.
      </t>
      <t>
   If no Depth header is submitted on a LOCK request, then the request 
   MUST act as if a "Depth:infinity" had been submitted. 
      </t>
    </section>
    
    <section title="Locking Unmapped URLs">
      <t>
   A successful LOCK method MUST result in the creation of an empty 
   resource that is locked (and that is not a collection) when a 
   resource did not previously exist at that URL.   Later on, the lock 
   may go away but the empty resource remains.  Empty resources MUST 
   then appear in PROPFIND responses including that URL in the response 
   scope.  A server MUST respond successfully to a GET request to an 
   empty resource, either by using a 204 No Content response, or by 
   using 200 OK with a Content-Length header indicating zero length 
     </t>
    </section>
    
    <section title="Lock Compatibility Table">
    
      <t>
   The table below describes the behavior that occurs when a lock 
   request is made on a resource. 
      </t>
      
     <texttable>
       <ttcol width="40%">Current State</ttcol><ttcol>Shared Lock OK</ttcol><ttcol>Exclusive Lock OK</ttcol>
       <c>None</c><c>True</c><c>True</c>
       <c>Shared Lock</c><c>True</c><c>False</c>
       <c>Exclusive Lock</c><c>False</c><c>False*</c>
     </texttable>
      
     <t>
   Legend: True = lock may be granted.  False = lock MUST NOT be 
   granted. *=It is illegal for a principal to request the same lock 
   twice. 
     </t>
     
     <t>
    
   The current lock state of a resource is given in the leftmost 
   column, and lock requests are listed in the first row.  The 
   intersection of a row and column gives the result of a lock request.  
   For example, if a shared lock is held on a resource, and an 
   exclusive lock is requested, the table entry is "false", indicating that
   the lock must not be granted. 
      </t>
    </section>
    
    <section title="LOCK Responses">
      <t>In addition to the general status codes possible, the following
        status codes have specific applicability to LOCK:
      </t>
      <t>
   200 (OK) - The LOCK request succeeded and the value of the 
   DAV:lockdiscovery property is included in the response body.         
      </t>
      <t>
   201 (Created) - The LOCK request was to an unmapped URL, the request
      succeeded and resulted in the creation of a new resource, and the
      value of the DAV:lockdiscovery property is included in the response body.
      </t>
      
      <t>
   409 (Conflict) - A resource cannot be created at the destination 
   until one or more intermediate collections have been created.  The 
   server MUST NOT create those intermediate collections automatically. 
      </t>
      <t>
        423 (Locked), potentially with 'no-conflicting-lock' precondition code - There 
        is already a lock on the resource that is not compatible with the requested 
        lock (see lock compatibility table above).
      </t>
      <t>
   412 (Precondition Failed), with 'lock-token-matches-request-uri' precondition code - 
   The LOCK request was made with an If header, indicating that the 
   client wishes to refresh the given lock.  However, the Request-URI did not
   fall within the scope of the lock identified by the token.  The lock may have
   a scope that does not include the Request-URI, or the lock could have disappeared,
   or the token may be invalid.
      </t>
      
    </section>
    
    <section title="Example - Simple Lock Request">
      <figure>
        <preamble>&gt;&gt;Request</preamble>
        <artwork><![CDATA[
  LOCK /workspace/webdav/proposal.doc HTTP/1.1 
  Host: example.com 
  Timeout: Infinite, Second-4100000000 
  Content-Type: application/xml; charset="utf-8" 
  Content-Length: xxxx 
  Authorization: Digest username="ejw", 
    realm="ejw@example.com", nonce="...", 
    uri="/workspace/webdav/proposal.doc", 
    response="...", opaque="..." 
    
  <?xml version="1.0" encoding="utf-8" ?> 
  <D:lockinfo xmlns:D='DAV:'> 
    <D:lockscope><D:exclusive/></D:lockscope> 
    <D:locktype><D:write/></D:locktype> 
    <D:owner> 
      <D:href>http://example.org/~ejw/contact.html</D:href> 
    </D:owner> 
  </D:lockinfo> 
        ]]></artwork>
      </figure>
      
      <figure>
        <preamble>&gt;&gt;Response</preamble>
        <artwork><![CDATA[
  HTTP/1.1 200 OK 
  Lock-Token: <urn:uuid:e71d4fae-5dec-22d6-fea5-00a0c91e6be4> 
  Content-Type: application/xml; charset="utf-8" 
  Content-Length: xxxx 
  
  <?xml version="1.0" encoding="utf-8" ?> 
  <D:prop xmlns:D="DAV:"> 
    <D:lockdiscovery> 
      <D:activelock> 
        <D:locktype><D:write/></D:locktype> 
        <D:lockscope><D:exclusive/></D:lockscope> 
        <D:depth>infinity</D:depth> 
        <D:owner> 
          <D:href>http://example.org/~ejw/contact.html</D:href> 
        </D:owner> 
        <D:timeout>Second-604800</D:timeout> 
        <D:locktoken> 
          <D:href
          >urn:uuid:e71d4fae-5dec-22d6-fea5-00a0c91e6be4</D:href>
        </D:locktoken> 
        <D:lockroot> 
          <D:href
          >http://example.com/workspace/webdav/proposal.doc</D:href>
        </D:lockroot> 
      </D:activelock> 
    </D:lockdiscovery> 
  </D:prop> 
]]>
        </artwork>
      </figure>
          <t>
   This example shows the successful creation of an exclusive write 
   lock on resource http://example.com/workspace/webdav/proposal.doc.  
   The resource http://example.org/~ejw/contact.html contains 
   contact information for the creator of the lock.  The server has an 
   activity-based timeout policy in place on this resource, which 
   causes the lock to automatically be removed after 1 week (604800 
   seconds).  Note that the nonce, response, and opaque fields have not 
   been calculated in the Authorization request header. 
          </t>
    </section>
    
    <section title="Example - Refreshing a Write Lock">
      <figure>
        <preamble>&gt;&gt;Request</preamble>
        <artwork><![CDATA[
  LOCK /workspace/webdav/proposal.doc HTTP/1.1 
  Host: example.com 
  Timeout: Infinite, Second-4100000000 
  If: (<urn:uuid:e71d4fae-5dec-22d6-fea5-00a0c91e6be4>) 
  Authorization: Digest username="ejw", 
    realm="ejw@example.com", nonce="...", 
    uri="/workspace/webdav/proposal.doc", 
    response="...", opaque="..." 
        ]]></artwork>
      </figure>
      
      <figure>
        <preamble>&gt;&gt;Response</preamble>
        <artwork><![CDATA[
  HTTP/1.1 200 OK 
  Content-Type: application/xml; charset="utf-8" 
  Content-Length: xxxx 
  
  <?xml version="1.0" encoding="utf-8" ?> 
  <D:prop xmlns:D="DAV:"> 
    <D:lockdiscovery> 
      <D:activelock> 
        <D:locktype><D:write/></D:locktype> 
        <D:lockscope><D:exclusive/></D:lockscope> 
        <D:depth>infinity</D:depth> 
        <D:owner> 
          <D:href>http://example.org/~ejw/contact.html</D:href> 
        </D:owner> 
        <D:timeout>Second-604800</D:timeout> 
        <D:locktoken> 
          <D:href
          >urn:uuid:e71d4fae-5dec-22d6-fea5-00a0c91e6be4</D:href> 
        </D:locktoken> 
        <D:lockroot> 
          <D:href
          >http://example.com/workspace/webdav/proposal.doc</D:href> 
        </D:lockroot> 
      </D:activelock> 
    </D:lockdiscovery> 
  </D:prop> 
]]>
        </artwork>
        <postamble>
   This request would refresh the lock, attempting to reset the timeout 
   to the new value specified in the timeout header.  Notice that the 
   client asked for an infinite time out but the server choose to 
   ignore the request. In this example, the nonce, response, and opaque 
   fields have not been calculated in the Authorization request header. 
        </postamble>        
      </figure>
    </section>
    
    <section title="Example - Multi-Resource Lock Request">
      <figure>
        <preamble>&gt;&gt;Request</preamble>
        <artwork><![CDATA[
  LOCK /webdav/ HTTP/1.1 
  Host: example.com 
  Timeout: Infinite, Second-4100000000 
  Depth: infinity 
  Content-Type: application/xml; charset="utf-8" 
  Content-Length: xxxx 
  Authorization: Digest username="ejw", 
    realm="ejw@example.com", nonce="...", 
    uri="/workspace/webdav/proposal.doc", 
    response="...", opaque="..." 
      
  <?xml version="1.0" encoding="utf-8" ?> 
  <D:lockinfo xmlns:D="DAV:"> 
    <D:locktype><D:write/></D:locktype> 
    <D:lockscope><D:exclusive/></D:lockscope> 
    <D:owner> 
      <D:href>http://example.org/~ejw/contact.html</D:href> 
    </D:owner> 
  </D:lockinfo> 
        ]]></artwork>
      </figure>
      
      <figure>
        <preamble>&gt;&gt;Response</preamble>
        <artwork><![CDATA[
  HTTP/1.1 207 Multi-Status 
  Content-Type: application/xml; charset="utf-8" 
  Content-Length: xxxx 
  
  <?xml version="1.0" encoding="utf-8" ?> 
  <D:multistatus xmlns:D="DAV:"> 
    <D:response> 
      <D:href>http://example.com/webdav/secret</D:href> 
      <D:status>HTTP/1.1 403 Forbidden</D:status> 
    </D:response> 
    <D:response> 
      <D:href>http://example.com/webdav/</D:href> 
      <D:status>HTTP/1.1 424 Failed Dependency</D:status> 
    </D:response> 
  </D:multistatus>      
]]>
        </artwork>
      </figure>
      <t>
        This example shows a request for an exclusive write lock on a 
   collection and all its children.  In this request, the client has 
   specified that it desires an infinite-length lock, if available,
   otherwise a timeout of 4.1 billion seconds, if available. The 
   request entity body contains the contact information for the 
   principal taking out the lock -- in this case, a Web page URL. 
      </t>
      <t>
   The error is a 403 (Forbidden) response on the resource 
   http://example.com/webdav/secret.  Because this resource could not 
   be locked, none of the resources were locked.  Note also that the 
   a 'response' element for the Request-URI itself has been included as 
   required. 
      </t>
      <t>
   In this example, the nonce, response, and opaque fields have not 
   been calculated in the Authorization request header. 
      </t>
    </section>
    
  </section>
  
  <section title="UNLOCK Method" anchor="UNLOCK">
    <t>
   The UNLOCK method removes the lock identified by the lock token in 
   the Lock-Token request header.  The Request-URI MUST identify a 
   resource within the scope of the lock.  </t>
      
      <t>Note that use of the Lock-Token header to 
      provide the lock token is not consistent with other state-changing methods,
      which all require an If header with the lock token. Thus, the If header 
      is not needed to provide the lock token.  Naturally, when the If header is 
      present, it has its normal meaning as a conditional header.  
    </t>
    <t>
   For a successful response to this 
   method, the server MUST delete the lock entirely.    
    </t>
   
    <t>
   If all resources that have been locked under the submitted lock
   token cannot be unlocked, then the UNLOCK request MUST fail. 
    </t>
    <t>
   A successful response to an UNLOCK method does not mean that the 
   resource is necessarily unlocked.  It means that the specific lock 
   corresponding to the specified token no longer exists. 
    </t>
    <t>
   Any DAV-compliant resource that supports the LOCK method MUST 
   support the UNLOCK method. 
    </t>
    <t>
      This method is idempotent, but not safe (see Section 9.1 of 
      <xref target="RFC2616"/>). Responses to this method MUST NOT be cached.
    </t>    
    
    
    <section title="Status Codes">
      <t>In addition to the general status codes possible, the following
        status codes have specific applicability to UNLOCK:
      </t>
      <t>
   204 (No Content) - Normal success response (rather than 200 OK, since 200 OK
        would imply a response body, and an UNLOCK success response does not 
        normally contain a body).
   