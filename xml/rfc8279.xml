<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "reference.RFC.2119.xml">
<!ENTITY RFC3443 SYSTEM "reference.RFC.3443.xml">
<!ENTITY RFC6513 SYSTEM "reference.RFC.6513.xml">
<!ENTITY RFC6514 SYSTEM "reference.RFC.6514.xml">
<!ENTITY RFC8174 SYSTEM "reference.RFC.8174.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="exp" number="8279" ipr="trust200902" submissionType="IETF" consensus="yes">

  <front>

    <title abbrev="Multicast with BIER">Multicast Using Bit Index Explicit
    Replication (BIER)</title>

    <author fullname="IJsbrand Wijnands" initials="IJ" role="editor"
            surname="Wijnands">
      <organization>Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>De Kleetlaan 6a</street>
          <city>Diegem</city>
          <region></region>
          <code>1831</code>
          <country>Belgium</country>
        </postal>
        <email>ice@cisco.com</email>
      </address>
    </author>

    <author fullname="Eric C. Rosen" initials="E." role="editor"
            surname="Rosen">
      <organization>Juniper Networks, Inc.</organization>
      <address>
        <postal>
          <street>10 Technology Park Drive</street>
          <city>Westford</city>
          <region>Massachusetts</region>
          <code>01886</code>
          <country>United States of America</country>
        </postal>
        <email>erosen@juniper.net</email>
      </address>
    </author>

    <author fullname="Andrew Dolganow" initials="A." 
            surname="Dolganow">
      <organization>Nokia</organization>
      <address>
        <postal>
          <street>438B Alexandra Rd #08-07/10</street>
          <street>Alexandra Technopark</street>
          <code>119968</code>
          <region>Singapore</region>
          <country>Singapore</country>
        </postal>
        <email>andrew.dolganow@nokia.com</email>
      </address>
    </author>

    <author fullname="Tony Przygienda" initials="T." 
            surname="Przygienda">
      <organization>Juniper Networks, Inc.</organization>
      <address>
        <postal>
          <street>1194 N. Mathilda Ave.</street>
          <city>Sunnyvale</city>
          <region>California</region>
          <code>94089</code>
          <country>United States of America</country>
        </postal>
        <email>prz@juniper.net</email>
      </address>
    </author>

    <author fullname="Sam K. Aldrin" initials="S." 
            surname="Aldrin">
      <organization>Google, Inc.</organization>
      <address>
        <postal>
          <street>1600 Amphitheatre Parkway</street>
          <city>Mountain View</city>
          <region>California</region>
          <code>94043</code>
          <country>United States of America</country>
        </postal>
        <email>aldrin.ietf@gmail.com</email>
      </address>
    </author>    
    
    <date month="November" year="2017" />

    <keyword>Multicast</keyword>

    <abstract>
      <t>
        This document specifies a new architecture for the forwarding of
        multicast data packets.  It provides optimal forwarding of multicast
        packets through a "multicast domain".  However, it does not require
        a protocol for explicitly building multicast distribution trees, nor
        does it require intermediate nodes to maintain any per-flow
        state. This architecture is known as "Bit Index Explicit
        Replication" (BIER).  When a multicast data packet enters the
        domain, the ingress router determines the set of egress routers to
        which the packet needs to be sent.  The ingress router then
        encapsulates the packet in a BIER header.  The BIER header contains
        a bit string in which each bit represents exactly one egress router
        in the domain; to forward the packet to a given set of egress
        routers, the bits corresponding to those routers are set in the BIER
        header.  The procedures for forwarding a packet based on its BIER
        header are specified in this document.  Elimination of the per-flow
        state and the explicit tree-building protocols results in a
        considerable simplification.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>
        This document specifies a new architecture for the forwarding of
        multicast data packets.  The architecture provides optimal
        forwarding of multicast data packets through a "multicast domain".
        However, it does not require the use of a protocol for explicitly
        building multicast distribution trees, and it does not require
        intermediate nodes to maintain any per-flow state. This architecture
        is known as "Bit Index Explicit Replication" (BIER).
      </t>

      <t>
        A router that supports BIER is known as a "Bit&nbhy;Forwarding Router"
        (BFR).  The BIER control-plane protocols (see <xref
        target="BierLayer"/>) run within a "BIER domain", allowing the BFRs
        within that domain to exchange the information needed for them to
        forward packets to each other using BIER. 
      </t>
      <t>
        A multicast data packet enters a BIER domain at a "Bit&nbhy;Forwarding
        Ingress Router" (BFIR), and leaves the BIER domain at one or more
        "Bit&nbhy;Forwarding Egress Routers" (BFERs).  A BFR that receives a
        multicast data packet from another BFR in the same BIER domain, and
        forwards the packet to another BFR in the same BIER domain, will be
        known as a "transit BFR" for that packet.  A single BFR may be a
        BFIR for some multicast traffic while also being a BFER for some
        multicast traffic and a transit BFR for some multicast traffic.  In
        fact, for a given packet, a BFR may be a BFIR and/or a transit BFR
        and/or (one of) the BFER(s) for that packet.
      </t>
      <t>
        A BIER domain may contain one or more sub&nbhy;domains.  Each BIER
        domain MUST contain at least one sub&nbhy;domain, the "default
        sub&nbhy;domain" (also denoted "sub&nbhy;domain 0").  If a BIER
        domain contains more than one sub&nbhy;domain, each BFR in the
        domain MUST be provisioned to know the set of sub&nbhy;domains to
        which it belongs.  Each sub&nbhy;domain is identified by a
        sub&nbhy;domain&nbhy;id in the range [0,255].
      </t>
      <t>
        For each sub&nbhy;domain to which a given BFR belongs, if the BFR is
        capable of acting as a BFIR or a BFER, it MUST be provisioned with a
        "BFR&nbhy;id" that is unique within the sub&nbhy;domain.  A
        BFR&nbhy;id is a small unstructured positive integer.  For instance,
        if a particular BIER sub&nbhy;domain contains 1,374 BFRs, each one
        could be given a BFR&nbhy;id in the range [1,1374].
      </t>
      <t>
        If a given BFR belongs to more than one sub&nbhy;domain, it may
        (though it need not) have a different BFR&nbhy;id for each
        sub&nbhy;domain.
      </t>
      <t>
        When a multicast packet arrives from outside the domain at a BFIR,
        the BFIR determines the set of BFERs to which the packet will be
        sent.  The BFIR also determines the sub&nbhy;domain in which the
        packet will be sent.  Determining the sub&nbhy;domain in which a
        given packet will be sent is known as "assigning the packet to a
        sub&nbhy;domain".  Procedures for choosing the sub&nbhy;domain to
        which a particular packet is assigned are outside the scope of this
        document.  However, once a particular packet has been assigned to a
        particular sub&nbhy;domain, it remains assigned to that
        sub&nbhy;domain until it leaves the BIER domain.  That is, the
        sub&nbhy;domain to which a packet is assigned MUST NOT be changed
        while the packet is in flight through the BIER domain.
      </t>
      <t>
        Once the BFIR determines the sub&nbhy;domain and the set of BFERs for
        a given packet, the BFIR encapsulates the packet in a "BIER header".
        The BIER header contains a bit string in which each bit represents a
        single BFR&nbhy;id.  To indicate that a particular BFER is to
        receive a given packet, the BFIR sets the bit corresponding to that
        BFER's BFR&nbhy;id in the sub&nbhy;domain to which the packet has
        been assigned.  We will use the term "BitString" to refer to the
        bit string field in the BIER header.  We will use the term "payload"
        to refer to the packet that has been encapsulated.  Thus, a
        "BIER&nbhy;encapsulated" packet consists of a "BIER header" followed
        by a "payload".
      </t>
      <t>
        The number of BFERs to which a given packet can be forwarded is
        limited only by the length of the BitString in the BIER header.
        Different deployments can use different BitString lengths.  We will
        use the term "BitStringLength" to refer to the number of bits in the
        BitString.  It is possible that some deployments will have more BFERs
        in a given sub&nbhy;domain than there are bits in the BitString.  To
        accommodate this case, the BIER encapsulation includes both the
        BitString and a "Set Identifier" (SI). It is the BitString and the
        SI together that determine the set of BFERs to which a given packet
        will be delivered:
        <list style="symbols">
          <t>
            By convention, the least significant (rightmost) bit in the
            BitString is "bit 1", and the most significant (leftmost) bit is
            "bit BitStringLength".
          </t>
          <t>
            If a BIER&nbhy;encapsulated packet has an SI of n and a BitString
            with bit k set, then the packet must be delivered to the BFER
            whose BFR&nbhy;id (in the sub&nbhy;domain to which the packet has
            been assigned) is n*BitStringLength+k.
          </t>
        </list>
      </t>
      <t>
        For example, suppose the BIER encapsulation uses a BitStringLength
        of 256 bits.  By convention, the least significant (rightmost) bit
        is bit 1, and the most significant (leftmost) bit is bit 256.
        Suppose that a given packet has been assigned to sub&nbhy;domain 0
        and needs to be delivered to three BFERs, where those BFERs have
        BFR&nbhy;ids in sub&nbhy;domain 0 of 13, 126, and 235, respectively.
        The BFIR would create a BIER encapsulation with the SI set to zero
        and with bits 13, 126, and 235 of the BitString set.  (All other
        bits of the BitString would be clear.)  If the packet also needs to
        be sent to a BFER whose BFR&nbhy;id is 257, the BFIR would have to
        create a second copy of the packet, and the BIER encapsulation would
        specify an SI of 1, and a BitString with bit 1 set and all the other
        bits clear.
      </t>
      <t>
        It is generally advantageous to assign the BFR&nbhy;ids of a given
        sub&nbhy;domain so that as many BFERs as possible can be represented
        in a single bit string.
      </t>
      <t>
        Suppose a BFR (call it "BFR&nbhy;A") receives a packet whose BIER
        encapsulation specifies an SI of 0 and a BitString with bits 13,
        26, and 235 set.  Suppose BFR&nbhy;A has two BFR neighbors,
        BFR&nbhy;B and BFR&nbhy;C, such that the best path to BFERs 13 and
        26 is via BFR&nbhy;B, but the best path to BFER 235 is via
        BFR&nbhy;C.  BFR&nbhy;A will then replicate the packet, sending one
        copy to BFR&nbhy;B and one copy to BFR&nbhy;C.  However, BFR&nbhy;A
        will clear bit 235 in the BitString of the packet copy it sends to
        BFR&nbhy;B and will clear bits 13 and 26 in the BitString of the
        packet copy it sends to BFR&nbhy;C.  As a result, BFR&nbhy;B will
        forward the packet only towards BFERs 13 and 26, and BFR&nbhy;C will
        forward the packet only towards BFER 235.  This ensures that each
        BFER receives only one copy of the packet.
      </t>
      <t>
        Detailed procedures for forwarding a BIER&nbhy;encapsulated packet
        through a BIER domain can be found in <xref target="forwarding"/>.
      </t>
      <t>
        With this forwarding procedure, a multicast data packet can follow
        an optimal path from its BFIR to each of its BFERs.  Further, since
        the set of BFERs for a given packet is explicitly encoded into the
        BIER header, the packet is not sent to any BFER that does not need
        to receive it.  This allows for optimal forwarding of multicast
        traffic.  This optimal forwarding is achieved without any need for
        transit BFRs to maintain per-flow state or to run a multicast
        tree-building protocol.
      </t>
      <t>
        The idea of encoding the set of egress nodes into the header of a
        multicast packet is not new.  For example, <xref
        target="Boivie_Feldman"/> proposes to encode the set of egress nodes
        as a set of IP addresses, and proposes mechanisms and procedures
        that are in some ways similar to those described in the current
        document.  However, since BIER encodes each BFR&nbhy;id as a single
        bit in a bit string, it can represent up to 128 BFERs in the same
        number of bits that it would take to carry the IPv6 address of a
        single BFER.  Thus, BIER scales to a much larger number of egress
        nodes per packet.
      </t>
      <t>
        BIER does not require that each transit BFR look up the best path to
        each BFER that is identified in the BIER header; the number of
        lookups required in the forwarding path for a single packet can be
        limited to the number of neighboring BFRs; this can be much smaller
        than the number of BFERs.  See <xref target="forwarding"/>
        (especially <xref target="rules"/>) for details.
      </t>

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
        "SHALL&nbsp;NOT", "SHOULD", "SHOULD&nbsp;NOT", "RECOMMENDED",
        "NOT&nbsp;RECOMMENDED", "MAY", and "OPTIONAL" in this document
        are to be interpreted as described in BCP&nbsp;14
        <xref format="default" pageno="false" target="RFC2119"/>
        <xref format="default" pageno="false" target="RFC8174"/> when,
        and only when, they appear in all capitals, as shown here.</t>

    </section>

      <section title="The BFR Identifier and BFR-Prefix" anchor="BFR-id">
        <t>
          Each BFR MUST be assigned a single "BFR&nbhy;prefix" for each
          sub&nbhy;domain to which it belongs.  A BFR's BFR&nbhy;prefix MUST be
          an IP address (either IPv4 or IPv6) of the BFR.  It is RECOMMENDED
          that the BFR&nbhy;prefix be a loopback address of the BFR.
        </t>
        <t>
          If a BFR belongs to more than one sub&nbhy;domain, it may (though it
          need not) have a different BFR&nbhy;prefix in each sub&nbhy;domain.
        </t>
        <t>
          All BFR&nbhy;prefixes used within a given sub&nbhy;domain MUST belong
          to the same address family (either IPv4 or IPv6).
        </t>
        <t>
          The BFR&nbhy;prefix of a given BFR in a given sub&nbhy;domain MUST be
          routable in that sub&nbhy;domain.  Whether a particular
          BFR&nbhy;prefix is routable in a given sub&nbhy;domain depends on
          the "routing underlay" associated with that sub&nbhy;domain.  The
          notion of "routing underlay" is described in
          <xref target="underlay"/>.
        </t>
        <t>
          A "BFR Identifier" (BFR&nbhy;id) is a number in the range
          [1,65535].  Within a given sub&nbhy;domain, every BFR that may
          need to function as a BFIR or BFER MUST have a single BFR&nbhy;id,
          which identifies it uniquely within that sub&nbhy;domain. A BFR
          that does not need to function as a BFIR or BFER in a given
          sub&nbhy;domain does not need to have a BFR&nbhy;id in that
          sub&nbhy;domain.
        </t>

        <t>
          The value 0 is not a legal BFR&nbhy;id.
        </t>
        <t>
          The procedure for assigning a particular BFR&nbhy;id to a
          particular BFR is outside the scope of this document.  However, it
          is RECOMMENDED that the BFR&nbhy;ids for each sub&nbhy;domain be
          assigned "densely" from the numbering space, as this will result
          in a more efficient encoding (see <xref target="encoding"/>).
          That is, if there are 256 or fewer BFERs, it is RECOMMENDED to
          assign all the BFR&nbhy;ids from the range [1,256].  If there are
          more than 256 BFERs but less than 512, it is RECOMMENDED to
          assign all the BFR&nbhy;ids from the range [1,512], with as few
          "holes" as possible in the earlier range.  However, in some
          deployments, it may be advantageous to depart from this
          recommendation; this is discussed further in <xref
          target="encoding"/>.
        </t>
        <t>
          In some deployments, it may not be possible to support (in a given
          sub&nbhy;domain) the full range of 65,535 BFR&nbhy;ids.  For
          example, if the BFRs in a given sub&nbhy;domain only support 16
          SIs and if they only support BitStringLengths of 256 or less, then
          only 16*256=4,096 BFR&nbhy;ids can be supported in that
          sub&nbhy;domain.
        </t>
      </section>
      
      <section title="Encoding BFR Identifiers in BitStrings" anchor="encoding">
        <t>
          To encode a BFR&nbhy;id in a BIER data packet, one must convert
          the BFR&nbhy;id to an SI and a BitString.  This conversion depends
          upon the parameter we are calling "BitStringLength".  The
          conversion is done as follows.  If the BFR&nbhy;id is N, then
        </t>
        <t>
          <list style="symbols">
            <t>
             SI is the integer part of the quotient (N&nbhy;1)/BitStringLength.
            </t>
            <t>
             The BitString has one bit position set.  If the low-order bit
             is bit 1 and the high-order bit is bit BitStringLength, the
             bit position that represents BFR&nbhy;id N is
             ((N&nbhy;1)&nbsp;modulo&nbsp;BitStringLength)+1.
            </t>
          </list>
        </t>
        <t>
          If several different BFR&nbhy;ids all resolve to the same SI, then
          all of those BFR&nbhy;ids can be represented in a single BitString.
          The BitStrings for all of those BFR&nbhy;ids are combined using a
          bitwise logical OR operation.
        </t>
        <t>
          Within a given BIER domain (or even within a given BIER
          sub&nbhy;domain), different values of BitStringLength may be used.
          Each BFR MUST be provisioned to know the following:
          <list style="symbols">
            <t>
              The BitStringLength ("Imposition BitStringLength") and
              sub&nbhy;domain ("Imposition sub&nbhy;domain") to use when it
              imposes (as a BFIR) a BIER encapsulation on a particular set
              of packets, and
            </t>
            <t>
              The BitStringLengths ("Disposition BitStringLengths") that it
              will process when (as a BFR or BFER) it receives packets from
              a particular sub&nbhy;domain.
            </t>
          </list>
          It is not required that a BFIR use the same Imposition
          BitStringLength or the same Imposition sub&nbhy;domain for all
          packets on which it imposes the BIER encapsulation.  However, if a
          particular BFIR is provisioned to use a particular Imposition
          BitStringLength and a particular Imposition sub&nbhy;domain when
          imposing the encapsulation on a given set of packets, all other
          BFRs with BFR&nbhy;ids in that sub&nbhy;domain SHOULD be
          provisioned to process received BIER packets with that
          BitStringLength (i.e., all other BFRs with BFR&nbhy;ids in that
          sub&nbhy;domain SHOULD be provisioned with that BitStringLength as
          a Disposition BitStringLength for that sub&nbhy;domain).
          Exceptions to this rule MAY be made under certain conditions; this
          is discussed in <xref target="different_bsls"/>.
        </t>

        <t>
          When a BIER encapsulation is specified, the specification MUST
          define a default BitStringLength for the encapsulation.  Every
          BFIR supporting that encapsulation MUST be capable of being
          provisioned with that default BitStringLength as its Imposition
          BitStringLength.  Every BFR and BFER supporting that encapsulation
          MUST be capable of being provisioned with that default
          BitStringLength as a Disposition BitStringLength.
        </t>
        <t>
          The specification of a BIER encapsulation MAY also allow the use
          of other BitStringLengths.
        </t>

        <t>
          If a BFR is capable of being provisioned with a given value of
          BitStringLength as an Imposition BitStringLength, it MUST also be
          capable of being provisioned with that same value as one of its
          Disposition BitStringLengths.  It SHOULD be capable of being
          provisioned with each legal smaller value of BitStringLength as
          (a) its Imposition BitStringLength, and (b) one of its Disposition
          BitStringLengths.
        </t>
        <t>
          In order to support transition from one BitStringLength to
          another, every BFR MUST be capable of being provisioned to
          simultaneously use two different Disposition BitStringLengths.  
        </t>
        <t>
          A BFR MUST support SI values in the range [0,15] and MAY support
          SI values in the range [0,255].  ("Supporting the values in a
          given range" means, in this context, that any value in the given
          range is legal and will be properly interpreted.)  Note that for
          a given BitStringLength, the total number of BFR&nbhy;ids that can be
          represented is the product of the BitStringLength and the number
          of supported SIs.  For example, if a deployment uses (in a given
          sub&nbhy;domain) a BitStringLength of 64 and supports 256 SIs, that
          deployment can only support 16384 BFR&nbhy;ids in that
          sub&nbhy;domain. Even a deployment that supports 256 SIs will not be
          able to support 65,535 BFR&nbhy;ids unless it uses a BitStringLength
          of at least 256. 
        </t>

        <t>
          When a BFIR determines that a multicast data packet, assigned to a
          given sub&nbhy;domain, needs to be forwarded to a particular set
          of destination BFERs, the BFIR partitions that set of BFERs into
          subsets, where each subset contains the target BFERs whose
          BFR&nbhy;ids in the given sub&nbhy;domain all resolve to the same
          SI.  Call these the "SI&nbhy;subsets" for the packet.  Each
          SI&nbhy;subset can be represented by a single BitString.  The BFIR
          creates a copy of the packet for each SI&nbhy;subset.  The BIER
          encapsulation is then applied to each packet.  The encapsulation
          specifies a single SI for each packet and contains the BitString
          that represents all the BFR&nbhy;ids in the corresponding
          SI&nbhy;subset.  Of course, in order to properly interpret the
          BitString, it must be possible to infer the
          sub&nbhy;domain&nbhy;id from the encapsulation as well.
        </t>
        <t>
          Suppose, for example, that a BFIR determines that a given packet
          needs to be forwarded to three BFERs, whose BFR&nbhy;ids (in the
          appropriate sub&nbhy;domain) are 27, 235, and 497.  The BFIR will
          have to forward two copies of the packet.  One copy, associated
          with SI=0, will have a BitString with bits 27 and 235 set.  The
          other copy, associated with SI=1, will have a BitString with bit
          241 set.
        </t>

         <t>
          In order to minimize the number of copies that must be made of a
          given multicast packet, it is RECOMMENDED that the BFR&nbhy;ids
          used in a given sub&nbhy;domain be assigned "densely" (see <xref
          target="BFR-id"/>) from the numbering space.  This will minimize
          the number of SIs that have to be used in that sub&nbhy;domain.
          However, depending upon the details of a particular deployment,
          other assignment methods may be more advantageous.  Suppose, for
          example, that in a certain deployment, every multicast flow is
          intended either for the "east coast" or for the "west coast", but
          not for both coasts.  In such a deployment, it would be
          advantageous to assign BFR&nbhy;ids so that all the "west coast"
          BFR&nbhy;ids fall into the same SI&nbhy;subset and so that all the
          "east coast" BFR&nbhy;ids fall into the same SI&nbhy;subset.
        </t>
        <t>
          When a BFR receives a BIER data packet, it will infer the SI from
          the encapsulation.  The set of BFERs to which the packet
          needs to be forwarded can then be inferred from the SI and the
          BitString.
        </t>
        <t>
          In some of the examples given later in this document, we will use
          a BitStringLength of 4 and will represent a BFR&nbhy;id in the
          form "SI:xyzw", where SI is the Set Identifier of the BFR&nbhy;id
          (assuming a BitStringLength of 4) and xyzw is a string of 4 bits.
          A BitStringLength of 4 is used only in the examples; we would not
          expect actual deployments to have such a small BitStringLength.
        </t>
        <t>
          It is possible that several different forms of BIER encapsulation
          will be developed.  If so, the particular encapsulation that is
          used in a given deployment will depend on the type of network
          infrastructure that is used to realize the BIER domain.  Details
          of the BIER encapsulation(s) will be given in companion documents.
          An encapsulation for use in MPLS networks is described in <xref
          target="MPLS_BIER_ENCAPS"/>; that document also describes a very
          similar encapsulation that can be used in non-MPLS networks.
        </t>
      </section>
      
      <section title="Layering" anchor="Layering">
        <t>
          It is helpful to think of the BIER architecture as consisting of
          three layers: the "routing underlay", the "BIER layer", and the
          "multicast flow overlay".
        </t>
        <section title="The Routing Underlay" anchor="underlay">
          <t>
            The "routing underlay" establishes "adjacencies" between pairs
            of BFRs and determines one or more "best paths" from a given
            BFR to a given set of BFRs.  Each such path is a sequence of
            BFRs &lt;BFR(k),&nbsp;BFR(k+1),&nbsp;...,&nbsp;BFR(k+n)&gt;
            such that BFR(k+j) is "adjacent" to BFR(k+j+1)
            (for&nbsp;0&lt;=j&lt;n).
          </t>
          <t>
            At a given BFR, say BFR&nbhy;A, for every IP address that is the
            address of a BFR in the BIER domain, the routing underlay will
            map that IP address into a set of one or more "equal&nbhy;cost"
            adjacencies.  If a BIER data packet has to be forwarded by
            BFR&nbhy;A to a given BFER, say BFER&nbhy;B, the packet will
            follow the path from BFR&nbhy;A to BFER&nbhy;B that is
            determined by the routing underlay.
          </t>
          <t>
            It is expected that in a typical deployment, the routing
            underlay will be the default topology that the Interior Gateway
            Protocol (IGP), e.g., OSPF, uses for unicast routing.  In that
            case, the underlay adjacencies are just the OSPF adjacencies.  A
            BIER data packet traveling from BFR&nbhy;A to BFER&nbhy;B will
            follow the path that OSPF has selected for unicast traffic from
            BFR&nbhy;A to BFER&nbhy;B.
          </t>
          <t>
            If one wants to have multicast traffic from BFR&nbhy;A to
            BFER&nbhy;B travel a path that is different from the path used
            by the unicast traffic from BFR&nbhy;A to BFER&nbhy;B, one can
            use a different underlay.  For example, if multi&nbhy;topology
            OSPF is being used, one OSPF topology could be used for unicast
            traffic and the other for multicast traffic.  (Each topology would
            be considered to be a different underlay.)  Alternatively, one
            could deploy a routing underlay that creates a multicast-specific
            tree of some sort.  BIER could then be used to forward multicast
            data packets along the multicast-specific tree, while unicast
            packets follow the "ordinary" OSPF best path. (In a case like
            this, many multicast flows could be traveling along a single tree,
            and the BitString carried by a particular packet would identify
            those nodes of the tree that need to receive that packet.)  It is
            even possible to have multiple routing underlays used by BIER, as
            long as one can infer from a data packet's BIER encapsulation
            which underlay is being used for that packet.
          </t>
          <t>
            If multiple routing underlays are used in a single BIER domain,
            each BIER sub&nbhy;domain MUST be associated with a single
            routing underlay (though multiple sub&nbhy;domains may be
            associated with the same routing underlay).  A BFR that belongs
            to multiple sub&nbhy;domains MUST be provisioned to know which
            routing underlay is used by each sub&nbhy;domain.  By default
            (i.e., in the absence of any provisioning to the contrary), each
            sub&nbhy;domain uses the default topology of the unicast IGP as
            the routing underlay.
          </t>
          <t>
            In scenarios where External BGP (EBGP) is used as the IGP, the
            underlay adjacencies, by default, are the BGP adjacencies.
          </t>
          <t>
            Specification of the protocols and procedures of the routing
            underlay is outside the scope of this document.
          </t>
        </section>
        
        <section title="The BIER Layer" anchor="BierLayer">
          <t>
            The BIER layer consists of the protocols and procedures that are
            used in order to transmit a multicast data packet across a BIER
            domain, from its BFIR to its BFERs.  This includes the following
            components:
          </t>
          <t>
            <list style="symbols">
              <t>
                Protocols and procedures that a given BFR uses to advertise,
                to all other BFRs in the same BIER domain:
                <list style="symbols">
                  <t>
                   its BFR&nbhy;prefix;
                  </t>
                  <t>
                    its BFR&nbhy;id in each sub&nbhy;domain for which it has
                    been provisioned with a BFR&nbhy;id;
                  </t>
                  <t>
                    the set of Disposition BitStringLengths it has been
                    provisioned to use for each sub&nbhy;domain;
                  </t>
                  <t>
                    optionally, information about the routing underlay
                    associated with each sub&nbhy;domain.
                  </t>
                </list>
              </t>
              <t>
                The procedures used by a BFIR to impose a BIER header on a
                multicast data packet.
              </t>
              <t>
                The procedures for forwarding BIER&nbhy;encapsulated
                packets and for modifying the BIER header during transit.
              </t>
              <t>
                The procedures used by a BFER to decapsulate a BIER packet
                and properly dispatch it.
              </t>
            </list>
          </t>
        </section>
        
        <section title="The Multicast Flow Overlay">
          <t>
            The "multicast flow overlay" consists of the set of protocols
            and procedures that enable the following set of functions.
          </t>
          <t>
            <list style="symbols">
              <t>
                When a BFIR receives a multicast data packet from outside
                the BIER domain, the BFIR must determine the set of BFERs
                for that packet.  This information is provided by the
                multicast flow overlay.
              </t>
              <t>
                When a BFER receives a BIER&nbhy;encapsulated packet from
                inside the BIER domain, the BFER must determine how to
                further forward the packet.  This information is provided by
                the multicast flow overlay.
              </t>
            </list>
          </t>
          <t>
              For example, suppose the BFIR and BFERs are Provider Edge (PE)
              routers providing Multicast Virtual Private Network (MVPN)
              service.  The multicast flow overlay consists of the protocols
              and procedures described in <xref target="RFC6513"/> and <xref
              target="RFC6514"/>.  The MVPN signaling described in those
              RFCs enables an ingress PE to determine the set of egress PEs
              for a given multicast flow (or set of flows); it also enables
              an egress PE to determine the "Virtual Routing and Forwarding
              Tables" (VRFs) to which multicast packets from the backbone
              network should be sent.  MVPN signaling also has several
              components that depend on the type of "tunneling technology"
              used to carry multicast data through the network.  Since BIER
              is, in effect, a new type of "tunneling technology", some
              extensions to the MVPN signaling are needed in order to properly
              interface the multicast flow overlay with the BIER layer.
              These are specified in <xref target="BIER_MVPN"/>.
            </t>

            <t>
              MVPN is just one example of a multicast flow overlay.
              Protocols and procedures for other overlays will be provided
              in companion documents.  It is also possible to implement the
              multicast flow overlay by means of a "Software-Defined
              Network" (SDN) controller.  Specification of the protocols and
              procedures of the multicast flow overlay is outside the scope
              of this document.
            </t>
        </section>
      </section>

      <section title="Advertising BFR-ids and BFR-Prefixes"
               anchor="advertising"> 
        <t>
          As stated in <xref target="BFR-id"/>, each BFER is assigned (by
          provisioning) a BFR&nbhy;id (for a given BIER sub&nbhy;domain).
          Each BFER must advertise these assignments to all the other BFRs
          in the domain.  Similarly, each BFR is assigned (by provisioning)
          a BFR&nbhy;prefix (for a given BIER domain) and must advertise
          this assignment to all the other BFRs in the domain.  Finally,
          each BFR has been provisioned to use a certain set of Disposition
          BitStringLengths for each sub&nbhy;domain and must advertise
          these to all other BFRs in the domain.
        </t>
        <t>
          If the BIER domain is also a link-state routing IGP domain (i.e.,
          an OSPF or IS&nbhy;IS domain), the advertisement of the
          BFR&nbhy;prefix, &lt;sub&nbhy;domain&nbhy;id, BFR&nbhy;id&gt;, and
          BitStringLength can be done using the advertisement capabilities
          of the IGP.  For example, if a BIER domain is also an OSPF domain,
          these advertisements can be done using the OSPF "Opaque Link State
          Advertisement" (Opaque LSA) mechanism.  Details of the necessary
          extensions to OSPF and IS&nbhy;IS will be provided in companion
          documents.  (See <xref target="OSPF_BIER_EXTENSIONS"/> and <xref
          target="ISIS_BIER_EXTENSIONS"/>.)
        </t>
        <t>
          If, in a particular deployment, the BIER domain is not an OSPF or
          IS&nbhy;IS domain, procedures suitable to the deployment must be
          used to advertise this information.  Details of the necessary
          procedures will be provided in companion documents.  For example, if
          BGP is the only routing algorithm used in the BIER domain, the
          procedures of <xref target="BGP_BIER_EXTENSIONS"/> may be used.
        </t>
        <t>
          These advertisements enable each BFR to associate a given
          &lt;sub&nbhy;domain&nbhy;id, BFR&nbhy;id&gt; with a given
          BFR&nbhy;prefix.  As will be seen in subsequent sections of this
          document, knowledge of this association is an important part of
          the forwarding process.
        </t>
        <t>
          Since each BFR needs to have a unique (in each sub&nbhy;domain)
          BFR&nbhy;id, two different BFRs will not advertise ownership of
          the same &lt;sub&nbhy;domain&nbhy;id, BFR&nbhy;id&gt; unless there
          has been a provisioning error.
          <list style="symbols">
            <t>
              If BFR&nbhy;A determines that BFR&nbhy;B and BFR&nbhy;C have
              both advertised the same BFR&nbhy;id for the same
              sub&nbhy;domain, BFR&nbhy;A MUST log an error.  Suppose that the
              duplicate BFR&nbhy;id is "N".  When BFR&nbhy;A is functioning as
              a BFIR, it MUST NOT encode the BFR&nbhy;id value N in the BIER
              encapsulation of any packet that has been assigned to the
              given sub&nbhy;domain, even if it has determined that the packet
              needs to be received by BFR&nbhy;B and/or BFR&nbhy;C.
              <vspace blankLines="1"/>
              This will mean that BFR&nbhy;B and BFR&nbhy;C cannot receive
              multicast traffic at all in the given sub&nbhy;domain until the
              provisioning error is fixed.  However, that is preferable to
              having them receive each other's traffic.
            </t>
            <t>
              Suppose that BFR&nbhy;A has been provisioned with
              BFR&nbhy;id&nbsp;N for a particular sub&nbhy;domain but that it
              has not yet advertised its ownership of BFR&nbhy;id&nbsp;N for
              that sub&nbhy;domain.  Suppose also that it has received an
              advertisement from a different BFR (say BFR&nbhy;B) that is
              advertising ownership of BFR&nbhy;id&nbsp;N for the same
              sub&nbhy;domain.  In such a case, BFR&nbhy;A SHOULD log an
              error and MUST&nbsp;NOT advertise its own ownership of
              BFR&nbhy;id&nbsp;N for that sub&nbhy;domain as long as
              the advertisement from BFR&nbhy;B is extant.
              <vspace blankLines="1"/>
              This procedure may prevent the accidental misconfiguration of
              a new BFR from impacting an existing BFR.
            </t>
            </list>
        </t>
        <t>
          If a BFR advertises that it has a BFR&nbhy;id of 0 in a particular
          sub&nbhy;domain, other BFRs receiving the advertisement MUST
          interpret that advertisement as meaning that the advertising BFR
          does not have a BFR&nbhy;id in that sub&nbhy;domain.
        </t>
      </section>

      <section title="BIER Intra-Domain Forwarding Procedures"
               anchor="forwarding">
        <t>
          This section specifies the rules for forwarding a
          BIER&nbhy;encapsulated data packet within a BIER domain.  These rules
          are not intended to specify an implementation strategy; to conform
          to this specification, an implementation need only produce the
          same results that these rules produce.
        </t>
        <section title="Overview">
          <t>
            This section provides a brief overview of the BIER forwarding
            procedures.  Subsequent subsections specify the procedures in
            more detail.
          </t>
          <t>
            To forward a BIER&nbhy;encapsulated packet:
            <list style="numbers">
              <t>
                Determine the packet's sub&nbhy;domain.
              </t>
              <t>
                Determine the packet's BitStringLength and BitString.
              </t>
              <t>
                Determine the packet's SI.
              </t>
              <t>
                From the sub&nbhy;domain, the SI, and the BitString,
                determine the set of destination BFERs for the packet.
              </t>
              <t>
                Using information provided by the routing underlay
                associated with the packet's sub&nbhy;domain, determine
                the next&nbhy;hop adjacency for each of the destination BFERs.
              </t>
              <t>
                It is possible that the packet's BitString will have one or
                more bits that correspond to BFR&nbhy;ids that are not in
                use.  It is also possible that the packet's BitString will
                have one or more bits that correspond to BFERs that are
                unreachable, i.e., that have no next&nbhy;hop adjacency.  In
                the following, we will consider the "next&nbhy;hop adjacency"
                for all such bit positions to be the "null" next hop.
              </t>
              <t>
                Partition the set of destination BFERs such that all the
                BFERs in a single partition have the same next hop.  We will
                say that each partition is associated with a next hop.
              </t>
              <t>
                For each partition:
                <list style="format %c.">
                  <t>
                    Make a copy of the packet.
                  </t>
                  <t>
                    Clear any bit in the packet's BitString that identifies
                    a BFER that is not in the partition.
                  </t>
                  <t>
                    Transmit the packet to the associated next hop.  (If the
                    next&nbsp;hop is the null next hop, the packet is
                    discarded.)
                  </t>
                </list>
              </t>
            </list>
          </t>
          <t>
            If a BFR receives a BIER&nbhy;encapsulated packet whose
            &lt;sub&nbhy;domain, SI, BitString&gt; triple identifies that
            BFR itself, then the BFR is also a BFER for that packet.  As a
            BFER, it must pass the payload to the multicast flow overlay.
            If the BitString has bits set for other BFRs, the packet also
            needs to be forwarded further within the BIER domain.  If the
            BF(E)R also forwards one or more copies of the packet within the
            BIER domain, the bit representing the BFR's own BFR&nbhy;id MUST
            be clear in all the copies.
          </t>
          <t>
            When BIER on a BFER is to pass a packet to the multicast flow
            overlay, it of course decapsulates the packet by removing the
            BIER header.  However, it may be necessary to provide the
            multicast flow overlay with contextual information obtained from
            the BIER encapsulation.  The information that needs to pass
            between the BIER layer and the multicast flow overlay is
            specific to the multicast flow overlay.  Specification of the
            interaction between the BIER layer and the multicast flow
            overlay is outside the scope of this specification.
          </t>
          <t>
            If the BIER encapsulation contains a "Time to Live" (TTL) value,
            this value is not, by default, inherited by the payload. If a
            particular multicast flow overlay needs to know the TTL value,
            this needs to be specified in whatever specification defines the
            interaction between BIER and that multicast flow overlay.
          </t>
          <t>
            If the BIER encapsulation contains a Traffic Class field, a
            Type&nbsp;of&nbsp;Service field, a Differentiated Services field,
            or any field of that sort, the value of that field is not, by
            default, passed to the multicast flow overlay. If a particular
            multicast flow overlay needs to know the values of such fields,
            this fact needs to be specified in whatever specification defines
            the interaction between BIER and that multicast flow overlay.
          </t>
          <t>
            When BIER on a BFER passes a packet to the multicast flow
            overlay, the overlay will determine how to further dispatch the
            packet.  If the packet needs to be forwarded into another BIER
            domain, then the BFR will act as a BFER in one BIER domain and
            as a BFIR in another.  A BIER&nbhy;encapsulated packet cannot pass
            directly from one BIER domain to another; at the boundary
            between BIER domains, the packet must be decapsulated and passed
            to the multicast flow overlay.
          </t>
          <t>
            Note that when a BFR transmits multiple copies of a packet
            within a BIER domain, only one copy will be destined to any
            given BFER.  Therefore, it is not possible for any
            BIER&nbhy;encapsulated packet to be delivered more than once
            to any BFER.
          </t>
        </section>
        <section title="BFR Neighbors" anchor="BFR-NBR">
          <t>
            The "BFR Neighbors" (BFR&nbhy;NBRs) of a given BFR, say
            BFR&nbhy;A, are those BFRs that, according to the routing
            underlay, are adjacencies of BFR&nbhy;A.  Each BFR&nbhy;NBR will
            have a BFR&nbhy;prefix.
          </t>
          <t>
            Suppose a BIER&nbhy;encapsulated packet arrives at BFR&nbhy;A.
            From the packet's encapsulation, BFR&nbhy;A learns (a)&nbsp;the
            sub&nbhy;domain of the packet and (b)&nbsp;the BFR&nbhy;ids (in
            that sub&nbhy;domain) of the BFERs to which the packet is destined.
            Then, using the information advertised per <xref
            target="advertising"/>, BFR&nbhy;A can find the BFR&nbhy;prefix of
            each destination BFER.  Given the BFR&nbhy;prefix of a particular
            destination BFER, say BFER&nbhy;D, BFR&nbhy;A learns from the
            routing underlay (associated with the packet's sub&nbhy;domain) an
            IP address of the BFR that is the next hop on the path from
            BFR&nbhy;A to BFER&nbhy;D.  Let's call this next hop "BFR&nbhy;B".
            BFR&nbhy;A must then determine the BFR&nbhy;prefix of BFR&nbhy;B.
            (This determination can be made from the information advertised
            per <xref target="advertising"/>.)  This BFR&nbhy;prefix is the
            BFR&nbhy;NBR of BFR&nbhy;A on the path from BFR&nbhy;A to
            BFER&nbhy;D.
          </t>
          <t>
            Note that if the routing underlay provides multiple
            equal&nbhy;cost paths from BFR&nbhy;A to BFER&nbhy;D,
            BFR&nbhy;A may have multiple BFR&nbhy;NBRs for BFER&nbhy;D.
          </t>
          <t>
            Under certain circumstances, a BFR may have adjacencies (in a
            particular routing underlay) that are not BFRs.  Please see
            <xref target="non-bier"/> for a discussion of how to handle
            those circumstances.
          </t>
      </section>

      <section title="The Bit Index Routing Table" anchor="BIRT">
        <t>
          The "Bit Index Routing Table" (BIRT) is a table that maps from the
          BFR&nbhy;id (in a particular sub&nbhy;domain) of a BFER to the
          BFR&nbhy;prefix of that BFER, and to the BFR&nbhy;NBR on the path
          to that BFER.  As an example, consider the topology shown in
          <xref target="BIER_TOPO1"/>.  In this diagram, we represent the
          BFR&nbhy;id of each BFR in the SI:xyzw form discussed
          in <xref target="encoding"/>.
        </t>

        <figure align="center" anchor="BIER_TOPO1" title="BIER Topology 1">
          <artwork align="center"><![CDATA[
 ( A ) ------------ ( B ) ------------ ( C ) ------------ ( D ) 
4 (0:1000)             \                  \           1 (0:0001)
                        \                  \    
                        ( E )              ( F ) 
                      3 (0:0100)         2 (0:0010)
]]></artwork>
        </figure>

        <t>
        This topology will result in the BIRT of <xref target="BIER_RIB"/> at
        BFR&nbhy;B.  The first column shows the BFR&nbhy;id as a number and
        also (in parentheses) in the SI:BitString format that corresponds to a
        BitStringLength of&nbsp;4.  (The actual minimum BitStringLength
        is 64, but we use 4 in the examples.)
        </t>
        <t>
        Note that a BIRT is specific to a particular BIER sub&nbhy;domain.
        </t>

        <figure align="center" anchor="BIER_RIB"
                title="Bit Index Routing Table at BFR-B">
          <artwork align="center"><![CDATA[
--------------------------------------------
|     BFR-id     |  BFR-Prefix  | BFR-NBR  | 
| (SI:BitString) | of Dest BFER |          |
============================================
|   4 (0:1000)   |     A        |     A    |
--------------------------------------------
|   1 (0:0001)   |     D        |     C    |
--------------------------------------------
|   3 (0:0100)   |     E        |     E    |
--------------------------------------------
|   2 (0:0010)   |     F        |     C    |
--------------------------------------------
]]></artwork>
        </figure>
      </section>

      <section title="The Bit Index Forwarding Table" anchor="BIFT">
        <t>
          The "Bit Index Forwarding Table" (BIFT) is derived from the BIRT
          as follows. (Note that a BIFT is specific to a particular
          sub&nbhy;domain.)
        </t>
        <t>
          Suppose that several rows in the BIRT have the same SI and the
          same BFR&nbhy;NBR.  By taking the logical OR of the BitStrings of
          those rows, we obtain a bit mask that corresponds to that
          combination of SI and BFR&nbhy;NBR.  We will refer to this bit
          mask as the "Forwarding Bit Mask" (F&nbhy;BM) for that
          &lt;SI,&nbsp;BFR&nbhy;NBR&gt; combination.
        </t>
        <t>
          For example, in <xref target="BIER_RIB"/>, we see that two of the
          rows have the same SI (0) and same BFR&nbhy;NBR (C).  The bit mask
          that corresponds to &lt;SI=0,&nbsp;BFR&nbhy;NBR&nbhy;C&gt; is
          0011 ("0001" OR'd with "0010").
        </t>
        <t>
          The BIFT is used to map from the BFR&nbhy;id of a BFER to the
          corresponding F&nbhy;BM and BFR&nbhy;NBR.  For example, <xref
          target="BIER_FIB"/> shows the BIFT that is derived from the BIRT
          of <xref target="BIER_RIB"/>.  Note that BFR&nbhy;ids 1 and 2 have
          the same SI and the same BFR&nbhy;NBR; hence, they have the
          same&nbsp;F&nbhy;BM.
        </t>

        <figure align="center" anchor="BIER_FIB" title="Bit Index Forwarding Table">
          <artwork align="center"><![CDATA[
-------------------------------------
|      BFR-id    |  F-BM  | BFR-NBR |
| (SI:BitString) |        |         |
=====================================
|   1 (0:0001)   |  0011  |    C    |
-------------------------------------
|   2 (0:0010)   |  0011  |    C    |
-------------------------------------
|   3 (0:0100)   |  0100  |    E    |
-------------------------------------
|   4 (0:1000)   |  1000  |    A    |
-------------------------------------
]]></artwork>
        </figure>
        <t>
          This BIFT is programmed into the data plane and used to forward
          packets, applying the rules specified below in
          <xref target="rules"/>.
        </t>
      </section>

      <section title="The BIER Forwarding Procedure" anchor="rules">
        <t>
          Below is the procedure that a BFR uses for forwarding a
          BIER&nbhy;encapsulated packet.
          <list style="numbers">
            <t>
              Determine the packet's SI, BitStringLength, and sub&nbhy;domain.
            </t>
            <t anchor="ifallzeroes">
              If the BitString consists entirely of zeroes, discard the
              packet; the forwarding process has been completed.  Otherwise,
              proceed to step <xref target="rightbit" format="counter"/>.
            </t>
            <t anchor="rightbit">
              Find the position (call it "k") of the least significant
              (i.e., of the rightmost) bit that is set in the packet's
              BitString.  (Remember, bits are numbered from 1, starting with
              the least significant bit.)
            </t>
            <t>
              If bit k identifies the BFR itself, copy the packet, and send
              the copy to the multicast flow overlay.  Then clear bit k in
              the original packet, and go to step <xref target="ifallzeroes"
              format="counter"/>.  Otherwise, proceed to step <xref
              target="index" format="counter"/>.
            </t>
            <t anchor="index">
              Use the value k, together with the SI, sub&nbhy;domain, and
              BitStringLength, as the "index" into the BIFT.
            </t>
            <t>
              Extract from the BIFT the F&nbhy;BM and the BFR&nbhy;NBR.
            </t>
            <t>
              Copy the packet.  Update the copy's BitString by AND'ing it
              with the F&nbhy;BM (i.e.,
              PacketCopy-&gt;BitString&nbsp;&amp;=&nbsp;F&nbhy;BM).  Then
              forward the copy to the BFR&nbhy;NBR.  (If the BFR&nbhy;NBR is
              null, the copy is just discarded.)  Note that when a packet is
              forwarded to a particular BFR&nbhy;NBR, its BitString
              identifies only those BFERs that are to be reached via that
              BFR&nbhy;NBR.
            </t>
            <t>
              Now update the original packet's BitString by AND'ing it with
              the INVERSE of the F&nbhy;BM (i.e.,
              Packet-&gt;BitString&nbsp;&amp;=&nbsp;~F&nbhy;BM).  (This clears
              the bits that identify the BFERs to which a copy of the packet
              has just been forwarded.)  Go to step <xref
              target="ifallzeroes" format="counter"/>.
            </t>
          </list>
        </t>
        <t>
          This procedure causes the packet to be forwarded to a particular
          BFR&nbhy;NBR only once.  The number of lookups in the BIFT is the
          same as the number of BFR&nbhy;NBRs to which the packet must be
          forwarded; it is not necessary to do a separate lookup for each
          destination BFER.
        </t>
        <t>
          When a packet is sent to a particular BFR&nbhy;NBR, the BitString is
          not the only part of the BIER header that needs to be modified. If
          there is a TTL field in the BIER header, it will need to be
          decremented.  In addition, when either of the encapsulations of
          <xref target="MPLS_BIER_ENCAPS"/> is used, the BIFT&nbhy;id field is
          likely to require modification, based on signaling from the
          BFR&nbhy;NBR to which the packet is being sent.  The
          BIFT&nbhy;id field of an incoming BIER packet implicitly identifies
          an SI, a sub&nbhy;domain, and a BitStringLength.  If the packet is
          sent to a particular BFR&nbhy;NBR, the BIFT&nbhy;id field must be
          changed to whatever value that BFR&nbhy;NBR has advertised for the
          same SI, sub&nbhy;domain, and BitStringLength. (If the
          encapsulation of Section&nbsp;2.1 of
          <xref target="MPLS_BIER_ENCAPS"/> is used, this is
          essentially an MPLS label swap operation.)
        </t>
        <t>
          Suppose it has been decided (by the above rules) to send a packet
          to a particular BFR&nbhy;NBR.  If that BFR&nbhy;NBR is connected
          via multiple parallel interfaces, it may be desirable to apply
          some form of load balancing.  Load&nbhy;balancing algorithms are
          outside the scope of this document.  However, if the packet's
          encapsulation contains an entropy field, the entropy field
          SHOULD be respected; two packets with the same value of the
          entropy field SHOULD be sent on the same interface (if possible).
        </t>
        <t>
          In some cases, the routing underlay may provide multiple
          equal&nbhy;cost paths (through different BFR&nbhy;NBRs) to a
          given BFER. This is known as "Equal&nbhy;Cost Multipath"
          (ECMP).  The procedures described in this section must be
          augmented in order to support load balancing over ECMP.  The
          necessary augmentations can be found in <xref target="ECMP"/>.
        </t>
        <t>
          In the event that unicast traffic to the BFR&nbhy;NBR is being
          sent via a "bypass tunnel" of some sort, the BIER&nbhy;encapsulated
          multicast traffic sent to the BFR&nbhy;NBR SHOULD also be sent via
          that tunnel.  This allows any existing "fast reroute" schemes to
          be applied to multicast traffic as well as to unicast traffic.
        </t>
        <t>
          Some examples of these forwarding procedures can be found in <xref
          target="example"/>.
        </t>
        <t>
          The rules given in this section can be represented by the
          following pseudocode:
          <figure align="center" anchor="Pseudocode" title="Pseudocode">
            <artwork align="left"><![CDATA[
void ForwardBitMaskPacket (Packet)
{
    SI=GetPacketSI(Packet);
    Offset=SI*BitStringLength;
    for (Index = GetFirstBitPosition(Packet->BitString); Index ;
         Index = GetNextBitPosition(Packet->BitString, Index)) {
        F-BM = BIFT[Index+Offset]->F-BM;
        if (!F-BM) continue;
        BFR-NBR = BIFT[Index+Offset]->BFR-NBR;
        PacketCopy = Copy(Packet);
        PacketCopy->BitString &= F-BM;
        PacketSend(PacketCopy, BFR-NBR);
        Packet->BitString &= ~F-BM;
    }
}]]>
            </artwork>
          </figure>
        </t>
        <t>
          This pseudocode assumes that, at a given BFER, the BFR&nbhy;NBR
          entry corresponding to the BFER's own BFR&nbhy;id will be the
          BFER's own BFR&nbhy;prefix.  It also assumes that the
          corresponding F&nbhy;BM has only one&nbsp;bit set, the bit
          representing the BFER itself.  In this case, the
          "PacketSend" function sends the packet to the multicast flow overlay.
        </t>
        <t>
          This pseudocode also assumes that the F&nbhy;BM for the null next
          hop contains a 1 in a given bit position if and only if that bit
          position corresponds to either an unused BFR&nbhy;id or an
          unreachable BFER.  When the BFR&nbhy;NBR is null, the "PacketSend"
          function discards the packet.
        </t>
      </section>

      <section title="Examples of BIER Forwarding" anchor="example">
        <t>
          In this section, we give two examples of BIER forwarding, based on
          the topology in <xref target="BIER_TOPO1"/>.  In these examples,
          all packets have been assigned to the default sub&nbhy;domain, all
          packets have SI=0, and the BitStringLength is 4.  <xref
          target="example_bifts"/> shows the BIFT entries for SI=0 only.
          For compactness, we show the first column of the BIFT, the
          BFR&nbhy;id, only as an integer.
        </t>
        <figure align="center" anchor="example_bifts"
                title="BIFTs Used in the Forwarding Examples">
          <artwork align="center"><![CDATA[
     BFR-A BIFT            BFR-B BIFT            BFR-C BIFT
-------------------   -------------------   -------------------
| Id | F-BM | NBR |   | Id | F-BM | NBR |   | Id | F-BM | NBR |
===================   ===================   ===================
|  1 | 0111 |  B  |   |  1 | 0011 |  C  |   |  1 | 0001 |  D  |
-------------------   -------------------   -------------------   
|  2 | 0111 |  B  |   |  2 | 0011 |  C  |   |  2 | 0010 |  F  |
-------------------   -------------------   -------------------   
|  3 | 0111 |  B  |   |  3 | 0100 |  E  |   |  3 | 1100 |  B  |
-------------------   -------------------   -------------------   
|  4 | 1000 |  A  |   |  4 | 1000 |  A  |   |  4 | 1100 |  B  |
-------------------   -------------------   -------------------   
]]></artwork>
        </figure>

        <section title = "Example 1">
          <t>
            BFR&nbhy;D, BFR&nbhy;E, and BFR&nbhy;F are BFERs.  BFR&nbhy;A is
            the BFIR. Suppose that BFIR&nbhy;A has learned from the
            multicast flow overlay that BFER&nbhy;D is interested in a given
            multicast flow. If BFIR&nbhy;A receives a packet of that flow
            from outside the BIER domain, BFIR&nbhy;A applies the BIER
            encapsulation to the packet.  The encapsulation must be such
            that the SI is zero.  The encapsulation also includes a
            BitString, with just bit 1 set and with all other bits clear
            (i.e., 0001).  This indicates that BFER&nbhy;D is the only BFER
            that needs to receive the packet.  BFIR&nbhy;A then follows the
            procedures of <xref target="rules"/>, as follows:
          </t>
          <t>
            <list style="symbols">
              <t>
                Since the packet's BitString is 0001, BFIR&nbhy;A finds that
                the first bit in the string is bit 1.  Looking at entry 1 in
                its BIFT, BFR&nbhy;A determines that the bit mask F&nbhy;BM
                is 0111 and the BFR&nbhy;NBR is BFR&nbhy;B.
              </t>
              <t>
                BFR&nbhy;A then makes a copy of the packet and applies the
                F&nbhy;BM to the copy:
                Copy-&gt;BitString&nbsp;&amp;=&nbsp;0111.  The copy's BitString
                is now 0001 (0001&nbsp;&amp;&nbsp;0111).
              </t>
              <t>
                The copy is now sent to BFR&nbhy;B.
              </t>
              <t>
                BFR&nbhy;A then updates the packet's BitString by applying
                the inverse of the F&nbhy;BM:
                Packet-&gt;BitString&nbsp;&amp;=&nbsp;~F&nbhy;BM.  As a result,
                the packet's BitString is now 0000
                (0001&nbsp;&amp;&nbsp;1000).
              </t>
              <t>
                As the packet's BitString is now zero, the forwarding
                procedure is complete.
              </t>
            </list>
          </t>
          <t>
            When BFR&nbhy;B receives the multicast packet from BFR&nbhy;A,
            it follows the same procedure.  The result is that a copy of the
            packet, with a BitString of 0001, is sent to BFR&nbhy;C.
            BFR&nbhy;C applies the same procedures and, as a result, sends a
            copy of the packet, with a BitString of 0001, to BFR&nbhy;D.
          </t>
          <t>
            At BFER&nbhy;D, the BIFT entry (not pictured) for BFR&nbhy;id 1
            will specify an F&nbhy;BM of 0001 and a BFR&nbhy;NBR of
            BFR&nbhy;D itself.  This will cause a copy of the packet to be
            delivered to the multicast flow overlay at BFR&nbhy;D.  The
            packet's BitString will be set to 0000, and the packet will not
            be forwarded any further.
          </t>
        </section>
        <section title="Example 2">
          <t>
            This example is similar to example 1, except that BFIR&nbhy;A
            has learned from the multicast flow overlay that both BFER&nbhy;D
            and BFER&nbhy;E are interested in a given multicast flow.  If
            BFIR&nbhy;A receives a packet of that flow from outside the BIER
            domain, BFIR&nbhy;A applies the BIER encapsulation to the
            packet.  The encapsulation must be such that the SI is zero.
            The encapsulation also includes a BitString with two&nbsp;bits set:
            bit 1 is set (as in example 1) to indicate that BFR&nbhy;D is a
            BFER for this packet, and bit 3 is set to indicate that
            BFR&nbhy;E is a BFER for this packet.  That is, the BitString
            (assuming again a BitStringLength of 4) is 0101.  To forward the
            packet, BFIR&nbhy;A follows the procedures of <xref
            target="rules"/>, as follows:
          </t>
          <t>
            <list style="symbols">
              <t>
                Since the packet's BitString is 0101, BFIR&nbhy;A finds that
                the first bit in the string is bit 1.  Looking at entry 1 in
                its BIFT, BFR&nbhy;A determines that the bit mask F&nbhy;BM
                is 0111 and the BFR&nbhy;NBR is BFR&nbhy;B.
              </t>
              <t>
                BFR&nbhy;A then makes a copy of the packet and applies the
                F&nbhy;BM to the copy:
                Copy-&gt;BitString&nbsp;&amp;=&nbsp;0111.  The copy's BitString
                is now 0101 (0101&nbsp;&amp;&nbsp;0111).
              </t>
              <t>
                The copy is now sent to BFR&nbhy;B.
              </t>
              <t>
                BFR&nbhy;A then updates the packet's BitString by applying
                the inverse of the F&nbhy;BM:
                Packet-&gt;BitString&nbsp;&amp;=&nbsp;~F&nbhy;BM.  As a result,
                the packet's BitString is now 0000
                (0101&nbsp;&amp;&nbsp;1000).
              </t>
              <t>
                As the packet's BitString is now zero, the forwarding
                procedure is complete.
              </t>
              </list>
            </t>
            
            <t>
              When BFR&nbhy;B receives the multicast packet from BFR&nbhy;A,
              it follows the procedure of <xref target="rules"/>, as
              follows:
            </t>
            <t>
              <list style="symbols">
                <t>
                  Since the packet's BitString is 0101, BFR&nbhy;B finds
                  that the first bit in the string is bit 1.  Looking at
                  entry 1 in its BIFT, BFR&nbhy;B determines that the bit
                  mask F&nbhy;BM is 0011 and the BFR&nbhy;NBR is BFR&nbhy;C.
                </t>
                <t>
                  BFR&nbhy;B then makes a copy of the packet and applies
                  the F&nbhy;BM to the copy:
                  Copy-&gt;BitString&nbsp;&amp;=&nbsp;0011.  The copy's
                  BitString is now 0001 (0101&nbsp;&amp;&nbsp;0011).
                </t>
                <t>
                  The copy is now sent to BFR&nbhy;C.
                </t>
                <t>
                  BFR&nbhy;B then updates the packet's BitString by applying
                  the inverse of the F&nbhy;BM:
                  Packet-&gt;BitString&nbsp;&amp;=&nbsp;~F&nbhy;BM.  As a
                  result, the packet's BitString is now 0100
                  (0101&nbsp;&amp;&nbsp;1100).
                </t>
                <t>
                  Now BFR&nbhy;B finds the next bit in the packet's
                  (modified) BitString.  This is bit 3.  Looking at entry 3
                  in its BIFT, BFR&nbhy;B determines that the F&nbhy;BM is
                  0100 and the BFR&nbhy;NBR is BFR&nbhy;E.
                </t>
                <t>
                  BFR&nbhy;B then makes a copy of the packet and applies
                  the F&nbhy;BM to the copy:
                  Copy-&gt;BitString&nbsp;&amp;=&nbsp;0100.  The copy's
                  BitString is now 0100 (0100&nbsp;&amp;&nbsp;0100).
                </t>
                <t>
                  The copy is now sent to BFR&nbhy;E.
                </t>
                <t>
                  BFR&nbhy;B then updates the packet's BitString by applying
                  the inverse of the F&nbhy;BM:
                  Packet-&gt;BitString&nbsp;&amp;=&nbsp;~F&nbhy;BM.  As a
                  result, the packet's BitString is now 0000
                  (0100&nbsp;&amp;&nbsp;1011).
                </t>
                <t>
                  As the packet's BitString is now zero, the forwarding
                  procedure is complete.
                </t>
              </list>
            </t>
            <t>
              Thus, BFR&nbhy;B forwards two copies of the packet.  One copy
              of the packet, with BitString 0001, has now been sent from
              BFR&nbhy;B to BFR&nbhy;C.  Following the same procedures,
              BFR&nbhy;C will forward the packet to BFER&nbhy;D.
            </t>
            <t>
              At BFER&nbhy;D, the BIFT entry (not pictured) for BFR&nbhy;id
              1 will specify an F&nbhy;BM of 0001 and a BFR&nbhy;NBR of
              BFR&nbhy;D itself.  This will cause a copy of the packet to be
              delivered to the multicast flow overlay at BFR&nbhy;D.  The
              packet's BitString will be set to 0000, and the packet will
              not be forwarded any further.
            </t>
            <t>
              The other copy of the packet has been sent from BFR&nbhy;B to
              BFER&nbhy;E, with BitString 0100.
            </t>
            <t>
              At BFER&nbhy;E, the BIFT entry (not pictured) for BFR&nbhy;id
              3 will specify an F&nbhy;BM of 0100 and a BFR&nbhy;NBR of
              BFR&nbhy;E itself.  This will cause a copy of the packet to be
              delivered to the multicast flow overlay at BFR&nbhy;E.  The
              packet's BitString will be set to 0000, and the packet will
              not be forwarded any further.
            </t>
          </section>
      </section>

      <section title="Equal-Cost Multipath Forwarding" anchor="ECMP">
        <t>
          In many networks, the routing underlay will provide multiple
          equal&nbhy;cost paths from a given BFR to a given BFER.  When
          forwarding multicast packets through the network, it can be
          beneficial to take advantage of this by load&nbhy;balancing among
          those paths.  This feature is known as "Equal&nbhy;Cost Multipath (ECMP) forwarding".
        </t>
        <t>
          BIER supports ECMP forwarding, but the procedures of <xref target="rules"/>
          must be modified slightly. Two ECMP procedures are defined.  In
          the first (described in <xref target="non-deterministic"/>), the
          choice among equal&nbhy;cost paths taken by a given packet from a
          given BFR to a given BFER depends on (a)&nbsp;routing,
          (b)&nbsp;the packet's entropy, and (c)&nbsp;the other BFERs
          to which that packet is destined.  In the second (described
          in <xref target="deterministic"/>), the choice depends only upon
          the packet's entropy.
        </t>
        <t>
          There are trade-offs between the two forwarding procedures
          described here.  In the procedure of <xref
          target="non-deterministic"/>, the number of packet replications is
          minimized. The procedure in <xref target="non-deterministic"/>
          also uses less memory in the BFR. In the procedure of <xref
          target="deterministic"/>, the path traveled by a given packet from a
          given BFR to a given BFER is independent of the other BFERs to
          which the packet is destined.  While the procedures of <xref
          target="deterministic"/> may cause more replications, they provide a
          more predictable behavior.
        </t>
        <t>
          The two procedures described here operate on identical packet
          formats and will interoperate correctly. However, if deterministic
          behavior is desired, then all BFRs would need to use the procedure
          from <xref target="deterministic"/>.
        </t>

        <section title="Non-deterministic ECMP" anchor="non-deterministic">
          <t>
            <xref target="ecmp_example"/> shows the operation of
            non-deterministic ECMP in BIER.
          </t>
          
          <figure align="center" anchor="ecmp_example" title="Example of 
Non-deterministic ECMP">
            <artwork align="center"><![CDATA[
     BFR-A BIFT            BFR-B BIFT            BFR-C BIFT
-------------------   -------------------   -------------------
| Id | F-BM | NBR |   | Id | F-BM | NBR |   | Id | F-BM | NBR |
===================   ===================   ===================
| 1  | 0111 |  B  |   | 1  | 0011 |  C  |   | 1  | 0001 |  D  |
-------------------   -------------------   -------------------
| 2  | 0111 |  B  |   | 2  | 0011 |  C  |   | 2  | 0010 |  F  |
-------------------   |    | 0110 |  E  |   -------------------
| 3  | 0111 |  B  |   -------------------   | 3  | 1100 |  B  |  
-------------------   | 3  | 0110 |  E  |   -------------------
| 4  | 1000 |  A  |   ------------------|   | 4  | 1100 |  B  |
-------------------   | 4  | 1000 |  A  |   -------------------
                      -------------------

 ( A ) ------------ ( B ) ------------ ( C ) ------------ ( D ) 
4 (0:1000)             \                  \           1 (0:0001)
                        \                  \    
                        ( E ) ------------ ( F ) 
                      3 (0:0100)         2 (0:0010)]]></artwork>
          </figure>
          <t>
            In this example, BFR&nbhy;B has two equal&nbhy;cost paths to reach
            BFER&nbhy;F: one via BFR&nbhy;C and one via BFR&nbhy;E.  Since
            the BFR&nbhy;id of BFER&nbhy;F is 2, this is reflected in entry
            2 of BFR&nbhy;B's BIFT.  Entry 2 shows that BFR&nbhy;B has a
            choice of two BFR&nbhy;NBRs for BFER&nbhy;B and that a
            different F&nbhy;BM is associated with each choice.  When
            BFR&nbhy;B looks up entry 2 in the BIFT, it can choose either
            BFR&nbhy;NBR.  However, when following the procedures of <xref
            target="rules"/>, it MUST use the F&nbhy;BM corresponding to the
            BFR&nbhy;NBR that it chooses.
          </t>
          <t>
            How the choice is made is an implementation matter.  However,
            the usual rules for ECMP apply: packets of a given flow SHOULD
            NOT be split among two paths, and any entropy field in the
            packet's encapsulation SHOULD be respected.
          </t>
          <t>
            Note, however, that by the rules of <xref target="rules"/>, any
            packet destined for both BFER&nbhy;D and BFER&nbhy;F will be
            sent via BFR&nbhy;C.
          </t>
        </section>
        <section title="Deterministic ECMP" anchor="deterministic">
          <t>
            With the procedures of <xref target="non-deterministic"/>, where
            ECMP paths exist, the path a packet takes to reach any
            particular BFER depends not only on routing and on the packet's
            entropy but also on the set of other BFERs to which the packet
            is destined.
          </t>
          <t>
            For example, consider the following scenario in the network
            of <xref target="ecmp_example"/>.
            <list style="symbols">
              <t>            
                There is a sequence of packets being transmitted by
                BFR&nbhy;A, some of which are destined for both D and F and
                some of which are destined only for F.
              </t>
              <t>
                All the packets in this sequence have the same entropy
                value (call it "Q").
              </t>
              <t>
                At BFR&nbhy;B, when a packet with entropy value Q is
                forwarded via entry 2 in the BIFT, the packet is sent to E.
              </t>
            </list>
          </t>
          <t>
            Using the forwarding procedure of <xref
            target="non-deterministic"/>, packets of this sequence that are
            destined for both D and F are forwarded according to entry 1 in
            the BIFT and thus will reach F via the
            path A&nbhy;B&nbhy;C&nbhy;F.  However,
            packets of this sequence that are destined only for F are
            forwarded according to entry 2 in the BIFT and thus will reach
            F via the path A&nbhy;B&nbhy;E&nbhy;F.
          </t>
         <t>
            That procedure minimizes the number of packets transmitted by
            BFR&nbhy;B.  However, consider the following scenario:
            <list style="symbols">
              <t>
                Beginning at time t0, the multicast flow in question needs
                to be received ONLY by BFER&nbhy;F.
              </t>
              <t>
                Beginning at a later time, t1, the flow needs to be received
                by both BFER&nbhy;D and BFER&nbhy;F.
              </t>
              <t>
                Beginning at a later time, t2, the flow no longer needs to be
                received by D, but still needs to be received by F.
              </t>
            </list>
          </t>
          <t>
            Then, from t0 until t1, the flow will travel to F via the path
            A&nbhy;B&nbhy;E&nbhy;F.  From t1 until t2, the flow will travel
            to F via the path A&nbhy;B&nbhy;C&nbhy;F.  And from t2, the
            flow will again travel to F via the path A&nbhy;B&nbhy;E&nbhy;F.
          </t>
          <t>
            The problem is that if D repeatedly joins and leaves the flow,
            the flow's path from B to F will keep switching.  This could
            cause F to receive packets out of order.  It also makes
            troubleshooting difficult.  For example, if there is some
            problem on the E&nbhy;F link, receivers at F will get good service
            when the flow is also going to D (avoiding the E&nbhy;F link) but
            bad service when the flow is not going to D.  Since it is hard
            to know which path is being used at any given time, this may be
            hard to troubleshoot.  Also, it is very difficult to perform a
            traceroute that is known to follow the path taken by the flow at
            any given time.
          </t>
          <t>
            The source of this difficulty is that, in the procedures of
            <xref target="non-deterministic"/>, the path taken by a
            particular flow to a particular BFER depends upon whether there
            are lower-numbered BFERs that are also receiving the flow.  Thus,
            the choice among the ECMP paths is fundamentally
            non-deterministic.
          </t>
          <t>          
            Deterministic forwarding can be achieved by using multiple
            BIFTs, such that each row in a BIFT has only one path to each
            destination but the multiple ECMP paths to any particular
            destination are spread across the multiple tables.  When a
            BIER&nbhy;encapsulated packet arrives to be forwarded, the BFR
            uses a hash of the BIER entropy field to determine which BIFT to
            use, and then the normal BIER forwarding algorithm (as described in
            Sections&nbsp;<xref target="rules" format="counter"/> and <xref
            target="example" format="counter"/>) is used with the selected
            BIFT.
          </t>
          <t>
            As an example, suppose there are two paths to destination X
            (call them "X1" and "X2") and four paths to destination Y
            (call them "Y1", "Y2", "Y3", and "Y4").  If there are, say,
            four BIFTs, one BIFT would have paths X1 and Y1, one would have X1
            and Y2, one would have X2 and Y3, and one would have X2 and Y4.
            If traffic to X is split evenly among these four BIFTs, the
            traffic will be split evenly between the two paths to X; if
            traffic to Y is split evenly among these four BIFTs, the traffic
            will be split evenly between the four paths to Y.
          </t>
          <t>
            Note that if there are three paths to one destination and four
            paths to another, 12 BIFTs would be required in order to get
            even splitting of the load to each of those two destinations.
            Of course, each BIFT uses some memory, and one might be willing
            to have less optimal splitting in order to have fewer BIFTs.
            How that trade-off is made is an implementation or deployment
            decision.
          </t>
        </section>
      </section>

      <section title="Prevention of Loops and Duplicates">
        <t>
          The BitString in a BIER-encapsulated packet specifies the set of
          BFERs to which that packet is to be forwarded.  When a
          BIER&nbhy;encapsulated packet is replicated, no two copies of the
          packet will ever have a BFER in common.  If one of the packet's
          BFERs forwards the packet further, that BFER will first clear
          the bit that identifies itself.  As a result, duplicate delivery of
          packets is not possible with BIER.
        </t>
        <t>
          As long as the routing underlay provides a loop-free path between
          each pair of BFRs, BIER&nbhy;encapsulated packets will not loop.
          Since the BIER layer does not create any paths of its own, there
          is no need for any BIER&nbhy;specific loop-prevention techniques
          beyond the forwarding procedures specified in <xref target="rules"/>.
        </t>
        <t>
          If, at some time, the routing underlay is not providing a
          loop&nbhy;free path between BFIR&nbhy;A and BFER&nbhy;B, then
          BIER&nbhy;encapsulated packets may loop while traveling from
          BFIR&nbhy;A to BFER&nbhy;B.  However, such loops will never
          result in delivery of duplicate packets to BFER&nbhy;B.
        </t>
        <t>
          These properties of BIER eliminate the need for the "Reverse Path
          Forwarding" (RPF) check that is used in conventional IP multicast
          forwarding.
        </t>
      </section>

      <section title="When Some Nodes Do Not Support BIER"
               anchor="non-bier">
        <t>
          The procedures of <xref target="BFR-NBR"/> presuppose that, within
          a given BIER domain, all the nodes adjacent to a given BFR in a
          given routing underlay are also BFRs.  However, it is possible to
          use BIER even when this is not the case, as long as the ingress and
          egress nodes are BFRs.  In this section, we describe procedures that
          can be used if the routing underlay is an SPF-based IGP that
          computes a shortest&nbhy;path tree from each node to all other
          nodes in the domain.
        </t>
        <t>
          At a given BFR, say "BFR&nbhy;B", start with a copy of the
          IGP-computed shortest-path tree from BFR&nbhy;B to each router in
          the domain.  (This tree is computed by the SPF algorithm of the
          IGP.)  Let's call this copy the "BIER&nbhy;SPF tree rooted at
          BFR&nbhy;B".  BFR&nbhy;B then modifies this BIER&nbhy;SPF tree as
          follows.
          <list style="numbers">
            <t>
              BFR&nbhy;B looks in turn at each of its child nodes on the
              BIER&nbhy;SPF tree.
            </t>
            <t>
              If one of the child nodes does not support BIER, BFR&nbhy;B
              removes that node from the tree.  The child nodes of the node
              that has just been removed are then re-parented on the tree, so
              that BFR&nbhy;B now becomes their parent.
            </t>
            <t>
              BFR&nbhy;B then continues to look at each of its child nodes,
              including any nodes that have been re-parented to BFR&nbhy;B
              as a result of the previous step.
            </t>
          </list>
        </t>
        <t>
          When all of the child nodes (the original child nodes plus any new
          ones) have been examined, BFR&nbhy;B's children on the
          BIER&nbhy;SPF tree will all be BFRs.
        </t>
        <t>
          When the BIFT is constructed, BFR&nbhy;B's child nodes on the
          BIER&nbhy;SPF tree are considered to be the BFR&nbhy;NBRs.  The
          F&nbhy;BMs must be computed appropriately, based on the
          BFR&nbhy;NBRs.
        </t>
        <t>
          BFR&nbhy;B may now have BFR&nbhy;NBRs that are not "directly
          connected" to BFR&nbhy;B via Layer 2.  To send a packet to one of
          these BFR&nbhy;NBRs, BFR&nbhy;B will have to send the packet
          through a unicast tunnel.  In an MPLS network, this may be as
          simple as finding the IGP unicast next hop to the child node and
          pushing on (above the BIER encapsulation header) an MPLS label
          that the IGP next hop has bound to an address of the child node.
          (This assumes that the packet is using an MPLS&nbhy;based
          BIER encapsulation, such as the one specified in
          Section&nbsp;2.1 of <xref target="MPLS_BIER_ENCAPS"/>.) Of course,
          the BIFT&nbhy;id in the BIER encapsulation header must be the
          BIFT&nbhy;id advertised by the child node for the packet's SI,
          sub&nbhy;domain, and BitStringLength.
        </t>
        <t>
          If for some reason the unicast tunnel cannot be an MPLS tunnel,
          any other kind of tunnel can be used, as long as the encapsulation
          for that tunnel type has a way of indicating that the payload is a
          BIER&nbhy;encapsulated packet.
        </t>
        <t>
          Note that if a BIER&nbhy;encapsulated packet is not using an
          MPLS-based BIER encapsulation, it will not be possible to send it
          through an MPLS tunnel unless it is known that the tunnel only
          carries BIER packets; this is because MPLS has no
          "next protocol type" field. This is not a problem if an
          MPLS&nbhy;based BIER encapsulation is used, because in that case the
          BIER encapsulation begins with an MPLS label that identifies the
          packet as a BIER&nbhy;encapsulated packet. 
        </t>
        <t>
          Of course, the above is not meant as an implementation technique,
          just as a functional description.  
        </t>
        <t>
          While the above description assumes that the routing underlay
          provides an SPF tree, it may also be applicable to other types of
          routing underlays.
        </t>
        <t>
          The technique above can also be used to provide "node protection"
          (i.e., to provide fast reroute around nodes that are believed to
          have failed).  If BFR&nbhy;B has a failed BFR&nbhy;NBR, BFR&nbhy;B
          can remove the failed BFR&nbhy;NBR from the BIER&nbhy;SPF tree and
          can then re&nbhy;parent the child BFR&nbhy;NBRs of the failed
          BFR&nbhy;NBR so that they appear to be BFR&nbhy;B's own child nodes
          on the tree (i.e., so that they appear to be BFR&nbhy;B's
          BFR&nbhy;NBRs).  The usual BIER forwarding procedures then apply.
          However, getting the packet from BFR&nbhy;B to the child nodes of
          the failed BFR&nbhy;NBR is a bit more complicated, as it may
          require using a unicast bypass tunnel to get around the failed node.
        </t>
        <t>
          A simpler variant of step 2 above would be the following:
          <list>
            <t>
              If one of the child nodes does not support BIER, BFR&nbhy;B
              removes that node from the tree.  All BFERs that are reached
              through that child node are then re-parented on the tree, so that
              BFR&nbhy;B now becomes their parent.
            </t>
          </list>
        </t>
        <t>
          This variant is simpler because the set of BFERs that are reached
          through a particular child node of BFR&nbhy;B can be determined
          from the F&nbhy;BM in the BIFT.  However, if this variant is used,
          the results are less optimal, because packets will be unicast
          directly from BFR&nbhy;B to the BFERs that are reachable through
          the non&nbhy;BIER child node.
        </t>
        <t>
          When using a unicast MPLS tunnel to get a packet to a BFR-NBR:
          <list style="symbols">
            <t>
              The TTL of the MPLS label entry representing the tunnel SHOULD
              be set to a large value, rather than being copied from the TTL
              value from the BIER encapsulation header, and
            </t>
            <t>
              When the tunnel labels are popped off, the TTL from the tunnel
              labels SHOULD NOT be copied to the BIER encapsulation header.
            </t>
          </list>
        </t>
        <t>
          In other words, the TTL processing for the tunnel SHOULD be as
          specified in <xref target="RFC3443"/> for "Pipe Model" and "Short
          Pipe Model" Label Switched Paths (LSPs). The same principle applies
          if the tunnels are not MPLS tunnels; the BIER packet SHOULD NOT
          inherit the TTL from the tunnel encapsulation. That way, the TTL of
          the BIER encapsulation header constrains only the number of BFRs
          that the packet may traverse, not the total number of hops.
        </t>
        <t>
          If two BIER packets have the same value in the entropy field of
          their respective BIER headers and if both are transmitted through
          a given tunnel, it is desirable for the tunnel encapsulation to
          preserve the fact that the two packets have the same entropy.
        </t>
        <t>
          The material in this section presupposes that if a given router is
          a BFR, then it supports BIER on all its interfaces.  It is,
          however, possible that a router will have some line cards that
          support BIER and some that do not.  In such a case, one can think
          of the router as a "partial&nbsp;BFR" that supports BIER only on
          some of its interfaces.  If it is desired to deploy such
          partial&nbsp;BFRs, one can use the multi-topology features of the
          IGP to set up a BIER-specific topology.  This topology would
          exclude all the non-BIER-capable interfaces that attach to BFRs.
          BIER would then have to be run in a sub&nbhy;domain that is bound
          to this topology.  If unicast tunnels are used to bypass
          non&nbhy;BFRs, either (a)&nbsp;the tunnels have to be restricted
          to this topology or (b)&nbsp;the tunnel endpoints have to be BFRs
          that do not have any non&nbhy;BIER-capable interfaces.
        </t>
      </section>
      
      <section title="Use of Different BitStringLengths within a Domain"
               anchor="different_bsls">
        <t>
          The procedures of this section apply only when the same
          encapsulation is used throughout the BIER domain.  Consideration
          of the scenario where both multiple encapsulations and multiple
          BitStringLengths are used in a given BIER domain is outside the
          scope of this document.
        </t>
        <t>
          It is possible for different BFRs within a BIER domain to be using
          different Imposition and/or Disposition BitStringLengths.  As
          stated in <xref target="encoding"/>:</t>

        <t>
          "if a particular BFIR is provisioned to use a particular
          Imposition BitStringLength and a particular Imposition
          sub&nbhy;domain when imposing the encapsulation on a given set of
          packets, all other BFRs with BFR&nbhy;ids in that
          sub&nbhy;domain SHOULD be provisioned to process received BIER
          packets with that BitStringLength (i.e., all other BFRs with
          BFR&nbhy;ids in that sub&nbhy;domain SHOULD be provisioned with
          that BitStringLength as a Disposition BitStringLength for that
          sub&nbhy;domain)."
        </t>

        <t>
          Note that mis-provisioning can result in "black holes".  If a BFIR
          creates a BIER packet with a particular BitStringLength and if
          that packet needs to travel through a BFR that cannot process
          received BIER packets with that BitStringLength, then it may be
          impossible to forward the packet to all of the BFERs identified in
          its BIER header.  <xref target="compatcheck"/> defines a
          procedure, the "BitStringLength Compatibility Check", that can be
          used to detect the possibility of such black holes.  
        </t>
        <t>
          However, failure of the BitStringLength Compatibility Check does
          not necessarily result in the creation of black holes; <xref
          target="mismatch"/> specifies OPTIONAL procedures that allow BIER
          forwarding to proceed without black holes, even if the
          BitStringLength Compatibility Check fails.  
        </t>
        <t>
          If the procedures of <xref target="mismatch"/> are not deployed
          but the BitStringLength Compatibility Check fails at some BFIR,
          the BFIR has two choices:
          <list style="symbols">
            <t>
              Create BIER packets with the provisioned Imposition
              BitStringLength, even though the packets may not be able to
              reach all the BFERs identified in their BitStrings.
            </t>
            <t>
              Use an Imposition BitStringLength that passes the
              Compatibility Check (assuming that there is one), even if this
              is not the provisioned Imposition BitStringLength.
            </t>
          </list>
          <xref target="compatcheck"/> discusses the implications of making
          one or the other of these choices.
        </t>
        <t>
          There will be times when an operator wishes to change the
          BitStringLengths used in a particular BIER domain.  <xref
          target="transition"/> specifies a simple procedure that can be
          used to transition a BIER domain from one BitStringLength to
          another.
        </t>
        
        <section title="BitStringLength Compatibility Check"
                 anchor="compatcheck">
          <t>
            When a BFIR needs to encapsulate a packet, the BFIR first
            assigns the packet to a sub&nbhy;domain.  The BFIR then chooses
            an Imposition BitStringLength L for the packet.  The choice of
            Imposition BitStringLength is determined by provisioning.
            However, the BFIR should also perform the BitStringLength
            Compatibility Check defined below.
          </t>
          <t>
            The combination of sub&nbhy;domain S and
            Imposition BitStringLength L passes the BitStringLength
            Compatibility Check if and only if the following condition holds:
            <list>
              <t>
                Every BFR that has advertised its membership in
                sub&nbhy;domain S has also advertised that it is using
                Disposition BitStringLength L (and possibly other
                BitStringLengths as well) in that sub&nbhy;domain.
                (If MPLS encapsulation (Section&nbsp;2.1 of
                <xref target="MPLS_BIER_ENCAPS"/>) is being used, this means
                that every BFR that is advertising a label for
                sub&nbhy;domain S is advertising a label for the combination
                of sub&nbhy;domain S and Disposition BitStringLength L.)
              </t>
            </list>
          </t>
          <t>
            If a BFIR has been provisioned to use a particular Imposition
            BitStringLength and a particular sub&nbhy;domain for some set of
            packets, and if that combination of Imposition BitStringLength
            and sub&nbhy;domain does not pass the BitStringLength Compatibility
            Check, the BFIR SHOULD log this fact as an error.  It then has
            the following two choices about what to do with the packets:
            <list style="numbers">
              <t anchor="useanyway">
                The BFIR MAY use the provisioned Imposition BitStringLength
                anyway.  If the procedure of either option 2 or option 3
                of <xref target="mismatch"/> is deployed, this will not
                cause black holes and may actually be the optimal result.
                It should be understood, though, that the BFIR cannot
                determine by signaling whether those procedures have been
                deployed.
              </t>
              <t anchor="changetocompat">
                If the BFIR is capable of using an Imposition BitStringLength
                that does pass the BitStringLength Compatibility Check for
                the particular sub&nbhy;domain, the BFIR MAY use that
                Imposition BitStringLength instead.
              </t>
            </list>
            Which of these two choices to make is itself determined by
            provisioning. 
          </t>
          <t>
            Note that discarding the packets is not one of the allowable
            choices.  Suppose, for example, that all the BFIRs are
            provisioned to use Imposition BitStringLength L for a particular
            sub&nbhy;domain S but one BFR has not been provisioned to use
            Disposition BitStringLength L for sub&nbhy;domain S.  This will
            cause the BitStringLength Compatibility Check to fail.  If the BFIR
            sends packets with BitStringLength L and sub&nbhy;domain S, the
            mis-provisioned BFR will not be able to forward those packets,
            and thus the packets may only be able to reach a subset of the
            BFERs to which they are destined.  However, this is still better
            than having the BFIRs drop the packets; if the BFIRs discard the
            packets, the packets won't reach any of the BFERs to which they
            are destined at all.
          </t>
          <t>
            If the procedures of <xref target="mismatch"/> have not been
            deployed, choice <xref target="changetocompat" format="counter"/>
            above might seem like a better option.  However, there might not
            be any Imposition BitStringLength that a given BFIR can use that
            also passes the BitStringLength Compatibility Check.  If it is
            desired to use choice <xref target="changetocompat"
            format="counter"/> in a particular deployment, then there should
            be a "Fallback Disposition BitStringLength" (call it "F") such
            that:
            <list style="symbols">
              <t>
                Every BFR advertises that it uses BitStringLength F as a
                Disposition BitStringLength for every sub&nbhy;domain, and
              </t>
              <t>
                If a BFIR is provisioned to use Imposition BitStringLength X
                and Imposition sub&nbhy;domain S for a certain class of
                packets but the BitStringLength Compatibility Check fails for
                the combination of BitStringLength X and sub&nbhy;domain S,
                then the BFIR will fall back to using BitStringLength F
                as the Imposition BitStringLength whenever the Imposition
                sub&nbhy;domain is S.
              </t>
            </list>
            It is RECOMMENDED that the value of F be the default
            BitStringLength for the encapsulation being used.
          </t>
        </section>

        <section title="Handling BitStringLength Mismatches"
                 anchor="mismatch">
          <t>
            Suppose that a packet has been BIER&nbhy;encapsulated with a
            BitStringLength value of X and that the packet has arrived at
            BFR&nbhy;A.  Now suppose that according to the routing underlay
            the next hop is BFR&nbhy;B, but BFR&nbhy;B is not using X as one
            of its Disposition BitStringLengths.  What should BFR&nbhy;A do
            with the packet?  BFR&nbhy;A has three options.  It MUST do one
            of the three, but the choice of which procedure to follow is a
            local matter.  The three options are:
            <list style="numbers">
              <t anchor="mm_discard">
                BFR&nbhy;A MAY discard the packet.
              </t>
              <t anchor="mm_change">
                BFR&nbhy;A MAY re-encapsulate the packet, using a BIER
                header whose BitStringLength value is supported by
                BFR&nbhy;B.
                <vspace blankLines="1"/>
                Note that if BFR&nbhy;B only uses Disposition
                BitStringLength values that are smaller than the
                BitStringLength value of the packet, this may require
                creating additional copies of the packet.  Whether
                additional copies actually have to be created depends upon
                the bits that are actually set in the original packet's
                BitString.
              </t>
              <t anchor="mm_tunnel">
                BFR&nbhy;A MAY treat BFR&nbhy;B as if BFR&nbhy;B did not
                support BIER at all, in&nbsp;which case BFR&nbhy;A applies the
                rules of <xref target="non-bier"/>.
              </t>
            </list>
          </t>
          <t>
            Note that there is no signaling that enables a BFR to advertise
            which of the three options it will use.
          </t>
          <t>
            Option <xref target="mm_change" format="counter"/> can be
            useful if there is a region of the BIER domain where the BFRs
            are capable of using a long BitStringLength as well as a region
            where the BFRs are only capable of using a shorter BitStringLength.
          </t>
        </section>
        
        <section title="Transitioning from One BitStringLength to Another"
                 anchor="transition">
          <t>
            Suppose one wants to migrate the BitStringLength used in a
            particular BIER domain from one value (X) to another value (Y).
            The following migration procedure can be used.  This procedure
            allows the BFRs to be reprovisioned one at a time and does not
            require a "flag day".
          </t>

          <t><list style="numbers">
            <t>Upgrade all the BFRs in the domain so that they use both
            value&nbsp;X and value&nbsp;Y as their
            Disposition BitStringLengths.</t>
            <t>Reprovision the BFIRs so that they use BitStringLength
            value&nbsp;Y as the Imposition BitStringLength.</t>
            <t>One may then optionally reprovision all the BFRs so
            that they no longer use Disposition BitStringLength X.</t>
          </list></t>
        </section>
      </section>
    </section>

    <section title="Operational Considerations" anchor="operations">
      <t>
        BIER offers a radical simplification over current IP multicast
        operations: no tree-building control plane, no per-flow forwarding
        state, no Reverse Path Forwarding (RPF), no Rendezvous Point (RP),
        etc. BIER packet forwarding/replication is along the unicast paths
        to each bit position set in the packet, ensuring that the encapsulated
        multicast packets follow the same path as unicast to each set bit in
        the header. The BIER FIB can be derived from the SPF&nbhy;calculated
        unicast FIB or from any other forwarding-path calculation in or
        out of band.  Each bit will follow this unicast path from the
        entry point of the BIER domain to the edge device with that assigned
        bit.
      </t>
      <t>
        Due to these differences, operational expectations from traditional
        multicast solutions do not apply to a BIER domain. There is no
        granular per-flow state at each node defining a tree. Monitoring
        flows at the forwarding-plane level ((S,G) entries) is not provided
        in a BIER node. BIER FIB packet counters may be maintained for
        BFR&nbhy;ids or next-hop neighbors. Any flow-based metrics will require
        deeper packet inspection; this topic is outside the scope of this
        document. In this way, BIER is again more like unicast.
      </t>
      <t>
        It is this reduction in state that allows for one of the key
        operational benefits of BIER: deterministic convergence. The BIER
        FIB can converge immediately after the unicast FIB regardless of how
        many multicast flows are transiting the links. Careful monitoring of
        (S,G) utilization is not required within a BIER domain.
      </t>

      <section title="Configuration" anchor="config">
        <t>
          A BIER domain requires that each edge node (BFER) be given a
          unique bit position in the BIER mask (BFR-id). The BFR-id must be
          configured on each BFER and associated with a unique IP address of
          that BFER. Any existing manual or automated configuration tools
          must provide access to BIER-specific configuration. The
          association of the BFR-id with a unique address of the BFER to
          which it is assigned must also be advertised into the IGP of the
          BIER domain. This may be implied from the BIER configuration or
          require IGP-specific configuration. This document does not dictate
          any specific configuration methodology.
        </t>       

      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>
        This document does not require any IANA actions.
      </t>
    </section>
    
    <section anchor="Security" title="Security Considerations">
      <t>
        When BIER is paired with a particular multicast flow overlay, it
        inherits the security considerations of that layer.  Similarly, when
        BIER is paired with a particular routing underlay, it inherits the
        security considerations of that layer.
      </t>
      <t>
        If the BIER encapsulation of a particular packet specifies an SI or
        a BitString other than the one intended by the BFIR, the packet is
        likely to be misdelivered.  If the BIER encapsulation of a packet is
        modified (through error or malfeasance) in a way other than that
        specified in this document, the packet may be misdelivered.  Some
        modifications of the BIER encapsulation, e.g., setting every bit in
        the BitString, may result in (intentional or unintentional)
        denial&nbhy;of&nbhy;service (DoS) attacks.
      </t>
      <t>
        If a BFIR is compromised, it may impose a BIER encapsulation with
        all the bits in the BitString set; this would also result in a DoS
        attack. 
      </t>
      <t>
        Every BFR MUST be provisioned to know which of its interfaces lead
        to a BIER domain and which do not.  BIER&nbhy;encapsulated packets MUST
        NOT be accepted from outside the BIER domain.  (Reception of
        BIER&nbhy;encapsulated packets from outside the BIER domain would
        create an attack vector for DoS attacks, as an attacker might set
        all the bits in the BitString.)
      </t>
      <t>
        If two interfaces lead to different BIER domains, the BFR MUST be
        provisioned to know that those two interfaces lead to different BIER
        domains.  If the provisioning is not correct, BIER&nbhy;encapsulated
        packets from one BIER domain may "leak" into another; this is likely
        to result in misdelivery of packets.
      </t>
      <t>
        DoS attacks may also result from incorrect provisioning (through
        error or malfeasance) of the BFRs.
      </t>
      <t>
        If the procedures used for advertising BFR&nbhy;ids and
        BFR&nbhy;prefixes are not secure, an attack on those procedures may
        result in incorrect delivery of BIER&nbhy;encapsulated packets.
      </t>
    </section>
  </middle>
  <back>

    <references title="Normative References">
      &RFC2119;
      &RFC3443;
      &RFC8174;
    </references>

    <references title="Informative References">

<!-- draft-boivie-sgm (Expired) -->
      <reference anchor='Boivie_Feldman'>
        <front>
          <title>Small Group Multicast</title>
          <author initials="R" surname="Boivie">
            <organization />
          </author>
          <author initials="N" surname="Feldman">
            <organization />
          </author>
          <date month='February' year='2001' />
        </front>
        <seriesInfo name='Work in Progress,' value='draft-boivie-sgm-02'/>
      </reference>

<!-- draft-ietf-bier-idr-extensions (I-D Exists) -->
      <reference anchor="BGP_BIER_EXTENSIONS">
        <front>
          <title>BGP Extensions for BIER</title>
          <author initials="X" surname="Xu" role="editor">
            <organization/>
          </author>
          <author initials="M" surname="Chen">
            <organization />
          </author>
          <author initials="K" surname="Patel">
            <organization />
          </author>
          <author initials="IJ" surname="Wijnands">
            <organization />
          </author>
          <author initials="A" surname="Przygienda">
            <organization />
          </author>
         <date month="August" year="2017" />
        </front>
        <seriesInfo name='Work in Progress,'
            value='draft-ietf-bier-idr-extensions-03'/>
      </reference>

<!-- draft-ietf-bier-ospf-bier-extensions (I-D Exists) -->
      <reference anchor='OSPF_BIER_EXTENSIONS'>
        <front>
          <title>OSPF Extensions for BIER</title>
          <author initials="P" surname="Psenak" role="editor">
            <organization/>
          </author>
          <author initials="N" surname="Kumar">
            <organization />
          </author>
          <author initials="IJ" surname="Wijnands">
            <organization />
          </author>
          <author initials="A" surname="Dolganow">
            <organization />
          </author>
          <author initials="T" surname="Przygienda">
            <organization />
          </author>
          <author initials="J" surname="Zhang">
            <organization />
          </author>
          <author initials="S" surname="Aldrin">
            <organization />
          </author>
          <date month="October" year="2017" />
        </front>
        <seriesInfo name='Work in Progress,'
            value='draft-ietf-bier-ospf-bier-extensions-09'/> 
      </reference>

<!-- draft-ietf-bier-isis-extensions (I-D Exists) -->
      <reference anchor='ISIS_BIER_EXTENSIONS'>
        <front>
          <title>BIER Support via ISIS</title>
          <author initials="L" surname="Ginsberg" role="editor">
            <organization />
          </author>
          <author initials="A" surname="Przygienda">
            <organization/>
          </author>
          <author initials="S" surname="Aldrin">
            <organization />
          </author>
          <author initials="J" surname="Zhang">
            <organization />
          </author>
          <date month="October" year="2017" />
        </front>
        <seriesInfo name='Work in Progress,'
             value='draft-ietf-bier-isis-extensions-06' /> 
      </reference>

<!-- draft-ietf-bier-mpls-encapsulation (EDIT) -->
      <reference anchor='MPLS_BIER_ENCAPS'>
        <front>
          <title>Encapsulation for Bit Index Explicit Replication in MPLS
          and non-MPLS Networks</title>
          <author initials="IJ" surname="Wijnands" role="editor">
            <organization />
          </author>
          <author initials="E" surname="Rosen" role="editor">
            <organization />
          </author>
          <author initials="A" surname="Dolganow">
            <organization />
          </author>
          <author initials="J" surname="Tantsura">
            <organization />
          </author>
          <author initials="S" surname="Aldrin">
            <organization />
          </author>
          <author initials="I" surname="Meilik">
            <organization />
          </author>
          <date month="October" year="2017" />
        </front>
        <seriesInfo name='Work in Progress,'
            value='draft-ietf-bier-mpls-encapsulation-12'/>
      </reference>

<!-- draft-ietf-bier-mvpn (I-D Exists) -->
      <reference anchor="BIER_MVPN">
        <front>
          <title>Multicast VPN Using BIER</title>
          <author initials="E" surname="Rosen" role="editor">
            <organization />
          </author>
          <author initials="M" surname="Sivakumar">
            <organization />
          </author>
          <author initials="S" surname="Aldrin">
            <organization />
          </author>
          <author initials="A" surname="Dolganow">
            <organization />
          </author>
          <author initials="T" surname="Przygienda">
            <organization />
          </author>
          <date month="November" year="2017"/>
        </front>
        <seriesInfo name='Work in Progress,'
            value='draft-ietf-bier-mvpn-09'/>
      </reference>

      &RFC6513;
      &RFC6514;
    </references>

    <section anchor="Acknowledgements" title="Acknowledgements" numbered="no">
      <t>
        The authors wish to thank Rajiv Asati, Alia Atlas, John Bettink,
        Ross Callon (who contributed much of the text on deterministic
        ECMP), Nagendra Kumar, Christian Martin, Neale Ranns, Albert Tian,
        Ramji Vaithianathan, Xiaohu Xu, and Jeffrey Zhang for their ideas
        and contributions to this work.
      </t>
      <t>
        The authors also wish to thank Sue Hares, Victor Kuarsingh, and Dan
        Romascanu for their reviews of this document.
      </t>
    </section>

    <section title="Contributors" numbered="no">
      <t>
      The following people contributed significantly to the content of
      this document and should be considered co&nbhy;authors:

        <figure align="left">
          <artwork align="left"><![CDATA[
Gregory Cauchie
Bouygues Telecom
Email: gcauchie@bouyguestelecom.fr

Mach(Guoyi) Chen
Huawei
Email: mach.chen@huawei.com

Arkadiy Gulko
Thomson Reuters
195 Broadway
New York, NY  10007
United States of America
Email: arkadiy.gulko@thomsonreuters.com
          
Wim Henderickx
Nokia
Copernicuslaan 50
Antwerp  2018
Belgium
Email: wim.henderickx@nokia.com

Martin Horneffer
Deutsche Telekom
Hammer Str. 216-226
Muenster  48153
Germany
Email: Martin.Horneffer@telekom.de

Luay Jalil
Verizon
1201 East Arapaho Rd.
Richardson, TX  75081
United States of America
Email: luay.jalil@verizon.com

Uwe Joorde
Deutsche Telekom
Hammer Str. 216-226
Muenster  D-48153
Germany
Email: Uwe.Joorde@telekom.de

Greg Shepherd
Cisco Systems
170 West Tasman Drive
San Jose, CA  95134
United States of America
Email: shep@cisco.com

Jeff Tantsura
Email: jefftant.ietf@gmail.com
          ]]></artwork>
        </figure>
      </t>
    </section>

  </back>
</rfc>
