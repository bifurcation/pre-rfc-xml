<?xml version="1.0" encoding="US-ASCII" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY % RFC2119 SYSTEM "reference.RFC.2119" >
<!ENTITY % RFC4291 SYSTEM "reference.RFC.4291" >
<!ENTITY % RFC4303 SYSTEM "reference.RFC.4303" >
<!ENTITY % RFC3484 SYSTEM "reference.RFC.3484" >
<!ENTITY % RFC4423 SYSTEM "reference.RFC.4423" >
<!ENTITY % RFC3552 SYSTEM "reference.RFC.3552" >
<!ENTITY % RFC4225 SYSTEM "reference.RFC.4225" >
]>


<?rfc rfcedstyle="yes"?>
<?rfc subcompact="no"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>

<rfc number="5206" category="exp">

<front>
  <title abbrev="HIP Mobility and Multihoming">
    End-Host Mobility and Multihoming with the Host Identity Protocol
  </title>

  <author initials="P." surname="Nikander"
    fullname="Pekka Nikander">
    <organization>Ericsson Research NomadicLab</organization>
    <address>
      <postal>
        <street />
        <city>JORVAS</city>
        <code>FIN-02420</code>
        <country>FINLAND</country>
      </postal>
      <phone>+358 9 299 1</phone>
      <email>pekka.nikander@nomadiclab.com</email>       
    </address>
  </author>

  <author initials="T." surname="Henderson"
    fullname="Thomas R. Henderson" role="editor">
    <organization>The Boeing Company</organization>
    <address>
      <postal>
        <street>P.O. Box 3707</street>
        <city>Seattle</city>
        <region>WA</region>
        <country>USA</country>
      </postal>
      <email>thomas.r.henderson@boeing.com</email>
    </address>
  </author>

  <author initials="C." surname="Vogt"
    fullname="Christian Vogt">
    <organization>Ericsson Research NomadicLab</organization>
    <address>
      <postal>
        <street>Hirsalantie 11 </street>
        <city>JORVAS</city>
        <code>FIN-02420</code>
        <country>FINLAND</country>
      </postal>
      <phone />
      <email>christian.vogt@ericsson.com</email>
    </address>
  </author>

  <author initials="J." surname="Arkko"
    fullname="Jari Arkko">
    <organization>Ericsson Research NomadicLab</organization>
    <address>
      <postal>
        <street />
        <city>JORVAS</city>
        <code>FIN-02420</code>
        <country>FINLAND</country>
      </postal>
      <phone>+358 40 5079256</phone>
      <email>jari.arkko@ericsson.com</email>
    </address>
  </author>

    <date month="March" year="2008" />
    
    <area>Internet</area>
    <keyword>I-D</keyword>
    <keyword>Internet Draft</keyword>

    <abstract>
      <t> This document defines mobility and multihoming extensions to
          the Host Identity Protocol (HIP).  Specifically, this document 
          defines a general "LOCATOR" parameter for HIP messages that
          allows for a HIP host to notify peers about alternate addresses
          at which it may be reached.  This document also defines elements
          of procedure for mobility of a HIP host -- the process by which
          a host dynamically changes the primary locator that it uses 
          to receive packets.  While the same LOCATOR parameter can also 
          be used to support end-host multihoming, detailed procedures are 
          left for further study.
      </t>
    </abstract>

  </front>

  <middle>

    <section title="Introduction and Scope">

      <t> The <xref target="RFC4423">Host Identity
      Protocol</xref> (HIP) supports an architecture that decouples the
      transport layer (TCP, UDP, etc.) from the internetworking layer
      (IPv4 and IPv6) by using public/private 
      key pairs, instead of IP addresses, as host identities.  When a host 
      uses HIP, the overlying protocol sublayers
      (e.g., transport layer sockets and Encapsulating Security
      Payload (ESP) Security Associations (SAs)) are 
      instead bound to representations of these host identities, and the 
      IP addresses are only used for packet forwarding.  However, each host 
      must also know at least one IP address at which its peers are reachable.
      Initially, these IP addresses are the ones used during the HIP
      base exchange <xref target="RFC5201" />.</t>

      <t> One consequence of such a decoupling is that new solutions to
      network-layer mobility and host multihoming are possible.  
      There are potentially many variations of mobility and multihoming 
      possible.  The scope of this document encompasses messaging
      and elements of procedure for basic network-level mobility and
      simple multihoming, leaving more complicated scenarios and other
      variations for further study.  More specifically:
      </t>
      <t>
        <list style="hanging">

	      <t hangText=""> 
      This document defines a generalized LOCATOR parameter for
      use in HIP messages.  The LOCATOR parameter allows a HIP host
      to notify a peer about alternate addresses at which it is 
      reachable.  The LOCATORs may be merely IP addresses, or they
      may have additional multiplexing and demultiplexing context to
      aid the packet handling in the lower layers.  For instance, 
      an IP address may need to be paired with an ESP Security
      Parameter Index (SPI) so that
      packets are sent on the correct SA for a given address. </t>

      <t hangText=""> 
      This document also specifies the messaging and elements of 
      procedure for end-host mobility of a HIP host -- the sequential
      change in the preferred IP address used to reach a host.  In particular, 
      message flows to enable successful host mobility, including
      address verification methods, are defined herein.</t>  

      <t hangText="">
      However, while the same LOCATOR parameter is intended to support 
      host multihoming
      (parallel support of a number of addresses), and experimentation
      is encouraged, detailed
      elements of procedure for host multihoming are left for further
      study.  </t>

	       </list>
      </t>

      <t>While HIP can potentially be used with transports other than
      the <xref target="RFC5202">ESP transport format</xref>,
      this document largely assumes the use of ESP and leaves other
      transport formats for further study.</t>

      <t>There are a number of situations where the simple end-to-end
      readdressing functionality is not sufficient.  These include the
      initial reachability of a mobile host, location privacy, 
      simultaneous
      mobility of both hosts, and some modes of NAT 
      traversal.  In these situations, there is a need for some helper 
      functionality in the network, such as a
      <xref target="RFC5204">HIP rendezvous server</xref>.
      Such functionality is out of the scope of
      this document.  We also do not consider localized mobility
      management extensions (i.e., mobility management techniques that do 
      not involve directly signaling the correspondent node); this 
      document is concerned with end-to-end
      mobility.   Finally, making underlying 
      IP mobility transparent to 
      the transport layer has implications on the proper response of
      transport congestion control, path MTU selection, and Quality of
      Service (QoS).
      Transport-layer mobility triggers, and the proper transport
      response to a HIP mobility or multihoming address change,
      are outside the scope of this document.</t>

    </section>

    <section title="Terminology and Conventions">

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described
      in <xref target="RFC2119">RFC 2119</xref>.</t>

      <t>
        <list style="hanging">

	      <t hangText="LOCATOR."> 
           The name of a HIP parameter containing zero or more Locator
           fields.  This parameter's name is distinguished from the Locator
           fields embedded within it by the use of all capital letters.  
         </t>

	      <t hangText="Locator."> 
           A name that controls how the packet is routed through
           the network and demultiplexed by the end host.  It may include
           a concatenation of traditional network addresses such as an 
           IPv6 address and end-to-end identifiers such as an ESP SPI.  
           It may also include transport port numbers or IPv6 Flow Labels 
           as demultiplexing context, or it may simply be a network address.
         </t>

         <t hangText="Address."> 
           A name that denotes a point-of-attachment 
           to the network.  The two most common examples are an IPv4 address 
           and an IPv6 address.  The set of possible addresses is a subset of 
           the set of possible locators.
         </t>

	       <t hangText="Preferred locator.">
           A locator on which a host prefers to receive data.  With
	         respect to a given peer, a host always has one active 
	         Preferred locator, unless there are no active locators.  
           By default, 
           the locators used in the HIP base exchange are the Preferred 
           locators.
         </t>

<!--
	  <t hangText="New Preferred locator.">
            A new Preferred locator sent by a host to its peers.  The
            reachability of the new Preferred locator often needs to
            be verified before it can be put into use.
            Consequently, there may simultaneously be an active
            Preferred locator, being used, and a new Preferred
            locator, the reachability of which is being verified.</t>
-->
	       <t hangText="Credit Based Authorization.">
           A host must verify a mobile or multihomed peer's 
           reachability at a new locator.  Credit-Based Authorization 
           authorizes the peer to receive a certain amount of data at
           the new locator before the result of such verification is known.
         </t>

	       </list>
      </t>

    </section>

    <section anchor="sec.protocol.model" title="Protocol Model">
      <t> This section is an overview; more detailed specification follows
      this section. </t>
    
      <section anchor="sec.operating.environment" title="Operating Environment">

      <t>
      The <xref target="RFC5201">Host Identity Protocol (HIP) </xref>
      is a key establishment and parameter negotiation protocol.
      Its primary applications are for authenticating
      host messages based on host identities, and establishing security 
      associations (SAs) for the 
      <xref target="RFC5202">ESP transport format</xref>
      and possibly other protocols in
      the future.  
      </t>

      <figure anchor="fig.hip.operating.environment" title="HIP Deployment
      Model">
      <artwork><![CDATA[
 +--------------------+                       +--------------------+
 |                    |                       |                    |
 |   +------------+   |                       |   +------------+   |
 |   |    Key     |   |         HIP           |   |    Key     |   |
 |   | Management | <-+-----------------------+-> | Management |   |
 |   |  Process   |   |                       |   |  Process   |   |
 |   +------------+   |                       |   +------------+   |
 |         ^          |                       |         ^          |
 |         |          |                       |         |          |
 |         v          |                       |         v          |
 |   +------------+   |                       |   +------------+   |
 |   |   IPsec    |   |        ESP            |   |   IPsec    |   |
 |   |   Stack    | <-+-----------------------+-> |   Stack    |   |
 |   |            |   |                       |   |            |   |
 |   +------------+   |                       |   +------------+   |
 |                    |                       |                    |
 |                    |                       |                    |
 |     Initiator      |                       |     Responder      |
 +--------------------+                       +--------------------+
      ]]></artwork>
     </figure> 

   <t>
   The general deployment model for HIP is shown above, assuming operation
   in an end-to-end fashion.  This document
   specifies extensions to the HIP protocol to enable end-host mobility
   and basic multihoming.  In summary, these extensions to the HIP base 
   protocol enable the signaling of 
   new addressing information to the peer in HIP messages.  The messages
   are authenticated 
   via a signature or keyed hash message authentication code
   (HMAC) based on its Host Identity.  This document
   specifies the format of this new addressing (LOCATOR) parameter, the
   procedures for sending and processing this parameter to enable basic
   host mobility, and procedures for a concurrent address verification 
   mechanism.
   </t>

      <figure anchor="fig.hip.architecture" title="Architecture for 
      HIP Mobility and Multihoming (MH)">
      <artwork><![CDATA[
         ---------
         | TCP   |  (sockets bound to HITs)
         ---------
            |
         ---------
   ----> | ESP   |  {HIT_s, HIT_d} <-> SPI
   |     ---------
   |         |
 ----    ---------
| MH |-> | HIP   |  {HIT_s, HIT_d, SPI} <-> {IP_s, IP_d, SPI}
 ----    ---------
            |
         ---------
         |  IP   |
         ---------
      ]]></artwork>
     </figure> 


      <t> <xref target="fig.hip.architecture" /> depicts a layered 
      architectural view of
      a HIP-enabled stack using the ESP transport format.  In HIP, 
      upper-layer protocols (including TCP and ESP in this figure) are 
      bound to Host Identity Tags (HITs) and not IP addresses.  The HIP sublayer is 
      responsible for maintaining the binding between HITs and IP
      addresses.  The SPI is used to associate
      an incoming packet with the right HITs.  The block labeled "MH"
      is introduced below.</t>
  
      <t> Consider first the case in which there is no mobility or
      multihoming, as specified in the 
      <xref target="RFC5201">base protocol specification</xref>.
      The HIP base exchange establishes the HITs in use between the hosts,
      the SPIs to use for ESP, and the IP addresses (used in both the HIP
      signaling packets and ESP data packets).  
      Note that there can only be one such set of bindings
      in the outbound direction for any given packet, and the only 
      fields used for the binding at the HIP layer are the fields 
      exposed by ESP (the SPI and HITs).  For the inbound direction, 
      the SPI is all that is required to find the right host context.  
      ESP rekeying events change the mapping between
      the HIT pair and SPI, but do not change the IP addresses.</t>

      <t> Consider next a mobility event, in which a host is still
      single-homed but moves to another IP address.
      Two things must occur in this 
      case.  First, the peer must be notified of the
      address change using a HIP UPDATE message.  Second, each host 
      must change its local bindings at the HIP sublayer (new IP 
      addresses).  It may be that both the SPIs and IP addresses are 
      changed simultaneously in a single UPDATE; the protocol described
      herein supports this.  However, 
      simultaneous movement of both hosts, notification of transport 
      layer protocols
      of the path change, and procedures for possibly traversing 
      middleboxes are not covered by this document. </t>

      <t> Finally, consider the case when a host is multihomed (has
      more than one globally routable address) and has
      multiple addresses available at the HIP layer as alternative
      locators for fault tolerance.  Examples include the use of
      (possibly multiple) IPv4 and IPv6 addresses on the same interface, 
      or the use of multiple interfaces attached to different service 
      providers.  Such host multihoming generally necessitates that a
      separate ESP SA is maintained for each interface in order to
      prevent packets that arrive over different paths from falling 
      outside of the <xref target="RFC4303">ESP anti-replay window</xref>.
      Multihoming thus makes it possible that the bindings shown
      on the right side of <xref target= "fig.hip.architecture" /> are 
      one to many (in the outbound direction, one HIT pair to 
      multiple SPIs, and possibly then to multiple IP addresses).  
      However, only one SPI and address pair can be used for any given packet,
      so the job of the "MH" block depicted above is to dynamically
      manipulate these bindings.  Beyond locally managing such
      multiple bindings, the peer-to-peer HIP signaling protocol needs 
      to be flexible enough to define the desired mappings between
      HITs, SPIs, and addresses, and needs to ensure that UPDATE
      messages are sent along the right network paths so that any
      HIP-aware middleboxes can observe the SPIs.  
      This document does not specify the "MH" block, nor does it
      specify detailed elements of procedure for how to handle
      various multihoming (perhaps combined with mobility) scenarios.
      The "MH" block may apply to more general problems outside of HIP.
      However, this document does describe a basic multihoming case
      (one host adds one address to its initial address and notifies
      the peer) and leave more complicated scenarios for 
      experimentation and future documents.
      </t>

      <section anchor="sec.model.locator" title="Locator">
      <t> This document defines a generalization of an address called a 
      "locator".  A locator specifies a point-of-attachment to the network 
      but may also include additional end-to-end tunneling or per-host 
      demultiplexing context that affects how packets are handled below 
      the logical HIP sublayer of the stack.  This
      generalization is useful because IP addresses alone may not be 
      sufficient to describe how packets should be handled below HIP.  
      For example, in a host multihoming context, certain IP addresses 
      may need to be associated with certain ESP SPIs to avoid violating the 
      ESP anti-replay window.
      Addresses may also be affiliated with transport ports in certain 
      tunneling scenarios.  Locators may simply be traditional network 
      addresses.  The format of the locator fields in the LOCATOR
      parameter is defined in 
      <xref target="sec-locator-format" />. 
</t>
      </section>

      <section anchor="sec.model.mobility." title="Mobility Overview">

      <t> When a host moves to another address, it notifies its peer of the
      new address by sending a HIP UPDATE packet containing a LOCATOR
      parameter.  This UPDATE packet is acknowledged by the peer.  For
      reliability in the presence of packet loss, the UPDATE packet is
      retransmitted as defined in the HIP protocol specification
      <xref target="RFC5201" />.
      The peer can authenticate the contents
      of the UPDATE packet based on the signature and keyed hash of the
      packet.  
      </t>

      <t> When using 
      <xref target="RFC5202">ESP Transport Format</xref>,
      the host may at the same time 
      decide to rekey its security association and possibly generate a new 
      Diffie-Hellman key; all of these actions are triggered by including
      additional parameters in the UPDATE packet, as defined in the
      <xref target="RFC5201">base protocol specification </xref>
      and <xref target="RFC5202">ESP extension</xref>.
      </t>

      <t> When using ESP (and possibly other transport modes in the
      future), the host is
      able to receive packets that are protected using a HIP created ESP
      SA from any address.  Thus, a host can change its IP address and
      continue to send packets to its peers without necessarily rekeying.  
      However, the peers are not able to send packets to these new addresses 
      before
      they can reliably and securely update the set of addresses that
      they associate with the sending host.  Furthermore, mobility
      may change the path characteristics in such a manner that 
      reordering occurs and packets fall outside the ESP anti-replay
      window for the SA, thereby requiring rekeying.</t>
      </section>

      <section anchor="sec.model.multihoming" title="Multihoming Overview">

      <t> A related operational configuration is host multihoming, in which
      a host has multiple locators simultaneously rather than sequentially,
      as in the case of mobility.  By using the LOCATOR parameter defined 
      herein,
      a host can inform its peers of additional (multiple) locators at which 
      it can be reached, and can declare a particular locator as a "preferred"
      locator.  Although this document defines a basic mechanism for 
      multihoming,
      it does not define detailed policies and procedures, such as 
      which locators to choose
      when more than one pair is available, the operation of simultaneous
      mobility and multihoming, source address selection policies 
      (beyond those specified in <xref target="RFC3484" />), 
      and the implications of multihoming
      on transport protocols and ESP anti-replay windows.  Additional
      definitions of HIP-based multihoming are expected to be part of future
      documents.
      </t> 
      </section>

      </section>

      <section anchor="sec.protocol.overview" title="Protocol Overview"> 

      <t>In this section, we briefly introduce a number of usage
      scenarios for HIP mobility and multihoming.
      These scenarios assume that HIP is being used with the 
      <xref target="RFC5202">ESP transform</xref>,
      although other scenarios may be defined in the
      future.  To understand these usage scenarios, the reader should
      be at least minimally familiar with the <xref
      target="RFC5201">HIP protocol specification</xref>.
      However, for the (relatively) uninitiated reader, it is most
      important to keep in mind that in HIP the actual payload traffic
      is protected with ESP, and that the ESP SPI acts as an index to
      the right host-to-host context.  More specification details are
      found later in <xref target="sec-locator-format" /> and 
      <xref target="sec.processing.rules" />.  </t>

      <t> The scenarios below assume that the two hosts have 
      completed a single HIP base exchange with each other.
      Both of the hosts therefore have one incoming and one outgoing
      SA.  Further, each SA uses the same pair of IP addresses, which
      are the ones used in the base exchange.  </t>

      <t>The readdressing protocol is an asymmetric protocol where a
      mobile or multihomed host informs a peer host
      about changes of IP addresses on affected SPIs.  
      The readdressing exchange is designed to be piggybacked 
      on existing HIP exchanges.  The majority of the packets on which
      the LOCATOR parameters are expected to be carried are UPDATE
      packets.  However, some implementations may want to
      experiment with sending LOCATOR parameters also on other packets,
      such as R1, I2, and NOTIFY.</t>
     
      <t> The scenarios below at times describe addresses as being in either
      an ACTIVE, VERIFIED, or DEPRECATED state.  From the perspective of
      a host, newly-learned addresses of the peer must be verified
      before put into active service, and addresses removed by the peer
      are put into a deprecated state.  Under limited conditions described
      below (<xref target="anchor.CBA.proc" />), an UNVERIFIED address 
      may be used.  
      The addressing states are defined more formally in 
      <xref target="sec.loc.data.struct.status" />. </t>
                    
      <t> Hosts that use link-local addresses as source addresses
      in their HIP handshakes may not be reachable by a mobile peer.
      Such hosts SHOULD provide a globally routable address either in
      the initial handshake or via the LOCATOR parameter.
      </t>

      <section title="Mobility with a Single SA Pair (No Rekeying)">
	    <t> A mobile host must sometimes change an IP address bound
        to an interface.  The change of an IP address might be needed due
        to a change in the advertised IPv6 prefixes on the link, a
        reconnected PPP link, a new DHCP lease, or an actual movement
        to another subnet.  In order to maintain its communication
        context, the host must inform its peers about the new IP
        address.  This first example considers the case in which the
        mobile host has only one interface, IP address, a single
        pair of SAs (one inbound, one outbound), and no rekeying
        occurs on the SAs.  We also assume that the new IP addresses 
        are within the same address family (IPv4 or IPv6) as the first
        address.  This is the simplest scenario, depicted
        in <xref target="single-homed-mobility1" />. 
        </t>

      <figure anchor="single-homed-mobility1" title="Readdress without Rekeying, but with Address Check">
	<artwork>
  Mobile Host                         Peer Host

          UPDATE(ESP_INFO, LOCATOR, SEQ)
     -----------------------------------&gt;
          UPDATE(ESP_INFO, SEQ, ACK, ECHO_REQUEST)  
     &lt;-----------------------------------
          UPDATE(ACK, ECHO_RESPONSE)
     -----------------------------------&gt;
        </artwork>
      </figure>

	      <t>
         The steps of the packet processing are as follows:
        <list style="numbers">

	        <t>The mobile host is disconnected from the peer host for
          a brief period of time while it switches from one IP address
          to another.  Upon obtaining a new IP address,
          the mobile host
	        sends a LOCATOR parameter to the peer host in an UPDATE 
          message.  The UPDATE message also contains an ESP_INFO
          parameter containing the values of the old and new SPIs for
          a security association.  In this case, the OLD SPI and 
          NEW SPI parameters both are
          set to the value of the preexisting incoming SPI; this
          ESP_INFO does not trigger a rekeying event but is instead
          included for possible parameter-inspecting middleboxes on
          the path.  The LOCATOR parameter contains
          the new IP address (Locator Type of "1", defined below)
          and a locator lifetime.
          The mobile host waits for this UPDATE to be acknowledged,
          and retransmits if necessary, as specified in the 
          <xref target="RFC5201"> base specification</xref>.
	        </t>

	        <t>The peer host receives the UPDATE, validates it, and
          updates any local bindings between the HIP association and
          the mobile host's destination address.  The peer host MUST
          perform an address verification by placing a nonce in the
          ECHO_REQUEST parameter of the UPDATE message sent back to
          the mobile host.  It also includes
          an ESP_INFO parameter with the OLD SPI and NEW SPI
          parameters both set to the value of the preexisting
          incoming SPI, and sends this UPDATE (with piggybacked
          acknowledgment) to the mobile host at its new address. 
          The peer MAY use the new address immediately, but
          it MUST limit the amount of data it sends to the address
          until address verification completes.</t>

          <t> The mobile host completes the readdress by processing
          the UPDATE ACK and echoing the nonce in an ECHO_RESPONSE.
          Once the peer host receives this ECHO_RESPONSE, it considers
          the new address to be verified and can put the address into full use.
          </t>
	    </list>
	    </t>
 
	  <t>While the peer host is verifying the new address, the new address
	  is marked as UNVERIFIED in the interim, and the old address is
          DEPRECATED.   Once the peer host has 
	  received a correct reply to its UPDATE challenge,
	  it marks the new address as
	  ACTIVE and removes the old address.
	  </t>

      </section>

      <section title="Mobility with a Single SA Pair (Mobile-Initiated Rekey)">
	    <t> The mobile host may decide to rekey the SAs at the same time
      that it notifies the peer of the new address.  In this
      case, the above procedure described in 
      <xref target="single-homed-mobility1" /> is slightly modified.
      The UPDATE message sent from the mobile host includes an 
      ESP_INFO with the OLD SPI set to the previous SPI, the
      NEW SPI set to the desired new SPI value for the incoming SA,
      and the KEYMAT Index desired.  Optionally, the host may include
      a DIFFIE_HELLMAN parameter for a new Diffie-Hellman key.  The
      peer completes the request for a rekey as is normally done
      for HIP rekeying, except that the new address is kept as 
      UNVERIFIED until the UPDATE nonce challenge is received as
      described above.  <xref target="single-homed-mobility2" /> 
      illustrates this scenario.</t>

      <figure anchor="single-homed-mobility2" title="Readdress with Mobile-Initiated Rekey">
	<artwork>
  Mobile Host                         Peer Host

          UPDATE(ESP_INFO, LOCATOR, SEQ, [DIFFIE_HELLMAN])
     -----------------------------------&gt;
          UPDATE(ESP_INFO, SEQ, ACK, [DIFFIE_HELLMAN,] ECHO_REQUEST)  
     &lt;-----------------------------------
          UPDATE(ACK, ECHO_RESPONSE)
     -----------------------------------&gt;
        </artwork>
      </figure>
      </section>

<!--
      <section title="Mobility with single SA pair (peer-initiated rekey)">
      <t> A second variation of this basic mobility scenario covers the
      case in which the mobile host does not attempt to rekey the existing SAs,
      but the peer host decides to do so.  This typically results in a 
      four packet exchange, as shown in 
      <xref target="single-homed-mobility3" />.
      The initial UPDATE packet from the mobile host is the same as
      in the scenario for which there is no rekey 
      (<xref target="single-homed-mobility1" />).  The peer may decide
      to rekey, however, in which case the subsequent
      three packets follow the normal rekeying procedure described in
      <xref target="RFC5202">the ESP specification</xref>,
      with the addition of the ECHO_REQUEST and ECHO_RESPONSE nonce
      for verification of the new address.
      </t>

      <figure anchor="single-homed-mobility3" title="Readdress with peer-initiated rekey">
	<artwork>
  Mobile Host                         Peer Host

          UPDATE(ESP_INFO, LOCATOR, SEQ)
     -----------------------------------&gt;
          UPDATE(ESP_INFO, SEQ, ACK, [DIFFIE_HELLMAN], ECHO_REQUEST)  
     &lt;-----------------------------------
          UPDATE(ESP_INFO, SEQ, ACK, [DIFFIE_HELLMAN,] ECHO_RESPONSE)
     -----------------------------------&gt;
             UPDATE(ACK)
     &lt;-----------------------------------
        </artwork>
      </figure>
      
      </section>

-->

      <section anchor="hostmh" title="Host Multihoming">
	    <t>A (mobile or stationary) host may sometimes have more than 
	    one interface or global address.  The host may notify the peer host 
      of the additional interface or address by using the LOCATOR 
      parameter.  To avoid problems
	    with the ESP anti-replay window, a host SHOULD use
	    a different SA for each interface or address used to receive 
      packets from the peer host when multiple locator pairs are being
      used simultaneously rather than sequentially.</t>
	
	    <t> When more than one locator is provided to the peer host,
	    the host SHOULD indicate which locator is preferred 
            (the locator on which the host prefers to receive traffic).  
	    By default, the addresses used in the base exchange are 
	    preferred until indicated otherwise.</t>

        <t> In the multihoming case, the sender may also have multiple
        valid locators from which to source traffic.  In practice,
        a HIP association in a multihoming configuration may have
        both a preferred peer locator and a preferred local locator,
        although rules for source address selection should ultimately
        govern the selection of the source locator based on the destination
        locator.</t>

        <t>Although the protocol may allow for configurations
        in which there is an asymmetric number of SAs between the
        hosts (e.g., one host has two interfaces and two inbound
        SAs, while the peer has one interface and one inbound SA),
        it is RECOMMENDED that inbound and outbound SAs be created
        pairwise between hosts.  When an ESP_INFO arrives to rekey a
        particular outbound SA, the corresponding inbound SA should
        be also rekeyed at that time.  Although asymmetric
        SA configurations might be experimented with, their usage
        may constrain interoperability at this time.  However,
        it is recommended that implementations attempt to support
        peers that prefer to use non-paired SAs.  It is expected
        that this section and behavior will be modified in future
        revisions of this protocol, once the issue and its implications
        are better understood.
        </t>
	
	  <t>Consider the case between two hosts, one single-homed and
    one multihomed.  The multihomed host may decide to inform the 
    single-homed host about its other address.  It is
    RECOMMENDED that the multihomed host set up a new SA pair for use 
    on this new address.  To do this, the multihomed host sends
	  a LOCATOR with an ESP_INFO, indicating the request for a new SA
    by setting the OLD SPI value to zero, and the NEW SPI
    value to the newly created incoming SPI.  A Locator Type of "1"
    is used to associate the new address with the new SPI.
    The LOCATOR parameter also contains a second Type "1" locator, that of
    the original address and SPI.  To simplify parameter processing
    and avoid explicit protocol extensions to remove locators, each
    LOCATOR parameter MUST list all locators in use on a connection
    (a complete listing of inbound locators and SPIs for the host).
	  The multihomed host waits for an ESP_INFO 
    (new outbound SA) from the
	  peer and an ACK of its own UPDATE.  As in the mobility case,
	  the peer host must perform an address verification before actively
    using the new address.  <xref target="multi-home1" /> 
    illustrates this scenario.
	  </t>

      <figure anchor="multi-home1" title="Basic Multihoming Scenario">
	<artwork>
  Multi-homed Host                    Peer Host

           UPDATE(ESP_INFO, LOCATOR, SEQ, [DIFFIE_HELLMAN])
     -----------------------------------&gt;
           UPDATE(ESP_INFO, SEQ, ACK, [DIFFIE_HELLMAN,] ECHO_REQUEST)  
     &lt;-----------------------------------
           UPDATE(ACK, ECHO_RESPONSE)
     -----------------------------------&gt;
        </artwork>
      </figure>
	
	  <t>In multihoming scenarios, it is important that hosts receiving
          UPDATEs associate them correctly with the destination address
          used in the packet carrying the UPDATE.  When processing 
          inbound LOCATORs that establish new security
	  associations on an interface with multiple addresses, a host uses 
          the destination address of the 
	  UPDATE containing the LOCATOR as the local address to which the LOCATOR
	  plus ESP_INFO is targeted.  This is because hosts may send 
          UPDATEs with the same (locator) IP address to different 
          peer addresses -- this has the effect of creating multiple 
          inbound SAs implicitly affiliated with
	  different peer source addresses. </t>

      </section>

      <section title="Site Multihoming">

	<t>A host may have an interface that has multiple globally
	routable IP addresses.  Such a situation may be a result of
	the site having multiple upper Internet Service Providers, or
	just because the site provides all hosts with both IPv4 and
	IPv6 addresses.  The host should stay reachable at all or any
subset of the currently available global routable addresses,
independent of how they are provided.
	</t>

	<t>This case is handled the same as if there were different
        IP addresses, described above in <xref target="hostmh" />.  
	Note that a single interface may experience site
	multihoming while the host itself may have multiple
	interfaces.</t>

	<t>Note that a host may be multihomed and mobile
	simultaneously, and that a multihomed host may want to
	protect the location of some of its interfaces while revealing
	the real IP address of some others.</t>

	<t>This document does not presently specify additional site
	multihoming extensions to HIP; further alignment with the
  IETF shim6 working group may be considered in the future. </t>
      </section>

      <section title="Dual host multihoming">
	<t>Consider the case in which both hosts would like to add
	an additional address after the base exchange completes.
	In <xref target="dual-host-mh" />, consider that host1, which
        used address addr1a in the base exchange to set up SPI1a and SPI2a,
	wants to add address addr1b.  It would send an UPDATE with LOCATOR 
        (containing the address addr1b) to host2, using destination
        address addr2a, and a new set of SPIs would be added
	between hosts 1 and 2 (call them SPI1b and SPI2b -- not shown
        in the figure).  Next,
	consider host2 deciding to add addr2b to the relationship.
	Host2 must select one of host1's addresses towards which to
	initiate an UPDATE.  It may choose to initiate an UPDATE to
	addr1a, addr1b, or both.  If it chooses to send to both,
	then a full mesh (four SA pairs) of SAs would exist between
	the two hosts.  This is the most general case; it often may be
	the case that hosts primarily establish new SAs
	only with the peer's Preferred locator.  The readdressing
	protocol is flexible enough to accommodate this choice. </t>

       <figure anchor="dual-host-mh"  title="Dual Multihoming Case in
	Which Each Host Uses LOCATOR to Add a Second Address">
	<artwork>           
           -&lt;- SPI1a --                         -- SPI2a ->-
   host1 &lt;              > addr1a &lt;---> addr2a &lt;              > host2
           ->- SPI2a --                         -- SPI1a -&lt;-

                          addr1b &lt;---> addr2a  (second SA pair)   
                          addr1a &lt;---> addr2b  (third SA pair)               
                          addr1b &lt;---> addr2b  (fourth SA pair)             
	</artwork>
       </figure>

      </section>

      <section title="Combined Mobility and Multihoming">

	<t>It looks likely that in the future, many mobile hosts will
	be simultaneously mobile and multihomed, i.e., have multiple
	mobile interfaces.  Furthermore, if the interfaces use
	different access technologies, it is fairly likely that one of
	the interfaces may appear stable (retain its current IP
	address) while some other(s) may experience mobility (undergo
	IP address change).</t>

	<t>The use of LOCATOR plus ESP_INFO should be flexible enough to 
	handle most such scenarios, although more complicated scenarios
	have not been studied so far. </t>

      </section>

      <section title="Using LOCATORs across Addressing Realms">
	<t>It is possible for HIP associations to migrate to a state
     in which both parties are only using locators in different
     addressing realms.  For example, the two hosts may initiate
     the HIP association when both are using IPv6 locators, then
     one host may loose its IPv6 connectivity and obtain an
     IPv4 address.  In such a case, some type of mechanism for
     interworking between the different realms must be employed;
     such techniques are outside the scope of the present text.
     The basic problem in this example is that the host readdressing
     to IPv4 does not know a corresponding IPv4 address of the peer.
     This may be handled (experimentally) by possibly configuring
     this address information manually or in the DNS, or the hosts
     exchange both IPv4 and IPv6 addresses in the locator.
</t>
      </section>

      <section title="Network Renumbering">

        <t>It is expected that IPv6 networks will be renumbered much
        more often than most IPv4 networks.  From an end-host
        point of view, network renumbering is similar to mobility.</t>

      </section>

      <section title="Initiating the Protocol in R1 or I2">

	<t>A Responder host MAY include a LOCATOR parameter in
	the R1 packet that it sends to the Initiator.  This
	parameter MUST be protected by the R1 signature.  If the R1
	packet contains LOCATOR parameters with a new Preferred locator, 
        the Initiator SHOULD directly set the new Preferred locator to
        status ACTIVE without performing address verification first, and 
        MUST send the I2 packet to the new Preferred locator.
	The I1 destination address and the new
	Preferred locator may be identical.  All new non-preferred locators
        must still undergo address verification once the base exchange
        completes.</t>

	<figure anchor="figure-protocol-over-R1" title="LOCATOR Inclusion in R1">
	  <artwork>
         Initiator                                Responder

                           R1 with LOCATOR
               &lt;-----------------------------------
record additional addresses
change responder address
                  I2 sent to newly indicated preferred address
               -----------------------------------&gt;
                                                  (process normally)
                               R2 
               &lt;-----------------------------------
(process normally, later verification of non-preferred locators)
          </artwork>
	</figure>

	<t>An Initiator MAY include one or more LOCATOR parameters in the
	I2 packet, independent of whether or not there was a LOCATOR parameter
	in the R1.  These parameters MUST be protected by the
	I2 signature.  Even if the I2 packet contains LOCATOR parameters,
	the Responder MUST still send the R2 packet to the source
	address of the I2.  The new Preferred locator SHOULD be
	identical to the I2 source address.  If the I2 packet contains 
  LOCATOR parameters, all new locators must undergo address verification
  as usual, and the ESP traffic that subsequently follows should use
  the Preferred locator.  </t>

	<figure anchor="figure-protocol-over-I2" title="LOCATOR Inclusion in I2">
	  <artwork>
         Initiator                                Responder

                          I2 with LOCATOR
               -----------------------------------&gt;
                                                  (process normally)
                                          record additional addresses
                    R2 sent to source address of I2
               &lt;-----------------------------------
(process normally)
          </artwork>
	</figure>


     <t> The I1 and I2 may be arriving from different source addresses 
         if the LOCATOR parameter is present in R1. In this case, 
         implementations simultaneously using multiple pre-created R1s,
         indexed by Initiator IP addresses, may inadvertently fail the 
         puzzle solution of I2 packets due to a perceived puzzle mismatch.
         See, for instance, the example in Appendix A of 
         <xref target="RFC5201" />.
         As a solution, the Responder's puzzle indexing mechanism must be 
         flexible enough to accommodate the situation when R1
         includes a LOCATOR parameter.
     </t>
      </section>

     </section>

      <section anchor="sec.other.considerations" title="Other Considerations"> 

        <section anchor="sec.model.verification" title="Address Verification">
      
	      <t>When a HIP host receives a set of locators from
        another HIP host in a LOCATOR, it does not necessarily know
        whether the other host is actually reachable at the claimed
        addresses.  In fact, a malicious peer host may be
        intentionally giving bogus addresses in order to cause a
        packet flood towards the target addresses <xref
        target="RFC4225" />.  Likewise, viral
        software may have compromised the peer host, programming it
        to redirect packets to the target addresses.  Thus, the HIP host
        must first check that
        the peer is reachable at the new address.</t>

	    <t> An additional potential benefit of performing address 
      verification is to allow middleboxes in the network along the 
      new path to obtain the peer host's inbound SPI.</t>

      <t> Address verification is implemented by the challenger sending 
      some piece of unguessable information to the new address, and waiting 
      for some acknowledgment from the Responder that indicates reception 
      of the information at the new address.  This may include the exchange 
      of a nonce, or the generation of a new SPI and observation of data 
      arriving on the new SPI.
      </t>

        </section>
      <section anchor="anchor.CBA" title="Credit-Based Authorization">
      
      <t>Credit-Based Authorization (CBA) allows a host to securely use a new 
      locator even though the peer's reachability at the address embedded 
      in the locator has not yet been verified.  This is accomplished 
      based on the following three hypotheses:
      </t>

      <list style="numbers">
        <t> A flooding attacker typically seeks to somehow multiply the 
            packets it generates for the purpose of its attack 
            because bandwidth is an ample resource for many victims.
        </t>
        <t> An attacker can often cause unamplified flooding by sending
            packets to its victim, either by directly addressing the
            victim in the packets, or by guiding the packets along a specific
            path by means of an IPv6 Routing header, if Routing headers are
            not filtered by firewalls.
            
        </t>
        <t> Consequently, the additional effort required to set up a 
            redirection-based flooding attack (without CBA and return 
            routability checks) would pay off for the 
            attacker only if amplification could be obtained this way.
        </t>
      </list>

      <t> On this basis, rather than eliminating malicious packet 
      redirection in the first place, Credit-Based Authorization prevents 
      amplifications.  This is 
      accomplished by limiting the data a host can send to an unverified 
      address of a peer by the data recently received from that peer.  
      Redirection-based flooding attacks thus become less attractive than, 
      for example, pure direct flooding, where the attacker itself sends bogus 
      packets to the victim.
      </t>

      <t><xref target="figure-readdressing-scenario"/> illustrates 
      Credit-Based Authorization:  Host B measures the amount of data
      recently 
      received from peer A and, when A readdresses, sends packets to A's 
      new, unverified address as long as the sum of the packet sizes does not 
      exceed the measured, received data volume.  When insufficient credit 
      is left, B stops sending further packets to A until A's address 
      becomes ACTIVE.  The address changes may be due to mobility,
      multihoming, or any other reason.  Not shown in 
      <xref target="figure-readdressing-scenario"/> are the results of 
      <xref target="sec-credit-aging">credit aging</xref>, 
      a mechanism used to dampen possible time-shifting attacks.</t>

      <figure title="Readdressing Scenario" 
       anchor="figure-readdressing-scenario">
      <artwork><![CDATA[
        +-------+                        +-------+
        |   A   |                        |   B   |
        +-------+                        +-------+
            |                                |
    address |------------------------------->| credit += size(packet)
     ACTIVE |                                |
            |------------------------------->| credit += size(packet)
            |<-------------------------------| do not change credit
            |                                |
            + address change                 |
            + address verification starts    |
    address |<-------------------------------| credit -= size(packet)
 UNVERIFIED |------------------------------->| credit += size(packet)
            |<-------------------------------| credit -= size(packet)
            |                                |
            |<-------------------------------| credit -= size(packet)
            |                                X credit < size(packet)
            |                                | => do not send packet!
            + address verification concludes |
    address |                                |
     ACTIVE |<-------------------------------| do not change credit
            |                                |
]]></artwork>
      </figure>
      <vspace blankLines="1"/> <!-- not sure this is needed -->
      </section>

      <section title="Preferred Locator">

        <t>When a host has multiple locators, the peer host
        must decide which to use for outbound packets.
	It may be that a host would
        prefer to receive data on a particular inbound interface.  
	HIP allows a particular locator to be designated as
        a Preferred locator and communicated to the peer  
        (see <xref target="sec-locator-format" />).
	</t>

	<t>In general, when multiple locators are used for a 
	session, there is the question of using multiple locators 
	for failover only or for load-balancing.  Due to the
	implications of load-balancing on the transport layer 
	that still need to be worked out, this document assumes
	that multiple locators are used primarily for failover.
	An implementation may use ICMP interactions, reachability
	checks, or other means to detect the failure of 
	a locator. </t>
	

      </section>
      <section title="Interaction with Security Associations">

	<t>This document specifies a new HIP protocol parameter, the
        LOCATOR parameter (see <xref target="sec-locator-format" />), that 
     allows the hosts to exchange information about their locator(s)
        and any changes in their locator(s).  The logical structure
        created with LOCATOR parameters has three levels: hosts,
        Security Associations (SAs) indexed by Security 
        Parameter Indices (SPIs), and addresses.</t>

        <t>The relation between these levels for an association
        constructed as defined in the <xref target="RFC5201"> 
        base specification</xref> and <xref target="RFC5202">
        ESP transform </xref> is illustrated in
	<xref target="base-relations" />.</t>

       <figure anchor="base-relations"  title="Relation between Hosts,
        SPIs, and Addresses (Base Specification)">
	<artwork>           
           -&lt;- SPI1a --                         -- SPI2a ->-
   host1 &lt;              > addr1a &lt;---> addr2a &lt;              > host2
           ->- SPI2a --                         -- SPI1a -&lt;-
	</artwork>
       </figure>

        <t>In <xref target="base-relations" />, host1 and host2
        negotiate two unidirectional SAs, and each host selects 
        the SPI value
        for its inbound SA.  The addresses addr1a and addr2a are the
        source addresses that the hosts use in the base HIP exchange.
        These are the "preferred" (and only) addresses conveyed to
        the peer for use on each SA.   That is, although packets sent to 
        any of the hosts' interfaces may be accepted on the inbound SA,
        the peer host in general knows of only the single destination
        address learned in the base exchange 
	(e.g., for host1, it sends a packet on SPI2a to addr2a to
        reach host2), unless other 
        mechanisms exist to learn of new addresses.</t>

        <t>In general, the bindings that exist in an implementation
        corresponding to this document can be depicted as shown in 
        <xref target="figure-levels" />.  In this figure, a host
        can have multiple inbound SPIs (and, not shown, multiple
        outbound SPIs) associated with another host.  Furthermore,
        each SPI may have multiple addresses associated with it.  
        These addresses that are bound to an SPI are not used to lookup
        the incoming SA.  Rather, the addresses are those
        that are provided to the peer host, as hints for which 
        addresses to use to reach the host on that SPI.  
        The LOCATOR
        parameter is used to change the set of addresses that a
        peer associates with a particular SPI.</t>

       <figure anchor="figure-levels" title="Relation between Hosts,
       SPIs, and Addresses (General Case)">
	<artwork>           
                         address11
                       / 
                SPI1   - address12
              /
             /           address21
        host -- SPI2   &lt;
             \           address22
              \
                SPI3   - address31
                       \
                         address32
	</artwork>
       </figure>

	<t>A host may establish any number of security associations
        (or SPIs) with a peer.  The main purpose of having multiple
        SPIs with a peer is to group the addresses into collections that
	are likely to experience fate sharing.  For example, if the
	host needs to change its addresses on SPI2, it is likely
	that both address21 and address22 will simultaneously become
	obsolete.  In a typical case, such SPIs may correspond with
	physical interfaces; see below.  Note, however, that
	especially in the case of site multihoming, one of the
	addresses may become unreachable while the other one still
	works.  In the typical case, however, this does not require
	the host to inform its peers about the situation, since even
	the non-working address still logically exists. </t>

	<t>A basic property of HIP SAs is that the inbound IP address
        is not used to lookup the incoming SA.  Therefore, in 
        <xref target="figure-levels" />, it may seem unnecessary for 
        address31, for example, to be associated only with SPI3 -- in
        practice, a packet may arrive to SPI1 via destination address
        address31 as well.  However, the use of different source
	and destination addresses typically leads to different paths,
        with different latencies in the network, and if packets were
        to arrive via an arbitrary destination IP address (or path)
        for a given SPI, the reordering due to different latencies
	may cause some packets to fall outside of the ESP 
	anti-replay window.  For this reason, HIP provides a mechanism to
        affiliate destination addresses with inbound SPIs, when there
        is a concern that anti-replay windows might be violated.
	In this sense, we can say that a given inbound SPI has an 
	"affinity" for certain inbound IP addresses, and this affinity 
	is communicated to the peer host.  Each physical interface
        SHOULD have a separate SA, unless the ESP anti-replay window
        is loose.</t>

	<t>Moreover, even when the destination addresses used for a
        particular SPI are held constant, the use of different 
        source interfaces may also cause packets to fall outside of
        the ESP anti-replay window, since the path traversed is often
        affected by the source address or interface used.  A host 
        has no way to influence the source interface on which a peer 
        sends its packets on a given SPI.  A host SHOULD 
        consistently use the same source interface and address when 
        sending to a 
        particular destination IP address and SPI.  For this reason, 
	a host may find it useful to change its SPI or at least reset 
	its ESP anti-replay window when the peer host readdresses.</t>

	<t>An address may appear on more than one SPI.  This creates
	no ambiguity since the receiver will ignore the IP addresses
        during SA lookup anyway.  However, this document does not
     specify such cases.</t>

<!---
	<t>A single LOCATOR parameter contains data only about one SPI.
	To simultaneously signal changes on several SPIs, it
	is necessary to send several LOCATOR parameters.  The packet
	structure supports this.</t>
-->

        <t> When the LOCATOR parameter is sent in an UPDATE packet, then the
        receiver will respond with an UPDATE acknowledgment.  When the
        LOCATOR parameter is sent in an R1 or I2 packet, the base exchange
        retransmission mechanism will confirm its successful delivery.  
        LOCATORs may experimentally be used in NOTIFY packets; in this case,
        the recipient MUST consider the LOCATOR as informational and not
        immediately change the current preferred address, but can test the 
        additional locators when the need arises.  The use of the LOCATOR 
        in a NOTIFY message may not be compatible with middleboxes.</t>

      </section>

      </section>


    </section>

    <section anchor="sec-locator-format"
      title="LOCATOR Parameter Format">

     <t> The LOCATOR parameter is a critical parameter as defined by 
     <xref target="RFC5201" />.  It consists of the 
       standard HIP parameter
       Type and Length fields, plus zero or more Locator sub-parameters.
       Each Locator sub-parameter contains a Traffic Type, Locator Type,
       Locator Length, Preferred locator bit, Locator Lifetime, and a 
       Locator encoding.  A LOCATOR contaning zero Locator fields 
       is permitted but has the effect of deprecating all addresses.
       </t>

<figure anchor="locator" title="LOCATOR Parameter Format">
            <artwork>
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |             Type              |            Length             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | Traffic Type   | Locator Type | Locator Length | Reserved   |P|
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                       Locator Lifetime                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                            Locator                            |
    |                                                               |
    |                                                               |
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    .                                                               .
    .                                                               .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | Traffic Type   | Locator Type | Locator Length | Reserved   |P|
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                       Locator Lifetime                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                            Locator                            |
    |                                                               |
    |                                                               |
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

            </artwork>
          </figure>
     <t>
    <list style="hanging">
      <t hangText="Type:">
        193</t>
      <t hangText="Length:">
        Length in octets, excluding Type and Length fields, and excluding padding.</t>
      <t hangText="Traffic Type:">
              Defines whether the locator pertains to HIP signaling, user data, or both.
      </t>
      <t hangText="Locator Type:">
              Defines the semantics of the Locator field.  </t>
      <t hangText="Locator Length:">
              Defines the length of the Locator field, in units of 4-byte words 
              (Locators up to a maximum of 4*255 octets are supported). </t>
      <t hangText="Reserved:">
        Zero when sent, ignored when received.</t>
      <t hangText="P:">
        Preferred locator.  Set to one if the locator is preferred for that Traffic
        Type; otherwise, set to zero.</t>   
      <t hangText="Locator Lifetime:">
        Locator lifetime, in seconds.  </t>
      <t hangText="Locator:">
        The locator whose semantics and encoding are indicated by the 
        Locator Type field.  All
        Locator sub-fields are integral multiples of four octets in length.
        </t>
    </list>
        </t>

	<t>The Locator Lifetime indicates how long the following locator
	is expected to be valid.  The lifetime is expressed in seconds.
	Each locator MUST have a non-zero lifetime.  The address is
	expected to become deprecated when the specified number of
	seconds has passed since the reception of the message.  A
	deprecated address SHOULD NOT be used as a destination address
	if an alternate (non-deprecated) is available and has sufficient
	scope.  </t>


    <section title="Traffic Type and Preferred Locator"> 
        <t>
        The following Traffic Type values are defined:
   <vspace blankLines="1" />
    <list style="hanging">
      <t hangText="0: "> Both signaling (HIP control packets) and user data. </t>
      <t hangText="1: "> Signaling packets only. </t>
      <t hangText="2: "> Data packets only. </t>
    </list>
    </t>
    
    <t> The "P" bit, when set, has scope over the corresponding Traffic 
    Type.  That is, when a "P" bit is set for Traffic Type "2", for example,
    it means that the locator is preferred for data packets.  If there is
    a conflict (for example, if the "P" bit is set for an address of Type "0" and a
    different address of Type "2"), the more
    specific Traffic Type rule applies (in this case, "2").  By default, 
    the IP addresses used in
    the base exchange are Preferred locators for both signaling and 
    user data, unless a new Preferred locator supersedes them.  If no 
    locators are indicated
    as preferred for a given Traffic Type, the implementation may use an
    arbitrary locator from the set of active locators.
    </t>

    </section>

    <section title="Locator Type and Locator"> 
        <t>
        The following Locator Type values are defined, along with the
        associated semantics of the Locator field:
    <list style="hanging">
      <t hangText="0: ">
        An IPv6 address or an IPv4-in-IPv6 format IPv4 address
        <xref target="RFC4291" /> (128 bits long).  This locator type is
        defined primarily for non-ESP-based usage.</t>
      <t hangText="1: ">
        The concatenation of an ESP SPI (first 32 bits) followed by an IPv6 address 
        or an IPv4-in-IPv6 format IPv4 address (an additional 128 bits).
        This IP address is defined primarily for ESP-based usage.
        </t>
    </list>
    </t>
    </section>

      <section title="UPDATE Packet with Included LOCATOR">

	<t>A number of combinations of parameters in an UPDATE packet
	are possible (e.g., see <xref target="sec.protocol.overview" />).
        In this document, procedures are defined only for the case in which
        one LOCATOR and one ESP_INFO parameter is used in any HIP packet.
        Furthermore, the
        LOCATOR SHOULD list all of the locators that are active on
        the HIP association (including those on SAs not covered by the 
        ESP_INFO parameter).
	Any UPDATE packet that includes a LOCATOR parameter SHOULD
	include both an HMAC and a HIP_SIGNATURE parameter.
        The relationship between the announced Locators and any ESP_INFO
        parameters present in the packet is defined in 
        <xref target="sending-locators" />.
        The sending of multiple LOCATOR and/or ESP_INFO parameters is
        for further study; receivers may wish to experiment with
        supporting such a possibility.
	</t>

<!--
	<t>If there are multiple LOCATOR parameters to be sent in a single
	UPDATE, and at least one of the LOCATOR parameters is matched with 
	a NES parameter, then each LOCATOR must be matched with a NES 
	parameter, to avoid ambiguity:</t>

	<figure>
	  <artwork>
   IP ( HIP ( LOC1, LOC2, NES1, NES2, [ DH, ] ... ) )
	  </artwork>
	</figure>

	<t>If there are multiple LOCATOR parameters to be sent and not
	all are paired with a NES, then multiple UPDATEs must
	be used (some with NES, some without) to avoid ambiguity
	in the pairing of LOCATOR with NES.</t>
-->
      </section>


    </section>

    <section anchor="sec.processing.rules" title="Processing Rules">
 
      <t> This section describes rules for sending and receiving
      the LOCATOR parameter, testing address reachability, and
      using Credit-Based Authorization (CBA) on UNVERIFIED locators.</t> 

<!--
      <t>HIP mobility and multihoming is fundamentally based on the
      <xref target="RFC4423">HIP architecture</xref>,
      where the transport and internetworking layers are decoupled
      from each other by an interposed Host Identity Protocol layer.  In
      the HIP architecture, the transport layer sockets are bound to
      the Host Identifiers (through HIT or LSI in the case of legacy
      APIs), and the Host Identifiers are translated to the actual IP
      address.</t>

      <t>The <xref target="RFC5201">HIP base protocol
      specification</xref> is expected to be commonly used with
      the <xref target="RFC5202"> ESP Transport Format </xref>
      to establish a pair of Security
      Associations (SA).  The ESP SAs are then used to carry the
      actual payload data between the two hosts, by wrapping TCP, UDP,
      and other upper layer packets into transport mode ESP payloads.
      The IP header uses the actual IP addresses in the network.</t>

      <t>Although HIP may also be specified in the future to operate
      with an alternative to ESP providing the per-packet HIP
      context, the remainder of this document assumes that HIP is
      being used in conjunction with ESP.  Future documents may extend
      this document to include other behaviors when ESP is not used.
      </t>

      <t>The base specification does not contain any mechanisms for
      changing the IP addresses that were used during the base HIP
      exchange.  Hence, in order to remain connected, any systems that
      implement only the base specification and nothing else must
      retain the ability to receive packets at their primary IP
      address; that is, those systems cannot change the IP address
      on which they are using to receive packets without causing loss of 
      connectivity until a base exchange is performed from the 
      new address.</t>

-->

      <section anchor="sec.loc.data.struct.status" title="Locator Data Structure and Status">

	<t>In a typical implementation, each outgoing locator is
        represented by a piece of state that contains the following
        data: 
          <list style="symbols">
	    <t>the actual bit pattern representing the locator,</t>
	    <t>the lifetime (seconds),</t>
	    <t>the status (UNVERIFIED, ACTIVE, DEPRECATED),</t>
	    <t>the Traffic Type scope of the locator, and </t>
	    <t>whether the locator is preferred for any particular scope.</t>
          </list>
	The status is used to track the reachability of the
	address embedded within the LOCATOR parameter:
          <list style="hanging">

	    <t hangText="UNVERIFIED">indicates that the reachability of the
	    address has not been verified yet,</t>

	    <t hangText="ACTIVE">indicates that the reachability of
	    the address has been verified and the address has not been
	    deprecated,</t>

	    <t hangText="DEPRECATED">indicates that the locator
	    lifetime has expired.</t>

	  </list>
        </t>

	<t>The following state changes are allowed:
  	  <list style="hanging">

	    <t hangText="UNVERIFIED to ACTIVE">
              The reachability procedure completes successfully.</t>

	    <t hangText="UNVERIFIED to DEPRECATED">
              The locator lifetime expires while the locator is 
              UNVERIFIED.</t>

	    <t hangText="ACTIVE to DEPRECATED">
              The locator lifetime expires while the locator is 
              ACTIVE.</t>
 
	    <t hangText="ACTIVE to UNVERIFIED">
              There has been no traffic on the address for some time,
              and the local policy mandates that the address
              reachability must be verified again before starting to
              use it again.</t>

	    <t hangText="DEPRECATED to UNVERIFIED">
              The host receives a new lifetime for the locator.</t>
	  </list>

        A DEPRECATED address MUST NOT be changed to ACTIVE without first
        verifying its reachability.  
        </t>
 
        <t> Note that the state of whether or not a locator is preferred
            is not necessarily the same as the value of the
            Preferred bit in the Locator sub-parameter received from 
            the peer.  Peers may recommend certain locators to be
            preferred, but the decision on whether to actually use
            a locator as a preferred locator is a local decision,
            possibly influenced by local policy.</t>

      </section>

      <section anchor="sending-locators" title="Sending LOCATORs">

	<t>The decision of when to send LOCATORs is basically a local policy
	issue.  However, it is RECOMMENDED that a host send a LOCATOR
	whenever it recognizes a change of its IP addresses in use on 
  an active HIP association, and assumes
	that the change is going to last at least for a few seconds.
	Rapidly sending LOCATORs that force the peer to change the preferred
        address SHOULD be avoided.</t>

	<t>When a host decides to inform its peers about changes in its
	IP addresses, it has to decide how to group the various
	addresses with SPIs.  The grouping should consider also whether
        middlebox interaction requires sending the same LOCATOR in
  separate UPDATEs on different paths.  Since each SPI is associated with
	a different Security Association, the grouping policy may also be
	based on ESP anti-replay protection considerations.  In the typical
	case, simply basing the grouping on actual kernel level physical
	and logical interfaces may be the best policy.  Grouping policy
  is outside of the scope of this document.</t>

	<t>Note that the purpose of announcing IP addresses in a LOCATOR
	is to provide connectivity between the communicating hosts.
	In most cases, tunnels or virtual interfaces such
  as IPsec tunnel interfaces or Mobile IP home addresses
	provide sub-optimal connectivity.  Furthermore, it should be
	possible to replace most tunnels with HIP based
	"non-tunneling", therefore making most virtual interfaces
	fairly unnecessary in the future.  Therefore, virtual interfaces
  SHOULD NOT be announced in general.  On the other hand, there
	are clearly situations where tunnels are used for diagnostic
	and/or testing purposes.  In such and other similar cases
	announcing the IP addresses of virtual interfaces may be
	appropriate. </t>  

        <t> Hosts MUST NOT announce broadcast or multicast
        addresses in LOCATORs.  Link-local addresses MAY be announced to 
        peers that are known to be neighbors on the same link, such as 
        when the IP destination address of a peer is also link-local.  
        The announcement of link-local addresses in this case is a 
        policy decision; link-local addresses used as Preferred locators 
        will create reachability problems when the host moves to 
        another link.  In any case, link-local addresses MUST NOT
        be announced to a peer unless that peer is known to be on the same
        link. </t>

	<t>Once the host has decided on the groups and assignment of
	addresses to the SPIs, it creates a LOCATOR parameter that serves
  as a complete representation of the addresses and affiliated SPIs
  intended for active use.
	We now describe a few cases introduced in 
  <xref target="sec.protocol.overview" />.  We assume that the
  Traffic Type for each locator is set to "0" (other values for Traffic
  Type may be specified in documents that separate the HIP control plane from
  data plane traffic).  Other mobility and
  multihoming cases are possible but are left for further experimentation.
	  <list style="numbers">
    <t>Host mobility with no multihoming and no rekeying.  The mobile 
       host creates a single UPDATE containing a single ESP_INFO 
       with a single LOCATOR parameter.  The ESP_INFO contains 
       the current value of the SPI in both the OLD SPI and NEW SPI
       fields.  The LOCATOR contains a single Locator with a
       "Locator Type" of "1"; the SPI must match
       that of the ESP_INFO.  The Preferred bit SHOULD be set and the
       "Locator Lifetime" is set according to local policy.  The
       UPDATE also contains a SEQ parameter as usual.  This packet is
       retransmitted as defined in the HIP protocol specification
       <xref target="RFC5201" />.
       The UPDATE should be sent to the peer's
       preferred IP address with an IP source address corresponding to
       the address in the LOCATOR parameter.</t>

    <t>Host mobility with no multihoming but with rekeying.  The mobile 
       host creates a single UPDATE containing a single ESP_INFO 
       with a single LOCATOR parameter (with a single address).  
       The ESP_INFO contains 
       the current value of the SPI in the OLD SPI and the new
       value of the SPI in the NEW SPI, and a KEYMAT Index 
       as selected by local policy.  Optionally, the host may choose to
       initiate a Diffie Hellman rekey by including a DIFFIE_HELLMAN
       parameter.  The LOCATOR contains a single Locator with
       "Locator Type" of "1"; the SPI must match
       that of the NEW SPI in the ESP_INFO.  Otherwise, the steps
       are identical to the case in which no rekeying is initiated.  </t>

    <t>Host multihoming (addition of an address).  We only describe the
       simple case of adding an additional address to a (previously) 
       single-homed,
       non-mobile host.  The host SHOULD set up a new SA pair between
       this new address and the preferred address of the peer host.
       To do this, the multihomed host creates a new inbound SA and 
       creates a new SPI. For the outgoing UPDATE message, it inserts 
       an ESP_INFO parameter
       with an OLD SPI field of "0", a NEW SPI field 
       corresponding to the new
       SPI, and a KEYMAT Index as selected by local policy.
       The host adds 
       to the UPDATE message a LOCATOR with two Type "1" Locators:  the 
       original address and SPI active on the association, and the
       new address and new SPI being added (with the 
       SPI matching the NEW SPI contained in the ESP_INFO).  The Preferred
       bit SHOULD be set depending on the policy to tell the peer host
       which of the two locators is preferred.  The UPDATE also contains
       a SEQ parameter and optionally a DIFFIE_HELLMAN parameter,
       and follows rekeying procedures with respect to this new address.
       The UPDATE message SHOULD be sent to the peer's Preferred
       address with a source address corresponding to the new locator.
       </t>
    </list>
  </t>

  <t> The sending of multiple LOCATORs, locators with Locator Type "0",
      and multiple ESP_INFO parameters is for further study.  Note
      that the inclusion of LOCATOR in an R1 packet requires the use
      of Type "0" locators since no SAs are set up at that point.</t>
<!--
<t>
If there are multiple LOCATOR parameters,
	the parameters MUST be ordered so that
	the new Preferred locator is in the first LOCATOR parameter.
	Only one locator (the first one, if at all) may be 
	indicated as preferred for each distinct Traffic Type in the LOCATOR parameter. </t>

       <t>If addresses are being added to an existing SPI,
        the LOCATOR parameter includes the full set of valid addresses for that 
        SPI, each using a Locator Type of "1" and each with the
        same value for SPI.  Any
        locators previously ACTIVE on that SPI that are not included
        in the LOCATOR will be set to DEPRECATED by the receiver.
        </t>

	<t> If a mobile host decides to change the SPI upon a readdress,
	it sends a LOCATOR with the SPI field within the LOCATOR set to the
	new SPI, and also an ESP_INFO parameter with the OLD SPI field
	set to the previous SPI and the NEW SPI field set to the new
	SPI.  If multiple LOCATOR and ESP_INFO parameters are included, the
	ESP_INFO MUST be ordered such that they appear in the same order
	as the set of corresponding LOCATORs.  The decision as to whether
	to rekey and send a new Diffie-Hellman parameter while performing
	readdressing is a local policy decision.
	</t>

	<t>If new addresses and new SPIs are being created, the 
	LOCATOR parameter's SPI field contains the new SPI, and the ESP_INFO
	parameter's OLD SPI field and NEW SPI fields are both set
	to the new SPI, indicating that this is a new and not a 
	replacement SPI.</t>

	<t>If there are multiple LOCATOR parameters leading to a packet size
	that exceeds the MTU, HIP fragmentation rules as described in
  <xref target="RFC5201" /> shall apply.
  </t>
-->
<!--
	<t>If there are multiple LOCATOR parameters leading to a packet size
	that exceeds the MTU, the host SHOULD send multiple packets,
	each smaller than the MTU.  In the case of R1 and I2, the
	additional packets should be UPDATE packets that are sent after
	the base exchange has been completed.</t>
-->

      </section>  

      <section anchor="receiving-locators" title="Handling Received LOCATORs"> 

	<t>A host SHOULD be prepared to receive a LOCATOR parameter in 
        the following HIP packets:  R1, I2, UPDATE, and NOTIFY.  </t>

  <t>  This document describes sending both ESP_INFO and LOCATOR parameters
       in an UPDATE.  The ESP_INFO parameter is included when there is a
       need to rekey or key a new SPI, and is otherwise included for the
       possible benefit of HIP-aware middleboxes.  The LOCATOR parameter
       contains a complete map of the locators that the host wishes to
       make or keep active for the HIP association. </t>

	<t> In general, the processing of a LOCATOR depends upon the 
         packet type in which it is included.
         Here, we describe only the case in which ESP_INFO is present and a 
         single LOCATOR and ESP_INFO are sent in an UPDATE message; other
         cases are for further study.  The steps below cover each of the
         cases described in <xref target="sending-locators" />.
         </t>

      <t> The processing of ESP_INFO and LOCATOR parameters is intended to be
          modular and support future generalization to the inclusion of
          multiple ESP_INFO and/or multiple LOCATOR parameters.  A host
          SHOULD first process the ESP_INFO before the LOCATOR, since the
          ESP_INFO may contain a new SPI value mapped to an existing SPI,
          while a Type "1" locator will only contain a reference to the new SPI.
      </t>

	<t> When a host receives a validated HIP UPDATE with a LOCATOR
        and ESP_INFO parameter, it processes the ESP_INFO as follows.
	 The ESP_INFO parameter indicates whether an SA is being
            rekeyed, created, deprecated, or just identified for the
            benefit of middleboxes.  The host examines the  
            OLD SPI and NEW SPI values in the ESP_INFO parameter:</t>

	  <list style="numbers">

         <t> (no rekeying) If the 
             OLD SPI is equal to the NEW SPI and both correspond to an
             existing SPI, the ESP_INFO is gratuitous (provided for 
             middleboxes) and no rekeying is necessary.  </t>
         <t> (rekeying) If the OLD SPI indicates an existing SPI and 
             the NEW SPI is
             a different non-zero value, the existing SA is being rekeyed
             and the host follows HIP ESP rekeying procedures by
             creating a new outbound SA with an SPI corresponding to the
             NEW SPI, with no addresses bound to this SPI.  Note that
             locators in the LOCATOR parameter will reference this 
             new SPI instead of the old SPI.</t>
         <t> (new SA) If the OLD SPI value is zero and the 
             NEW SPI is a new non-zero
             value, then a new SA is being requested by the peer.  This case
             is also treated like a rekeying event; the receiving host
             must create a new SA and respond with an UPDATE ACK. </t>
         <t> (deprecating the SA) 
             If the OLD SPI indicates an existing SPI and the NEW SPI is
             zero, the SA is being deprecated and all locators uniquely
             bound to the SPI are put into the DEPRECATED state. </t>
         </list>
         <t> If none of the above cases apply, a protocol error has 
             occurred and the processing of the UPDATE is stopped.</t>

	    <t>Next, the locators in the LOCATOR parameter are processed.
            For each locator listed in the LOCATOR parameter, check
	    that the address therein is a legal unicast or anycast address.
	    That is, the address MUST NOT be a broadcast or multicast
	    address.  Note that some implementations MAY accept
	    addresses that indicate the local host, since it may be
	    allowed that the host runs HIP with itself.</t>

            <t> The below assumes that all locators are of Type "1" with
            a Traffic Type of "0"; other cases are for further study.</t>

            <t>For each Type "1" address listed in the LOCATOR parameter, 
            the host checks whether the address is already bound 
            to the SPI indicated.  
            If the address is already bound, its lifetime is updated.  If the
            status of the address is DEPRECATED, the status is changed
            to UNVERIFIED.  If the address is not already bound, the address
            is added, and its status is set to UNVERIFIED.
            Mark all addresses corresponding to the SPI that were NOT
            listed in the LOCATOR parameter as DEPRECATED.
            </t>
            <t>
            As a result, at the end of processing, the addresses listed 
            in the LOCATOR parameter have either a state of UNVERIFIED 
            or ACTIVE, and any old addresses on the old SA not listed in the
            LOCATOR parameter have a state of DEPRECATED.</t>


	<t>Once the host has processed the locators, if the LOCATOR
	parameter contains a new Preferred locator, the host SHOULD
	initiate a change of the Preferred locator.  This
	requires that the host first verifies reachability of the associated
	address, and only then changes the Preferred locator; see
        <xref target="sec-change" />.</t>

            <t> If a host receives a locator with an unsupported Locator
            Type, and when such a locator is also declared to be the Preferred
            locator for the peer, the host SHOULD send a NOTIFY error
            with a Notify Message Type of LOCATOR_TYPE_UNSUPPORTED,
            with the Notification Data field containing the locator(s)
            that the receiver failed to process.  Otherwise, a host
            MAY send a NOTIFY error if a (non-preferred) locator with
            an unsupported Locator Type is received in a LOCATOR parameter.
            </t>

      </section>  

      <section anchor="sec-reach" title="Verifying Address Reachability">

	<t>A host MUST verify the reachability of an UNVERIFIED address.  The 
  status of a newly learned address MUST initially be set to UNVERIFIED
  unless the new address is advertised in a R1 packet as a new Preferred
  locator.  A host MAY also want to verify the reachability of an 
  ACTIVE address again after some time, in which case it would set the
  status of the address to UNVERIFIED and reinitiate address verification.
  </t>
  
  <t> 
  A host typically starts the address-verification procedure
	by sending a nonce
	to the new address.  For example, when the host is changing its
	SPI and sending an ESP_INFO to the peer, the NEW SPI value SHOULD
	be random and the value MAY be copied into an ECHO_REQUEST
	sent in the rekeying UPDATE.  However, if the host is not changing
        its SPI, 
	it MAY still use the ECHO_REQUEST parameter in an UPDATE
	message sent to the new address.  A host MAY also use other
	message exchanges as confirmation of the address reachability.
  </t>
  <t>
	Note that in the case of receiving a LOCATOR in an R1 and
	replying with an I2 to the new address in the LOCATOR, receiving 
        the corresponding R2 is
	sufficient proof of reachability for the Responder's preferred
  address.  Since further address verification of such an address can
  impede the HIP-base exchange, a host MUST NOT separately verify 
  reachability
  of a new Preferred locator that was received on an R1. </t>

	<t>In some cases, it MAY be sufficient to use the arrival
	of data on a newly advertised SA as implicit address
	reachability verification as depicted in
        <xref target="activation" />, instead of waiting for the 
	confirmation via a HIP packet. 
	In this case, a host advertising a new SPI as part of its
	address reachability check SHOULD be prepared to receive 
	traffic on the new SA.  </t>

	<figure anchor="activation" title="Address Activation Via Use of a New SA">
	  <artwork>
  Mobile host                                   Peer host

                                                prepare incoming SA
                   NEW SPI in ESP_INFO (UPDATE)
             &lt;-----------------------------------
switch to new outgoing SA
                        data on new SA
             -----------------------------------&gt;
                                                mark address ACTIVE
	  </artwork>
	</figure>

<t>
When address verification is in progress for a new Preferred locator,
the host SHOULD select a different locator listed as ACTIVE, if one such
locator is available, to continue communications until address
verification completes.  Alternatively, the host MAY use the new
Preferred locator while in UNVERIFIED status to the extent Credit-Based
Authorization permits.  Credit-Based Authorization is explained in
<xref target="anchor.CBA.proc" />.
Once address verification succeeds, the status of the new
Preferred locator changes to ACTIVE.
</t>

      </section>

      <section anchor="sec-change" title="Changing the Preferred Locator">

	<t>A host MAY want to change the Preferred outgoing locator
	for different reasons, e.g., because traffic information or ICMP
	error messages indicate that the currently used preferred
	address may have become unreachable.  Another reason may be due to 
	receiving a LOCATOR parameter that has the "P" bit set.</t>

	<t>To change the Preferred locator, the host initiates the
	following procedure:

	  <list style="numbers">

	    <t>If the new Preferred locator has ACTIVE status, the
	    Preferred locator is changed and the procedure succeeds.</t>

      <t>If the new Preferred locator has UNVERIFIED status, the host
        starts to verify its reachability.  The host SHOULD use a
        different locator listed as ACTIVE until address verification
        completes if one such locator is available.  Alternatively, the
        host MAY use the new Preferred locator, even though in UNVERIFIED
        status, to the extent Credit-Based Authorization permits.  Once
        address verification succeeds, the status of the new Preferred
        locator changes to ACTIVE and its use is no longer governed by
        Credit-Based Authorization. </t>
<!--
	    <t>If the new Preferred locator has UNVERIFIED status, the
	    host starts to verify its reachability.  Once the
	    verification has succeeded, the Preferred locator change
	    is completed, unless a new change has been initiated in
	    the meantime.</t>
-->

	    <t>If the peer host has not indicated a preference for any
	    address, then the host picks one of the peer's ACTIVE 
	    addresses randomly or according to policy.  This case may
	    arise if, for example, ICMP error messages that deprecate
	    the Preferred locator arrive, but the peer has not yet indicated
	    a new Preferred locator. </t>

<!--
	    <t>If the new Preferred locator has DEPRECATED status and
	    there is at least one non-deprecated address, the host
	    selects one of the non-deprecated addresses as a new
	    Preferred locator and continues.</t>
-->
      <t>  If the new Preferred locator has DEPRECATED status and there is
        at least one non-deprecated address, the host selects one of the
        non-deprecated addresses as a new Preferred locator and
        continues.  If the selected address is UNVERIFIED, the address
verification procedure described above will apply.
      </t>

	  </list>
	</t>

      </section>

      <section anchor="anchor.CBA.proc" title="Credit-Based Authorization">

      <t> To prevent redirection-based flooding attacks, the use of
         a Credit-Based Authorization (CBA) approach is mandatory when a host
         sends data to an UNVERIFIED locator.  The following algorithm meets
         the security considerations for prevention of amplification and
         time-shifting attacks.  Other forms of credit aging, and other values
         for the CreditAgingFactor and CreditAgingInterval parameters in
         particular, are for further study, and so are the advanced CBA
         techniques specified in 
         <xref target="CBA-MIPv6" />.</t>

        <section anchor="sec-handling" title="Handling Payload Packets">

      <t> A host maintains a "credit counter" for each of its peers.  
      Whenever a packet arrives from a peer, the host SHOULD increase that 
      peer's credit counter by the size of the received packet.  When the 
      host has a packet to be sent to the peer, and when the peer's Preferred 
      locator is listed as UNVERIFIED and no alternative locator with status 
      ACTIVE is available, the host checks whether it can send the packet 
      to the UNVERIFIED locator.  The packet SHOULD be sent if the value 
      of the credit counter is higher than the size of the outbound 
      packet.  If the credit counter is too low, the packet MUST be 
      discarded or buffered until address verification succeeds. When a 
      packet is sent to a peer at an UNVERIFIED locator, the peer's credit 
      counter MUST be reduced by the size of the packet.  The peer's 
      credit counter is not affected by packets that the host sends to an 
      ACTIVE locator of that peer.</t>

      <t> <xref target="figure-receiving-packets-with-cba"/> depicts the 
      actions taken by the host when a packet is received.  
      <xref target="figure-sending-packets-with-cba"/> shows the decision 
      chain in the event a packet is sent.</t>

      <figure title="Receiving Packets with Credit-Based Authorization"
      anchor="figure-receiving-packets-with-cba">
      <artwork><![CDATA[
    Inbound
    packet
       |
       |       +----------------+               +---------------+
       |       |    Increase    |               |    Deliver    |
       +-----> | credit counter |-------------> |   packet to   |
               | by packet size |               |  application  |
               +----------------+               +---------------+
      ]]></artwork>
      </figure>
      <vspace blankLines="1"/> <!-- not sure this is needed -->

      <figure title="Sending Packets with Credit-Based Authorization"
      anchor="figure-sending-packets-with-cba">
      <artwork><![CDATA[
 Outbound
  packet
     |          _________________ 
     |         /                 \                 +---------------+
     |        /  Is the preferred \       No       |  Send packet  |
     +-----> | destination address |-------------> |  to preferred |
              \    UNVERIFIED?    /                |    address    |
               \_________________/                 +---------------+ 
                        |
                        | Yes
                        |
                        v
                _________________  
               /                 \                 +---------------+
              /   Does an ACTIVE  \      Yes       |  Send packet  |
             | destination address |-------------> |   to ACTIVE   |
              \       exist?      /                |    address    |
               \_________________/                 +---------------+
                        |
                        | No
                        |
                        v
                _________________
               /                 \                 +---------------+
              /   Credit counter  \       No       |               |
             |          >=         |-------------> |  Drop packet  |
              \    packet size?   /                |               |
               \_________________/                 +---------------+ 
                        |
                        | Yes
                        |
                        v
                +---------------+                  +---------------+
                | Reduce credit |                  |  Send packet  |
                |  counter by   |----------------> | to preferred  |
                |  packet size  |                  |    address    |
                +---------------+                  +---------------+
      ]]></artwork>
      </figure>
      <vspace blankLines="1"/> <!-- not sure this is needed -->

      </section>

      <section anchor="sec-credit-aging" title="Credit Aging">

      <t> A host ensures that the credit counters it maintains for its peers 
      gradually decrease over time.  Such "credit aging" prevents a 
      malicious peer from building up credit at a very slow speed and using 
      this, all at once, for a severe burst of redirected packets.</t>

      <t> Credit aging may be implemented by multiplying credit counters 
      with a factor, CreditAgingFactor (a fractional value less than one),
      in fixed time intervals 
      of CreditAgingInterval length.  Choosing appropriate values for 
      CreditAgingFactor and CreditAgingInterval is important to ensure that 
      a host can send packets to an address in state UNVERIFIED even when 
      the peer sends at a lower rate than the host itself.  When 
      CreditAgingFactor or CreditAgingInterval are too small, the peer's 
      credit counter might be too low to continue sending packets until 
      address verification concludes.</t>

      <t>The parameter values proposed in this document are as follows:</t>

      <figure>
      <artwork><![CDATA[
   CreditAgingFactor        7/8
   CreditAgingInterval      5 seconds
      ]]></artwork>
      </figure>
      <vspace blankLines="1"/> <!-- not sure this is needed -->

      <t> These parameter values work well when the host transfers a file to 
      the peer via a TCP connection and the end-to-end round-trip time does 
      not exceed 500 milliseconds.  Alternative credit-aging algorithms may 
      use other parameter values or different parameters, which may even be 
      dynamically established.</t>

        </section>

      </section>


<!--

OLD Section 5.2

      <section title="Address verification">

	<t>When a HIP host receives a set of locators from
        another HIP host in a LOCATOR, it does not necessarily know
        whether the other host is actually reachable at the claimed
        addresses.  In fact, a malicious peer host may be
        intentionally giving bogus addresses in order to cause a
        packet flood towards the target addresses <xref
        target="RFC4225" />.  Likewise, viral
        software may have compromised the peer host, programming it
        to redirect packets to the target addresses.  Thus, the HIP host
        must first check that
        the peer is reachable at the new address.</t>

        <t>A simple technique to verify addresses is to send an UPDATE
        to the host at the new address.  The UPDATE packet SHOULD 
        include a nonce, unguessable by anyone not on the path to
	the new address, that forces the host to reply
        in a manner that confirms reception of the nonce.  One direct
        way to perform this is to include an ECHO_REQUEST parameter
	with some piece of unguessable information such as a random
	number.  If the host is sending an ESP_INFO  parameter, the ECHO_REQUEST
	MAY contain the new SPI, for example.    If the peer host 
	is rekeying by sending an UPDATE with ESP_INFO to the new address,
	the arrival of data on the new SPI can also be used to verify
	the address.</t>
	
	<t>If middlebox traversal is
        possible along the path, and the peer host is not rekeying, 
	the peer host SHOULD include a SPI parameter as part of its 
	UPDATE, with the SPI corresponding to its active inbound SPI.
	It is not specified how a host knows whether or not middleboxes
	might lie on its path, so a conservative assumption may
	be to always include the SPI parameter.
	</t>

        <t> To prevent redirection-based flooding attacks, the easiest 
        way would be to disable a new locator until it has been verified.  
        This could proceed unnoticed when there is a second locator that 
        can be used in the meantime.  However, many situations are 
        conceivable in which a new locator becomes known only when the 
        previous one is no longer operational.  Address verification would 
        increase signaling delays by one round-trip time in such cases 
        since it is by definition an end-to-end procedure.  To avoid this 
        additional delay, a host starts using a new address immediately 
        after the locator update and verifies the peer's reachability at 
        that address concurrently.  The host applies Credit-Based 
        Authorization to protect against illegitimate packet redirection 
        until the validity of the address has been established.  
        Credit-Based Authorization is described in 
        <xref target="anchor.CBA" /> and specified in 
        <xref target="anchor.CBA.proc" />.
        </t> 


      </section>
-->



    </section>

    <section title="Security Considerations">

       <t>
       The HIP mobility mechanism provides a secure means of updating a host's 
       IP address via HIP UPDATE packets. Upon receipt, a HIP host 
       cryptographically verifies the sender of an UPDATE, so forging or 
       replaying a HIP UPDATE packet is very difficult 
       (see <xref target="RFC5201" />).
       Therefore, security issues reside in other attack domains.  The two we 
       consider are malicious redirection of legitimate connections as well as 
       redirection-based flooding attacks using this protocol.  This can be 
       broken down into the following:
       <list style="hanging">
       <t> Impersonation attacks </t>
          <list style="hanging">
          <t> - direct conversation with the misled victim </t>
          <t> - man-in-the-middle attack </t>
          </list>
       <t> DoS attacks </t>
          <list style="hanging">
          <t> - flooding attacks (== bandwidth-exhaustion attacks) </t>
            <list style="hanging">
            <t> * tool 1: direct flooding </t>
            <t> * tool 2: flooding by zombies </t>
            <t> * tool 3: redirection-based flooding </t>
            </list>
          <t> - memory-exhaustion attacks </t>
          <t> - computational-exhaustion attacks </t>
          </list>
        </list>
       We consider these in more detail in the following sections.
       </t>
       
       <t>
       In <xref target="sec.impersonate" /> and <xref target="sec.denial" />, 
       we assume that all users are using HIP.  
       In <xref target="sec.mixed" /> we consider the security 
       ramifications when we have both HIP and non-HIP users.
       Security considerations for Credit-Based Authorization are discussed
       in <xref target="SIMPLE-CBA" />.
       </t>
       
      <section anchor="sec.impersonate" title="Impersonation Attacks">

       <t>
       An attacker wishing to impersonate another host will try to mislead its victim 
<!-- [rfced] Wishing to impersonate what?  --> 
       into directly communicating with them, or carry out a
       man-in-the-middle (MitM) attack between the victim and the victim's desired  
       communication peer.  Without mobility support, both attack types 
       are possible only if the attacker resides on the routing path 
       between its victim and the victim's desired communication peer, or 
       if the attacker tricks its victim into initiating the connection over 
       an incorrect routing path (e.g., by acting as a router or using 
       spoofed DNS entries).
       </t>
       
       <t>
       The HIP extensions defined in this specification change the 
       situation in that they introduce an ability to redirect a 
       connection (like IPv6), both before and after establishment.  If no 
       precautionary measures are taken, an attacker could misuse the
       redirection 
       feature to impersonate a victim's peer from any arbitrary location.  
       The authentication and authorization mechanisms of the HIP base 
       exchange <xref target="RFC5201" /> and the signatures 
       in the  
       UPDATE message prevent this attack.  Furthermore, ownership of a 
       HIP association is securely linked to a HIP HI/HIT.  If an attacker 
       somehow uses a bug in the implementation or weakness in some protocol 
       to redirect a HIP connection, the original owner can always 
       reclaim their connection (they can always prove ownership of the 
       private key associated with their public HI).
       </t>

       <t>
       MitM attacks are always possible if the attacker is present 
       during the initial HIP base exchange and if the hosts do not 
       authenticate each other's identities.  However, once the opportunistic
       base exchange 
       has taken place, even a MitM cannot steal the HIP connection anymore
       because 
       it is very difficult for an attacker to create an UPDATE 
       packet (or any HIP packet) that will be accepted as a legitimate 
       update. UPDATE packets use HMAC and are signed.  Even when an 
       attacker can snoop packets to obtain the SPI and HIT/HI, they still 
       cannot forge an UPDATE packet without knowledge of the secret keys.
       </t>

      </section>

      <section anchor="sec.denial" title="Denial-of-Service Attacks">

        <section anchor="sec.flooding" title="Flooding Attacks">

         <t>
         The purpose of a denial-of-service attack is to exhaust some 
         resource of the victim such that the victim ceases to operate 
         correctly.  A denial-of-service attack can aim at the victim's  
         network attachment (flooding attack), its memory, or its processing 
         capacity.  In a flooding attack, the attacker causes an excessive 
         number of bogus or unwanted packets to be sent to the victim, 
         which fills their available bandwidth.  Note that the victim does 
         not necessarily need to be a node; it can also be an entire 
         network.  The attack basically functions the same way in either case.
         </t>
          
         <t>
         An effective DoS strategy is distributed denial of service 
         (DDoS).  Here, the attacker conventionally distributes some viral 
         software to as many nodes as possible.  Under the control of the 
         attacker, the infected nodes, or "zombies", jointly send packets 
         to the victim.  With such an 'army', an attacker can take down 
         even very high bandwidth networks/victims.
         </t>
         
         <t>
         With the ability to redirect connections, an attacker could 
         realize a DDoS attack without having to distribute viral code.  
         Here, the attacker initiates a large download from a server, and 
         subsequently redirects this download to its victim.  The attacker 
         can repeat this with multiple servers.  This threat is mitigated 
         through reachability checks and credit-based authorization.  
         Both strategies do not eliminate flooding attacks per se, but 
         they preclude: (i) their use from a location off the path 
         towards the flooded victim; and (ii) any amplification in the 
         number and size of the redirected packets.  As a result, the 
         combination of a reachability check and credit-based authorization 
         lowers a HIP redirection-based flooding attack to the level of
         a direct flooding attack in which the 
         attacker itself sends the flooding traffic to the victim.
         </t>
          
<!--
         <t>
         This analysis leads to the following two points.  First, when 
         a reachability packet with nonce is received, the packet MUST be 
         ignored if the HIT is not one that is currently active for
         the association.  
         Second, if the attacker is a MitM and can capture this nonce 
         packet then it can respond to it, in which case it is possible 
         for an attacker to redirect the connection.  Note, this attack 
         will always be possible when a reachability packet is not sent.
         </t>
-->

        </section>

        <section anchor="sec.memory" title="Memory/Computational-Exhaustion DoS Attacks">
  
         <t>
         We now consider whether or not the proposed extensions to HIP add 
         any new DoS attacks (consideration of DoS attacks using the base 
         HIP exchange and updates is discussed in 
         <xref target="RFC5201" />).  A simple attack is 
         to send many UPDATE packets containing many IP addresses that 
         are not flagged as preferred.  The attacker continues to send such 
         packets until the number of IP addresses associated with the 
         attacker's HI crashes the system.  Therefore, there SHOULD be a limit  
         to the number of IP addresses that can be associated with any HI.  
         Other forms of memory/computationally exhausting attacks via the HIP 
         UPDATE packet are handled in the base HIP document
         <xref target="RFC5201" />. 
         </t>

         <t>
         A central server that has to deal with a large number of mobile
         clients may consider increasing the SA lifetimes to try to slow
         down the rate of rekeying UPDATEs or increasing the cookie
         difficulty to slow down the rate of attack-oriented connections.
         </t>

        </section>

       </section>

       <section anchor="sec.mixed" title="Mixed Deployment Environment">

        <t>
         We now assume an environment with both HIP and non-HIP aware hosts.  
         Four cases exist. 
	  <list style="numbers">
           <t> A HIP host redirects its connection onto a non-HIP host.  
               The non-HIP host will drop the reachability packet, so this 
               is not a threat unless the HIP host is a MitM that could
               somehow respond successfully to the reachability check.
           </t>
           <t> A non-HIP host attempts to redirect their connection onto 
               a HIP host.  This falls into IPv4 and IPv6 security 
               concerns, which are outside the scope of this document.
           </t>
           <t>
               A non-HIP host attempts to steal a HIP host's session  
               (assume that Secure Neighbor Discovery is not active for the 
               following).  The 
               non-HIP host contacts the service that a HIP host has a 
               connection with and then attempts to change its IP 
               address to steal the HIP host's connection.  What 
               will happen in this case is implementation dependent but 
               such a request should fail by being ignored or dropped.  
               Even if the 
               attack were successful, the HIP host could reclaim its 
               connection via HIP.
           </t>
           <t> A HIP host attempts to steal a non-HIP host's session.  
               A HIP host could spoof the non-HIP host's IP address 
               during the base exchange or set the non-HIP host's IP address 
               as its preferred address via an UPDATE.  Other 
               possibilities exist, but a simple solution is to prevent the
               use of HIP address check information to influence non-HIP
               sessions.
           </t>
         </list>
        </t>
       
        </section>

     </section>

     <section title="IANA Considerations">
   <t>
   This document defines a LOCATOR parameter for the Host Identity
   Protocol <xref target="RFC5201" />.  This parameter 
   is defined in <xref target="sec-locator-format" /> with a Type of 193.
   </t>

   <t>
   This document also defines a LOCATOR_TYPE_UNSUPPORTED Notify Message
   Type as defined in the Host Identity Protocol specification
   <xref target="RFC5201" />.  This parameter 
   is defined in <xref target="receiving-locators" /> with a value of 46.
   </t>

     </section>


     <section title="Authors and Acknowledgments">
     <t>
     Pekka Nikander and Jari Arkko originated this document, and Christian
     Vogt and Thomas Henderson (editor) later joined as co-authors. Greg Perkins
     contributed the initial draft of the security section.  Petri Jokela
     was a co-author of the initial individual submission.
     </t>
     <t>
     The authors thank Miika Komu, Mika Kousa, Jeff Ahrenholz, and
     Jan Melen for many improvements to the document.
     </t>     
     </section>

    </middle>
    <back>

     <references title="Normative references">

      &RFC4423; 

<reference anchor='RFC5201'>
<front>
<title>Host Identity Protocol</title>

<author initials='R' surname='Moskowitz' fullname='Robert Moskowitz'>
    <organization />
</author>

<author initials='P' surname='Nikander' fullname='Pekka Nikander'>
    <organization />
</author>

<author initials='P' surname='Jokela' fullname='Petri Jokela' role='editor'>
    <organization />
</author>

<author initials='T' surname='Henderson' fullname='Tom  Henderson'>
    <organization />
</author>

<date month='March' year='2008' />

<abstract><t>This memo specifies the details of the Host Identity
Protocol (HIP). HIP allows consenting hosts to securely establish and
maintain shared IP-layer state, allowing separation of the identifier
and locator roles of IP addresses, thereby enabling continuity of
communications across IP address changes. HIP is based on a
Sigma-compliant Diffie- Hellman key exchange, using public key
identifiers from a new Host Identity name space for mutual peer
authentication. The protocol is designed to be resistant to
Denial-of-Service (DoS) and Man-in-the- middle (MitM) attacks, and
when used together with another suitable security protocol, such as
Encapsulated Security Payload (ESP), it provides integrity protection
and optional encryption for upper layer protocols, such as TCP and
UDP.</t></abstract> 

</front>

<seriesInfo name='RFC' value='5201' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-hip-base-10.txt' />
</reference>

<reference anchor='RFC5204'>
<front>
<title>Host Identity Protocol (HIP) Rendezvous Extension</title>

<author initials='J' surname='Laganier' fullname='Julien Laganier'>
    <organization />
</author>

<author initials='L' surname='Eggert' fullname='Lars  Eggert'>
    <organization />
</author>

<date month='March' year='2008' />

<abstract><t>This document defines a rendezvous extension for the Host
Identity Protocol (HIP). The rendezvous extension extends HIP and the
HIP registration extension for initiating communication between HIP
nodes via HIP rendezvous servers. Rendezvous servers improve
reachability and operation when HIP nodes are multihomed or mobile.</t></abstract>

</front>

<seriesInfo name='RFC' value='5204' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-hip-rvs-05.txt' />
</reference>

      &RFC4303; 
      &RFC3484; 

<reference anchor='RFC5202'>
<front>
<title>Using the ESP Transport Format with the Host Identity Protocol (HIP)</title>

<author initials='P' surname='Jokela' fullname='Petri Jokela'>
    <organization />
</author>

<author initials='R' surname='Moskowitz' fullname='R. Moskowitz'>
    <organization />
</author>
<author initials='P' surname='Nikander' fullname='P. Nikander'>
    <organization />
</author>

<date month='March' year='2008' />

<abstract><t>This memo specifies an Encapsulated Security Payload
(ESP) based mechanism for transmission of user data packets, to be
used with the Host Identity Protocol (HIP).</t></abstract>

</front>

<seriesInfo name='RFC' value='5202' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-hip-esp-06.txt' />
</reference>

      &RFC2119; 
      &RFC4291; 
     </references>
     <references title="Informative references">

<!--
      <reference anchor="bellovin-hostnat">
       <front>
	<title>EIDs, IPsec, and HostNAT</title>
	<author initials="S" surname="Bellovin" fullname="Steven Bellovin">
	 <organization />
	</author>
	<date month="March" year="1998" />
       </front>
       <seriesInfo name="IETF" value="41th" />
       <format type="pdf"
	       target="http://www.research.att.com/~smb/talks/hostnat.pdf" />
       <format type="ps"
	       target="http://www.research.att.com/~smb/talks/hostnat.ps" />
      </reference>

       &RFC3552; 
-->
       &RFC4225;

<reference anchor='CBA-MIPv6'>
<front>
<title>Credit-Based Authorization for Mobile IPv6 Early Binding
Updates</title>

<author initials='C' surname='Vogt' fullname='Christian  Vogt'>
    <organization />
</author>

<author initials='J' surname='Arkko' fullname='Jari Arkko'>
    <organization />
</author>

<date month='February' year='2005' />

<abstract><t>The latency associated with Mobile IPv6's Return
Routability test can have an adverse impact on delay-sensitive
applications. Early Binding Updates mitigate this issue by already
using a new care-of address in parallel with testing it. We propose
and analyze a credit-based mechanism that prevents misuse of Early
Binding Updates for amplified flooding attacks and discourages such
misuse for non-amplified flooding attacks.</t></abstract>

</front>

<seriesInfo name='Work' value='in Progress' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-vogt-mobopts-credit-based-authorization-00.txt' />
</reference>

<reference anchor='SIMPLE-CBA'>
<front>
<title>Credit-Based Authorization for Concurrent Reachability
Verification</title>

<author initials='C' surname='Vogt' fullname='Christian Vogt'>
    <organization />
</author>

<author initials='J' surname='Arkko' fullname='Jari Arkko'>
    <organization />
</author>

<date month='February' year='2006' />

<abstract><t>Mobility and multi-homing protocols enable
multi-addressed nodes to redirect ongoing communication sessions from
one IP address to another. Most of these protocols verify a
multi-addressed node's reachability at a claimed new IP address in
order to prevent redirection-based flooding attacks. In view of
reduced protocol latencies, such verification is preferably performed
concurrently, i.e., while packets are already being sent to the new IP
address. This document defines Credit-Based Authorization, a technique
that facilitates concurrent reachability verification without
compromise of security.</t></abstract> 

</front>

<seriesInfo name='Work in' value='Progress' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-vogt-mobopts-simple-cba-00.txt' />
</reference>

     </references>

  </back>
</rfc>
