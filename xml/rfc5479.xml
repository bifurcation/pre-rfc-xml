<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3261 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml">
<!ENTITY RFC3262 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3262.xml">
<!ENTITY RFC3264 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3264.xml">
<!ENTITY RFC3711 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3711.xml">
<!ENTITY RFC5027 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5027.xml">
<!ENTITY RFC3550 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3550.xml">
<!ENTITY RFC3372 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3372.xml">
<!ENTITY RFC4474 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4474.xml">
<!ENTITY rfc4568 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4568.xml">
<!ENTITY rfc4650 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4650.xml">
<!ENTITY rfc4738 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4738.xml">
<!ENTITY RFC3326 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3326.xml">
<!ENTITY rfc3830 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3830.xml">
<!ENTITY rfc4492 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4492.xml">
<!ENTITY rfc4916 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4916.xml">
<!ENTITY RFC5197 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5197.xml">
<!ENTITY rfc4771 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4771.xml">
]>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc strict="yes" ?>
<?rfc rfcedstyle="yes" ?>
<?rfc subcompact="no" ?>

<rfc number="5479" category="info" >
  <front>
    <title abbrev="Media Security Requirements">Requirements and Analysis of
    Media Security Management Protocols</title>

    <author fullname="Dan Wing" initials="D." role="editor" surname="Wing">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>170 West Tasman Drive</street>

          <city>San Jose</city>

          <region>CA</region>

          <code>95134</code>

          <country>USA</country>
        </postal>

        <email>dwing@cisco.com</email>
      </address>
    </author>

    <author fullname="Steffen Fries" initials="S." surname="Fries">
      <organization>Siemens AG</organization>

      <address>
        <postal>
          <street>Otto-Hahn-Ring 6</street>

          <city>Munich</city>

          <region>Bavaria</region>

          <code>81739</code>

          <country>Germany</country>
        </postal>

        <email>steffen.fries@siemens.com</email>
      </address>
    </author>

    <author fullname="Hannes Tschofenig" initials="H" surname="Tschofenig">
      <organization>Nokia Siemens Networks</organization>

      <address>
        <postal>
          <street>Linnoitustie 6</street>

          <city>Espoo</city>

          <region></region>

          <code>02600</code>

          <country>Finland</country>
        </postal>
        <phone>+358 (50) 4871445</phone>
        <email>Hannes.Tschofenig@nsn.com</email>

        <uri>http://www.tschofenig.priv.at</uri>
      </address>
    </author>

    <author fullname="Francois Audet" initials="F." surname="Audet">
      <organization>Nortel</organization>

      <address>
        <postal>
          <street>4655 Great America Parkway</street>

          <city>Santa Clara</city>

          <region>CA</region>

          <code>95054</code>

          <country>USA</country>
        </postal>

        <email>audet@nortel.com</email>
      </address>
    </author>

    <date  month="March" year="2009" />

    <area>RAI</area>

    <workgroup>SIP Working Group</workgroup>

    <keyword>keying</keyword>

    <keyword>Secure RTP</keyword>

    <keyword>SRTP</keyword>

    <abstract>
      <t>This document describes requirements for a protocol to negotiate a
      security context for SIP-signaled Secure RTP (SRTP) media. In addition to the natural
      security requirements, this negotiation protocol must interoperate well
      with SIP in certain ways. A number of proposals have been published and
      a summary of these proposals is in the appendix of this document.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>The work on media security started when the Session Initiation
      Protocol (SIP) was still in its infancy. With the increased SIP
      deployment and the availability of new SIP extensions and related
      protocols, the need for end-to-end security was re-evaluated. The
      procedure of re-evaluating prior protocol work and design decisions is
      not an uncommon strategy and, to some extent, considered necessary to
      ensure that the developed protocols indeed meet the previously
      envisioned needs for the users on the Internet.</t>

      <t>This document summarizes media security requirements, i.e.,
      requirements for mechanisms that negotiate security context such as
      cryptographic keys and parameters for SRTP.</t>

      <t>The organization of this document is as follows: <xref
      target="terminology"></xref> introduces terminology, <xref
      target="attack_scenarios"></xref> describes various attack scenarios
      against the signaling path and media path, <xref
      target="scenarios"></xref> provides an overview about possible call
      scenarios, and <xref target="requirements"></xref> lists requirements for
      media security. The main part of the document concludes with the
      security considerations <xref target="security"></xref>, and acknowledgements
      in <xref target="acks"></xref>. <xref
      target="comparison"></xref> lists and compares available solution
      proposals. The following <xref target="eval-sip"></xref> compares the
      different approaches regarding their suitability for the SIP signaling
      scenarios described in <xref target="comparison"></xref>, while <xref
      target="eval-sec"></xref> provides a comparison regarding security
      aspects. <xref target="ofs"></xref> lists non-goals for this
      document.</t>
    </section>

    <section anchor="terminology" title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref>, with the important qualification that, unless
      otherwise stated, these terms apply to the design of the media security
      key management protocol, not its implementation or application.</t>

      <t> Furthermore, the terminology described in SIP 
	  <xref target="RFC3261"></xref> regarding functions and components 
	  are used throughout the document </t>
	  
      <t>Additionally, the following items are used in this document:</t>

      <t><list style="hanging">
          <t hangText="AOR (Address-of-Record): ">A SIP or SIPS URI that
          points to a domain with a location service that can map the URI to
          another URI where the user might be available. Typically, the
          location service is populated through registrations. An AOR is
          frequently thought of as the "public address" of the user.</t>

          <t hangText="SSRC:">The 32-bit value that defines the
          synchronization source, used in RTP. These are generally unique, but
          collisions can occur.</t>

          <t hangText="two-time pad:">The use of the same key and the same
          keystream to encrypt different data. For SRTP, a two-time pad occurs
          if two senders are using the same key and the same RTP SSRC
          value.</t>

          <t hangText="Perfect Forward Secrecy (PFS):">The property that
          disclosure of the long-term secret keying material that is used to
          derive an agreed ephemeral key does not compromise the secrecy of
          agreed keys from earlier runs.</t>

          <t hangText="active adversary:">An active adversary is able to alter
          data communication to affect its operation (see also <xref
          target="RFC4949"></xref>).</t>

          <t hangText="passive adversary:">A passive adversary is able to
          learn information from data communication, but not alter that data
          communication (see also <xref target="RFC4949"></xref>).</t>

          <t hangText="signaling path:">The signaling path is the route taken
          by SIP signaling messages transmitted between the calling and called
          user agents. This can be either direct signaling between the calling
          and called user agents or, more commonly, involves the SIP proxy
          servers that were involved in the call setup.</t>

          <t hangText="media path:">The media path is the route taken by media
          packets exchanged by the endpoints. In the simplest case, the
          endpoints exchange media directly, and the &ldquo;media path&rdquo;
          is defined by a quartet of IP addresses and TCP/UDP ports, along
          with an IP route. In other cases, this path may include RTP relays,
          mixers, transcoders, session border controllers, NATs, or media
          gateways.</t>
        </list></t>
		
      <t>Moreover, as this document discusses requirements for media security, 
	     the nomenclature R-XXX is used to mark requirements, where XXX is the 
		 requirement, which needs to be met.</t>
    </section>

    <section anchor="attack_scenarios" title="Attack Scenarios">
      <t>The discussion in this section relates to requirements R-ASSOC (specified in <xref target="req_key_mgmt"/>) R-PASS-MEDIA,
      R-PASS-SIG, R-SIG-MEDIA, R-ACT-ACT, and R-ID-BINDING (specified in <xref target="req_attack_scenario" />).</t>

      <t>This document classifies adversaries according to their access and
      their capabilities. An adversary might have access:<list style="numbers">
          <t hangText="(1)">only to the media path,</t>

          <t hangText="(2)">only to the signaling path,</t>

          <t hangText="(3)">to the media path and to the signaling path.</t>
        </list></t>

      <t>An attacker that can solely be located along the signaling path, and
      does not have access to media (item 2), is not considered in this
      document.</t>

      <t>There are two different types of adversaries: active and passive. An
      active adversary may need to be active with regard to the key exchange
      relevant information traveling along the media path or traveling along
      the signaling path.</t>

      <t>Based on their robustness against the adversary capabilities
      described above, we can group security mechanisms using the following
      labels. This list is generally ordered from easiest to compromise (at
      the top) to more difficult to compromise:</t>

      <texttable>
        <ttcol align="center">SIP signaling</ttcol>

        <ttcol align="center">media</ttcol>

        <ttcol align="center">abbreviation</ttcol>

        <c>none</c>

        <c>passive</c>

        <c>no-signaling-passive-media</c>

        <c>none</c>

        <c>active</c>

        <c>no-signaling-active-media</c>

        <c>passive</c>

        <c>passive</c>

        <c>passive-signaling-passive-media</c>

        <c>passive</c>

        <c>active</c>

        <c>passive-signaling-active-media</c>

        <c>active</c>

        <c>passive</c>

        <c>active-signaling-passive-media</c>

        <c>active</c>

        <c>active</c>

        <c>active-signaling-active-media</c>

        <c>active</c>

        <c>active</c>

        <c>active-signaling-active-media-detect</c>
      </texttable>

      <t><list style="hanging">
          <t hangText="no-signaling-passive-media:"><vspace blankLines="0" />
          Access only to the media path is sufficient to reveal the content of
          the media traffic.</t>

          <t hangText="passive-signaling-passive-media:"><vspace
          blankLines="0" />Passive attack on the signaling and passive attack
          on the media path is necessary to reveal the content of the media
          traffic.</t>

          <t hangText="passive-signaling-active-media:"><vspace
          blankLines="0" /> Passive attack on the signaling and active attack
          on the media path is necessary to reveal the content of the media
          traffic.</t>

          <t hangText="active-signaling-passive-media:"><vspace
          blankLines="0" />Active attack on the signaling path and passive
          attack on the media path is necessary to reveal the content of the
          media traffic.</t>

          <t hangText="no-signaling-active-media:"><vspace
          blankLines="0" />Active attack on the media path is sufficient to
          reveal the content of the media traffic.</t>

          <t hangText="active-signaling-active-media:"><vspace
          blankLines="0" />Active attack on both the signaling path and the
          media path is necessary to reveal the content of the media
          traffic.</t>

          <t hangText="active-signaling-active-media-detect:"><vspace
          blankLines="0" />Active attack on both signaling and media path is
          necessary to reveal the content of the media traffic (as with
          active-signaling-active-media), and the attack is detectable by
          protocol messages exchanged between the endpoints.</t>
        </list></t>

      <t>For example, unencrypted RTP is vulnerable to
      no-signaling-passive-media.</t>

      <t>As another example, <xref target="RFC4568">SDP Security
      Descriptions</xref>, when protected by TLS (as it is commonly
      implemented and deployed), belong in the passive-signaling-passive-media category since the adversary
      needs to learn the SDP Security Descriptions key by seeing the SIP
      signaling message at a SIP proxy (assuming that the adversary is
      in control of the SIP proxy). The media traffic can be decrypted
      using that learned key.</t>

      <t>  As another example, DTLS-SRTP (Datagram Transport Layer Security
  Extension for SRTP) falls into active-signaling-active-media category
  when DTLS-SRTP is used with a public-key-based ciphersuite with self-
  signed certificates and without SIP Identity <xref target="RFC4474"/>.  An adversary
  would have to modify the fingerprint that is sent along the signaling
  path and subsequently to modify the certificates carried in the DTLS
  handshake that travel along the media path.  If DTLS-SRTP is used
  with both SIP Identity <xref target="RFC4474"/> and SIP Connected Identity
  <xref target="RFC4916" />, the RFC-4474 signature protects both the offer and the
  answer, and such a system would then belong to the active-signaling-
  active-media-detect category (provided, of course, the signaling
  path to the RFC-4474 authenticator and verifier is secured as per RFC
  4474, and the RFC-4474 authenticator and verifier are behaving as per
  RFC 4474).</t>

      <t>The above discussion of DTLS-SRTP demonstrates how a single security
      protocol can be in different classes depending on the mode in which it
      is operated. Other protocols can achieve a similar effect by adding
      functions outside of the on-the-wire key management protocol itself.
      Although it may be appropriate to deploy lower-classed mechanisms in
      some cases, the ultimate security requirement for a media security
      negotiation protocol is that it have a mode of operation available in
      which is detect-attack, which provides protection against the passive
      and active attacks and provides detection of such attacks. That is,
      there must be a way to use the protocol so that an active attack is
      required against both the signaling and media paths, and so that such
      attacks are detectable by the endpoints.</t>
    </section>

    <section anchor="scenarios"
             title="Call Scenarios and Requirements Considerations">
      <t>The following subsections describe call scenarios that pose the most
      challenge to the key management system for media data in cooperation
      with SIP signaling.</t>

	  <t> Throughout the subsections, requirements are stated by
	  using the nomenclature R- to state an explicit
	  requirement. All of the stated requirements are explained in
	  detail in <xref target="requirements"></xref>. They are
	  listed according to their association to the key management
	  protocol, to attack scenarios, and requirements that can be
	  met inside the key management protocol or outside of the key
	  management protocol.</t>

      <!-- ====================================================================== -->

      <section anchor="clipping"
               title="Clipping Media before Signaling Answer">
        <t>The discussion in this section relates to requirements
        R-AVOID-CLIPPING and R-ALLOW-RTP.</t>

        <t>Per the Session Description Protocol (SDP) Offer/Answer Model <xref target="RFC3264"></xref>:</t>

        <t><list>
            <t>Once the offerer has sent the offer, it MUST be prepared to
            receive media for any recvonly streams described by that offer. It
            MUST be prepared to send and receive media for any sendrecv
            streams in the offer, and send media for any sendonly streams in
            the offer (of course, it cannot actually send until the peer
            provides an answer with the needed address and port
            information).</t>
          </list></t>

        <t>To meet this requirement with SRTP, the offerer needs to know the
        SRTP key for arriving media. If either endpoint receives encrypted
        media before it has access to the associated SRTP key, it cannot play
        the media -- causing clipping.</t>

        <t>For key exchange mechanisms that send the answerer's key in SDP, a
        SIP provisional response <xref target="RFC3261"></xref>, such as 183
        (session progress), is useful. However, the 183 messages are not
        reliable unless both the calling and called endpoint support Provisional Response ACKnowledgement (PRACK)
        <xref target="RFC3262"></xref>, use TCP across all SIP proxies,
        implement Security Preconditions <xref target="RFC5027"></xref>, or
        both ends implement Interactive Connectivity Establishment <xref target="ICE"></xref>
        and the answerer implements the reliable provisional response
        mechanism described in ICE. Unfortunately, there is not wide
        deployment of any of these techniques and there is industry reluctance
        to require these techniques to avoid the problems described in this
        section.</t>

        <t>Note that the receipt of an SDP answer is not always sufficient to
        allow media to be played to the offerer. Sometimes, the offerer must
        send media in order to open up firewall holes or NAT bindings before
        media can be received (for details, see <xref
        target="MIDDLEBOX"></xref>). In this
        case, even a solution that makes the key available before the SDP
        answer arrives will not help.</t>

        <t>Preventing the arrival of early media (i.e., media that arrives at
        the SDP offerer before the SDP answer arrives) might obsolete the
        R-AVOID-CLIPPING requirement, but at the time of writing such early
        media exists in many normal call scenarios.</t>
      </section>

      <!-- === -->

      <section anchor="forking" title="Retargeting and Forking">
        <t>The discussion in this section relates to requirements
        R-FORK-RETARGET, R-DISTINCT, R-HERFP, and R-BEST-SECURE.</t>

        <t>In SIP, a request sent to a specific AOR but delivered to a
        different AOR is called a "retarget". A typical scenario is a "call
        forwarding" feature. In <xref target="retargeting_figure"></xref>,
        Alice sends an INVITE in step 1 that is sent to Bob in step 2. Bob
        responds with a redirect (SIP response code 3xx) pointing to Carol in
        step 3. This redirect typically does not propagate back to Alice but
        only goes to a proxy (i.e., the retargeting proxy) that sends the
        original INVITE to Carol in step 4.</t>

        <t><figure anchor="retargeting_figure" title="Retargeting">
            <artwork align="center"><![CDATA[
                +-----+
                |Alice|
                +--+--+
                   |
                   | INVITE (1)
                   V
              +----+----+
              |  proxy  |
              ++-+-----++
               | ^     |
    INVITE (2) | |     | INVITE (4)
& redirect (3) | |     |
               V |     V
              ++-++   ++----+
              |Bob|   |Carol|
              +---+   +-----+
              ]]></artwork>
          </figure></t>

        <t>Using retargeting might lead to situations where the User Agent Client 
		(UAC) does not know where its request will be going. This might not 
		immediately seem like a serious problem; after all, when one places a 
		telephone call on the Public Switched Telephone Network (PSTN), one never really knows if it will be forwarded 
		to a different number, who will pick up the line when it rings, and so on.
        However, when considering SIP mechanisms for authenticating the called
        party, this function can also make it difficult to differentiate an
        intermediary that is behaving legitimately from an attacker. From this
        perspective, the main problems with retargeting are:</t>

        <t><list style="hanging">
            <t hangText="Not detectable by the caller: ">The originating user
            agent has no means of anticipating that the condition will arise,
            nor any means of determining that it has occurred until the call
            has already been set up.</t>

            <t hangText="Not preventable by the caller:">There is no existing
            mechanism that might be employed by the originating user agent in
            order to guarantee that the call will not be retargeted.</t>
          </list></t>

        <t>The mechanism used by SIP for identifying the calling party is SIP
        Identity <xref target="RFC4474"></xref>. However, due to the nature of
        retargeting, SIP Identity can only identify the calling party (that is,
        the party that initiated the SIP request). Some key exchange
        mechanisms predate SIP Identity and include their own identity
        mechanism (e.g., Multimedia Internet KEYing (MIKEY)). However, those built-in identity mechanism
        also suffer from the SIP retargeting problem. While <xref
        target="RFC4916">Connected Identity</xref> allows positive
        identification of the called party, the primary difficulty still
        remains that the calling party does not know if a mismatched called
        party is legitimate (i.e., due to authorized retargeting) or
        illegitimate (i.e., due to unauthorized retargeting by an attacker
        above to modify SIP signaling).</t>

        <t>In SIP, 'forking' is the delivery of a request to multiple
        locations. This happens when a single AOR is registered more than
        once. An example of forking is when a user has a desk phone, PC
        client, and mobile handset all registered with the same AOR.</t>

        <t><figure anchor="forking_figure" title="Forking">
            <artwork align="center"><![CDATA[
         +-----+
         |Alice|
         +--+--+
            |
            | INVITE
            V
      +-----+-----+
      |   proxy   |
      ++---------++
       |         |
INVITE |         | INVITE
       V         V
    +--+--+   +--+--+
    |Bob-1|   |Bob-2|
    +-----+   +-----+
]]></artwork>
          </figure></t>

        <t>With forking, both Bob-1 and Bob-2 might send back SDP answers in
        SIP responses. Alice will see those intermediate (18x) and final (200)
        responses. It is useful for Alice to be able to associate the SIP
        response with the incoming media stream. Although this association can
        be done with ICE <xref target="ICE"></xref>, 

<!-- Do you want to delete "ICE", and assume that the citation serves 
   as readable text? For example:

OLD:  done with ICE [ICE],
NEW:  done with [ICE],

Please note there are several occurrences of this in the document,
such as "ZRTP [ZRTP]", "EKT [EKT]", etc.  RFCs go both ways on this
usage. Another option is making the reference tags be last names.
-->

	  and ICE
        is useful to make this association with RTP, it is not desirable to
        require ICE to accomplish this association.</t>

        <t>Forking and retargeting are often used together. For example, a
        boss and secretary might have both phones ring (forking) and rollover
        to voice mail if neither phone is answered (retargeting).</t>

        <t>To maintain the security of the media traffic, only the endpoint that
        answers the call should know the SRTP keys for the session. Forked and
        retargeted calls only reveal sensitive information to non-responders
        when the signaling messages contain sensitive information (e.g., SRTP
        keys) that is accessible by parties that receive the offer, but may
        not respond (i.e., the original recipients in a retargeted call, or
        non-answering endpoints in a forked call). For key exchange mechanisms
        that do not provide secure forking or secure retargeting, one
        workaround is to rekey immediately after forking or retargeting.
        However, because the originator may not be aware that the call forked
        this mechanism requires rekeying immediately after every session is
        established. This doubles the number of messages processed by the
        network.</t>

        <t>Further compounding this problem is a unique feature of SIP that,
        when forking is used, there is always only one final error response
        delivered to the sender of the request: the forking proxy is
        responsible for choosing which final response to choose in the event
        where forking results in multiple final error responses being received
        by the forking proxy. This means that if a request is rejected, say
        with information that the keying information was rejected and
        providing the far end's credentials, it is very possible that the
        rejection will never reach the sender. This problem, called the <xref
        target="RFC3326">Heterogeneous Error Response Forking Problem
        (HERFP)</xref>, is difficult to solve in SIP. Because we expect the
        HERFP to continue to be a problem in SIP for the foreseeable future, a
        media security system should function even in the presence of HERFP
        behavior.</t>
      </section>

      <!-- === -->

      <section anchor="recording" title="Recording">
        <t>The discussion in this section relates to requirement
        R-RECORDING.</t>

        <t>Some business environments, such as stock brokerages, banks, and
        catalog call centers, require recording calls with customers. This is
        the familiar "this call is being recorded for quality purposes" heard
        during calls to these sorts of businesses. In these environments,
        media recording is typically performed by an intermediate device (with
        RTP, this is typically implemented in a 'sniffer').</t>

        <t>When performing such call recording with SRTP, the end-to-end
        security is compromised. This is unavoidable, but necessary because
        the operation of the business requires such recording. It is desirable
        that the media security is not unduly compromised by the media
        recording. The endpoint within the organization needs to be informed
        that there is an intermediate device and needs to cooperate with that
        intermediate device.</t>

        <t>This scenario does not place a requirement directly on the key
        management protocol. The requirement could be met directly by the key
        management protocol (e.g., MIKEY-NULL or <xref
        target="RFC4568"></xref>) or through an external out-of-band mechanism
        (e.g., <xref target="SRTP-KEY"></xref>).</t>
      </section>

      <section anchor="pstn_gateway" title="PSTN Gateway">
        <t>The discussion in this section relates to requirement R-PSTN.</t>

        <t>It is desirable, even when one leg of a call is on the PSTN, that
        the IP leg of the call be protected with SRTP.</t>

        <t>A typical case of using media security where two entities are
        having a Voice over IP (VoIP) conversation over IP-capable networks. However, there
        are cases where the other end of the communication is not connected to
        an IP-capable network. In this kind of setting, there needs to be some
        kind of gateway at the edge of the IP network that converts the VoIP
        conversation to a format understood by the other network. An example of
        such a gateway is a PSTN gateway sitting at the edge of IP and PSTN
        networks (such as the architecture described in <xref
        target="RFC3372"></xref>).</t>

        <t>If media security (e.g., SRTP protection) is employed in this kind
        of gateway-setting, then media security and the related key management
        is terminated at the PSTN gateway. The other network (e.g., PSTN) may
        have its own measures to protect the communication, but this means
        that from media security point of view the media security is not
        employed truly end-to-end between the communicating entities.</t>
      </section>

      <section title="Call Setup Performance">
        <t>The discussion in this section relates to requirement R-REUSE.</t>

        <t>Some devices lack sufficient processing power to perform public key
        operations or Diffie-Hellman operations for each call, or prefer to
        avoid performing those operations on every call. The ability to reuse
        previous public key or Diffie-Hellman operations can vastly decrease
        the call setup delay and processing requirements for such devices.</t>

        <t>In certain devices, it can take a second or two to perform a
        Diffie-Hellman operation. Examples of these devices include handsets,
        IP Multimedia Services Identity Modules (ISIMs), and PSTN gateways.
        PSTN gateways typically utilize a Digital Signal Processor (DSP) that
        is not yet involved with typical DSP operations at the beginning of a
        call; thus, the DSP could be used to perform the calculation, so as to
        avoid having the central host processor perform the calculation.
        However, not all PSTN gateways use DSPs (some have only central
        processors or their DSPs are incapable of performing the necessary
        public key or Diffie-Hellman operation), and handsets lack a separate,
        unused processor to perform these operations.</t>

        <t>Two scenarios where R-REUSE is useful are calls between an endpoint
        and its voicemail server or its PSTN gateway. In those scenarios, calls
        are made relatively often and it can be useful for the voicemail
        server or PSTN gateway to avoid public key operations for subsequent
        calls.</t>

        <t>Storing keys across sessions often interferes with perfect forward
        secrecy (R-PFS).</t>
      </section>

      <section title="Transcoding">
        <t>The discussion in this section relates to requirement
        R-TRANSCODER.</t>

        <t>In some environments, it is necessary for network equipment to
        transcode from one codec (e.g., a highly compressed codec that makes
        efficient use of wireless bandwidth) to another codec (e.g., a
        standardized codec to a SIP peering interface). With RTP, a
        transcoding function can be performed with the combination of a SIP
        back-to-back user agent (B2BUA) to modify the SDP and a processor to perform the transcoding
        between the codecs. However, with end-to-end secured SRTP, a
        transcoding function implemented the same way is a man-in-the-middle
        attack, and the key management system prevents its use.</t>

        <t>However, such a network-based transcoder can still be realized with
        the cooperation and approval of the endpoint, and can provide
        end-to-transcoder and transcoder-to-end security.</t>
      </section>

      <section title="Upgrading to SRTP">
        <t>The discussion in this section relates to the requirement
        R-ALLOW-RTP.</t>

        <t>Legitimate RTP media can be sent to an endpoint for announcements,
        colorful ringback tones (e.g., music), advertising, or normal call
        progress tones. The RTP may be received before an associated SDP
        answer. For details on various scenarios, see <xref
        target="EARLY-MEDIA"> </xref>.</t>

        <t>While receiving such RTP exposes the calling party to a risk of
        receiving malicious RTP from an attacker, SRTP endpoints will need to
        receive and play out RTP media in order to be compatible with deployed
        systems that send RTP to calling parties.</t>
      </section>

      <section title="Interworking with Other Signaling Protocols">
        <t>The discussion in this section relates to the requirement
        R-OTHER-SIGNALING.</t>

        <t>In many environments, some devices are signaled with protocols
        other than SIP that do not share SIP's offer/answer model (e.g.,
        <xref target="H.248.1"></xref> or do not utilize SDP (e.g., H.323). In
        other environments, both endpoints may be SIP, but may use different
        key management systems (e.g., one uses MIKEY-RSA, the other
        MIKEY-RSA-R).</t>

        <t>In these environments, it is desirable to have SRTP -- rather than
        RTP -- between the two endpoints. It is always possible, although
        undesirable, to interwork those disparate signaling systems or
        disparate key management systems by decrypting and re-encrypting each
        SRTP packet in a device in the middle of the network (often the same
        device performing the signaling interworking). This is undesirable due
        to the cost and increased attack area, as such an SRTP/SRTP
        interworking device is a valuable attack target.</t>

        <t>At the time of this writing, interworking is considered important.
        Interworking without decryption/encryption of the SRTP, while useful,
        is not yet deemed critical because the scale of such SRTP deployments
        is, to date, relatively small.</t>
      </section>

      <section title="Certificates">
        <t>The discussion in this section relates to R-CERTS.</t>

<t>
      On the Internet and on some private networks, validating another
      peer's certificate is often done through a trust anchor -- a list
      of Certificate Authorities that are trusted. It can be difficult
      or expensive for a peer to obtain these certificates. In all
      cases, both parties to the call would need to trust the same
      trust anchor (i.e., "certificate authority"). For these reasons,
      it is important that the media plane key management protocol
      offer a mechanism that allows end-users who have no prior
      association to authenticate to each other without acquiring
      credentials from a third-party trust point. Note that this does
      not rule out mechanisms in which servers have certificates and
      attest to the identities of end-users.
</t>
      </section>
    </section>

    <section anchor="requirements" title="Requirements">
      <t>This section is divided into several parts: requirements specific to
      the key management protocol (<xref target="req_key_mgmt"></xref>),
      attack scenarios (<xref target="req_attack_scenario"></xref>), and
      requirements that can be met inside the key management protocol or
      outside of the key management protocol (<xref
      target="req_outside_key_mgmt"></xref>).</t>

      <section anchor="req_key_mgmt"
               title="Key Management Protocol Requirements">
        <t>SIP Forking and Retargeting, from <xref
        target="forking"></xref>:<list hangIndent="6" style="hanging">
            <t hangText="R-FORK-RETARGET:"><vspace blankLines="0" />The media
            security key management protocol MUST securely support forking and
            retargeting when all endpoints are willing to use SRTP without
            causing the call setup to fail. This requirement means the
            endpoints that did not answer the call MUST NOT learn the SRTP
            keys (in either direction) used by the answering endpoint.</t>

            <t hangText="R-DISTINCT:"><vspace blankLines="0" />The media
            security key management protocol MUST be capable of creating
            distinct, independent cryptographic contexts for each endpoint in
            a forked session.</t>

            <t hangText="R-HERFP:"><vspace blankLines="0" />The media security
            key management protocol MUST function securely even in the
            presence of HERFP behavior, i.e., the rejection of key information 
			does not reach the sender.</t>
          </list>Performance considerations:<list hangIndent="6"
            style="hanging">
            <t hangText="R-REUSE:"><vspace blankLines="0" />The media security
            key management protocol MAY support the reuse of a previously
            established security context.<list>
                <t>Note: reuse of the security context does not imply reuse
                of RTP parameters (e.g., payload type or SSRC).</t>
              </list></t>
          </list>Media considerations:<list hangIndent="6" style="hanging">
            <t hangText="R-AVOID-CLIPPING:"><vspace blankLines="0" />The media
            security key management protocol SHOULD avoid clipping media
            before SDP answer without requiring <xref
            target="RFC5027">Security Preconditions</xref>. This requirement
            comes from <xref target="clipping"></xref>.</t>

            <t hangText="R-RTP-CHECK:"><vspace blankLines="0" />If SRTP key
            negotiation is performed over the media path (i.e., using the same
            UDP/TCP ports as media packets), the key negotiation packets MUST
            NOT pass the RTP validity check defined in Appendix A.1 of <xref
            target="RFC3550"></xref>, so that SRTP negotiation packets
            can be differentiated from RTP packets.</t>

            <t hangText="R-ASSOC:"><vspace blankLines="0" />The media security
            key management protocol SHOULD include a mechanism for associating
            key management messages with both the signaling traffic that
            initiated the session and with protected media traffic. It is
            useful to associate key management messages with call signaling
            messages, as this allows the SDP offerer to avoid performing
            CPU-consuming operations (e.g., Diffie-Hellman or public key
            operations) with attackers that have not seen the signaling
            messages.<vspace blankLines="1" />For example, if using a
            Diffie-Hellman keying technique with security preconditions that
            forks to 20 endpoints, the call initiator would get 20
            provisional responses containing 20 signed Diffie-Hellman key
            pairs. Calculating 20 Diffie-Hellman secrets and validating
            signatures can be a difficult task for some devices. Hence, in the
            case of forking, it is not desirable to perform a Diffie-Hellman
            operation with every party, but rather only with the party that
            answers the call (and incur some media clipping). To do this, the
            signaling and media need to be associated so the calling party
            knows which key management exchange needs to be completed. This
            might be done by using the transport address indicated in the SDP,
            although NATs can complicate this association.<list>
                <t>Note: due to RTP's design requirements, it is expected that
                SRTP receivers will have to perform authentication of any
                received SRTP packets.</t>
              </list></t>

            <t hangText="R-NEGOTIATE:"><vspace blankLines="0" />The media
            security key management protocol MUST allow a SIP User Agent to
            negotiate media security parameters for each individual
            session.  Such negotiation MUST NOT cause a two-time
            pad (<xref target="RFC3711">Section 9.1 of </xref>).</t>

            <t hangText="R-PSTN:"><vspace blankLines="0" />The media security
            key management protocol MUST support termination of media security
            in a PSTN gateway. This requirement is from <xref
            target="pstn_gateway"></xref>.</t>
          </list></t>
      </section>

      <section anchor="req_attack_scenario" title="Security Requirements">
        <t>This section describes overall security requirements and specific
        requirements from the attack scenarios (<xref
        target="attack_scenarios"></xref>).</t>

        <t>Overall security requirements:<list hangIndent="6" style="hanging">
            <t hangText="R-PFS:"><vspace blankLines="0" />The media security
            key management protocol MUST be able to support perfect forward
            secrecy.</t>

            <t hangText="R-COMPUTE:"><vspace blankLines="0" />The media
            security key management protocol MUST support offering additional
            SRTP cipher suites without incurring significant computational
            expense.</t>

            <t hangText="R-CERTS:"><vspace blankLines="0" />

 
       The key management protocol MUST NOT require
       that end-users obtain credentials (certificates or private
       keys) from a third-party trust anchor.</t>



            <t hangText="R-FIPS:"><vspace blankLines="0" />The media security
            key management protocol SHOULD use algorithms that allow <xref
            target="FIPS-140-2">FIPS 140-2</xref> certification or 
similar country-specific certification (e.g., <xref target="AISITSEC"></xref>).<vspace
            blankLines="1" />The United States Government can only purchase
            and use crypto implementations that have been validated by the
            <xref target="FIPS-140-2">FIPS-140</xref> process: 

	    <list>
                <t>The FIPS-140 standard is applicable to all Federal
                agencies that use cryptographic-based security systems to
                protect sensitive information in computer and
                telecommunication systems, including voice systems. The
                adoption and use of this standard is available to private and
                commercial organizations.</t>
              </list>

Some commercial organizations, such as banks and defense
            contractors, require or prefer equipment that has received the
            same validation.</t>

            <t hangText="R-DOS:"><vspace blankLines="0" />The media
            security key management protocol MUST NOT introduce any
            new significant denial-of-service vulnerabilities (e.g.,
            the protocol should not request the endpoint to perform
            CPU-intensive operations without the client being able to
            validate or authorize the request).</t>

            <t hangText="R-EXISTING:"><vspace blankLines="0" />The media
            security key management protocol SHOULD allow endpoints to
            authenticate using pre-existing cryptographic credentials, e.g.,
            certificates or pre-shared keys.</t>

            <t hangText="R-AGILITY:"><vspace blankLines="0" />The media
            security key management protocol MUST provide crypto-agility,
            i.e., the ability to adapt to evolving cryptography and security
            requirements (update of cryptographic algorithms without
            substantial disruption to deployed implementations).</t>

            <t hangText="R-DOWNGRADE:"><vspace blankLines="0" />The media
            security key management protocol MUST protect cipher suite
            negotiation against downgrading attacks.</t>

            <t hangText="R-PASS-MEDIA:"><vspace blankLines="0" />The media
            security key management protocol MUST have a mode that prevents a
            passive adversary with access to the media path from gaining
            access to keying material used to protect SRTP media packets.</t>

            <t hangText="R-PASS-SIG:"><vspace blankLines="0" />The media
            security key management protocol MUST have a mode in which it
            prevents a passive adversary with access to the signaling path
            from gaining access to keying material used to protect SRTP media
            packets.</t>

            <t hangText="R-SIG-MEDIA:"><vspace blankLines="0" />The media
            security key management protocol MUST have a mode in which it
            defends itself from an attacker that is solely on the media path
            and from an attacker that is solely on the signaling path. A
            successful attack refers to the ability for the adversary to
            obtain keying material to decrypt the SRTP encrypted media
            traffic.</t>

            <t hangText="R-ID-BINDING:"><vspace blankLines="0" />The media
            security key management protocol MUST enable the media security
            keys to be cryptographically bound to an identity of the endpoint.
            <list>
                <t>Note: This allows domains to deploy <xref target="RFC4474">SIP
                Identity</xref>.</t>
              </list></t>

            <t hangText="R-ACT-ACT:"><vspace blankLines="0" />The media
            security key management protocol MUST support a mode of operation
            that provides active-signaling-active-media-detect robustness, and
            MAY support modes of operation that provide lower levels of
            robustness (as described in <xref
            target="attack_scenarios"></xref>).<list>
                <t>Note: Failing to meet R-ACT-ACT indicates the protocol cannot
                provide secure end-to-end media.</t>
              </list></t>
          </list></t>
      </section>

      <section anchor="req_outside_key_mgmt"
               title="Requirements outside of the Key Management Protocol">
        <t>The requirements in this section are for an overall VoIP security
        system. These requirements can be met within the key management
        protocol itself, or can be solved outside of the key management
        protocol itself (e.g., solved in SIP or in SDP).<list hangIndent="6"
            style="hanging">
            <t hangText="R-BEST-SECURE:"><vspace blankLines="0" />Even when
            some endpoints of a forked or retargeted call are incapable of
            using SRTP, a solution MUST be described that allows the
            establishment of SRTP associations with SRTP-capable endpoints and/or RTP associations with non-SRTP-capable endpoints.</t>

            <t hangText="R-OTHER-SIGNALING:"><vspace blankLines="0" />A
            solution SHOULD be able to negotiate keys for SRTP sessions
            created via different call signaling protocols (e.g., between
            Jabber, SIP, H.323, Media Gateway Control Protocol (MGCP).</t>

            <t hangText="R-RECORDING:"><vspace blankLines="0" />A solution
            SHOULD be described that supports recording of decrypted media.
            This requirement comes from <xref target="recording"></xref>.</t>

            <t hangText="R-TRANSCODER:"><vspace blankLines="0" />A solution
            SHOULD be described that supports intermediate nodes (e.g.,
            transcoders), terminating or processing media, between the endpoints.</t>

            <t hangText="R-ALLOW-RTP:">A solution SHOULD be described that
            allows RTP media to be received by the calling party until SRTP
            has been negotiated with the answerer, after which SRTP is
            preferred over RTP.</t>
          </list></t>
      </section>
    </section>

    <section anchor="security" title="Security Considerations">
      <t>This document lists requirements for securing media traffic. As such,
      it addresses security throughout the document.</t>
    </section>

    <section anchor="acks" title="Acknowledgements">
      <t>For contributions to the requirements portion of this document, the
      authors would like to thank the active participants of the RTPSEC BoF
      and on the RTPSEC mailing list, and a special thanks to Steffen Fries
      and Dragan Ignjatic for their excellent <xref target="RFC5197">
	  MIKEY comparison</xref> document.</t>

      <t>The authors would furthermore like to thank the following people for
      their review, suggestions, and comments: Flemming Andreasen, Richard
      Barnes, Mark Baugher, Wolfgang Buecker, Werner Dittmann,
      Lakshminath Dondeti, John Elwell, Martin Euchner, 
      Hans-Heinrich Grusdt, Christer Holmberg, Guenther Horn, Peter Howard,
      Leo Huang, Dragan Ignjatic, Cullen Jennings, Alan Johnston, Vesa
      Lehtovirta, Matt Lepinski, David McGrew, David Oran, Colin Perkins, Eric
      Raymond, Eric Rescorla, Peter Schneider, Frank Shearar, Srinath Thiruvengadam, Dave
      Ward, Dan York, and Phil Zimmermann.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      &RFC2119;

      &RFC3261;

      &RFC3262;

      &RFC3264;

      &RFC3711;

      <reference anchor="FIPS-140-2"
                 target="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">
        <front>
          <title>Security Requirements for Cryptographic Modules</title>

          <author fullname="NIST">
            <organization>NIST</organization>
          </author>

          <date day="13" month="June" year="2005" />
        </front>
      </reference>

    </references>

    <references title="Informative References">
      &RFC5027;

      &RFC3550;

      &RFC3372;

<!--      &I-D.ietf-mmusic-ice; -->

<reference anchor='ICE'>
<front>
<title>Interactive Connectivity Establishment (ICE): A Protocol for Network Address  Translator (NAT) Traversal for Offer/Answer Protocols</title>

<author initials='J' surname='Rosenberg' fullname='Jonathan Rosenberg'>
    <organization />
</author>

<date month='October' year='2007' />

<abstract><t>This document describes a protocol for Network Address Translator (NAT) traversal for UDP-based multimedia sessions established with the offer/answer model.  This protocol is called Interactive Connectivity Establishment (ICE).  ICE makes use of the Session Traversal Utilities for NAT (STUN) protocol and its extension, Traversal Using Relay NAT (TURN).  ICE can be used by any protocol utilizing the offer/answer model, such as the Session Initiation Protocol (SIP).</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

<!--      &I-D.stucker-sipping-early-media-coping;-->

<reference anchor='EARLY-MEDIA'>
<front>
<title>Coping with Early Media in the Session Initiation Protocol (SIP)</title>

<author initials='B' surname='Stucker' fullname='Brian  Stucker'>
    <organization />
</author>

<date month='October' day='19' year='2006' />

<abstract><t>Several mechanisms for early media have been proposed in the past, each attacking a different aspect of the problem. A good example of this is RFC-3960 which talks about two models of early media: the gateway model, and the application model. The gateway model uses a series of offer/answer exchanges to control the rendering of early media, but breaks down in the presence of forking (as mentioned in section 3 of RFC-3960). The application model relies on the UAS to know when it is generating early media and use RFC-3959 to keep early media and regular media streams separate to avoid clipping. Even in the presence of the recommendations in RFC-3960 some problems exist within SIP in the area of early media. Although some of these challenges are likely to never be overcome, for example when interworking with a PSTN gateway that does not take into account CPG or ACM messages (in the case of ISUP). However, the potential to improve on what is already there does exist. This document attempts to go into more detail around early media where RFC-3960 left off, what sorts of mechanisms are in use today in existing implementations to deal with the challenges at hand, derives requirements and a possible mechanism to improve upon the current model. In addition, the document goes into other areas that can complicate or be complicated by the presence of early media (especially with forking) such as SRTP keying and media flow authorization.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

      &RFC4474;

<!--      &I-D.wing-sipping-srtp-key;-->

<reference anchor='SRTP-KEY'>
<front>
<title>Secure Media Recording and Transcoding with the Session Initiation Protocol</title>

<author initials='D' surname='Wing' fullname='Dan Wing'>
    <organization />
</author>

<author initials='F' surname='Audet' fullname='Francois Audet'>
    <organization />
</author>

<author initials='S' surname='Fries' fullname='Steffen Fries'>
    <organization />
</author>

<author initials='H' surname='Tschofenig' fullname='Hannes Tschofenig'>
    <organization />
</author>

<author initials='A' surname='Johnston' fullname='Alan Johnston'>
    <organization />
</author>

<date month='October' day='31' year='2008' />

<abstract><t>Call recording is an important feature in enterprise telephony applications.  Some industries such as financial traders have requirements to record all calls in which customers give trading orders.  This poses a particular problem for Secure RTP systems as many SRTP key exchange mechanisms do not disclose the SRTP session keys to intermediate SIP proxies.  As a result, these key exchange mechanisms cannot be used in environments where call recording is needed.  This document specifies a secure mechanism for a cooperating endpoint to disclose its SRTP master keys to an authorized party to allow secure call recording.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

      &rfc4568;

      &rfc4650;

 <!--     &I-D.ietf-msec-mikey-ecc;-->

<reference anchor='MIKEY-ECC'>
<front>
<title>ECC Algorithms for MIKEY</title>

<author initials='A' surname='Milne' fullname='Andrew Milne'>
    <organization />
</author>

<date month='June' day='20' year='2007' />

<abstract><t>This document proposes extensions to the authentication, encryption and digital signature methods described for use in MIKEY, employing elliptic-curve cryptography (ECC). These extensions are defined to align MIKEY with other ECC implementations and standards. It should be noted that this document is not self-contained; it uses the notations and definitions of [RFC3830].</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

      &rfc4738;

<reference anchor='RFC4949'>
  <front>
    <title>Internet Security Glossary, Version 2</title>
    <author initials='R.' surname='Shirey' fullname='R. Shirey'>
      <organization /></author>
    <date year='2007' month='August' />
</front>
    <seriesInfo name='FYI' value='36' />
    <seriesInfo name='RFC' value='4949' />
    <format type='TXT' octets='867626' target='ftp://ftp.isi.edu/in-notes/rfc4949.txt' />
  </reference>

 <!--     &I-D.ietf-sip-certs;-->

<reference anchor='SIP-CERTS'>
<front>
<title>Certificate Management Service for The Session Initiation Protocol (SIP)</title>

<author initials='C' surname='Jennings' fullname='Cullen Jennings'>
    <organization />
</author>

<author initials='J' surname='Fischl' fullname='Jason Fischl'>
    <organization />
</author>

<date month='November' day='3' year='2008' />

<abstract><t>This draft defines a Credential Service that allows Session Initiation Protocol (SIP) User Agents (UAs) to use a SIP event package to discover the certificates of other users.  This mechanism allows user agents that want to contact a given Address-of-Record (AOR) to retrieve that AOR's certificate by subscribing to the Credential Service, which returns an authenticated response containing that certificate.  The Credential Service also allows users to store and retrieve their own certificates and private keys.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

      &RFC3326;

      &rfc3830;

      &rfc4492;

<!--      &I-D.ietf-tls-rfc4346-bis;-->

      <reference anchor='RFC5246'>

<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<date year='2008' month='August' />
<abstract>
<t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5246' />
<format type='TXT' octets='222395' target='ftp://ftp.isi.edu/in-notes/rfc5246.txt' />
</reference>

      &rfc4916;

<!--      &I-D.fischl-sipping-media-dtls; -->

<reference anchor='SIP-DTLS'>
<front>
<title>Datagram Transport Layer Security (DTLS) Protocol for Protection of Media Traffic Established with the Session Initiation Protocol</title>

<author initials='J' surname='Fischl' fullname='Jason Fischl'>
    <organization />
</author>

<date month='July' day='11' year='2007' />

<abstract><t>This document specifies how to use the Session Initiation Protocol (SIP) to establish secure media sessions using or over the Datagram Transport Layer Security (DTLS) protocol. It describes a mechanism of transporting a fingerprint attribute in the Session Description Protocol (SDP) that identifies the key that will be presented during the DTLS handshake. It relies on the SIP identity mechanism to ensure the integrity of the fingerprint attribute. This allows the establishment of media security along the media path.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

      &RFC5197;

<!--      &I-D.zimmermann-avt-zrtp;-->

<reference anchor='ZRTP'>
<front>
<title>ZRTP: Media Path Key Agreement for Secure RTP</title>

<author initials='P' surname='Zimmermann' fullname='Philip Zimmermann'>
    <organization />
</author>

<author initials='A' surname='Johnston' fullname='Alan  Johnston'>
    <organization />
</author>

<author initials='J' surname='Callas' fullname='Jon Callas'>
    <organization />
</author>

<date month='February' day='3' year='2009' />

<abstract><t>This document defines ZRTP, a protocol for media path Diffie-Hellman exchange to agree on a session key and parameters for establishing Secure Real-time Transport Protocol (SRTP) sessions.  The ZRTP protocol is media path keying because it is multiplexed on the same port as RTP and does not require support in the signaling protocol. ZRTP does not assume a Public Key Infrastructure (PKI) or require the complexity of certificates in end devices.  For the media session, ZRTP provides confidentiality, protection against man-in-the-middle (MiTM) attacks, and, in cases where the signaling protocol provides end-to-end integrity protection, authentication.  ZRTP can utilize a Session Description Protocol (SDP) attribute to provide discovery and authentication through the signaling channel.  To provide best effort SRTP, ZRTP utilizes normal RTP/AVP profiles.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

 <!--     &I-D.baugher-mmusic-sdp-dh; -->


<reference anchor='SDP-DH'>
<front>
<title>Diffie-Hellman Exchanges for Multimedia Sessions</title>

<author initials='M' surname='Baugher' fullname='Mark Baugher'>
    <organization />
</author>

<author initials='D' surname='McGrew' fullname='David  McGrew'>
    <organization />
</author>

<date month='February' day='27' year='2006' />

<abstract><t>This memo defines a new Session Description Protocol (SDP) attribute for exchanging Diffie-Hellman (DH) public keys. The attribute is an SDP session-level attribute for describing DH keys, and there is a new media-level parameter for describing public keying material for SRTP key generation. The SDP attribute supports the key establishment schemes of NIST Draft Special Publication 800-56, adds domain parameters and supports external authentication of the DH endpoint without a public key infrastructure.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

<!--      &I-D.mcgrew-srtp-ekt;-->

<reference anchor='EKT'>
<front>
<title>Encrypted Key Transport for Secure RTP</title>

<author initials='D' surname='McGrew' fullname='David McGrew'>
    <organization />
</author>

<date month='July' day='3' year='2007' />

<abstract><t>SRTP Encrypted Key Transport (EKT) is an extension to SRTP that provides for the secure transport of SRTP master keys, Rollover Counters, and other information, within SRTCP. This facility enables SRTP to work for decentralized conferences with minimal control, and to handle situations caused by SIP forking and early media.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

<!--      &I-D.ietf-mmusic-media-path-middleboxes; -->

<reference anchor='MIDDLEBOX'>
<front>
<title>Analysis of Middlebox Interactions for Signaling Protocol Communication along the Media Path</title>

<author initials='B' surname='Stucker' fullname='Brian Stucker'>
    <organization />
</author>

<author initials='H' surname='Tschofenig' fullname='Hannes Tschofenig'>
    <organization />
</author>

<date month='July' day='14' year='2008' />

<abstract><t>Middleboxes are defined as any intermediary box performing functions apart from normal, standard functions of an IP router on the data path between a source host and destination host.  Two such functions are network address translation and firewalling.  When Application Layer Gateways, such as SIP entities, interact with NATs and firewalls, as described in the MIDCOM architecture, then problems may occur in the transport of media traffic when signaling protocol interaction takes place along the media path, as it is the case for recent key exchange proposals (such as DTLS-SRTP).  This document highlights problems that may arise.  Unfortunately, it is difficult for the end points to detect or predict problematic behavior and to determine whether the media path is reliably available for packet exchange.  This document aims to summarize the various sources and effects of NAT and firewall control, the reasons that they exist, and possible means of improving their behavior to allow protocols that rely upon signaling along the media path to operate effectively.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>


      &rfc4771;

<!--      &I-D.jennings-sipping-multipart;-->

<reference anchor='MULTIPART'>
<front>
<title>Session Initiation Protocol (SIP) Offer/Answer with Multipart Alternative</title>

<author initials='D' surname='Wing' fullname='Dan Wing'>
    <organization />
</author>

<author initials='C' surname='Jennings' fullname='Cullen Jennings'>
    <organization />
</author>

<date month='March' day='7' year='2006' />

<abstract><t>SIP needs a mechanism for general backwards compatibility for moving from SDP to SDPng or moving from non end-to-end encrypted SDP to end- to-end encrypted SDP. This document specifies how a SIP offer uses multipart/alternative, and how an answer indicates which part was selected.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

<!--      &I-D.ietf-avt-dtls-srtp; -->

<reference anchor='DTLS-SRTP'>
<front>
<title>Datagram Transport Layer Security (DTLS) Extension to Establish Keys for Secure Real-time Transport Protocol (SRTP)</title>

<author initials='D' surname='McGrew' fullname='David McGrew'>
    <organization />
</author>

<author initials='E' surname='Rescorla' fullname='Eric Rescorla'>
    <organization />
</author>

<date month='October' day='29' year='2008' />

<abstract><t>This document describes a Datagram Transport Layer Security (DTLS) extension to establish keys for secure RTP (SRTP) and secure RTP Control Protocol (SRTCP) flows.  DTLS keying happens on the media path, independent of any out-of-band signalling channel present.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

<!--      &I-D.dondeti-msec-rtpsec-mikeyv2; -->

<reference anchor='MIKEYv2'>
<front>
<title>MIKEYv2: SRTP Key Management using MIKEY, revisited</title>

<author initials='L' surname='Dondeti' fullname='Lakshminath Dondeti'>
    <organization />
</author>

<date month='March' day='8' year='2007' />

<abstract><t>The Multimedia Internet Keying (MIKEY) protocol is a general purpose key management protocol; it is used especially for key management for secure RTP. We specify a couple of variations of that protocol to support mode negotiation, media path key establishment and other assorted requirements.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

<!--      &I-D.ietf-mmusic-sdp-capability-negotiation;-->

<reference anchor='SDP-CAP'>
<front>
<title>SDP Capability Negotiation</title>

<author initials='F' surname='Andreasen' fullname='Flemming Andreasen'>
    <organization />
</author>

<date month='July' day='11' year='2008' />

<abstract><t>The Session Description Protocol (SDP) was intended for describing multimedia sessions for the purposes of session announcement, session invitation, and other forms of multimedia session initiation. SDP was not intended to provide capability indication or capability negotiation, however over the years, SDP has seen widespread adoption and as a result it has been gradually extended to provide limited support for these, notably in the form of the offer/answer model defined in RFC 3264. SDP does not define how to negotiate one or more alternative transport protocols (e.g. RTP profiles) or attributes. This makes it difficult to deploy new RTP profiles such as secure RTP or RTP with RTCP-based feedback, negotiate use of different security keying mechanisms, etc. It also presents problems for some forms of media negotiation.  The purpose of this document is to address these shortcomings by extending SDP with capability negotiation parameters and associated offer/answer procedures to use those parameters in a backwards compatible manner.  The document defines a general SDP Capability Negotiation framework. It also specifies how to provide attributes and transport protocols as capabilities and negotiate them using the framework. Extensions for other types of capabilities (e.g. media types and media formats) may be provided in other documents.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

      <reference anchor="H.248.1"
                 target="http://www.itu.int/rec/T-REC-H.248/e">
        <front>
          <title>Gateway control protocol</title>

          <author fullname="ITU" surname="ITU">
            <organization></organization>
          </author>

          <date month="June" year="2000" />
        </front>
<seriesInfo name='Recommendation' value='H.248' />

      </reference>

      <reference anchor="AISITSEC"
		 target="http://www.bsi.de/zertifiz/zert/interpr/aisitsec.htm">
        <front>
        <title>Anwendungshinweise und Interpretationen (AIS) zu ITSEC</title>
        <author><organization>Bundesamt fuer Sicherheit in der
	    Informationstechnik [Federal Office of
	    Information Security - Germany]</organization>
	</author>
	<date month="January" year="2002" />
	</front>
      </reference>

    </references>

    <section anchor="comparison"
             title="Overview and Evaluation of Existing Keying Mechanisms">
      <t>Based on how the SRTP keys are exchanged, each SRTP key exchange
      mechanism belongs to one general category:<list hangIndent="5"
          style="hanging">
          <t hangText="signaling path:"><vspace blankLines="0" />All the
          keying is carried in the call signaling (SIP or SDP) path.</t>

          <t hangText="media path:"><vspace blankLines="0" />All the keying is
          carried in the SRTP/SRTCP media path, and no signaling whatsoever is
          carried in the call signaling path.</t>

          <t hangText="signaling and media path:"><vspace
          blankLines="0" />Parts of the keying are carried in the SRTP/SRTCP
          media path, and parts are carried in the call signaling (SIP or SDP)
          path.</t>
        </list></t>

      <t>One of the significant benefits of SRTP over other end-to-end
      encryption mechanisms, such as for example IPsec, is that SRTP is
      bandwidth efficient and SRTP retains the header of RTP packets.
      Bandwidth efficiency is vital for VoIP in many scenarios where access
      bandwidth is limited or expensive, and retaining the RTP header is
      important for troubleshooting packet loss, delay, and jitter.</t>

      <t>Related to SRTP's characteristics is a goal that any SRTP keying
      mechanism to also be efficient and not cause additional call setup
      delay. Contributors to additional call setup delay include network or
      database operations: retrieval of certificates and additional SIP or
      media path messages, and computational overhead of establishing keys or
      validating certificates.</t>

      <t>When examining the choice between keying in the signaling path,
      keying in the media path, or keying in both paths, it is important to
      realize the media path is generally "faster" than the SIP signaling
      path. The SIP signaling path has computational elements involved that
      parse and route SIP messages. The media path, on the other hand, does
      not normally have computational elements involved, and even when
      computational elements such as firewalls are involved, they cause very
      little additional delay. Thus, the media path can be useful for
      exchanging several messages to establish SRTP keys. A disadvantage of
      keying over the media path is that interworking different key exchange
      requires the interworking function be in the media path, rather than
      just in the signaling path; in practice, this involvement is probably
      unavoidable anyway.</t>

      <section title="Signaling Path Keying Techniques">
        <section title="MIKEY-NULL">
          <t><xref target="RFC3830">MIKEY-NULL</xref> has the offerer indicate
          the SRTP keys for both directions. The key is sent unencrypted in
          SDP, which means the SDP must be encrypted hop-by-hop (e.g., by
          using TLS (SIPS)) or end-to-end (e.g., by using Secure/Multipurpose Internet Mail Extensions (S/MIME)).</t>

          <t>MIKEY-NULL requires one message from offerer to answerer (half a
          round trip), and does not add additional media path messages.</t>
        </section>

        <section title="MIKEY-PSK">
          <t>MIKEY-PSK (pre-shared key) <xref target="RFC3830"></xref>
          requires that all endpoints share one common key. MIKEY-PSK has the
          offerer encrypt the SRTP keys for both directions using this
          pre-shared key.</t>

          <t>MIKEY-PSK requires one message from offerer to answerer (half a
          round trip), and does not add additional media path messages.</t>
        </section>

        <section title="MIKEY-RSA">
          <t><xref target="RFC3830">MIKEY-RSA</xref> has the offerer encrypt
          the keys for both directions using the intended answerer's public
          key, which is obtained from a mechanism outside of MIKEY.</t>

          <t>MIKEY-RSA requires one message from offerer to answerer (half a
          round trip), and does not add additional media path messages.
          MIKEY-RSA requires the offerer to obtain the intended answerer's
          certificate.</t>
        </section>

        <section title="MIKEY-RSA-R">
          <t><xref target="RFC4738">MIKEY-RSA-R </xref> is essentially the
          same as MIKEY-RSA but reverses the role of the offerer and the
          answerer with regards to providing the keys. That is, the answerer
          encrypts the keys for both directions using the offerer's public
          key. Both the offerer and answerer validate each other's public keys
          using a standard X.509 validation techniques. MIKEY-RSA-R also
          enables sending certificates in the MIKEY message.</t>

          <t>MIKEY-RSA-R requires one message from offerer to answer, and one
          message from answerer to offerer (full round trip), and does not add
          additional media path messages. MIKEY-RSA-R requires the offerer
          validate the answerer's certificate.</t>
        </section>

        <section title="MIKEY-DHSIGN">
          <t><xref target="RFC3830">In MIKEY-DHSIGN</xref>, the offerer and
          answerer derive the key from a Diffie-Hellman (DH) exchange. In order to
          prevent an active man-in-the-middle, the DH exchange itself is signed
          using each endpoint's private key and the associated public keys are
          validated using standard X.509 validation techniques.</t>

          <t>MIKEY-DHSIGN requires one message from offerer to answerer, and
          one message from answerer to offerer (full round trip), and does not
          add additional media path messages. MIKEY-DHSIGN requires the
          offerer and answerer to validate each other's certificates.
          MIKEY-DHSIGN also enables sending the answerer's certificate in the
          MIKEY message.</t>
        </section>

        <section title="MIKEY-DHHMAC">
          <t><xref target="RFC4650">MIKEY-DHHMAC</xref> uses a pre-shared
          secret to HMAC the Diffie-Hellman exchange, essentially combining
          aspects of MIKEY-PSK with MIKEY-DHSIGN, but without MIKEY-DHSIGN's
          need for certificate authentication.</t>

          <t>MIKEY-DHHMAC requires one message from offerer to answerer, and
          one message from answerer to offerer (full round trip), and does not
          add additional media path messages.</t>
        </section>

        <section title="MIKEY-ECIES and MIKEY-ECMQV (MIKEY-ECC)">
          <t><xref target="MIKEY-ECC">ECC Algorithms For
          MIKEY</xref> describes how ECC can be used with MIKEY-RSA (using
          Elliptic Curve Digital Signature Algorithm (ECDSA) signature) and with MIKEY-DHSIGN (using a new DH-Group code),
          and also defines two new ECC-based algorithms, Elliptic Curve
          Integrated Encryption Scheme (ECIES) and Elliptic Curve
          Menezes-Qu-Vanstone (ECMQV) .</t>

          <t>With this proposal, the ECDSA signature, MIKEY-ECIES, and
          MIKEY-ECMQV function exactly like MIKEY-RSA, and the new DH-Group
          code function exactly like MIKEY-DHSIGN. Therefore, these ECC
          mechanisms are not discussed separately in this document.</t>
        </section>

        <section anchor="sdesc" title="SDP Security Descriptions with SIPS">
          <t><xref target="RFC4568">SDP Security Descriptions</xref> have each side
          indicate the key they will use for transmitting SRTP media, and the
          keys are sent in the clear in SDP. SDP Security Descriptions rely on
          hop-by-hop (TLS via "SIPS:") encryption to protect the keys
          exchanged in signaling.</t>

          <t>SDP Security Descriptions requires one message from offerer to
          answerer, and one message from answerer to offerer (full round
          trip), and does not add additional media path messages.</t>
        </section>

        <section title="SDP Security Descriptions with S/MIME">
          <t>This keying mechanism is identical to <xref
          target="sdesc"></xref> except that, rather than protecting the
          signaling with TLS, the entire SDP is encrypted with S/MIME.</t>
        </section>

        <section title="SDP-DH (Expired)">
          <t><xref target="SDP-DH">SDP
          Diffie-Hellman</xref> exchanges Diffie-Hellman messages in the
          signaling path to establish session keys. To protect against active
          man-in-the-middle attacks, the Diffie-Hellman exchange needs to be
          protected with S/MIME, SIPS, or <xref target="RFC4474">SIP
          Identity</xref> and <xref target="RFC4916">SIP Connected
          Identity</xref>.</t>

          <t>SDP-DH requires one message from offerer to answerer, and one
          message from answerer to offerer (full round trip), and does not add
          additional media path messages.</t>
        </section>

        <section anchor="mikey2-sdp" title="MIKEYv2 in SDP (Expired)">
          <t><xref target="MIKEYv2">MIKEYv2</xref>
          adds mode negotiation to MIKEYv1 and removes the time
          synchronization requirement. It therefore now takes 2 round trips to
          complete. In the first round trip, the communicating parties learn
          each other's identities, agree on a MIKEY mode, crypto algorithm,
          SRTP policy, and exchanges nonces for replay protection. In the
          second round trip, they negotiate unicast and/or group SRTP context
          for SRTP and/or SRTCP.</t>

          <t>Furthermore, MIKEYv2 also defines an in-band negotiation mode as
          an alternative to SDP (see <xref
          target="mikey2-inband"></xref>).</t>
        </section>
      </section>

      <section title="Media Path Keying Technique">
        <section title="ZRTP">
          <t><xref target="ZRTP">ZRTP</xref> does not
          exchange information in the signaling path (although it's possible
          for endpoints to exchange a hash of the ZRTP Hello message with
          "a=zrtp-hash" in the initial offer if sent over an
          integrity-protected signaling channel. This provides some useful
          correlation between the signaling and media layers). In ZRTP, the
          keys are exchanged entirely in the media path using a Diffie-Hellman
          exchange. The advantage to this mechanism is that the signaling
          channel is used only for call setup and the media channel is used to
          establish an encrypted channel -- much like encryption devices on
          the PSTN. ZRTP uses voice authentication of its Diffie-Hellman
          exchange by having each person read digits or words to the other
          person. Subsequent sessions with the same ZRTP endpoint can be
          authenticated using the stored hash of the previously negotiated key
          rather than voice authentication. ZRTP uses four media path messages
          (Hello, Commit, DHPart1, and DHPart2) to establish the SRTP key, and
          three media path confirmation messages. These initial messages are all
          sent as non-RTP packets. <list>
              <t>Note: that when ZRTP probing is used, unencrypted RTP can be
              exchanged until the SRTP keys are established.</t>
            </list></t>
        </section>
      </section>

      <section title="Signaling and Media Path Keying Techniques">
        <t></t>

        <section title="EKT">
          <t><xref target="EKT">EKT</xref> relies on another
          SRTP key exchange protocol, such as SDP Security Descriptions or MIKEY,
          for bootstrapping. In the initial phase, each member of a conference
          uses an SRTP key exchange protocol to establish a common key
          encryption key (KEK). Each member may use the KEK to securely
          transport its SRTP master key and current SRTP rollover counter
          (ROC), via RTCP, to the other participants in the session.</t>

          <t>EKT requires the offerer to send some parameters (EKT_Cipher,
          KEK, and security parameter index (SPI)) via the bootstrapping
          protocol such as SDP Security Descriptions or MIKEY. Each answerer sends
          an SRTCP message that contains the answerer's SRTP Master Key,
          rollover counter, and the SRTP sequence number. Rekeying is done by
          sending a new SRTCP message. For reliable transport, multiple RTCP
          messages need to be sent.</t>
        </section>

        <section anchor="dtls-srtp" title="DTLS-SRTP">
          <t><xref target="DTLS-SRTP">DTLS-SRTP</xref> exchanges
          public key fingerprints in SDP <xref
          target="SIP-DTLS"></xref> and then establishes
          a DTLS session over the media channel. The endpoints use the DTLS
          handshake to agree on crypto suites and establish SRTP session keys.
          SRTP packets are then exchanged between the endpoints.</t>

          <t>DTLS-SRTP requires one message from offerer to answerer (half
          round trip), and one message from the answerer to offerer (full
          round trip) so the offerer can correlate the SDP answer with the
          answering endpoint. DTLS-SRTP uses four media path messages to
          establish the SRTP key.</t>

          <t>This document assumes DTLS will use TLS_RSA_WITH_AES_128_CBC_SHA
          as its cipher suite, which is the mandatory-to-implement cipher
          suite in <xref target="RFC5246">TLS</xref>.</t>
        </section>

        <section anchor="mikey2-inband" title="MIKEYv2 Inband (Expired)">
          <t>As defined in <xref target="mikey2-sdp"></xref>, MIKEYv2 also
          defines an in-band negotiation mode as an alternative to SDP (see
          <xref target="mikey2-inband"></xref>). The details are not sorted
          out in the document yet on what in-band actually means (i.e., UDP, RTP,
          RTCP, etc.).</t>
        </section>
      </section>

      <section anchor="eval-sip" title="Evaluation Criteria - SIP">
        <t>This section considers how each keying mechanism interacts with SIP
        features.</t>

        <section anchor="retargeting"
                 title="Secure Retargeting and Secure Forking">
          <t></t>

          <t>Retargeting and forking of signaling requests is described within
          <xref target="forking"></xref>. The following builds upon this
          description.</t>

          <t>The following list compares the behavior of secure forking,
          answering association, two-time pads, and secure retargeting for
          each keying mechanism.</t>

          <t><list>
              <t><list style="hanging">
                  <t hangText="MIKEY-NULL"><vspace blankLines="0" />Secure Forking: No, all AORs see
                  offerer's and answerer's keys. Answer is associated with
                  media by the SSRC in MIKEY. Additionally, a two-time pad
                  occurs if two branches choose the same 32-bit SSRC and
                  transmit SRTP packets.<vspace blankLines="1" />Secure
                  Retargeting: No, all targets see offerer's and answerer's
                  keys. Suffers from retargeting identity problem.</t>

                  <t hangText="MIKEY-PSK"><vspace blankLines="0" />Secure
                  Forking: No, all AORs see offerer's and answerer's keys.
                  Answer is associated with media by the SSRC in MIKEY. Note
                  that all AORs must share the same pre-shared key in order
                  for forking to work at all with MIKEY-PSK. Additionally, a
                  two-time pad occurs if two branches choose the same 32-bit
                  SSRC and transmit SRTP packets.<vspace
                  blankLines="1" />Secure Retargeting: Not secure. For
                  retargeting to work, the final target must possess the
                  correct PSK. As this is likely in scenarios where the call is
                  targeted to another device belonging to the same user
                  (forking), it is very unlikely that other users will possess
                  that PSK and be able to successfully answer that call.</t>

                  <t hangText="MIKEY-RSA"><vspace blankLines="0" />Secure
                  Forking: No, all AORs see offerer's and answerer's keys.
                  Answer is associated with media by the SSRC in MIKEY. Note
                  that all AORs must share the same private key in order for
                  forking to work at all with MIKEY-RSA. Additionally, a
                  two-time pad occurs if two branches choose the same 32-bit
                  SSRC and transmit SRTP packets.<vspace
                  blankLines="1" />Secure Retargeting: No.</t>

                  <t hangText="MIKEY-RSA-R"><vspace blankLines="0" />Secure
                  Forking: Yes, answer is associated with media by the SSRC in
                  MIKEY.<vspace blankLines="1" />Secure Retargeting: Yes.</t>

                  <t hangText="MIKEY-DHSIGN"><vspace blankLines="0" />Secure
                  Forking: Yes, each forked endpoint negotiates unique keys
                  with the offerer for both directions. Answer is associated
                  with media by the SSRC in MIKEY.<vspace
                  blankLines="1" />Secure Retargeting: Yes, each target
                  negotiates unique keys with the offerer for both
                  directions.</t>

                  <t hangText="MIKEYv2 in SDP"><vspace blankLines="0" />The
                  behavior will depend on which mode is picked.</t>

                  <t hangText="MIKEY-DHHMAC"><vspace blankLines="0" />Secure
                  Forking: Yes, each forked endpoint negotiates unique keys
                  with the offerer for both directions. Answer is associated
                  with media by the SSRC in MIKEY.<vspace
                  blankLines="1" />Secure Retargeting: Yes, each target
                  negotiates unique keys with the offerer for both directions.
                  Note that for the keys to be meaningful, it would require
                  the PSK to be the same for all the potential intermediaries,
                  which would only happen within a single domain.</t>

                  <t hangText="SDP Security Descriptions with SIPS"><vspace
                  blankLines="0" />Secure Forking: No, each forked endpoint
                  sees the offerer's key. Answer is not associated with
                  media.<vspace blankLines="1" />Secure Retargeting: No, each
                  target sees the offerer's key.</t>

                  <t hangText="SDP Security Descriptions with S/MIME"><vspace
                  blankLines="0" />Secure Forking: No, each forked endpoint
                  sees the offerer's key. Answer is not associated with
                  media.<vspace blankLines="1" />Secure Retargeting: No, each
                  target sees the offerer's key. Suffers from retargeting
                  identity problem.</t>

                  <t hangText="SDP-DH"><vspace blankLines="0" />Secure
                  Forking: Yes, each forked endpoint calculates a unique SRTP
                  key. Answer is not associated with media.<vspace
                  blankLines="1" />Secure Retargeting: Yes, the final target
                  calculates a unique SRTP key.</t>

                  <t hangText="ZRTP"><vspace blankLines="0" /> Secure Forking: Yes, each
                  forked endpoint calculates a unique SRTP key. With the
                  "a=zrtp-hash" attribute, the media can be associated with an
                  answer. <vspace blankLines="1" />Secure Retargeting: Yes, the final target calculates a unique SRTP key.</t>

                  <t hangText="EKT"><vspace blankLines="0" />Secure Forking:
                  Inherited from the bootstrapping mechanism (the specific
                  MIKEY mode or SDP Security Descriptions). Answer is associated
                  with media by the SPI in the EKT protocol. Answer is
                  associated with media by the SPI in the EKT protocol.<vspace
                  blankLines="1" />Secure Retargeting: Inherited from the
                  bootstrapping mechanism (the specific MIKEY mode or SDP Security
                  Descriptions).</t>

                  <t hangText="DTLS-SRTP"><vspace blankLines="0" />Secure
                  Forking: Yes, each forked endpoint calculates a unique SRTP
                  key. Answer is associated with media by the certificate
                  fingerprint in signaling and certificate in the media
                  path.<vspace blankLines="1" /> Secure Retargeting: Yes, the
                  final target calculates a unique SRTP key.</t>

                  <t hangText="MIKEYv2 Inband"><vspace blankLines="0" />The
                  behavior will depend on which mode is picked.</t>
                </list></t>
            </list></t>
        </section>

        <section title="Clipping Media before SDP Answer">
          <t>Clipping media before receiving the signaling answer is described
          within <xref target="clipping"></xref>. The following builds upon
          this description.</t>

          <t>Furthermore, the problem of clipping gets compounded when forking
          is used. For example, if using a Diffie-Hellman keying technique
          with security preconditions that forks to 20 endpoints, the call
          initiator would get 20 provisional responses containing 20 signed
          Diffie-Hellman half keys. Calculating 20 DH secrets and validating
          signatures can be a difficult task depending on the device
          capabilities.</t>

          <t>The following list compares the behavior of clipping before SDP
          answer for each keying mechanism.</t>

          <t><list>
              <t><list style="hanging">
                  <t hangText="MIKEY-NULL"><vspace blankLines="0" />Not
                  clipped. The offerer provides the answerer's keys.</t>

                  <t hangText="MIKEY-PSK"><vspace blankLines="0" />Not
                  clipped. The offerer provides the answerer's keys.</t>

                  <t hangText="MIKEY-RSA"><vspace blankLines="0" />Not
                  clipped. The offerer provides the answerer's keys.</t>

                  <t hangText="MIKEY-RSA-R"><vspace blankLines="0" />Clipped.
                  The answer contains the answerer's encryption key.</t>

                  <t hangText="MIKEY-DHSIGN"><vspace blankLines="0" />Clipped.
                  The answer contains the answerer's Diffie-Hellman
                  response.</t>

                  <t hangText="MIKEY-DHHMAC"><vspace blankLines="0" />Clipped.
                  The answer contains the answerer's Diffie-Hellman
                  response.</t>

                  <t hangText="MIKEYv2 in SDP"><vspace blankLines="0" />The
                  behavior will depend on which mode is picked.</t>

                  <t hangText="SDP Security Descriptions with SIPS"><vspace
                  blankLines="0" />Clipped. The answer contains the answerer's
                  encryption key.</t>

                  <t hangText="SDP Security Descriptions with S/MIME"><vspace
                  blankLines="0" />Clipped. The answer contains the answerer's
                  encryption key.</t>

                  <t hangText="SDP-DH"><vspace blankLines="0" />Clipped. The
                  answer contains the answerer's Diffie-Hellman response.</t>

                  <t hangText="ZRTP"><vspace blankLines="0" />Not clipped
                  because the session initially uses RTP. While RTP is flowing,
                  both ends negotiate SRTP keys in the media path and then
                  switch to using SRTP.</t>

                  <t hangText="EKT"><vspace blankLines="0" />Not clipped, as
                  long as the first RTCP packet (containing the answerer's
                  key) is not lost in transit. The answerer sends its
                  encryption key in RTCP, which arrives at the same time (or
                  before) the first SRTP packet encrypted with that key.<list>
                      <t>Note: RTCP needs to work, in the answerer-to-offerer
                      direction, before the offerer can decrypt SRTP
                      media.</t>
                    </list></t>

                  <t hangText="DTLS-SRTP"><vspace blankLines="0" />No clipping
                  after the DTLS-SRTP handshake has completed. SRTP keys are
                  exchanged in the media path. Need to wait for SDP answer to
                  ensure DTLS-SRTP handshake was done with an authorized
                  party.<list>
                      <t>If a middlebox interferes with the media path, there
                      can be clipping <xref
                      target="MIDDLEBOX"></xref>.</t>
                    </list></t>

                  <t hangText="MIKEYv2 Inband"><vspace blankLines="0" />Not
                  clipped. Keys are exchanged in the media path without
                  relying on the signaling path.</t>
                </list></t>
            </list></t>
        </section>

        <section title="SSRC and ROC">
          <t>In SRTP, a cryptographic context is defined as the SSRC,
          destination network address, and destination transport port number.
          Whereas RTP, a flow is defined as the destination network address
          and destination transport port number. This results in a problem --
          how to communicate the SSRC so that the SSRC can be used for the
          cryptographic context.</t>

          <t>Two approaches have emerged for this communication. One, used by
          all MIKEY modes, is to communicate the SSRCs to the peer in the
          MIKEY exchange. Another, used by SDP Security Descriptions, is to apply
          "late binding" -- that is, any new packet containing a
          previously unseen SSRC (which arrives at the same destination
          network address and destination transport port number) will create a
          new cryptographic context. Another approach, common amongst
          techniques with media-path SRTP key establishment, is to require a
          handshake over that media path before SRTP packets are sent. MIKEY's
          approach changes RTP's SSRC collision detection behavior by
          requiring RTP to pre-establish the SSRC values for each session.</t>

          <t>Another related issue is that SRTP introduces a rollover counter
          (ROC), which records how many times the SRTP sequence number has
          rolled over. As the sequence number is used for SRTP's default
          ciphers, it is important that all endpoints know the value of the
          ROC. The ROC starts at 0 at the beginning of a session.</t>

          <t>Some keying mechanisms cause a two-time pad to occur if two
          endpoints of a forked call have an SSRC collision.</t>

          <t>Note: A proposal has been made to send the ROC value on every Nth
          SRTP packet<xref target="RFC4771"></xref>. This proposal has not yet
          been incorporated into this document.</t>

          <t>The following list examines handling of SSRC and ROC:</t>

          <t><list>
              <t><list style="hanging">
                  <t hangText="MIKEY-NULL"><vspace blankLines="0" />Each
                  endpoint indicates a set of SSRCs and the ROC for SRTP
                  packets it transmits.</t>

                  <t hangText="MIKEY-PSK"><vspace blankLines="0" />Each
                  endpoint indicates a set of SSRCs and the ROC for SRTP
                  packets it transmits.</t>

                  <t hangText="MIKEY-RSA"><vspace blankLines="0" />Each
                  endpoint indicates a set of SSRCs and the ROC for SRTP
                  packets it transmits.</t>

                  <t hangText="MIKEY-RSA-R"><vspace blankLines="0" />Each
                  endpoint indicates a set of SSRCs and the ROC for SRTP
                  packets it transmits.</t>

                  <t hangText="MIKEY-DHSIGN"><vspace blankLines="0" />Each
                  endpoint indicates a set of SSRCs and the ROC for SRTP
                  packets it transmits.</t>

                  <t hangText="MIKEY-DHHMAC"><vspace blankLines="0" />Each
                  endpoint indicates a set of SSRCs and the ROC for SRTP
                  packets it transmits.</t>

                  <t hangText="MIKEYv2 in SDP"><vspace blankLines="0" />Each
                  endpoint indicates a set of SSRCs and the ROC for SRTP
                  packets it transmits.</t>

                  <t hangText="SDP Security Descriptions with SIPS"><vspace
                  blankLines="0" />Neither SSRC nor ROC are signaled. SSRC
                  "late binding" is used.</t>

                  <t hangText="SDP Security Descriptions with S/MIME"><vspace
                  blankLines="0" />Neither SSRC nor ROC are signaled. SSRC
                  "late binding" is used.</t>

                  <t hangText="SDP-DH"><vspace blankLines="0" />Neither SSRC
                  nor ROC are signaled. SSRC "late binding" is used.</t>

                  <t hangText="ZRTP"><vspace blankLines="0" />Neither SSRC nor
                  ROC are signaled. SSRC "late binding" is used.</t>

                  <t hangText="EKT"><vspace blankLines="0" />The SSRC of the
                  SRTCP packet containing an EKT update corresponds to the
                  SRTP master key and other parameters within that packet.</t>

                  <t hangText="DTLS-SRTP"><vspace blankLines="0" />Neither
                  SSRC nor ROC are signaled. SSRC "late binding" is used.</t>

                  <t hangText="MIKEYv2 Inband"><vspace blankLines="0" />Each
                  endpoint indicates a set of SSRCs and the ROC for SRTP
                  packets it transmits.</t>
                </list></t>
            </list></t>
        </section>
      </section>

      <section anchor="eval-sec" title="Evaluation Criteria - Security">
        <t>This section evaluates each keying mechanism on the basis of their
        security properties.</t>

        <section title="Distribution and Validation of Persistent Public Keys and Certificates">
          <t>Using persistent public keys for confidentiality and
          authentication can introduce requirements for two types of systems,
          often implemented using certificates: (1) a system to distribute
          those persistent public keys certificates, and (2) a system for
          validating those persistent public keys. We refer to the former as a
          key distribution system and the latter as an authentication
          infrastructure. In many cases, a monolithic public key
          infrastructure (PKI) is used to fulfill both of these roles.
          However, these functions can be provided by many other systems. For
          instance, key distribution may be accomplished by any public
          repository of keys. Any system in which the two endpoints have
          access to trust anchors and intermediate CA certificates that can be
          used to validate other endpoints&rsquo; certificates (including a
          system of self-signed certificates) can be used to support
          certificate validation in the below schemes.</t>

          <t>With real-time communications, it is desirable to avoid fetching
          or validating certificates that delay call setup. Rather, it is
          preferable to fetch or validate certificates in such a way that call
          setup is not delayed. For example, a certificate can be validated
          while the phone is ringing or can be validated while ring-back tones
          are being played or even while the called party is answering the
          phone and saying "hello". Even better is to avoid fetching or
          validating persistent public keys at all.</t>

          <t hangText="Avoids PKI:">SRTP key exchange mechanisms that require
          a particular authentication infrastructure to operate (whether for
          distribution or validation) are gated on the deployment of a such an
          infrastructure available to both endpoints. This means that no media
          security is achievable until such an infrastructure exists. For SIP,
          something like <xref target="SIP-CERTS">sip-certs</xref>
          might be used to obtain the certificate of a peer.</t>

          <t><list>
              <t>Note: Even if <xref
              target="SIP-CERTS">sip-certs</xref> were deployed, the
              <xref target="retargeting">retargeting problem</xref> would
              still prevent successful deployment of keying techniques which
              require the offerer to obtain the actual target's public
              key.</t>
            </list></t>

          <t>The following list compares the requirements introduced by the
          use of public-key cryptography in each keying mechanism, both for
          public key distribution and for certificate validation.</t>

          <t><list>
              <t><list style="hanging">
                  <t hangText="MIKEY-NULL"><vspace blankLines="0" />Public-key
                  cryptography is not used.</t>

                  <t hangText="MIKEY-PSK"><vspace blankLines="0" />Public-key
                  cryptography is not used. Rather, all endpoints must have
                  some way to exchange per-endpoint or per-system pre&nbhy;shared
                  keys.</t>

                  <t hangText="MIKEY-RSA"><vspace blankLines="0" />The offerer
                  obtains the intended answerer's public key before initiating
                  the call. This public key is used to encrypt the SRTP keys.
                  There is no defined mechanism for the offerer to obtain the
                  answerer's public key, although <xref
                  target="SIP-CERTS"></xref> might be viable in the
                  future.<vspace blankLines="1" />The offer may also contain a
                  certificate for the offerer, which would require an
                  authentication infrastructure in order to be validated by
                  the receiver.</t>

                  <t hangText="MIKEY-RSA-R"><vspace blankLines="0" />The offer
                  contains the offerer's certificate, and the answer contains
                  the answerer's certificate. The answerer uses the public key
                  in the certificate to encrypt the SRTP keys that will be
                  used by the offerer and the answerer. An authentication
                  infrastructure is necessary to validate the
                  certificates.</t>

                  <t hangText="MIKEY-DHSIGN"><vspace blankLines="0" />An
                  authentication infrastructure is used to authenticate the
                  public key that is included in the MIKEY message.</t>

                  <t hangText="MIKEY-DHHMAC"><vspace
                  blankLines="0" />Public-key cryptography is not used.
                  Rather, all endpoints must have some way to exchange
                  per-endpoint or per-system pre&nbhy;shared keys.</t>

                  <t hangText="MIKEYv2 in SDP"><vspace blankLines="0" />The
                  behavior will depend on which mode is picked.</t>

                  <t hangText="SDP Security Descriptions with SIPS"><vspace
                  blankLines="0" />Public-key cryptography is not used.</t>

                  <t hangText="SDP Security Descriptions with S/MIME"><vspace
                  blankLines="0" />Use of S/MIME requires that the endpoints
                  be able to fetch and validate certificates for each other.
                  The offerer must obtain the intended target's certificate
                  and encrypts the SDP offer with the public key contained in
                  target's certificate. The answerer must obtain the offerer's
                  certificate and encrypt the SDP answer with the public key
                  contained in the offerer's certificate.</t>

                  <t hangText="SDP-DH"><vspace blankLines="0" />Public-key
                  cryptography is not used.</t>

                  <t hangText="ZRTP"><vspace blankLines="0" />Public-key
                  cryptography is used (Diffie-Hellman), but without
                  dependence on persistent public keys. Thus, certificates are
                  not fetched or validated.</t>

                  <t hangText="EKT"><vspace blankLines="0" />Public-key
                  cryptography is not used by itself, but might be used by the
                  EKT bootstrapping keying mechanism (such as certain MIKEY
                  modes).</t>

                  <t hangText="DTLS-SRTP"><vspace blankLines="0" />Remote
                  party's certificate is sent in media path, and a fingerprint
                  of the same certificate is sent in the signaling path.</t>

                  <t hangText="MIKEYv2 Inband"><vspace blankLines="0" />The
                  behavior will depend on which mode is picked.</t>
                </list></t>
            </list></t>
        </section>

        <section title="Perfect Forward Secrecy">
          <t>In the context of SRTP, Perfect Forward Secrecy is the property
          that SRTP session keys that protected a previous session are not
          compromised if the static keys belonging to the endpoints are
          compromised. That is, if someone were to record your encrypted
          session content and later acquires either party's private key, that
          encrypted session content would be safe from decryption if your key
          exchange mechanism had perfect forward secrecy.</t>

          <t>The following list describes how each key exchange mechanism
          provides PFS.</t>

          <t><list>
              <t><list style="hanging">
                  <t hangText="MIKEY-NULL"><vspace blankLines="0" />Not
                  applicable; MIKEY-NULL does not have a long-term secret.</t>

                  <t hangText="MIKEY-PSK"><vspace blankLines="0" />No PFS.</t>

                  <t hangText="MIKEY-RSA"><vspace blankLines="0" />No PFS.</t>

                  <t hangText="MIKEY-RSA-R"><vspace blankLines="0" />No
                  PFS.</t>

                  <t hangText="MIKEY-DHSIGN"><vspace blankLines="0" />PFS is
                  provided with the Diffie-Hellman exchange.</t>

                  <t hangText="MIKEY-DHHMAC"><vspace blankLines="0" />PFS is
                  provided with the Diffie-Hellman exchange.</t>

                  <t hangText="MIKEYv2 in SDP"><vspace blankLines="0" />The
                  behavior will depend on which mode is picked.</t>

                  <t hangText="SDP Security Descriptions with SIPS"><vspace
                  blankLines="0" />Not applicable; SDP Security Descriptions does
                  not have a long-term secret.</t>

                  <t hangText="SDP Security Descriptions with S/MIME"><vspace
                  blankLines="0" />Not applicable; SDP Security Descriptions does
                  not have a long-term secret.</t>

                  <t hangText="SDP-DH"><vspace blankLines="0" />PFS is
                  provided with the Diffie-Hellman exchange.</t>

                  <t hangText="ZRTP"><vspace blankLines="0" />PFS is provided
                  with the Diffie-Hellman exchange.</t>

                  <t hangText="EKT"><vspace blankLines="0" />No PFS.</t>

                  <t hangText="DTLS-SRTP"><vspace blankLines="0" />PFS is
                  provided if the negotiated cipher suite uses ephemeral keys
                  (e.g., Diffie-Hellman (<xref
                  target="RFC5246">DHE_RSA</xref>) or <xref
                  target="RFC4492">Elliptic Curve Diffie-Hellman</xref>).</t>

                  <t hangText="MIKEYv2 Inband"><vspace blankLines="0" />The
                  behavior will depend on which mode is picked.</t>
                </list></t>
            </list></t>
        </section>

        <section title="Best Effort Encryption">
          <t>With best effort encryption, SRTP is used with endpoints that
          support SRTP, otherwise RTP is used.</t>

          <t>SIP needs a backwards-compatible best effort encryption in order
          for SRTP to work successfully with SIP retargeting and forking when
          there is a mix of forked or retargeted devices that support SRTP and
          don't support SRTP.</t>

          <t><list>
              <t>Consider the case of Bob, with a phone that only does RTP and
              a voice mail system that supports SRTP and RTP. If Alice calls
              Bob with an SRTP offer, Bob's RTP-only phone will reject the
              media stream (with an empty "m=" line) because Bob's phone
              doesn't understand SRTP (RTP/SAVP). Alice's phone will see this
              rejected media stream and may terminate the entire call (BYE)
              and re&nbhy;initiate the call as RTP-only, or Alice's phone may
              decide to continue with call setup with the SRTP-capable leg
              (the voice mail system). If Alice's phone decided to re&nbhy;initiate
              the call as RTP-only, and Bob doesn't answer his phone, Alice
              will then leave voice mail using only RTP, rather than SRTP as
              expected.</t>
            </list>Currently, several techniques are commonly considered as
          candidates to provide opportunistic encryption:</t>

          <t><list style="hanging">
              <t hangText="multipart/alternative"><vspace blankLines="0" />
              <xref target="MULTIPART"></xref> describes
              how to form a multipart/alternative body part in SIP. The
              significant issues with this technique are (1) that multipart
              MIME is incompatible with existing SIP proxies, firewalls,
              Session Border Controllers, and endpoints and (2) when forking,
              the <xref target="RFC3326">Heterogeneous Error Response Forking
              Problem (HERFP)</xref> causes problems if such
              non-multipart-capable endpoints were involved in the
              forking.</t>

              <t hangText="session attribute"><vspace blankLines="0" />With
              this technique, the endpoints signal their desire to do SRTP by
              signaling RTP (RTP/AVP), and using an attribute ("a=") in the
              SDP. This technique is entirely backwards compatible with
              non&nbhy;SRT&nbhy;aware endpoints, but doesn't use the RTP/SAVP protocol
              registered by <xref target="RFC3711">SRTP</xref>.</t>

              <t hangText="SDP Capability Negotiation"><vspace
              blankLines="0" /><xref
              target="SDP-CAP">SDP
              Capability Negotiation</xref> provides a backwards-compatible
              mechanism to allow offering both SRTP and RTP in a single offer.
              This is the preferred technique.</t>

              <t hangText="Probing"><vspace blankLines="0" />With this
              technique, the endpoints first establish an RTP session using
              RTP (RTP/AVP). The endpoints send probe messages, over the media
              path, to determine if the remote endpoint supports their keying
              technique. A disadvantage of probing is an active attacker can
              interfere with probes, and until probing completes (and SRTP is
              established) the media is in the clear.</t>
            </list>The preferred technique, <xref
          target="SDP-CAP">SDP Capability
          Negotiation</xref>, can be used with all key exchange mechanisms.
          What remains unique is ZRTP, which can also accomplish its best
          effort encryption by probing (sending ZRTP messages over the media
          path) or by session attribute (see "a=zrtp-hash" in <xref
          target="ZRTP"></xref>). Current implementations
          of ZRTP use probing.</t>
        </section>

        <section title="Upgrading Algorithms">
          <t>It is necessary to allow upgrading SRTP encryption and hash
          algorithms, as well as upgrading the cryptographic functions used
          for the key exchange mechanism. With SIP's offer/answer model, this
          can be computationally expensive because the offer needs to contain
          all combinations of the key exchange mechanisms (all MIKEY modes,
          SDP Security Descriptions), all SRTP cryptographic suites (AES-128,
          AES&nbhy;256) and all SRTP cryptographic hash functions (SHA&nbhy;1, SHA&nbhy;256)
          that the offerer supports. In order to do this, the offerer has to
          expend CPU resources to build an offer containing all of this
          information that becomes computationally prohibitive.</t>

          <t>Thus, it is important to keep the offerer's CPU impact fixed so
          that offering multiple new SRTP encryption and hash functions incurs
          no additional expense.</t>

          <t>The following list describes the CPU effort involved in using
          each key exchange technique.</t>

          <t><list>
              <t><list style="hanging">
                  <t hangText="MIKEY-NULL"><vspace blankLines="0" />No
                  significant computational expense.</t>

                  <t hangText="MIKEY-PSK"><vspace blankLines="0" />No
                  significant computational expense.</t>

                  <t hangText="MIKEY-RSA"><vspace blankLines="0" />For each
                  offered SRTP crypto suite, the offerer has to perform RSA
                  operation to encrypt the TGK (TEK Generation Key).</t>

                  <t hangText="MIKEY-RSA-R"><vspace blankLines="0" />For each
                  offered SRTP crypto suite, the offerer has to perform public
                  key operation to sign the MIKEY message.</t>

                  <t hangText="MIKEY-DHSIGN"><vspace blankLines="0" />For each
                  offered SRTP crypto suite, the offerer has to perform
                  Diffie-Hellman operation, and a public key operation to sign
                  the Diffie-Hellman output.</t>

                  <t hangText="MIKEY-DHHMAC"><vspace blankLines="0" />For each
                  offered SRTP crypto suite, the offerer has to perform
                  Diffie-Hellman operation.</t>

                  <t hangText="MIKEYv2 in SDP"><vspace blankLines="0" />The
                  behavior will depend on which mode is picked.</t>

                  <t hangText="SDP Security Descriptions with SIPS"><vspace
                  blankLines="0" />No significant computational expense.</t>

                  <t hangText="SDP Security Descriptions with S/MIME"><vspace
                  blankLines="0" />S/MIME requires the offerer and the
                  answerer to encrypt the SDP with the other's public key, and
                  to decrypt the received SDP with their own private key.</t>

                  <t hangText="SDP-DH"><vspace blankLines="0" />For each
                  offered SRTP crypto suite, the offerer has to perform a
                  Diffie-Hellman operation.</t>

                  <t hangText="ZRTP"><vspace blankLines="0" />The offerer has
                  no additional computational expense at all, as the offer
                  contains no information about ZRTP or might contain
                  "a=zrtp-hash".</t>

                  <t hangText="EKT"><vspace blankLines="0" />The offerer's
                  computational expense depends entirely on the EKT
                  bootstrapping mechanism selected (one or more MIKEY modes or
                  SDP Security Descriptions).</t>

                  <t hangText="DTLS-SRTP"><vspace blankLines="0" />The offerer
                  has no additional computational expense at all, as the offer
                  contains only a fingerprint of the certificate that will be
                  presented in the DTLS exchange.</t>

                  <t hangText="MIKEYv2 Inband"><vspace blankLines="0" />The
                  behavior will depend on which mode is picked.</t>
                </list></t>
            </list></t>
        </section>
      </section>
    </section>

    <section anchor="ofs" title="Out-of-Scope">
      <t>The compromise of an endpoint that has access to decrypted media
      (e.g., SIP user agent, transcoder, recorder) is out of scope of this
      document. Such a compromise might be via privilege escalation,
      installation of a virus or trojan horse, or similar attacks.</t>

      <section anchor="conferencing" title="Shared Key Conferencing">
        <t>The consensus on the RTPSEC mailing list was to concentrate on
        unicast, point-to-point sessions. Thus, there are no requirements
        related to shared key conferencing. This section is retained for
        informational purposes.</t>

        <t>For efficient scaling, large audio and video conference bridges
        operate most efficiently by encrypting the current speaker once and
        distributing that stream to the conference attendees. Typically,
        inactive participants receive the same streams -- they hear (or see)
        the active speaker(s), and the active speakers receive distinct
        streams that don't include themselves. In order to maintain
        the confidentiality of such conferences where listeners share a common
        key, all listeners must rekeyed when a listener joins or leaves a
        conference.</t>

        <t>An important use case for mixers/translators is a conference
        bridge:</t>

        <t><figure anchor="figure_centralized_keying"
            title="Centralized Keying">
            <artwork align="center"><![CDATA[
            +----+
A --- 1 --->|    |
  <-- 2 ----| M  |
            | I  |
B --- 3 --->| X  |
  <-- 4 ----| E  |
            | R  |
C --- 5 --->|    |
  <-- 6 ----|    |
            +----+
              ]]></artwork>
          </figure></t>

        <t>In the figure above, 1, 3, and 5 are RTP media contributions from
        Alice, Bob, and Carol, and 2, 4, and 6 are the RTP flows to those
        devices carrying the "mixed" media.</t>

        <t>Several scenarios are possible:</t>

        <t><list style="letters">
            <t>Multiple inbound sessions: 1, 3, and 5 are distinct RTP
            sessions,</t>

            <t>Multiple outbound sessions: 2, 4, and 6 are distinct RTP
            sessions,</t>

            <t>Single inbound session: 1, 3, and 5 are just different sources
            within the same RTP session,</t>

            <t>Single outbound session: 2, 4, and 6 are different flows of the
            same (multi-unicast) RTP session.</t>
          </list></t>

        <t>If there are multiple inbound sessions and multiple outbound
        sessions (scenarios a and b), then every keying mechanism behaves as
        if the mixer were an endpoint and can set up a point-to-point secure
        session between the participant and the mixer. This is the simplest
        situation, but is computationally wasteful, since SRTP processing has
        to be done independently for each participant. The use of multiple
        inbound sessions (scenario a) doesn't waste computational resources,
        though it does consume additional cryptographic context on the mixer
        for each participant and has the advantage of data origin
        authentication.</t>

        <t>To support a single outbound session (scenario d), the mixer has to
        dictate its encryption key to the participants. Some keying mechanisms
        allow the transmitter to determine its own key, and others allow the
        offerer to determine the key for the offerer and answerer. Depending
        on how the call is established, the offerer might be a participant
        (such as a participant dialing into a conference bridge) or the
        offerer might be the mixer (such as a conference bridge calling a
        participant). The use of offerless INVITEs may help some keying
        mechanisms reverse the role of offerer/answerer. A difficulty,
        however, is knowing a priori if the role should be reversed for a
        particular call. The significant advantage of a single outbound
        session is the number of SRTP encryption operations remains constant
        even as the number of participants increases. However, a disadvantage
        is that data origin authentication is lost, allowing any participant
        to spoof the sender (because all participants know the sender's SRTP
        key).</t>
      </section>
    </section>
  </back>
</rfc>
