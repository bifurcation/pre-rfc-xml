<?xml version="1.0" encoding="US-ASCII"?>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc strict="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="no"?>
<?rfc subcompact="no"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" number="8323" category="std" updates="7641, 7959"
     submissionType="IETF" consensus="yes">

  <front>
    <title abbrev="TCP/TLS/WebSockets Transports for CoAP">CoAP (Constrained
    Application Protocol) over TCP, TLS, and WebSockets</title>

    <author initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </author>

    <author initials="S." surname="Lemay" fullname="Simon Lemay">
      <organization>Zebra Technologies</organization>
      <address>
        <postal>
          <street>820 W. Jackson Blvd. Suite 700</street>
          <city>Chicago</city>
          <region>IL</region>
          <code>60607</code>
          <country>United States of America</country>
        </postal>
        <phone>+1-847-634-6700</phone>
        <email>slemay@zebra.com</email>
      </address>
    </author>

    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization>ARM Ltd.</organization>
      <address>
        <postal>
          <street>110 Fulbourn Road</street>
          <city>Cambridge</city>
          <code>CB1 9NJ</code>
          <country>United Kingdom</country>
        </postal>
        <email>Hannes.tschofenig@gmx.net</email>
        <uri>http://www.tschofenig.priv.at</uri>
      </address>
    </author>

    <author initials="K." surname="Hartke" fullname="Klaus Hartke">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63905</phone>
        <email>hartke@tzi.org</email>
      </address>
    </author>

    <author initials="B." surname="Silverajan" fullname="Bilhanan Silverajan">
      <organization>Tampere University of Technology</organization>
      <address>
        <postal>
          <street>Korkeakoulunkatu 10</street>
          <city>Tampere</city>
          <code>FI-33720</code>
          <country>Finland</country>
        </postal>
        <email>bilhanan.silverajan@tut.fi</email>
      </address>
    </author>

    <author initials="B." surname="Raymor" fullname="Brian Raymor" role="editor">
      <organization></organization>
      <address>
        <email>brianraymor@hotmail.com</email>
      </address>
    </author>

    <date year="2018" month="February"/>

<keyword>CoAP</keyword>
<keyword>Constrained Application Protocol</keyword>
<keyword>REST</keyword>
<keyword>IoT</keyword>
<keyword>Internet of Things</keyword>
<keyword>NAT Traversal</keyword>
<keyword>CoAP in Browsers</keyword>

    <abstract>
<t>The Constrained Application Protocol (CoAP), although inspired by HTTP,
was designed to use UDP instead of TCP. The message layer of CoAP over UDP
includes support for reliable delivery, simple congestion control, and
flow control.</t>

<t>Some environments benefit from the availability of CoAP carried over
reliable transports such as TCP or Transport Layer Security (TLS). This
document outlines the changes required to use CoAP over TCP, TLS, and
WebSockets transports. It also formally updates RFC 7641 for use with these
transports and RFC 7959 to enable the use of larger messages over a reliable
transport.</t>
    </abstract>

  </front>

  <middle>

<section anchor="introduction" title="Introduction">

<t>The <xref target="RFC7252">Constrained Application Protocol (CoAP)</xref>
was designed for Internet of Things (IoT) deployments, assuming that UDP
<xref target="RFC0768"/> can be used unimpeded as can the Datagram Transport
Layer Security (DTLS) protocol <xref target="RFC6347"/> over UDP. The use of
CoAP over UDP is focused on simplicity, has a low code footprint, and has a
small over&nbhy;the&nbhy;wire message size.</t>

<t>The primary reason for introducing CoAP over TCP <xref target="RFC0793"/>
and TLS <xref target="RFC5246"/> is that some networks do not forward UDP
packets. Complete blocking of UDP happens in between about 2% and 4% of
terrestrial access networks, according to <xref target="EK2016"/>. UDP
impairment is especially concentrated in enterprise networks and networks in 
geographic regions with otherwise challenged connectivity. Some networks also 
rate-limit UDP traffic, as reported in <xref target="BK2015"/>, and deployment
investigations related to the standardization of Quick UDP Internet
Connections (QUIC) revealed numbers around 0.3% <xref target="SW2016"/>.</t>

<t>The introduction of CoAP over TCP also leads to some additional
effects that may be desirable in a specific deployment:</t>

<t><list style="symbols">
<t>Where NATs are present along the communication path, CoAP over TCP leads to 
different NAT traversal behavior than CoAP over UDP. NATs often calculate
expiration timers based on the transport&nbhy;layer protocol being used by
application protocols. Many NATs maintain TCP-based NAT bindings for longer
periods based on the assumption that a transport&nbhy;layer protocol, such as
TCP, offers additional information about the session lifecycle. UDP, on the
other hand, does not provide such information to a NAT and timeouts tend to be
much shorter <xref target="HomeGateway"/>. According to <xref
target="HomeGateway"/>, the mean for TCP and UDP NAT binding timeouts is
386&nbsp;minutes (TCP) and 160&nbsp;seconds (UDP).  Shorter timeout values
require keepalive messages to be sent more frequently. Hence, the use of
CoAP over TCP requires less-frequent transmission of keepalive messages.</t>

<t>TCP utilizes mechanisms for congestion control and flow control that are
more sophisticated than the default mechanisms provided by CoAP over UDP;
these TCP mechanisms are useful for the transfer of larger payloads.
(However, work is ongoing to add advanced congestion control to
CoAP over UDP as well; see <xref target="CoCoA"/>.)</t>
</list></t>

<t>Note that the use of CoAP over UDP (and CoAP over DTLS over UDP) is still
the recommended transport for use in constrained node networks, particularly
when used in concert with block&nbhy;wise transfer. CoAP over TCP is
applicable for those cases where the networking infrastructure leaves no other
choice. The use of CoAP over TCP leads to a larger code size, more round
trips, increased RAM requirements, and larger packet sizes. Developers
implementing CoAP over TCP are encouraged to consult <xref
target="TCP-in-IoT"/> for guidance on low&nbhy;footprint TCP implementations
for IoT devices.</t>

<t>Standards based on CoAP, such as Lightweight Machine to Machine <xref
target="LWM2M"/>, currently use CoAP over UDP as a transport; adding support
for CoAP over TCP enables them to address the issues above for specific
deployments and to protect investments in existing CoAP implementations and
deployments.</t>

<t>Although HTTP/2 could also potentially address the need for enterprise
firewall traversal, there would be additional costs and delays introduced by
such a transition from CoAP to HTTP/2. Currently, there are also fewer HTTP/2
implementations available for constrained devices in comparison to CoAP. Since
CoAP also supports group communication using IP-layer multicast and unreliable
communication, IoT devices would have to support HTTP/2 in addition to
CoAP.</t>

<t>Furthermore, CoAP may be integrated into a web environment where the
front&nbsp;end uses CoAP over UDP from IoT devices to a cloud infrastructure
and then CoAP over TCP between the back-end services. A TCP-to-UDP gateway can
be used at the cloud boundary to communicate with the UDP-based IoT device.</t>

<t>Finally, CoAP applications running inside a web browser may be without
access to connectivity other than HTTP.  In this case, the WebSocket
Protocol <xref target="RFC6455"/> may be used to transport CoAP requests and
responses, as opposed to cross-proxying them via HTTP to an
HTTP&nbhy;to&nbhy;CoAP cross-proxy. This preserves the functionality of CoAP
without translation -- in particular, the Observe Option <xref
target="RFC7641"/>.</t>

<t>To address the above-mentioned deployment requirements, this document
defines how to transport CoAP over TCP, CoAP over TLS, and CoAP over
WebSockets. For these cases, the reliability offered by the transport protocol
subsumes the reliability functions of the message layer used for CoAP over
UDP. (Note that for both a reliable transport and the message layer for
CoAP&nbsp;over&nbsp;UDP, the reliability offered is per transport hop: where
proxies -- see Sections&nbsp;5.7 and 10 of <xref target="RFC7252"/> -- are
involved, that layer's reliability function does not extend end to end.) <xref
target="fig-layering"/> illustrates the layering:</t>

<figure title="Layering of CoAP over Reliable Transports" anchor="fig-layering"><artwork align="center"><![CDATA[
  +--------------------------------+
  |          Application           |
  +--------------------------------+
  +--------------------------------+
  |  Requests/Responses/Signaling  |  CoAP (RFC 7252) / This Document
  |--------------------------------|
  |        Message Framing         |  This Document
  +--------------------------------+
  |      Reliable Transport        |
  +--------------------------------+
]]></artwork></figure>

<t>This document specifies how to access resources using CoAP requests
and responses over the TCP, TLS, and WebSocket protocols. This allows
connectivity-limited applications to obtain end-to-end CoAP
connectivity either (1)&nbsp;by communicating CoAP directly with a CoAP
server accessible over a TCP, TLS, or WebSocket connection or
(2)&nbsp;via a CoAP intermediary that proxies CoAP requests and
responses between different transports, such as between WebSockets
and UDP.</t>

<t><xref target="observing"/> updates <xref target="RFC7641"/>
("Observing Resources in the Constrained Application Protocol (CoAP)")
for use with CoAP over reliable transports. <xref target="RFC7641"/> is
an extension to CoAP that enables CoAP clients to "observe" a resource on a
CoAP server. (The CoAP client retrieves a representation of a resource and
registers to be notified by the CoAP server when the representation is
updated.)</t>

</section>

<section anchor="conventions-and-terminology" title="Conventions and Terminology">

  <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
  "SHALL&nbsp;NOT", "SHOULD", "SHOULD&nbsp;NOT", "RECOMMENDED",
  "NOT&nbsp;RECOMMENDED", "MAY", and "OPTIONAL" in this document
  are to be interpreted as described in BCP&nbsp;14
  <xref format="default" pageno="false" target="RFC2119"/>
  <xref format="default" pageno="false" target="RFC8174"/> when,
  and only when, they appear in all capitals, as shown here.</t>

<t>This document assumes that readers are familiar with the terms and
concepts that are used in <xref target="RFC6455"/>, <xref target="RFC7252"/>,
<xref target="RFC7641"/>, and <xref target="RFC7959"/>.</t>

<t>The term "reliable transport" is used only to refer to transport protocols,
such as TCP, that provide reliable and ordered delivery of a
byte&nbsp;stream.</t>

<t><list style="hanging">
  <t hangText='Block-wise Extension for Reliable Transport (BERT):'>
  <vspace blankLines='0'/>
  Extends <xref target="RFC7959"/> to enable the use of larger messages
  over a reliable transport.</t>
  <t hangText='BERT Option:'><vspace blankLines='0'/>
  A Block1 or Block2 option that includes an SZX (block size)
  value&nbsp;of&nbsp;7.</t>
  <t hangText='BERT Block:'><vspace blankLines='0'/>
  The payload of a CoAP message that is affected by a BERT Option in
  descriptive usage (see Section&nbsp;2.1 of <xref target="RFC7959"/>).</t>
  <t hangText='Transport Connection:'><vspace blankLines='0'/>
  Underlying reliable byte-stream connection, as directly provided by
  TCP or indirectly provided via TLS or WebSockets.</t>
  <t hangText='Connection:'><vspace blankLines='0'/>
  Transport Connection, unless explicitly qualified otherwise.</t>
  <t hangText='Connection Initiator:'><vspace blankLines='0'/>
  The peer that opens a Transport Connection, i.e., the
TCP active opener, TLS client, or WebSocket client.</t>
  <t hangText='Connection Acceptor:'><vspace blankLines='0'/>
  The peer that accepts the Transport Connection opened by
the other peer, i.e., the TCP passive opener, TLS server, or
WebSocket server.</t>
</list></t>

</section>
<section anchor="coap-over-tcp" title="CoAP over TCP">

<t>The request/response interaction model of CoAP over TCP is the same as
CoAP over UDP. The primary differences are in the message layer. The message
layer of CoAP over UDP supports optional reliability by defining four types
of messages: Confirmable, Non&nbhy;confirmable, Acknowledgment, and Reset. In
addition, messages include a Message&nbsp;ID to relate Acknowledgments to
Confirmable messages and to detect duplicate messages.</t>

<t>Management of the transport connections is left to the application,
i.e., the present specification does not describe how an application decides
to open a connection or to reopen another one in the presence of
failures (or what it would deem to be a failure; see also
<xref target="sec-ping"/>).  In particular, the Connection Initiator need not
be the client of the first request placed on the connection. Some
implementations will want to implement dynamic connection management similar
to the technique described in Section&nbsp;6 of <xref target="RFC7230"/> for
HTTP: opening a connection when the first client request is ready to be sent,
reusing that connection for subsequent messages until no more messages are
sent for a certain time period and no requests are outstanding (possibly
with a configurable idle time), and then starting a release process
(orderly shutdown) (see <xref target="sec-release"/>). In implementations
of this kind, connection releases or aborts may not be indicated as errors to
the application but may simply be handled by automatic reconnection once the
need arises again. Other implementations may be based on configured
connections that are kept open continuously and lead to management system
notifications on release or abort. The protocol defined in the present
specification is intended to work with either model (or other,
application-specific connection management models).</t>

<section anchor="messaging-model" title="Messaging Model">

<t>Conceptually, CoAP over TCP replaces most of the message layer of CoAP over
UDP with a framing mechanism on top of the byte&nbsp;stream provided by
TCP/TLS, conveying the length information for each message that, on datagram
transports, is provided by the UDP/DTLS datagram layer.</t>

<t>TCP ensures reliable message transmission, so the message layer of CoAP
over TCP is not required to support Acknowledgment messages or to detect
duplicate messages. As a result, both the Type and Message&nbsp;ID fields
are no longer required and are removed from the message format for
CoAP&nbsp;over&nbsp;TCP.</t>

<t><xref target="fig-flow-comparison"/> illustrates the difference between
CoAP over UDP and CoAP over reliable transports. The removed Type and Message
ID fields are indicated by dashes.</t>

<figure title="Comparison between CoAP over Unreliable Transports and
 CoAP&nbsp;over Reliable Transports" anchor="fig-flow-comparison"><artwork align="center"><![CDATA[
CoAP Client       CoAP Server     CoAP Client       CoAP Server
    |                    |            |                    |
    |   CON [0xbc90]     |            | (-------) [------] |
    | GET /temperature   |            | GET /temperature   |
    |   (Token 0x71)     |            |   (Token 0x71)     |
    +------------------->|            +------------------->|
    |                    |            |                    |
    |   ACK [0xbc90]     |            | (-------) [------] |
    |   2.05 Content     |            |   2.05 Content     |
    |   (Token 0x71)     |            |   (Token 0x71)     |
    |     "22.5 C"       |            |     "22.5 C"       |
    |<-------------------+            |<-------------------+
    |                    |            |                    |

        CoAP over UDP                   CoAP over reliable
                                            transports
]]></artwork></figure>

</section>
<section anchor="tcp-message-format" title="Message Format">

<t>The CoAP message format defined in <xref target="RFC7252"/>, as shown in 
<xref target="CoAP-Header"/>, relies on the datagram transport (UDP, or DTLS
over UDP) for keeping the individual messages separate and for providing 
length information.</t>

<figure title="CoAP Message Format as Defined in RFC 7252" anchor="CoAP-Header"><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Ver| T |  TKL  |      Code     |          Message ID           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Token (if any, TKL bytes) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Options (if any) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1 1 1 1 1 1 1 1|    Payload (if any) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The message format for CoAP over TCP is very similar to the format
specified for CoAP over UDP. The differences are as follows:</t>

<t><list style="symbols">
  <t>Since the underlying TCP connection provides retransmissions and
  deduplication, there is no need for the reliability mechanisms
  provided by CoAP over UDP. The Type (T) and Message ID fields in
  the CoAP message header are elided.</t>
  <t>The Version (Vers) field is elided as well. In contrast to the message
  format of CoAP over UDP, the message format for CoAP over TCP does not
  include a version number. CoAP is defined in <xref target="RFC7252"/> with a
  version number of 1. At this time, there is no known reason to support
  version numbers different from 1. If version negotiation needs to be
  addressed in the future, Capabilities and Settings Messages (CSMs)
  (see <xref target="csm"/>) have been specifically designed to enable such a
  potential feature.</t>
  <t>In a stream-oriented transport protocol such as TCP, a form of message 
  delimitation is needed. For this purpose, CoAP over TCP introduces a 
  length field with variable size. <xref target="fig-frame"/> shows the
  adjusted CoAP message format with a modified structure for the fixed header
  (first 4&nbsp;bytes of the header for CoAP over UDP), which includes the
  length information of variable size.</t>
</list></t>

<figure title="CoAP Frame for Reliable Transports" anchor="fig-frame"><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Len  |  TKL  | Extended Length (if any, as chosen by Len) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Code     | Token (if any, TKL bytes) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Options (if any) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1 1 1 1 1 1 1 1|    Payload (if any) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='Length (Len):'>
  4-bit unsigned integer. A value between 0 and 12 inclusive indicates the
length of the message in bytes, starting with the first bit of the Options
field. Three values are reserved for special constructs:

      <list style="hanging">
        <t hangText='13:'>
        An 8-bit unsigned integer (Extended Length) follows the initial byte
	and indicates the length of options/payload minus&nbsp;13.</t>
        <t hangText='14:'>
        A 16-bit unsigned integer (Extended Length) in network byte order
	follows the initial byte and indicates the length of options/payload
	minus 269.</t>
        <t hangText='15:'>
        A 32-bit unsigned integer (Extended Length) in network byte order
	follows the initial byte and indicates the length of options/payload
	minus 65805.</t>
      </list>
  </t>
</list></t>

<t>The encoding of the Length field is modeled after the Option Length field
of the CoAP Options (see Section 3.1 of <xref target="RFC7252"/>).</t>

<t>For simplicity, a Payload Marker (0xFF) is shown in <xref
target="fig-frame"/>; the Payload Marker indicates the start of the optional
payload and is absent for zero-length payloads (see Section 3 of <xref
target="RFC7252"/>). (If present, the Payload Marker is included in the
message length, which counts from the start of the Options field to the end of
the Payload field.)</t>

<t>For example, a CoAP message just containing a 2.03 code with the
Token 7f and no options or payload is encoded as shown in <xref
target="fig-frame2"/>.</t>

<figure title="CoAP Message with No Options or Payload" anchor="fig-frame2"><artwork><![CDATA[
 0                   1                   2
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      0x01     |      0x43     |      0x7f     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 Len   =    0 ------>  0x01
 TKL   =    1 ___/
 Code  =  2.03     --> 0x43
 Token =               0x7f
]]></artwork></figure>

<t>The semantics of the other CoAP header fields are left unchanged.</t>

</section>
<section anchor="message-transmission" title="Message Transmission">

<t>Once a Transport Connection is established, each endpoint MUST send a
CSM (see <xref target="csm"/>) as its first message on the connection. This
message establishes the initial settings and capabilities for the endpoint,
such as maximum message size or support for block-wise transfers. The absence
of options in the CSM indicates that base values are assumed.</t>

<t>To avoid a deadlock, the Connection Initiator MUST NOT wait for the
Connection Acceptor to send its initial CSM before sending its own initial
CSM.  Conversely, the Connection Acceptor MAY wait for the Connection
Initiator to send its initial CSM before sending its own initial CSM.</t>

<t>To avoid unnecessary latency, a Connection Initiator MAY send
additional messages after its initial CSM without waiting to receive
the Connection Acceptor's CSM; however, it is important to note that
the Connection Acceptor's CSM might indicate capabilities that impact how the
Connection Initiator is expected to communicate with the Connection
Acceptor. For example, the Connection Acceptor's CSM could indicate
a Max&nbhy;Message&nbhy;Size Option (see <xref target="max-message-size"/>)
that is smaller than the base value (1152) in order to limit both buffering
requirements and head-of-line blocking.</t>

<t>Endpoints MUST treat a missing or invalid CSM as a connection error and
abort the connection (see <xref target="sec-abort"/>).</t>

<t>CoAP requests and responses are exchanged asynchronously over the
Transport Connection. A CoAP client can send multiple requests
without waiting for a response, and the CoAP server can return
responses in any order. Responses MUST be returned over the same
connection as the originating request. Each concurrent request is
differentiated by its Token, which is scoped locally to the
connection.</t>

<t>The Transport Connection is bidirectional, so requests can be sent
by both the entity that established the connection (Connection Initiator)
and the remote host (Connection Acceptor). If one side does not implement a
CoAP server, an error response MUST be returned for all CoAP requests from the
other side. The simplest approach is to always return 5.01 (Not
Implemented). A more elaborate mock server could also return 4.xx responses
such as 4.04 (Not Found) or 4.02 (Bad Option) where appropriate.</t>

<t>Retransmission and deduplication of messages are provided by TCP.</t>

</section>

<section anchor="liveliness" title="Connection Health">

<t>Empty messages (Code 0.00) can always be sent and MUST be ignored by the
recipient. This provides a basic keepalive function that can refresh NAT
bindings.</t>

<t>If a CoAP client does not receive any response for some time after
sending a CoAP request (or, similarly, when a client observes a
resource and it does not receive any notification for some time),
it can send a CoAP Ping Signaling message (see <xref target="sec-ping"/>) to
test the Transport Connection and verify that the CoAP server is
responsive.</t>

<t>When the underlying Transport Connection is closed or reset, the signaling
state and any observation state (see <xref target="observe-cancel"/>)
associated with the connection are removed. Messages that are in&nbsp;flight
may or may not be lost.</t>

</section>
</section>

<section anchor="websockets-overview" title="CoAP over WebSockets">

<t>CoAP over WebSockets is intentionally similar to CoAP over TCP; therefore,
this section only specifies the differences between the transports.</t>

<t>CoAP over WebSockets can be used in a number of configurations. The
most basic configuration is a CoAP client retrieving or updating a
CoAP resource located on a CoAP server that exposes a WebSocket endpoint
(see <xref target="arch-1"/>). The CoAP client acts as the WebSocket client,
establishes a WebSocket connection, and sends a CoAP request, to which the
CoAP server returns a CoAP response. The WebSocket connection can be used for
any number of requests.</t>

<figure title="CoAP Client (WebSocket Client) Accesses CoAP Server (WebSocket Server)" anchor="arch-1"><artwork align="center"><![CDATA[
 ___________                            ___________
|           |                          |           |
|          _|___      requests      ___|_          |
|   CoAP  /  \  \  ------------->  /  /  \  CoAP   |
|  Client \__/__/  <-------------  \__\__/ Server  |
|           |         responses        |           |
|___________|                          |___________|
        WebSocket  =============>  WebSocket
          Client     Connection     Server
]]></artwork></figure>

<t>The challenge with this configuration is how to identify a resource in the
namespace of the CoAP server. When the WebSocket Protocol is used by
a dedicated client directly (i.e., not from a web page through a web browser),
the client can connect to any WebSocket endpoint.
Sections&nbsp;<xref target="coap-ws-scheme" format="counter"/> and
<xref target="coaps-ws-scheme" format="counter"/> define new URI schemes
that enable the client to identify both a WebSocket endpoint and the path and
query of the CoAP resource within that endpoint.</t>

<t>Another possible configuration is to set up a CoAP forward proxy
at the WebSocket endpoint. Depending on what transports are available
to the proxy, it could forward the request to a CoAP server with a
CoAP UDP endpoint (<xref target="arch-2"/>), an SMS endpoint (a.k.a. mobile
phone),

or even another WebSocket endpoint. The CoAP client specifies the resource to be
updated or retrieved in the Proxy-Uri Option.</t>

<figure title="CoAP Client (WebSocket Client) Accesses CoAP Server
 (UDP&nbsp;Server) via a CoAP Proxy (WebSocket Server / UDP Client)" anchor="arch-2"><artwork align="center"><![CDATA[
 ___________                ___________                ___________
|           |              |           |              |           |
|          _|___        ___|_         _|___        ___|_          |
|   CoAP  /  \  \ ---> /  /  \ CoAP  /  \  \ ---> /  /  \  CoAP   |
|  Client \__/__/ <--- \__\__/ Proxy \__/__/ <--- \__\__/ Server  |
|           |              |           |              |           |
|___________|              |___________|              |___________|
        WebSocket ===> WebSocket      UDP            UDP
          Client        Server      Client          Server
]]></artwork></figure>

<t>A third possible configuration is a CoAP server running inside a web browser
(<xref target="arch-3"/>). The web browser initially connects to a WebSocket endpoint and
is then reachable through the WebSocket server. When no connection exists, the
CoAP server is unreachable. Because the WebSocket server is the only way to
reach the CoAP server, the CoAP proxy should be a reverse&nbhy;proxy.</t>

<figure title="CoAP Client (UDP Client) Accesses CoAP Server (WebSocket
 Client) via a CoAP Proxy (UDP Server / WebSocket Server)" anchor="arch-3"><artwork align="center"><![CDATA[
 ___________                ___________                ___________
|           |              |           |              |           |
|          _|___        ___|_         _|___        ___|_          |
|   CoAP  /  \  \ ---> /  /  \ CoAP  /  /  \ ---> /  \  \  CoAP   |
|  Client \__/__/ <--- \__\__/ Proxy \__\__/ <--- \__/__/ Server  |
|           |              |           |              |           |
|___________|              |___________|              |___________|
           UDP            UDP      WebSocket <=== WebSocket
         Client          Server      Server        Client
]]></artwork></figure>

<t>Further configurations are possible, including those where a
WebSocket connection is established through an HTTP proxy.</t>

<section anchor="handshake" title="Opening Handshake">

<t>Before CoAP requests and responses are exchanged, a WebSocket
connection is established as defined in Section 4 of <xref target="RFC6455"/>.
<xref target="handshake-example"/> shows an example.</t>

<t>The WebSocket client MUST include the subprotocol name "coap" in
the list of protocols; this indicates support for the protocol
defined in this document.</t>

<t>The WebSocket client includes the hostname of the WebSocket server
in the Host header field of its handshake as per <xref target="RFC6455"/>. The
Host header field also indicates the default value of the Uri-Host Option in
requests from the WebSocket client to the WebSocket server.</t>

<figure title="Example of an Opening Handshake" anchor="handshake-example"><artwork align="center"><![CDATA[
GET /.well-known/coap HTTP/1.1
Host: example.org
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Protocol: coap
Sec-WebSocket-Version: 13

HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: coap
]]></artwork></figure>

</section>
<section anchor="websocket-message-format" title="Message Format">

<t>Once a WebSocket connection is established, CoAP requests and
responses can be exchanged as WebSocket messages. Since CoAP uses a
binary message format, the messages are transmitted in binary data
frames as specified in Sections 5 and 6 of <xref target="RFC6455"/>.</t>

<t>The message format shown in <xref target="ws-message-format"/> is
the same as the message format for CoAP&nbsp;over&nbsp;TCP (see
<xref target="tcp-message-format"/>), with one change: the Length (Len)
field MUST be set to zero, because the WebSocket frame contains the
length.</t>

<figure title="CoAP Message Format over WebSockets" anchor="ws-message-format"><artwork align="center"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Len=0 |  TKL  |      Code     |    Token (TKL bytes) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Options (if any) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1 1 1 1 1 1 1 1|    Payload (if any) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>As with CoAP over TCP, the message format for CoAP over WebSockets
eliminates the Version field defined in CoAP over UDP. If CoAP version
negotiation is required in the future, CoAP over WebSockets can address
the requirement by defining a new subprotocol identifier that is
negotiated during the opening handshake.</t>

<t>Requests and responses can be fragmented as specified in
Section&nbsp;5.4 of <xref target="RFC6455"/>, though typically they are
sent unfragmented, as they tend to be small and fully buffered before
transmission. The WebSocket Protocol does not provide means for
multiplexing. If it is not desirable for a large message to monopolize the
connection, requests and responses can be transferred in a block-wise fashion
as defined in <xref target="RFC7959"/>.</t>

</section>
<section anchor="requests-responses" title="Message Transmission">

<t>As with CoAP over TCP, each endpoint MUST send a CSM (see <xref
target="csm"/>) as its first message on the WebSocket connection.</t>

<t>CoAP requests and responses are exchanged asynchronously over the
WebSocket connection. A CoAP client can send multiple requests
without waiting for a response, and the CoAP server can return
responses in any order. Responses MUST be returned over the same
connection as the originating request. Each concurrent request is
differentiated by its Token, which is scoped locally to the
connection.</t>

<t>The connection is bidirectional, so requests can be sent
by both the entity that established the connection and the remote host.</t>

<t>As with CoAP over TCP, retransmission and deduplication of messages are
provided by the WebSocket Protocol. CoAP over WebSockets therefore does not
make a distinction between Confirmable messages and
Non&nbhy;confirmable messages and does not provide Acknowledgment or
Reset messages.</t>

</section>

<section anchor="ws-liveliness" title="Connection Health">

<t>As with CoAP over TCP, a CoAP client can test the health of the
connection for CoAP&nbsp;over&nbsp;WebSockets by sending a
CoAP Ping Signaling message (<xref target="sec-ping"/>). 
To ensure that redundant maintenance traffic is not transmitted,
WebSocket Ping and unsolicited Pong frames
(Section&nbsp;5.5 of <xref target="RFC6455"/>) SHOULD&nbsp;NOT be used.</t>

</section>
</section>

<section anchor="signaling" title="Signaling">

<t>Signaling messages are specifically introduced only for CoAP over reliable
transports to allow peers to:</t>

<t><list style="symbols">
  <t>Learn related characteristics, such as maximum message size for the
  connection.</t>
  <t>Shut down the connection in an orderly fashion.</t>
  <t>Provide diagnostic information when terminating a connection in response
  to a serious error condition.</t>
</list></t>

<t>Signaling is a third basic kind of message in CoAP, after requests and
responses.  Signaling messages share a common structure with the existing CoAP
messages. There are a code, a Token, options, and an optional payload.</t>

<t>(See Section 3 of <xref target="RFC7252"/> for the overall structure of
the message format, option format, and option value formats.)</t>

<section anchor="signaling-codes" title="Signaling Codes">

<t>A code in the 7.00-7.31 range indicates a Signaling message. Values in
this range are assigned by the "CoAP Signaling Codes" subregistry (see <xref
target="message-codes"/>).</t>

<t>For each message, there are a sender and a peer receiving the message.</t>

<t>Payloads in Signaling messages are diagnostic payloads as defined in
Section&nbsp;5.5.2 of <xref target="RFC7252"/>, unless otherwise defined by a
Signaling message option.</t>

</section>
<section anchor="signaling-option-numbers" title="Signaling Option Numbers">

<t>Option Numbers for Signaling messages are specific to the message
code. They do not share the number space with CoAP options for
request/response messages or with Signaling messages using other
codes.</t>

<t>Option Numbers are assigned by the "CoAP Signaling Option Numbers"
subregistry (see <xref target="option-codes"/>).</t>

<t>Signaling Options are elective or critical as defined in
Section&nbsp;5.4.1 of <xref target="RFC7252"/>. If a Signaling Option is
critical and not understood by the receiver, it MUST abort the connection (see
<xref target="sec-abort"/>). If the option is understood but cannot be
processed, the option documents the behavior.</t>

</section>

<section anchor="csm" title="Capabilities and Settings Messages (CSMs)">

<t>CSMs are used for two purposes:</t>

<t><list style="symbols">
  <t>Each capability option indicates one capability of the sender to the
  recipient.</t>
  <t>Each setting option indicates a setting that will be applied by the
  sender.</t>
</list></t>

<t>One CSM MUST be sent by each endpoint at the start of the
Transport Connection. Additional CSMs MAY be sent at any other time by either
endpoint over the lifetime of the connection.</t>

<t>Both capability options and setting options are cumulative. A CSM does not
invalidate a previously sent capability indication or setting even if it is
not repeated. A capability message without any option is a no-operation (and
can be used as such). An option that is sent might override a previous value
for the same option. The option defines how to handle this case if needed.</t>

<t>Base values are listed below for CSM options. These are the values for the
capability and settings before any CSMs send a modified value.</t>

<t>These are not default values (as defined in Section&nbsp;5.4.4 in
<xref target="RFC7252"/>) for the option. Default values apply on a
per-message basis and are thus reset when the value is not present in a
given&nbsp;CSM.</t>

<t>CSMs are indicated by the 7.01 (CSM) code; see
<xref target="signal-codes"/>.</t>

<section anchor="max-message-size" title="Max-Message-Size Capability Option">

<t>The sender can use the elective Max-Message-Size Option to indicate
the maximum size of a message in bytes that it can receive.  The
message size indicated includes the entire message, starting from the
first byte of the message header and ending at the end of the message
payload.</t>

<t>(Note that there is no relationship of the message size to the overall
request or response body size that may be achievable in block-wise
transfer.  For example, the exchange depicted in <xref target="fig-bert1"/>
(<xref target="example-get-with-bert-blocks"/>) can be performed if the CoAP
client indicates a value of around 6000&nbsp;bytes for the
Max-Message-Size Option, even though the total body size transferred to the
client is 3072 + 5120 + 4711 = 12903 bytes.)</t>

<texttable>
      <ttcol width='2em' align='right'>#</ttcol>
      <ttcol align='left'>C</ttcol>
      <ttcol align='left'>R</ttcol>
      <ttcol width='8em' align='left'>Applies to</ttcol>
      <ttcol width='17em' align='left'>Name</ttcol>
      <ttcol width='6em' align='right'>Format</ttcol>
      <ttcol width='6em' align='right'>Length</ttcol>
      <ttcol width='7em' align='left'>Base Value</ttcol>
      <c>2</c>
      <c>&#160;</c>
      <c>&#160;</c>
      <c>CSM</c>
      <c>Max-Message-Size</c>
      <c>uint</c>
      <c>0-4</c>
      <c>1152</c>

<postamble>C=Critical, R=Repeatable</postamble>
</texttable>

<t>As per Section 4.6 of <xref target="RFC7252"/>, the base value (and the
value used when this option is not implemented) is 1152.</t>

<t>The active value of the Max-Message-Size Option is replaced each time the
option is sent with a modified value. Its starting value is its base value.</t>

</section>
<section anchor="block-wise-transfer-capability-option" title="Block-Wise-Transfer Capability Option">

<texttable>
      <ttcol width='2em' align='right'>#</ttcol>
      <ttcol align='left'>C</ttcol>
      <ttcol align='left'>R</ttcol>
      <ttcol width='8em' align='left'>Applies to</ttcol>
      <ttcol width='17em' align='left'>Name</ttcol>
      <ttcol width='6em' align='right'>Format</ttcol>
      <ttcol width='6em' align='right'>Length</ttcol>
      <ttcol width='7em' align='left'>Base Value</ttcol>
      <c>4</c>
      <c>&#160;</c>
      <c>&#160;</c>
      <c>CSM</c>
      <c>Block-Wise-Transfer</c>
      <c>empty</c>
      <c>0</c>
      <c>(none)</c>

<postamble>C=Critical, R=Repeatable</postamble>
</texttable>

<t>A sender can use the elective Block-Wise-Transfer Option to indicate that it
supports the block-wise transfer protocol <xref target="RFC7959"/>.</t>

<t>If the option is not given, the peer has no information about whether
block-wise transfers are supported by the sender or not.  An implementation
wishing to offer block-wise transfers to its peer therefore needs to
indicate so via the Block-Wise-Transfer Option.</t>

<t>If a Max-Message-Size Option is indicated with a value that is greater than
1152 (in the same CSM or a different CSM), the Block&nbhy;Wise&nbhy;Transfer
Option also indicates support for BERT (see <xref target="bert"/>).
Subsequently, if the Max-Message-Size Option is indicated with a value equal
to or less than 1152, BERT support is no longer indicated. (Note that the
indication of BERT support does not oblige either peer to actually choose to
make use of BERT.)</t>

<t>Implementation note: When indicating a value of the
Max-Message-Size Option with an intention to enable BERT, the indicating
implementation may want to (1)&nbsp;choose a particular BERT block size it
wants to encourage and (2)&nbsp;add a delta for the header and any options
that may also need to be included in the message with a BERT block of that
size. Section&nbsp;4.6 of <xref target="RFC7252"/> adds 128&nbsp;bytes to a
maximum block size of 1024 to arrive at a default message size of 1152.  A
BERT-enabled implementation may want to indicate a BERT block size of
2048 or a higher multiple of 1024 and at the same time be more generous
with the size of the header and options added (say, 256 or 512). However,
adding 1024 or more to the base BERT block size may encourage the peer
implementation to vary the BERT block size based on the size of the
options included; this type of scenario might make it harder to establish
interoperability.</t>

</section>
</section>

<section anchor="sec-ping" title="Ping and Pong Messages">

<t>In CoAP over reliable transports, Empty messages (Code 0.00) can always be
sent and MUST be ignored by the recipient. This provides a basic keepalive
function. In contrast, Ping and Pong messages are a bidirectional exchange.</t>

<t>Upon receipt of a Ping message, the receiver MUST return a Pong message
with an identical Token in response. Unless the Ping carries an option with
delaying semantics such as the Custody Option, it SHOULD respond as soon as
practical. As with all Signaling messages, the recipient of a Ping or Pong
message MUST ignore elective options it does not understand.</t>

<t>Ping and Pong messages are indicated by the 7.02 code (Ping) and the 7.03
code (Pong).</t>

<t>Note that, as with similar mechanisms defined in <xref target="RFC6455"/>
and <xref target="RFC7540"/>, the present specification does not define any
specific maximum time that the sender of a Ping message has to allow when
waiting for a Pong reply.  Any limitations on patience for this reply are
a matter of the application making use of these messages, as is any
approach to recover from a failure to respond in time.</t>

<section anchor="custody-option" title="Custody Option">

<texttable>
      <ttcol width='2em' align='right'>#</ttcol>
      <ttcol align='left'>C</ttcol>
      <ttcol align='left'>R</ttcol>
      <ttcol width='8em' align='left'>Applies to</ttcol>
      <ttcol width='17em' align='left'>Name</ttcol>
      <ttcol width='6em' align='right'>Format</ttcol>
      <ttcol width='6em' align='right'>Length</ttcol>
      <ttcol width='7em' align='left'>Base Value</ttcol>
      <c>2</c>
      <c>&#160;</c>
      <c>&#160;</c>
      <c>Ping, Pong</c>
      <c>Custody</c>
      <c>empty</c>
      <c>0</c>
      <c>(none)</c>

<postamble>C=Critical, R=Repeatable</postamble>
</texttable>

<t>When responding to a Ping message, the receiver can include an elective
Custody Option in the Pong message. This option indicates that the application
has processed all the request/response messages received prior to the Ping
message on the current connection. (Note that there is no definition of
specific application semantics for "processed", but there is an expectation
that the receiver of a Pong message with a Custody Option should be able to
free buffers based on this indication.)</t>

<t>A sender can also include an elective Custody Option in a Ping message to
explicitly request the inclusion of an elective Custody Option in the
corresponding Pong message. In that case, the receiver SHOULD delay its Pong
message until it finishes processing all the request/response messages
received prior to the Ping message on the current connection.</t>

</section>
</section>
<section anchor="sec-release" title="Release Messages">

<t>A Release message indicates that the sender does not want to continue
maintaining the Transport Connection and opts for an orderly shutdown,
but wants to leave it to the peer to actually start closing the
connection. The details are in the options. A diagnostic payload (see
Section 5.5.2 of <xref target="RFC7252"/>) MAY be included.</t>

<t>A peer will normally
respond to a Release message by closing the Transport Connection.
(In case that does not happen, the sender of the release may want to
implement a timeout mechanism if getting rid of the connection is
actually important to it.)</t>

<t>Messages may be in flight or responses outstanding when the sender
decides to send a Release message (which is one reason the sender had
decided to wait before closing the connection). The peer responding to
the Release message SHOULD delay the closing of the connection until
it has responded to all requests received by it before the Release
message. It also MAY wait for the responses to its own requests.</t>

<t>It is NOT RECOMMENDED for the sender of a Release message to continue
sending requests on the connection it already indicated to be
released: the peer might close the connection at any time and miss
those requests.  The peer is not obligated to check for this condition,
though.</t>

<t>Release messages are indicated by the 7.04 code (Release).</t>

<t>Release messages can indicate one or more reasons using elective options.
The following options are defined:</t>

<texttable>
      <ttcol width='2em' align='right'>#</ttcol>
      <ttcol align='left'>C</ttcol>
      <ttcol align='left'>R</ttcol>
      <ttcol width='8em' align='left'>Applies to</ttcol>
      <ttcol width='17em' align='left'>Name</ttcol>
      <ttcol width='6em' align='right'>Format</ttcol>
      <ttcol width='6em' align='right'>Length</ttcol>
      <ttcol width='7em' align='left'>Base Value</ttcol>
      <c>2</c>
      <c>&#160;</c>
      <c>x</c>
      <c>Release</c>
      <c>Alternative-Address</c>
      <c>string</c>
      <c>1-255</c>
      <c>(none)</c>

<postamble>C=Critical, R=Repeatable</postamble>
</texttable>

<t>The elective Alternative-Address Option requests the peer to instead open a
connection of the same scheme as the present connection to the alternative
transport address given. Its value is in the form "authority" as defined in
Section&nbsp;3.2 of <xref target="RFC3986"/>. (Existing state related to the
connection is not transferred from the present connection to the new
connection.)</t>

<t>The Alternative-Address Option is a repeatable option as defined in
Section&nbsp;5.4.5 of <xref target="RFC7252"/>. When multiple occurrences of
the option are included, the peer can choose any of the alternative transport
addresses.</t>

<texttable>
      <ttcol width='2em' align='right'>#</ttcol>
      <ttcol align='left'>C</ttcol>
      <ttcol align='left'>R</ttcol>
      <ttcol width='8em' align='left'>Applies to</ttcol>
      <ttcol width='17em' align='left'>Name</ttcol>
      <ttcol width='6em' align='right'>Format</ttcol>
      <ttcol width='6em' align='right'>Length</ttcol>
      <ttcol width='7em' align='left'>Base Value</ttcol>
      <c>4</c>
      <c>&#160;</c>
      <c>&#160;</c>
      <c>Release</c>
      <c>Hold-Off</c>
      <c>uint</c>
      <c>0-3</c>
      <c>(none)</c>

<postamble>C=Critical, R=Repeatable</postamble>
</texttable>

<t>The elective Hold-Off Option indicates that the server is requesting that
the peer not reconnect to it for the number of seconds given in the value.</t>

</section>

<section anchor="sec-abort" title="Abort Messages">

<t>An Abort message indicates that the sender is unable to continue
maintaining the Transport Connection and cannot even wait for an orderly
release. The sender shuts down the connection immediately after
the Abort message (and may or may not wait for a Release message,
Abort message, or connection shutdown in the inverse direction). A diagnostic
payload (see Section&nbsp;5.5.2 of <xref target="RFC7252"/>) SHOULD be
included in the Abort message. Messages may be in flight or responses
outstanding when the sender decides to send an Abort message. The general
expectation is that these will NOT be processed.</t>

<t>Abort messages are indicated by the 7.05 code (Abort).</t>

<t>Abort messages can indicate one or more reasons using elective
options. The following option is defined:</t>

<texttable>
      <ttcol width='2em' align='right'>#</ttcol>
      <ttcol align='left'>C</ttcol>
      <ttcol align='left'>R</ttcol>
      <ttcol width='8em' align='left'>Applies to</ttcol>
      <ttcol width='17em' align='left'>Name</ttcol>
      <ttcol width='6em' align='right'>Format</ttcol>
      <ttcol width='6em' align='right'>Length</ttcol>
      <ttcol width='7em' align='left'>Base Value</ttcol>
      <c>2</c>
      <c>&#160;</c>
      <c>&#160;</c>
      <c>Abort</c>
      <c>Bad-CSM-Option</c>
      <c>uint</c>
      <c>0-2</c>
      <c>(none)</c>

<postamble>C=Critical, R=Repeatable</postamble>
</texttable>

<t>Bad-CSM-Option, which is elective, indicates that the sender is unable to
process the CSM option identified by its Option Number, e.g., when it is
critical and the Option Number is unknown by the sender, or when there is a
parameter problem with the value of an elective option. More detailed
information SHOULD be included as a diagnostic payload.</t>

<t>For CoAP over UDP, messages that contain syntax violations are
processed as message format errors. As described in
Sections&nbsp;4.2 and 4.3 of <xref target="RFC7252"/>, such messages are
rejected by sending a matching Reset message and otherwise ignoring the
message.</t>

<t>For CoAP over reliable transports, the recipient rejects such messages by
sending an Abort message and otherwise ignoring (not processing) the message.
No specific Option has been defined for the Abort message in this case, as the
details are best left to a diagnostic payload.</t>

</section>
<section anchor="signaling-examples" title="Signaling Examples">

<t>An encoded example of a Ping message with a non-empty Token is shown
in <xref target="fig-ping-example"/>.</t>

<figure title="Ping Message Example" anchor="fig-ping-example"><artwork><![CDATA[
    0                   1                   2
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x01     |      0xe2     |      0x42     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    Len   =    0 -------> 0x01
    TKL   =    1 ___/
    Code  = 7.02 Ping --> 0xe2
    Token =               0x42
]]></artwork></figure>

<t>An encoded example of the corresponding Pong message is shown in <xref
target="fig-pong-example"/>.</t>

<figure title="Pong Message Example" anchor="fig-pong-example"><artwork><![CDATA[
    0                   1                   2
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x01     |      0xe3     |      0x42     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    Len   =    0 -------> 0x01
    TKL   =    1 ___/
    Code  = 7.03 Pong --> 0xe3
    Token =               0x42
]]></artwork></figure>

</section>
</section>

<section anchor="bert" title="Block-Wise Transfer and Reliable Transports">

<t>The message size restrictions defined in Section 4.6 of <xref
target="RFC7252"/> to avoid IP fragmentation are not necessary when CoAP is
used over a reliable transport. While this suggests that the block&nbhy;wise
transfer protocol <xref target="RFC7959"/> is also no longer needed, it
remains applicable for a number of cases:</t>

<t><list style="symbols">
  <t>Large messages, such as firmware downloads, may cause undesired
  head-of-line blocking when a single transport connection is used.</t>
  <t>A UDP-to-TCP gateway may simply not have the context to convert a
  message with a Block Option into the equivalent exchange without any
  use of a Block Option (it would need to convert the entire
  block&nbhy;wise exchange from start to end into a single exchange).</t>
</list></t>

<t>BERT extends the block-wise transfer protocol to enable the use of
larger messages over a reliable transport.</t>

<t>The use of this new extension is signaled by sending Block1 or
Block2 Options with SZX == 7 (a "BERT Option"). SZX == 7 is a 
reserved value in <xref target="RFC7959"/>.</t>

<t>In control usage, a BERT Option is interpreted in the same way as the
equivalent Option with SZX == 6, except that it also indicates the
capability to process BERT blocks. As with the basic block-wise transfer
protocol, the recipient of a CoAP request with a BERT Option in control usage
is allowed to respond with a different SZX value, e.g., to send a
non&nbhy;BERT block instead.</t>

<t>In descriptive usage, a BERT Option is interpreted in the same way as
the equivalent Option with SZX == 6, except that the payload is also
allowed to contain multiple blocks. For non&nbhy;final BERT blocks, the payload
is always a multiple of 1024 bytes. For final BERT blocks, the payload is
a multiple (possibly 0) of 1024 bytes plus a partial block of less than
1024&nbsp;bytes.</t>

<t>The recipient of a non&nbhy;final BERT block (M=1) conceptually partitions
the payload into a sequence of 1024-byte blocks and acts exactly as
if it had received this sequence in conjunction with block numbers
starting at, and sequentially increasing from, the block number given
in the Block Option. In other words, the entire BERT block is
positioned at the byte position that results from multiplying the
block number by 1024. The position of further blocks to be
transferred is indicated by incrementing the block number by the
number of elements in this sequence (i.e., the size of the payload
divided by 1024 bytes).</t>

<t>As with SZX == 6, the recipient of a final BERT block (M=0) simply
appends the payload at the byte position that is indicated by the
block number multiplied by 1024.</t>

<t>The following examples illustrate BERT Options. A value of SZX == 7
is labeled as "BERT" or as "BERT(nnn)" to indicate a payload of
size&nbsp;nnn.</t>

<t>In all these examples, a Block Option is decomposed to indicate the
kind of Block Option (1 or 2) followed by a colon, the block number (NUM),
the more bit (M), and the block size (2**(SZX + 4)) separated by slashes.
For example, a Block2 Option value of 33 would be shown as 2:2/0/32), or a
Block1 Option value of 59 would be shown as 1:3/1/128.</t>

<section anchor="example-get-with-bert-blocks" title="Example: GET with BERT Blocks">

<t><xref target="fig-bert1"/> shows a GET request with a response that is
split into three BERT blocks. The first response contains 3072&nbsp;bytes
of payload; the second, 5120; and the third, 4711. Note how the block number
increments to move the position inside the response body forward.</t>

<figure title="GET with BERT Blocks" anchor="fig-bert1"><artwork><![CDATA[
CoAP Client                             CoAP Server
  |                                            |
  | GET, /status                       ------> |
  |                                            |
  | <------   2.05 Content, 2:0/1/BERT(3072)   |
  |                                            |
  | GET, /status, 2:3/0/BERT           ------> |
  |                                            |
  | <------   2.05 Content, 2:3/1/BERT(5120)   |
  |                                            |
  | GET, /status, 2:8/0/BERT          ------>  |
  |                                            |
  | <------   2.05 Content, 2:8/0/BERT(4711)   |
]]></artwork></figure>

</section>

<section anchor="example-put-with-bert-blocks" title="Example: PUT with BERT Blocks">

<t><xref target="fig-bert2"/> demonstrates a PUT exchange with BERT blocks.</t>

<figure title="PUT with BERT Blocks" anchor="fig-bert2"><artwork><![CDATA[
CoAP Client                             CoAP Server
  |                                             |
  | PUT, /options, 1:0/1/BERT(8192)     ------> |
  |                                             |
  | <------   2.31 Continue, 1:0/1/BERT         |
  |                                             |
  | PUT, /options, 1:8/1/BERT(16384)    ------> |
  |                                             |
  | <------   2.31 Continue, 1:8/1/BERT         |
  |                                             |
  | PUT, /options, 1:24/0/BERT(5683)    ------> |
  |                                             |
  | <------   2.04 Changed, 1:24/0/BERT         |
  |                                             |
]]></artwork></figure>

</section>
</section>

<section anchor="observing" title="Observing Resources over Reliable Transports">

<t>This section describes how the procedures defined in <xref
target="RFC7641"/> for observing resources over CoAP are applied (and
modified, as needed) for reliable transports.  In this section, "client" and
"server" refer to the CoAP client and CoAP server.</t>

<section anchor="notifications-and-reordering" title="Notifications and Reordering">

<t>When using the Observe Option <xref target="RFC7641"/> with CoAP over UDP,
notifications from the server set the option value to an increasing sequence
number for reordering detection on the client, since messages can arrive in a
different order than they were sent. This sequence number is not required for
CoAP over reliable transports, since TCP ensures reliable and ordered delivery
of messages. The value of the Observe Option in 2.xx notifications MAY be
empty on transmission and MUST be ignored on reception.</t>

<t>Implementation note: This means that a proxy from a reordering
transport to a reliable (in-order) transport (such as a UDP-to-TCP
proxy) needs to process the Observe Option in notifications according
to the rules in Section 3.4 of <xref target="RFC7641"/>.</t>

</section>

<section anchor="transmission-and-acknowledgments" title="Transmission and Acknowledgments">

<t>For CoAP over UDP, server notifications to the client can be Confirmable or
Non&nbhy;confirmable. A Confirmable message requires the client to respond with
either an Acknowledgment message or a Reset message. An Acknowledgment message
indicates that the client is alive and wishes to receive further
notifications. A Reset message indicates that the client does not recognize
the Token; this causes the server to remove the associated entry from the list
of observers.</t>

<t>Since TCP eliminates the need for the message layer to support reliability,
CoAP over reliable transports does not support Confirmable or
Non&nbhy;confirmable message types. All notifications are delivered reliably
to the client with positive acknowledgment of receipt occurring at the TCP
level. If the client does not recognize the Token in a notification, it MAY
immediately abort the connection (see <xref target="sec-abort"/>).</t>

</section>
<section anchor="freshness" title="Freshness">

<t>For CoAP over UDP, if a client does not receive a notification for some
time, it can send a new GET request with the same Token as the original
request to re-register its interest in a resource and verify that the server
is still responsive. For CoAP over reliable transports, it is more efficient
to check the health of the connection (and all its active observations) by
sending a single CoAP Ping Signaling message (<xref target="sec-ping"/>)
rather than individual requests to confirm each active observation.  (Note
that such a Ping/Pong only confirms a single hop: a proxy is not obligated
or expected to react to a Ping by checking all its own registered interests
or all the connections, if any, underlying them.  A proxy MAY maintain
its own schedule for confirming the interests that it relies on being
registered toward the origin server; however, it is generally inadvisable for
a proxy to generate a large number of outgoing checks based on a single
incoming check.)</t>

</section>

<section anchor="observe-cancel" title="Cancellation">

<t>For CoAP over UDP, a client that is no longer interested in receiving
notifications can "forget" the observation and respond to the next
notification from the server with a Reset message to cancel the
observation.</t>

<t>For CoAP over reliable transports, a client MUST explicitly deregister by
issuing a GET request that has the Token field set to the Token of the
observation to be canceled and includes an Observe Option with the value set
to 1 (deregister).</t>

<t>If the client observes one or more resources over a reliable transport,
then the CoAP server (or intermediary in the role of the CoAP server) MUST
remove all entries associated with the client endpoint from the lists of
observers when the connection either times&nbsp;out or is closed.</t>

</section>
</section>

<section anchor="URI" title="CoAP over Reliable Transport URIs">

<t>CoAP over UDP <xref target="RFC7252"/> defines the "coap" and "coaps"
URI schemes. This document introduces four additional URI schemes for
identifying CoAP resources and providing a means of locating the resource:</t>

<t><list style="symbols">
  <t>The "coap+tcp" URI scheme for CoAP over TCP.</t>
  <t>The "coaps+tcp" URI scheme for CoAP over TCP secured by TLS.</t>
  <t>The "coap+ws" URI scheme for CoAP over WebSockets.</t>
  <t>The "coaps+ws" URI scheme for CoAP over WebSockets secured by TLS.</t>
</list></t>

<t>Resources made available via these schemes have no shared identity even if
their resource identifiers indicate the same authority (the same host
listening to the same TCP port). They are hosted in distinct namespaces
because each URI scheme implies a distinct origin server.</t>

<t>In this section, the syntax for the URI schemes is specified using the
Augmented Backus-Naur Form (ABNF) <xref target="RFC5234"></xref>. The
definitions of "host", "port", "path-abempty", and "query" are adopted from
<xref target="RFC3986"></xref>.</t>

<t>Section 8 ("Multicast CoAP") in <xref target="RFC7252"/> is not applicable
to these schemes.</t>

<t>As with the "coap" and "coaps" schemes defined in <xref target="RFC7252"/>,
all URI schemes defined in this section also support the path prefix
"/.well&nbhy;known/" as defined by <xref target="RFC5785"/> for
"well-known locations" in the namespace of a host.  This enables discovery
as per Section&nbsp;7 of <xref target="RFC7252"/>.</t>

<section anchor="coap-tcp-scheme" title="coap+tcp URI Scheme">

<t>The "coap+tcp" URI scheme identifies CoAP resources that are intended to be
accessible using CoAP over TCP.</t>

<figure><artwork type="abnf" align="left"><![CDATA[
  coap-tcp-URI = "coap+tcp:" "//" host [ ":" port ]
    path-abempty [ "?" query ]
]]></artwork></figure>

<t>The syntax defined in Section 6.1 of <xref target="RFC7252"/> applies to
this URI scheme, with the following change:</t>

<t><list style="symbols">
  <t>The port subcomponent indicates the TCP port at which the CoAP Connection
  Acceptor is located. (If it is empty or not given, then the default
  port&nbsp;5683 is assumed, as with UDP.)</t>
</list></t>

<t><list style="hanging">
  <t hangText='Encoding considerations:'>
  The scheme encoding conforms to the encoding rules established for URIs in
  <xref target="RFC3986"></xref>.</t>
  <t hangText='Interoperability considerations:'>
  None.</t>
  <t hangText='Security considerations:'>
  See Section 11.1 of <xref target="RFC7252"/>.</t>
</list></t>

</section>
<section anchor="coaps-tcp-scheme" title="coaps+tcp URI Scheme">

<t>The "coaps+tcp" URI scheme identifies CoAP resources that are intended to
be accessible using CoAP over TCP secured with TLS.</t>

<figure><artwork type="abnf" align="left"><![CDATA[
  coaps-tcp-URI = "coaps+tcp:" "//" host [ ":" port ]
    path-abempty [ "?" query ]
]]></artwork></figure>

<t>The syntax defined in Section 6.2 of <xref target="RFC7252"/> applies to
this URI scheme, with the following changes:</t>

<t><list style="symbols">
  <t>The port subcomponent indicates the TCP port at which the TLS server
  for the CoAP Connection Acceptor is located. If it is empty or not given,
  then the default port 5684 is assumed.</t>

  <t>If a TLS server does not support the Application-Layer Protocol
  Negotiation (ALPN) extension <xref target="RFC7301"/> or wishes to
  accommodate TLS clients that do not support ALPN, it MAY offer a coaps+tcp
  endpoint on TCP port 5684. This endpoint MAY also be ALPN enabled. A TLS
  server MAY offer coaps+tcp endpoints on ports other than TCP port 5684,
  which MUST be ALPN enabled.</t>

  <t>For TCP ports other than port 5684, the TLS client MUST use the
  ALPN extension to advertise the "coap" protocol identifier (see <xref
  target="alpnpid"/>) in the list of protocols in its ClientHello. If the
  TCP server selects and returns the "coap" protocol identifier using the
  ALPN extension in its ServerHello, then the connection succeeds. If the TLS
  server either does not negotiate the ALPN extension or returns a
  no_application_protocol alert, the TLS client MUST close the connection.</t>

  <t>For TCP port 5684, a TLS client MAY use the ALPN extension to advertise
  the "coap" protocol identifier in the list of protocols in its
  ClientHello. If the TLS server selects and returns the "coap" protocol
  identifier using the ALPN extension in its ServerHello, then the connection
  succeeds. If the TLS server returns a no_application_protocol alert, then
  the TLS client MUST close the connection. If the TLS server does not
  negotiate the ALPN extension, then coaps+tcp is implicitly selected.</t>

  <t>For TCP port 5684, if the TLS client does not use the ALPN extension to
  negotiate the protocol, then coaps+tcp is implicitly selected.</t>
</list></t>

<t><list style="hanging">
  <t hangText='Encoding considerations:'>
  The scheme encoding conforms to the encoding rules established for URIs in
  <xref target="RFC3986"></xref>.</t>
  <t hangText='Interoperability considerations:'>
  None.</t>
  <t hangText='Security considerations:'>
  See Section 11.1 of <xref target="RFC7252"/>.</t>
</list></t>

</section>
<section anchor="coap-ws-scheme" title="coap+ws URI Scheme">

<t>The "coap+ws" URI scheme identifies CoAP resources that are intended to be
accessible using CoAP over WebSockets.</t>

<figure><artwork type="abnf" align="left"><![CDATA[
  coap-ws-URI = "coap+ws:" "//" host [ ":" port ]
    path-abempty [ "?" query ]
]]></artwork></figure>

<t>The port subcomponent is OPTIONAL. The default is port 80.</t>

<t>The WebSocket endpoint is identified by a "ws" URI that is composed of the
authority part of the "coap+ws" URI and the well-known path
"/.well-known/coap" <xref target="RFC5785"/> <xref target="RFC8307"/>.
Within the endpoint specified in a "coap+ws" URI, the path and query
parts of the URI identify a resource that can be operated on by the
methods defined by&nbsp;CoAP:</t>

<figure title="The &quot;coap+ws&quot; URI Scheme" anchor="coap-ws-example"><artwork align="center"><![CDATA[
      coap+ws://example.org/sensors/temperature?u=Cel
           \______  ______/\___________  ___________/
                  \/                   \/
                                     Uri-Path: "sensors"
ws://example.org/.well-known/coap    Uri-Path: "temperature"
                                     Uri-Query: "u=Cel"
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='Encoding considerations:'>
  The scheme encoding conforms to the encoding rules established for URIs in
  <xref target="RFC3986"></xref>.</t>
  <t hangText='Interoperability considerations:'>
  None.</t>
  <t hangText='Security considerations:'>
  See Section 11.1 of <xref target="RFC7252"/>.</t>
</list></t>

</section>
<section anchor="coaps-ws-scheme" title="coaps+ws URI Scheme">

<t>The "coaps+ws" URI scheme identifies CoAP resources that are intended to be
accessible using CoAP over WebSockets secured by TLS.</t>

<figure><artwork type="abnf" align="left"><![CDATA[
  coaps-ws-URI = "coaps+ws:" "//" host [ ":" port ]
    path-abempty [ "?" query ]
]]></artwork></figure>

<t>The port subcomponent is OPTIONAL. The default is port 443.</t>

<t>The WebSocket endpoint is identified by a "wss" URI that is composed of the
authority part of the "coaps+ws" URI and the well-known path
"/.well-known/coap" <xref target="RFC5785"/> <xref target="RFC8307"/>.
Within the endpoint specified in a "coaps+ws" URI, the path and query
parts of the URI identify a resource that can be operated on by the
methods defined by&nbsp;CoAP:</t>

<figure title="The &quot;coaps+ws&quot; URI Scheme" anchor="coaps-ws-example"><artwork align="center"><![CDATA[
      coaps+ws://example.org/sensors/temperature?u=Cel
            \______  ______/\___________  ___________/
                   \/                   \/
                                     Uri-Path: "sensors"
wss://example.org/.well-known/coap   Uri-Path: "temperature"
                                     Uri-Query: "u=Cel"
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='Encoding considerations:'>
  The scheme encoding conforms to the encoding rules established for URIs in
  <xref target="RFC3986"></xref>.</t>
  <t hangText='Interoperability considerations:'>
  None.</t>
  <t hangText='Security considerations:'>
  See Section 11.1 of <xref target="RFC7252"/>.</t>
</list></t>

</section>
<section anchor="uri-host-and-uri-port-options" title="Uri-Host and Uri-Port Options">

<t>CoAP over reliable transports maintains the property from
Section&nbsp;5.10.1 of <xref target="RFC7252"/>:</t>

<t><list style='empty'>
  <t>The default values for the Uri-Host and Uri-Port Options are
  sufficient for requests to most servers.</t>
</list></t>

<t>Unless otherwise noted, the default value of the Uri-Host Option is the IP
literal representing the destination IP address of the request message. The
default value of the Uri-Port Option is the destination TCP port.</t>

<t>For CoAP over TLS, these default values are the same, unless Server Name
Indication (SNI) <xref target="RFC6066"/> is negotiated. In this case, the
default value of the Uri-Host Option in requests from the TLS client to the
TLS server is the SNI host.</t>

<t>For CoAP over WebSockets, the default value of the Uri-Host Option in
requests from the WebSocket client to the WebSocket server is indicated by the
Host header field from the WebSocket handshake.</t>

</section>
<section anchor="decomposing-uris-into-options" title="Decomposing URIs into Options">

<t>The steps are the same as those specified in Section&nbsp;6.4 of <xref
target="RFC7252"/>, with minor changes:</t>

<t>This step from <xref target="RFC7252"/>:</t>

<figure><artwork><![CDATA[
3.  If |url| does not have a <scheme> component whose value, when
    converted to ASCII lowercase, is "coap" or "coaps", then fail
    this algorithm.
]]></artwork></figure>

<t>is updated to:</t>

<figure><artwork><![CDATA[
3.  If |url| does not have a <scheme> component whose value, when
    converted to ASCII lowercase, is "coap+tcp", "coaps+tcp",
    "coap+ws", or "coaps+ws", then fail this algorithm.
]]></artwork></figure>

<t>This step from <xref target="RFC7252"/>:</t>

<figure><artwork><![CDATA[
7.  If |port| does not equal the request's destination UDP port,
    include a Uri-Port Option and let that option's value be |port|.
]]></artwork></figure>

<t>is updated to:</t>

<figure><artwork><![CDATA[
7.  If |port| does not equal the request's destination TCP port,
    include a Uri-Port Option and let that option's value be |port|.
]]></artwork></figure>

</section>

<section anchor="composing-uris-from-options" title="Composing URIs from Options">

<t>The steps are the same as those specified in Section 6.5 of <xref
target="RFC7252"/>, with minor changes:</t>

<t>This step from <xref target="RFC7252"/>:</t>

<figure><artwork><![CDATA[
1.  If the request is secured using DTLS, let |url| be the string
    "coaps://".  Otherwise, let |url| be the string "coap://".
]]></artwork></figure>

<t>is updated to:</t>

<figure><artwork><![CDATA[
1.  For CoAP over TCP, if the request is secured using TLS, let |url|
    be the string "coaps+tcp://".  Otherwise, let |url| be the string
    "coap+tcp://".  For CoAP over WebSockets, if the request is
    secured using TLS, let |url| be the string "coaps+ws://".
    Otherwise, let |url| be the string "coap+ws://".
]]></artwork></figure>

<t>This step from <xref target="RFC7252"/>:</t>

<figure><artwork><![CDATA[
4.  If the request includes a Uri-Port Option, let |port| be that
    option's value.  Otherwise, let |port| be the request's
    destination UDP port.
]]></artwork></figure>

<t>is updated to:</t>

<figure><artwork><![CDATA[
4.  If the request includes a Uri-Port Option, let |port| be that
    option's value.  Otherwise, let |port| be the request's
    destination TCP port.
]]></artwork></figure>

</section>
</section>

<section anchor="securing" title="Securing CoAP">

<t>"Security Challenges For the Internet Of Things" <xref
target="SecurityChallenges"/> recommends the following:</t>

<t><list style='empty'>
  <t>... it is essential that IoT protocol suites specify a mandatory to
  implement but optional to use security solution. This will ensure security
  is available in all implementations, but configurable to use when not
  necessary (e.g., in closed environment). ... even if those features stretch
  the capabilities of such devices.</t>
</list></t>

<t>A security solution MUST be implemented to protect CoAP over reliable
transports and MUST be enabled by default. This document defines the TLS
binding, but alternative solutions at different layers in the protocol stack
MAY be used to protect CoAP over reliable transports when appropriate. Note
that there is ongoing work to support a data-object-based security model for
CoAP that is independent of transport (see <xref target="OSCORE"/>).</t>

<section anchor="tls-binding-for-coap-over-tcp" title="TLS Binding for CoAP over TCP">

<t>The TLS usage guidance in <xref target="RFC7925"/> applies, including the
guidance about cipher suites in that document that are derived from the
mandatory-to-implement cipher suites defined in <xref target="RFC7252"/>.</t>

<t>This guidance assumes implementation in a constrained device or for
communication with a constrained device.  However, CoAP over TCP/TLS has
a wider applicability.  It may, for example, be implemented on a gateway or on
a device that is less constrained (such as a smart phone or a tablet), for
communication with a peer that is likewise less constrained, or within a
back&nbhy;end environment that only communicates with constrained devices via
proxies.  As an exception to the previous paragraph, in this case, the
recommendations in <xref target="RFC7525"/> are more appropriate.</t>

<t>Since the guidance offered in <xref target="RFC7925"/> differs from
the guidance offered in <xref target="RFC7525"/> in terms of algorithms
and credential types, it is assumed that an implementation of
CoAP&nbsp;over&nbsp;TCP/TLS that needs to support both cases implements the
recommendations offered by both specifications.</t>

<t>During the provisioning phase, a CoAP device is provided with the security
information that it needs, including keying materials, access control lists,
and authorization servers. At the end of the provisioning phase, the device
will be in one of four security modes:</t>

<t><list style="hanging">
  <t hangText='NoSec:'>
  TLS is disabled.</t>
  <t hangText='PreSharedKey:'>
  TLS is enabled. The guidance in Section&nbsp;4.2 of <xref target="RFC7925"/>
  applies.</t>
  <t hangText='RawPublicKey:'>
  TLS is enabled. The guidance in Section&nbsp;4.3 of <xref target="RFC7925"/>
  applies.</t>
  <t hangText='Certificate:'>
  TLS is enabled. The guidance in Section&nbsp;4.4 of <xref target="RFC7925"/>
  applies.</t>
</list></t>

<t>The "NoSec" mode is optional to implement. The system simply sends the
packets over normal TCP; this is indicated by the "coap+tcp" scheme and the
TCP CoAP default port. The system is secured only by keeping attackers from
being able to send or receive packets from the network with the CoAP nodes.</t>

<t>"PreSharedKey", "RawPublicKey", or "Certificate" is mandatory to implement
for the TLS binding, depending on the credential type used with the
device. These security modes are achieved using TLS and are&nbsp;indicated by
the "coaps+tcp" scheme and TLS-secured CoAP default&nbsp;port.</t>

</section>

<section anchor="tls-usage-for-coap-over-websockets" title="TLS Usage for CoAP over WebSockets">

<t>A CoAP client requesting a resource identified by a "coaps+ws" URI
negotiates a secure WebSocket connection to a WebSocket server endpoint with
a "wss" URI. This is described in <xref target="coaps-ws-scheme"/>.</t>

<t>The client MUST perform a TLS handshake after opening the connection to the
server. The guidance in Section&nbsp;4.1 of <xref target="RFC6455"/>
applies. When a CoAP server exposes resources identified by a "coaps+ws" URI,
the guidance in Section&nbsp;4.4 of <xref target="RFC7925"/> applies towards
mandatory-to-implement TLS functionality for certificates. For the server-side
requirements for accepting incoming connections over an HTTPS
(HTTP&nbsp;over&nbsp;TLS) port, the guidance in
Section&nbsp;4.2 of <xref target="RFC6455"/> applies.</t>

<t>Note that the guidance above formally inherits the mandatory-to-implement
cipher suites defined in <xref target="RFC5246"/>. However, modern browsers
usually implement cipher suites that are more recent; these cipher suites are
then automatically picked up via the JavaScript WebSocket API. WebSocket
servers that provide secure CoAP over WebSockets for the browser use case will
need to follow the browser preferences and MUST follow <xref
target="RFC7525"/>.</t>

</section>
</section>

<section anchor="security" title="Security Considerations">

<t>The security considerations of <xref target="RFC7252"/> apply. For CoAP
over WebSockets and CoAP over TLS-secured WebSockets, the security
considerations of <xref target="RFC6455"/> also apply.</t>

<section anchor="signaling-messages" title="Signaling Messages">

<t>The guidance given by an Alternative-Address Option cannot be
followed blindly. In particular, a peer MUST NOT assume that a
successful connection to the Alternative-Address inherits all the
security properties of the current connection.</t>

</section>
</section>

<section anchor="iana" title="IANA Considerations">

<section anchor="message-codes" title="Signaling Codes">

<t>IANA has created a third subregistry for values of the Code
field in the CoAP header (Section 12.1 of <xref target="RFC7252"/>). The
name of this subregistry is "CoAP Signaling Codes".</t>

<t>Each entry in the subregistry must include the Signaling Code in the
range 7.00&nbhy;7.31, its name, and a reference to its documentation.</t>

<t>Initial entries in this subregistry are as follows:</t>

<texttable title="CoAP Signaling Codes" anchor="signal-codes">
      <ttcol align='left'>Code</ttcol>
      <ttcol align='left'>Name</ttcol>
      <ttcol align='left'>Reference</ttcol>
      <c>7.01</c>
      <c>CSM</c>
      <c>RFC 8323</c>
      <c>7.02</c>
      <c>Ping</c>
      <c>RFC 8323</c>
      <c>7.03</c>
      <c>Pong</c>
      <c>RFC 8323</c>
      <c>7.04</c>
      <c>Release</c>
      <c>RFC 8323</c>
      <c>7.05</c>
      <c>Abort</c>
      <c>RFC 8323</c>
</texttable>

<t>All other Signaling Codes are Unassigned.</t>

<t>The IANA policy for future additions to this subregistry is
"IETF&nbsp;Review" or "IESG Approval" as described in
<xref target="RFC8126"/>.</t>

</section>

<section anchor="option-codes" title="CoAP Signaling Option Numbers Registry">

<t>IANA has created a subregistry for Option Numbers used
in CoAP Signaling Options within the "Constrained RESTful Environments (CoRE)
Parameters" registry. The name of this subregistry is "CoAP Signaling Option
Numbers".</t> 

<t>Each entry in the subregistry must include one or more of the codes
in the "CoAP Signaling Codes" subregistry (<xref target="message-codes"/>),
the number for the Option, the name of the Option, and a reference to the
Option's documentation.</t>

<t>Initial entries in this subregistry are as follows:</t>

<texttable title="CoAP Signaling Option Codes" anchor="signal-option-codes">
      <ttcol align='left'>Applies to</ttcol>
      <ttcol align='right'>Number</ttcol>
      <ttcol align='left'>Name</ttcol>
      <ttcol align='center'>Reference</ttcol>
      <c>7.01</c>
      <c>2</c>
      <c>Max-Message-Size</c>
      <c>RFC 8323</c>
      <c>7.01</c>
      <c>4</c>
      <c>Block-Wise-Transfer</c>
      <c>RFC 8323</c>
      <c>7.02, 7.03</c>
      <c>2</c>
      <c>Custody</c>
      <c>RFC 8323</c>
      <c>7.04</c>
      <c>2</c>
      <c>Alternative-Address</c>
      <c>RFC 8323</c>
      <c>7.04</c>
      <c>4</c>
      <c>Hold-Off</c>
      <c>RFC 8323</c>
      <c>7.05</c>
      <c>2</c>
      <c>Bad-CSM-Option</c>
      <c>RFC 8323</c>
</texttable>

<t>The IANA policy for future additions to this subregistry is based on
number ranges for the option numbers, analogous to the policy defined
in Section&nbsp;12.2 of <xref target="RFC7252"/>. (The policy is analogous
rather than identical because the structure of this subregistry includes an
additional column ("Applies to"); however, the value of this column has no
influence on the policy.)</t>

<t>The documentation for a Signaling Option Number should specify the
semantics of an option with that number, including the following
properties:</t>

<t><list style="symbols">
  <t>Whether the option is critical or elective, as determined by the
  Option Number.</t>
  <t>Whether the option is repeatable.</t>
  <t>The format and length of the option's value.</t>
  <t>The base value for the option, if any.</t>
</list></t>

</section>
<section anchor="service-name-and-port-number-registration" title="Service Name and Port Number Registration">

<t>IANA has assigned the port number 5683 and the service name
"coap", in accordance with <xref target="RFC6335"/>.</t>

<t><list style="hanging">
  <t hangText='Service Name:'><vspace blankLines='0'/>
  coap</t>
  <t hangText='Transport Protocol:'><vspace blankLines='0'/>
  tcp</t>
  <t hangText='Assignee:'><vspace blankLines='0'/>
  IESG &lt;iesg@ietf.org&gt;</t>
  <t hangText='Contact:'><vspace blankLines='0'/>
  IETF Chair &lt;chair@ietf.org&gt;</t>
  <t hangText='Description:'><vspace blankLines='0'/>
  Constrained Application Protocol (CoAP)</t>
  <t hangText='Reference:'><vspace blankLines='0'/>
  RFC 8323</t>
  <t hangText='Port Number:'><vspace blankLines='0'/>
  5683</t>
</list></t>

</section>

<section anchor="secure-service-name-and-port-number-registration" title="Secure Service Name and Port Number Registration">

<t>IANA has assigned the port number 5684 and the service name
"coaps", in accordance with <xref target="RFC6335"/>. The port number is
to address the exceptional case of TLS implementations that do not
support the ALPN extension <xref target="RFC7301"/>.</t>

<t><list style="hanging">
  <t hangText='Service Name:'><vspace blankLines='0'/>
  coaps</t>
  <t hangText='Transport Protocol:'><vspace blankLines='0'/>
  tcp</t>
  <t hangText='Assignee:'><vspace blankLines='0'/>
  IESG &lt;iesg@ietf.org&gt;</t>
  <t hangText='Contact:'><vspace blankLines='0'/>
  IETF Chair &lt;chair@ietf.org&gt;</t>
  <t hangText='Description:'><vspace blankLines='0'/>
  Constrained Application Protocol (CoAP)</t>
  <t hangText='Reference:'><vspace blankLines='0'/>
  <xref target="RFC7301"/>, RFC 8323</t>
  <t hangText='Port Number:'><vspace blankLines='0'/>
  5684</t>
</list></t>

</section>

<section anchor="uri-scheme-registration" title="URI Scheme Registration">

<t>URI schemes are registered within the "Uniform Resource Identifier (URI)
Schemes" registry maintained at <xref target="IANA.uri-schemes"/>.</t>

<t>Note: The following has been added as a note for each of the URI schemes
defined in this document:

<list><t>CoAP registers different URI schemes for accessing CoAP
resources via different protocols. This approach runs counter to the WWW
principle that a URI identifies a resource and that multiple URIs for
identifying the same resource should be avoided
&lt;https://www.w3.org/TR/webarch/#avoid-uri-aliases&gt;.</t>
</list>
</t>

<t>
This is not a problem for many of the usage scenarios envisioned
for CoAP over reliable transports; additional URI schemes can be
introduced to address additional usage scenarios (as being prepared,
for example, in <xref target="Multi-Transport-URIs"/> and
<xref target="CoAP-Alt-Transports"/>).
</t>

<section anchor="coaptcp" title="coap+tcp">
<t>IANA has registered the URI scheme "coap+tcp". This
registration request complies with <xref target="RFC7595"/>.</t>

<t><list style="hanging">
  <t hangText='Scheme name:'><vspace blankLines='0'/>
  coap+tcp</t>
  <t hangText='Status:'><vspace blankLines='0'/>
  Permanent</t>
  <t hangText='Applications/protocols that use this scheme name:'>
  <vspace blankLines='0'/>
  The scheme is used by CoAP endpoints to access CoAP resources using TCP.</t>
  <t hangText='Contact:'>
  <vspace blankLines='0'/>
  IETF Chair &lt;chair@ietf.org&gt;</t>
  <t hangText='Change controller:'>
  <vspace blankLines='0'/>
  IESG &lt;iesg@ietf.org&gt;</t>
  <t hangText='Reference:'>
  <vspace blankLines='0'/>
  <xref target="coap-tcp-scheme"/> in RFC 8323</t>
</list></t>

</section>
<section anchor="coapstcp" title="coaps+tcp">
<t>IANA has registered the URI scheme "coaps+tcp". This
registration request complies with <xref target="RFC7595"/>.</t>

<t><list style="hanging">
  <t hangText='Scheme name:'>
  <vspace blankLines='0'/>
  coaps+tcp</t>
  <t hangText='Status:'>
  <vspace blankLines='0'/>
  Permanent</t>
  <t hangText='Applications/protocols that use this scheme name:'>
  <vspace blankLines='0'/>
  The scheme is used by CoAP endpoints to access CoAP resources using TLS.</t>
  <t hangText='Contact:'>
  <vspace blankLines='0'/>
  IETF Chair &lt;chair@ietf.org&gt;</t>
  <t hangText='Change controller:'>
  <vspace blankLines='0'/>
  IESG &lt;iesg@ietf.org&gt;</t>
  <t hangText='Reference:'>
  <vspace blankLines='0'/>
  <xref target="coaps-tcp-scheme"/> in RFC 8323</t>
</list></t>

</section>

<section anchor="coapws" title="coap+ws">

<t>IANA has registered the URI scheme "coap+ws". This
registration request complies with <xref target="RFC7595"/>.</t>

<t><list style="hanging">
  <t hangText='Scheme name:'><vspace blankLines='0'/>
  coap+ws</t>
  <t hangText='Status:'><vspace blankLines='0'/>
  Permanent</t>
  <t hangText='Applications/protocols that use this scheme name:'>
  <vspace blankLines='0'/>
  The scheme is used by CoAP endpoints to access CoAP resources using the
  WebSocket Protocol.</t>
  <t hangText='Contact:'><vspace blankLines='0'/>
  IETF Chair &lt;chair@ietf.org&gt;</t>
  <t hangText='Change controller:'><vspace blankLines='0'/>
  IESG &lt;iesg@ietf.org&gt;</t>
  <t hangText='Reference:'><vspace blankLines='0'/>
  <xref target="coap-ws-scheme"/> in RFC 8323</t>
</list></t>

</section>
<section anchor="coapsws" title="coaps+ws">
<t>IANA has registered the URI scheme "coaps+ws". This
registration request complies with <xref target="RFC7595"/>.</t>

<t><list style="hanging">
  <t hangText='Scheme name:'><vspace blankLines='0'/>
  coaps+ws</t>
  <t hangText='Status:'><vspace blankLines='0'/>
  Permanent</t>
  <t hangText='Applications/protocols that use this scheme name:'>
  <vspace blankLines='0'/>
  The scheme is used by CoAP endpoints to access CoAP resources using the
  WebSocket Protocol secured with TLS.</t>
  <t hangText='Contact:'><vspace blankLines='0'/>
  IETF Chair &lt;chair@ietf.org&gt;</t>
  <t hangText='Change controller:'><vspace blankLines='0'/>
  IESG &lt;iesg@ietf.org&gt;</t>
  <t hangText='References:'><vspace blankLines='0'/>
  <xref target="coaps-ws-scheme"/> in RFC 8323</t>
</list></t>

</section>
</section>

<section anchor="well-known-uri-suffix-registration" title="Well-Known URI Suffix Registration">

<t>IANA has registered "coap" in the
"Well&nbhy;Known URIs" registry. This registration request complies with
<xref target="RFC5785"/>.</t>

<t><list style="hanging">
  <t hangText='URI suffix:'><vspace blankLines='0'/>
  coap</t>
  <t hangText='Change controller:'><vspace blankLines='0'/>
  IETF</t>
  <t hangText='Specification document(s):'><vspace blankLines='0'/>
  RFC 8323</t>
  <t hangText='Related information:'><vspace blankLines='0'/>
  None.</t>
</list></t>

</section>
<section anchor="alpnpid" title="ALPN Protocol Identifier">

<t>IANA has assigned the following value in the 
"Application&nbhy;Layer Protocol Negotiation (ALPN) Protocol IDs" registry
created by <xref target="RFC7301"/>. The "coap" string identifies CoAP
when used over TLS.</t>

<t><list style="hanging">
  <t hangText='Protocol:'><vspace blankLines='0'/>
  CoAP</t>
  <t hangText='Identification Sequence:'><vspace blankLines='0'/>
  0x63 0x6f 0x61 0x70 ("coap")</t>
  <t hangText='Reference:'><vspace blankLines='0'/>
  RFC 8323</t>
</list></t>

</section>
<section anchor="websocket-subprotocol-registration" title="WebSocket Subprotocol Registration">

<t>IANA has registered the WebSocket CoAP subprotocol in the 
"WebSocket Subprotocol Name Registry":</t>

<t><list style="hanging">
  <t hangText='Subprotocol Identifier:'><vspace blankLines='0'/>
  coap</t>
  <t hangText='Subprotocol Common Name:'><vspace blankLines='0'/>
  Constrained Application Protocol (CoAP)</t>
  <t hangText='Subprotocol Definition:'><vspace blankLines='0'/>
  RFC 8323</t>
</list></t>

</section>
<section anchor="coap-option-numbers-registry" title="CoAP Option Numbers Registry">

<t>IANA has added this document as a reference for the following
entries registered by <xref target="RFC7959"/> in the "CoAP Option Numbers"
subregistry defined by <xref target="RFC7252"/>:</t>

<texttable title="CoAP Option Numbers" anchor="option-numbers">
      <ttcol align='left'>Number</ttcol>
      <ttcol align='left'>Name</ttcol>
      <ttcol align='left'>Reference</ttcol>
      <c>23</c>
      <c>Block2</c>
      <c>RFC 7959, RFC 8323</c>
      <c>27</c>
      <c>Block1</c>
      <c>RFC 7959, RFC 8323</c>
</texttable>

</section>
</section>

  </middle>

  <back>

    <references title='Normative References'>

<reference anchor='RFC0793' target='https://www.rfc-editor.org/info/rfc793'>
<front>
<title>Transmission Control Protocol</title>
<author initials='J.' surname='Postel' fullname='J. Postel'><organization /></author>
<date year='1981' month='September' />
</front>
<seriesInfo name='STD' value='7'/>
<seriesInfo name='RFC' value='793'/>
<seriesInfo name='DOI' value='10.17487/RFC0793'/>
</reference>

<?rfc include="reference.RFC.2119"?>
<?rfc include="reference.RFC.3986"?>
<?rfc include="reference.RFC.5234"?>
<?rfc include="reference.RFC.5246"?>
<?rfc include="reference.RFC.5785"?>
<?rfc include="reference.RFC.6066"?>
<?rfc include="reference.RFC.6455"?>
<?rfc include="reference.RFC.7252"?>
<?rfc include="reference.RFC.7301"?>
<?rfc include="reference.RFC.7525"?>
<?rfc include="reference.RFC.7595"?>
<?rfc include="reference.RFC.7641"?>
<?rfc include="reference.RFC.7925"?>
<?rfc include="reference.RFC.7959"?>
<?rfc include="reference.RFC.8126"?>
<?rfc include="reference.RFC.8174"?>
<?rfc include="reference.RFC.8307"?>

    </references>

    <references title='Informative References'>

<!-- draft-ietf-core-cocoa ("Publication Requested") -->
<reference anchor="CoCoA">
<front>
<title>CoAP Simple Congestion Control/Advanced</title>
<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>
<author initials='A' surname='Betzler' fullname='August Betzler'>
    <organization />
</author>
<author initials='C' surname='Gomez' fullname='Carles Gomez'>
    <organization />
</author>
<author initials='I' surname='Demirkol' fullname='Ilker Demirkol'>
    <organization />
</author>
<date month='October' year='2017' />
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-core-cocoa-02' />
</reference>

<!-- draft-ietf-core-object-security (I-D Exists) -->
<reference anchor="OSCORE">
<front>
<title>Object Security for Constrained RESTful Environments (OSCORE)</title>
<author initials='G' surname='Selander' fullname='Goeran Selander'>
    <organization />
</author>
<author initials='J' surname='Mattsson' fullname='John Mattsson'>
    <organization />
</author>
<author initials='F' surname='Palombini' fullname='Francesca Palombini'>
    <organization />
</author>
<author initials='L' surname='Seitz' fullname='Ludwig Seitz'>
    <organization />
</author>
<date month='January' year='2018' />
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-core-object-security-08' />
</reference>

<!-- draft-gomez-lwig-tcp-constrained-node-networks
   (replaced by draft-ietf-lwig-tcp-constrained-node-networks) (I-D Exists) -->
<reference anchor="TCP-in-IoT">
<front>
<title>TCP Usage Guidance in the Internet of Things (IoT)</title>
<author initials='C' surname='Gomez' fullname='Carles Gomez'>
    <organization />
</author>
<author initials='J' surname='Crowcroft' fullname='Jon Crowcroft'>
    <organization />
</author>
<author initials='M' surname='Scharf' fullname='Michael Scharf'>
    <organization />
</author>
<date month='October' year='2017' />
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-lwig-tcp-constrained-node-networks-01' />
</reference>

<!-- draft-thaler-appsawg-multi-transport-uris (Expired) -->
<reference anchor='Multi-Transport-URIs'>
<front>
<title>Using URIs With Multiple Transport Stacks</title>
<author initials='D' surname='Thaler' fullname='Dave Thaler'>
    <organization />
</author>
<date month='July' year='2017' />
</front>
<seriesInfo name='Work in Progress,' value='draft-thaler-appsawg-multi-transport-uris-01'/>
</reference>

<!-- draft-silverajan-core-coap-alternative-transports (Expired) -->
<reference anchor='CoAP-Alt-Transports'>
<front>
<title>CoAP Communication with Alternative Transports</title>
<author initials='B' surname='Silverajan' fullname='Bill Silverajan'>
    <organization />
</author>
<author initials='T' surname='Savolainen' fullname='Teemu Savolainen'>
    <organization />
</author>
<date month='July' year='2017' />
</front>
<seriesInfo name='Work in Progress,' value='draft-silverajan-core-coap-alternative-transports-10'/>
</reference>

<reference anchor="LWM2M" target="http://www.openmobilealliance.org/release/LightweightM2M/V1_0-20170208-A/OMA-TS-LightweightM2M-V1_0-20170208-A.pdf">
  <front>
    <title>Lightweight Machine to Machine Technical Specification Version 1.0</title>
    <author >
      <organization>Open Mobile Alliance</organization>
    </author>
    <date year="2017" month="February"/>
  </front>
  <format type="PDF" target="http://www.openmobilealliance.org/release/LightweightM2M/V1_0-20170208-A/OMA-TS-LightweightM2M-V1_0-20170208-A.pdf"/>
</reference>

<reference  anchor='RFC0768' target='https://www.rfc-editor.org/info/rfc768'>
<front>
<title>User Datagram Protocol</title>
<author initials='J.' surname='Postel' fullname='J. Postel'><organization /></author>
<date year='1980' month='August' />
</front>
<seriesInfo name='STD' value='6'/>
<seriesInfo name='RFC' value='768'/>
<seriesInfo name='DOI' value='10.17487/RFC0768'/>
</reference>

<?rfc include="reference.RFC.6335"?>
<?rfc include="reference.RFC.6347"?>
<?rfc include="reference.RFC.7230"?>
<?rfc include="reference.RFC.7540"?>

<reference anchor="HomeGateway" >
  <front>
    <title>An experimental study of home gateway characteristics</title>
    <author initials="S." surname="Haetoenen" fullname="Seppo Haetoenen">
      <organization></organization>
    </author>
    <author initials="A." surname="Nyrhinen" fullname="Aki Nyrhinen">
      <organization></organization>
    </author>
    <author initials="L." surname="Eggert" fullname="Lars Eggert">
      <organization></organization>
    </author>
    <author initials="S." surname="Strowes" fullname="Stephen Strowes">
      <organization></organization>
    </author>
    <author initials="P." surname="Sarolahti" fullname="Pasi Sarolahti">
      <organization></organization>
    </author>
    <author initials="N." surname="Kojo" fullname="Markku Kojo">
      <organization></organization>
    </author>
    <date month="November" year="2010"/>
  </front>
  <seriesInfo name="Proceedings of the 10th ACM SIGCOMM conference"
     value="on Internet measurement"/>
  <seriesInfo name="DOI" value="10.1145/1879141.1879174"/>
</reference>

<reference anchor="SecurityChallenges" target="https://www.iab.org/wp-content/IAB-uploads/2011/03/Turner.pdf">
  <front>
    <title>Security Challenges For the Internet Of Things</title>
    <author initials="T." surname="Polk" fullname="Tim Polk">
      <organization></organization>
    </author>
    <author initials="S." surname="Turner" fullname="Sean Turner">
      <organization></organization>
    </author>
    <date year="2011" month="February"/>
  </front>
  <seriesInfo name="Interconnecting Smart Objects with the Internet /" value="IAB Workshop"/>
</reference>

<reference anchor="EK2016" target="https://arxiv.org/abs/1612.07816">
  <front>
    <title>Using UDP for Internet Transport Evolution</title>
    <author initials="K." surname="Edeline" fullname="Korian Edeline">
      <organization></organization>
    </author>
    <author initials="M." surname="Kuehlewind" fullname="Mirja Kuehlewind">
      <organization></organization>
    </author>
    <author initials="B." surname="Trammell" fullname="Brian Trammell">
      <organization></organization>
    </author>
    <author initials="E." surname="Aben" fullname="Emile Aben">
      <organization></organization>
    </author>
    <author initials="B." surname="Donnet" fullname="Benoit Donnet">
      <organization></organization>
    </author>
    <date month="December" year="2016"/>
  </front>
  <seriesInfo name="arXiv" value="preprint 1612.07816"/>
</reference>

<reference anchor="SW2016" target="https://www.ietf.org/proceedings/96/slides/slides-96-quic-3.pdf">
  <front>
    <title>QUIC Deployment Experience @Google</title>
    <author initials="I." surname="Swett" fullname="Ian Swett">
      <organization></organization>
    </author>
    <date month="July" year="2016"/>
  </front>
  <seriesInfo name="IETF 96 Proceedings," value="Berlin, Germany"/>
</reference>

<!-- draft-byrne-opsec-udp-advisory (Expired) -->
<reference anchor="BK2015" >
  <front>
    <title>Advisory Guidelines for UDP Deployment</title>
    <author initials="C." surname="Byrne" fullname="Cameron Byrne">
      <organization></organization>
    </author>
    <author initials="J." surname="Kleberg" fullname="Jason Kleberg">
      <organization></organization>
    </author>
    <date month="July" year="2015"/>
  </front>
  <seriesInfo name="Work in Progress," value="draft-byrne-opsec-udp-advisory-00"/>
</reference>

<reference anchor="IANA.uri-schemes" target='https://www.iana.org/assignments/uri-schemes'>
<front>
<title>Uniform Resource Identifier (URI) Schemes</title>
<author><organization>IANA</organization></author>
<date/>
</front>
</reference>

</references>

<section anchor="examples" title="Examples of CoAP over WebSockets">

<t>This appendix gives examples for the first two configurations
discussed in <xref target="websockets-overview"/>.</t>

<t>An example of the process followed by a CoAP client to retrieve the
representation of a resource identified by a "coap+ws" URI might be as
follows. <xref target="example-1"/> below illustrates the WebSocket and
CoAP messages exchanged in detail.</t>

<t><list style="numbers">
  <t>The CoAP client obtains the URI
  <vspace/> 
  &lt;coap+ws://example.org/sensors/temperature?u=Cel&gt;,
  for example, from a resource representation that it retrieved
  previously.</t>
  <t>The CoAP client establishes a WebSocket connection to the endpoint URI
  composed of the authority "example.org" and the well-known path
  "/.well-known/coap", &lt;ws://example.org/.well&nbhy;known/coap&gt;.</t>
  <t>CSMs (<xref target="csm"/>) are exchanged (not shown).</t>
  <t>The CoAP client sends a single-frame, masked, binary message containing a
  CoAP request. The request indicates the target resource with the
  Uri&nbhy;Path ("sensors", "temperature") and Uri&nbhy;Query ("u=Cel")
  Options.</t>
  <t>The CoAP client waits for the server to return a response.</t>
  <t>The CoAP client uses the connection for further requests, or the
  connection is closed.</t>
</list></t>

<figure title="A CoAP Client Retrieves the Representation of a Resource Identified by a &quot;coap+ws&quot; URI" anchor="example-1"><artwork><![CDATA[
   CoAP        CoAP
  Client      Server
(WebSocket  (WebSocket
  Client)     Server)

     |          |
     |          |
     +=========>|  GET /.well-known/coap HTTP/1.1
     |          |  Host: example.org
     |          |  Upgrade: websocket
     |          |  Connection: Upgrade
     |          |  Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
     |          |  Sec-WebSocket-Protocol: coap
     |          |  Sec-WebSocket-Version: 13
     |          |
     |<=========+  HTTP/1.1 101 Switching Protocols
     |          |  Upgrade: websocket
     |          |  Connection: Upgrade
     |          |  Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
     |          |  Sec-WebSocket-Protocol: coap
     :          :
     :<-------->:  Exchange of CSMs (not shown)
     |          |
     +--------->|  Binary frame (opcode=%x2, FIN=1, MASK=1)
     |          |    +-------------------------+
     |          |    | GET                     |
     |          |    | Token: 0x53             |
     |          |    | Uri-Path: "sensors"     |
     |          |    | Uri-Path: "temperature" |
     |          |    | Uri-Query: "u=Cel"      |
     |          |    +-------------------------+
     |          |
     |<---------+  Binary frame (opcode=%x2, FIN=1, MASK=0)
     |          |    +-------------------------+
     |          |    | 2.05 Content            |
     |          |    | Token: 0x53             |
     |          |    | Payload: "22.3 Cel"     |
     |          |    +-------------------------+
     :          :
     :          :
     +--------->|  Close frame (opcode=%x8, FIN=1, MASK=1)
     |          |
     |<---------+  Close frame (opcode=%x8, FIN=1, MASK=0)
     |          |
]]></artwork></figure>

<t><xref target="example-2"/> shows how a CoAP client uses a CoAP
forward proxy with a WebSocket endpoint to retrieve the representation
of the resource "coap://[2001:db8::1]/". The use of the forward proxy and the
address of the WebSocket endpoint are determined by the client from local
configuration rules. The request URI is specified in the Proxy&nbhy;Uri
Option. Since the request URI uses the "coap" URI scheme, the proxy fulfills
the request by issuing a Confirmable GET request over UDP to the CoAP server
and returning the response over the WebSocket connection to the client.</t>

<figure title="A CoAP Client Retrieves the Representation of a Resource Identified by a &quot;coap&quot; URI via a WebSocket-Enabled CoAP Proxy" anchor="example-2"><artwork><![CDATA[
   CoAP        CoAP       CoAP
  Client      Proxy      Server
(WebSocket  (WebSocket    (UDP
  Client)     Server)   Endpoint)

     |          |          |
     +--------->|          |  Binary frame (opcode=%x2, FIN=1, MASK=1)
     |          |          |    +------------------------------------+
     |          |          |    | GET                                |
     |          |          |    | Token: 0x7d                        |
     |          |          |    | Proxy-Uri: "coap://[2001:db8::1]/" |
     |          |          |    +------------------------------------+
     |          |          |
     |          +--------->|  CoAP message (Ver=1, T=Con, MID=0x8f54)
     |          |          |    +------------------------------------+
     |          |          |    | GET                                |
     |          |          |    | Token: 0x0a15                      |
     |          |          |    +------------------------------------+
     |          |          |
     |          |<---------+  CoAP message (Ver=1, T=Ack, MID=0x8f54)
     |          |          |    +------------------------------------+
     |          |          |    | 2.05 Content                       |
     |          |          |    | Token: 0x0a15                      |
     |          |          |    | Payload: "ready"                   |
     |          |          |    +------------------------------------+
     |          |          |
     |<---------+          |  Binary frame (opcode=%x2, FIN=1, MASK=0)
     |          |          |    +------------------------------------+
     |          |          |    | 2.05 Content                       |
     |          |          |    | Token: 0x7d                        |
     |          |          |    | Payload: "ready"                   |
     |          |          |    +------------------------------------+
     |          |          |
]]></artwork></figure>

</section>

<section numbered="no" anchor="acknowledgments" title="Acknowledgments">

<t>We would like to thank Stephen Berard, Geoffrey Cristallo,
Olivier Delaby, Esko Dijk, Christian Groves, Nadir Javed,
Michael Koster, Achim Kraus, David Navarro,
Szymon Sasin, Goeran Selander, Zach Shelby, Andrew Summers,
Julien Vermillard, and Gengyu Wei for their feedback.</t>

<t>Last Call reviews from Yoshifumi Nishida, Mark Nottingham, and
Meral Shirazipour as well as several IESG reviewers provided extensive
comments; from the IESG, we would like to specifically call out Ben Campbell,
Mirja Kuehlewind, Eric Rescorla, Adam Roach, and the responsible AD Alexey
Melnikov.</t>
</section>

<section numbered="no" anchor="contributors" title="Contributors">

<figure><artwork><![CDATA[
Matthias Kovatsch
Siemens AG
Otto-Hahn-Ring 6
Munich  D-81739
Germany

Phone: +49-173-5288856
Email: matthias.kovatsch@siemens.com


Teemu Savolainen
Nokia Technologies
Hatanpaan valtatie 30
Tampere  FI-33100
Finland

Email: teemu.savolainen@nokia.com


Valik Solorzano Barboza
Zebra Technologies
820 W. Jackson Blvd. Suite 700
Chicago, IL  60607
United States of America

Phone: +1-847-634-6700
Email: vsolorzanobarboza@zebra.com
]]></artwork></figure>

</section>

  </back>

</rfc>

