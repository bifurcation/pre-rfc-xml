<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
    <!ENTITY rfc4512 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4512.xml'>
    <!ENTITY rfc4517 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4517.xml'>
    <!ENTITY rfc2307 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2307.xml'>
    <!ENTITY rfc4514 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4514.xml'>
    <!ENTITY rfc4515 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4515.xml'>
    <!ENTITY rfc4516 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4516.xml'>
    <!ENTITY rfc4519 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4519.xml'>
    <!ENTITY rfc3986 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml'>
    <!ENTITY rfc4511 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4511.xml'>
    <!ENTITY rfc4510 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4510.xml'>
    <!ENTITY rfc4422 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4422.xml'>
    <!ENTITY rfc4520 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4520.xml'>
    <!ENTITY rfc2831 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2831.xml'>
    <!ENTITY rfc2849 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2849.xml'>
    <!ENTITY rfc2789 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2789.xml'>
    <!ENTITY rfc4234 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4234.xml'>
]>

<rfc number="4876" category="info">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc rfcedstyle="yes" ?>
<?rfc subcompact="no" ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>


<front>
    <title abbrev="LDAP-Based Agent Configuration Schema">A
    Configuration Profile Schema for Lightweight&nbsp;Directory&nbsp;Access&nbsp;Protocol&nbsp;(LDAP)-Based&nbsp;Agents</title>

    <author initials='B.' surname="Neal-Joslin" fullname='Bob Neal-Joslin' role="editor">
        <organization abbrev="HP">Hewlett-Packard Company</organization>
        <address>
          <postal>
            <street>19420 Homestead RD</street>
            <street>M/S 4029</street>
            <city>Cupertino</city>
            <region>CA</region>
            <code>95014</code>
            <country>US</country>
          </postal>
          <phone>+1 408 447 3044</phone>
          <email>bob_joslin@hp.com</email>
          <uri>http://www.hp.com</uri>
        </address>
    </author>

    <author initials='L.H' surname="Howard" fullname='Luke Howard'>
        <organization abbrev="PADL">PADL Software Pty. Ltd.</organization>
        <address>
          <postal>
            <street>PO Box 59</street>
            <city>Central Park</city>
            <region>Vic</region>
            <code>3145</code>
            <country>AU</country>
          </postal>
          <email>lukeh@padl.com</email>
          <uri>http://www.padl.com</uri>
        </address>
    </author>

    <author initials='M.A' surname="Ansari" fullname='Morteza Ansari'>
        <organization>Infoblox</organization>
        <address>
          <postal>
            <street>475 Potrero Avenue</street>
            <city>Sunnyvale</city>
            <region>CA</region>
            <code>94085</code>
            <country>US</country>
          </postal>
          <phone>+1 408 716 4300</phone>
          <email>morteza@infoblox.com</email>
        </address>
    </author>

    <date month="May" year="2007"/>
    
    <area>General</area>

<workgroup>Individual Submission</workgroup>
<keyword>LDAP</keyword>
<keyword>schema</keyword>
<keyword>profile</keyword>
<keyword>configuration</keyword>
<keyword>RFC2307</keyword>
<keyword>RFC 2307</keyword>
<keyword>nss_ldap</keyword>
<keyword>pam_ldap</keyword>
<keyword>NSS</keyword>
<keyword>name service</keyword>

<note title="IESG Note">
<t>
This RFC is not a candidate for any level of Internet Standard.
The IETF disclaims any knowledge of the fitness of this RFC for
any purpose and in particular notes that the decision to publish
is not based on IETF review for such things as security,
congestion control, or inappropriate interaction with deployed
protocols.  The RFC Editor has chosen to publish this document at
its discretion.  Readers of this document should exercise caution
in evaluating its value for implementation and deployment.  See
RFC 3932 for more information.
</t>
</note>

<abstract>
<t>
This document consists of two primary components, a schema for agents
that make use of the Lightweight Directory Access protocol (LDAP) and
a proposed use case of that schema, for distributed configuration of similar
directory user agents.  A set of attribute types and an object class are
proposed.  In the proposed use case, directory user agents (DUAs) can use
this schema to determine directory data location and access parameters for
specific services they support. In addition, in the proposed use case, 
attribute and object class mapping allows DUAs to reconfigure their expected
(default) schema to match that of the end user's environment. This document
is intended to be a skeleton for future documents that describe configuration
of specific DUA services.
</t>
</abstract>

</front>

<middle>
<section title="Background and Motivation" anchor="background">
<t>
LDAP <xref target="RFC4510"/> has brought about a nearly ubiquitous acceptance
of the directory server.  Many client applications (DUAs) are being created 
that use LDAP directories for many different services.  And although the LDAP
protocol has eased the development of these applications, some challenges still
exist for both developers and directory administrators.
</t>

<t>
The authors of this document are implementers of DUAs described by
<xref target="RFC2307"/>.  In developing these agents, we felt there were several
issues that still need to be addressed to ease the deployment and configuration
of a large network of these DUAs.
</t>

<t>
One of these challenges stems from the lack of a utopian schema.  A utopian
schema would be one that every application developer could agree upon and that
would support every application.  Unfortunately today, many DUAs define their
own schema, even when they provide similar services (like RFC 2307 vs.
Microsoft's Services for Unix <xref target="MSSFU"/>).  These schemas contain
similar attributes, but use different attribute names.  This can
lead to data redundancy within directory entries and cause directory
administrators unwanted challenges, updating schemas and synchronizing data.
Or, in a more common case, two or more applications may agree on common
schema elements, but choose a different schema for other elements of data
that might also be shareable between the applications.  While data
synchronization and translation tools exist, the authors of this document
believe there is value in providing this capability in the directory user
agent itself.
</t>

<t>
Aside from proposing a schema for general use, one goal of this document is
to eliminate data redundancy by having DUAs configure themselves to the schema
of the deployed directory, instead of forcing the DUA's own schema on the
directory.
</t>

<t>
Another goal of this document is to provide the DUA with enough configuration
information so that it can discover how to retrieve its data in the directory,
such as what locations to search in the directory tree.
</t>

<t>
Finally, this document intends to describe a configuration method for DUAs that can
be shared among many DUAs on various platforms, providing, as such, a configuration
profile.  The purpose of this profile is to centralize and simplify management of DUAs.
</t>

<t>
This document is intended to provide the skeleton framework for future
documents that
will describe the individual implementation details for the particular services
provided by that DUA.  The authors of this document plan to develop such a document
for the Network Information Service DUA, described by RFC 2307 or its successor.
</t>

<!-- [rfced] What is the intended use of "object class" vs. "objectclass"? 
Note the mix in this paragraph and throughout the document. -->
<!-- [author-bob] "object class" refers to the concept of the object class while
"objectclass" refers specifically to the objectclass attribute.  Unfortunately,
I have used "objectclass" many times when I meant to use "object class".
I have fixed this. -->
<t>
We expect that as DUAs take advantage of this configuration scheme, each DUA
will require additional configuration parameters, not specified by this document.
Thus, we would expect that new auxiliary object classes that contain new
configuration attributes will be created and then joined with the structural
class defined by this document to create a configuration profile for a particular
DUA service.   By joining various auxiliary object classes for different
DUA services, the configuration of various DUA services can be controlled by a
single configuration profile entry.
</t>
</section>

<section title="General Information">
<t>
The schema defined by this document is defined under the "DUA
Configuration Schema".  This schema is derived from the object
identifier (OID):
iso (1) org (3) dod (6) internet (1) private (4) enterprises (1)
Hewlett-Packard Company (11) directory (1) LDAP-UX Integration Project (3)
DUA Configuration Schema (1).  This OID is represented in
this document by the keystring "DUAConfSchemaOID" (1.3.6.1.4.1.11.1.3.1).
</t>

<section title="Requirements Notation">
<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
"SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
and "OPTIONAL" in this document are to be interpreted as
described in <xref target="RFC2119"/>.
</t>
</section>

<section title="Attributes Summary">

<figure>
<preamble>The following attributes are defined in this document:</preamble>
<artwork>
preferredServerList
defaultServerList
defaultSearchBase
defaultSearchScope
authenticationMethod
credentialLevel
serviceSearchDescriptor
serviceCredentialLevel
serviceAuthenticationMethod
attributeMap
objectclassMap
searchTimeLimit
bindTimeLimit
followReferrals
dereferenceAliases
profileTTL
</artwork>
</figure>

</section>
<section title="Object Classes Summary">

<figure>
<preamble>The following object class is defined in this document:</preamble>
<artwork>
DUAConfigProfile
</artwork></figure>


</section>

<section title="Common Syntax/Encoding Definitions">
<t>
The proposed string encodings used by the attributes defined in
this document can be found in <xref target="DUAImplementation"/>.  This document
makes use of ABNF <xref target="RFC4234"/> for defining new encodings.
</t>
<t>
The following syntax definitions are used throughout this document.  
</t>

<texttable>
<preamble>The list of used syntaxes are:</preamble>

<ttcol align='left'>Key</ttcol>
<ttcol align='left'>Source</ttcol>

<c>keystring</c>
<c>as defined by <xref target="RFC4512"/> Section 1.4</c>

<c>descr</c>
<c>as defined by <xref target="RFC4512"/> Section 1.4</c>

<c>SP</c>
<c>as defined by <xref target="RFC4512"/> Section 1.4</c>

<c>WSP</c>
<c>as defined by <xref target="RFC4512"/> Section 1.4</c>

<c>base</c>
<c>as defined by distinguishedName in <xref target="RFC4514"/></c>

<c>distinguishedName</c>
<c>as defined by <xref target="RFC4514"/> Section 2</c>

<c>relativeDistinguishedName</c>
<c>as defined by <xref target="RFC4514"/> Section 2</c>

<c>scope</c>
<c>as defined by <xref target="RFC4516"/> Section 2</c>

<c>host</c>
<c>as defined by <xref target="RFC3986"/> Section 3.2.2</c>

<c>hostport</c>
<c>host [":" port ]</c>

<c>port</c>
<c>as defined by <xref target="RFC3986"/> Section 3.2.3</c>

<c>serviceID</c>
<c>same as keystring</c>
</texttable>

<t>
This document does not define new syntaxes that must be supported by the
directory server.  Instead, these syntaxes are merely expected to be interpreted
by the DUA.  As referenced in the schema definition in <xref target="schema"/>,
most encodings are expected to be stored in attributes using common syntaxes, such
as the Directory String syntax, as defined in Section 3.3.6 of <xref target="RFC4517"/>.
Refer to RFC 4517 for additional syntaxes used by this schema.</t>
</section>
</section>

<section title="Schema Definition" anchor="schema">
<t>
This section defines a proposed schema.  This schema does not require
definition of new matching rules or syntaxes, and it may be used for
any purpose seen.  A proposed use of this schema to support elements
of configuration of a directory user agent is described in
<xref target="DUAImplementation"/>.
</t>

<section title="Attribute Definitions" anchor="attributes">

<t>
This section contains attribute definitions used by agents.  The syntax used
to describe these attributes is defined in <xref target="RFC4512"/>,
Section 4.1.2.  Individual syntaxes and matching rules used within these
descriptions are described in <xref target="RFC4517"/>, Sections 3.3 and 4.2,
respectively.
</t>

<?rfc needLines="6"?>
<artwork>
( 1.3.6.1.4.1.11.1.3.1.1.0 NAME 'defaultServerList'
  DESC 'List of default servers'
  EQUALITY caseIgnoreMatch
  SUBSTR caseIgnoreSubstringsMatch
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.15
  SINGLE-VALUE )
</artwork>
<artwork>
( 1.3.6.1.4.1.11.1.3.1.1.1 NAME 'defaultSearchBase'
  DESC 'Default base for searches'
  EQUALITY distinguishedNameMatch
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.12
  SINGLE-VALUE )
</artwork>
<artwork>
( 1.3.6.1.4.1.11.1.3.1.1.2 NAME 'preferredServerList'
  DESC 'List of preferred servers'
  EQUALITY caseIgnoreMatch
  SUBSTR caseIgnoreSubstringsMatch
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.15
  SINGLE-VALUE )
</artwork>
<artwork>
( 1.3.6.1.4.1.11.1.3.1.1.3 NAME 'searchTimeLimit'
  DESC 'Maximum time an agent or service allows for a
  search to complete'
  EQUALITY integerMatch
  ORDERING integerOrderingMatch
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
  SINGLE-VALUE )
</artwork>
<artwork>
( 1.3.6.1.4.1.11.1.3.1.1.4 NAME 'bindTimeLimit'
  DESC 'Maximum time an agent or service allows for a
  bind operation to complete'
  EQUALITY integerMatch
  ORDERING integerOrderingMatch
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
  SINGLE-VALUE )
</artwork>
<artwork>
( 1.3.6.1.4.1.11.1.3.1.1.5 NAME 'followReferrals'
  DESC 'An agent or service does or should follow referrals'
  EQUALITY booleanMatch
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.7
  SINGLE-VALUE )
</artwork>
<artwork>
( 1.3.6.1.4.1.11.1.3.1.1.6 NAME 'authenticationMethod'
  DESC 'Identifies the types of authentication methods either
  used, required, or provided by a service or peer'
  EQUALITY caseIgnoreMatch
  SUBSTR caseIgnoreSubstringsMatch
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.15
  SINGLE-VALUE )
</artwork>
<artwork>
( 1.3.6.1.4.1.11.1.3.1.1.7 NAME 'profileTTL'
  DESC 'Time to live, in seconds, before a profile is
  considered stale'
  EQUALITY integerMatch
  ORDERING integerOrderingMatch
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
  SINGLE-VALUE )
</artwork>
<artwork>
( 1.3.6.1.4.1.11.1.3.1.1.9 NAME 'attributeMap'
  DESC 'Attribute mappings used, required, or supported by an
  agent or service'
  EQUALITY caseIgnoreIA5Match
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
</artwork>
<artwork>
( 1.3.6.1.4.1.11.1.3.1.1.10 NAME 'credentialLevel'
  DESC 'Identifies type of credentials either used, required,
  or supported by an agent or service'
  EQUALITY caseIgnoreIA5Match
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.26
  SINGLE-VALUE )
</artwork>
<artwork>
( 1.3.6.1.4.1.11.1.3.1.1.11 NAME 'objectclassMap'
  DESC 'Object class mappings used, required, or supported by
  an agent or service'
  EQUALITY caseIgnoreIA5Match
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
</artwork>
<artwork>
( 1.3.6.1.4.1.11.1.3.1.1.12 NAME 'defaultSearchScope'
  DESC 'Default scope used when performing a search'
  EQUALITY caseIgnoreIA5Match
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.26
  SINGLE-VALUE )
</artwork>
<artwork>
( 1.3.6.1.4.1.11.1.3.1.1.13 NAME 'serviceCredentialLevel'
  DESC 'Specifies the type of credentials either used, required,
  or supported by a specific service'
  EQUALITY caseIgnoreIA5Match
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
</artwork>
<artwork>
( 1.3.6.1.4.1.11.1.3.1.1.14 NAME 'serviceSearchDescriptor'
  DESC 'Specifies search descriptors required, used, or
  supported by a particular service or agent'
  EQUALITY caseExactMatch
  SUBSTR caseExactSubstringsMatch
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )
</artwork>
<artwork>
( 1.3.6.1.4.1.11.1.3.1.1.15 NAME 'serviceAuthenticationMethod'
  DESC 'Specifies types authentication methods either
  used, required, or supported by a particular service'
  EQUALITY caseIgnoreMatch
  SUBSTR caseIgnoreSubstringsMatch
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )
</artwork>
<artwork>
( 1.3.6.1.4.1.11.1.3.1.1.16 NAME 'dereferenceAliases'
  DESC 'Specifies if a service or agent either requires,
  supports, or uses dereferencing of aliases.'
  EQUALITY booleanMatch
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.7
  SINGLE-VALUE )
</artwork>

</section>

<section title="Class Definition">
<t>
The object class below is constructed from the attributes defined
in <xref target="attributes"/>, with the exception of the "cn" attribute,
which is defined in <xref target="RFC4519"/>.  "cn" is used to represent the
name of the DUA configuration profile and is recommended for the relative
distinguished name (RDN) <xref target="RFC4514"/> naming
attribute.  This object class is used specifically by the DUA described in
<xref target="DUAImplementation"/>.  The syntax used to describe this
object class is defined in <xref target="RFC4512"/>, Section 4.1.1.
</t>
<figure>
<artwork>
( 1.3.6.1.4.1.11.1.3.1.2.5 NAME 'DUAConfigProfile'
  SUP top STRUCTURAL
  DESC 'Abstraction of a base configuration for a DUA'
  MUST ( cn )
  MAY ( defaultServerList $ preferredServerList $
        defaultSearchBase $ defaultSearchScope $
        searchTimeLimit $ bindTimeLimit $ 
        credentialLevel $ authenticationMethod $
        followReferrals $ dereferenceAliases $
        serviceSearchDescriptor $ serviceCredentialLevel $
        serviceAuthenticationMethod $ objectclassMap $
        attributeMap $ profileTTL ) )
</artwork>
</figure>
</section>
</section>

<section title="DUA Implementation Details" anchor="DUAImplementation">
<t>
This section describes an implementation of the schema described in <xref target="schema"/>.
Details about how a DUA should format and interpret the defined attributes are described
below.  Agents that make use of the DUAConfigProfile object class are expected to
follow the specifications in this section.
</t>
<t>
Note:  Many of the subsections below contain examples.  Unless otherwise
specified, these examples are rendered using the LDAP Data Interchange
Format (LDIF) <xref target="RFC2849"/>.
</t>
<section title="Interpreting the preferredServerList Attribute" anchor="preferredServerList">
<t>
<!-- <list><t> -->
Interpretation:
<list><t>
As described by the syntax, the preferredServerList parameter is
a whitespace-separated list of server addresses and associated
port numbers.  When the DUA needs to contact a directory server
agent (DSA), the DUA MUST
first attempt to contact one of the servers listed in the
preferredServerList attribute.  The DUA MUST contact the DSA
specified by the first server address in the list.  If that DSA
is unavailable, the remaining DSAs MUST be queried in the order
provided (left to right) until a connection is established with a
DSA.  Once a connection with a DSA is established, the DUA
SHOULD NOT attempt to establish a connection with the remaining
DSAs.  The purpose of enumerating multiple DSAs is not for
supplemental data, but for high availability of replicated data.
This is also the main reason why an LDAP URL <xref target="RFC3986"/>
syntax was not selected for this document.
</t>
<t>
If the DUA is unable to contact any of the DSAs specified by the
preferredServerList, the defaultServerList attribute MUST be
examined, as described in <xref target="defaultServerList"/>.
The servers identified by the preferredServerList MUST be contacted
before attempting to contact any of the servers specified by the
defaultServerList.
</t></list>
</t>
<t>Syntax:
<list><t>
serverList = hostport *(SP [hostport])
</t></list>
</t>
<t>Default Value:
<list><t>
The preferredServerList attribute does not have a default value.
Instead a DUA MUST examine the defaultServerList attribute.
</t></list>
</t>
<t>Other attribute notes:
<list><t>
This attribute is used in conjunction with the defaultServerList
attribute.  Please see <xref target="defaultServerList"/> for
additional implementation notes.  Determining how the DUA should
query the DSAs also depends on the additional configuration
attributes, credentialLevel, serviceCredentialLevel,
bindTimeLimit, serviceAuthenticationMethod, and
authenticationMethod.  Please review <xref target="binding"/>
for details on how a DUA should properly bind to a DSA.
</t></list>
</t>
<t>Example:
<figure><artwork>
      preferredServerList: 192.168.169.170 ldap1.mycorp.com
        ldap2:1389 [1080::8:800:200C:417A]:389
</artwork></figure>
<!-- </t></list> -->
</t>
</section>

<section title="Interpreting the defaultServerList Attribute" anchor="defaultServerList">
<t>
<!--<list><t>-->
Interpretation:
<list><t>
The defaultServerList attribute MUST only be examined if the
preferredServerList attribute is not provided, or the DUA
is unable to establish a connection with any of the DSAs
specified by the preferredServerList.
</t>
<t>
If more than one address is provided, the DUA may choose
either to accept the order provided or to create its own
order, based on what the DUA determines is the "best" order of
DSAs to query.  For example, the DUA may choose to examine the
server list and to query the DSAs in order based on the
"closest" server or the server with the least amount of "load".
Interpretation of the "best" server order is entirely up to the
DUA, and not part of this document.
</t>
<t>
Once the order of server addresses is determined, the DUA
contacts the DSA specified by the first server address in the list.
If that DSA is unavailable, the remaining DSAs SHOULD be queried
until an available DSA is found, or no more DSAs are available.  If
a server address or port is invalid, the DUA SHOULD proceed to the
next server address as described just above.
</t></list>
</t>
<t>Syntax:
<list><t>
serverList = hostport *(SP [hostport])
</t></list>
</t>
<t>Default Value:
<list><t>
If a defaultServerList attribute is not provided, the DUA MAY
attempt to contact the same DSA that provided the configuration
profile entry itself.  The default DSA is contacted only if the
preferredServerList attribute is also not provided.
</t></list>
</t>
<t>Other attribute notes:
<list><t>
This attribute is used in conjunction with the preferredServerList
attribute.  Please see <xref target="preferredServerList"/> for additional implementation
notes.  Determining how the DUA should query the DSAs also depends
on the additional configuration attributes, credentialLevel,
serviceCredentialLevel, bindTimeLimit, serviceAuthenticationMethod,
and authenticationMethod.  Please review <xref target="binding"/> for details on
how a DUA should properly contact a DSA.
</t></list>
</t>
<t>Example:
<figure><artwork>
      defaultServerList: 192.168.169.170 ldap1.mycorp.com
        ldap2:1389 [1080::8:800:200C:417A]:5912
</artwork></figure>
<!--</t></list>-->
</t>
</section>

<section title="Interpreting the defaultSearchBase Attribute" anchor="defaultSearchBase">
<t>
<!--<list><t>-->
Interpretation:
<list><t>
When a DUA needs to search the DSA for information, this
attribute provides the base for the search.  This parameter can
be overridden or appended by the serviceSearchDescriptor attribute.
See <xref target="serviceSearchDescriptor"/>.
</t></list>
</t>
<t>Syntax:
<list><t>
Defined by OID 1.3.6.1.4.1.1466.115.121.1.12 <xref target="RFC4517"/>.
</t></list>
</t>
<t>Default Value:
<list><t>
There is no default value for the defaultSearchBase.  A DUA MAY define
its own method for determining the search base, if the defaultSearchBase
is not provided.
</t></list>
</t>
<t>Other attribute notes:
<list><t>
This attribute is used in conjunction with the serviceSearchDescriptor
attribute.  See <xref target="serviceSearchDescriptor"/>.
</t></list>
</t>
<t>Example:
<figure><artwork>
      defaultSearchBase: dc=mycompany,dc=com
</artwork></figure>
<!--</t></list>-->
</t>
</section>

<section title="Interpreting the authenticationMethod Attribute" anchor="authenticationMethod">
<t>
<!--<list><t>-->
Interpretation:
<list><t>
The authenticationMethod attribute defines an ordered list of LDAP bind
methods to be used when attempting to contact a DSA.   The
serviceAuthenticationMethod overrides this value for a particular
service (see <xref target="serviceAuthenticationMethod"/>).  Each method
MUST be attempted in the order provided by the attribute, until a successful
LDAP bind is performed ("none" is assumed to always be successful). However,
the DUA MAY skip over one or more methods.  See
<xref target="binding"/> for more information.
</t>
<t>
<list style="hanging" hangIndent="9">
<t hangText="none   -">
The DUA does not perform an LDAP bind.
</t>
<t hangText="simple -">
The DUA performs an LDAP simple bind.
</t>
<t hangText="sasl   -">
The DUA performs an LDAP Simple Authentication and Security Layer
(SASL) <xref target="RFC4422"/> bind using the specified
SASL mechanism and options.
</t>
<t hangText="tls    -">
The DUA performs an LDAP StartTLS operation followed by the specified bind method (for
more information refer to Section 4.14 of <xref target="RFC4511"/>).
</t></list>
</t></list>
</t>
<t>Syntax:
<list>
<list style="hanging" hangIndent="14">
<t hangText="authMethod  =">
method *(";" method)
</t>
<t hangText="method      =">
none / simple / sasl / tls
</t>
<t hangText="none        =">
"none"
</t>
<t hangText="simple      =">
"simple"
</t>
<t hangText="sasl        =">
"sasl/" saslmech [ ":" sasloption ]
</t>
<t hangText="sasloption  =">
"auth-conf" / "auth-int"
</t>
<t hangText="tls         =">
"tls:" (none / simple / sasl)
</t>
<t hangText="saslmech    =">
SASL mechanism name as defined in <xref target="SASLMECH"/>
</t>
</list>
<t>Note: Although multiple authentication methods may be specified in the syntax,
at most one of each type is allowed.  That is, "simple;simple" is invalid.
</t></list>
</t>
<t>Default Value:
<list><t>
If the authenticationMethod or serviceAuthenticationMethod (for that particular
service) attributes are not provided, the DUA MAY choose to
bind to the DSA using any method defined by the DUA.
However, if either authenticationMethod or serviceAuthenticationMethod is
provided, the DUA MUST only use the methods specified.
</t></list>
</t>
<t>Other attribute notes:
<list><t>
When using TLS, the string "tls:sasl/EXTERNAL" implies that both client and
server (DSA and DUA) authentications are to be performed.  Any other TLS
authentication method implies server-only (DSA side credential) 
authentication, along with the other SASL method used for DUA-side 
authentication.
</t>
<t>
Determining how the DUA should bind to the DSAs also depends
on the additional configuration attributes, credentialLevel,
serviceCredentialLevel, serviceAuthenticationMethod, and bindTimeLimit.
Please review <xref target="binding"/> for details on how to properly bind to a DSA.

</t></list>
</t>
<t>Example:
<figure><artwork>
   authenticationMethod: tls:simple;sasl/DIGEST-MD5
</artwork></figure>
<list><t>
(see <xref target="RFC2831"/>)
</t></list>
</t>
</section>

<?rfc needLines="9"?>
<section title="Interpreting the credentialLevel Attribute" anchor="credentialLevel">
<t>
<!--<list><t>-->
Interpretation:
<list><t>
The credentialLevel attribute defines what type(s) of credential(s)
the DUA MUST use when contacting the DSA.  The serviceCredentialLevel
overrides this value for a particular service (<xref target="serviceCredentialLevel"/>).  The credentialLevel
can contain more than one credential type, separated by whitespace.

<list style="hanging" hangIndent="10">
<t hangText="anonymous">
The DUA SHOULD NOT use a credential when 
binding to the DSA.
</t>

<t hangText="proxy">
The DUA SHOULD use a known proxy identity when binding
to the DSA.  A proxy identity is a specific credential that was
created to represent the DUA.  This document does not define how
the proxy user should be created, or how the DUA should determine
what the proxy user's credential is.  This functionality is up
to each implementation.
</t>

<t hangText="self">
When the DUA is acting on behalf of a known identity, the
DUA MUST attempt to bind to the DSA as that identity.  The DUA should
contain methods to determine the identity of the user such that the
identity can be authenticated by the directory server using the
defined authentication methods.
</t>
</list>
If the credentialLevel contains more than one credential type, the DUA
MUST use the credential types in the order specified.  However, the DUA
MAY skip over one or more credential types.  As soon as
the DUA is able to successfully bind to the DSA, the DUA SHOULD NOT
attempt to bind using the remaining credential types.
</t></list>
</t>
<t>Syntax:
<list>
<list style="hanging" hangIndent="20">
<t hangText="credentialLevel   =">
level *(SP level)
</t>
<t hangText="level             =">
self / proxy / anonymous
</t>
<t hangText="self              =">
"self"
</t>
<t hangText="proxy             =">
"proxy"
</t>
<t hangText="anonymous         =">
"anonymous"
</t>
</list>
<t>
Note: Although multiple credential levels may be specified in the syntax,
at most one of each type is allowed.  Refer to implementation notes in
<xref target="binding"/> for additional syntax requirements for the credentialLevel
attribute.
</t>
</list></t>
<t>Default Value:
<list><t>
If the credentialLevel attribute is not defined, the DUA SHOULD
NOT use a credential when binding to the DSA (also known as
anonymous).
</t></list>
</t>
<t>Other attribute notes:
<list><t>
Determining how the DUA should bind to the DSAs also depends
on the additional configuration attributes, authenticationMethod,
serviceAuthenticationMethod, serviceCredentialLevel, and bindTimeLimit.
Please review <xref target="binding"/> for details on how to properly
bind to a DSA.
</t></list>
</t>
<t>Example:
<figure><artwork>
      credentialLevel: proxy anonymous
</artwork></figure>
<!--</t></list>-->
</t>
</section>

<section title="Interpreting the serviceSearchDescriptor Attribute"
anchor="serviceSearchDescriptor">
<t>
<!--<list><t>-->
Interpretation:
<list><t>
The serviceSearchDescriptor attribute defines how and where a DUA
SHOULD search for information for a particular service.  The
serviceSearchDescriptor contains a serviceID, followed by one or more
base-scope-filter triples.  These base-scope-filter triples are used to
define searches only for the specific service.  Multiple
base-scope-filters allow the DUA to search for data in multiple
locations in the directory information tree (DIT). Although this syntax
is very similar to the
LDAP URL <xref target="RFC3986"/>, this document requires the ability to
supply multiple hosts as part of the configuration of the DSA.  In
addition, an ordered list of search descriptors is required, which cannot be specified by the LDAP URL.
</t><t>
The serviceSearchDescriptor might also contain the DN of an entry
that will contain an alternate profile.  The DSA SHOULD re-evaluate
the alternate profile and perform searches as specified by that profile.
</t><t>
If the base, as defined in the serviceSearchDescriptor, is
followed by the "," (ASCII 0x2C) character, this base is known
as a relative base.  This relative base may be constructed of one
or more RDN components.  In this case, the DUA MUST define the search
base by appending the relative base with the defaultSearchBase.
</t></list>
</t>
<t>Syntax:
<!--<list><t>-->
<list>
<list style="hanging" hangIndent="20">
<t hangText="serviceSearchList =">
serviceID ":" serviceSearchDesc *(";" serviceSearchDesc)
</t>
<t hangText="serviceSearchDesc =">
confReferral / searchDescriptor
</t>
<t hangText="searchDescriptor  =">
[base] ["?" [scopeSyntax] ["?" [filter]]]
</t>
<t hangText="confReferral      =">
"ref:" distinguishedName
</t>
<t hangText="base              =">
distinguishedName / relativeBaseName
</t>
<t hangText="relativeBaseName  =">
1*(relativeDistinguishedName ",")
</t>
<t hangText="filter            =">
UTF-8 encoded string
</t>
</list>
<t>
If the confReferral, base, relativeBaseName, or filter contains the
";" (ASCII 0x3B), "?" (ASCII 0x3F), """ (ASCII 0x22), or "\" (ASCII 0x5C)
characters, those characters MUST be escaped (preceded by the "\"
character). Alternately, the DN may be surrounded by quotes (ASCII 0x22).
Refer to RFC 4514. If the confReferral, base, relativeBaseName, or filter
are surrounded by quotes, only the """ character needs to be escaped.
Any character that does not need
to be escaped, and yet is preceded by the "\" character, results in
both the "\" character and the character itself.
</t><t>
The usage and syntax of the filter string MUST be defined by the DUA
service.  A suggested syntax would be that defined by <xref target="RFC4515"/>.
</t><t>
If a DUA is performing a search for a particular service that has a
serviceSearchDescriptor defined, the DUA MUST set the base, scope, and
filter as defined.  Each base-scope-filter triple represents a single
LDAP search operation.  If multiple base-scope-filter triples are
provided in the serviceSearchDescriptor, the DUA SHOULD perform multiple
search requests, and in that case, it MUST be in the order specified by
the serviceSearchDescriptor.
</t><t>
FYI: Service search descriptors do not exactly follow the LDAP URL
syntax <xref target="RFC4516"/>.  The reasoning for this difference
is to separate the host name(s) from the filter.  This allows the
DUA to have a more flexible solution in choosing its DSA.
<!--</t></list>-->
</t></list>
</t>
<t>Default Value:
<list><t>
If a serviceSearchDescriptor, or an element thereof, is not defined
for a particular service, the DUA SHOULD create the base, scope, and
filter as follows:
<list style="hanging" hangIndent="9">
<t hangText="base   -">
Same as the defaultSearchBase.
</t>
<t hangText="scope  -">
Same as the defaultSearchScope.
</t>
<t hangText="filter -">
Use defaults as defined by DUA's service.
</t>
</list>
If the defaultSearchBase or defaultSearchScope is not defined,
then the DUA service MAY use its own default.
</t></list>
</t>
<t>Other attribute notes:
<list><t>
If a serviceSearchDescriptor exists for a given service, the service
MUST use at least one base-scope-filter triple in performing searches.
It SHOULD perform multiple searches per service if multiple
base-scope-filter triples are defined for that service.
</t><t>
The details of how the "filter" is interpreted by each DUA's service is
defined by that service.  This means the filter is NOT REQUIRED to be a
legal LDAP filter <xref target="RFC4515"/>.  Furthermore, determining
how attribute and object class mapping affects that search filter MUST be
defined by the service. That is, the DUA SHOULD specify if the attributes in
the filter are assumed to already have been mapped, or if it is expected
that attribute mapping (see <xref target="attributeMap"/>) would be applied
to the filter.  In general practice, implementation and usability suggests
that attribute and object class mapping (Sections
<xref target="attributeMap" format="counter"/> and
<xref target="objectclassMap" format="counter"/>) SHOULD NOT be applied to the filter
defined in the serviceSearchDescriptor.
</t><t>
The serviceID is unique to a given service within the scope of any DUA
that might use the given profile, and should be defined by that service.
Registration of serviceIDs is not addressed by this document.  However, as
per the guidance at the end of <xref target="background"/>, when DUA
developers define their use of the DUAConfigProfile schema, they will
define the serviceIDs used by that DUA.
</t>
<t>
searchGuide and enhancedSearchGuide <xref target="RFC4517"/>:
</t>
<t>
There are a few reasons why the authors chose not to take advantage of the
existing searchGuide and enhancedSearchGuide attributes and related syntaxes.
While the enhancedSearchGuide met a number of the serviceSearchDescriptor
requirements, serviceSearchDescriptor was developed primarily to support
associating search operations with services.  Multiple services could
be configured using the same profile, thus requiring the serviceID to
be specified together with the search descriptor information.  A few other reasons for not
using enhancedSearchGuide include:

<list>
<t>
The need to specify alternate search bases, including the ability to specify
search bases that are relative to the parent defaultSearchBase.
</t><t>
The need to specify alternate profiles using the "ref:" syntax.
</t><t>
The ability for individual services to specify their own syntaxes for
the format of the search filter.
</t><t>
The authors' belief that the user community is more familiar with the
search filter syntax described by RFC 4515 than with that described
by the enhancedSearchGuide syntax.
</t>
</list>
</t></list>
</t>
<t>Example:
<figure><artwork>
      defaultSearchBase: dc=mycompany,dc=com
      
      serviceSearchDescriptor: email:ou=people,ou=org1,?
       one;ou=contractor,?one;
       ref:cn=profile,dc=mycompany,dc=com
</artwork></figure>
<list><t>
In this example, the DUA MUST search in "ou=people,ou=org1,dc=mycompany,dc=com"
first.  The DUA then SHOULD search in "ou=contractor,dc=mycompany,dc=com", and
finally it SHOULD search other locations as specified in the profile described
at "cn=profile,dc=mycompany,dc=com".  For more examples, see <xref target="Examples"/>.
</t></list>
</t>
</section>

<section title="Interpreting the attributeMap Attribute" anchor="attributeMap">
<t>
<!--<list><t>-->
Interpretation:
<list><t>
A DUA SHOULD perform attribute mapping for all LDAP operations performed
for a service that has an attributeMap entry. Because attribute mapping is
specific to each service within the DUA, a "serviceID" is required as part
of the attributeMap syntax.  That is, not all DUA services should necessarily
perform the same attribute mapping.
</t><t>
Attribute mapping in general is expected to be used to map attributes of
similar syntaxes as specified by the service supported by the DUA.
However, a DUA is NOT REQUIRED to verify syntaxes of mapped attributes.
If the DUA does discover that the syntax of the mapped attribute does not
match that of the original attribute, the DUA MAY perform translation
between the original syntax and the new syntax.  When DUAs do support
attribute value translation, the method and list of capable translations
SHOULD be documented in a description of the DUA service.
</t></list>
</t>
<t>Syntax:
<!--<list><t>-->
<list>
<list style="hanging" hangIndent="20">
<t hangText="attributeMap      ="> 
serviceID ":" origAttribute "=" attributes
</t>
<t hangText="origAttribute     =">
attribute
</t>
<t hangText="attributes        =">
wattribute *( SP wattribute )
</t>
<t hangText="wattribute        =">
WSP newAttribute WSP
</t>
<t hangText="newAttribute      =">
descr / "*NULL*"
</t>
<t hangText="attribute         =">
descr
</t>
</list>
<t>
Values of the origAttribute are defined by and SHOULD be documented for
the DUA service, as a list of known supported attributes.
</t></list>
</t>
<t>Default Value:
<list><t>
By default, attributes that are used by a DUA service are not mapped
unless mapped by the attributeMap attributes.  The DUA SHOULD NOT map
an attribute unless it is explicitly defined by an attributeMap
attribute.
</t></list>
</t>
<t>Other attribute notes:
<list><t>
When an attribute is mapped to the special keystring "*NULL*", the
DUA SHOULD NOT request that attribute from the DSA, when performing
a search or compare request.  If the DUA is also capable of performing
modification on the DSA, the DUA SHOULD NOT attempt to modify any
attribute which has been mapped to "*NULL*".
</t><t>
It is assumed the serviceID is unique to a given service within
the scope of the DSA.
</t><t>
A DUA SHOULD support attribute mapping.  If it does, the following
additional rules apply:

<list style="numbers">
<t>
The list of attributes that are allowed to be mapped SHOULD be defined by
and documented for the service.
</t>
<t>
Any supported translation of mapping from attributes
of dissimilar syntax SHOULD also be defined and documented.
</t>
<t>
If an attribute may be mapped to multiple attributes,
the DSA SHOULD define a syntax or usage statement for
how the new attribute value will be constructed.  Furthermore,
the resulting translated syntax of the combined attributes
MUST be the same as the attribute being mapped.
</t>
<t>
A DUA MUST support mapping of attributes using the attribute OID.
It SHOULD support attribute mapping based on the attribute name.
</t>
<t>
It is recommended that attribute mapping not be applied
to parents of the target entries.
</t>
<t>
Attribute mapping is not recursive.  In other words, if an attribute
has been mapped to a target attribute, that new target attribute MUST NOT
be mapped to a third attribute.
</t>
<t>
A given attribute MUST only be mapped once for a given service.
</t></list>
</t></list>
</t>
<t>Example:
<list>
<t>
Suppose a DUA is acting on behalf of an email service.  By default the
"email" service uses the "mail", "cn", and "sn" attributes to discover
mail addresses.  However, the email service has been deployed in an
environment that uses "employeeName" instead of "cn".  Also,
instead of using the "mail" attribute for email addresses, the "email"
attribute is used.  In this case,
the attribute "cn" can be mapped to "employeeName", allowing the DUA to
perform searches using the "employeeName" attribute as part of the
search filter, instead of "cn".  Also, "mail" can be mapped to "email"
when attempting to retrieve the email address.  This mapping is performed
by adding the attributeMap attributes to the configuration profile entry
as follows (represented in LDIF <xref target="RFC2849"/>):

<figure><artwork align="center">
attributeMap: email:cn=employeeName
attributeMap: email:mail=email
</artwork></figure>

As described above, the DUA MAY also map a single attribute to multiple attributes.
When mapping a single attribute to more than one attribute, the new
syntax or usage of the mapped attribute must be intrinsically defined by
the DUAs service.

<figure><artwork align="center">
attributeMap: email:cn=firstName lastName
</artwork></figure>

In the above example, the DUA creates the new value by generating a space-separated string using the values of the mapped attributes.  In this
case, a special mapping must be defined so that a proper search
filter can be created.  For further information on this example, please
refer to <xref target="Examples"/>.
</t><t>
Another possibility for multiple attribute mapping might come in when
constructing returned attributes.  For example, perhaps all email
addresses are of a guaranteed syntax of "uid@domain".  In this
example, the uid and domain are separate attributes in the directory.  The email
service may define that if the "mail" attribute is mapped to two
different attributes, it will construct the email address as a
concatenation of the two attributes (uid and domain), placing the "@"
character between them.

<figure><artwork align="center">
attributeMap: email:mail=uid domain
</artwork></figure>
</t></list>
<!--</t></list>-->
</t>

<t>
Note: The attributeMap attribute contains only a list of attribute
names that should be mapped, not the definition of how syntax
translation should be performed. The process used to perform
attribute value syntax translation (such as translating a uid to a DN)
and/or joining of multiple attribute values to form the target syntax
(such as in the above email example) is up to the service. The
attribute list defined in the attributeMap merely provides the
attributes that would be used as inputs to the translation function
provided by the service.
</t>

</section>

<section title="Interpreting the searchTimeLimit Attribute" anchor="searchTimeLimit">
<t>
<!--<list><t>-->
Interpretation:
<list><t>
The searchTimeLimit attribute defines the maximum time,
in seconds, that the DUA SHOULD allow for a search request to complete.
<!-- [authorbob] I chose the word "allow" because it implies that the DUA 
has control of, but is dependent on the DSA for, the performance of the
operation.  However, I am also happy with your suggestion.
Orignal text: "...that a DUA SHOULD allow to perform a search request."  
-->
<!-- [rfced] "the max time that a DUA SHOULD allow to perform a search" 
  sounds odd. Is there a way to re-phrase this?
  "the max time that a DUA SHOULD spend performing a search"?
-->
</t></list>
</t>
<t>Syntax:
<list><t>
Defined by OID 1.3.6.1.4.1.1466.115.121.1.27 <xref target="RFC4517"/>.
</t></list>
</t>
<t>Default Value:
<list><t>
If the searchTimeLimit attribute is not defined or is zero, the searchTimeLimit SHOULD NOT be enforced by the DUA.
</t></list>
</t>
<t>Other attribute notes:
<list><t>
This time limit only includes the amount of time
required to perform the LDAP search operation.  If other
operations are required, they do not need to
be considered part of the search time.  See
bindTimeLimit for the LDAP bind operation.
</t></list>
<!--</t></list>-->
</t>
</section>

<section title="Interpreting the bindTimeLimit Attribute" anchor="bindTimeLimit">
<t>
<!--<list><t>-->
Interpretation:
<list><t>
The bindTimeLimit attribute defines the maximum time,
in seconds, that a DUA SHOULD allow for the bind request to
complete when performed against each server on the
preferredServerList or defaultServerList.
<!-- [authorbob] See my previous comment.
Orignal text: "...that a DUA SHOULD allow to perform an LDAP bind
request against each server on the preferredServerList or
defaultServerList."
-->
<!-- [rfced] As above. "the max time that a DUA SHOULD allow to perform an
  LDAP bind request"  sounds odd. Is there a way to re-phrase this?
  "the max time that a DUA SHOULD spend performing an LDAP bind request"? -->
</t></list>
</t>
<t>Syntax:
<list><t>
Defined by OID 1.3.6.1.4.1.1466.115.121.1.27.
</t></list>
</t>
<t>Default Value:
<list><t>
If the bindTimeLimit attribute is not defined or is zero, the bindTimeLimit SHOULD NOT be enforced by the DUA.
</t></list>
</t>
<t>Other attribute notes:
<list><t>
This time limit only includes the amount of time
required to perform the LDAP bind operation.  If other
operations are required, those operations do not need to
be considered part of the bind time.  See
searchTimeLimit for the LDAP search operation.
</t></list>
<!--</t></list>-->
</t>
</section>

<section title="Interpreting the followReferrals Attribute" anchor="followReferrals">
<t>
<!--<list><t>-->
Interpretation:
<list><t>
If set to TRUE, the DUA SHOULD follow any referrals if discovered.
</t>
<t>
If set to FALSE, the DUA MUST NOT follow referrals.
</t></list>
</t>
<t>Syntax:
<list><t>
Defined by OID 1.3.6.1.4.1.1466.115.121.1.7 <xref target="RFC4517"/>.
</t></list>
</t>
<t>Default Value:
<list><t>
If the followReferrals attribute is not set or set to an
invalid value, the default value is TRUE.
</t></list>
<!--</t></list>-->
</t>
</section>

<section title="Interpreting the dereferenceAliases Attribute" anchor="dereferenceAliases">
<t>
<!--<list><t>-->
Interpretation:
<list><t>
If set to TRUE, the DUA SHOULD enable alias dereferencing.
</t>
<t>
If set to FALSE, the DUA MUST NOT enable alias dereferencing.
</t></list>
</t>
<t>Syntax:
<list><t>
Defined by OID 1.3.6.1.4.1.1466.115.121.1.7.
</t></list>
</t>
<t>Default Value:
<list><t>
If the dereferenceAliases attribute is not set or set to an
invalid value, the default value is TRUE.
</t></list>
<!--</t></list>-->
</t>
</section>

<section title="Interpreting the profileTTL Attribute" anchor="profileTTL">
<t>
<!--<list><t>-->
Interpretation:
<list><t>
The profileTTL attribute defines how often the DUA SHOULD
reload and reconfigure itself using the corresponding
configuration profile entry.  The value is represented in
seconds.  Once a DUA reloads the profile entry, it SHOULD
reconfigure itself with the new values.
</t></list>
</t>
<t>Syntax:
<list><t>
Defined by OID 1.3.6.1.4.1.1466.115.121.1.27.
</t></list>
</t>
<t>Default Value:
<list><t>
If not specified, the DUA MAY use its own reconfiguration
policy.
</t></list>
</t>
<t>Other attribute notes:
<list><t>
If the profileTTL value is zero, the DUA SHOULD NOT automatically
reload the configuration profile.
</t></list>
<!--</t></list>-->
</t>
</section>

<section title="Interpreting the objectclassMap Attribute" anchor="objectclassMap">
<t>
<!--<list><t>-->
Interpretation:
<list><t>
A DUA MAY perform object class mapping for all LDAP operations
performed for a service that has an objectclassMap entry.  Because
object class mapping is specific for each service within the DUA, a
"serviceID" is required as part of the objectclassMap syntax. That is, not all DUA services should necessarily perform the same
object class mapping.
</t><t>
Object class mapping SHOULD be used in conjunction with attribute mapping
to map the schema required by the service to an equivalent schema that is
available in the directory.
</t><t>
Object class mapping may or may not be required by a DUA.  Often, the objectclass
attribute is used in search filters.  <xref target="attributeMap"/> recommends
that attribute mapping not be applied to the serviceSearchDescriptor.  Thus, if
the default object classes are not used in a DUA deployment, typically only
the serviceSearchDescriptor needs to be defined to reflect that mapping.
However, when the service search descriptor is not provided, and the default
search filter for that service contains the objectclass attribute, that search
filter SHOULD be redefined by object class mapping, if defined.  If a default
search filter is not used, it SHOULD be redefined through the
serviceSearchDescriptor.  If a serviceSearchDescriptor is defined for a
particular service, it SHOULD NOT be remapped by either the objectclassMap
or attributeMap values.
</t><t>
One condition where the objectclassMap SHOULD be used is when the DUA
is providing gateway functionality.  In this case, the DUA is acting
on behalf of another service, which may pass in a search filter itself.
In this type of DUA, the DUA may alter the search filter according to
the appropriate attributeMap and objectclassMap values.  In this
case, it is also assumed that a serviceSearchDescriptor is not defined.
</t></list>
</t>
<t>Syntax:
<list>
<list style="hanging" hangIndent="20">
<t hangText="objectclassMap    =">
serviceID ":" origObjectclass "=" objectclass
</t>
<t hangText="origObjectclass   =">
objectclass
</t>
<t hangText="objectclass       =">
keystring
</t>
</list>
<t>
Values of the origObjectclass depend on the type of DUA Service using
the object class mapping feature.
</t></list>
</t>
<t>Default Value:
<list><t>
The DUA MUST NOT remap an object class unless it is explicitly defined by
an objectclassMap attribute.
</t></list>
</t>
<t>Other attribute notes:
<list><t>
A DUA SHOULD support object class mapping.  If it does, the DUA MUST
support mapping of object classes using the objectclass OID.
It SHOULD support object class mapping based on the object class name.
</t><t>
It is assumed the serviceID is unique to a given service within
the scope of the DSA.
</t></list>
</t>
<t>Example:
<list>
<t>
Suppose a DUA is acting on behalf of an email service.  By default the
"email" service uses the "mail", "cn", and "sn" attributes to discover
mail addresses in entries created using inetOrgPerson object class <xref target="RFC2789"/>.
However, the email service has been deployed in an
environment that uses entries created using "employee" object class.  In
this case, the attribute "cn" can be mapped to "employeeName", and
"inetOrgPerson" can be mapped to "employee", allowing the DUA to perform
LDAP operations using the entries that exist in the directory.  This
mapping is performed by adding attributeMap and objectclassMap
attributes to the configuration profile entry as follows (represented
in LDIF <xref target="RFC2849"/>):

<figure><artwork align="center">
attributeMap: email:cn=employeeName
objectclassMap: email:inetOrgPerson=employee
</artwork></figure>
</t></list>
<!--</t></list>-->
</t>
</section>

<section title="Interpreting the defaultSearchScope Attribute" anchor="defaultSearchScope">
<t>
<!--<list><t>-->
Interpretation:
<list><t>
When a DUA needs to search the DSA for information, this attribute
provides the "scope" for the search.  This parameter can be overridden
by the serviceSearchDescriptor attribute.  See <xref target="serviceSearchDescriptor"/>.
</t></list>
</t>
<t>Syntax:
<list><t>
scopeSyntax   = "base" / "one" / "sub"
</t></list>
</t>
<t>Default Value:
<list><t>
The default value for the defaultSearchScope SHOULD be defined by the
DUA service.  If the default search scope for a service is not defined,
then the scope SHOULD be for the DUA to perform a subtree search.
</t></list>
<!--</t></list>-->
</t>
</section>

<section title="Interpreting the serviceAuthenticationMethod Attribute" anchor="serviceAuthenticationMethod">
<t>
<!--<list><t>-->
Interpretation:
<list><t>
The serviceAuthenticationMethod attribute defines an ordered list of LDAP bind
methods to be used when attempting to contact a DSA for a particular service.
Interpretation and use of this attribute is the same as <xref target="authenticationMethod"/>, but specific
for each service.
</t></list>
</t>
<t>Syntax:
<list><t>
svAuthMethod    = serviceID ":" method *(";" method)
</t><t>
Note: Although multiple authentication methods may be specified in the syntax,
at most one of each type is allowed.
</t></list>
</t>
<t>Default Value:
<list><t>
If the serviceAuthenticationMethod attribute is not provided, the
authenticationMethod SHOULD be followed, or its default.
</t></list>
</t>
<t>Other attribute notes:
<list><t>
Determining how the DUA should bind to the DSAs also depends
on the additional configuration attributes, credentialLevel,
serviceCredentialLevel, and
bindTimeLimit.  Please review <xref target="binding"/> for details on how to
properly bind to a DSA.
</t></list>
</t>
<t>Example:
<figure><artwork>
      serviceAuthenticationMethod: email:tls:simple;sasl/DIGEST-MD5
</artwork></figure>
<!--</t></list>-->
</t>
</section>

<section title="Interpreting the serviceCredentialLevel Attribute" anchor="serviceCredentialLevel">
<t>
<!--<list><t>-->
Interpretation:
<list><t>
The serviceCredentialLevel attribute defines what type(s) of credential(s)
the DUA SHOULD use when contacting the DSA for a particular service.
Interpretation and use of this attribute are the same as <xref target="credentialLevel"/>.
</t></list>
</t>
<t>Syntax:
<list><t>
svCredentialLevel = serviceID ":" level *(SP level)
</t><t>
Refer to implementation notes in <xref target="binding"/> for additional syntax
requirements for the credentialLevel attribute.
</t><t>
Note: Although multiple credential levels may be specified in the syntax,
at most one of each type is allowed.
</t></list>
</t>
<t>Default Value:
<list><t>
If the serviceCredentialLevel attribute is not defined, the DUA MUST
examine the credentialLevel attribute, or if one is not
provided, the DUA must follow its default.
</t></list>
</t>
<t>Other attribute notes:
<list><t>
Determining how the DUA should bind to the DSAs also depends
on the additional configuration attributes, serviceAuthenticationMethod,
authenticationMethod, and
bindTimeLimit.  Please review <xref target="binding"/> for details on how to
properly bind to a DSA.
</t></list>
</t>
<t>Example:
<figure><artwork>
      serviceCredentialLevel: email:proxy anonymous
</artwork></figure>
<!--</t></list>-->
</t>
</section>
</section>

<section title="Binding to the Directory Server" anchor="binding">
<figure>
<preamble>The DUA SHOULD use the following algorithm when binding to the server:</preamble>
<artwork>
for (clevel in credLevel) [see Note 1]
  if (clevel is "anonymous")
    for (host in hostnames) [see Note 2]
      if (server is responding)
        return success
    return failure
  else
    for (amethod in authMethod) [see Note 3]
      if (amethod is none)
        for (host in hostnames)
          if (server is responding)
            return success
        return failure
      else
        for (host in hostnames)
          authenticate using amethod and clevel
          if (authentication passed)
            return success
return failure
</artwork>
</figure>
<t>
<list style="format Note %d: ">
<t>
The credLevel is a list of credential levels as defined
in serviceCredentialLevel (<xref target="serviceCredentialLevel"/>) for a given
service.  If the serviceCredentialLevel is not defined,
the DUA MUST examine the credentialLevel attribute.
</t><t>
hostnames is the list of servers to contact as defined
in Sections <xref target="preferredServerList" format="counter"/> and
<xref target="defaultServerList"  format="counter"/>.
</t><t>
The authMethod is a list of authentication methods as defined
in serviceAuthenticationMethod (<xref target="serviceAuthenticationMethod"/>) for a
given service.  If the serviceAuthenticationMethod is not
defined, the DUA MUST examine the authenticationMethod
attribute.
</t></list>
</t>
</section>

<section title="Security Considerations">
<t>
The profile entries MUST be protected against unauthorized modification.
Each service
needs to consider implications of providing its service configuration
as part of this profile and limit access to the profile entries
accordingly.
</t><t>
The management of the authentication
credentials for the DUA is outside the scope of this document and needs
to be handled by the DUA.
</t><t>
Since the DUA needs to know how to properly bind to the directory server,
the access control configuration of the DSA MUST assure that the DSA can
view all the elements of the DUAConfigProfile attributes.  For example, if
the credentialLevel attribute contains "Self", but the DSA is unable to
access the credentialLevel attribute, the DUA will instead attempt an
anonymous connection to the directory server.
</t><t>
The algorithm described by <xref target="binding"/> also has security considerations.
Altering that design will alter the security aspects of the configuration
profile.
</t><t>
At times, DUAs connect to multiple directory servers in order to
support potential high-availability and/or performance requirements.  As such, each directory server specified in the preferredServer list and
defaultServerList MUST contain the same (replicated) data and be part of the same
security domain.  This means the directory-supported authentication methods,
authentication policies, and access control policies for directory data are exactly
the same across all the defined directory servers.
</t>
</section>


<section title="Acknowledgments">
<t>
There were several additional authors of this document.  However, we
chose to represent only one author per company in the heading.  From
Sun, we would like to acknowledge Roberto Tam for his design work
on Sun's first LDAP name service product and his input for this document.  From
Hewlett-Packard, we'd like to acknowledge Dave Binder for his work
architecting Hewlett-Packard's LDAP name service product as well as his
design guidance on this document.  We'd also like to acknowledge Grace Lu
from HP, for her input and implementation of HP's configuration profile
manager code.
</t>
</section>

<section title="IANA Considerations">
<t>
This document defines new LDAP attributes and an object class for object
identifier descriptors.  As specified by Section 3.4 and required by
Section 4 of <xref target="RFC4520"/>, this document registers new
descriptors as follows per the Expert Review.
</t>
<section title="Registration of Object Classes">
<figure><artwork>
Subject:  Request for LDAP Descriptor Registration

Descriptor (short name): DUAConfigProfile

Object Identifier:  1.3.6.1.4.1.11.1.3.1.2.5

Person &amp; email address to contact for further information:
   See "Author/Change Controller"

Usage: object class

Specification: RFC 4876
</artwork></figure>
<figure><artwork>
Author/Change Controller:

   Bob Neal-Joslin
   Hewlett-Packard Company
   19420 Homestead RD
   Cupertino, CA 95014
   USA
   Phone: +1 408-447-3044
   EMail: bob_joslin@hp.com
</artwork></figure>
<figure><artwork>
Comments:

   See also the associated request for the defaultServerList, 
   defaultSearchBase, preferredServerList, searchTimeLimit,
   bindTimeLimit, followReferrals, authenticationMethod,
   profileTTL, attributeMap, credentialLevel, objectclassMap,
   defaultSearchScope, serviceCredentialLevel,
   serviceSearchDescriptor, serviceAuthenticationMethod, and
   dereferenceAliases attribute types.
</artwork></figure>
</section>

<section title="Registration of Attribute Types">

<figure><artwork>
Subject:  Request for LDAP Descriptor Registration

Descriptor (short name):  See comments

Object Identifier:  See comments

Person &amp; email address to contact for further information:
   See "Author/Change Controller"

Usage:  attribute type

Specification: RFC 4876
</artwork></figure>
<figure><artwork>
Author/Change Controller:

   Bob Neal-Joslin
   Hewlett-Packard Company
   19420 Homestead RD
   Cupertino, CA 95014
   USA
   Phone: +1 408-447-3044
   EMail: bob_joslin@hp.com
</artwork></figure>
<figure><artwork>
Comments:

   The following object identifiers and associated attribute
   types have been registered.
   
     OID                           Attribute Type
     --------------------------    ---------------------------
     1.3.6.1.4.1.11.1.3.1.1.0      defaultServerList
     1.3.6.1.4.1.11.1.3.1.1.1      defaultSearchBase
     1.3.6.1.4.1.11.1.3.1.1.2      preferredServerList
     1.3.6.1.4.1.11.1.3.1.1.3      searchTimeLimit
     1.3.6.1.4.1.11.1.3.1.1.4      bindTimeLimit
     1.3.6.1.4.1.11.1.3.1.1.5      followReferrals
     1.3.6.1.4.1.11.1.3.1.1.6      authenticationMethod
     1.3.6.1.4.1.11.1.3.1.1.7      profileTTL
     1.3.6.1.4.1.11.1.3.1.1.9      attributeMap
     1.3.6.1.4.1.11.1.3.1.1.10     credentialLevel
     1.3.6.1.4.1.11.1.3.1.1.11     objectclassMap
     1.3.6.1.4.1.11.1.3.1.1.12     defaultSearchScope
     1.3.6.1.4.1.11.1.3.1.1.13     serviceCredentialLevel
     1.3.6.1.4.1.11.1.3.1.1.14     serviceSearchDescriptor
     1.3.6.1.4.1.11.1.3.1.1.15     serviceAuthenticationMethod
     1.3.6.1.4.1.11.1.3.1.1.16     dereferenceAliases
     
   Please also see the associated registration request for the
   DUAConfigProfile object class.

</artwork></figure>
</section>
</section>

</middle>
    

    <back>

<?rfc needLines="10"?>
        <references title="Normative References">

        &rfc4510;
        &rfc2119;
        &rfc4517;
        &rfc4234;
        &rfc4512;
        &rfc4514;
        &rfc4516;
        &rfc3986;
        &rfc4519;
        &rfc4511;
        <reference anchor="SASLMECH" target="http://www.iana.org/assignments/sasl-mechanisms">
          <front>
           <title>SIMPLE AUTHENTICATION AND SECURITY LAYER (SASL) MECHANISMS</title>
           <author><organization abbrev="IANA">IANA</organization></author>
           <date month="July" year="2006"/>
          </front>
        </reference>
        </references>

        <references title="Informative References">

        &rfc4520;
        &rfc2307;

<!-- [rfced] The URL for MSSFU is not found. Please update. 
Possibly
http://www.microsoft.com/technet/interopmigration/unix/sfu/default.mspx or
http://www.microsoft.com/technet/interopmigration/unix/sfu/sfu35wp.mspx
 -->
<!-- [author-bob] The orignal URL minus the basename works.  It is shorter and readable. -->
        <reference anchor="MSSFU" target="http://www.microsoft.com/windows/sfu/">
          <front>
           <title>Windows Services for Unix 3.5</title>
           <author surname="Microsoft Corporation"><organization/></author>
          </front>
        </reference>
        &rfc4422;
        &rfc2831;
        &rfc4515;
        &rfc2849;
        &rfc2789;

        </references>

<?rfc needLines="50"?>
<section title="Examples" anchor="Examples">
<t>
In this section, we will describe a fictional DUA that provides one service, called
the "email" service.  This service would be similar to an email client that uses
an LDAP directory to discover email addresses based on a textual representation
of the recipient's colloquial name.
</t><t>
This email service is defined by default to expect that users with email addresses
will be of the "inetOrgPerson" object class type <xref target="RFC2789"/>.  And by default, the "email"
service expects the colloquial name to be stored in the "cn" attribute, while it expects
the email address to be stored in the "mail" attribute (as one would expect as
defined by the inetOrgPerson object class).
</t><t>
As a special feature, the "email" service will perform a special type of attribute
mapping when performing searches.  If the "cn" attribute has been mapped to two
or more attributes, the "email" service will parse the requested search
string and map each whitespace-separated token into the mapped attributes, respectively.
</t><t>
The default search filter for the "email" service is "(objectclass=inetOrgPerson)".
The email service also defines that when it performs a name-to-address discovery, it
will wrap the search filter inside a complex search filter as follows:
</t><t>
(&amp;(&lt;filter&gt;)(cn~=&lt;name string&gt;))
</t><t>
Or, if "cn" has been mapped to multiple attributes, that wrapping would appear
as follows:
</t><t>
(&amp;(&lt;filter&gt;)(attr1~=&lt;token1&gt;)(attr2~=&lt;token2&gt;)...)
</t><t>
The below examples show how the "email" service builds its search
requests, based on the defined profile.  In all cases, the defaultSearchBase
is "o=airius.com", and the defaultSearchScope is undefined.
</t><t>
In addition, for all examples, we assume that the "email" service has
been requested to discover the email address for "Jane Hernandez".</t>

<figure><artwork>
Example 1:

serviceSearchDescriptor: email:"ou=marketing,"

base: ou=marketing,o=airius.com
scope: sub
filter: (&amp;(objectclass=inetOrgPerson)(cn~=Jane Hernandez))
</artwork></figure>


<figure><artwork>
Example 2:

serviceSearchDescriptor: email:"ou=marketing,"?one?
 (&amp;(objectclass=inetOrgPerson)(c=us))
attributeMap: email:cn=2.5.4.42 sn

Note: 2.5.4.42 is the OID that represents the "givenName"
attribute.
</artwork></figure>
<t>
In this example, the email service performs &lt;name string&gt; parsing
as described above to generate a complex search filter.  The above example
results in one search.</t>

<figure><artwork>
base: ou=marketing,o=airius.com
scope: one
filter: (&amp;(&amp;(objectclass=inetOrgPerson)(c=us))
            (2.5.4.42~=Jane)(sn~=Hernandez))
</artwork></figure>


<figure><artwork>
Example 3:

serviceSearchDescriptor: email:ou=marketing,"?base
attributeMap: email:cn=name

This example is invalid, because either the quote should have
been escaped, or there should have been a leading quote.
</artwork></figure>


<figure><artwork>
Example 4:

serviceSearchDescriptor: email:ou=\\mar\\\\keting,\\"?base
attributeMap: email:cn=name

base: ou=\\mar\\keting,"
scope: base
filter (&amp;(objectclass=inetOrgPerson)(name~=Jane Hernandez))
</artwork></figure>


<figure><artwork>
Example 5:

serviceSearchDescriptor: email:ou="marketing",o=supercom

This example is invalid, since the quote was not a leading quote,
and thus should have been escaped.
</artwork></figure>


<figure><artwork>
Example 6:

serviceSearchDescriptor: email:??(&amp;(objectclass=person)
                                 (ou=Org1 \\\\(temporary\\\\)))

base: o=airius.com
scope: sub
filter: (&amp;((&amp;(objectclass=person)(ou=Org1 \\(Temporary\\)))
          (cn~=Jane Henderson)))
</artwork></figure>


<figure><artwork>
Example 7:

serviceSearchDescriptor: email:"ou=funny?org,"

base: ou=funny?org,o=airius.com
scope: sub
filter (&amp;(objectclass=inetOrgPerson)(cn~=Jane Hernandez))
</artwork></figure>

</section>
</back>
</rfc>
