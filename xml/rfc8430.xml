<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC4271 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4271.xml">
<!ENTITY RFC4915 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4915.xml">
<!ENTITY RFC5065 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5065.xml">
<!ENTITY RFC5120 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5120.xml">
<!ENTITY RFC5246 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC5511 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5511.xml">
<!ENTITY RFC6020 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6020.xml">
<!ENTITY RFC6241 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6241.xml">
<!ENTITY RFC6242 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6242.xml">
<!ENTITY RFC8341 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8341.xml">
<!ENTITY RFC7920 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7920.xml">
<!ENTITY RFC8040 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8040.xml">
<!ENTITY RFC8174 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml">
<!ENTITY I2RS-RIB-DATA-MODEL SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-i2rs-rib-data-model.xml">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>

<rfc number="8430"
     category="info" 
     submissionType="IETF"
     consensus="yes"
     ipr="trust200902">
  <front>
    <title>RIB Information Model</title>

    <author fullname="Nitin Bahadur" initials="N.B." role="editor"
            surname="Bahadur">
      <organization>Uber</organization>

      <address>
        <postal>
          <street>900 Arastradero Rd</street>

          <city>Palo Alto</city>

          <region>CA</region>

          <code>94304</code>

          <country>United States of America</country>
        </postal>

        <email>nitin_bahadur@yahoo.com</email>
      </address>
    </author>

    <author fullname="Sriganesh Kini" initials="S.K." role="editor"
            surname="Kini">
      <address>
        <email>sriganeshkini@gmail.com</email>
      </address>
    </author>

    <author fullname="Jan Medved" initials="J.M." surname="Medved">
      <organization>Cisco</organization>

      <address>
        <email>jmedved@cisco.com</email>
      </address>
    </author>

    <date month="September" year="2018"/>

    <area>Routing</area>

    <workgroup>Network Working Group</workgroup>



    <keyword>RIB</keyword>

    <keyword>info model</keyword>

    <abstract>
      <t>Routing and routing functions in enterprise and carrier networks are
      typically performed by network devices (routers and switches) using a
      Routing Information Base (RIB).
      Protocols and configurations push data
      into the RIB, and the RIB manager installs state into the hardware for
      packet forwarding. This document specifies an information model for the RIB to enable defining a
standardized data model. The IETF's I2RS WG used this document to design the I2RS RIB data model.
      This document is being
      published to record the higher-level information model decisions for
      RIBs so that other developers of RIBs may benefit from the design
      concepts.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction" toc="default">
      <t>Routing and routing functions in enterprise and carrier networks are
      traditionally performed in network devices. Customarily, routers run
      routing protocols, and the routing protocols (along with static
      configuration information) populate the Routing Information Base (RIB)
      of the router. The RIB is managed by the RIB manager, and the RIB manager
      provides a northbound interface to its clients (i.e., the routing
      protocols) to insert routes into the RIB. The RIB manager consults the
      RIB and decides how to program the Forwarding Information Base (FIB) of
      the hardware by interfacing with the FIB manager. The relationship
      between these entities is shown in <xref
      target="rib-fib-interaction"/>.</t>

      <figure align="center" anchor="rib-fib-interaction"
              title="RIB Manager, RIB Clients, and FIB Managers">
        <artwork align="left"><![CDATA[
      +-------------+        +-------------+
      |RIB Client 1 | ...... |RIB Client N |
      +-------------+        +-------------+
             ^                      ^
             |                      |
             +----------------------+
                        |
                        V
             +---------------------+
             |    RIB Manager      |
             |                     |
             |     +--------+      |
             |     | RIB(s) |      |
             |     +--------+      |
             +---------------------+
                        ^
                        |
       +---------------------------------+
       |                                 |
       V                                 V
+----------------+               +----------------+
| FIB Manager 1  |               | FIB Manager M  |
|   +--------+   |  ..........   |   +--------+   |
|   | FIB(s) |   |               |   | FIB(s) |   |
|   +--------+   |               |   +--------+   |
+----------------+               +----------------+
           ]]></artwork>
      </figure>

      <t>Routing protocols are inherently distributed in nature, and each
      router makes an independent decision based on the routing data received
      from its peers. With the advent of newer deployment paradigms and the
      need for specialized applications, there is an emerging need to guide
      the router's routing function <xref target="RFC7920"/>.
      The traditional network-device RIB population that is protocol based
      suffices for most use cases where distributed network control is used.
      However, there are use cases
      that the network operators currently address by configuring static
      routes, policies, and RIB import/export rules on the routers. There is
      also a growing list of use cases in which a network operator might want
      to program the RIB based on data unrelated to just routing (within that
      network's domain). Programming the RIB could be based on other
      information (such as routing data in the adjacent domain or the load on
      storage and compute) in the given domain. Or, it could simply be a
      programmatic way of creating on-demand dynamic overlays (e.g., GRE
      tunnels) between compute hosts (without requiring the hosts to run
      traditional routing protocols). If there was a standardized,
      publicly documented programmatic interface to a RIB, it would enable
      further networking applications that address a variety of use cases
      <xref target="RFC7920"/>.</t>

      <t>A programmatic interface to the RIB involves two types of operations:
      reading from the RIB and writing (adding/modifying/deleting) to the
      RIB.</t>

      <t>In order to understand what is in a router's RIB, methods like
      per-protocol SNMP MIBs and screen scraping are used. These methods are
      not scalable since they are client pull mechanisms and not proactive
      push (from the router) mechanisms. Screen scraping is error prone (since
      the output format can change) and is vendor dependent. Building a RIB
      from per-protocol MIBs is error prone since the MIB data represents
      protocol data and not the exact information that went into the RIB.
      Thus, just getting read-only RIB information from a router is a hard
      task.</t>

      <t>Adding content to the RIB from a RIB client can be done today using
      static configuration mechanisms provided by router vendors. However, the
      mix of what can be modified in the RIB varies from vendor to vendor, and
      the method of configuring it is also vendor dependent. This makes it
      hard for a RIB client to program a multi-vendor network in a consistent
      and vendor-independent way.</t>

      <t>The purpose of this document is to specify an information model for the
      RIB. Using the information model, one can build a detailed data model
      for the RIB. That data model could then be used by a RIB client to
      program a network device. One data model that has been based on this
      document is the I2RS RIB data model <xref
      target="RFC8431"></xref>.</t>

      <t>The rest of this document is organized as follows. <xref
      target="rib-data"> </xref> goes into the details of what constitutes and
      can be programmed in a RIB. Guidelines for reading and writing the RIB
      are provided in Sections <xref target="rib-read" format="counter"/> and
      <xref target="rib-write" format="counter"/>,
      respectively. <xref target="events"/> provides a high-level view of the
      events and notifications going from a network device to a RIB client to
      update the RIB client on asynchronous events. The RIB grammar is
      specified in <xref target="rib-grammar"/>. Examples of using the RIB
      grammar are shown in <xref target="rib-examples"/>. <xref
      target="rib-scale"/> covers considerations for performing RIB operations
      at scale.</t>

      <section title="Conventions Used in This Document">
        <t>
    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
    "MAY", and "OPTIONAL" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
      </section>
    </section>

    <section anchor="rib-data" title="RIB Data" toc="default">
      <t>This section describes the details of a RIB. It makes forward
      references to objects in the RIB grammar (see <xref target="rib-grammar"/>).
      A high-level description of the RIB contents is as shown in <xref
      target="rib-model"/>. Please note that for ease of representation in ASCII art, this drawing shows a single routing instance, a single
      RIB, and a single route. Subsections of this section describe the
      logical data nodes that should be contained within a RIB. Sections <xref
      target="rib-read" format="counter"/> and <xref target="rib-write" format="counter"/> describe the
      high-level read and write operations.</t>

      <figure align="center" anchor="rib-model" title="RIB Information Model">
        <artwork name="RIB model"><![CDATA[
                       network-device
                             |
                             | 0..N
                             |
                      routing instance(s)
                       |             |
                       |             | 
                 0..N  |             | 0..N
                       |             |
                  interface(s)     RIB(s)
                                     |
                                     |
                                     | 0..N
                                     |
                                   route(s)
 ]]></artwork>
      </figure>

      <section title="RIB Definition">
        <t>A RIB, in the context of the RIB information model, is an entity
        that contains routes. It is identified by its name and is contained
        within a routing instance (see <xref target="routing-instance"/>). A
        network device MAY contain routing instances, and each routing instance
        MAY contain RIBs. The name MUST be unique within a routing instance.
        All routes in a given RIB MUST be of the same address family (e.g.,
        IPv4). Each RIB MUST belong to a routing instance.</t>

        <t>A routing instance may contain two or more RIBs of the same address
        family (e.g., IPv6). A typical case where this can be used is for
        multi-topology routing <xref target="RFC4915"/> <xref
        target="RFC5120"/>.</t>

        <t>Each RIB MAY be associated with an ENABLE_IP_RPF_CHECK attribute
        that enables Reverse Path Forwarding (RPF) checks on all IP routes in
        that RIB. The RPF check is used to prevent spoofing and limit
        malicious traffic. For IP packets, the IP source address is looked up
        and the RPF interface(s) associated with the route for that IP source
        address is found. If the incoming IP packet's interface matches one of
        the RPF interfaces, then the IP packet is forwarded based on its IP
        destination address; otherwise, the IP packet is discarded.</t>
      </section>

      <section anchor="routing-instance" title="Routing Instance">
        <t>A routing instance, in the context of the RIB information model, is
        a collection of RIBs, interfaces, and routing parameters. A routing
        instance creates a logical slice of the router. It allows different
        logical slices across a set of routers to communicate with each other.
        Layer 3 VPNs, Layer 2 VPNs (L2VPNs), and
        Virtual Private LAN Service (VPLS) can be modeled as routing
        instances. Note that modeling an L2VPN using a routing instance
        only models the Layer 3 (RIB) aspect and does not model any Layer 2
        information (like ARP) that might be associated with the L2VPN.</t>

        <t>The set of interfaces indicates which interfaces are associated
        with this routing instance. The RIBs specify how incoming traffic is
        to be forwarded, and the routing parameters control the information in
        the RIBs. The intersection set of interfaces of two routing instances
        MUST be the null set. In other words, an interface MUST NOT be present
        in two routing instances. Thus, a routing instance describes the routing
        information and parameters across a set of interfaces.</t>

        <t>A routing instance MUST contain the following mandatory
        fields:<list style="symbols">
            <t>INSTANCE_NAME: A routing instance is identified by its name,
            INSTANCE_NAME. This MUST be unique across all routing instances in
            a given network device.</t>

            <t>rib-list: This is the list of RIBs associated with this routing
            instance. Each routing instance can have multiple RIBs to
            represent routes of different types. For example, one would put
            IPv4 routes in one RIB and MPLS routes in another RIB. The list of
            RIBs can be an empty list.</t>
          </list></t>

        <t>A routing instance MAY contain the following fields:<list
            style="symbols">
            <t>interface-list: This represents the list of interfaces
            associated with this routing instance. The interface list helps
            constrain the boundaries of packet forwarding. Packets coming in
            on these interfaces are directly associated with the given routing
            instance. The interface list contains a list of identifiers, with
            each identifier uniquely identifying an interface.</t>

            <t>ROUTER_ID: This field identifies the network device in control
            plane interactions with other network devices. This field is to be
            used if one wants to virtualize a physical router into multiple
            virtual routers. Each virtual router MUST have a unique ROUTER_ID.
            A ROUTER_ID MUST be unique across all network devices in a given
            domain.</t>
          </list>A routing instance may be created purely for the purposes of
        packet processing and may not have any interfaces associated with it.
        For example, an incoming packet in routing instance A might have a
        nexthop of routing instance B, and after packet processing in B, the
        nexthop might be routing instance C. Thus, routing instance B is not
        associated with any interface. And, given that this routing instance
        does not do any control-plane interaction with other network devices,
        a ROUTER_ID is also not needed.</t>
      </section>

      <section title="Route">
        <t>A route is essentially a match condition and an action following
        the match. The match condition specifies the kind of route (IPv4,
        MPLS, etc.) and the set of fields to match on. <xref
        target="route-model"/> represents the overall contents of a route.
        Please note that for ease of depiction in ASCII art, only a single
        instance of the route-attribute, match flags, and nexthop is
        depicted.</t>
	
        <figure align="center" anchor="route-model" title="Route Model">
          <artwork name="Route model"><![CDATA[
                              route
                              | | |
                    +---------+ | +----------+
                    |           |            |
               0..N |           |            |
                                            
      route-attribute         match         nexthop
                                |
                                |
                +-------+-------+-------+--------+
                |       |       |       |        |
                |       |       |       |        |
 
               IPv4    IPv6    MPLS    MAC    Interface
    ]]></artwork>
        </figure>

        <t>This document specifies the following match types:<list
            style="symbols">
            <t>IPv4: Match on destination and/or source IP address in the IPv4
            header</t>

            <t>IPv6: Match on destination and/or source IP address in the IPv6
            header</t>

            <t>MPLS: Match on an MPLS label at the top of the MPLS label
            stack</t>

            <t>MAC: Match on Media Access Control (MAC) destination addresses in the Ethernet
            header</t>

            <t>Interface: Match on the incoming interface of the packet</t>
          </list></t>

        <t>A route MAY be matched on one or more of these match types by policy
        as either an &ldquo;AND&rdquo; (to restrict the number of routes) or
        an &ldquo;OR&rdquo; (to combine two filters).</t>

        <t>Each route MUST have the following mandatory
        route-attributes associated with it:<list style="symbols">
            <t>ROUTE_PREFERENCE: This is a numerical value that allows for
            comparing routes from different protocols. Static configuration is
            also considered a protocol for the purpose of this field. It is
            also known as "administrative distance". The lower the value, the
            higher the preference. For example, there can be an OSPF route for
            192.0.2.1/32 (or IPv6 2001:DB8::1/128) with a preference of 5. If
            a controller programs a route for 192.0.2.1/32 (or IPv6
            2001:DB8::1/128) with a preference of 2, then the controller's
            route will be preferred by the RIB manager. Preference should be
            used to dictate behavior. For more examples of preference, see
            <xref target="route-preference"/>.</t>
          </list></t>

        <t>Each route can have one or more optional route-attributes associated with it.<list style="symbols">
            <t>route-vendor-attributes: Vendors can specify vendor-specific
            attributes using this. The details of this attribute are outside
            the scope of this document.</t>
          </list></t>

        <t>Each route has a nexthop associated with it. Nexthops are described
        in <xref target="nexthop"/>.</t>

        <t>Additional features to match multicast packets were considered
        (e.g., TTL of the packet to limit the range of a multicast group), but
        these were not added to this information model. Future RIB information
        models should investigate these multicast features.</t>
      </section>

      <section anchor="nexthop" title="Nexthop">

        <t>A nexthop represents an object resulting from a route lookup. 
	For example, if a route lookup results in sending the packet out of a
	given interface, then the nexthop represents that interface.</t>

        <t>Nexthops can be either fully resolved or unresolved. A
        resolved nexthop has adequate information to send the outgoing packet
        to the destination by forwarding it on an interface to a directly
        connected neighbor. For example, a nexthop to a point-to-point
        interface or a nexthop to an IP address on an Ethernet interface has
        the nexthop resolved. An unresolved nexthop is something that requires
        the RIB manager to determine the final resolved nexthop. For example,
        a nexthop could be an IP address. The RIB manager would resolve how to
        reach that IP address; for example, is the IP address reachable by
	regular IP forwarding, by an MPLS tunnel, or by both? If the RIB manager cannot
        resolve the nexthop, then the nexthop remains in an unresolved state
        and is NOT a candidate for installation in the FIB. Future RIB events
        can cause an unresolved nexthop to get resolved (e.g., an IP address
        being advertised by an IGP neighbor). Conversely, resolved nexthops
        can also become unresolved (e.g., in the case of a tunnel going down);
        hence, they would no longer be candidates to be installed in the
        FIB.</t>

        <t>When at least one of a route's nexthops is resolved, then the route
        can be used to forward packets. Such a route is considered eligible to
        be installed in the FIB and is henceforth referred to as a
        FIB-eligible route. Conversely, when all the nexthops of a route are
        unresolved, that route can no longer be used to forward packets. Such a
        route is considered ineligible to be installed in the FIB and is
        henceforth referred to as a FIB-ineligible route. The RIB information
        model allows a RIB client to program routes whose nexthops may be
        unresolved initially. Whenever an unresolved nexthop gets resolved,
        the RIB manager will send a notification of the same (see <xref
        target="events"/>).</t>

        <t>The overall structure and usage of a nexthop is as shown in the
        figure below. For ease of description using ASCII art, only a single instance
        of any component of the nexthop is shown in <xref
        target="nexthop-model"/>.</t>

        <figure align="center" anchor="nexthop-model" title="Nexthop Model">
          <artwork name="Nexthop model"><![CDATA[                       
                              route
                                | 
                                | 0..N
                                |
                              nexthop <-------------------------------+
                                |                                     |
         +-------+----------------------------+-------------+         |
         |       |              |             |             |         |
         |       |              |             |             |         |
      base   load-balance   protection      replicate     chain       |
         |       |              |             |             |         |
         |       |2..N          |2..N         |2..N         |1..N     |
         |       |              |             |             |         |
         |       |              V             |             |         |
         |       +------------->+<------------+-------------+         |
         |                      |                                     |
         |                      +-------------------------------------+
         |
         +-------------------+
                             |
                             | 
                             |
                             |
    +---------------+--------+--------+--------------+----------+
    |               |                 |              |          |
    |               |                 |              |          |
 nexthop-id  egress-interface  ip-address     logical-tunnel    |
                                                                |
                                                                |
                         +--------------------------------------+
                         |
      +----------------------+------------------+-------------+
      |                      |                  |             |
      |                      |                  |             |
tunnel-encapsulation   tunnel-decapsulation  rib-name   special-nexthop
    ]]></artwork>
        </figure>

        <t>This document specifies a very generic, extensible, and recursive
        grammar for nexthops. A nexthop can be a base nexthop or a derived
        nexthop. <xref target="base-nexthop"/> details base nexthops, and <xref
        target="derived-nexthop"/> explains various kinds of derived nexthops.
        There are certain special nexthops, and those are described in <xref
        target="special-nexthops"/>. Lastly, <xref
        target="nexthop-indirection"/> delves into nexthop indirection and
        its use. Examples of when and how to use tunnel nexthops and derived
        nexthops are shown in <xref target="nexthop-examples"/>.</t>

        <section anchor="base-nexthop" title="Base Nexthops">
          <t>At the lowest level, a nexthop can be one of the following:<list
              style="symbols">
              <t>Identifier: This is an identifier returned by the network
              device representing a nexthop. This can be used as a way of
              reusing a nexthop when programming derived nexthops.</t>

              <t>Interface nexthops: These are nexthops that are pointing to an interface.
              Various attributes associated with these nexthops are: <list
                  style="symbols">
                  <t>Egress-interface: This represents a physical, logical, or
                  virtual interface on the network device. Address resolution
                  must not be required on this interface. This interface may
                  belong to any routing instance.</t>

                  <t>IP address: A route lookup on this IP address is done to
                  determine the egress-interface. Address resolution may be
                  required depending on the interface. <list style="symbols">
                      <t>An optional rib-name can also be specified to
                      indicate the RIB in which the IP address is to be looked
                      up. One can use the rib-name field to direct the packet
                      from one domain into another domain. By default the RIB
                      will be the same as the one that route belongs to.</t>
                    </list></t>
                </list> These attributes can be used in combination as
              follows: <list style="symbols">
                  <t>Egress-interface and IP address: This can be used in
                  cases where, e.g., the IP address is a link-local
                  address.</t>

                  <t>Egress-interface and MAC address: The egress-interface
                  must be an Ethernet interface. Address resolution is not
                  required for this nexthop.</t>
                </list></t>

              <t>Tunnel nexthops: These are nexthops that are pointing to a tunnel. The types of
              tunnel nexthops are: <list style="symbols">
                  <t>tunnel-encapsulation: This can be an encapsulation representing
                  an IP tunnel, MPLS tunnel, or others as defined in this
                  document. An optional egress-interface can be chained to the
                  tunnel-encapsulation to indicate which interface to send the packet
                  out on. The egress-interface is useful when the network
                  device contains Ethernet interfaces and one needs to perform
                  address resolution for the IP packet.</t>

                  <t>tunnel-decapsulation: This is to specify decapsulating a tunnel
                  header. After decapsulation, further lookup on the packet
                  can be done via chaining it with another nexthop. The packet
                  can also be sent out via an egress-interface directly.</t>

                  <t>logical-tunnel: This can be an MPLS Label Switched Path (LSP) or a GRE tunnel
                  (or others as defined in this document) that is represented
                  by a unique identifier (e.g., name).</t>
                </list></t>

              <t>rib-name: A nexthop pointing to a RIB. This indicates that
              the route lookup needs to continue in the specified RIB. This is
              a way to perform chained lookups.</t>
            </list></t>

          <t>Tunnel nexthops allow a RIB client to program static tunnel
          headers. There can be cases where the remote tunnel endpoint does
          not support dynamic signaling (e.g., no LDP support on a host); 
          in those cases, the RIB client might want to program the tunnel
          header on both ends of the tunnel. The tunnel nexthop is kept
          generic with specifications provided for some commonly used tunnels.
          It is expected that the data model will model these tunnel types
          with complete accuracy.</t>

          <section anchor="special-nexthops" title="Special Nexthops">
            <t>Special nexthops are for performing specific well-defined
            functions (e.g., DISCARD). The purpose of each of them is
            explained below:<list style="symbols">
                <t>DISCARD: This indicates that the network device should drop
                the packet and increment a drop counter.</t>

                <t>DISCARD_WITH_ERROR: This indicates that the network device
                should drop the packet, increment a drop counter, and send back
                an appropriate error message (like ICMP error).</t>

                <t>RECEIVE: This indicates that the traffic is destined
                for the network device, for example, protocol packets or
		Operations, Administration, and Maintenance (OAM)
                packets. All locally destined traffic SHOULD be throttled to
                avoid a denial-of-service attack on the router's control
                plane. An optional rate limiter can be specified to indicate
                how to throttle traffic destined for the control plane. The
                description of the rate limiter is outside the scope of this
                document.</t>
              </list></t>
          </section>
        </section>

        <section anchor="derived-nexthop" title="Derived Nexthops">

          <t>Derived nexthops can be: <list style="symbols">
              <t>weighted lists, which are used for load-balancing;</t>

              <t>preference lists, which are used for protection using primary and
              backup;</t>

              <t>replication lists, which are lists of nexthops to which to replicate a
              packet;</t>

              <t>nexthop chains, which are for chaining multiple operations or
              attaching multiple headers; or</t>

              <t>lists of lists, which are a recursive application of the above.</t>
            </list></t>

          <t>Nexthop chains (see <xref target="nexthop-chains"/> for usage)
          are a way to perform multiple operations on a packet by logically
          combining them. For example, one can chain together "decapsulate
          MPLS header" and "send it out a specific egress-interface". Chains
          can be used to specify multiple headers over a packet before a
          packet is forwarded. One simple example is that of MPLS over GRE,
          wherein the packet has an inner MPLS header followed by a GRE header
          followed by an IP header. The outermost IP header is decided by the
          network device, whereas the MPLS header or GRE header is specified
          by the controller. Not every network device will be able to support
          all kinds of nexthop chains and an arbitrary number of headers
          chained together. The RIB data model SHOULD provide a way to expose a
          nexthop chaining capability supported by a given network device.</t>

          <t>It is expected that all network devices will have a limit on how
          many levels of lookup can be performed, and not all hardware will be
          able to support all kinds of nexthops. RIB capability negotiation
          becomes very important for this reason, and a RIB data model MUST
          specify a way for a RIB client to learn about the network device's
          capabilities.</t>

          <section title="Nexthop List Attributes">
            <t>For nexthops that are of the form of a list(s), attributes can
            be associated with each member of the list to indicate the role of
            an individual member of the list. Two attributes are
            specified:<list style="symbols">
                <t>NEXTHOP_PREFERENCE: This is used for protection schemes. It
                is an integer value between 1 and 99. A lower value indicates
                higher preference. To download a primary/standby pair to the
                FIB, the nexthops that are resolved and have the two highest
                preferences are selected. Each &lt;NEXTHOP_PREFERENCE&gt;
                should have a unique value within a &lt;nexthop-protection&gt;
                (see <xref target="rib-grammar"/>).</t>

                <t>NEXTHOP_LB_WEIGHT: This is used for load-balancing. Each
                list member MUST be assigned a weight between 1 and 99. The
                weight determines the proportion of traffic to be sent over a
                nexthop used for forwarding as a ratio of the weight of this
                nexthop divided by the weights of all the nexthops of this
                route that are used for forwarding. To perform equal
                load-balancing, one MAY specify a weight of "0" for all the
                member nexthops. The value "0" is reserved for equal
                load-balancing and, if applied, MUST be applied to all member
                nexthops. Note that a weight of 0 is special because of historical
                reasons.</t>
              </list></t>
          </section>
        </section>

        <section anchor="nexthop-indirection" title="Nexthop Indirection">
          <t>Nexthops can be identified by an identifier to create a level of
          indirection. The identifier is set by the RIB manager and returned
          to the RIB client on request.</t>

          <t>One example of usage of indirection is a nexthop that points to
          another network device (e.g., a BGP peer). The returned nexthop
          identifier can then be used for programming routes to point to the
          this nexthop. Given that the RIB manager has created an indirection
          using the nexthop identifier, if the transport path to the network
          device (BGP peer) changes, that change in path will be seamless to
          the RIB client and all routes that point to that network device will
          automatically start going over the new transport path. Nexthop
          indirection using identifiers could be applied to not only unicast
          nexthops but also nexthops that contain chains and nested
          nexthops. See <xref target="derived-nexthop"/> for examples.</t>
        </section>
      </section>
    </section>

    <section anchor="rib-read" title="Reading from the RIB">
      <t>A RIB data model MUST allow a RIB client to read entries for RIBs
      created by that entity. The network device administrator MAY allow
      reading of other RIBs by a RIB client through access lists on the
      network device. The details of access lists are outside the scope of
      this document.</t>

      <t>The data model MUST support a full read of the RIB and subsequent
      incremental reads of changes to the RIB. When sending data to a RIB
      client, the RIB manager SHOULD try to send all dependencies of an object
      prior to sending that object.</t>
    </section>

    <section anchor="rib-write" title="Writing to the RIB">
      <t>A RIB data model MUST allow a RIB client to write entries for RIBs
      created by that entity. The network device administrator MAY allow
      writes to other RIBs by a RIB client through access lists on the network
      device. The details of access lists are outside the scope of this
      document.</t>

      <t>When writing an object to a RIB, the RIB client SHOULD try to write
      all dependencies of the object prior to sending that object. The
      data model SHOULD support requesting identifiers for nexthops and
      collecting the identifiers back in the response.</t>

      <t>Route programming in the RIB MUST result in a return code that
      contains the following attributes:<list style="symbols">
          <t>Installed: Yes/No (indicates whether the route got installed in
          the FIB)</t>

          <t>Active: Yes/No (indicates whether a route is fully resolved and
          is a candidate for selection)</t>

          <t>Reason: E.g., "Not authorized"</t>
        </list>The data model MUST specify which objects can be modified. An
      object that can be modified is one whose contents can be changed without
      having to change objects that depend on it and without affecting any
      data forwarding. To change a non-modifiable object, one will need to
      create a new object and delete the old one. For example, routes that use
      a nexthop that is identified by a nexthop identifier should be
      unaffected when the contents of that nexthop changes.</t>
    </section>

    <section anchor="events" title="Notifications">
      <t>Asynchronous notifications are sent by the network device's RIB
      manager to a RIB client when some event occurs on the network device. A
      RIB data model MUST support sending asynchronous notifications. A brief
      list of suggested notifications is as below:<list style="symbols">
          <t>Route change notification (with a return code as specified in <xref
          target="rib-write"/>)</t>

          <t>Nexthop resolution status (resolved/unresolved) notification</t>
        </list></t>
    </section>

    <section anchor="rib-grammar" title="RIB Grammar">
      <t>This section specifies the RIB information model in Routing
      Backus-Naur Form (rBNF) <xref target="RFC5511"/>. This grammar is intended to
      help the reader better understand <xref target="rib-data"/> in order to
      derive a data model.</t>

      <figure anchor="rib-grammar-details" title="RIB rBNF Grammar">
        <artwork><![CDATA[
<routing-instance> ::= <INSTANCE_NAME>
                       [<interface-list>] <rib-list>
                       [<ROUTER_ID>]


<interface-list> ::= (<INTERFACE_IDENTIFIER> ...)


<rib-list> ::= (<rib> ...)
<rib> ::= <rib-name> <address-family>
                    [<route> ... ]
                    [ENABLE_IP_RPF_CHECK]
<address-family> ::= <IPV4_ADDRESS_FAMILY> | <IPV6_ADDRESS_FAMILY> |
                     <MPLS_ADDRESS_FAMILY> | <IEEE_MAC_ADDRESS_FAMILY>


<route> ::= <match> <nexthop>
            [<route-attributes>]
            [<route-vendor-attributes>]


<match> ::= <IPV4> <ipv4-route> | <IPV6> <ipv6-route> |
            <MPLS> <MPLS_LABEL> | <IEEE_MAC> <MAC_ADDRESS> |
            <INTERFACE> <INTERFACE_IDENTIFIER>
<route-type> ::= <IPV4> | <IPV6> | <MPLS> | <IEEE_MAC> | <INTERFACE>


<ipv4-route> ::= <ip-route-type> 
                 (<destination-ipv4-address> | <source-ipv4-address> |
                  (<destination-ipv4-address> <source-ipv4-address>))
<destination-ipv4-address> ::= <ipv4-prefix>
<source-ipv4-address> ::= <ipv4-prefix>
<ipv4-prefix> ::= <IPV4_ADDRESS> <IPV4_PREFIX_LENGTH>


<ipv6-route> ::= <ip-route-type>
                 (<destination-ipv6-address> | <source-ipv6-address> |
                  (<destination-ipv6-address> <source-ipv6-address>))
<destination-ipv6-address> ::= <ipv6-prefix>
<source-ipv6-address> ::= <ipv6-prefix>
<ipv6-prefix> ::= <IPV6_ADDRESS> <IPV6_PREFIX_LENGTH>                 
<ip-route-type> ::= <SRC> | <DEST> | <DEST_SRC>


<route-attributes> ::= <ROUTE_PREFERENCE> [<LOCAL_ONLY>]       
                       [<address-family-route-attributes>]
                       
<address-family-route-attributes> ::= <ip-route-attributes> | 
                                      <mpls-route-attributes> | 
                                      <ethernet-route-attributes>
<ip-route-attributes> ::= <>
<mpls-route-attributes> ::= <>
<ethernet-route-attributes> ::= <>
<route-vendor-attributes> ::= <>


<nexthop> ::= <nexthop-base> |
              (<NEXTHOP_LOAD_BALANCE> <nexthop-lb>) |
              (<NEXTHOP_PROTECTION> <nexthop-protection>) |
              (<NEXTHOP_REPLICATE> <nexthop-replicate>) |
              <nexthop-chain>

<nexthop-base> ::= <NEXTHOP_ID> |
                   <nexthop-special> |
                   <egress-interface> |
                   <ipv4-address> | <ipv6-address> |
                   (<egress-interface> 
                       (<ipv4-address> | <ipv6-address>)) |
                   (<egress-interface> <IEEE_MAC_ADDRESS>) |
                   <tunnel-encapsulation> | <tunnel-decapsulation> |
                   <logical-tunnel> |
                   <rib-name>
                   
<egress-interface> ::= <INTERFACE_IDENTIFIER>

<nexthop-special> ::= <DISCARD> | <DISCARD_WITH_ERROR> | 
                      (<RECEIVE> [<COS_VALUE>])


<nexthop-lb> ::= <NEXTHOP_LB_WEIGHT> <nexthop>
                 (<NEXTHOP_LB_WEIGHT> <nexthop) ...


<nexthop-protection> = <NEXTHOP_PREFERENCE> <nexthop>
                      (<NEXTHOP_PREFERENCE> <nexthop>)...

<nexthop-replicate> ::= <nexthop> <nexthop> ...


<nexthop-chain> ::= <nexthop> ...


<logical-tunnel> ::= <tunnel-type> <TUNNEL_NAME>
<tunnel-type> ::= <IPV4> | <IPV6> | <MPLS> | <GRE> | <VxLAN> | <NVGRE>

<tunnel-encapsulation> ::= (<IPV4> <ipv4-header>) | 
                           (<IPV6> <ipv6-header>) |
                           (<MPLS> <mpls-header>) | 
                           (<GRE> <gre-header>) |
                           (<VXLAN> <vxlan-header>) | 
                           (<NVGRE> <nvgre-header>)
                   
<ipv4-header> ::= <SOURCE_IPv4_ADDRESS> <DESTINATION_IPv4_ADDRESS> 
                  <PROTOCOL> [<TTL>] [<DSCP>]
               
<ipv6-header> ::= <SOURCE_IPV6_ADDRESS> <DESTINATION_IPV6_ADDRESS> 
                  <NEXT_HEADER> [<TRAFFIC_CLASS>] 
                  [<FLOW_LABEL>] [<HOP_LIMIT>]

<mpls-header> ::= (<mpls-label-operation> ...)
<mpls-label-operation> ::= (<MPLS_PUSH> <MPLS_LABEL> [<S_BIT>] 
                                        [<TOS_VALUE>] [<TTL_VALUE>]) | 
                           (<MPLS_SWAP> <IN_LABEL> <OUT_LABEL>
                                       [<TTL_ACTION>])

<gre-header> ::= <GRE_IP_DESTINATION> <GRE_PROTOCOL_TYPE> [<GRE_KEY>]
<vxlan-header> ::= (<ipv4-header> | <ipv6-header>) 
                   [<VXLAN_IDENTIFIER>]
<nvgre-header> ::= (<ipv4-header> | <ipv6-header>) 
                   <VIRTUAL_SUBNET_ID> 
                   [<FLOW_ID>]

<tunnel-decapsulation> ::= ((<IPV4> <IPV4_DECAP> [<TTL_ACTION>]) |
                           (<IPV6> <IPV6_DECAP> [<HOP_LIMIT_ACTION>]) |
                           (<MPLS> <MPLS_POP> [<TTL_ACTION>]))


]]></artwork>
      </figure>

      <section title="Nexthop Grammar Explained">
        <t>A nexthop is used to specify the next network element to forward
        the traffic to. It is also used to specify how the traffic should be
        load-balanced, protected using preference, or multicast using
        replication. This is explicitly specified in the grammar. The nexthop
        has recursion built in to address complex use cases like the one
        defined in <xref target="lists-of-lists"/>.</t>
      </section>
    </section>

    <section anchor="rib-examples" title="Using the RIB Grammar">
      <t>The RIB grammar is very generic and covers a variety of features.
      This section provides examples on using objects in the RIB grammar and
      examples to program certain use cases.</t>

      <section anchor="route-preference" title="Using Route Preference">
        <t>Using route preference, a client can preinstall alternate paths in
        the network. For example, if OSPF has a route preference of 10, then
        another client can install a route with a route preference of 20 to the
        same destination. The OSPF route will get precedence and will get
        installed in the FIB. When the OSPF route is withdrawn, the alternate
        path will get installed in the FIB.</t>

        <t>Route preference can also be used to prevent denial-of-service
        attacks by installing routes with the best preference, which either
        drops the offending traffic or routes it to some monitoring/analysis
        station. Since the routes are installed with the best preference, they
        will supersede any route installed by any other protocol.</t>
      </section>

      <section anchor="nexthop-examples"
               title="Using Different Nexthop Types">
        <t>The RIB grammar allows one to create a variety of nexthops. This
        section describes uses for certain types of nexthops.</t>

        <section title="Tunnel Nexthops">
          <t>A tunnel nexthop points to a tunnel of some kind. Traffic that
          goes over the tunnel gets encapsulated with the tunnel-encapsulation. Tunnel
          nexthops are useful for abstracting out details of the network by
          having the traffic seamlessly route between network edges. At the
          end of a tunnel, the tunnel will get decapsulated. Thus, the grammar
          supports two kinds of operations: one for encapsulation and another
          for decapsulation.</t>
        </section>

        <section anchor="replication-list" title="Replication Lists">
          <t>One can create a replication list for replicating traffic to
          multiple destinations. The destinations, in turn, could be derived
          nexthops in themselves (at a level supported by the network device);
          point to multipoint and broadcast are examples that involve
          replication.</t>

          <t>A replication list (at the simplest level) can be represented
          as:</t>

          <figure>
            <artwork><![CDATA[
<nexthop> ::= <NEXTHOP_REPLICATE> <nexthop> [ <nexthop> ... ]
]]></artwork></figure>

<t>The above can be derived from the grammar as follows:</t>

<figure><artwork><![CDATA[
<nexthop> ::= <nexthop-replicate>
<nexthop> ::= <NEXTHOP_REPLICATE> <nexthop> <nexthop> ...
]]></artwork>
          </figure>
        </section>

        <section title="Weighted Lists">
          <t>A weighted list is used to load-balance traffic among a set of
          nexthops. From a modeling perspective, a weighted list is very
          similar to a replication list, with the difference that each member
          nexthop MUST have a NEXTHOP_LB_WEIGHT associated with it.</t>

          <t>A weighted list (at the simplest level) can be represented
          as:</t>

          <figure>
            <artwork><![CDATA[
<nexthop> ::= <NEXTHOP_LOAD_BALANCE> (<nexthop> <NEXTHOP_LB_WEIGHT>) 
                   [(<nexthop> <NEXTHOP_LB_WEIGHT>)... ]
]]></artwork></figure>

<t>The above can be derived from the grammar as follows:</t>

<figure><artwork><![CDATA[
<nexthop> ::= <nexthop-lb>
<nexthop> ::= <NEXTHOP_LOAD_BALANCE>
                <NEXTHOP_LB_WEIGHT> <nexthop> 
                (<NEXTHOP_LB_WEIGHT> <nexthop>) ...
<nexthop> ::= <NEXTHOP_LOAD_BALANCE> (<NEXTHOP_LB_WEIGHT> <nexthop>)
                (<NEXTHOP_LB_WEIGHT> <nexthop>) ...
]]></artwork>
          </figure>
        </section>

        <section title="Protection">
          <t>A primary/backup protection can be represented as:</t>

          <figure>
            <artwork><![CDATA[
<nexthop> ::= <NEXTHOP_PROTECTION> <1> <interface-primary>
                                   <2> <interface-backup>)

]]></artwork></figure>

<t>The above can be derived from the grammar as follows:</t>

<figure><artwork><![CDATA[
<nexthop> ::= <nexthop-protection>
<nexthop> ::= <NEXTHOP_PROTECTION> (<NEXTHOP_PREFERENCE> <nexthop>
                      (<NEXTHOP_PREFERENCE> <nexthop>)...)
<nexthop> ::= <NEXTHOP_PROTECTION> (<NEXTHOP_PREFERENCE> <nexthop>
                      (<NEXTHOP_PREFERENCE> <nexthop>))
<nexthop> ::= <NEXTHOP_PROTECTION> ((<NEXTHOP_PREFERENCE> <nexthop-base>
                      (<NEXTHOP_PREFERENCE> <nexthop-base>))
<nexthop> ::= <NEXTHOP_PROTECTION> (<1> <interface-primary>
                      (<2> <interface-backup>))
]]></artwork>
          </figure>

          <t>Traffic can be load-balanced among multiple primary nexthops and
          a single backup. In such a case, the nexthop will look like:</t>

          <figure>
            <artwork><![CDATA[
<nexthop> ::= <NEXTHOP_PROTECTION> (<1>
              (<NEXTHOP_LOAD_BALANCE> 
               (<NEXTHOP_LB_WEIGHT> <nexthop-base>
               (<NEXTHOP_LB_WEIGHT> <nexthop-base>) ...))
                <2> <nexthop-base>)
]]></artwork>
          </figure>

          <t>A backup can also have another backup. In such a case, the list
          will look like:</t>

          <figure>
            <artwork><![CDATA[
<nexthop> ::= <NEXTHOP_PROTECTION> (<1> <nexthop> 
              <2> <NEXTHOP_PROTECTION>(<1> <nexthop> <2> <nexthop>))
]]></artwork>
          </figure>
        </section>

        <section anchor="nexthop-chains" title="Nexthop Chains">
<t>A nexthop chain is a way to perform multiple operations on a packet by
logically combining them.
For example, when a VPN packet comes on
the WAN interface and has to be forwarded to the correct VPN
interface, one needs to pop the VPN label before sending the packet
out.  Using a nexthop chain, one can chain together "pop MPLS header" 
and "send it out a specific egress-interface".</t>

<t>The above example can be derived from the grammar as follows:</t>
          <figure>
            <artwork><![CDATA[
<nexthop-chain> ::= <nexthop> <nexthop>
<nexthop-chain> ::= <nexthop-base> <nexthop-base>
<nexthop-chain> ::= <tunnel-decapsulation> <egress-interface>
<nexthop-chain> ::= (<MPLS> <MPLS_POP>) <interface-outgoing>
]]></artwork>
          </figure>

          <t>Elements in a nexthop chain are evaluated left to right.</t>

          <t>A nexthop chain can also be used to put one or more headers on an
          outgoing packet. One example is a pseudowire, which is MPLS over
          some transport (MPLS or GRE, for instance). Another example is
	  Virtual eXtensible Local Area Network (VXLAN) over IP. 
A nexthop chain thus allows a RIB client to break up the
          programming of the nexthop into independent pieces (one per
          encapsulation).</t>

          <t>A simple example of MPLS over GRE can be represented as follows:</t>

          <figure>
            <artwork><![CDATA[
<nexthop-chain> ::= (<MPLS> <mpls-header>) (<GRE> <gre-header>)
                    <interface-outgoing>
]]></artwork></figure>

<t>The above can be derived from the grammar as follows:</t>

<figure><artwork><![CDATA[
<nexthop-chain> ::= <nexthop> <nexthop> <nexthop>
<nexthop-chain> ::= <nexthop-base> <nexthop-base> <nexthop-base>
<nexthop-chain> ::= <tunnel-encapsulation> <tunnel-encapsulation> 
                    <egress-interface>
<nexthop-chain> ::= (<MPLS> <mpls-header>) (<GRE> <gre-header>)
                    <interface-outgoing>
]]></artwork>
          </figure>
        </section>

        <section anchor="lists-of-lists" title="Lists of Lists">
          <t>Lists of lists is a derived construct. One example of usage of
          such a construct is to replicate traffic to multiple destinations
          with load-balancing. In other words, for each branch of the
          replication tree, there are multiple interfaces on which traffic
          needs to be load-balanced. So, the outer list is a replication
          list for multicast and the inner lists are weighted lists for load-balancing. Let's take an example of a network element that has to
          replicate traffic to two other network elements. Traffic to the
          first network element should be load-balanced equally over two
          interfaces: outgoing-1-1 and outgoing-1-2. Traffic to the second
          network element should be load-balanced over three interfaces:
          outgoing-2-1, outgoing-2-2, and outgoing-2-3 (in the ratio
          20:20:60).</t>

<t>This can be derived from the grammar as follows:</t>
          <figure>
            <artwork><![CDATA[
<nexthop> ::= <nexthop-replicate>
<nexthop> ::= <NEXTHOP_REPLICATE> (<nexthop> <nexthop>...)
<nexthop> ::= <NEXTHOP_REPLICATE> (<nexthop> <nexthop>)
<nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE> <nexthop-lb>)
              (<NEXTHOP_LOAD_BALANCE> <nexthop-lb>))
<nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE>
              (<NEXTHOP_LB_WEIGHT> <nexthop> 
              (<NEXTHOP_LB_WEIGHT> <nexthop>) ...))
               ((<NEXTHOP_LOAD_BALANCE>
                (<NEXTHOP_LB_WEIGHT> <nexthop>
                (<NEXTHOP_LB_WEIGHT> <nexthop>) ...))
<nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE>
              (<NEXTHOP_LB_WEIGHT> <nexthop> 
               (<NEXTHOP_LB_WEIGHT> <nexthop>)))
                ((<NEXTHOP_LOAD_BALANCE>
                (<NEXTHOP_LB_WEIGHT> <nexthop>
                (<NEXTHOP_LB_WEIGHT> <nexthop>)
                (<NEXTHOP_LB_WEIGHT> <nexthop>)))
<nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE>
               (<NEXTHOP_LB_WEIGHT> <nexthop>) 
               (<NEXTHOP_LB_WEIGHT> <nexthop>)))
               ((<NEXTHOP_LOAD_BALANCE>
               (<NEXTHOP_LB_WEIGHT> <nexthop>)
               (<NEXTHOP_LB_WEIGHT> <nexthop>)
               (<NEXTHOP_LB_WEIGHT> <nexthop>)))
<nexthop> ::= <NEXTHOP_REPLICATE>
               ((<NEXTHOP_LOAD_BALANCE>
                 (50 <outgoing-1-1>) 
                 (50 <outgoing-1-2>)))
                ((<NEXTHOP_LOAD_BALANCE>
                  (20 <outgoing-2-1>)
                  (20 <outgoing-2-2>)
                  (60 <outgoing-2-3>)))
]]></artwork>
          </figure>

          <t/>
        </section>
      </section>

      <section title="Performing Multicast">
        <t>IP multicast involves matching a packet on (S,G) or (*,G), where
        both S (Source) and G (Group) are IP prefixes. Following the match,
        the packet is replicated to one or more recipients. How the recipients
        subscribe to the multicast group is outside the scope of this
        document.</t>

        <t>In PIM-based multicast, the packets are IP forwarded on an IP
        multicast tree. The downstream nodes on each point in the multicast
        tree are one or more IP addresses. These can be represented as a
        replication list (see <xref target="replication-list"/>).</t>

        <t>In MPLS-based multicast, the packets are forwarded on a Point-to-Multipoint
        (P2MP) LSP. The nexthop for a P2MP
        LSP can be represented in the nexthop grammar as a
        &lt;logical-tunnel&gt; (P2MP LSP identifier) or a replication list 
        (see <xref target="replication-list"/>) of &lt;tunnel-encapsulation&gt;, with each
        tunnel-encapsulation representing a single MPLS downstream nexthop.</t>
      </section>
    </section>

    <section anchor="rib-scale" title="RIB Operations at Scale">
      <t>This section discusses the scale requirements for a RIB data model.
      The RIB data model should be able to handle a large scale of operations to
      enable deployment of RIB applications in large networks.</t>

      <section title="RIB Reads">
        <t>Bulking (grouping of multiple objects in a single message) MUST be
        supported when a network device sends RIB data to a RIB client.
        Similarly, the data model MUST enable a RIB client to request data in
        bulk from a network device.</t>
      </section>

      <section title="RIB Writes">
        <t>Bulking (grouping of multiple write operations in a single message)
        MUST be supported when a RIB client wants to write to the RIB. The
        response from the network device MUST include a return-code for each
        write operation in the bulk message.</t>
      </section>

      <section title="RIB Events and Notifications">
        <t>There can be cases where a single network event results in multiple
        events and/or notifications from the network device to a RIB client.
        On the other hand, due to timing of multiple things happening at the
        same time, a network device might have to send multiple events and/or
        notifications to a RIB client. The network-device-originated
        event/notification message MUST support the bulking of multiple events and
        notifications in a single message.</t>
      </section>
    </section>

    <section title="Security Considerations">

<t>The information model specified in this document defines a schema for data
models that are designed to be accessed via network management protocols such
as NETCONF <xref target="RFC6241"/> or RESTCONF <xref target="RFC8040"/>.
The lowest NETCONF layer is the secure transport layer, and the
mandatory-to-implement secure transport is Secure Shell (SSH) <xref target="RFC6242"/>. 
The lowest RESTCONF layer is HTTPS, and the mandatory-to-implement secure
transport is TLS <xref target="RFC5246"/>.</t>

<t>The NETCONF access control model <xref target="RFC8341"/> provides the
means to restrict access for particular NETCONF or RESTCONF users to a
preconfigured subset of all available NETCONF or RESTCONF protocol operations
and content.</t>


<t>The RIB information model specifies read and write operations to network
devices.  These network devices might be considered sensitive or vulnerable in
some network environments.  Write operations to these network devices without
proper protection can have a negative effect on network operations.  Due to
this factor, it is recommended that data models also consider the following in
their design:</t>

      <t><list style="symbols">
          <t>Require utilization of the authentication and authorization
          features of the NETCONF or RESTCONF suite of protocols.</t>

          <t>Augment the limits on how much data can be written or updated by
          a remote entity built to include enough protection for a RIB data
          model.</t>

          <t>Expose the specific RIB data model implemented via NETCONF/RESTCONF
          data models.</t>
        </list></t>

    </section>

    <section title="IANA Considerations">
      <t>This document has no IANA actions.</t>
    </section>

  </middle>

  <back>
    <references title="Normative References">
      &RFC2119;

      &RFC5246;

      &RFC6241;
      
      &RFC6242;

      &RFC8040;

      &RFC8341;
      
      &RFC8174;
    </references>

    <references title="Informative References">
      &RFC4915;

      &RFC5120;

      &RFC5511;

      &RFC7920;

<reference anchor='RFC8431' target='http://www.rfc-editor.org/info/rfc8431'>
<front>
<title>A YANG Data Model for the Routing Information Base (RIB)</title>

<author initials='L' surname='Wang' fullname='Lixing Wang'>
    <organization />
</author>

<author initials='M' surname='Chen' fullname='Mach Chen'>
    <organization />
</author>

<author initials='A' surname='Dass' fullname='Amit Dass'>
    <organization />
</author>

<author initials='H' surname='Ananthakrishnan' fullname='Hariharan Ananthakrishnan'>
    <organization />
</author>

<author initials='S' surname='Kini' fullname='Sriganesh Kini'>
    <organization />
</author>

<author initials='N' surname='Bahadur' fullname='Nitin Bahadur'>
    <organization />
</author>

<date month='September' year='2018' />

<abstract><t>This document defines a YANG data model for the Routing Information Base (RIB) that aligns with the I2RS RIB information model.</t></abstract>

</front>

<seriesInfo name='RFC' value='8431' />
<seriesInfo name="DOI" value="10.17487/RFC8431"/>
</reference>

    </references>

    <section title="Acknowledgements" numbered="no"> 
<t>The authors would like to thank Ron
Folkes, Jeffrey Zhang, the WG co-Chairs, and reviewers for their
comments and suggestions on this document. The following people contributed to
the design of the RIB information model as part of the I2RS Interim meeting in April 2013:
Wes George, Chris Liljenstolpe, Jeff Tantsura, Susan Hares, and Fabian
Schneider.</t> </section>

  </back>
</rfc>
