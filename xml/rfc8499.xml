<?xml version="1.0" encoding="US-ASCII"?>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc number="8499" submissionType="IETF"  ipr="trust200902" category="bcp" consensus="yes" seriesNo="219"
     obsoletes="7719" updates="2308"
>

<front>
<title abbrev="DNS Terminology">DNS Terminology</title>

<author initials="P." surname="Hoffman" fullname="Paul Hoffman">
<organization>ICANN</organization>
<address>
<email>paul.hoffman@icann.org</email>
</address>
</author>
<author initials="A." surname="Sullivan" fullname="Andrew Sullivan">
<organization> </organization>
<address>
<email>ajs@anvilwalrusden.com</email>
</address>
</author>
<author initials="K." surname="Fujiwara" fullname="Kazunori Fujiwara">
<organization abbrev="JPRS">Japan Registry Services Co., Ltd.</organization>
<address>
<postal>
<street>Chiyoda First Bldg. East 13F, 3-8-1 Nishi-Kanda</street>
<city>Chiyoda-ku, Tokyo</city>
<code>101-0065</code>
<country>Japan</country>
</postal>
<phone>+81 3 5215 8451</phone>
<email>fujiwara@jprs.co.jp</email>
</address>
</author>

<date month="December" year="2018"/>

<area>Internet</area>


<keyword>vocabulary, domain name system</keyword>



<abstract>

<t>The Domain Name System (DNS) is defined in literally dozens of
different RFCs. The terminology used by implementers and developers of
DNS protocols, and by operators of DNS systems, has sometimes changed
in the decades since the DNS was first defined. This document gives
current definitions for many of the terms used in the DNS in a single
document.</t>

<t>This document obsoletes RFC 7719 and updates RFC 2308.</t>

</abstract>

</front>

<middle>

  <section anchor="introduction" title="Introduction">



<t>The Domain Name System (DNS) is a simple query-response protocol
whose messages in both directions have the same format.  (<xref
target="names"/> gives a definition of "public DNS", which is often
what people mean when they say "the DNS".)  The protocol and message
format are defined in <xref target="RFC1034"/> and <xref
target="RFC1035"/>. These RFCs defined some terms, and later documents
defined others. Some of the terms from <xref target="RFC1034"/> and
<xref target="RFC1035"/> have somewhat different meanings now than
they did in 1987.</t>



<t>This document contains a collection of a wide variety of DNS-related terms, organized loosely by topic. Some of
   them have been precisely defined in earlier RFCs, some have been
   loosely defined in earlier RFCs, and some are not defined in an
   earlier RFC at all.</t>

<t>Other organizations sometimes define DNS-related terms their own way.
For example, the WHATWG defines "domain" at
&lt;https://url.spec.whatwg.org/&gt;.
The Root Server System Advisory Committee (RSSAC) has a good
lexicon <xref target="RSSAC026"/>.
</t>

<t>Most of the definitions listed here represent the consensus definition of the DNS
community -- both protocol developers and operators. Some of the definitions
differ from earlier RFCs, and those differences are noted.
In this document, where the consensus definition is the same as the one in
an RFC, that RFC is quoted. Where the consensus definition has changed somewhat,
the RFC is mentioned but the new stand-alone definition is given.
See <xref target="updates-list"/> for a list of the definitions
that this document updates.</t>

<t>It is important to note that,
during the development of this document, it became clear that some DNS-related terms
are interpreted quite differently by different DNS experts. Further, some terms
that are defined in early DNS RFCs now have definitions that are generally agreed to, but
that are different from the original definitions.
Therefore, this document is a substantial revision to <xref target="RFC7719"/>.</t>

<t>Note that there is no single consistent definition of "the DNS". It can be considered to be some
combination of the following: a commonly used naming scheme for objects on the Internet; a distributed database representing
the names and certain properties of these objects; an architecture providing distributed
maintenance, resilience, and loose coherency for this database; and a simple query-response protocol
(as mentioned below) implementing this architecture. <xref target="names"/> defines
"global DNS" and "private DNS" as a way to deal with these differing definitions.</t>

<t>Capitalization in DNS terms is often inconsistent among RFCs and
various DNS practitioners. The capitalization used in this document is a best
guess at current practices, and is not meant to indicate that other
capitalization styles are wrong or archaic.
In some cases, multiple styles of capitalization are used for the same term due to quoting
from different RFCs.</t>

<t>Readers should note that the terms in this document are grouped by topic.
Someone who is not already familiar with the DNS probably cannot
learn about the DNS from scratch by reading this document from front to back. 
Instead, skipping around may be the only way to get enough context to
understand some of the definitions. This document has an index that might be useful for
readers who are attempting to learn the DNS by reading this document.</t>


</section>

<section anchor="names" title="Names">
<t><list style="hanging">

<t hangText='Naming system:'>
<iref item='Naming system'/>
A naming system associates names with data. Naming systems have many significant facets
that help differentiate them from each other. Some commonly identified facets include:

<list style="symbols">
<t>Composition of names</t>
<t>Format of names</t>
<t>Administration of names</t>
<t>Types of data that can be associated with names</t>
<t>Types of metadata for names</t>
<t>Protocol for getting data from a name</t>
<t>Context for resolving a name</t>
</list></t>

<t>Note that this list is a small subset of facets that people have identified over time
for naming systems, and the IETF has yet to agree on a good set of facets that can be used
to compare naming systems. For example, other facets might include "protocol to update
data in a name", "privacy of names", and "privacy of data associated with names", but
those are not as well defined as the ones listed above. The list here is chosen because it
helps describe the DNS and naming systems similar to the DNS.</t>

<t hangText='Domain name:'>
<iref item='Domain name'/>
An ordered list of one or more labels.</t>



<t>Note that this is a definition independent of the DNS RFCs (<xref target="RFC1034"/> and <xref target="RFC1035"/>), and the definition here
also applies to systems other than the DNS. <xref target="RFC1034"/> defines the "domain
name space" using mathematical trees and their nodes in graph theory, and that definition
has the same practical result as the definition here. Any path of a directed acyclic graph
can be represented by a domain name consisting of the labels of its nodes, ordered by
decreasing distance from the root(s) (which is the normal convention within the DNS,
including this document). A domain name whose last label identifies a root of the graph is
fully qualified; other domain names whose labels form a strict prefix of a fully-qualified
domain name are relative to its first omitted node.</t>

<t>Also note that different IETF and non-IETF documents have used the term "domain name"
in many different ways. It is common for earlier documents to use "domain name" to mean
"names that match the syntax in <xref target="RFC1035"/>", but possibly with additional
rules such as "and are, or will be, resolvable in the global DNS" or "but only using the
presentation format".</t>

<t hangText='Label:'>
<iref item='Label'/>
An ordered list of zero or more octets that makes up a portion of a domain name.
Using graph theory, a label identifies one node in a portion of the graph of all possible
domain names.</t>

<t hangText='Global DNS:'>
<iref item='Global DNS'/>
Using the short set of facets listed in "Naming system", the global DNS can be defined as
follows. Most of the rules here come from <xref target="RFC1034"/> and <xref
target="RFC1035"/>, although the term "global DNS" has not been defined before now.</t>

<t>Composition of names: A name in the global DNS has one or more
labels.  The length of each label is between 0 and 63 octets
inclusive. In a fully-qualified domain name, the last label
in the ordered list is 0 octets long; it is the only label whose
length may be 0 octets, and it is called the "root" or "root label".
A domain name in the global DNS has a maximum total length of 255
octets in the wire format; the root represents one octet for this
calculation.
(Multicast DNS <xref target="RFC6762"/> allows names up to 255 bytes plus a terminating zero byte
based on a different interpretation of RFC 1035 and what is included in the 255 octets.)
</t>

<t>Format of names: Names in the global DNS are domain names. There are three formats:
wire format,  presentation format, and common display.
<list style="empty">
<t>The basic wire format for names in the global DNS is a list of labels ordered by
decreasing distance from the root, with the root label last. Each label is preceded by a
length octet. <xref target="RFC1035"/> also defines a compression scheme that modifies
this format.</t>

<t>The presentation format for names in the global DNS is a list of labels ordered by
decreasing distance from the root, encoded as ASCII, with a "." character between each
label. In presentation format, a fully-qualified domain name includes the root label and
the associated separator dot. For example, in presentation format, a fully-qualified
domain name with two non-root labels is always shown as "example.tld." instead of
"example.tld". <xref target="RFC1035"/> defines a method for showing octets that do not
display in ASCII.</t>

<t>The common display format is used in applications and free text. It is the same as the
presentation format, but showing the root label and the "." before it is optional and is
rarely done. For example, in common display format, a fully-qualified domain name with two
non-root labels is usually shown as "example.tld" instead of "example.tld.". Names in the
common display format are normally written such that the directionality of the writing
system presents labels by decreasing distance from the root (so, in both English and the C programming language the
root or Top-Level Domain (TLD) label in the ordered list is rightmost; but in Arabic, it may be leftmost,
depending on local conventions).</t></list></t>

<t>Administration of names: Administration is specified by delegation (see the
definition of "delegation" in <xref target="zones"/>).  Policies for administration of
the root zone in the global DNS are determined by the names operational community, which
convenes itself in the Internet Corporation for Assigned Names and Numbers (ICANN).  The
names operational community selects the IANA Functions Operator for the global DNS root
zone. At the time of writing, that operator is Public Technical
Identifiers (PTI).
(See &lt;https://pti.icann.org/&gt; for more information about PTI operating the IANA Functions.)
The name servers that serve the root zone are provided by independent
root operators. Other zones in the global DNS have their own policies for
administration.</t>

<t>Types of data that can be associated with names: A name can have zero or more
resource records associated with it. There are numerous types of resource records with
unique data structures defined in many different RFCs and in the IANA registry at <xref
target="IANA_Resource_Registry"/>.</t>

<t>Types of metadata for names: Any name that is published in the DNS appears as a set
of resource records (see the definition of "RRset" in <xref target="rrs"/>).  Some names
do not, themselves, have data associated with them in the DNS, but they "appear" in the DNS
anyway because they form part of a longer name that does have data associated with it (see
the definition of "empty non-terminals" in <xref target="zones"/>).</t>

<t>Protocol for getting data from a name: The protocol described in <xref
target="RFC1035"/>.</t>

<t>Context for resolving a name: The global DNS root zone distributed by PTI.</t>

<t hangText='Private DNS:'>
<iref item='Private DNS'/>
Names that use the protocol described in <xref target="RFC1035"/> but that do not rely on
the global DNS root zone or names that are otherwise not generally available on the
Internet but are using the protocol described in <xref target="RFC1035"/>.  A system can
use both the global DNS and one or more private DNS systems; for example, see "Split DNS"
in <xref target="dns-servers-and-clients"/>.</t>

<t>Note that domain names that do not appear in the DNS, and that are intended never to be
looked up using the DNS protocol, are not part of the global DNS or a private DNS even
though they are domain names.</t>

<t hangText='Multicast DNS (mDNS):'>
<iref item='Multicast DNS'/>
<iref item='mDNS'/> 

<!--Begin DNE text -->
"Multicast DNS (mDNS) provides the ability to perform DNS-like operations on the local link in the
absence of any conventional Unicast DNS server.  In addition, Multicast DNS designates a portion of
the DNS namespace to be free for local use, without the need to pay any annual fee, and without the
need to set up delegations or otherwise configure a conventional DNS server to answer for those
names."  (Quoted from <xref target="RFC6762"/>, Abstract)
<!--End DNE text -->
Although it uses a compatible wire format, mDNS is, strictly speaking, a different protocol than DNS.
Also, where the above quote says "a portion of the DNS namespace", it would be clearer to say "a
portion of the domain name space".  The names in mDNS are not intended to be looked up in the
DNS.</t>

<t hangText='Locally served DNS zone:'>
<iref item='Locally served DNS zone'/>
A locally served DNS zone is a special case of private DNS.
Names are resolved using the DNS protocol in a local context. 
<xref target="RFC6303"/> defines subdomains of IN-ADDR.ARPA
that are locally served zones.
Resolution of names through locally served zones may result in ambiguous results.
For example, the same name may resolve to different results in different locally served DNS
zone contexts.  The context for a locally served DNS zone may be explicit, such as those that are listed in 
<xref target="RFC6303"/> and <xref target="RFC7793"/>, or implicit, such as those defined by local DNS administration and not known to the
resolution client.</t>

<t hangText='Fully-Qualified Domain Name (FQDN):'>
<iref item='Fully-qualified domain name (FQDN)'/>
This is often just a clear way
of saying the same thing as "domain name of a node", as outlined
above.  However, the term is ambiguous.  Strictly speaking, a fully-qualified
domain name would include every label, including the zero-length label
of the root: such a name would be written "www.example.net."
(note the terminating dot).  But, because every name eventually shares
the common root, names are often written relative to the root
(such as "www.example.net") and are still called "fully qualified".
This term first appeared in <xref target="RFC0819"/>. In this document, names
are often written relative to the root.</t>
<t>The need for the term "fully-qualified domain name" comes from the existence
of partially qualified domain names, which are names where one or more
of the last labels in the ordered list are omitted (for example,
a domain name of "www" relative to "example.net" identifies "www.example.net").
Such relative names are understood only by context.</t>

<t hangText='Host name:'>
<iref item='Host name'/>
This term and its equivalent, "hostname", have been
widely used but are not defined in <xref target="RFC1034"/>, <xref target="RFC1035"/>,
<xref target="RFC1123"/>, or <xref target="RFC2181"/>. The
DNS was originally deployed into the Host Tables environment as
outlined in <xref target="RFC0952"/>, and it is likely that the term followed
informally from the definition there.


Over time, the definition seems
to have shifted. "Host name" is often meant to be a domain name that follows
the rules in Section 3.5 of <xref target="RFC1034"/>, which is also called the "preferred name
syntax". (In that syntax, every character in each label is a letter,
a digit, or a hyphen). Note that any label in a domain name can contain any octet
value; hostnames are generally considered to be domain names where
every label follows the rules in the "preferred name syntax", with the
amendment that labels can start with ASCII digits (this amendment
comes from Section 2.1 of <xref target="RFC1123"/>).

</t>
<t>People also sometimes use the term "hostname" to refer to just the first
label of an FQDN, such as "printer" in "printer.admin.example.com".
(Sometimes this is formalized in configuration in operating systems.) 
In addition, people sometimes use this term to
describe any name that refers to a machine, and those might include
labels that do not conform to the "preferred name syntax".</t>

<t hangText='Top-Level Domain (TLD):'>
<iref item='TLD'/>
A Top-Level Domain is a zone that is one layer below the
root, such as "com" or "jp".  There is nothing special, from the point
of view of the DNS, about TLDs.  Most of them are also
delegation-centric zones (defined in <xref target="zones"/>, and there are significant policy issues
around their operation.
TLDs are often divided into sub-groups such as Country Code Top-Level Domains
(ccTLDs), Generic Top-Level Domains (gTLDs), and others; the
division is a matter of policy and beyond the scope of this document.</t>

<t hangText='Internationalized Domain Name (IDN):'>
<iref item='Internationalized Domain Name'/> 
<iref item='IDN'/>
The Internationalized Domain Names for Applications (IDNA) protocol is
the standard mechanism for handling domain names with non-ASCII
characters in applications in the DNS. The current standard at the
time of this writing, normally called "IDNA2008", is defined in <xref
target="RFC5890"/>, <xref target="RFC5891"/>, <xref
target="RFC5892"/>, <xref target="RFC5893"/>, and <xref
target="RFC5894"/>.  These documents define many IDN-specific terms
such as "LDH label", "A-label", and "U-label".  <xref
target="RFC6365"/> defines more terms that relate to
internationalization (some of which relate to IDNs); <xref
target="RFC6055"/> has a much more extensive discussion of IDNs,
including some new terminology.</t>

<t hangText='Subdomain:'>
<iref item='Subdomain'/>

<!--Begin DNE text -->
"A domain is a subdomain of another domain if it is contained within that domain.  This relationship can be tested by
seeing if the subdomain's name ends with the containing domain's name."  (Quoted
from <xref target="RFC1034"/>, Section 3.1)
<!--End DNE text -->

For
example, in the host name "nnn.mmm.example.com", both "mmm.example.com" and "nnn.mmm.example.com" are subdomains of "example.com".
Note that the comparisons here are done on whole labels; that is,
"ooo.example.com" is not a subdomain of "oo.example.com".</t>

<t hangText='Alias:'>
<iref item='Alias'/>
The owner of a CNAME resource record, or a subdomain of the owner of a
DNAME resource record (DNAME records are defined in <xref target="RFC6672"/>). See also "canonical name".</t>

<t hangText='Canonical name:'>
<iref item='Canonical name'/>
A CNAME resource record 
<!--Begin DNE text -->
"identifies its owner name as an
alias, and specifies the corresponding canonical name in the RDATA
section of the RR." (Quoted from <xref target="RFC1034"/>, Section 3.6.2)
<!--END DNE text -->
This usage of the word "canonical" is related to the mathematical
concept of "canonical form".</t>

<t hangText='CNAME:'>
  <iref item='CNAME'/>
  <!--Begin DNE-->
 
   "It has been traditional to refer to the [owner] of a CNAME record as 'a
   CNAME'.  This is unfortunate, as 'CNAME' is an abbreviation of
   'canonical name', and the [owner] of a CNAME record is most certainly
   not a canonical name."  
   <!--End DNE text -->


(Quoted from <xref target="RFC2181"/>, Section 10.1.1. The quoted
text has been changed from "label" to "owner".)</t></list></t>


</section>

<section anchor="dns-response-codes" title="DNS Response Codes">

<t>Some of the response codes (RCODEs) that are defined in <xref target="RFC1035"/> have acquired their own
shorthand names.  All of the RCODEs are listed at
<xref target="IANA_Resource_Registry"/>, although
that list uses mixed-case capitalization, while most documents use all caps.
Some of the common names for values defined in <xref target="RFC1035"/> are described in this section.
This section also includes an additional RCODE and a general definition.
The official list of all RCODEs is in the IANA registry.</t>



<t><list style="hanging">

<t hangText='NOERROR:'>
<iref item='NOERROR'/>
This RCODE appears as "No error condition" in Section 4.1.1 of <xref target="RFC1035"/>.</t>

<t hangText='FORMERR:'>
<iref item='FORMERR'/>
This RCODE appears as "Format error - The name server was unable to interpret the query" in Section 4.1.1 of <xref target="RFC1035"/>.</t>

<t hangText='SERVFAIL:'>
<iref item='SERVFAIL'/>
This RCODE appears as "Server failure - The name server was unable to process this query due to a problem with the name
server" in Section 4.1.1 of <xref target="RFC1035"/>.</t>

<t hangText='NXDOMAIN:'>
<iref item='NXDOMAIN'/>
This RCODE appears as "Name Error [...] this code signifies that the domain name
referenced in the query does not exist." in Section 4.1.1 of <xref target="RFC1035"/>.
<xref target="RFC2308"/> established NXDOMAIN as a synonym for Name Error.</t>

<t hangText='NOTIMP:'>
<iref item='NOTIMP'/>
This RCODE appears as "Not Implemented - The name server does not support the requested kind of query" in Section 4.1.1 of <xref target="RFC1035"/>.</t>

<t hangText='REFUSED:'>
<iref item='REFUSED'/>
This RCODE appears as "Refused - The name server refuses to perform the specified operation for policy reasons.  For
example, a name server may not wish to provide the information to the particular requester, or a
name server may not wish to perform a particular operation (e.g., zone transfer) for particular
data." in Section 4.1.1 of <xref target="RFC1035"/>.</t>

<t hangText='NODATA:'>
<iref item='NODATA'/>
"A pseudo RCODE which indicates that the name is valid, for
the given class, but [there] are no records of the given type.  A NODATA
response has to be inferred from the answer." (Quoted from <xref target="RFC2308"/>, Section 1)
"NODATA is indicated by an answer with the RCODE set to NOERROR and no
relevant answers in the Answer section.  The authority section will
contain an SOA record, or there will be no NS records there." (Quoted from <xref target="RFC2308"/>, Section 2.2)
Note that referrals have a similar format to NODATA replies; <xref target="RFC2308"/>
explains how to distinguish them.</t>

<t>The term "NXRRSET" is sometimes used as a synonym for NODATA. However, this is a mistake, given
that NXRRSET is a specific error code defined in <xref target="RFC2136"/>.</t>

<t hangText='Negative response:'>
  <iref item='Negative response'/>

A response that indicates that a particular RRset does not exist 
or whose RCODE indicates that the nameserver cannot answer.
Sections 2 and 7 of <xref target="RFC2308"/> describe the types of negative responses in detail.</t>

</list></t>

</section>

<section anchor="dns-transactions" title="DNS Transactions">

<t>The header of a DNS message is its first 12 octets. Many of the fields and flags in
the diagrams in Sections 4.1.1 through 4.1.3 of <xref target="RFC1035"/> are referred to by their names
in each diagram.



For example, the response codes are called "RCODEs",
the data for a record is called the "RDATA", and the
authoritative answer bit is often called "the AA flag" or "the AA bit".</t>

<t><list style="hanging">

<t hangText='Class:'>
<iref item='Class'/>
A class "identifies a protocol family or instance of a protocol".  (Quoted from <xref
target="RFC1034"/>, Section 3.6)  

  <!--Begin DNE text -->
"The DNS tags all data with a class as well as the type, so that we can allow parallel use
of different formats for data of type address."  (Quoted from <xref target="RFC1034"/>, Section 2.2)
<!--End DNE text -->
In practice, the class for nearly every query is "IN" (the Internet).

There are some queries for "CH" (the Chaos class), but they are usually for the purposes of
information about the server itself rather than for a different type of address.



</t>

<t hangText='QNAME:'>
<iref item='QNAME'/>
The most commonly used rough definition is that the QNAME is a field in the Question section of a
query.  
<!--Begin DNE -->
"A standard query specifies a target domain name (QNAME), query type (QTYPE), and query
class (QCLASS) and asks for RRs which match."  (Quoted from <xref target="RFC1034"/>, Section
3.7.1)
<!--END DNE -->
Strictly speaking, the definition comes from <xref target="RFC1035"/>,
Section 4.1.2, where the QNAME is defined in respect of the Question
section.  This definition appears to be applied consistently: the
discussion of inverse queries in Section 6.4.1 refers to the "owner name
of the query RR and its TTL", because inverse queries populate the
Answer section and leave the Question section empty.  (Inverse queries
are deprecated in <xref target="RFC3425"/>; thus, relevant
definitions do not appear in this document.)
</t>

<t>
However, <xref target="RFC2308"/> has an alternate definition that
puts the QNAME in the answer (or series of answers) instead of the
query. It defines QNAME as

  <!--Begin DNE -->
"...the name in the query section of an
answer, or where this resolves to a CNAME, or CNAME chain, the data
field of the last CNAME.  The last CNAME in this sense is that which
contains a value which does not resolve to another CNAME."
<!--END DNE -->
This definition has a certain internal logic, because of the way CNAME
substitution works and the definition of CNAME.  If a name server does
not find an RRset that matches a query, but does find the same name in
the same class with a CNAME record, then the name server "includes the
CNAME record in the response and restarts the query at the domain name
specified in the data field of the CNAME record." (Quoted from <xref
target="RFC1034"/>, Section 3.6.2)  This is made explicit in the
resolution algorithm outlined in Section 4.3.2 of <xref
target="RFC1034"/>, which says to "change QNAME to the canonical name
in the CNAME RR, and go back to step 1" in the case of a CNAME RR.
Since a CNAME record explicitly declares that the owner name is
canonically named what is in the RDATA, then there is a way to view
the new name (i.e., the name that was in the RDATA of the CNAME RR) as
also being the QNAME.
</t>

<t>
However, this creates a kind of confusion because the response to a
query that results in CNAME processing contains in the echoed Question
section one QNAME (the name in the original query) and a second QNAME
that is in the data field of the last CNAME.  The confusion comes from
the iterative/recursive mode of resolution, which finally returns an
answer that need not actually have the same owner name as the QNAME
contained in the original query.
</t>

<t>
To address this potential confusion, it is helpful to distinguish
between three meanings:

<list style="symbols">
<t>
QNAME (original): The name actually sent in the Question section in the original query, which is
always echoed in the (final) reply in the Question section when the QR bit is set to 1.
</t>
<t>
QNAME (effective): A name actually resolved, which is either the name originally queried
or a name received in a CNAME chain response.
</t>
<t>
QNAME (final): The name actually resolved, which is either the name actually queried or else
the last name in a CNAME chain response.
</t>
</list></t>

<t>Note that, because the definition in <xref target="RFC2308"/> is
actually for a different concept than what was in <xref
target="RFC1034"/>, it would have been better if <xref
target="RFC2308"/> had used a different name for that concept. In
general use today, QNAME almost always means what is defined above as
"QNAME (original)".</t>

<t hangText='Referrals:'>
<iref item='Referrals'/>
A type of response in which a server, signaling that it is not
(completely) authoritative for an answer, provides the querying
resolver with an alternative place to send its query.  Referrals can
be partial.</t>

<t>A referral arises when a server is not performing recursive service
while answering a query.  It appears in step 3(b) of the algorithm in
<xref target="RFC1034" />, Section 4.3.2.</t>

<t>There are two types of referral response.  The first is a downward
referral (sometimes described as "delegation response"), where the
server is authoritative for some portion of the QNAME.  The authority
section RRset's RDATA contains the name servers specified at the
referred-to zone cut.  In normal DNS operation, this kind of response
is required in order to find names beneath a delegation.  The bare
use of "referral" means this kind of referral, and many people believe
that this is the only legitimate kind of referral in the DNS.</t>

<t>The second is an upward referral (sometimes described as "root
referral"), where the server is not authoritative for any portion of
the QNAME.  When this happens, the referred-to zone in the authority
section is usually the root zone (".").  In normal DNS operation, this
kind of response is not required for resolution or for correctly
answering any query.  There is no requirement that any server send
upward referrals.  Some people regard upward referrals as a sign of a
misconfiguration or error.  Upward referrals always need some sort of
qualifier (such as "upward" or "root") and are never identified simply by
the word "referral".</t>

<t>A response that has only a referral contains an empty answer
section.  It contains the NS RRset for the referred-to zone in the
Authority section.  It may contain RRs that provide addresses in the
additional section.  The AA bit is clear.</t>

<t>In the case where the query matches an alias, and the server is not
authoritative for the target of the alias but is authoritative for
some name above the target of the alias, the resolution algorithm will
produce a response that contains both the authoritative answer for the
alias and a referral.  Such a partial answer and referral
response has data in the Answer section.  It has the NS RRset for the
referred-to zone in the Authority section.  It may contain RRs that
provide addresses in the additional section.  The AA bit is set,
because the first name in the Answer section matches the QNAME and the
server is authoritative for that answer (see <xref target="RFC1035"/>,
Section 4.1.1).</t>

</list></t>
</section>

<section anchor="rrs" title="Resource Records">
<t><list style="hanging">

<t hangText='RR:'>
<iref item='RR'/>
An acronym for resource record.  (See <xref target="RFC1034"/>, Section 3.6.)</t>


<t hangText='RRset:'>
<iref item='RRset'/>
A set of resource records "with the same label, class and type, but with different
data" (according to <xref target="RFC2181"/>, Section 5).  Also written as "RRSet" in some documents. As a clarification,
"same label" in this definition means "same owner name".
In addition, <xref target="RFC2181"/> states that "the TTLs of all RRs in an RRSet must be the same".
</t>

<t>Note that RRSIG resource records do not match this definition.
<xref target="RFC4035"/> says:
<list style="empty"><t>
  <!--Begin DNE -->
An RRset MAY have multiple RRSIG RRs associated with it. Note that
as RRSIG RRs are closely tied to the RRsets whose signatures they
contain, RRSIG RRs, unlike all other DNS RR types, do not form
RRsets. In particular, the TTL values among RRSIG RRs with a common
owner name do not follow the RRset rules described in <xref target="RFC2181"/>.</t></list>
<!--End DNE -->
</t>

<t hangText='Master file:'>
<iref item='Master file'/>

  <!--Begin DNE -->
"Master files are text files that contain RRs in text form.  Since the contents of a zone
can be expressed in the form of a list of RRs a master file is most often used to define a
zone, though it can be used to list a cache's contents."  (Quoted from <xref target="RFC1035"/>,
Section 5)

<!--End DNE -->
Master files are sometimes called "zone files".</t>

<t hangText='Presentation format:'>
<iref item='Presentation format'/>
The text format used in master files. This format is shown but not formally defined in
<xref target="RFC1034"/> or <xref target="RFC1035"/>. The term "presentation format"
first appears in <xref target="RFC4034"/>.</t>

<t hangText='EDNS:'>
<iref item='EDNS'/>
The extension mechanisms for DNS, defined in <xref
target="RFC6891"/>. Sometimes called "EDNS0" or "EDNS(0)"
to indicate the version number. EDNS allows DNS clients and servers to specify message
sizes larger than the original 512 octet limit, to expand the response code space and
to carry additional options that affect the handling of a DNS query.</t>

<t hangText='OPT:'>
<iref item='OPT'/>
A pseudo-RR (sometimes called a "meta-RR") that is used only to contain
control information pertaining to the question-and-answer sequence of a specific
transaction. (Definition paraphrased from <xref target="RFC6891"/>, Section 6.1.1.)
It is used by EDNS.</t>

<t hangText='Owner:'>
<iref item='Owner'/>
"The domain name where the RR is found."  (Quoted from <xref target="RFC1034"/>, Section 3.6)  Often appears in the term "owner name".</t>

<t hangText='SOA field names:'>
<iref item='SOA field names'/>
<iref item='SOA'/>
DNS documents, including the definitions here, often refer to the fields in the
RDATA of an SOA resource record by field name.
"SOA" stands for "start of a zone of authority".
Those fields are defined in Section 3.3.13 of <xref target="RFC1035"/>.
The names (in the order they appear in the SOA RDATA) are MNAME, RNAME, SERIAL, REFRESH, RETRY,
EXPIRE, and MINIMUM.
Note that the meaning of the MINIMUM field is updated in Section 4 of <xref target="RFC2308"/>; the new definition
is that the MINIMUM field is only "the TTL to be used for negative responses".
This document tends to use field names instead of terms that describe the fields.</t>

<t hangText='TTL:'>
<iref item='TTL'/>
The maximum "time to live" of a resource record.


  <!--Begin DNE -->
  "A TTL value is an unsigned
number, with a minimum value of 0, and a maximum value of 2147483647. That is, a
maximum of 2^31 - 1. When transmitted, this value shall be encoded in the less
significant 31 bits of the 32 bit TTL field, with the most significant, or sign,
bit set to zero."  (Quoted from <xref target="RFC2181"/>, Section 8)
<!--End DNE -->
(Note that <xref target="RFC1035"/>
erroneously stated that this is a signed integer; that was fixed by <xref target="RFC2181"/>.)</t>

<t>The TTL "specifies the time interval that the resource record may be cached
before the source of the information should again be consulted." (Quoted from
<xref target="RFC1035"/>, Section 3.2.1)  Section 4.1.3 of the same document states: "the time interval (in seconds) that the resource
record may be cached before it should be discarded".  Despite being defined for a resource record, the TTL of every
resource record in an RRset is required to be the same (<xref target="RFC2181"/>, Section 5.2).</t>

<t>The reason that the TTL is the maximum time to live is that a cache operator
might decide to shorten the time to live for operational purposes, such as if
there is a policy to disallow TTL values over a certain number.
Some servers are known to ignore the TTL on some RRsets (such as when the authoritative data
has a very short TTL) even though this is against the advice in RFC 1035.
An RRset can be flushed from the cache before the end of the TTL interval,
at which point, the value of the TTL becomes unknown because the RRset
with which it was associated no longer exists.</t>

<t>There is also the concept of a "default TTL" for a zone, which can be a configuration
parameter in the server software. This is often expressed by a default for the
entire server, and a default for a zone using the $TTL directive
in a zone file.  The $TTL directive was added to the master file
format by <xref target="RFC2308"/>.</t>


<t hangText='Class independent:'>
<iref item='Class independent'/>
A resource record type whose syntax and semantics are the same for every DNS
class. A resource record type that is not class independent has different meanings depending on the
DNS class of the record, or the meaning is undefined for some class.
Most resource record types are defined for class 1 (IN, the Internet),
but many are undefined for other classes.</t>

<t hangText='Address records:'>
<iref item='Address records'/>
Records whose type is A or AAAA. 
<xref target="RFC2181"/> informally defines these as "(A, AAAA, etc)".
Note that new types of address records could be defined in the future.</t>

</list></t>
</section>

<section anchor="dns-servers-and-clients" title="DNS Servers and Clients">

<t>This section defines the terms used for the systems that act as DNS
clients, DNS servers, or both.  In past RFCs, DNS servers are
sometimes called "name servers", "nameservers", or just
"servers". There is no formal definition of "DNS server", but RFCs
generally assume that it is an Internet server that listens for
queries and sends responses using the DNS protocol defined in <xref
target="RFC1035"/> and its successors.</t>

<t>It is important to note that the terms "DNS server" and "name
server" require context in order to understand the services being
provided. Both authoritative servers and recursive resolvers are often
called "DNS servers" and "name servers" even though they serve
different roles (but may be part of the same software package).</t>

<t>For terminology specific to the public DNS root server system, see
<xref target="RSSAC026"/>.  That document defines terms such as "root
server", "root server operator", and terms that are specific to the
way that the root zone of the public DNS is served.</t>

<t><list style="hanging">

<t hangText='Resolver:'>
<iref item='Resolver'/>
A program "that extract[s] information from name
servers in response to client requests."  (Quoted from <xref target="RFC1034"/>, Section 2.4)  A resolver performs
queries for a name, type, and class, and receives responses.  The
logical function is called "resolution".  In practice, the term is
usually referring to some specific type of resolver
(some of which are defined below), and understanding
the use of the term depends on understanding the context.</t>

<t>A related term is "resolve", which is not formally defined in <xref target="RFC1034"/>
or <xref target="RFC1035"/>. An imputed definition might be "asking a question that
consists of a domain name, class, and type, and receiving some sort of response".
Similarly, an imputed definition of "resolution" might be "the response received
from resolving".</t>

<t hangText='Stub resolver:'>
<iref item='Stub resolver'/>
A resolver that cannot perform all resolution
itself. Stub resolvers generally depend on a recursive resolver to undertake the
actual resolution function.  Stub resolvers are discussed but never
fully defined in Section 5.3.1 of <xref target="RFC1034"/>.
They are fully defined in Section 6.1.3.1 of <xref target="RFC1123"/>.</t>

<t hangText='Iterative mode:'>
<iref item='Iterative mode'/>
A resolution mode of a server that receives DNS
queries and responds with a referral to another server.  Section 2.3 of <xref target="RFC1034"/>
describes this as "The server refers the client to
another server and lets the client pursue the query."
A resolver that works in iterative mode is sometimes called an "iterative
resolver".
See also "iterative resolution" later in this section.</t>

<t hangText='Recursive mode:'>
<iref item='Recursive mode'/>
A resolution mode of a server that receives DNS
queries and either responds to those queries from a local cache or
sends queries to other servers in order to get the final answers to
the original queries. Section 2.3 of <xref target="RFC1034"/> describes this as "the
first server pursues the query for the client at another server".
Section 4.3.1 of <xref target="RFC1034"/> says: "in [recursive]
mode the name server acts in the role of a resolver and
returns either an error or the answer, but never referrals."
That same section also says:
<list style="empty">
<!--Begin DNE -->
  <t>The recursive mode occurs when a query with RD set arrives at a server
which is willing to provide recursive service; the client can verify that recursive mode was used by
checking that both RA and RD are set in the reply.</t></list></t>
<!--End DNE -->

<t>A server operating in recursive mode may be thought of as having a name
server side (which is what answers the query) and a resolver side
(which performs the resolution function).  Systems operating
in this mode are commonly called "recursive servers".  Sometimes they
are called "recursive resolvers".  In practice, it is not possible to know
in advance whether the server that one is querying will also perform
recursion; both terms can be observed in use interchangeably.</t>

<t hangText='Recursive resolver:'>
<iref item='Recursive resolver'/>
A resolver that acts in recursive mode.
In general, a recursive resolver is expected to cache the answers it receives
(which would make it a full-service resolver), but some recursive resolvers might not cache.</t>

<t><xref target="RFC4697"/> tried to differentiate between a
recursive resolver and an iterative resolver.</t>

<t hangText='Recursive query:'>
<iref item='Recursive query'/>
A query with the Recursion Desired (RD) bit set to 1 in the header. (See Section 4.1.1 of <xref
target="RFC1035"/>.) If recursive service is available and is requested by the RD bit in the query,
the server uses its resolver to answer the query. (See Section 4.3.2 of <xref target="RFC1034"/>.)</t>


<t hangText='Non-recursive query:'>
<iref item='Non-recursive query'/>
A query with the Recursion Desired (RD) bit set to 0 in the header. A server can answer
non-recursive queries using only local information: the response contains either an error, the
answer, or a referral to some other server "closer" to the answer.
(See Section 4.3.1 of <xref target="RFC1034"/>.)</t>

<t hangText='Iterative resolution:'>
<iref item='Iterative resolution'/>
A name server may be presented with a query that can only be answered by some other server. The two
general approaches to dealing with this problem are "recursive", in which the first server pursues
the query on behalf of the client at another server, and "iterative", in which the server refers the client
to another server and lets the client pursue the query there. (See Section 2.3 of <xref
target="RFC1034"/>.)</t>

<t>In iterative resolution, the client repeatedly makes non-recursive queries and follows referrals
and/or aliases. The iterative resolution algorithm is described in Section 5.3.3 of <xref
target="RFC1034"/>.</t>



<t hangText='Full resolver:'>
<iref item='Full resolver'/>
This term is used in <xref target="RFC1035"/>, but it is not defined there. RFC
1123 defines a "full-service resolver" that may or may not be what was intended
by "full resolver" in <xref target="RFC1035"/>.
This term is not properly defined in any RFC.</t>

<t hangText='Full-service resolver:'>
<iref item='Full-service resolver'/>
Section 6.1.3.1 of <xref target="RFC1123"/> defines this term
to mean a resolver that acts in recursive mode with a cache (and meets
other requirements).</t>

<t hangText='Priming:'>
<iref item='Priming'/>
"The act of finding the list of root servers from a
configuration that lists some or all of the purported IP addresses of
some or all of those root servers." (Quoted from <xref target="RFC8109"/>, Section 2)
In order to operate in recursive mode, a resolver needs to know the address of at least one root server.
Priming is most often done from a configuration setting that contains a
list of authoritative servers for the root zone.</t>

<t hangText='Root hints:'>
<iref item='Root hints'/>"Operators who manage a DNS recursive resolver typically need to configure
a 'root hints file'.
This file contains the names and IP addresses of the authoritative name servers
for the root zone, so the software can bootstrap the DNS resolution process. 
For many pieces of software, this list comes built into the software."  (Quoted from <xref target="IANA_RootFiles"/>)
This file is often used in priming.</t>

<t hangText='Negative caching:'>
<iref item='Negative caching'/>
"The storage of knowledge that something does not exist, cannot
or does not give an answer." (Quoted from <xref target="RFC2308"/>, Section 1)</t>

<t hangText='Authoritative server:'>
<iref item='Authoritative server'/>
<iref item='NS'/>
"A server that knows the content of a DNS zone from local knowledge, and thus can answer
queries about that zone without needing to query other servers." (Quoted from <xref target="RFC2182"/>, Section 2)
An authoritative server is named in the NS ("name server") record in a zone.

It is a system that responds to DNS queries with information about
zones for which it has been configured to answer with the AA flag in
the response header set to 1. It is a server that has authority over
one or more DNS zones.  Note that it is possible for an authoritative
server to respond to a query without the parent zone delegating
authority to that server. Authoritative servers also provide
"referrals", usually to child zones delegated from them; these
referrals have the AA bit set to 0 and come with referral data in the
Authority and (if needed) the Additional sections.</t>

<t hangText='Authoritative-only server:'>
<iref item='Authoritative-only server'/>
A name server that only serves authoritative data and ignores requests for recursion.
It will "not normally generate any queries of its own.  Instead it answers non-recursive
queries from iterative resolvers looking for information in zones it serves."  (Quoted from <xref target="RFC4697"/>, Section 2.4) 
In this case, "ignores requests for recursion" means "responds to requests for
recursion with responses indicating that recursion was not performed".</t>

<t hangText='Zone transfer:'>
<iref item='Zone transfer'/>
The act of a client requesting a copy of a zone and an authoritative server
sending the needed information.
(See <xref target="zones"/> for a description of zones.)
There are two common standard ways to do zone transfers:
the AXFR ("Authoritative Transfer") mechanism to copy the full zone (described in <xref target="RFC5936"/>, and 
the IXFR ("Incremental Transfer") mechanism to copy only parts of the zone that have changed (described in <xref target="RFC1995"/>).
Many systems use non-standard methods for zone transfer outside the DNS protocol.</t>

<t hangText='Slave server:'>
<iref item='Slave server'/>
See "Secondary server".</t>

<t hangText='Secondary server:'>
<iref item='Secondary server'/>
"An authoritative server which uses zone transfer to retrieve the
zone." (Quoted from <xref target="RFC1996"/>, Section 2.1)
Secondary servers are also discussed in <xref target="RFC1034"/>.
<xref target="RFC2182"/> describes secondary servers in
more detail.  Although early DNS RFCs such as <xref target="RFC1996"/> referred to this as a "slave", the
current common usage has shifted to calling it a "secondary".
</t>

<t hangText='Master server:'>
<iref item='Master server'/>
See "Primary server".</t>

<t hangText='Primary server:'>
<iref item='Primary server'/>
"Any authoritative server configured to be the source of zone transfer
for one or more [secondary] servers." (Quoted from <xref target="RFC1996"/>, Section 2.1)  Or, more
specifically, <xref target="RFC2136"/> calls it "an authoritative server configured to be the source of AXFR or IXFR data
for one or more [secondary] servers".
Primary servers are also discussed in <xref target="RFC1034"/>.
Although early DNS RFCs such as <xref target="RFC1996"/> referred to this as a "master", the current
common usage has shifted to "primary".</t>

<t hangText='Primary master:'>
<iref item='Primary master'/>
"The primary master is named in the zone's SOA MNAME field and
optionally by an NS RR." (Quoted from <xref target="RFC1996"/>, Section 2.1)
<xref target="RFC2136"/> defines "primary master" as
"Master server at the root of the AXFR/IXFR dependency graph. 
The primary master is named in the zone's SOA MNAME field and optionally by an NS RR.  There is by
definition only one primary master server per zone."
</t>

<t>The idea of a primary master is only used in <xref target="RFC1996"/> and <xref target="RFC2136"/>.
A modern interpretation of the term "primary master" is a server that is both authoritative for a zone
and that gets its updates to the zone from configuration (such as a master file) or from UPDATE transactions.</t>

<t hangText='Stealth server:'>
<iref item='Stealth server'/>
This is "like a slave server except not listed in an NS RR for
the zone." (Quoted from <xref target="RFC1996"/>, Section 2.1)</t>

<t hangText='Hidden master:'>
<iref item='Hidden master'/>
A stealth server that is a primary server for zone transfers. "In this arrangement, the
master name server that processes the updates is unavailable to general hosts on the
Internet; it is not listed in the NS RRset."  (Quoted from
<xref target="RFC6781"/>, Section 3.4.3)  An earlier RFC, <xref target="RFC4641"/>, said
that the hidden master's name "appears in the SOA RRs MNAME field", although, in some
setups, the name does not appear at all in the public DNS.  A hidden master can also be a
secondary server for the zone itself.</t>

<t hangText='Forwarding:'>
<iref item='Forwarding'/>
The process of one server sending a DNS query with the
RD bit set to 1 to another server to resolve that query. Forwarding is
a function of a DNS resolver; it is different than simply blindly
relaying queries.</t>
<t><xref target="RFC5625"/> does not give a specific definition for forwarding, but
describes in detail what features a system that forwards needs to
support. Systems that forward are sometimes called "DNS proxies", but
that term has not yet been defined (even in <xref target="RFC5625"/>).</t>

<t hangText='Forwarder:'>
<iref item='Forwarder'/>
Section 1 of <xref target="RFC2308"/> describes a forwarder as "a
nameserver used to resolve queries instead of directly using the
authoritative nameserver chain".  <xref target="RFC2308"/> further says "The
forwarder typically either has better access to the internet, or
maintains a bigger cache which may be shared amongst many resolvers."
That definition appears to suggest that forwarders
normally only query authoritative servers.  In current use, however,
forwarders often stand between stub resolvers and recursive servers.
<xref target="RFC2308"/> is silent on whether a forwarder is iterative-only or
can be a full-service resolver.</t>

<t hangText='Policy-implementing resolver:'>
<iref item='Policy-implementing resolver'/>
A resolver acting in recursive mode that changes some of the answers
that it returns based on policy criteria, such as to prevent access to
malware sites or objectionable content. In general, a stub resolver has no idea
whether upstream resolvers implement such policy or, if they do, the exact
policy about what changes will be made.
In some cases, the user of the stub resolver has selected the policy-implementing resolver
with the explicit intention of using it to implement the policies.  In other cases,
policies are imposed without the user of the stub resolver being informed.</t>

<t hangText='Open resolver:'>
<iref item='Open resolver'/>
A full-service resolver that accepts and processes queries from any (or nearly any) client.
This is sometimes also called a "public resolver", although the term "public resolver"
is used more with open resolvers that are meant to be open, as compared to the vast majority of open
resolvers that are probably misconfigured to be open.
Open resolvers are discussed in <xref target="RFC5358"/>.</t>

<t hangText='Split DNS:'>
<iref item='Split DNS'/>
<iref item='Split-horizon DNS'/>
The terms "split DNS" and "split-horizon DNS" have long been used in the DNS community without
formal definition. In general, they refer to situations in which
DNS servers that are authoritative for a particular set of domains
provide partly or completely different answers in those domains depending
on the source of the query. The effect of this is that a domain name that
is notionally globally unique nevertheless has different meanings for
different network users. This can sometimes be the result of a "view"
configuration, described below.</t>

<t>Section 3.8 of <xref target="RFC2775"/> gives a related definition that is too specific to be generally useful.</t>

<t hangText='View:'>
<iref item='View'/>
A configuration for a DNS server that allows it to provide
different responses depending on attributes of the query, such as for "split DNS". Typically, views differ
by the source IP address of a query, but can also be based on the destination IP address,
the type of query (such as AXFR), whether it is recursive, and so on.
Views are often used to
provide more names or different addresses to queries from "inside" a protected network
than to those "outside" that network.  Views are not a standardized
part of the DNS, but they are widely implemented in server software.</t>

<t hangText='Passive DNS:'>
<iref item='Passive DNS'/>
A mechanism to collect DNS data by storing DNS responses from name servers. Some of these systems
also collect the DNS queries associated with the responses, although doing so raises some privacy
concerns. Passive DNS databases can be used to answer historical questions about DNS zones such as
which values were present at a given time in the past, or when a name was spotted first.  
Passive DNS databases allow searching of the stored records on keys other than
just the name and type, such as "find all names which have A records of a
particular value".</t>

<t hangText='Anycast:'>
<iref item='Anycast'/>
"The practice of making a particular service address available in multiple, discrete, autonomous
locations, such that datagrams sent are routed to one of several available locations."
(Quoted from <xref target="RFC4786"/>, Section 2)
See <xref target="RFC4786"/> for more detail on Anycast and other terms that are
specific to its use.</t>

<t hangText='Instance:'>
<iref item='Instance'/>
"When anycast routing is used to allow more than one server to have the same IP
address, each one of those servers is commonly referred to as an 'instance'."
It goes on to say: "An instance of a server, such as a root server, is often referred to as an 'Anycast
instance'."  (Quoted from <xref target="RSSAC026" />)</t> 

<t hangText='Privacy-enabling DNS server:'>
<iref item='Privacy-enabling DNS server'/>
"A DNS server that implements
DNS over TLS <xref target="RFC7858"/> and may optionally implement DNS over DTLS
<xref target="RFC8094"/>."  (Quoted from <xref target="RFC8310"/>, Section 2)
Other types of DNS servers might also be considered privacy-enabling, such as those
running DNS over HTTPS <xref target="RFC8484" />.</t>

</list></t>
</section>

<section anchor="zones" title="Zones">

<t>This section defines terms that are used when discussing zones that are being served or retrieved.</t>

<t><list style="hanging">

<t hangText='Zone:'>
<iref item='Zone'/>
"Authoritative information is
organized into units called ZONEs, and these zones can be
automatically distributed to the name servers which provide
redundant service for the data in a zone."  (Quoted from <xref target="RFC1034"/>, Section 2.4)</t> 

<t hangText='Child:'>
<iref item='Child'/>
"The entity on record that has the delegation of the domain from the
Parent." (Quoted from <xref target="RFC7344"/>, Section 1.1)</t>

<t hangText='Parent:'>
<iref item='Parent'/>
"The domain in which the Child is registered."  (Quoted from <xref target="RFC7344"/>, Section 1.1)  Earlier,
"parent name server" was defined in <xref target="RFC0882"/> as "the name server that has authority over the place
in the domain name space that will hold the new domain".  (Note
that <xref target="RFC0882"/> was obsoleted by <xref target="RFC1034"/> and <xref target="RFC1035"/>.) <xref target="RFC0819"/> also has some description of
the relationship between parents and children.</t>

<t hangText='Origin:'>
<iref item='Origin'/>
</t>
<t>There are two different uses for this term:<list style="format (%c)">
<t>"The domain name that
appears at the top of a zone (just below the cut that separates the
zone from its parent)... The name of the zone is the same as the name
of the domain at the zone's origin."  (Quoted from <xref target="RFC2181"/>, Section 6)  These days, this sense of
"origin" and "apex" (defined below) are often used
interchangeably.</t>
<t>The domain name within which a given relative domain name
appears in zone files.  Generally seen in the context of "$ORIGIN", which is a
control entry defined in <xref target="RFC1035"/>, Section 5.1, as part of the master
file format.  For example, if the $ORIGIN is set to "example.org.",
then a master file line for "www" is in fact an entry for
"www.example.org.".</t></list></t>

<t hangText='Apex:'>
<iref item='Apex'/>
The point in the tree at an owner of an SOA and corresponding authoritative NS RRset.
This is also called the "zone apex".
<xref target="RFC4033"/> defines it as "the name at the child's side of a zone cut".
The "apex" can usefully be thought of as a data-theoretic description of a tree structure,
and "origin" is the name of the same concept when it is implemented in
zone files.  The distinction is not always maintained in use, however,
and one can find uses that conflict subtly with this definition.
<xref target="RFC1034"/> uses the term "top node of the zone" as a synonym of "apex", but that term is not widely used.
These days, the first sense of "origin" (above) and "apex" are often used interchangeably.</t>

<t hangText='Zone cut:'>
<iref item='Zone cut'/>
The delimitation point between two zones where the origin
of one of the zones is the child of the other zone.</t>
<t>"Zones are delimited by 'zone cuts'.  Each zone cut separates a
'child' zone (below the cut) from a 'parent' zone (above the cut)."  (Quoted from <xref target="RFC2181"/>, Section 6; note that this is barely an ostensive
definition.)

Section 4.2 of <xref target="RFC1034"/> uses "cuts" instead of "zone cut".</t>

<t hangText='Delegation:'>
<iref item='Delegation'/>
The process by which a separate zone is created in the
name space beneath the apex of a given domain.  Delegation happens when an NS
RRset is added in the parent zone for the child origin. Delegation
inherently happens at a zone cut.
The term is also commonly a noun: the new zone that is created by the act of delegating.</t>

<t hangText='Authoritative data:'>
<iref item='Authoritative data'/>
"All of the RRs attached to all of the nodes from the top node of the zone
down to leaf nodes or nodes above cuts around the bottom edge of the zone." (Quoted from
<xref target="RFC1034"/>, Section 4.2.1)
Note that this definition might inadvertently also cause any NS records
that appear in the zone to be included, even those that might not truly be authoritative because there are
identical NS RRs below the zone cut.  This reveals the ambiguity in
the notion of authoritative data, because the parent-side NS records
authoritatively indicate the delegation, even though they are not
themselves authoritative data.</t>

<t><xref target="RFC4033"/>, Section 2, defines "Authoritative RRset", which is related
to authoritative data but has a more precise definition.</t>

<t hangText='Lame delegation:'>
<iref item='Lame delegation'/>

  <!--Begin DNE -->
"A lame delegations exists [sic] when a nameserver is delegated responsibility for providing nameservice
for a zone (via NS records) but is not performing nameservice for that zone (usually because it is
not set up as a primary or secondary for the zone)." (Quoted from <xref target="RFC1912"/>, Section 2.8)
<!--End DNE -->
Another definition is that a lame delegation
<!--Begin DNE -->
  "...happens when a name server is listed in the NS records for some domain and in fact it is not a
server for that domain. Queries are thus sent to the wrong servers, who don't know nothing [sic] (at least
not as expected) about the queried domain. Furthermore, sometimes these hosts (if they exist!) don't
even run name servers."  (Quoted from <xref target="RFC1713"/>, Section 2.3)</t>
<!--End DNE -->
<t hangText='Glue records:'>
<iref item='Glue records'/>

  <!--begin DNE -->
"...[Resource records] which are not part of the authoritative data [of the zone],
and are address RRs for the [name] servers [in subzones].  These RRs are only
necessary if the name server's name is 'below' the cut, and are only used as part of a
referral response." Without glue "we could be faced with the situation where the NS RRs
tell us that in order to learn a name server's address, we should contact the server using
the address we wish to learn."  (Quoted from <xref target="RFC1034"/>, Section 4.2.1)</t>
<!--End DNE -->

<t>A later definition is that glue
  <!--Begin DNE -->
  "includes any record in a zone file that is not properly
part of that zone, including nameserver records of delegated sub-zones (NS records),
address records that accompany those NS records (A, AAAA, etc), and any other stray data
that might appear."  (Quoted from <xref target="RFC2181"/>, Section 5.4.1)
<!--End DNE -->
Although glue is sometimes used today
with this wider definition in mind, the context surrounding the definition in <xref target="RFC2181"/> 
suggests it is intended to apply to the use of glue within the document itself and not
necessarily beyond.</t>

<t hangText='Bailiwick:'>
<iref item='In-bailiwick'/>
<iref item='Out-of-bailiwick'/>
"In-bailiwick" is a modifier to describe a name server whose name
is either a subdomain of or (rarely) the same as the origin
of the zone that contains the delegation to the name server.
In-bailiwick name servers may have glue records in their parent
zone (using the first of the definitions of "glue records" in the definition above).
(The word "bailiwick" means the district or territory where a bailiff or
policeman has jurisdiction.)

</t>

<t>"In-bailiwick" names are divided into two types of names for name servers:
"in-domain" names and "sibling domain" names.

<list style="symbols">

<t>In-domain: a modifier to describe a name server whose name is either
subordinate to or (rarely) the same as the owner name of the NS resource records.
An in-domain name server name needs to have glue records or name resolution fails.

For example, a delegation for "child.example.com" may have "in-domain" name
server name "ns.child.example.com".
</t>

<t>Sibling domain: a name server's name that is either subordinate to or
(rarely) the same as the zone origin and not subordinate to or the same as the
owner name of the NS resource records.
Glue records for sibling domains are allowed, but not necessary.
For example, a delegation for "child.example.com" in "example.com" zone may have
"sibling" name server name "ns.another.example.com".
</t>

</list></t>

<t>"Out-of-bailiwick" is the antonym of "in-bailiwick".
It is a modifier to describe a name server whose name
is not subordinate to or the same as the zone origin.
Glue records for out-of-bailiwick name servers are useless.

The following table shows examples of delegation types.

<figure><artwork><![CDATA[
Delegation |Parent|Name Server Name  | Type
-----------+------+------------------+-----------------------------
com        | .    |a.gtld-servers.net|in-bailiwick / sibling domain
net        | .    |a.gtld-servers.net|in-bailiwick / in-domain
example.org| org  |ns.example.org    |in-bailiwick / in-domain
example.org| org  |ns.ietf.org       |in-bailiwick / sibling domain
example.org| org  |ns.example.com    |out-of-bailiwick
example.jp | jp   |ns.example.jp     |in-bailiwick / in-domain
example.jp | jp   |ns.example.ne.jp  |in-bailiwick / sibling domain
example.jp | jp   |ns.example.com    |out-of-bailiwick
]]></artwork></figure>
</t>

<t hangText='Root zone:'>
<iref item='Root zone'/>
The zone of a DNS-based tree whose apex is the zero-length label.
Also sometimes called "the DNS root".</t>

<t hangText='Empty non-terminals (ENT):'>
<iref item='Empty non-terminals (ENT)'/>
"Domain names that own no resource records but have subdomains that do."
(Quoted from <xref target="RFC4592"/>, Section 2.2.2)
A typical example is in SRV records: in the name
"_sip._tcp.example.com", it is likely that "_tcp.example.com" has no RRsets, but
that "_sip._tcp.example.com" has (at least) an SRV RRset.</t>

<t hangText='Delegation-centric zone:'>
<iref item='Delegation-centric zone'/>
A zone that consists mostly of delegations to child zones. This term is
used in contrast to a zone that might have some delegations to child zones but also has many data
resource records for the zone itself and/or for child zones.
The term is used in <xref target="RFC4956"/> and <xref target="RFC5155"/>, but it is not defined in either document.</t>

<t hangText='Occluded name:'>
<iref item='Occluded name'/>

  <!--begin DNE -->
"The addition of a delegation point via dynamic update will render all subordinate
domain names to be in a limbo, still part of the zone but not available to the lookup process.  The
addition of a DNAME resource record has the same impact.  The subordinate names are said to be
'occluded'."  (Quoted from <xref target="RFC5936"/>, Section 3.5)</t>

<t hangText='Fast flux DNS:'>
<iref item='Fast flux DNS'/>

This "occurs when a domain is [found] in DNS using A records to multiple IP addresses,
each of which has a very short Time-to-Live (TTL) value associated with it.  This means
that the domain resolves to varying IP addresses over a short period of time."
(Quoted from <xref target="RFC6561"/>, Section 1.1.5, with a typo corrected)
In addition to having legitimate uses, fast flux DNS can used to deliver malware.
Because the addresses change so rapidly, it is difficult to
ascertain all the hosts.  It should be noted that the technique also works
with AAAA records, but such use is not frequently observed on the
Internet as of this writing.</t>


<t hangText='Reverse DNS, reverse lookup:'>
<iref item='Reverse DNS, reverse lookup'/>
"The process of mapping an address to a name is
generally known as a 'reverse lookup', and the IN-ADDR.ARPA and
IP6.ARPA zones are said to support the 'reverse DNS'."
(Quoted from <xref target="RFC5855"/>, Section 1)
</t>

<t hangText='Forward lookup:'>
<iref item='Forward lookup'/>
"Hostname-to-address translation". (Quoted from 
<xref target="RFC3493" />, Section 6)

</t>

<t hangText='arpa: Address and Routing Parameter Area Domain:'>
<iref item='arpa: Address and Routing Parameter Area Domain'/>
"The 'arpa' domain was originally established as part of the initial
deployment of the DNS, to provide a transition mechanism from the
Host Tables that were common in the ARPANET, as well as a home for
the IPv4 reverse mapping domain.  During 2000, the abbreviation was
redesignated to 'Address and Routing Parameter Area' in the hope of
reducing confusion with the earlier network name."
(Quoted from <xref target="RFC3172"/>, Section 2)
.arpa is an "infrastructure domain",
a domain whose "role is to
support the operating infrastructure of the Internet".
(Quoted from <xref target="RFC3172"/>, Section 2)
See <xref target="RFC3172"/> for more history of this name.
</t>

<t hangText='Service name:'>
<iref item='Service name'/>
"Service names are the unique key in the Service Name and Transport
Protocol Port Number registry.  This unique symbolic name for a
service may also be used for other purposes, such as in DNS SRV
records." (Quoted from <xref target="RFC6335"/>, Section 5)
</t>

</list></t>
</section>

<section anchor="wildcards" title="Wildcards">
<t><list style="hanging">

<t hangText='Wildcard:'>
<iref item='Wildcard'/>
<xref target="RFC1034"/> defined "wildcard", but in a way that turned out to be
confusing to implementers.
For an extended discussion of wildcards, including clearer definitions, see <xref target="RFC4592"/>.
Special treatment is given to RRs with owner names starting with the label "*".  "Such RRs
are called 'wildcards'. Wildcard RRs can be thought of as instructions for synthesizing RRs."
(Quoted from <xref target="RFC1034"/>, Section 4.3.3)
</t>

<t hangText='Asterisk label:'>
<iref item='Asterisk label'/>
"The first octet is the normal label type and length for a 1-octet-long
label, and the second octet is the ASCII representation [RFC20]
for the '*' character.
A descriptive name of a label equaling that value is an 'asterisk
label'." (Quoted from <xref target="RFC4592"/>, Section 2.1.1)</t>

<t hangText='Wildcard domain name:'>
  <iref item='Wildcard domain name'/>
"A 'wildcard domain name' is defined by having its initial (i.e.,
leftmost or least significant) label, in binary format: 0000 0001 0010 1010 (binary) = 0x01 0x2a (hexadecimal)".
(Quoted from <xref target="RFC4592"/>, Section 2.1.1)  The second octet in this label is the ASCII representation for the "*" character.</t>

<t hangText='Closest encloser:'>
<iref item='Closest encloser'/>
"The longest existing ancestor of a name."
(Quoted from <xref target="RFC5155"/>, Section 1.3)
An earlier definition is "The node in the zone's tree of existing
domain names that has the most labels matching the query name
(consecutively, counting from the root label downward).  Each match
is a 'label match' and the order of the labels is the same."
(Quoted from <xref target="RFC4592"/>, Section 3.3.1)
</t>

<t hangText='Closest provable encloser:'>
<iref item='Closest provable encloser'/>
"The longest ancestor of a name that can
be proven to exist.  Note that this is only different from the
closest encloser in an Opt-Out zone."
(Quoted from <xref target="RFC5155"/>, Section 1.3)
See <xref target="dnssec-general"/> for more on "opt-out".
</t>

<t hangText='Next closer name:'>
<iref item='Next closer name'/>
"The name one label longer than the closest
provable encloser of a name."
(Quoted from <xref target="RFC5155"/>, Section 1.3)</t>

<t hangText='Source of Synthesis:'>
<iref item='Source of Synthesis'/>
"The source of synthesis is defined in the context of a query process
as that wildcard domain name immediately descending from the closest
encloser, provided that this wildcard domain name exists.
'Immediately descending' means that the source of synthesis has a
name of the form: 
<vspace blankLines="0"/>
&lt;asterisk label&gt;.&lt;closest encloser&gt;."
<vspace blankLines="0"/>
(Quoted from <xref target="RFC4592"/>, Section 3.3.1)</t>

</list></t>
</section>

<section anchor="reg-model" title="Registration Model">
<t><list style="hanging">

<t hangText='Registry:'>
<iref item='Registry'/>
The administrative operation of a zone that allows registration of names within that
zone.  People often use this term to refer only to those organizations
that perform registration in large delegation-centric zones (such as
TLDs); but formally, whoever decides what data goes into a zone is the
registry for that zone.
This definition of "registry" is from a DNS point of view; for some zones, the policies
that determine what can go in the zone are decided by zones that are superordinate and not the registry operator.</t>

<t hangText='Registrant:'>
<iref item='Registrant'/>
An individual or organization on whose behalf a name in
a zone is registered by the registry.  In many zones, the registry and
the registrant may be the same entity, but in TLDs they often are
not.</t>

<t hangText='Registrar:'>
<iref item='Registrar'/>
A service provider that acts as a go-between for
registrants and registries.  Not all registrations require a
registrar, though it is common to have registrars involved in
registrations in TLDs.</t>

<t hangText='EPP:'>
<iref item='EPP'/>
The Extensible Provisioning Protocol (EPP), which is commonly used for communication
of registration information between registries and registrars. EPP is defined in <xref target="RFC5730"/>.</t>

<t hangText='WHOIS:'>
<iref item='WHOIS'/>
A protocol specified in <xref target="RFC3912"/>, often used for querying registry databases.
WHOIS data is frequently used to associate registration data (such as zone management
contacts) with domain names.
The term "WHOIS data" is often used as a synonym for the registry database, even though
that database may be served by different protocols, particularly RDAP.
The WHOIS protocol is also used with IP address registry data.</t>

<t hangText='RDAP:'>
<iref item='RDAP'/>
The Registration Data Access Protocol, defined in
<xref target="RFC7480"/>, <xref target="RFC7481"/>, <xref target="RFC7482"/>, <xref target="RFC7483"/>,
<xref target="RFC7484"/>, and <xref target="RFC7485"/>.
The RDAP protocol and data format are meant as a replacement for WHOIS.</t>

<t hangText='DNS operator:'>
<iref item='DNS operator'/>
An entity responsible for running DNS servers. For a zone's authoritative servers, the registrant
may act as their own DNS operator, their registrar may do it on their behalf, or they may use a
third-party operator.
For some zones, the registry function is performed by the DNS operator plus other entities
who decide about the allowed contents of the zone.</t>

<t hangText='Public suffix:'>
<iref item='Public suffix'/>
"A domain that is controlled by a public registry" (Quoted from <xref target="RFC6265"/>, Section 5.3)
A common definition for this term is a domain under which subdomains can be registered by third parties and on which HTTP cookies
(which are described in detail in <xref target="RFC6265"/>) should not be set.
There is no indication in a domain name whether it is a public suffix; that  can only be
determined by outside means.
In fact, both a domain and a subdomain of that domain can be public suffixes.
</t>

<t>There is nothing inherent in a domain name to indicate whether it is
a public suffix.  One
resource for identifying public suffixes is the Public Suffix List (PSL)
maintained by Mozilla (http://publicsuffix.org/).</t>

<t>For example, at the time this document is published,
the "com.au" domain is listed as a public suffix in the PSL.
(Note that this example might change in the future.)</t>

<t>Note that the term "public suffix" is controversial in the DNS
community for many reasons, and it may be significantly changed in the future. One example of the
difficulty of calling a domain a public suffix is that designation can change over time as the
registration policy for the zone changes, such as was the case with the "uk" TLD in 2014.</t>

<t hangText='Subordinate and Superordinate:'>
<iref item='Subordinate'/>
<iref item='Superordinate'/>
These terms are introduced in <xref target="RFC5731"/> for use in the registration model, but not defined there.
Instead, they are given in examples.
"For example, domain name 'example.com' has a superordinate relationship to host name
ns1.example.com'...  For example, host ns1.example1.com is a subordinate host of domain example1.com,
but it is a not a subordinate host of domain example2.com."
(Quoted from <xref target="RFC5731"/>, Section 1.1)
These terms are strictly ways of referring to the relationship standing of two domains
where one is a subdomain of the other.</t>

</list></t>
</section>



<section anchor="dnssec-general" title="General DNSSEC">

<t>Most DNSSEC terms are defined in <xref target="RFC4033"/>,
<xref target="RFC4034"/>, <xref target="RFC4035"/>, and <xref target="RFC5155"/>. The
terms that have caused confusion in the DNS community are highlighted here.</t>

<t><list style="hanging">

<t hangText='DNSSEC-aware and DNSSEC-unaware:'>
<iref item='DNSSEC-aware and DNSSEC-unaware'/>
These two terms, which are used in some RFCs, have not been formally defined.
However, Section 2 of <xref target="RFC4033"/> defines many types of resolvers and
validators, including "non-validating security-aware stub resolver", "non-validating
stub resolver", "security-aware name server", "security-aware recursive name server",
"security-aware resolver", "security-aware stub resolver", and "security-oblivious 'anything'".
(Note that the term "validating resolver", which is used in some
places in DNSSEC-related documents, is also not defined in those RFCs, but is defined below.)</t>

<t hangText='Signed zone:'>
<iref item='Signed zone'/>
"A zone whose RRsets are signed and that contains
properly constructed DNSKEY, Resource Record Signature (RRSIG),
Next Secure (NSEC), and (optionally) DS records." (Quoted from 
<xref target="RFC4033"/>, Section 2)
It has been noted in other contexts that the zone itself is not
really signed, but all the relevant RRsets in the zone are signed.
Nevertheless, if a zone that should be signed contains any RRsets that
are not signed (or opted out), those RRsets will be treated as bogus,
so the whole zone needs to be handled in some way.</t>
<t>It should also be noted that, since the publication of <xref target="RFC6840"/>, NSEC records are no
longer required for signed zones: a signed zone might include NSEC3 records instead.
<xref target="RFC7129"/> provides additional background commentary and some context for the NSEC and
NSEC3 mechanisms used by DNSSEC to provide authenticated denial-of-existence responses.
NSEC and NSEC3 are described below.</t>

<t hangText='Unsigned zone:'>
<iref item='Unsigned zone'/>
Section 2 of <xref target="RFC4033"/> defines this as "a zone that is not signed". Section 2 of
<xref target="RFC4035"/> defines this as a "zone that does not include these records [properly constructed DNSKEY,
Resource Record Signature (RRSIG), Next Secure (NSEC), and (optionally) DS records] according to the
rules in this section..."  There is an important note at the end of Section 5.2 of <xref target="RFC4035"/> that defines an
additional situation in which a zone is considered unsigned:
<!--Begin DNE -->
"If the resolver does not support any of
the algorithms listed in an authenticated DS RRset, then the resolver will not be able to verify the
authentication path to the child zone.  In this case, the resolver SHOULD treat the child zone as if
it were unsigned."
<!--End DNE -->
</t>

<t hangText='NSEC:'>
<iref item='NSEC'/>
"The NSEC record allows a security-aware resolver to authenticate a negative reply for
either name or type non-existence with the same mechanisms used to authenticate other DNS replies."
(Quoted from <xref target="RFC4033"/>, Section 3.2) In short, an NSEC record provides authenticated denial of
existence.</t>

<t>"The NSEC resource record lists two separate things: the next owner name (in the canonical
ordering of the zone) that contains authoritative data or a delegation point NS RRset, and the set
of RR types present at the NSEC RR's owner name." (Quoted from Section 4 of RFC 4034)</t>

<t hangText='NSEC3:'>
<iref item='NSEC3'/>
Like the NSEC record, the NSEC3 record also provides authenticated denial of existence; however,
NSEC3 records mitigate zone enumeration and support Opt-Out.
NSEC3 resource records require associated NSEC3PARAM resource records.
NSEC3 and NSEC3PARAM resource records are defined in <xref target="RFC5155"/>.</t>

<t>Note that <xref target="RFC6840"/> says that <xref target="RFC5155"/> "is now considered part of the DNS Security Document Family
as described by Section 10 of <xref target="RFC4033"/>". This means that some of the definitions from earlier RFCs that
only talk about NSEC records should probably be considered to be talking about both NSEC and NSEC3.</t>

<t hangText='Opt-out:'>
<iref item='Opt-out'/>
"The Opt-Out Flag indicates whether this NSEC3 RR may cover unsigned delegations."
(Quoted from <xref target="RFC5155"/>, Section 3.1.2.1)
Opt-out tackles the high costs of securing a delegation to an insecure zone.  When using
Opt-Out, names that are an insecure delegation (and empty non-terminals that are only
derived from insecure delegations) don't require an NSEC3 record or its corresponding
RRSIG records. Opt-Out NSEC3 records are not able to prove or deny the existence of the
insecure delegations. (Adapted from <xref target="RFC7129"/>, Section 5.1)</t>

<t hangText='Insecure delegation:'>
<iref item='Insecure delegation'/>
"A signed name containing a delegation (NS RRset), but lacking a DS RRset,
signifying a delegation to an unsigned subzone." (Quoted from <xref target="RFC4956"/>, Section 2)</t>

<t hangText='Zone enumeration:'>
<iref item='Zone enumeration'/>
"The practice of discovering the full content of a zone via successive queries."
(Quoted from <xref target="RFC5155"/>, Section 1.3) This is also sometimes called "zone walking".
Zone enumeration is different from zone content guessing where the guesser uses a large dictionary
of possible labels and sends successive queries for them, or matches the contents of NSEC3 records
against such a dictionary.</t>

<t hangText='Validation:'>
<iref item='Validation'/>
Validation, in the context of DNSSEC, refers to one of the following:

<list style="symbols">

<t>Checking the validity of DNSSEC signatures,</t>

<t>Checking the validity of DNS responses, such as those including authenticated denial of
existence, or</t>

<t>Building an authentication chain from a trust anchor to a DNS response or individual
DNS RRsets in a response</t>

</list></t> 

<t>The first two definitions above consider only the validity of individual DNSSEC
components such as the RRSIG validity or NSEC proof validity. The third definition
considers the components of the entire DNSSEC authentication chain; thus, it requires
"configured knowledge of at least one authenticated DNSKEY or DS RR" (as described in
<xref target="RFC4035"/>, Section 5).</t>

<t><xref target="RFC4033"/>, Section 2, says that a "Validating Security-Aware Stub
Resolver... performs signature validation" and uses a trust anchor "as a starting point
for building the authentication chain to a signed DNS response"; thus, it uses the first
and third definitions above.  The process of validating an RRSIG resource record is described in <xref
target="RFC4035"/>, Section 5.3.</t>

<t><xref target="RFC5155"/> refers to validating responses throughout the document, in the
context of hashed authenticated denial of existence; this uses the second definition
above.</t>

<t>
The term "authentication" is used interchangeably with "validation", in the sense of the
third definition above.
<xref target="RFC4033"/>, Section
2, describes the chain linking trust anchor to DNS data as the "authentication chain".  A
response is considered to be authentic if "all RRsets in the Answer and Authority sections
of the response [are considered] to be authentic" (Quoted from <xref target="RFC4035"/>)  DNS data or
responses deemed to be authentic or validated have a security status of "secure" (<xref
target="RFC4035"/>, Section 4.3; <xref target="RFC4033"/>, Section 5).  "Authenticating
both DNS keys and data is a matter of local policy, which may extend or even override the
[DNSSEC] protocol extensions..." (Quoted from <xref target="RFC4033"/>, Section 3.1)</t>

<t>The term "verification", when used, is usually synonym for "validation".</t>

<t hangText='Validating resolver:'>
<iref item='Validating resolver'/>
  A security-aware recursive name server, security-aware resolver, or
  security-aware stub resolver that is applying at least one of the
  definitions of validation (above), as appropriate to the resolution
  context.  For the same reason that the generic term "resolver" is
  sometimes ambiguous and needs to be evaluated in context (see <xref
  target="dns-servers-and-clients" />), "validating resolver" is a
  context-sensitive term.
</t>

<t hangText='Key signing key (KSK):'>
<iref item='Key signing key (KSK)'/>
DNSSEC keys that "only sign the apex DNSKEY RRset in a zone." (Quoted from
<xref target="RFC6781"/>, Section 3.1)</t>

<t hangText='Zone signing key (ZSK):'>
<iref item='Zone signing key (ZSK)'/>
"DNSSEC keys that can be used to sign all the RRsets in a zone that
require signatures, other than the apex DNSKEY RRset." (Quoted from <xref target="RFC6781"/>, Section 3.1)
Also note that a ZSK is sometimes used to sign the apex DNSKEY RRset.</t>

<t hangText='Combined signing key (CSK):'>
<iref item='Combined signing key (CSK)'/>
"In cases where the differentiation between the KSK and ZSK is not made,
i.e., where keys have the role of both KSK and ZSK, we talk about a Single-Type Signing
Scheme." (Quoted from <xref target="RFC6781"/>, Section 3.1) This is sometimes called a "combined
signing key" or "CSK".  It is operational practice, not protocol, that determines whether a
particular key is a ZSK, a KSK, or a CSK.</t>

<t hangText='Secure Entry Point (SEP):'>
<iref item='Secure Entry Point (SEP)'/>
A flag in the DNSKEY RDATA that "can be used to distinguish between
keys that are intended to be used as the secure entry point into the zone when building
chains of trust, i.e., they are (to be) pointed to by parental DS RRs or configured as a
trust anchor.... 
Therefore, it is suggested that the SEP flag be set on keys that are used as KSKs and not on keys
that are used as ZSKs, while in those cases where a distinction between a KSK and ZSK is not made
(i.e., for a Single-Type Signing Scheme), it is suggested that the SEP flag be set on all keys."
(Quoted from <xref target="RFC6781"/>, Section 3.2.3)  Note that the
SEP flag is only a hint, and its presence or absence may not be used to disqualify a given
DNSKEY RR from use as a KSK or ZSK during validation.</t>

<t>The original definition of SEPs was in <xref target="RFC3757"/>. That definition
clearly indicated that the SEP was a key, not just a bit in the key. The
abstract of <xref target="RFC3757"/> says:
"With the Delegation Signer (DS) resource record (RR), the concept of
a public key acting as a secure entry point (SEP) has been
introduced.  During exchanges of public keys with the parent there is
a need to differentiate SEP keys from other public keys in the Domain
Name System KEY (DNSKEY) resource record set.  A flag bit in the
DNSKEY RR is defined to indicate that DNSKEY is to be used as a SEP."
That definition of the SEP as a key was made obsolete by <xref target="RFC4034"/>,
and the definition from <xref target="RFC6781"/> is consistent with <xref target="RFC4034"/>.</t>

<t hangText='Trust anchor:'>
<iref item='Trust anchor'/>
"A configured DNSKEY RR or DS RR hash of a DNSKEY RR.  A
validating security-aware resolver uses this public key or hash as
a starting point for building the authentication chain to a signed
DNS response. In general, a validating resolver will have to
obtain the initial values of its trust anchors via some secure or
trusted means outside the DNS protocol." (Quoted from <xref target="RFC4033"/>, Section 2)</t>

<t hangText='DNSSEC Policy (DP):'>
<iref item='DNSSEC Policy (DP)'/>
A statement that "sets forth the security requirements and
standards to be implemented for a DNSSEC-signed zone." (Quoted from <xref target="RFC6841"/>,
Section 2)</t>

<t hangText='DNSSEC Practice Statement (DPS):'>
<iref item='DNSSEC Practice Statement (DPS)'/>"A practices disclosure document that may
support and be a supplemental document to the DNSSEC Policy (if such exists),
and it states how the management of a given zone implements procedures and
controls at a high level." (Quoted from <xref target="RFC6841"/>, Section 2)</t>

<t hangText='Hardware security module (HSM):'>
<iref item='Hardware security module (HSM)'/>
A specialized piece of hardware that is used to create keys for signatures and to
sign messages without ever disclosing the private key. In DNSSEC, HSMs are often used to hold the private keys for
KSKs and ZSKs and to create the signatures used in RRSIG records at periodic intervals.</t>

<t hangText='Signing software:'>
<iref item='Signing software'/>
Authoritative DNS servers that support DNSSEC often contain software that
facilitates the creation and maintenance of DNSSEC signatures in zones.
There is also stand-alone software that can be used to sign a zone regardless
of whether the authoritative server itself supports signing. Sometimes
signing software can support particular HSMs as part of the signing process.</t>

</list></t>
</section>

<section anchor="dnssec-states" title="DNSSEC States">

<t>A validating resolver can determine that a response is in one of four states:
secure, insecure, bogus, or indeterminate. These states are defined in
<xref target="RFC4033"/> and <xref target="RFC4035"/>, although the definitions in the two documents differ a bit.  This document makes no effort to reconcile the definitions in the two documents, and takes no
position as to whether they need to be reconciled.</t>

<!--Begin DNE text -->
<t>Section 5 of <xref target="RFC4033"/> says:</t>

<figure><artwork><![CDATA[
   A validating resolver can determine the following 4 states:
   
   Secure: The validating resolver has a trust anchor, has a chain
      of trust, and is able to verify all the signatures in the
      response.
   
   Insecure: The validating resolver has a trust anchor, a chain
      of trust, and, at some delegation point, signed proof of the
      non-existence of a DS record.  This indicates that subsequent
      branches in the tree are provably insecure.  A validating
      resolver may have a local policy to mark parts of the domain
      space as insecure.
   
   Bogus: The validating resolver has a trust anchor and a secure
      delegation indicating that subsidiary data is signed, but
      the response fails to validate for some reason: missing
      signatures, expired signatures, signatures with unsupported
      algorithms, data missing that the relevant NSEC RR says
      should be present, and so forth.
   
   Indeterminate: There is no trust anchor that would indicate that a
      specific portion of the tree is secure.  This is the default
      operation mode.
]]></artwork></figure>

<t>Section 4.3 of <xref target="RFC4035"/> says:</t>

<figure><artwork><![CDATA[
   A security-aware resolver must be able to distinguish between four
   cases:
   
   Secure: An RRset for which the resolver is able to build a chain
       of signed DNSKEY and DS RRs from a trusted security anchor to
       the RRset.  In this case, the RRset should be signed and is
       subject to signature validation, as described above.
   
   Insecure: An RRset for which the resolver knows that it has no
      chain of signed DNSKEY and DS RRs from any trusted starting
      point to the RRset.  This can occur when the target RRset lies
      in an unsigned zone or in a descendent [sic] of an unsigned   
      zone.  In this case, the RRset may or may not be signed, but 
      the resolver will not be able to verify the signature.
   
   Bogus: An RRset for which the resolver believes that it ought to 
      be able to establish a chain of trust but for which it is
      unable to do so, either due to signatures that for some reason
      fail to validate or due to missing data that the relevant
      DNSSEC RRs indicate should be present.  This case may indicate
      an attack but may also indicate a configuration error or some
      form of data corruption.
   
   Indeterminate: An RRset for which the resolver is not able to
      determine whether the RRset should be signed, as the resolver 
      is not able to obtain the necessary DNSSEC RRs.  This can occur 
      when the security-aware resolver is not able to contact 
      security-aware name servers for the relevant zones.
]]></artwork></figure>

<!--End DNE -->
</section>

<section anchor="securitycons" title="Security Considerations">

<t>These definitions do not change any security considerations for the DNS.</t>

</section>

<section anchor="ianacons" title="IANA Considerations">

<t>This document has no IANA actions.</t>

</section>

</middle>

<back>

<references title='Normative References'>

<reference anchor="IANA_RootFiles" target="https://www.iana.org/domains/root/files">
<front>
<title>Root Files</title>
<author>
<organization>IANA</organization>
</author>
<date/>
</front>
</reference>

<?rfc include="reference.RFC.0882.xml" ?>
<?rfc include="reference.RFC.1034.xml" ?>
<?rfc include="reference.RFC.1035.xml" ?>
<?rfc include="reference.RFC.1123.xml" ?>
<?rfc include="reference.RFC.1912.xml" ?>
<?rfc include="reference.RFC.1996.xml" ?>
<?rfc include="reference.RFC.2136.xml" ?>
<?rfc include="reference.RFC.2181.xml" ?>
<?rfc include="reference.RFC.2182.xml" ?>
<?rfc include="reference.RFC.2308.xml" ?>
<?rfc include="reference.RFC.4033.xml" ?>
<?rfc include="reference.RFC.4034.xml" ?>
<?rfc include="reference.RFC.4035.xml" ?>
<?rfc include="reference.RFC.4592.xml" ?>
<?rfc include="reference.RFC.5155.xml" ?>
<?rfc include="reference.RFC.5358.xml" ?>
<?rfc include="reference.RFC.5730.xml" ?>
<?rfc include="reference.RFC.5731.xml" ?>
<?rfc include="reference.RFC.5855.xml" ?>
<?rfc include="reference.RFC.5936.xml" ?>
<?rfc include="reference.RFC.6561.xml" ?>
<?rfc include="reference.RFC.6781.xml" ?>
<?rfc include="reference.RFC.6840.xml" ?>
<?rfc include="reference.RFC.6841.xml" ?>
<?rfc include="reference.RFC.6891.xml" ?>
<?rfc include="reference.RFC.7344.xml" ?>
<?rfc include="reference.RFC.7719.xml" ?>
<?rfc include="reference.RFC.8310.xml" ?>

</references>

<references title='Informative References'>

  <!--<?rfc include="reference.I-D.ietf-doh-dns-over-https.xml" ?> in AUTH48 as of 10/17/18 (RFC-to-be 8484)-->


<reference anchor='RFC8484' target='https://www.rfc-editor.org/info/rfc8484'>
<front>
<title>DNS Queries over HTTPS (DoH)</title>

<author initials='P' surname='Hoffman' fullname='Paul Hoffman'>
    <organization />
</author>

<author initials='P' surname='McManus' fullname='Patrick McManus'>
    <organization />
</author>

<date month='October' year='2018' />

<abstract><t>This document defines a protocol for sending DNS queries and getting DNS responses over HTTPS.  Each DNS query-response pair is mapped into an HTTP exchange.</t></abstract>

</front>
<seriesInfo name='RFC' value='8484' />
<seriesInfo name="DOI" value="10.17487/RFC8484"/>

</reference>
 

<reference anchor="IANA_Resource_Registry" target="https://www.iana.org/assignments/dns-parameters/">
<front>
<title>Resource Record (RR) TYPEs</title>
<author>
<organization>IANA</organization>
</author>
<date/>
</front>
</reference>

<?rfc include="reference.RFC.0819.xml" ?>
<?rfc include="reference.RFC.0952.xml" ?>
<?rfc include="reference.RFC.1713.xml" ?>
<?rfc include="reference.RFC.1995.xml" ?>
<?rfc include="reference.RFC.2775.xml" ?>
<?rfc include="reference.RFC.3172.xml" ?>
<?rfc include="reference.RFC.3425.xml" ?>
<?rfc include="reference.RFC.3493.xml" ?>
<?rfc include="reference.RFC.3757.xml" ?>
<?rfc include="reference.RFC.3912.xml" ?>
<?rfc include="reference.RFC.4641.xml" ?>
<?rfc include="reference.RFC.4697.xml" ?>
<?rfc include="reference.RFC.4786.xml" ?>
<?rfc include="reference.RFC.4956.xml" ?>
<?rfc include="reference.RFC.5625.xml" ?>
<?rfc include="reference.RFC.5890.xml" ?>
<?rfc include="reference.RFC.5891.xml" ?>
<?rfc include="reference.RFC.5892.xml" ?>
<?rfc include="reference.RFC.5893.xml" ?>
<?rfc include="reference.RFC.5894.xml" ?>
<?rfc include="reference.RFC.6055.xml" ?>
<?rfc include="reference.RFC.6265.xml" ?>
<?rfc include="reference.RFC.6303.xml" ?>
<?rfc include="reference.RFC.6335.xml" ?>
<?rfc include="reference.RFC.6365.xml" ?>
<?rfc include="reference.RFC.6672.xml" ?>
<?rfc include="reference.RFC.6762.xml" ?>
<?rfc include="reference.RFC.7129.xml" ?>
<?rfc include="reference.RFC.7480.xml" ?>
<?rfc include="reference.RFC.7481.xml" ?>
<?rfc include="reference.RFC.7482.xml" ?>
<?rfc include="reference.RFC.7483.xml" ?>
<?rfc include="reference.RFC.7484.xml" ?> 
<?rfc include="reference.RFC.7485.xml" ?>
<?rfc include="reference.RFC.7858.xml" ?>
<?rfc include="reference.RFC.7793.xml" ?>
<?rfc include="reference.RFC.8094.xml" ?>
<?rfc include="reference.RFC.8109.xml" ?>

<reference anchor="RSSAC026" target="https://www.icann.org/en/system/files/files/rssac-026-14mar17-en.pdf">
<front>
<title>RSSAC Lexicon</title>
<author>
<organization>Root Server System Advisory Committee (RSSAC)</organization>
</author>
<date year="2017"/>
</front>
</reference>

</references>

<section anchor="updates-list" title="Definitions Updated by This Document">

<t>The following definitions from RFCs are updated by this document:

<list style="symbols">

<t>Forwarder in <xref target="RFC2308"/></t>

<t>QNAME in <xref target="RFC2308"/></t>

<t>Secure Entry Point (SEP) in <xref target="RFC3757"/>;
note, however, that this RFC is already obsolete
(see <xref target="RFC4033"/>, <xref target="RFC4034"/>, <xref target="RFC4035"/>).</t>

</list></t>

</section>

<section anchor="new-def" title="Definitions First Defined in This Document">

<t>The following definitions are first defined in this document:

<list style="symbols">


<t>"Alias" in <xref target="names"/></t>
<t>"Apex" in <xref target="zones"/></t>
<t>"arpa" in <xref target="zones"/></t>
<t>"Bailiwick" in <xref target="zones"/></t>
<t>"Class independent" in <xref target="rrs"/></t>
<t>"Delegation-centric zone" in <xref target="zones"/></t>
<t>"Delegation" in <xref target="zones"/></t>
<t>"DNS operator" in <xref target="reg-model"/></t>
<t>"DNSSEC-aware" in <xref target="dnssec-general"/></t>
<t>"DNSSEC-unaware" in <xref target="dnssec-general"/></t>
<t>"Forwarding" in <xref target="dns-servers-and-clients"/></t>
<t>"Full resolver" in <xref target="dns-servers-and-clients"/></t>
<t>"Fully-qualified domain name" in <xref target="names"/></t>
<t>"Global DNS" in <xref target="names"/></t>
<t>"Hardware Security Module (HSM)" in <xref target="dnssec-general"/></t>
<t>"Host name" in <xref target="names"/></t>
<t>"IDN" in <xref target="names"/></t>
<t>"In-bailiwick" in <xref target="zones"/></t>
<t>"Iterative resolution" in <xref target="dns-servers-and-clients"/></t>
<t>"Label" in <xref target="names"/></t>
<t>"Locally served DNS zone" in <xref target="names"/></t>
<t>"Naming system" in <xref target="names"/></t>
<t>"Negative response" in <xref target="dns-response-codes"/></t>
<t>"Non-recursive query" in <xref target="dns-servers-and-clients"/></t>
<t>"Open resolver" in <xref target="dns-servers-and-clients"/></t>
<t>"Out-of-bailiwick" in <xref target="zones"/></t>
<t>"Passive DNS" in <xref target="dns-servers-and-clients"/></t>
<t>"Policy-implementing resolver" in <xref target="dns-servers-and-clients"/></t>
<t>"Presentation format" in <xref target="rrs"/></t>
<t>"Priming" in <xref target="dns-servers-and-clients"/></t>
<t>"Private DNS" in <xref target="names"/></t>
<t>"Recursive resolver" in <xref target="dns-servers-and-clients"/></t>
<t>"Referrals" in <xref target="dns-transactions"/></t>
<t>"Registrant" in <xref target="reg-model"/></t>
<t>"Registrar" in <xref target="reg-model"/></t>
<t>"Registry" in <xref target="reg-model"/></t>
<t>"Root zone" in <xref target="zones"/></t>
<t>"Secure Entry Point (SEP)" in <xref target="dnssec-general"/></t>
<t>"Signing software" in <xref target="dnssec-general"/></t>
<t>"Split DNS" in <xref target="dns-servers-and-clients"/></t>
<t>"Stub resolver" in <xref target="dns-servers-and-clients"/></t>
<t>"Subordinate" in <xref target="wildcards"/></t>
<t>"Superordinate" in <xref target="wildcards"/></t>
<t>"TLD" in <xref target="names"/></t>
<t>"Validating resolver" in <xref target="dnssec-general"/></t>
<t>"Validation" in <xref target="dnssec-general"/></t>
<t>"View" in <xref target="dns-servers-and-clients"/></t>
<t>"Zone transfer" in <xref target="dns-servers-and-clients"/></t>

</list></t>

</section>

<section anchor="acknowledgements" title="Acknowledgements" numbered="no">

<t>The following is the Acknowledgements section of RFC 7719.
<list style="empty">
<!--Begin DNE -->

<t>The authors gratefully acknowledge all of the authors of DNS-related RFCs that proceed
this one. Comments from Tony Finch, Stephane Bortzmeyer, Niall O'Reilly,
Colm MacCarthaigh, Ray Bellis, John Kristoff, Robert Edmonds, Paul Wouters, Shumon Huque,
Paul Ebersman, David Lawrence, Matthijs Mekking, Casey Deccio, Bob Harold, Ed Lewis,
John Klensin, David Black,
and many others in the DNSOP Working Group helped shape RFC 7719.</t></list></t>
<!--End DNE -->
<t>Most of the major changes between RFC 7719 and this document came from
active discussion on the DNSOP WG. Specific people who contributed material to this document include: 
Bob Harold,
Dick Franks,
Evan Hunt,
John Dickinson,
Mark Andrews,
Martin Hoffmann,
Paul Vixie,
Peter Koch,
Duane Wessels,
Allison Mankin, 
Giovane Moura,
Roni Even,
Dan Romascanu, and
Vladmir Cunat.</t>

</section>

</back>
</rfc>

