<?xml version="1.0" encoding="US-ASCII"?>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<?rfc toc="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no"?>
<?rfc strict="yes"?>

<rfc ipr="trust200902"   category="std"
    number="8040" submissionType="IETF" consensus="yes" >

    <front>
    <title abbrev="RESTCONF">RESTCONF Protocol</title>

    <author initials="A" surname="Bierman" fullname='Andy Bierman' >
      <organization>YumaWorks</organization>
      <address>
        <email>andy@yumaworks.com</email>
      </address>
    </author>
    <author initials="M" surname="Bjorklund" fullname='Martin Bjorklund' >
      <organization>Tail-f Systems</organization>
      <address>
        <email>mbj@tail-f.com</email>
      </address>
    </author>
    <author initials="K" surname="Watsen" fullname='Kent Watsen' >
      <organization>Juniper Networks</organization>
      <address>
        <email>kwatsen@juniper.net</email>
      </address>
    </author>

        <date month="January" year="2017"/>

    <abstract>
        <t>
This document describes an HTTP-based protocol that provides
a programmatic interface for accessing data defined in YANG,
using the datastore concepts defined in the Network Configuration
Protocol (NETCONF).
        </t>
</abstract>
</front>

<middle>
<section title="Introduction">
    <t>
There is a need for standard mechanisms to allow Web applications
to access the configuration data, state data, data-model-specific
Remote Procedure Call (RPC) operations, and event notifications
within a networking device, in a modular and extensible manner.
    </t>
    <t>
This document defines a protocol based on HTTP <xref target="RFC7230"/>
called &quot;RESTCONF&quot;, for configuring data defined in
YANG version&nbsp;1 <xref target="RFC6020"/> or YANG version&nbsp;1.1
<xref target="RFC7950"/>, using the datastore concepts defined in the
Network Configuration Protocol (NETCONF) <xref target="RFC6241"/>.
    </t>
    <t>
NETCONF defines configuration datastores and
a set of Create, Read, Update, Delete (CRUD) operations
that can be used to access these datastores.
NETCONF also defines a protocol for invoking these operations.
The YANG language defines the syntax and semantics
of datastore content, configuration, state data, RPC operations,
and event notifications.
    </t>
    <t>
RESTCONF uses HTTP methods to provide CRUD operations on a
conceptual datastore containing YANG-defined data, which is
compatible with a server that implements NETCONF datastores.
    </t>
    <t>
If a RESTCONF server is co-located with a NETCONF server,
then there are protocol interactions with the NETCONF protocol;
these interactions are described in <xref target="netconf-coexistence"/>.
The RESTCONF server MAY provide access to specific datastores using
operation resources, as described in <xref target="operation-resource"/>.
The RESTCONF protocol does not specify any
mandatory operation resources.  The semantics of each operation
resource determine if and how datastores are accessed.
    </t>
    <t>
Configuration data and state data are exposed as resources that
can be retrieved with the GET method.
Resources representing configuration data
can be modified with the DELETE, PATCH, POST, and PUT methods.
Data is encoded with either XML <xref target="W3C.REC-xml-20081126"/>
or JSON <xref target="RFC7159"/>.
    </t>
    <t>
Data-model-specific RPC operations defined with the YANG &quot;rpc&quot; or
&quot;action&quot; statements can be invoked with the POST method.
Data-model-specific event notifications defined with the YANG &quot;notification&quot;
statement can be accessed.
    </t>
<section title="Terminology">
    <t>
The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL
NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,  &quot;MAY&quot;, and
&quot;OPTIONAL&quot; in this document are to be interpreted as described in
<xref target="RFC2119"/>.
    </t>
<section title="NETCONF">
    <t>
The following terms are defined in <xref target="RFC6241"/>:
    </t>
<t>
 <list style="symbols">
 <t>
candidate configuration datastore
 </t>
 <t>
configuration data
 </t>
 <t>
datastore
 </t>
 <t>
configuration datastore
 </t>
 <t>
running configuration datastore
 </t>
 <t>
startup configuration datastore
 </t>
 <t>
state data
 </t>
 <t>
user
 </t>
 </list>
</t>
</section>
<section title="HTTP">
    <t>
The following terms are defined in <xref target="RFC3986"/>:
    </t>
<t>
 <list style="symbols">
 <t>
fragment
 </t>
 <t>
path
 </t>
 <t>
query
 </t>
 </list>
</t>
    <t>
The following terms are defined in <xref target="RFC7230"/>:
    </t>
<t>
 <list style="symbols">
 <t>
header field
 </t>
 <t>
message-body
 </t>
 <t>
request-line
 </t>
 <t>
request URI
 </t>
 <t>
status-line
 </t>
 </list>
</t>
    <t>
The following terms are defined in <xref target="RFC7231"/>:
    </t>
<t>
 <list style="symbols">
 <t>
method
 </t>
 <t>
request
 </t>
 <t>
resource
 </t>
 </list>
</t>
    <t>
The following term is defined in <xref target="RFC7232"/>:
    </t>
<t>
 <list style="symbols">
 <t>
entity-tag
 </t>
 </list>
</t>
</section>

<section title="YANG">
    <t>
The following terms are defined in <xref target="RFC7950"/>:
    </t>
<t>
 <list style="symbols">
 <t>
action
 </t>
 <t>
container
 </t>
 <t>
data node
 </t>
 <t>
key leaf
 </t>
 <t>
leaf
 </t>
 <t>
leaf-list
 </t>
 <t>
list
 </t>
 <t>
mandatory node
 </t>
 <t>
ordered-by user
 </t>
 <t>
presence container
 </t>
 <t>
RPC operation
 </t>
 <t>
top-level data node
 </t>
 </list>
</t>
</section>
<section title="NETCONF Notifications">
    <t>
The following term is defined in <xref target="RFC5277"/>:
    </t>
<t>
 <list style="symbols">
 <t>
notification replay
 </t>
 </list>
</t>
</section>

<section title="Terms">
    <t>
The following terms are used within this document:
    </t>
<t>
 <list style="symbols">
 <t>
API resource: the resource that models the RESTCONF root resource
and the sub-resources to access YANG-defined content.
It is defined with the YANG data template named &quot;yang&#8209;api&quot;
in the &quot;ietf&#8209;restconf&quot; module.
 </t>
 <t>
client: a RESTCONF client.
 </t>
 <t>
data resource: a resource that models a YANG data node.
It is defined with YANG data definition statements.
 </t>
 <t>
datastore resource: the resource that models a
programmatic interface using NETCONF datastore concepts.
By default, RESTCONF methods access a unified view
of the underlying datastore implementation on the server.
It is defined as a sub-resource within the API resource.
 </t>
 <t>
edit operation: a RESTCONF operation on a data resource
using either a POST, PUT, PATCH, or DELETE method.  This is
not the same as the NETCONF edit operation (i.e., one of
the values for the &quot;nc:operation&quot; attribute:
&quot;create&quot;, &quot;replace&quot;, &quot;merge&quot;,
&quot;delete&quot;, or &quot;remove&quot;).
 </t>
 <t>
event stream resource: a resource that represents an SSE
(Server&nbhy;Sent Events) event stream. The content consists of text
using the media type &quot;text/event&#8209;stream&quot;, as defined by the
SSE specification <xref target="W3C.REC-eventsource-20150203"/>.
Event stream contents are described in <xref target="stream-resource"/>.
 </t>
 <t>
media type: HTTP uses Internet media types
<xref target="RFC2046"/> in the &quot;Content&nbhy;Type&quot;
and &quot;Accept&quot; header fields
in order to provide open and extensible data typing and type negotiation.
 </t>
 <t>
NETCONF client: a client that implements the NETCONF protocol.
Called &quot;client&quot; in <xref target="RFC6241"/>.
 </t>
 <t>
NETCONF server: a server that implements the NETCONF protocol.
Called &quot;server&quot; in <xref target="RFC6241"/>.
 </t>
 <t>
operation: the conceptual RESTCONF operation for a message,
derived from the HTTP method, request URI, header fields, and message-body.
 </t>
 <t>
operation resource: a resource that models a data-model-specific
operation that is in turn defined with a YANG &quot;rpc&quot; or
&quot;action&quot; statement. It is invoked with the POST method.
 </t>
 <t>
patch: a PATCH method on the target datastore
or data resource.
The media type of the message-body content will identify
the patch type in use.
 </t>
 <t>
plain patch: a specific media type for use with the PATCH method;
see <xref target="plain-patch"/>. It can be used for simple
&quot;merge&quot; edit operations. It is specified by a
request Content&nbhy;Type of
&quot;application&wj;/yang&#8209;data+xml&quot; or
&quot;application&wj;/yang&#8209;data+json&quot;.
 </t>
 <t>
query parameter: a parameter (and its value, if any),
encoded within the query component of the request URI.
 </t>
 <t>
resource type: one of the RESTCONF resource classes defined in
this document. One of &quot;api&quot;, &quot;datastore&quot;,
&quot;data&quot;, &quot;operation&quot;, &quot;schema&quot;, or
&quot;event stream&quot;.
 </t>
 <t>
RESTCONF capability: an optional RESTCONF protocol feature
that is advertised by a particular server if the feature is
supported on that server.  The feature is identified by an
IANA&nbhy;registered NETCONF Capability URI and advertised with
an entry in the &quot;capability&quot; leaf-list defined in
<xref target="mon-mod"/>.
 </t>
 <t>
RESTCONF client: a client that implements the RESTCONF protocol.
 </t>
 <t>
RESTCONF server: a server that implements the RESTCONF protocol.
 </t>
 <t>
retrieval request: a request using the GET or HEAD methods.
 </t>
 <t>
schema resource: a resource that is used by the client to retrieve
a YANG schema with the GET method. It has a representation
with the media type &quot;application/yang&quot;.
 </t>
 <t>
server: a RESTCONF server.
 </t>
 <t>
&quot;stream&quot; list: the set of data resource instances
that describe the event stream resources available from the server.
This information is defined in the
&quot;ietf&#8209;restconf&#8209;monitoring&quot; module as the
&quot;stream&quot; list. It can be retrieved using the target resource
&quot;{+restconf}/data/ietf&#8209;restconf&#8209;monitoring:restconf&#8209;state/streams/stream&quot;.
The &quot;stream&quot;&nbsp;list contains information about each stream,
such as the URL to retrieve the event stream data.
 </t>
 <t>
stream resource: an event stream resource.
 </t>
 <t>
target resource: the resource that is associated with
a particular message, identified by the &quot;path&quot; component
of the request URI.
 </t>
 <t>
yang-data extension: a YANG external statement that conforms
to the &quot;yang&#8209;data&quot; extension statement, found
in <xref target="module"/>. The yang&nbhy;data extension is used to
define YANG data structures that are meant to be used as
YANG data templates.  These data structures are not intended to be
implemented as part of a configuration datastore or as an operational
state within the server, so normal YANG data definition statements
cannot be used.
 </t>
 <t>
YANG data template: a schema for modeling protocol message components
as conceptual data structures using YANG.
This allows the messages to be defined in an encoding-independent manner.
Each YANG data template is defined with the
&quot;yang&#8209;data&quot; extension, found in <xref target="module"/>.
Representations of instances conforming to a particular YANG data template
can be defined for YANG. The XML representation is defined in
YANG version 1.1 <xref target="RFC7950"/> and supported with
the &quot;application/yang&#8209;data+xml&quot;  media type.
The JSON representation is defined in &quot;JSON Encoding of Data Modeled
with YANG&quot; <xref target="RFC7951"/> and supported with
the &quot;application&wj;/yang&#8209;data+json&quot; media type.
 </t>
 </list>
</t>
</section>

<section title="URI Template and Examples" anchor="uri-template">
    <t>
Throughout this document, the URI template <xref target="RFC6570"/> syntax
&quot;{+restconf}&quot; is used to refer to the RESTCONF root resource outside
of an example.  See <xref target="root-resource-discovery"/> for details.
    </t>
    <t>
For simplicity, all of the examples in this document use &quot;/restconf&quot;
as the discovered RESTCONF API root path.
Many of the examples throughout the document are based on the
&quot;example&#8209;jukebox&quot; YANG module defined in
<xref target="example-module"/>.
    </t>
    <t>
Many protocol header lines and message-body text
within examples throughout the document
are split into multiple lines for display purposes only.
When a line ends with a backslash (&quot;\&quot;) as the last character,
the line is wrapped for display purposes.  It is to be
considered to be joined to the next line by deleting the
backslash, the following line break,
and the leading whitespace of the next line.
    </t>
</section>
<section title="Tree Diagrams">
    <t>
A simplified graphical representation of the data model is used in
this document.  The meanings of the symbols in these diagrams are
as follows:
    </t>
<t>
 <list style="symbols">
 <t>
Brackets &quot;[&quot; and &quot;]&quot; enclose list keys.
 </t>
 <t>
Abbreviations before data node names: &quot;rw&quot; means configuration
data (read-write), &quot;ro&quot; means state data (read-only),
and &quot;x&quot; means operation resource (executable).
 </t>
 <t>
Symbols after data node names: &quot;?&quot; means an optional node,
&quot;!&quot; means a presence container, and &quot;*&quot; denotes a
list and leaf-list.
 </t>
 <t>
Parentheses enclose choice and case nodes, and case nodes are also
marked with a colon (&quot;:&quot;).
 </t>
 <t>
Ellipsis (&quot;...&quot;) stands for contents of subtrees that are not shown.
 </t>
 </list>
</t>
</section>
</section>
<section title="Subset of NETCONF Functionality">
    <t>
RESTCONF does not need to mirror the full functionality of the NETCONF
protocol, but it does need to be compatible with NETCONF.  RESTCONF
achieves this by implementing a subset of the interaction capabilities
provided by the NETCONF protocol -- for instance, by eliminating
datastores and explicit locking.
    </t>
    <t>
RESTCONF uses HTTP methods to implement the equivalent of NETCONF
operations, enabling basic CRUD operations on a hierarchy of
conceptual resources.
    </t>
    <t>
The HTTP POST, PUT, PATCH, and DELETE methods are used to
edit data resources represented by YANG data models.
These basic edit operations allow the running configuration
to be altered by a RESTCONF client.
    </t>
    <t>
RESTCONF is not intended to replace NETCONF, but rather to provide
an HTTP interface that follows Representational State Transfer (REST)
principles <xref target="REST-Dissertation"/> and is compatible with
the NETCONF datastore model.
    </t>
</section>
<section title="Data-Model-Driven API">
    <t>
RESTCONF combines the simplicity of HTTP with the predictability
and automation potential of a schema-driven API. Knowing the
YANG modules used by the server, a client can derive all
management resource URLs and the proper structure of all
RESTCONF requests and responses. This strategy obviates the need
for responses provided by the server to contain
Hypermedia as the Engine of Application State (HATEOAS) links,
originally described in Roy Fielding&apos;s doctoral dissertation
<xref target="REST-Dissertation"/>, because the client can
determine the links it needs from the YANG modules.
    </t>
    <t>
RESTCONF utilizes the YANG library <xref target="RFC7895"/>
to allow a client to discover the YANG module conformance information
for the server, in case the client wants to use it.
    </t>
    <t>
The server can optionally support the retrieval of the
YANG modules it uses, as identified in its YANG library.
See <xref target="schema-resource"/> for details.
    </t>
    <t>
The URIs for data-model-specific RPC operations and datastore content
are predictable, based on the YANG module definitions.
    </t>
    <t>
The RESTCONF protocol operates on a conceptual datastore defined with
the YANG data modeling language.  The server lists each YANG
module it supports using the &quot;ietf&#8209;yang&#8209;library&quot;
YANG module defined in <xref target="RFC7895"/>.
The server MUST implement the &quot;ietf&#8209;yang&#8209;library&quot;
module, which MUST identify all of the YANG modules used by the server,
in the &quot;modules&#8209;state/module&quot; list.
The conceptual datastore contents, data-model-specific
RPC operations, and event notifications are identified by this set of
YANG modules.
    </t>
    <t>
The classification of data as configuration data or
non&nbhy;configuration data is derived from the
YANG &quot;config&quot; statement. Behavior related to
the ordering of data is derived from the
YANG &quot;ordered&#8209;by&quot; statement. Non&nbhy;configuration data
is also called &quot;state data&quot;.
    </t>
    <t>
The RESTCONF datastore editing model is simple and direct,
similar to the behavior of the :writable-running
capability in NETCONF. Each RESTCONF edit of a data
resource within the datastore resource
is activated upon successful completion of the edit.
    </t>
</section>
<section title="Coexistence with NETCONF" anchor="netconf-coexistence">
    <t>
RESTCONF can be implemented on a device that supports
the NETCONF protocol.
    </t>
    <t>
The following figure shows the system components if a RESTCONF server
is co-located with a NETCONF server:
    </t>
        <figure>
            <artwork><![CDATA[
      +-----------+           +-----------------+
      |  Web app  | <-------> |                 |
      +-----------+  RESTCONF | network device  |
                              |                 |
      +-----------+           |   +-----------+ |
      | NETCONF   | <-------> |   | datastore | |
      | Client    |  NETCONF  |   |           | |
      +-----------+           |   +-----------+ |
                              +-----------------+
            ]]></artwork>
        </figure>
    <t>
The following figure shows the system components if a RESTCONF server
is implemented in a device that does not have a NETCONF server:
    </t>
        <figure>
            <artwork><![CDATA[
      +-----------+           +-----------------+
      |  Web app  | <-------> |                 |
      +-----------+  RESTCONF | network device  |
                              |                 |
                              +-----------------+
            ]]></artwork>
        </figure>
    <t>
There are interactions between the NETCONF protocol and RESTCONF protocol
related to edit operations.  It is possible that locks are in use on a
RESTCONF server, even though RESTCONF cannot manipulate locks.
In such a case, the RESTCONF protocol will not be granted write access to
data resources within a datastore.
    </t>
    <t>
If the NETCONF server supports :writable-running, all edits to configuration
nodes in {+restconf}/data are performed in the running configuration
datastore. The URI template &quot;{+restconf}&quot; is defined in <xref target="uri-template"/>.
    </t>
    <t>
Otherwise, if the device supports :candidate, all edits to
configuration nodes in {+restconf}/data are performed in the candidate
configuration datastore.  The candidate MUST be automatically committed to
running immediately after each successful edit. Any edits from other
sources that are in the candidate datastore will also be
committed. If a confirmed commit procedure is in progress by any
NETCONF client, then any new commit will act as the confirming
commit.  If the NETCONF server is expecting a
&quot;persist&#8209;id&quot; parameter to complete the confirmed
commit procedure, then the RESTCONF edit operation MUST fail with a
&quot;409 Conflict&quot; status-line. The error-tag
&quot;in&#8209;use&quot; is used in this case.
    </t>
    <t>
If the NETCONF server supports :startup, the RESTCONF server MUST
automatically update the non&nbhy;volatile startup configuration datastore,
after the &quot;running&quot; datastore has been altered as a
consequence of a RESTCONF edit operation.
    </t>
    <t>
If a datastore that would be modified by a RESTCONF operation has an
active lock from a NETCONF client, the RESTCONF edit operation MUST fail
with a &quot;409 Conflict&quot; status-line. The error-tag value
&quot;in&#8209;use&quot; is returned in this case.
    </t>
</section>
<section title="RESTCONF Extensibility">
    <t>
There are two extensibility mechanisms built into RESTCONF:
    </t>
<t>
 <list style="symbols">
 <t>
protocol version
 </t>
 <t>
optional capabilities
 </t>
 </list>
</t>
    <t>
This document defines version 1 of the RESTCONF protocol.
If a future version of this protocol is defined, then that document
will specify how the new version of RESTCONF is identified.
It is expected that a different RESTCONF root resource will be used,
which will be located using a different link relation
(see <xref target="root-resource-discovery"/>).
    </t>
    <t>
The server will advertise all protocol versions that it supports
in its host-meta data.
    </t>
    <t>
In this example, the server supports both RESTCONF version 1 and a
fictitious version 2.
    </t>
    <t>
The client might send the following:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /.well-known/host-meta HTTP/1.1
   Host: example.com
   Accept: application/xrd+xml
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Content-Type: application/xrd+xml
   Content-Length: nnn
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <XRD xmlns='http://docs.oasis-open.org/ns/xri/xrd-1.0'>
       <Link rel='restconf' href='/restconf'/>
       <Link rel='restconf2' href='/restconf2'/>
   </XRD>
            ]]></artwork>
        </figure>
    <t>
RESTCONF also supports a server-defined list of optional capabilities,
which are listed by a server using the
&quot;ietf&#8209;restconf&#8209;monitoring&quot; module
defined in <xref target="mon-mod"/>. This document defines
several query parameters in <xref target="query-parameters"/>.  Each
optional parameter has a corresponding capability URI,
defined in <xref target="query-parameter-uri"/>,
that is advertised by the server if supported.
    </t>
    <t>
The &quot;capability&quot; leaf-list can identify any sort of
server extension. Currently, this extension mechanism is used
to identify optional query parameters that are supported,
but it is not limited to that purpose.
For example, the &quot;defaults&quot; URI defined in
<xref target="defaults-uri"/> specifies a mandatory URI identifying
server default-handling behavior.
    </t>
    <t>
A new sub-resource type could be identified with a capability if
it is optional to implement.  Mandatory protocol features and
new resource types require a new revision of the RESTCONF protocol.
    </t>
</section>
</section>
<section title="Transport Protocol">
<section title="Integrity and Confidentiality" anchor="integ-and-conf">
    <t>
HTTP <xref target="RFC7230"/> is an application-layer protocol
that may be layered on any reliable transport-layer protocol.
RESTCONF is defined on top of HTTP, but due to the sensitive nature
of the information conveyed, RESTCONF requires that the
transport-layer protocol provide both data integrity and
confidentiality. A RESTCONF server MUST support the
Transport Layer Security (TLS) protocol <xref target="RFC5246"/> and SHOULD
adhere to <xref target="RFC7525"/>.  The RESTCONF protocol MUST NOT be
used over HTTP without using the TLS protocol.
    </t>
    <t>
RESTCONF does not require a specific version of HTTP.
However, it is RECOMMENDED that at least HTTP/1.1 <xref target="RFC7230"/>
be supported by all implementations.
    </t>
</section>
<section title="HTTPS with X.509v3 Certificates">
    <t>
Given the nearly ubiquitous support for HTTP over TLS <xref target="RFC7230"/>,
RESTCONF implementations MUST support the &quot;https&quot; URI scheme, which
has the IANA-assigned default port 443.
    </t>
    <t>
RESTCONF servers MUST present an X.509v3-based certificate when
establishing a TLS connection with a RESTCONF client.  The
use of X.509v3-based certificates is consistent with NETCONF over TLS
<xref target="RFC7589"/>.
    </t>
</section>
<section title="Certificate Validation">
    <t>
The RESTCONF client MUST either (1)&nbsp;use X.509 certificate path
validation <xref target="RFC5280"/> to verify the integrity of the
RESTCONF server&apos;s TLS certificate or (2)&nbsp;match the server&apos;s
TLS certificate with a certificate obtained by a trusted mechanism
(e.g., a pinned certificate).   If X.509 certificate path validation
fails and the presented X.509 certificate does not match a certificate
obtained by a trusted mechanism, the connection MUST be terminated, as
described in Section&nbsp;7.2.1 of <xref target="RFC5246"/>.
    </t>
</section>
<section title="Authenticated Server Identity">
    <t>
The RESTCONF client MUST check the identity of the server according
to Section&nbsp;3.1 of <xref target="RFC2818"/>.
    </t>
</section>
<section title="Authenticated Client Identity" anchor="auth-client-id">
    <t>
The RESTCONF server MUST authenticate client access to any
protected resource.   If the RESTCONF client is not authenticated,
the server SHOULD send an HTTP response with a
&quot;401 Unauthorized&quot; status-line, as defined
in Section&nbsp;3.1 of <xref target="RFC7235"/>. The error-tag value
&quot;access&#8209;denied&quot; is used in this case.
    </t>
    <t>
To authenticate a client, a RESTCONF server SHOULD require 
authentication based on TLS client certificates (Section&nbsp;7.4.6 of
<xref target="RFC5246"/>). If certificate-based authentication is not
feasible (e.g., because one cannot build the required PKI for clients),
then HTTP authentication MAY be used. In the latter case, one of the
HTTP authentication schemes defined in the
&quot;Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry&quot;
(Section&nbsp;5.1 in <xref target="RFC7235"/>) MUST be used.
    </t>
    <t>
A server MAY also support the combination of both client
certificates and an HTTP client authentication scheme,
with the determination of how to process this combination
left as an implementation decision.
    </t>
    <t>
The RESTCONF client identity derived from the authentication
mechanism used is hereafter known as the &quot;RESTCONF username&quot; and
subject to the NETCONF Access Control Model (NACM) <xref target="RFC6536"/>.
When a client certificate is presented, the RESTCONF username
MUST be derived using the algorithm defined
in Section&nbsp;7 of <xref target="RFC7589"/>. For all other cases,
when HTTP authentication is used, the RESTCONF username MUST be
provided by the HTTP authentication scheme used.
    </t>
</section>
</section>
<section title="Resources" anchor="resources">
    <t>
The RESTCONF protocol operates on a hierarchy of resources, starting
with the top-level API resource itself
(<xref target="root-resource-discovery"/>). Each resource represents a manageable
component within the device.
    </t>
    <t>
A resource can be considered as a collection of data and the
set of allowed methods on that data.  It can contain nested child
resources.  The child resource types and the methods allowed on them are
specific to the data model.
    </t>
    <t>
A resource has a representation associated with a media type identifier,
as represented by the &quot;Content&#8209;Type&quot; header field
in the HTTP response message. A resource has one or more
representations, each associated with a different media type.  When
a representation of a resource is sent in an HTTP message, the
associated media type is given in the &quot;Content&#8209;Type&quot; header.
A resource can contain zero or more nested resources.
A resource can be created and deleted independently of its
parent resource, as long as the parent resource exists.
    </t>
    <t>
The RESTCONF resources are accessed via a set of
URIs defined in this document.
The set of YANG modules supported by the server
will determine the data-model-specific RPC operations,
top-level data nodes, and event notification messages
supported by the server.
    </t>
    <t>
The RESTCONF protocol does not include a
data resource discovery mechanism.  Instead, the definitions
within the YANG modules advertised by the server
are used to construct an RPC operation or data
resource identifier.
    </t>
<section title="Root Resource Discovery" anchor="root-resource-discovery">
    <t>
In line with the best practices defined by <xref target="RFC7320"/>, RESTCONF
enables deployments to specify where the RESTCONF API is located.
When first connecting to a RESTCONF server, a RESTCONF client MUST
determine the root of the RESTCONF API.  There MUST be exactly
one &quot;restconf&quot; link relation returned by the device.
    </t>
    <t>
The client discovers this
by getting the &quot;/.well&#8209;known/host&#8209;meta&quot; resource
(<xref target="RFC6415"/>) and using the &lt;Link&gt; element containing
the &quot;restconf&quot; attribute:
    </t>
    <t>
Example returning /restconf:
    </t>
    <t>
The client might send the following:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /.well-known/host-meta HTTP/1.1
   Host: example.com
   Accept: application/xrd+xml
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Content-Type: application/xrd+xml
   Content-Length: nnn
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <XRD xmlns='http://docs.oasis-open.org/ns/xri/xrd-1.0'>
       <Link rel='restconf' href='/restconf'/>
   </XRD>
            ]]></artwork>
        </figure>
    <t>
After discovering the RESTCONF API root, the client MUST use
this value as the initial part of the path
in the request URI, in any subsequent request for a RESTCONF resource.
    </t>
    <t>
In this example, the client would use the path &quot;/restconf&quot;
as the RESTCONF root resource.
    </t>
    <t>
Example returning /top/restconf:
    </t>
    <t>
The client might send the following:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /.well-known/host-meta HTTP/1.1
   Host: example.com
   Accept: application/xrd+xml
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Content-Type: application/xrd+xml
   Content-Length: nnn
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <XRD xmlns='http://docs.oasis-open.org/ns/xri/xrd-1.0'>
       <Link rel='restconf' href='/top/restconf'/>
   </XRD>
            ]]></artwork>
        </figure>
    <t>
In this example, the client would use the path &quot;/top/restconf&quot;
as the RESTCONF root resource.
    </t>
    <t>
The client can now determine the operation resources supported by
the server. In this example, a custom &quot;play&quot; operation
is supported:
    </t>
    <t>
The client might send the following:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /top/restconf/operations HTTP/1.1
   Host: example.com
   Accept: application/yang-data+json
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>

        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Last-Modified: Thu, 26 Jan 2017 16:00:14 GMT
   Content-Type: application/yang-data+json

   { "operations" : { "example-jukebox:play" : [null] } }
            ]]></artwork>
        </figure>
    <t>
If the Extensible Resource Descriptor (XRD)
contains more than one link relation, then only the
relation named &quot;restconf&quot; is relevant to this specification.
    </t>
    <t>
Note that any given endpoint (host:port)
can only support one RESTCONF server,
due to the root resource discovery mechanism.
This limits the number of RESTCONF servers that can run
concurrently on a host, since each server must use a different port.
    </t>
</section>
<section title="RESTCONF Media Types">
    <t>
The RESTCONF protocol defines two application-specific media
types to identify representations of data that conforms to
the schema for a particular YANG construct.
    </t>
    <t>
This document defines media types for XML and JSON serialization
of&nbsp;YANG data.  Other documents MAY define other media types for
different serializations of YANG data.
The &quot;application&wj;/yang&#8209;data+xml&quot; media&nbsp;type is
defined in <xref target="yang-data-xml"/>.
The &quot;application/yang&#8209;data+json&quot; media&nbsp;type is
defined in <xref target="yang-data-json"/>.
    </t>
</section>
<section title="API Resource" anchor="api-resource">
    <t>
The API resource contains the RESTCONF root resource for
the RESTCONF datastore and operation resources.
It is the top-level resource located at {+restconf} and has the media type
&quot;application&wj;/yang&#8209;data+xml&quot;
or &quot;application/yang&#8209;data+json&quot;.
    </t>
    <t>
YANG tree diagram for an API resource:
    </t>
        <figure>
            <artwork><![CDATA[
  +---- {+restconf}
        +---- data
        | ...
        +---- operations?
        | ...
        +--ro yang-library-version    string
            ]]></artwork>
        </figure>
    <t>
The &quot;yang&#8209;api&quot; YANG data template is defined using
the &quot;yang&#8209;data&quot; extension
in the &quot;ietf&#8209;restconf&quot; module,
found in <xref target="module"/>.
It specifies the structure and syntax
of the conceptual child resources within the API resource.
    </t>
    <t>
The API resource can be retrieved with the GET method.
    </t>
    <t>
The {+restconf} root resource name used in responses
representing the root of the &quot;ietf&#8209;restconf&quot; module
MUST identify the &quot;ietf&#8209;restconf&quot; YANG module.
For example, a request to GET the root resource &quot;/restconf&quot;
in JSON format will return a representation of
the API resource named &quot;ietf&#8209;restconf:restconf&quot;.
    </t>
    <t>
This resource has the following child resources:
    </t>

<?rfc compact="yes"?>
<texttable title="RESTCONF API Resource">
<ttcol align='left'> Child Resource</ttcol>
<ttcol align='left'>Description</ttcol>
<c>data</c>
<c>Contains all data resources</c>
<c>operations</c>
<c>Data-model-specific operations</c>
<c>yang-library-version</c>
<c>&quot;ietf-yang-library&quot; module date</c>
</texttable>
<?rfc compact="no"?>

<section title="{+restconf}/data">
    <t>
This mandatory resource represents the combined configuration
and state data resources that can be accessed by a client.
It cannot be created or deleted by the client.
The datastore resource type is defined in <xref target="datastore-resource"/>.
    </t>
    <t>
Example:
    </t>
    <t>
This example request by the client
would retrieve only the non&nbhy;configuration data nodes
that exist within the &quot;library&quot; resource, using the &quot;content&quot;
query parameter (see <xref target="content"/>).
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf/data/example-jukebox:jukebox/library\
       ?content=nonconfig HTTP/1.1
   Host: example.com
   Accept: application/yang-data+xml
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <library xmlns="https://example.com/ns/example-jukebox">
     <artist-count>42</artist-count>
     <album-count>59</album-count>
     <song-count>374</song-count>
   </library>
            ]]></artwork>
        </figure>
</section>
<section title="{+restconf}/operations" anchor="restconf-operations">
    <t>
This optional resource is a container that provides access to the
data-model-specific RPC operations supported by the server.
The server MAY omit this resource if no data-model-specific
RPC operations are advertised.
    </t>
    <t>
Any data-model-specific RPC operations defined in the YANG
modules advertised by the server MUST be available as child nodes of
this resource.
    </t>
    <t>
The access point for each RPC operation is represented as
an empty leaf.  If an operation resource is retrieved,
the empty leaf representation is returned by the server.
    </t>
    <t>
Operation resources are defined in <xref target="operation-resource"/>.
    </t>
</section>
<section title="{+restconf}/yang-library-version" anchor="library-version">

    <t>
This mandatory leaf identifies the revision date of
the &quot;ietf&#8209;yang&#8209;library&quot; YANG module that is
implemented by this server.  In the example that follows,
the revision date for the module version found in
<xref target="RFC7895"/> is used.
    </t>
    <t>
Example:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf/yang-library-version HTTP/1.1
   Host: example.com
   Accept: application/yang-data+xml
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <yang-library-version
     xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf">\
     2016-06-21\
   </yang-library-version>
            ]]></artwork>
        </figure>
</section>
</section>
<section title="Datastore Resource" anchor="datastore-resource">
    <t>
The &quot;{+restconf}/data&quot; subtree represents the datastore resource,
which is a collection of configuration data and state data nodes.
    </t>
    <t>
This resource type is an abstraction of the system&apos;s underlying datastore
implementation. The client uses it to edit and retrieve data resources,
as the conceptual root of all configuration and state data
that is present on the device.
    </t>
    <t>
Configuration edit transaction management and configuration persistence
are handled by the server and not controlled by the client.
A datastore resource can be written directly with
the POST and PATCH methods. Each RESTCONF edit of a datastore resource is
saved to non&nbhy;volatile storage by the server if the server supports
non&nbhy;volatile storage of configuration data,
as described in <xref target="netconf-coexistence"/>.
    </t>
    <t>
If the datastore resource represented by the
&quot;{+restconf}/data&quot; subtree is retrieved, then the
datastore and its contents are returned by the server. The datastore
is represented by a node named &quot;data&quot; in the
&quot;ietf&#8209;restconf&quot; module namespace.
    </t>
<section title="Edit Collision Prevention" anchor="edit-collision">
    <t>
Two edit collision detection and prevention mechanisms are provided
in RESTCONF for the datastore resource: a timestamp and an entity&nbhy;tag.
Any change to configuration data resources updates the timestamp
and entity&nbhy;tag of the datastore resource.
In addition, the RESTCONF server MUST return an error if
the datastore is locked by an external source (e.g., NETCONF server).
    </t>
<section title="Timestamp">
    <t>
The last change time is maintained, and
the &quot;Last&#8209;Modified&quot; header field (Section&nbsp;2.2 of <xref target="RFC7232"/>)
is returned in the response for a
retrieval request. The &quot;If&#8209;Unmodified&#8209;Since&quot;
header field (Section&nbsp;3.4 of <xref target="RFC7232"/>) can be used
in edit operation requests to cause the server
to reject the request if the resource has been modified
since the specified timestamp.
    </t>
    <t>
The server SHOULD maintain a last-modified timestamp for the
datastore resource, defined in <xref target="datastore-resource"/>.
This timestamp is only affected by configuration
child data resources and MUST NOT be updated
for changes to non&nbhy;configuration child data resources.
Last&nbhy;modified timestamps for data resources are discussed
in <xref target="data-resource"/>.
    </t>
    <t>
If the RESTCONF server is co&nbhy;located with a NETCONF server, then the
last-modified timestamp MUST be for the &quot;running&quot; datastore.
Note that it is possible that other protocols can cause the last-modified
timestamp to be updated.  Such mechanisms are out of scope
for this document.
    </t>
</section>
<section title="Entity-Tag">
    <t>
The server MUST maintain a unique opaque entity-tag for the
datastore resource and MUST return it in the &quot;ETag&quot;
(Section&nbsp;2.3 of <xref target="RFC7232"/>) header in the response
for a retrieval request.  The client MAY use an &quot;If&#8209;Match&quot;
header in edit operation requests to cause the server to reject the request
if the resource entity-tag does not match the specified value.
    </t>
    <t>
The server MUST maintain an entity-tag for the
top-level {+restconf}/data resource. This entity-tag is only
affected by configuration data resources and MUST NOT be updated
for changes to non&nbhy;configuration data.
Entity-tags for data resources are discussed in <xref target="data-resource"/>.
Note that each representation (e.g., XML vs. JSON) requires a
different entity-tag.
    </t>
    <t>
If the RESTCONF server is co&nbhy;located with a NETCONF server,
then this entity-tag MUST be for the &quot;running&quot; datastore.
Note that it is possible that other protocols can cause the entity&nbhy;tag
to be updated.  Such mechanisms are out of scope for this document.
    </t>
</section>
<section title="Update Procedure">
    <t>
Changes to configuration data resources affect the timestamp
and entity-tag for that resource, any ancestor data resources,
and the datastore resource.
    </t>
    <t>
For example, an edit to disable an interface might be
done by setting the leaf &quot;/interfaces/interface/enabled&quot; to
&quot;false&quot;. The &quot;enabled&quot; data node and its ancestors
(one &quot;interface&quot; list instance, and the
&quot;interfaces&quot; container) are considered to be changed. The
datastore is considered to be changed when any top-level configuration
data node is changed (e.g., &quot;interfaces&quot;).
    </t>
</section>
</section>
</section>
<section title="Data Resource" anchor="data-resource">
    <t>
A data resource represents a YANG data node that is a descendant
node of a datastore resource.  Each YANG-defined data node can be uniquely
targeted by the request-line of an HTTP method.  Containers,
leafs, leaf-list entries, list entries, anydata nodes, and
anyxml nodes are data resources.
    </t>
    <t>
The representation maintained for each data resource is the
YANG&nbhy;defined subtree for that node.  HTTP methods on a data
resource affect both the targeted data node and all of its
descendants, if&nbsp;any.
    </t>
    <t>
A data resource can be retrieved with the GET method.
Data resources are accessed via the &quot;{+restconf}/data&quot; URI.
This subtree is used to retrieve and edit data resources.
    </t>
<section title="Timestamp">
    <t>
For configuration data resources, the server MAY maintain a
last&nbhy;modified timestamp for the resource and return the
&quot;Last&#8209;Modified&quot; header field when it is
retrieved with the GET or HEAD methods.
    </t>
    <t>
The &quot;Last&#8209;Modified&quot; header field can be used by a
RESTCONF client in subsequent requests, within the
&quot;If&#8209;Modified&#8209;Since&quot; and
&quot;If&#8209;Unmodified&#8209;Since&quot; header fields.
    </t>
    <t>
If maintained, the resource timestamp MUST be set to the current
time whenever the resource
or any configuration resource within the resource is altered.
If not maintained, then the resource timestamp for the datastore
MUST be used instead.
If the RESTCONF server is co&nbhy;located with a NETCONF server, then the
last-modified timestamp for a configuration data resource MUST represent
the instance within the &quot;running&quot; datastore.
    </t>
    <t>
This timestamp is only
affected by configuration data resources and MUST NOT be updated
for changes to non&nbhy;configuration data.
    </t>
</section>
<section title="Entity-Tag">
    <t>
For configuration data resources,
the server SHOULD maintain a resource entity-tag for each
resource and return the &quot;ETag&quot; header field when it
is retrieved as the target resource with the GET or HEAD methods.
If maintained, the resource entity-tag MUST be updated
whenever the resource
or any configuration resource within the resource is altered.
If not maintained, then the resource entity-tag for the datastore
MUST be used instead.
    </t>
    <t>
The &quot;ETag&quot; header field can be used by a
RESTCONF client in subsequent requests, within the &quot;If&#8209;Match&quot;
and &quot;If&#8209;None&#8209;Match&quot; header fields.
    </t>
    <t>
This entity-tag is only
affected by configuration data resources and MUST NOT be updated
for changes to non&nbhy;configuration data.
If the RESTCONF server is co&nbhy;located with a NETCONF server, then the
entity&nbhy;tag for a configuration data resource MUST represent
the instance within the &quot;running&quot; datastore.
    </t>
</section>
<section title="Encoding Data Resource Identifiers in the Request URI" anchor="uri-encoding">
    <t>
In YANG, data nodes can be identified with an absolute
XPath expression, defined in <xref target="XPath"/>, starting
from the document root to the target resource.
In RESTCONF, URI-encoded path expressions are used instead.
    </t>
    <t>
A predictable location for a data resource
is important, since applications will code to the YANG
data model module, which uses static naming and defines an
absolute path location for all data nodes.
    </t>
    <t>
A RESTCONF data resource identifier is encoded from left to right,
starting with the top-level data node, according to the
&quot;api&#8209;path&quot; rule in <xref target="path-abnf"/>.  The
node name of each ancestor of the target resource node is encoded
in order, ending with the node name for the target resource.  If a
node in the path is defined in a module other than its parent node
or its parent is the datastore, then the module name followed by a
colon character (&quot;:&quot;) MUST be prepended to the node name in
the resource identifier.  See <xref target="path-abnf"/> for details.
    </t>
    <t>
If a data node in the path expression is a YANG leaf-list node,
then the leaf-list value MUST be encoded according to the following rules:
    </t>
<t>
 <list style="symbols">
 <t>
The identifier for the leaf-list MUST be encoded
using one path segment <xref target="RFC3986"/>.
 </t>
 <t>
The path segment is constructed by having the leaf-list name, followed
by an &quot;=&quot; character, followed by the leaf-list value
(e.g., /restconf/data/top-leaflist=fred).
 </t>
 <t>
The leaf-list value is specified as a string, using the
canonical representation for the YANG data type.
Any reserved characters MUST be percent-encoded,
according to Sections&nbsp;2.1 and 2.5 of <xref target="RFC3986"/>.
 </t>
 <t>
YANG 1.1 allows duplicate leaf-list values
for non&nbhy;configuration data. In this case, there is no
mechanism to specify the exact matching leaf-list instance.
 </t>
 <t>
The comma (&quot;,&quot;) character is
percent-encoded <xref target="RFC3986"/>,
even though multiple key values are not possible for a leaf-list.
This is more consistent and avoids special processing rules.
 </t>
 </list>
</t>
    <t>
If a data node in the path expression is a YANG list node,
then the key values for the list (if any) MUST be encoded
according to the following rules:
    </t>
<t>
 <list style="symbols">
 <t>
The key leaf values for a data resource representing a YANG
list MUST be encoded using one path segment <xref target="RFC3986"/>.
 </t>
 <t>
If there is only one key leaf value, the path segment is constructed
by having the list name, followed by an &quot;=&quot; character,
followed by the single key leaf value.
 </t>
 <t>
If there are multiple key leaf values,
the path segment is constructed by having the list name,
followed by the value of each leaf
identified in the &quot;key&quot; statement, encoded
in the order specified in the YANG &quot;key&quot; statement.
Each key leaf value except the last one is followed by a comma
character.
 </t>
 <t>
The key value is specified as a string, using the
canonical representation for the YANG data type.
Any reserved characters MUST be percent-encoded,
according to Sections&nbsp;2.1 and 2.5 of <xref target="RFC3986"/>.
The comma (&quot;,&quot;) character MUST be percent-encoded if it is
present in the key value.
 </t>
 <t>
All of the components in the &quot;key&quot; statement MUST be encoded.
Partial instance identifiers are not supported.
 </t>
 <t>
Missing key values are not allowed,
so two consecutive commas are interpreted as
a comma, followed by a zero-length string, followed by a comma.
For example, &quot;list1=foo,,baz&quot; would be interpreted as a
list named &quot;list1&quot; with three key values,
and the second key value is a zero-length string.
 </t>
 <t>
Note that non&nbhy;configuration lists are not required to define keys.
In this case, a single list instance cannot be accessed.
 </t>
 <t>
The &quot;list&#8209;instance&quot; Augmented Backus-Naur Form
(ABNF) <xref target="RFC5234"/> rule defined in
<xref target="path-abnf"/> represents the syntax of a
list instance identifier.
 </t>
 </list>
</t>
    <t>
Examples:
    </t>
        <figure>
            <artwork><![CDATA[
   container top {
       list list1 {
           key "key1 key2 key3";
            ...
            list list2 {
                key "key4 key5";
                ...
                leaf X { type string; }
            }
        }
        leaf-list Y {
          type uint32;
        }
    }
            ]]></artwork>
        </figure>
    <t>
For the above YANG definition, the container &quot;top&quot; is defined in
the &quot;example&#8209;top&quot; YANG module, and a target resource URI
for leaf &quot;X&quot; would be encoded as follows:
    </t>
        <figure>
            <artwork><![CDATA[
    /restconf/data/example-top:top/list1=key1,key2,key3/\
       list2=key4,key5/X
            ]]></artwork>
        </figure>
    <t>
For the above YANG definition, a target resource URI for
leaf&nbhy;list&nbsp;&quot;Y&quot; would be encoded as follows:
    </t>
        <figure>
            <artwork><![CDATA[
    /restconf/data/example-top:top/Y=instance-value
            ]]></artwork>
        </figure>
    <t>
The following example shows how reserved characters are
percent-encoded within a key value.  The value of &quot;key1&quot; contains a
comma, single-quote, double-quote, colon, double-quote, space, and
forward slash (,&apos;&quot;:&quot; /).  Note that double-quote is not a
reserved character and does not need to be percent-encoded.  The value of
&quot;key2&quot; is the empty string, and the value of &quot;key3&quot; is
the string &quot;foo&quot;.
    </t>
    <t>
Example URL:
    </t>
        <figure>
            <artwork><![CDATA[
   /restconf/data/example-top:top/list1=%2C%27"%3A"%20%2F,,foo
            ]]></artwork>
        </figure>
<section title="ABNF for Data Resource Identifiers" anchor="path-abnf">
    <t>
The &quot;api&#8209;path&quot; ABNF <xref target="RFC5234"/> syntax
is used to construct RESTCONF path identifiers.
Note that this syntax is used for all resources,
and the API path starts with the RESTCONF root resource.
Data resources are required to be identified under
the &quot;{+restconf}/data&quot; subtree.
    </t>
    <t>
An identifier is not allowed to start with the case-insensitive
string &quot;XML&quot;, according to YANG identifier rules.
The syntax for &quot;api&#8209;identifier&quot; and &quot;key&#8209;value&quot; MUST conform to the
JSON identifier encoding rules in Section&nbsp;4 of <xref target="RFC7951"/>:
The RESTCONF root resource path is required.
Additional sub-resource identifiers are optional.
The characters in a key value string are constrained,
and some characters need to be percent-encoded,
as described in <xref target="uri-encoding"/>.
    </t>
        <figure>
            <artwork><![CDATA[
api-path = root *("/" (api-identifier / list-instance))

root = string  ;; replacement string for {+restconf}

api-identifier = [module-name ":"] identifier

module-name = identifier

list-instance = api-identifier "=" key-value *("," key-value)

key-value = string  ;; constrained chars are percent-encoded

string = <an unquoted string>

identifier = (ALPHA / "_")
             *(ALPHA / DIGIT / "_" / "-" / ".")
            ]]></artwork>
        </figure>
</section>
</section>
<section title="Default Handling">
    <t>
RESTCONF requires that a server report its default-handling mode
(see <xref target="defaults-uri"/> for details).  If the optional &quot;with&#8209;defaults&quot; query
parameter is supported by the server, a client may use it to control
the retrieval of default values  (see <xref target="with-defaults"/> for details).
    </t>
    <t>
If a leaf or leaf-list is missing from the configuration
and there is a YANG-defined default for that data resource, then
the server MUST use the YANG-defined default as the configured value.
    </t>
    <t>
If the target of a GET method is a data node that represents a leaf
or leaf-list that has a default value and the leaf or leaf-list has not
been instantiated yet, the server MUST return the default value or
values that are in use by the server. In this case, the server MUST
ignore its &quot;basic&nbhy;mode&quot;, described
in <xref target="with-defaults"/>, and return the default value.
    </t>
    <t>
If the target of a GET method is a data node
that represents a container or list that has any child resources
with default values, for the child resources that have not been given
values yet, the server MAY return the default values that are in use
by the server in accordance with its reported default-handling mode
and query parameters passed by the client.
    </t>
</section>
</section>
<section title="Operation Resource" anchor="operation-resource">
    <t>
An operation resource represents an RPC operation
defined with the YANG &quot;rpc&quot; statement or a data-model-specific
action defined with a YANG &quot;action&quot; statement.
It is invoked using a POST method on the operation resource.
    </t>
    <t>
An RPC operation is invoked as:
    </t>
        <figure>
            <artwork><![CDATA[
   POST {+restconf}/operations/<operation>
            ]]></artwork>
        </figure>
    <t>
The &lt;operation&gt; field identifies the module name and rpc identifier
string for the desired operation.
    </t>
    <t>
For example, if &quot;module&#8209;A&quot; defined a &quot;reset&quot;
RPC operation, then invoking the operation would be requested as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   POST /restconf/operations/module-A:reset HTTP/1.1
   Server: example.com
            ]]></artwork>
        </figure>
    <t>
An action is invoked as:
    </t>
        <figure>
            <artwork><![CDATA[
   POST {+restconf}/data/<data-resource-identifier>/<action>
            ]]></artwork>
        </figure>
    <t>
where &lt;data&#8209;resource&#8209;identifier&gt; contains the path to the data node
where the action is defined, and &lt;action&gt; is the name of the
action.
    </t>
    <t>
For example, if &quot;module&#8209;A&quot; defined a &quot;reset&#8209;all&quot; action in the
container &quot;interfaces&quot;, then invoking this action would be requested
as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   POST /restconf/data/module-A:interfaces/reset-all HTTP/1.1
   Server: example.com
            ]]></artwork>
        </figure>
    <t>
If the RPC operation is invoked without errors and if the
&quot;rpc&quot; or &quot;action&quot; statement has no
&quot;output&quot; section, the response message MUST&nbsp;NOT
include a message-body and MUST send a &quot;204 No Content&quot;
status&nbhy;line instead.
    </t>
    <t>
All operation resources representing RPC operations
supported by the server MUST be identified
in the &quot;{+restconf}/operations&quot; subtree,
defined in <xref target="restconf-operations"/>.
Operation resources representing YANG actions are not
identified in this subtree, since they are invoked
using a URI within the &quot;{+restconf}/data&quot; subtree.
    </t>
<section title="Encoding Operation Resource Input Parameters" anchor="example-ops-mod">
    <t>
If the &quot;rpc&quot; or &quot;action&quot; statement has an
&quot;input&quot; section, then instances of these input parameters
are encoded in the module namespace where the &quot;rpc&quot; or
&quot;action&quot; statement is defined, in an XML element
or JSON object named &quot;input&quot;, which is in the
module namespace where the &quot;rpc&quot; or
&quot;action&quot; statement is defined.
    </t>
    <t>
If the &quot;rpc&quot; or &quot;action&quot; statement has an
&quot;input&quot; section and the &quot;input&quot; object tree
contains any child data nodes that are considered mandatory nodes,
then a message-body MUST be sent by the client in the request.
    </t>
    <t>
If the &quot;rpc&quot; or &quot;action&quot; statement has an
&quot;input&quot; section and the &quot;input&quot; object tree
does not contain any child nodes that are considered mandatory nodes,
then a message-body MAY be sent by the client in the request.
    </t>
    <t>
If the &quot;rpc&quot; or &quot;action&quot; statement has no
&quot;input&quot; section, the request message MUST NOT include a
message-body.
    </t>
    <t>
Examples:
    </t>
    <t>
The following YANG module is used for the RPC operation
examples in this section.
    </t>
        <figure>
            <artwork><![CDATA[
module example-ops {
  namespace "https://example.com/ns/example-ops";
  prefix "ops";

  organization "Example, Inc.";
  contact "support at example.com";
  description "Example Operations Data Model Module.";
  revision "2016-07-07" {
    description "Initial version.";
    reference "example.com document 3-3373.";
  }

  rpc reboot {
    description "Reboot operation.";
    input {
      leaf delay {
        type uint32;
        units "seconds";
        default 0;
        description
          "Number of seconds to wait before initiating the
           reboot operation.";
      }
      leaf message {
        type string;
        description
          "Log message to display when reboot is started.";
      }
      leaf language {
        type string;
        description "Language identifier string.";
        reference "RFC 5646.";
      }
    }
  }

  rpc get-reboot-info {
    description
      "Retrieve parameters used in the last reboot operation.";
    output {
      leaf reboot-time {
        type uint32;
        description
          "The 'delay' parameter used in the last reboot
           operation.";
      }
      leaf message {
        type string;
        description
          "The 'message' parameter used in the last reboot
           operation.";
      }
      leaf language {
        type string;
        description
          "The 'language' parameter used in the last reboot
           operation.";
      }
    }
  }
}
            ]]></artwork>
        </figure>
    <t>
The following YANG module is used for the YANG action
examples in this section.
    </t>
        <figure>
            <artwork><![CDATA[
module example-actions {
  yang-version 1.1;
  namespace "https://example.com/ns/example-actions";
  prefix "act";
  import ietf-yang-types { prefix yang; }

  organization "Example, Inc.";
  contact "support at example.com";
  description "Example Actions Data Model Module.";
  revision "2016-07-07" {
    description "Initial version.";
    reference "example.com document 2-9973.";
  }

  container interfaces {
    description "System interfaces.";
    list interface {
      key name;
      description "One interface entry.";
      leaf name {
        type string;
        description "Interface name.";
      }

      action reset {
        description "Reset an interface.";
        input {
          leaf delay {
            type uint32;
            units "seconds";
            default 0;
            description
              "Number of seconds to wait before starting the
               interface reset.";
          }
        }
      }

      action get-last-reset-time {
        description
          "Retrieve the last interface reset time.";
        output {
          leaf last-reset {
            type yang:date-and-time;
            mandatory true;
            description
              "Date and time of the last interface reset, or
               the last reboot time of the device.";
          }
        }
      }
    }
  }

}
            ]]></artwork>
        </figure>
    <t>
RPC Input Example:
    </t>
    <t>
The client might send the following POST request message
to invoke the &quot;reboot&quot; RPC operation:
    </t>
        <figure>
            <artwork><![CDATA[
   POST /restconf/operations/example-ops:reboot HTTP/1.1
   Host: example.com
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <input xmlns="https://example.com/ns/example-ops">
    <delay>600</delay>
    <message>Going down for system maintenance</message>
    <language>en-US</language>
   </input>
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
            ]]></artwork>
        </figure>
    <t>
The same example request message is shown here using JSON encoding:
    </t>
        <figure>
            <artwork><![CDATA[
   POST /restconf/operations/example-ops:reboot HTTP/1.1
   Host: example.com
   Content-Type: application/yang-data+json

   {
     "example-ops:input" : {
       "delay" : 600,
       "message" : "Going down for system maintenance",
       "language" : "en-US"
     }
   }
            ]]></artwork>
        </figure>
    <t>
Action Input Example:
    </t>
    <t>
The client might send the following POST request message
to invoke the &quot;reset&quot; action:
    </t>
        <figure>
            <artwork><![CDATA[
   POST /restconf/data/example-actions:interfaces/\
      interface=eth0/reset HTTP/1.1
   Host: example.com
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <input xmlns="https://example.com/ns/example-actions">
     <delay>600</delay>
   </input>
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
            ]]></artwork>
        </figure>
    <t>
The same example request message is shown here using JSON encoding:
    </t>
        <figure>
            <artwork><![CDATA[
   POST /restconf/data/example-actions:interfaces/\
     interface=eth0/reset HTTP/1.1
   Host: example.com
   Content-Type: application/yang-data+json

   { "example-actions:input" : {
       "delay" : 600
     }
   }
            ]]></artwork>
        </figure>
</section>
<section title="Encoding Operation Resource Output Parameters">
    <t>
If the &quot;rpc&quot; or &quot;action&quot; statement has an
&quot;output&quot; section, then instances of these output parameters
are encoded in the module namespace where the &quot;rpc&quot; or
&quot;action&quot; statement is defined,
in an XML element or JSON object named &quot;output&quot;,
which is in the module namespace where the &quot;rpc&quot;
or &quot;action&quot; statement is defined.
    </t>
    <t>
If the RPC operation is invoked without errors,
and if the &quot;rpc&quot; or &quot;action&quot; statement has an &quot;output&quot; section and the
&quot;output&quot; object tree contains any child data nodes that are considered
mandatory nodes, then a response message-body MUST be sent by the server in the response.
    </t>
    <t>
If the RPC operation is invoked without errors,
and if the &quot;rpc&quot; or &quot;action&quot; statement has an &quot;output&quot; section and the
&quot;output&quot; object tree does not contain any child nodes that are
considered mandatory nodes, then a response message-body
MAY be sent by the server in the response.
    </t>
    <t>
The request URI is not returned in the response.
Knowledge of the request URI may be needed to associate
the output with the specific &quot;rpc&quot; or &quot;action&quot;
statement used in the request.
    </t>
    <t>
Examples:
    </t>
    <t>
RPC Output Example:
    </t>
    <t>
The &quot;example&#8209;ops&quot; YANG module
defined in <xref target="example-ops-mod"/>
is used for this example.
    </t>
    <t>
The client might send the following POST request message
to invoke the &quot;get&#8209;reboot&#8209;info&quot; operation:
    </t>
        <figure>
            <artwork><![CDATA[
   POST /restconf/operations/example-ops:get-reboot-info HTTP/1.1
   Host: example.com
   Accept: application/yang-data+json
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Content-Type: application/yang-data+json

   {
     "example-ops:output" : {
       "reboot-time" : 30,
       "message" : "Going down for system maintenance",
       "language" : "en-US"
     }
   }
            ]]></artwork>
        </figure>
    <t>
The same response is shown here using XML encoding:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <output xmlns="https://example.com/ns/example-ops">
     <reboot-time>30</reboot-time>
     <message>Going down for system maintenance</message>
     <language>en-US</language>
   </output>
            ]]></artwork>
        </figure>
    <t>
Action Output Example:
    </t>
    <t>
The &quot;example&#8209;actions&quot; YANG module
defined in <xref target="example-ops-mod"/>
is used for this example.
    </t>
    <t>
The client might send the following POST request message
to invoke the &quot;get&#8209;last&#8209;reset&#8209;time&quot; action:
    </t>
        <figure>
            <artwork><![CDATA[
   POST /restconf/data/example-actions:interfaces/\
      interface=eth0/get-last-reset-time HTTP/1.1
   Host: example.com
   Accept: application/yang-data+json
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Content-Type: application/yang-data+json

   {
     "example-actions:output" : {
       "last-reset" : "2015-10-10T02:14:11Z"
     }
   }
            ]]></artwork>
        </figure>
</section>
<section title="Encoding Operation Resource Errors" anchor="op-resource-errors">
    <t>
If any errors occur while attempting to invoke the operation
or action, then an &quot;errors&quot; media type is returned with the
appropriate error status.
    </t>
    <t>
If (1) the RPC operation input is not valid or (2) the RPC operation is
invoked but errors occur, then a message-body containing an
&quot;errors&quot; resource MUST be sent by the server, as defined
in <xref target="errors-media-type"/>.
    </t>
    <t>
Using the &quot;reboot&quot; RPC operation from the example in
<xref target="example-ops-mod"/>,
the client might send the following POST request message:
    </t>
        <figure>
            <artwork><![CDATA[
   POST /restconf/operations/example-ops:reboot HTTP/1.1
   Host: example.com
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <input xmlns="https://example.com/ns/example-ops">
     <delay>-33</delay>
     <message>Going down for system maintenance</message>
     <language>en-US</language>
   </input>
            ]]></artwork>
        </figure>
    <t>
The server might respond with an &quot;invalid&#8209;value&quot; error:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 400 Bad Request
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <errors xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf">
     <error>
       <error-type>protocol</error-type>
       <error-tag>invalid-value</error-tag>
       <error-path xmlns:ops="https://example.com/ns/example-ops">
         /ops:input/ops:delay
       </error-path>
       <error-message>Invalid input parameter</error-message>
     </error>
   </errors>
            ]]></artwork>
        </figure>
    <t>
The same response is shown here using JSON encoding:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 400 Bad Request
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Content-Type: application/yang-data+json

   { "ietf-restconf:errors" : {
       "error" : [
         {
           "error-type" : "protocol",
           "error-tag" : "invalid-value",
           "error-path" : "/example-ops:input/delay",
           "error-message" : "Invalid input parameter"
         }
       ]
     }
   }
            ]]></artwork>
        </figure>

</section>
</section>
<section title="Schema Resource" anchor="schema-resource">
    <t>
The server can optionally support the retrieval of the
YANG modules it uses.  If retrieval is supported, then
the &quot;schema&quot; leaf MUST be present in the
associated &quot;module&quot; list entry, defined in
<xref target="RFC7895"/>.
    </t>
    <t>
To retrieve a YANG module, a client first needs to get
the URL for retrieving the schema, which is stored in the
&quot;schema&quot; leaf.  Note that there is no required structure
for this URL. The URL value shown below is just an example.
    </t>
    <t>
The client might send the following GET request message:
    </t>

        <figure>
            <artwork><![CDATA[
   GET /restconf/data/ietf-yang-library:modules-state/\
       module=example-jukebox,2016-08-15/schema HTTP/1.1
   Host: example.com
   Accept: application/yang-data+json
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Content-Type: application/yang-data+json

   {
     "ietf-yang-library:schema" :
      "https://example.com/mymodules/example-jukebox/2016-08-15"
   }
            ]]></artwork>
        </figure>
    <t>
Next, the client needs to retrieve the actual YANG schema.
    </t>
    <t>
The client might send the following GET request message:
    </t>
        <figure>
            <artwork><![CDATA[
   GET https://example.com/mymodules/example-jukebox/\
      2016-08-15 HTTP/1.1
   Host: example.com
   Accept: application/yang
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Content-Type: application/yang

      // entire YANG module contents deleted for this example...
            ]]></artwork>
        </figure>
</section>
<section title="Event Stream Resource" anchor="stream-resource">
    <t>
An event stream resource represents a source for
system-generated event notifications.  Each stream is created and modified
by the server only.  A client can retrieve a stream resource
or initiate a long-poll server-sent event stream
<xref target="W3C.REC-eventsource-20150203"/>, using the procedure
specified in <xref target="receive-notifs"/>.
    </t>
    <t>
An event stream functions according to the
&quot;NETCONF Event Notifications&quot; specification
<xref target="RFC5277"/>. The available streams can be retrieved from
the &quot;stream&quot;&nbsp;list, which specifies the syntax and semantics
of the stream resources.
    </t>
</section>
<section title="&quot;errors&quot; YANG Data Template" anchor="errors-media-type">
    <t>
The &quot;errors&quot; YANG data template models a collection
of error information that is sent as the message-body in a
server response message if an error occurs while processing a
request message. It is not considered as a resource type because
no instances can be retrieved with a GET request.
    </t>
    <t>
The &quot;ietf&#8209;restconf&quot; YANG module contains the
&quot;yang&#8209;errors&quot; YANG data template, which specifies
the syntax and semantics of an &quot;errors&quot; container within a
RESTCONF response. RESTCONF error&nbhy;handling behavior is
defined in <xref target="error-reporting"/>.
    </t>
</section>
</section>
<section title="RESTCONF Methods" anchor="operations">
    <t>
The RESTCONF protocol uses HTTP methods to identify
the CRUD operations requested for a particular resource.
    </t>
    <t>
The following table shows how the RESTCONF operations relate to
NETCONF protocol operations.
    </t>

<texttable title="CRUD Methods in RESTCONF">
<ttcol align='left'> RESTCONF</ttcol>
<ttcol align='left'>NETCONF</ttcol>
<c>OPTIONS</c>
<c>none</c>
<c>HEAD</c>
<c>&lt;get-config&gt;, &lt;get&gt;</c>
<c>GET</c>
<c>&lt;get-config&gt;, &lt;get&gt;</c>
<c>POST</c>
<c>&lt;edit-config&gt; (nc:operation=&quot;create&quot;)</c>
<c>POST</c>
<c>invoke an RPC operation</c>
<c>PUT</c>
<c>&lt;copy-config&gt; (PUT on datastore)</c>
<c>PUT</c>
<c>&lt;edit-config&gt; (nc:operation=&quot;create/replace&quot;)</c>
<c>PATCH</c>
<c>&lt;edit-config&gt; (nc:operation depends on PATCH content)</c>
<c>DELETE</c>
<c>&lt;edit-config&gt; (nc:operation=&quot;delete&quot;)</c>
</texttable>

<t>
The &quot;remove&quot; edit operation attribute for the
NETCONF &lt;edit&#8209;config&gt; RPC operation is not supported by
the HTTP DELETE method. The resource must exist or the DELETE method
will fail. The PATCH method is equivalent to a &quot;merge&quot;
edit operation when using a plain patch (see <xref target="plain-patch"/>);
other media&nbsp;types may provide more granular control.
    </t>
    <t>
Access control mechanisms are used to limit what CRUD operations
can be used.  In particular, RESTCONF is compatible with the
NETCONF Access Control Model (NACM) <xref target="RFC6536"/>, as there is a
specific mapping between RESTCONF and NETCONF operations.
The resource path needs to be converted internally by the server to the
corresponding YANG instance identifier.  Using this information,
the server can apply the NACM access control rules to RESTCONF
messages.
    </t>
    <t>
The server MUST NOT allow any RESTCONF operation
for any resources that the client is not authorized to access.
    </t>
    <t>
The implementation of all methods (except PATCH <xref target="RFC5789"/>)
is defined in <xref target="RFC7231"/>.
This section defines the RESTCONF protocol usage for each HTTP method.
    </t>
<section title="OPTIONS" anchor="options">
    <t>
The OPTIONS method is sent by the client to
discover which methods are supported by the server
for a specific resource (e.g., GET, POST, DELETE).
The server MUST implement this method.
    </t>
    <t>
The &quot;Accept&#8209;Patch&quot; header field MUST
be supported and returned in the response to the OPTIONS request, as
defined in <xref target="RFC5789"/>.
    </t>
</section>
<section title="HEAD" anchor="head">
    <t>
The RESTCONF server MUST support the HEAD method.
The HEAD method is sent by the client to
retrieve just the header fields
(which contain the metadata for a resource) that would be returned
for the comparable GET method, without the response message-body.
It is supported for all resources that support the GET method.
    </t>
    <t>
The request MUST contain a request URI
that contains at least the root resource.
The same query parameters supported by the GET method
are supported by the HEAD method.
    </t>
    <t>
The access control behavior is enforced
as if the method was GET instead of HEAD.
The server MUST respond the same as if the method
was GET instead of HEAD, except that no
response message-body is included.
    </t>
</section>
<section title="GET" anchor="get">
    <t>
The RESTCONF server MUST support the GET method.
The GET method is sent by the client to
retrieve data and metadata for a resource.
It is supported for all resource types, except operation
resources.
The request MUST contain a request URI
that contains at least the root resource.
    </t>
    <t>
The server MUST NOT return any data resources for which the user
does not have read privileges.
If the user is not authorized to read the target resource, an error
response containing a &quot;401 Unauthorized&quot; status-line SHOULD be
returned.
The error-tag value &quot;access&#8209;denied&quot; is returned in this case.
A server MAY return a &quot;404 Not Found&quot; status-line, as
described in Section&nbsp;6.5.4 in <xref target="RFC7231"/>.
The error&nbhy;tag value &quot;invalid&#8209;value&quot; is returned
in this case.
    </t>
    <t>
If the user is authorized to read some but not all of
the target resource, the unauthorized content is omitted
from the response message-body, and the authorized content
is returned to the client.
    </t>
    <t>
If any content is returned to the client, then the server MUST
send a valid response message-body.  More than one element
MUST NOT be returned for XML encoding.
If multiple elements are sent in a JSON message-body,
then they MUST be sent as a JSON array. In this case,
any timestamp or entity-tag returned in the response
MUST be associated with the first element returned.
    </t>
    <t>
If a retrieval request for a data resource representing a YANG
leaf&nbhy;list or list object identifies more than one instance and
XML encoding is used in the response, then an error response containing
a &quot;400 Bad Request&quot; status-line MUST be returned by the server.
The error-tag value &quot;invalid&#8209;value&quot; is used in this case.
Note that a non&nbhy;configuration list is not required to define any keys.
In this case, the retrieval of a single list instance is not possible.
    </t>
    <t>
If a retrieval request for a data resource represents
an instance that does not exist,
then an error response containing a &quot;404 Not Found&quot; status-line
MUST be returned by the server.
The error-tag value &quot;invalid&#8209;value&quot; is used in this case.
    </t>
    <t>
If the target resource of a retrieval request is for an operation resource,
then a &quot;405 Method Not Allowed&quot; status-line MUST be returned
by the server. The error-tag value
&quot;operation&#8209;not&#8209;supported&quot; is used in this case.
    </t>
    <t>
Note that the way that access control is applied to data resources may
not be completely compatible with HTTP caching.  The
&quot;Last&nbhy;Modified&quot; and &quot;ETag&quot; header fields
maintained for a data resource are not affected by changes to
the access control rules for that data resource.  It is
possible for the representation of a data resource that is visible to
a particular client to be changed without detection via the
&quot;Last&nbhy;Modified&quot; or &quot;ETag&quot; values.
    </t>
    <t>
Example:
    </t>
    <t>
The client might request the response header fields for an
XML representation of a specific &quot;album&quot; resource:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf/data/example-jukebox:jukebox/\
      library/artist=Foo%20Fighters/album=Wasting%20Light HTTP/1.1
   Host: example.com
   Accept: application/yang-data+xml
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Content-Type: application/yang-data+xml
   Cache-Control: no-cache
   ETag: "a74eefc993a2b"
   Last-Modified: Thu, 26 Jan 2017 14:02:14 GMT
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <album xmlns="http://example.com/ns/example-jukebox"
          xmlns:jbox="http://example.com/ns/example-jukebox">
     <name>Wasting Light</name>
     <genre>jbox:alternative</genre>
     <year>2011</year>
   </album>
            ]]></artwork>
        </figure>
    <t>
Refer to <xref target="ex-get"/> for more resource retrieval examples.
    </t>
</section>
<section title="POST" anchor="post">
    <t>
The RESTCONF server MUST support the POST method.
The POST method is sent by the client to create a data resource
or invoke an operation resource.
The server uses the target resource type
to determine how to process the request.
    </t>

<?rfc compact="yes"?>
<texttable title="Resource Types That Support POST">
<ttcol align='left'> Type</ttcol>
<ttcol align='left'>Description</ttcol>
<c>Datastore</c>
<c>Create a top-level configuration data resource</c>
<c>Data</c>
<c>Create a configuration data child resource</c>
<c>Operation</c>
<c>Invoke an RPC operation</c>
</texttable>
<?rfc compact="no"?>

<section title="Create Resource Mode">
    <t>
If the target resource type is a datastore or data resource, then the
POST is treated as a request to create a top-level resource or child
resource, respectively.  The message-body is expected to contain the
content of a child resource to create within the parent (target
resource).  The message-body MUST contain exactly one instance
of the expected data resource. The data model for the child tree
is the subtree, as defined by YANG for the child resource.
    </t>
    <t>
The &quot;insert&quot; (<xref target="insert"/>)
and &quot;point&quot; (<xref target="point"/>) query parameters
MUST be supported by the POST method for datastore and data resources.
These parameters are only allowed if the list or leaf&nbhy;list
is &quot;ordered&nbhy;by user&quot;.
    </t>
    <t>
If the POST method succeeds,
a &quot;201 Created&quot; status-line is returned and there is
no response message-body.  A &quot;Location&quot; header field identifying
the child resource that was created MUST be present
in the response in this case.
    </t>
    <t>
If the data resource already exists, then the POST request MUST
fail and a &quot;409 Conflict&quot; status-line MUST be returned.
The error-tag value &quot;resource&#8209;denied&quot; is used in this case.
    </t>
    <t>
If the user is not authorized to create the target resource,
an error response containing a &quot;403 Forbidden&quot; status-line SHOULD be
returned. The error-tag value &quot;access&#8209;denied&quot; is used in this case.
A server MAY return a &quot;404 Not Found&quot; status-line, as
described in Section&nbsp;6.5.4 in <xref target="RFC7231"/>.
The error-tag value &quot;invalid&#8209;value&quot; is used in this case.
All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
    <t>
Example:
    </t>
    <t>
To create a new &quot;jukebox&quot; resource, the client might send
the following:
    </t>
        <figure>
            <artwork><![CDATA[
   POST /restconf/data HTTP/1.1
   Host: example.com
   Content-Type: application/yang-data+json

   { "example-jukebox:jukebox" : {} }
            ]]></artwork>
        </figure>
    <t>
If the resource is created, the server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Location: https://example.com/restconf/data/\
       example-jukebox:jukebox
   Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
   ETag: "b3a3e673be2"
            ]]></artwork>
        </figure>
    <t>
Refer to <xref target="ex-create"/> for more resource creation examples.
    </t>
</section>
<section title="Invoke Operation Mode">
    <t>
If the target resource type is an operation resource,
then the POST method is treated as a request to invoke that operation.
The message-body (if any) is processed as the operation input
parameters.  Refer to <xref target="operation-resource"/> for details
on operation resources.
    </t>
    <t>
If the POST request succeeds, a &quot;200 OK&quot; status-line
is returned if there is a response message-body, and
a &quot;204 No Content&quot; status-line is returned if there is
no response message-body.
    </t>
    <t>
If the user is not authorized to invoke the target operation,
an error response containing a &quot;403 Forbidden&quot; status-line
SHOULD be returned. The error-tag value &quot;access&#8209;denied&quot;
is used in this case. A server MAY return a &quot;404 Not Found&quot;
status-line, as described in Section&nbsp;6.5.4 in <xref target="RFC7231"/>.
All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
    <t>
Example:
    </t>
    <t>
In this example, the client is invoking the &quot;play&quot; operation
defined in the &quot;example&#8209;jukebox&quot; YANG module.
    </t>
    <t>
A client might send a &quot;play&quot; request as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   POST /restconf/operations/example-jukebox:play HTTP/1.1
   Host: example.com
   Content-Type: application/yang-data+json

   {
     "example-jukebox:input" : {
       "playlist" : "Foo-One",
       "song-number" : 2
     }
   }
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
            ]]></artwork>
        </figure>
</section>
</section>
<section title="PUT" anchor="put">
    <t>
The RESTCONF server MUST support the PUT method.
The PUT method is sent by the client to create or replace
the target data resource. A request message-body MUST be present,
representing the new data resource, or the server MUST return a
&quot;400 Bad Request&quot; status-line.
The error-tag value &quot;invalid&#8209;value&quot; is used in this case.
    </t>
    <t>
Both the POST and PUT methods can be used to create data resources.
The difference is that for POST, the client does not provide
the resource identifier for the resource that will be created.
The target resource for the POST method for resource creation
is the parent of the new resource.
The target resource for the PUT method for resource creation
is the new resource.
    </t>
    <t>
The PUT method MUST be supported for data and datastore resources.
A PUT on the datastore resource is used to replace the entire contents
of the datastore.  A PUT on a data resource only replaces that data resource
within the datastore.
    </t>
    <t>
The &quot;insert&quot; (<xref target="insert"/>) and &quot;point&quot; (<xref target="point"/>) query parameters MUST be
supported by the PUT method for data resources.
These parameters are only allowed if the list or leaf-list
is &quot;ordered&nbhy;by user&quot;.
    </t>
    <t>
Consistent with <xref target="RFC7231"/>, if the PUT request creates a new resource,
a &quot;201 Created&quot; status-line is returned.   If an existing resource
is modified, a &quot;204 No Content&quot; status-line is returned.
    </t>
    <t>
If the user is not authorized to create or replace the target resource,
an error response containing a &quot;403 Forbidden&quot; status-line SHOULD be
returned. The error-tag value &quot;access&#8209;denied&quot; is used in
this case.
    </t>
<t>
A server MAY return a &quot;404 Not Found&quot; status-line, as
described in Section&nbsp;6.5.4 in <xref target="RFC7231"/>.
The error-tag value &quot;invalid-value&quot; is used in this case.
All other error responses are handled according to the procedures
defined in <xref target="error-reporting"/>.
</t>
    <t>
If the target resource represents a YANG leaf-list, then the
PUT method MUST NOT change the value of the leaf-list instance.
    </t>
    <t>
If the target resource represents a YANG list instance, then
the key leaf values, in message-body representation,
MUST be the same as the key leaf values in the request URI.
The PUT method MUST NOT be used to change the key leaf
values for a data resource instance.
    </t>
    <t>
Example:
    </t>
    <t>
An &quot;album&quot; child resource defined in the
&quot;example&#8209;jukebox&quot; YANG module
is replaced, or it is created if it does not already exist.
    </t>
    <t>
To replace the &quot;album&quot; resource contents,
the client might send the following:
    </t>
        <figure>
            <artwork><![CDATA[
   PUT /restconf/data/example-jukebox:jukebox/\
       library/artist=Foo%20Fighters/album=Wasting%20Light HTTP/1.1
   Host: example.com
   Content-Type: application/yang-data+json

   {
     "example-jukebox:album" : [
       {
         "name" : "Wasting Light",
         "genre" : "example-jukebox:alternative",
         "year" : 2011
       }
     ]
   }
            ]]></artwork>
        </figure>
    <t>
If the resource is updated, the server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
   ETag: "b27480aeda4c"
            ]]></artwork>
        </figure>
    <t>
The same request is shown here using XML encoding:
    </t>
        <figure>
            <artwork><![CDATA[
   PUT /restconf/data/example-jukebox:jukebox/\
       library/artist=Foo%20Fighters/album=Wasting%20Light HTTP/1.1
   Host: example.com
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <album xmlns="http://example.com/ns/example-jukebox"
          xmlns:jbox="http://example.com/ns/example-jukebox">
     <name>Wasting Light</name>
     <genre>jbox:alternative</genre>
     <year>2011</year>
   </album>
            ]]></artwork>
        </figure>
    <t>
Refer to <xref target="replace-datastore-ex"/> for an example using the PUT method
to replace the contents of the datastore resource.
    </t>
</section>
<section title="PATCH" anchor="patch">
    <t>
The RESTCONF server MUST support the PATCH method for
a plain patch and MAY support additional media types.
The media types for the PATCH method supported by the server
can be discovered by the client by sending an OPTIONS request
and examining the &quot;Accept&nbhy;Patch&quot; header field
in the response (see <xref target="options"/>).
    </t>

    <t>
RESTCONF uses the HTTP PATCH method defined
in <xref target="RFC5789"/> to provide an extensible framework for
resource patching mechanisms.
Each patch mechanism needs a unique media type.
    </t>
    <t>
This document defines one patch mechanism
(<xref target="plain-patch"/>). Another patch mechanism,
the YANG Patch mechanism, is defined in
<xref target="YANG-Patch"/>. Other patch mechanisms may be
defined by future specifications.
    </t>
    <t>
If the target resource instance does not exist, the server MUST NOT
create it.
    </t>
    <t>
If the PATCH request succeeds, a &quot;200 OK&quot; status-line
is returned if there is a message-body, and &quot;204 No Content&quot;
is returned if no response message-body is sent.
    </t>
    <t>
If the user is not authorized to alter the target resource,
an error response containing a &quot;403 Forbidden&quot; status-line SHOULD be
returned.  A server MAY return a &quot;404 Not Found&quot; status-line, as
described in Section&nbsp;6.5.4 in <xref target="RFC7231"/>.
The error-tag value &quot;invalid&#8209;value&quot; is used in this case.
All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
<section title="Plain Patch" anchor="plain-patch">
    <t>
The plain patch mechanism merges the contents of the message-body with
the target resource.  The message-body for a plain patch
MUST be present and MUST be represented by the
media type &quot;application&wj;/yang&#8209;data+xml&quot;
or &quot;application/yang&#8209;data+json&quot;.
    </t>
    <t>
Plain patch can be used to create or update, but not delete, a child
resource within the target resource.  Please see
<xref target="YANG-Patch"/> for an alternate media&nbsp;type
supporting the ability to delete child resources.
The YANG Patch media type allows multiple suboperations
(e.g., &quot;merge&quot;, &quot;delete&quot;) within a single
PATCH method.
    </t>
    <t>
If the target resource represents a YANG leaf-list, then the
PATCH method MUST NOT change the value of the leaf-list instance.
    </t>
    <t>
If the target resource represents a YANG list instance, then
the key leaf values, in message-body representation,
MUST be the same as the key leaf values in the request URI.
The PATCH method MUST NOT be used to change the key leaf
values for a data resource instance.
    </t>
    <t>
After the plain patch is processed by the server,
a response will be returned to the client, as specified
in <xref target="patch"/>.
    </t>
    <t>
Example:
    </t>
    <t>
To replace just the &quot;year&quot; field in the &quot;album&quot; resource
(instead of replacing the entire resource with the PUT method),
the client might send a plain patch as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   PATCH /restconf/data/example-jukebox:jukebox/\
       library/artist=Foo%20Fighters/album=Wasting%20Light HTTP/1.1
   Host: example.com
   If-Match: "b8389233a4c"
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <album xmlns="http://example.com/ns/example-jukebox">
    <year>2011</year>
   </album>
            ]]></artwork>
        </figure>
    <t>
If the field is updated, the server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
   ETag: "b2788923da4c"
            ]]></artwork>
        </figure>
</section>
</section>
<section title="DELETE" anchor="delete">
    <t>
The RESTCONF server MUST support the DELETE method.
The DELETE method is used to delete the target resource.
If the DELETE request succeeds, a &quot;204 No Content&quot; status-line
is returned.
    </t>
    <t>
If the user is not authorized to delete the target resource, then
an error response containing a &quot;403 Forbidden&quot; status-line SHOULD be
returned. The error-tag value &quot;access&#8209;denied&quot; is returned in this case.
A server MAY return a &quot;404 Not Found&quot; status-line, as
described in Section&nbsp;6.5.4 in <xref target="RFC7231"/>.
The error-tag value &quot;invalid&#8209;value&quot; is returned in this case.
All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
    <t>
If the target resource represents a configuration leaf-list
or list data node, then it MUST represent a single YANG leaf-list
or list instance. The server MUST NOT use the
DELETE method to delete more than one such instance.
    </t>
    <t>
Example:
    </t>
    <t>
To delete the &quot;album&quot; resource with the
key &quot;Wasting Light&quot;, the client might send the following:
    </t>
        <figure>
            <artwork><![CDATA[
   DELETE /restconf/data/example-jukebox:jukebox/\
       library/artist=Foo%20Fighters/album=Wasting%20Light HTTP/1.1
   Host: example.com
            ]]></artwork>
        </figure>
    <t>
If the resource is deleted, the server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
            ]]></artwork>
        </figure>
</section>
<section title="Query Parameters" anchor="query-parameters">
    <t>
Each RESTCONF operation allows zero or more query
parameters to be present in the request URI.
Which specific parameters are allowed will depend on
the resource type, and sometimes the specific target
resource used, in the request.
    </t>
<t>
 <list style="symbols">
 <t>
Query parameters can be given in any order.
 </t>
 <t>
Each parameter can appear at most once in a request URI.
 </t>
 <t>
If more than one instance of a query parameter is present, then a
&quot;400 Bad Request&quot; status-line MUST be returned by the server.
The error-tag value &quot;invalid&#8209;value&quot; is returned in this case.
 </t>
 <t>
A default value may apply if the parameter is missing.
 </t>
 <t>
Query parameter names and values are case sensitive.
 </t>
 <t>
A server MUST return an error with a &quot;400 Bad Request&quot; status-line
if a query parameter is unexpected.
The error-tag value &quot;invalid&#8209;value&quot; is returned in this case.
 </t>
 </list>
</t>

<texttable title="RESTCONF Query Parameters">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Methods</ttcol>
<ttcol align='left'>Description</ttcol>
<c>content</c>
<c>GET, HEAD</c>
<c>Select config and/or non-config data resources</c>
<c>depth</c>
<c>GET, HEAD</c>
<c>Request limited subtree depth in the reply content</c>
<c>fields</c>
<c>GET, HEAD</c>
<c>Request a subset of the target resource contents</c>
<c>filter</c>
<c>GET, HEAD</c>
<c>Boolean notification filter for event stream resources</c>
<c>insert</c>
<c>POST, PUT</c>
<c>Insertion mode for "ordered-by user" data resources</c>
<c>point</c>
<c>POST, PUT</c>
<c>Insertion point for "ordered-by user" data resources</c>
<c>start-time</c>
<c>GET, HEAD</c>
<c>Replay buffer start time for event stream resources</c>
<c>stop-time</c>
<c>GET, HEAD</c>
<c>Replay buffer stop time for event stream resources</c>
<c>with-defaults</c>
<c>GET, HEAD</c>
<c>Control the retrieval of default values</c>
</texttable>

<t>
Refer to <xref target="ex-query"/> for examples of query parameter usage.
</t>
    <t>
If vendors define additional query parameters, they SHOULD use a
prefix (such as the enterprise or organization name) for query
parameter names in order to avoid collisions with other parameters.
    </t>
<section title="The &quot;content&quot; Query Parameter" anchor="content">
    <t>
The &quot;content&quot; query parameter controls how descendant nodes of
the requested data nodes will be processed in the reply.
    </t>
    <t>
The allowed values are:
    </t>

<texttable>
<ttcol align='left'>Value</ttcol>
<ttcol align='left'>Description</ttcol>
<c>config</c>
<c>Return only configuration descendant data nodes</c>
<c>nonconfig</c>
<c>Return only non-configuration descendant data nodes</c>
<c>all</c>
<c>Return all descendant data nodes</c>
</texttable>

    <t>
This parameter is only allowed for GET methods on datastore and data
resources.  A &quot;400 Bad Request&quot; status-line is returned if used for other
methods or resource types.
    </t>
    <t>
If this query parameter is not present, the default value is &quot;all&quot;.
This query parameter MUST be supported by the server.
    </t>
</section>
<section title="The &quot;depth&quot; Query Parameter" anchor="depth">
    <t>
The &quot;depth&quot; query parameter is used to limit the depth of
subtrees returned by the server.
Data nodes with a &quot;depth&quot; value greater than the
&quot;depth&quot; parameter are not returned in a response for a GET method.
    </t>
    <t>
The requested data node has a depth level of &quot;1&quot;.
If the &quot;fields&quot; parameter (<xref target="fields"/>) is used
to select descendant data nodes, then these nodes and all of their
ancestor nodes have a &quot;depth&quot; value of &quot;1&quot;. (This has
the effect of including the nodes specified by the fields, even if
the &quot;depth&quot; value is less than the actual depth level of the
specified fields.) Any other child node has a &quot;depth&quot; value
that is 1 greater than its parent.
    </t>
    <t>
The value of the &quot;depth&quot; parameter is either
an integer between 1 and 65535 or the string &quot;unbounded&quot;.
&quot;unbounded&quot; is the default.
    </t>
    <t>
This parameter is only allowed for GET methods on API, datastore, and
data resources.  A &quot;400 Bad Request&quot; status-line is returned
if used for other methods or resource types.
    </t>
    <t>
By default, the server will include all sub-resources within a
retrieved resource that have the same resource type as the requested
resource. The exception is the datastore resource.  If this resource type
is retrieved, then by default the datastore and all child data
resources are returned.
    </t>
    <t>
If the &quot;depth&quot; query parameter URI is listed in
the &quot;capability&quot; leaf-list defined in
<xref target="mon-mod"/>, then the server
supports the &quot;depth&quot; query parameter.
    </t>
</section>
<section title="The &quot;fields&quot; Query Parameter" anchor="fields">
    <t>
The &quot;fields&quot; query parameter is used to optionally identify
data nodes within the target resource to be retrieved in a
GET method.  The client can use this parameter to retrieve
a subset of all nodes in a resource.
    </t>
    <t>
The server will return a message-body representing the
target resource, with descendant nodes pruned as specified
in the &quot;fields&#8209;expr&quot; value. The server does not return a set
of separate sub-resources.
    </t>
    <t>
A value of the &quot;fields&quot; query parameter matches the
following rule:
    </t>

        <figure>
            <artwork><![CDATA[
 fields-expr = path "(" fields-expr ")" / path ";" fields-expr / path
 path = api-identifier [ "/" path ]
            ]]></artwork>
        </figure>
    <t>
&quot;api&#8209;identifier&quot; is defined in <xref target="path-abnf"/>.
    </t>
    <t>
&quot;;&quot; is used to select multiple nodes.  For example, to
retrieve only the &quot;genre&quot; and &quot;year&quot; of an album, use
&quot;fields=genre;year&quot;.
    </t>
    <t>
Parentheses are used to specify sub-selectors of a node.
Note that there is no path separator character &quot;/&quot;
between a &quot;path&quot; field and a left parenthesis
character &quot;(&quot;.
    </t>
    <t>
For example, assume that the target resource is the &quot;album&quot; list.
To retrieve only the &quot;label&quot; and
&quot;catalogue&#8209;number&quot; of the &quot;admin&quot; container
within an album, use &quot;fields=admin(label;catalogue&#8209;number)&quot;.
    </t>
    <t>
&quot;/&quot; is used in a path to retrieve a child node of a node.
For example, to retrieve only the &quot;label&quot; of an album, use
&quot;fields=admin&wj;/label&quot;.
    </t>
    <t>
This parameter is only allowed for GET methods on API, datastore,
and data resources.  A &quot;400 Bad Request&quot; status-line
is returned if used for other methods or resource types.
    </t>
    <t>
If the &quot;fields&quot; query parameter URI is listed in the
&quot;capability&quot; leaf-list defined in <xref target="mon-mod"/>,
then the server supports the &quot;fields&quot; parameter.
    </t>
</section>
<section title="The &quot;filter&quot; Query Parameter" anchor="filter">
    <t>
The &quot;filter&quot; query parameter is used to indicate
which subset of all possible events is of interest.  If not present,
all events not precluded by other parameters will be sent.
    </t>
    <t>
This parameter is only allowed for GET methods on an
event stream resource.
A &quot;400 Bad Request&quot; status-line
is returned if used for other methods or resource types.
    </t>
    <t>
The format of this parameter is an XPath 1.0 expression
<xref target="XPath"/> and is evaluated in the following context:
    </t>
<t>
 <list style="symbols">
 <t>
The set of namespace declarations is the set of prefix and
namespace pairs for all supported YANG modules, where
the prefix is the YANG module name and the namespace is as defined
by the &quot;namespace&quot; statement in the YANG module.
 </t>
 <t>
The function library is the core function library defined
in XPath&nbsp;1.0, plus any functions defined by the data model.
 </t>
 <t>
The set of variable bindings is empty.
 </t>
 <t>
The context node is the root node.
 </t>
 </list>
</t>
    <t>
The &quot;filter&quot; query parameter is used as defined in
Section&nbsp;3.6 of <xref target="RFC5277"/>. If the boolean result of
the expression is &quot;true&quot; when applied to the
conceptual &quot;notification&quot; document root, then the
event notification is delivered to the client.
    </t>
    <t>
If the &quot;filter&quot; query parameter URI is listed in the
&quot;capability&quot; leaf-list defined in <xref target="mon-mod"/>,
then the server supports the &quot;filter&quot; query parameter.
    </t>
</section>
<section title="The &quot;insert&quot; Query Parameter" anchor="insert">
    <t>
The &quot;insert&quot; query parameter is used to specify how a
resource should be inserted within an &quot;ordered&nbhy;by user&quot; list.
    </t>
    <t>
The allowed values are:
    </t>

<texttable>
<ttcol align='left'>Value</ttcol>
<ttcol align='left'>Description</ttcol>
<c>first</c>
<c>Insert the new data as the new first entry.</c>
<c>last</c>
<c>Insert the new data as the new last entry.</c>
<c>before</c>
<c>Insert the new data before the insertion point, as specified by the value of the &quot;point&quot; parameter.</c>
<c>after</c>
<c>Insert the new data after the insertion point, as specified by the value of the &quot;point&quot; parameter.</c>
</texttable>

    <t>
The default value is &quot;last&quot;.
    </t>
    <t>
This parameter is only supported for the POST and PUT
methods. It is also only supported if the target
resource is a data resource, and that data represents
a YANG list or leaf-list that is &quot;ordered&nbhy;by&nbsp;user&quot;.
    </t>
    <t>
If the values &quot;before&quot; or &quot;after&quot; are used,
then a &quot;point&quot; query parameter for the
&quot;insert&quot; query parameter MUST also be present, or
a &quot;400 Bad Request&quot; status&nbhy;line is returned.
    </t>
    <t>
The &quot;insert&quot; query parameter MUST be supported by the server.
    </t>
</section>
<section title="The &quot;point&quot; Query Parameter" anchor="point">
    <t>
The &quot;point&quot; query parameter is used to specify the
insertion point for a data resource that is being
created or moved within an &quot;ordered&nbhy;by user&quot; list or
leaf&nbhy;list.
    </t>
    <t>
The value of the &quot;point&quot; parameter is a string that
identifies the path to the insertion point object.  The format is
the same as a target resource URI string.
    </t>
    <t>
This parameter is only supported for the POST and PUT
methods. It is also only supported if the target
resource is a data resource, and that data represents
a YANG list or leaf-list that is &quot;ordered&nbhy;by&nbsp;user&quot;.
    </t>
    <t>
If the &quot;insert&quot; query parameter is not present or has
a value other than &quot;before&quot; or &quot;after&quot;, then
a &quot;400 Bad Request&quot; status-line is returned.
    </t>
    <t>
This parameter contains the instance identifier of the
resource to be used as the insertion point for a
POST or PUT method.
    </t>
    <t>
The &quot;point&quot; query parameter MUST be supported by the server.
    </t>
</section>
<section title="The &quot;start-time&quot; Query Parameter" anchor="start-time">
    <t>
The &quot;start&#8209;time&quot; query parameter is used to trigger the
notification replay feature defined in <xref target="RFC5277"/> and indicate
that the replay should start at the time specified. If the stream does not
support replay per the &quot;replay&#8209;support&quot; attribute returned
by the &quot;stream&quot;&nbsp;list entry for the stream resource, then the
server MUST return a &quot;400 Bad Request&quot; status&nbhy;line.
    </t>
    <t>
The value of the &quot;start&#8209;time&quot; parameter is of type
&quot;date&#8209;and&#8209;time&quot;, defined in
the &quot;ietf&#8209;yang&nbhy;types&quot; YANG module
<xref target="RFC6991"/>.
    </t>
    <t>
This parameter is only allowed for GET methods on a
&quot;text&wj;/event&nbhy;stream&quot; data resource.
A &quot;400 Bad Request&quot; status-line is returned
if used for other methods or resource types.
    </t>
    <t>
If this parameter is not present, then a replay subscription
is not being requested.  It is not valid to specify start
times that are later than the current time.  If the value
specified is earlier than the log can support, the replay
will begin with the earliest available notification.
A client can obtain a server&apos;s current time by examining the &quot;Date&quot;
header field that the server returns in response messages, according
to <xref target="RFC7231"/>.
    </t>
    <t>
If this query parameter is supported by the server, then the
&quot;replay&quot; query parameter URI MUST be listed in the
&quot;capability&quot; leaf-list defined in <xref target="mon-mod"/>,
and the &quot;stop&#8209;time&quot; query parameter MUST also be
supported by the server.
    </t>
    <t>
If the &quot;replay&#8209;support&quot; leaf has the value &quot;true&quot;
in the &quot;stream&quot; entry (defined in <xref target="mon-mod"/>), then
the server MUST support the &quot;start&#8209;time&quot; and
&quot;stop&#8209;time&quot; query parameters for that stream.
    </t>
</section>
<section title="The &quot;stop-time&quot; Query Parameter" anchor="stop-time">
    <t>
The &quot;stop&#8209;time&quot; query parameter is used with the
replay feature to indicate the newest notifications of
interest.  This parameter MUST be used with, and have a
value later than, the &quot;start&#8209;time&quot; parameter.
    </t>
    <t>
The value of the &quot;stop&#8209;time&quot; parameter is of type
&quot;date&#8209;and&#8209;time&quot;, defined in the
&quot;ietf&#8209;yang&nbhy;types&quot; YANG module <xref target="RFC6991"/>.
    </t>
    <t>
This parameter is only allowed for GET methods on a
&quot;text&wj;/event&nbhy;stream&quot; data resource.
A &quot;400 Bad Request&quot; status-line is returned
if used for other methods or resource types.
    </t>
    <t>
If this parameter is not present, the notifications will
continue until the subscription is terminated.
Values in the future are valid.
    </t>
    <t>
If this query parameter is supported by the server, then the
&quot;replay&quot; query parameter URI MUST be listed in the
&quot;capability&quot; leaf-list defined in <xref target="mon-mod"/>,
and the &quot;start&#8209;time&quot; query parameter MUST also be
supported by the server.
    </t>
    <t>
If the &quot;replay&#8209;support&quot; leaf is present in the
&quot;stream&quot; entry (defined in <xref target="mon-mod"/>), then
the server MUST support the &quot;start&#8209;time&quot; and
&quot;stop&#8209;time&quot; query parameters for that stream.
    </t>
</section>
<section title="The &quot;with-defaults&quot; Query Parameter" anchor="with-defaults">
    <t>
The &quot;with&#8209;defaults&quot; query parameter is used to specify
how information about default data nodes should be returned
in response to GET requests on data resources.
    </t>
    <t>
If the server supports this capability, then it MUST implement
the behavior described in Section&nbsp;4.5.1 of <xref target="RFC6243"/>,
except applied to the RESTCONF GET operation instead of the NETCONF
operations.
    </t>

<texttable>
<ttcol align='left'>Value</ttcol>
<ttcol align='left'>Description</ttcol>
<c>report-all</c>
<c>All data nodes are reported</c>
<c>trim</c>
<c>Data nodes set to the YANG default are not reported</c>
<c>explicit</c>
<c>Data nodes set to the YANG default by the client are reported</c>
<c>report-all-tagged</c>
<c>All data nodes are reported, and defaults are tagged</c>
</texttable>

    <t>
If the &quot;with&#8209;defaults&quot; parameter is set to
&quot;report&#8209;all&quot;, then the server MUST
adhere to the default-reporting behavior defined in
Section&nbsp;3.1 of <xref target="RFC6243"/>.
    </t>
    <t>
If the &quot;with&#8209;defaults&quot; parameter is set to
&quot;trim&quot;, then the server MUST
adhere to the default-reporting behavior defined in
Section&nbsp;3.2 of <xref target="RFC6243"/>.
    </t>
    <t>
If the &quot;with&#8209;defaults&quot; parameter is set to
&quot;explicit&quot;, then the server MUST
adhere to the default-reporting behavior defined in
Section&nbsp;3.3 of <xref target="RFC6243"/>.
    </t>
    <t>
If the &quot;with&#8209;defaults&quot; parameter is set to
&quot;report&#8209;all&#8209;tagged&quot;, then the server MUST
adhere to the default-reporting behavior defined in
Section&nbsp;3.4 of <xref target="RFC6243"/>. Metadata is
reported by the server as specified in <xref target="restconf-metadata"/>.
The XML encoding for the &quot;default&quot; attribute
sent by the server for default nodes is defined in
Section&nbsp;6 of <xref target="RFC6243"/>.
The JSON encoding for the &quot;default&quot; attribute MUST use the same
values, as defined in <xref target="RFC6243"/>, but encoded according to the
rules in <xref target="RFC7952"/>.  The module
name &quot;ietf&#8209;netconf&#8209;with&#8209;defaults&quot; MUST be used for the &quot;default&quot; attribute.
    </t>
    <t>
If the &quot;with&#8209;defaults&quot; parameter is not present,
then the server MUST adhere to the default-reporting behavior defined in
its &quot;basic&#8209;mode&quot; parameter for the
&quot;defaults&quot; protocol capability URI,
defined in <xref target="defaults-uri"/>.
    </t>
    <t>
If the server includes the &quot;with&#8209;defaults&quot; query parameter
URI in the &quot;capability&quot; leaf-list defined in
<xref target="mon-mod"/>, then the &quot;with&#8209;defaults&quot;
query parameter MUST be supported.
    </t>
    <t>
Since the server does not report the &quot;also&#8209;supported&quot; parameter
as described in Section&nbsp;4.3 of <xref target="RFC6243"/>, it is
possible that some values for the &quot;with&#8209;defaults&quot; parameter
will not be supported. If the server does not support the requested value
of the &quot;with&#8209;defaults&quot; parameter, the server MUST
return a response with a &quot;400 Bad Request&quot; status-line.
The error-tag value &quot;invalid&#8209;value&quot; is used in this case.
    </t>
</section>
</section>
</section>
<section title="Messages" anchor="messages">
    <t>
The RESTCONF protocol uses HTTP messages.
A single HTTP message corresponds to a single protocol method.
Most messages can perform a single task on a single resource,
such as retrieving a resource or editing a resource.
The exception is the PATCH method, which allows multiple datastore
edits within a single message.
    </t>
<section title="Request URI Structure">
    <t>
Resources are represented with URIs following the structure
for generic URIs in <xref target="RFC3986"/>.
    </t>
    <t>
A RESTCONF operation is derived from the HTTP method
and the request URI, using the following conceptual fields:
    </t>
        <figure>
            <artwork><![CDATA[
     <OP> /<restconf>/<path>?<query>
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
       ^       ^        ^       ^
       |       |        |       |
     method  entry  resource  query

       M       M        O        O

    M=mandatory, O=optional

    where:
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
      <OP> is the HTTP method
      <restconf> is the RESTCONF root resource
      <path> is the target resource URI
      <query> is the query parameter list
            ]]></artwork>
        </figure>
<t>
 <list style="symbols">
 <t>
method: the HTTP method identifying the RESTCONF operation
requested by the client, to act upon the target resource
specified in the request URI.  RESTCONF operation details are
described in <xref target="operations"/>.
 </t>
 <t>
entry: the root of the RESTCONF API configured on this HTTP
server, discovered by getting the &quot;/.well&#8209;known/host&#8209;meta&quot;
resource, as described in <xref target="root-resource-discovery"/>.
 </t>
 <t>
resource: the path expression identifying the resource
that is being accessed by the RESTCONF operation.
If this field is not present, then the target resource
is the API itself, represented by the YANG data template
named &quot;yang&#8209;api&quot;, found in <xref target="module"/>.
 </t>
 <t>
query: the set of parameters associated with the RESTCONF
message; see Section&nbsp;3.4 of <xref target="RFC3986"/>.
RESTCONF parameters have the familiar form of &quot;name=value&quot; pairs.
Most query parameters are optional to implement by the server
and optional to use by the client. Each optional query parameter is
identified by a URI. The server MUST list the
optional query parameter URIs it supports in the &quot;capability&quot;
leaf&nbhy;list defined in <xref target="mon-mod"/>.
 </t>
 </list>
</t>
    <t>
There is a specific set of parameters defined,
although the server MAY choose to support query
parameters not defined in this document.
The contents of any query parameter value MUST be encoded
according to Section&nbsp;3.4 of <xref target="RFC3986"/>. Any
reserved characters MUST be percent-encoded, according to
Sections&nbsp;2.1 and 2.5 of <xref target="RFC3986"/>.
    </t>
    <t>
Note that the fragment component is not used by the RESTCONF protocol.
The fragment is excluded from the target URI by a server, as described
in Section&nbsp;5.1 of <xref target="RFC7230"/>.
    </t>
    <t>
When new resources are created by the client, a &quot;Location&quot; header field
is returned, which identifies the path of the newly created resource.
The client uses this exact path identifier to access
the resource once it has been created.
    </t>
    <t>
The target of a RESTCONF operation is a resource.
The &quot;path&quot; field in the request URI represents
the target resource for the RESTCONF operation.
    </t>
    <t>
Refer to <xref target="main-examples"/> for examples of RESTCONF request URIs.
    </t>
</section>
<section title="Message Encoding">
    <t>
RESTCONF messages are encoded in HTTP according to <xref target="RFC7230"/>.
The &quot;utf&#8209;8&quot; character set is used for all messages.
RESTCONF message content is sent in the HTTP message-body.
    </t>
    <t>
Content is encoded in either JSON or XML format.
A server MUST support one of either XML or JSON encoding.
A server MAY support both XML and JSON encoding.
A client will need to support both XML and JSON to interoperate with all
RESTCONF servers.
    </t>
    <t>
XML encoding rules for data nodes are defined in <xref target="RFC7950"/>.
The same encoding rules are used for all XML content.
JSON encoding rules are defined in <xref target="RFC7951"/>.
Additional JSON encoding rules for metadata are defined
in <xref target="RFC7952"/>.
This encoding is valid JSON, but it also has
special encoding rules to identify module namespaces
and provide consistent type processing of YANG data.
    </t>
    <t>
The request input content encoding format is identified with the
&quot;Content&nbhy;Type&quot; header field.  This field MUST be present if a
message&nbhy;body is sent by the client.
    </t>
    <t>
The server MUST support the &quot;Accept&quot; header field and
the &quot;406 Not Acceptable&quot; status-line, as defined in
<xref target="RFC7231"/>. The response output content encoding formats
that the client will accept are identified with the
&quot;Accept&quot; header field in the request. If it is not specified,
the request input encoding format SHOULD be used, or the
server MAY choose any supported content encoding format.
    </t>
    <t>
If there was no request input, then the default output encoding
is XML or JSON, depending on server preference.
File extensions encoded in the request are not used to identify
format encoding.
    </t>
    <t>
A client can determine if the RESTCONF server supports an
encoding format by sending a request using a specific format
in the &quot;Content&nbhy;Type&quot; and/or &quot;Accept&quot; header field.  If the server
does not support the requested input encoding for a request,
then it MUST return an error response with
a &quot;415 Unsupported Media Type&quot; status&nbhy;line.
If the server does not support any of the requested
output encodings for a request, then it MUST return
an error response with a &quot;406 Not Acceptable&quot; status-line.
    </t>
</section>
<section title="RESTCONF Metadata" anchor="restconf-metadata">
    <t>
The RESTCONF protocol needs to support the retrieval of the same
metadata that is used in the NETCONF protocol.  Information about
default leafs, last-modified timestamps, etc. is commonly used
to annotate representations of the datastore contents.
    </t>
    <t>
With the XML encoding, the metadata is encoded as attributes in XML,
according to Section&nbsp;3.3 of <xref target="W3C.REC-xml-20081126"/>.
With the JSON encoding, the metadata is encoded as specified in
<xref target="RFC7952"/>.
    </t>
    <t>
The following examples are based on the example
in <xref target="with-defaults-example"/>.
The &quot;report&#8209;all&#8209;tagged&quot; mode for the
&quot;with&#8209;defaults&quot; query parameter requires that
a &quot;default&quot; attribute be returned for default nodes.
These examples show that attribute for the &quot;mtu&quot; leaf.
    </t>
<section title="XML Metadata Encoding Example">
        <figure>
            <artwork><![CDATA[
   GET /restconf/data/interfaces/interface=eth1
       ?with-defaults=report-all-tagged HTTP/1.1
   Host: example.com
   Accept: application/yang-data+xml
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <interface
     xmlns="urn:example.com:params:xml:ns:yang:example-interface">
     <name>eth1</name>
     <mtu xmlns:wd="urn:ietf:params:xml:ns:netconf:default:1.0"
       wd:default="true">1500</mtu>
     <status>up</status>
   </interface>
            ]]></artwork>
        </figure>
</section>
<section title="JSON Metadata Encoding Example">
    <t>
Note that RFC 6243 defines the &quot;default&quot; attribute with the
XML&nbsp;Schema Definition (XSD), not YANG, so the YANG module name
has to be assigned instead of derived from the YANG module.
The value &quot;ietf&#8209;netconf&#8209;with&#8209;defaults&quot; is
assigned for JSON metadata encoding.
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf/data/interfaces/interface=eth1\
       ?with-defaults=report-all-tagged HTTP/1.1
   Host: example.com
   Accept: application/yang-data+json
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Content-Type: application/yang-data+json

   {
     "example:interface" : [
       {
         "name" : "eth1",
         "mtu" : 1500,
         "@mtu" : {
            "ietf-netconf-with-defaults:default" : true
         },
         "status" : "up"
       }
     ]
   }
            ]]></artwork>
        </figure>
</section>
</section>
<section title="Return Status">
    <t>
Each message represents some sort of resource access.
An HTTP &quot;status&#8209;line&quot; header field is returned for
each request. If a status code in the &quot;4xx&quot; range is returned
in the status-line, then the error information SHOULD be returned in
the response, according to the format defined in <xref target="errors"/>.
If a status code in the &quot;5xx&quot; range is returned in the
status-line, then the error information MAY be returned in the response,
according to the format defined in <xref target="errors"/>. If a
status code in the &quot;1xx&quot;, &quot;2xx&quot;, or &quot;3xx&quot; range
is returned in the status-line, then error information MUST NOT be returned
in the response, since these ranges do not represent error conditions.
    </t>
</section>
<section title="Message Caching">
    <t>
Since the datastore contents change at unpredictable times,
responses from a RESTCONF server generally SHOULD NOT be cached.
    </t>
    <t>
The server MUST include a &quot;Cache&#8209;Control&quot; header field in every response
that specifies whether the response should be cached.
    </t>
    <t>
Instead of relying on HTTP caching, the client SHOULD track the &quot;ETag&quot;
and/or &quot;Last&#8209;Modified&quot; header fields returned by the server for the
datastore resource (or data resource, if the server supports it).
A retrieval request for a resource can include
the &quot;If&#8209;None&#8209;Match&quot;
and/or &quot;If&#8209;Modified&#8209;Since&quot; header fields, which
will cause the server to return a &quot;304 Not Modified&quot; status-line
if the resource has not changed.
The client MAY use the HEAD method to retrieve just
the message header fields, which SHOULD include the &quot;ETag&quot;
and &quot;Last&#8209;Modified&quot; header fields, if this metadata is maintained
for the target resource.
    </t>
    <t>
Note that access control can be applied to data resources, such that
the values in the &quot;Last&nbhy;Modified&quot; and &quot;ETag&quot;
headers maintained for a data resource may not be reliable, as
described in <xref target="get"/>.
</t>
</section>
</section>

<section title="Notifications" anchor="notifications">
    <t>
The RESTCONF protocol supports YANG-defined event notifications.  The
solution preserves aspects of NETCONF event notifications
<xref target="RFC5277"/> while utilizing the
Server-Sent Events <xref target="W3C.REC-eventsource-20150203"/>
transport strategy.
    </t>
<section title="Server Support">
    <t>
A RESTCONF server MAY support RESTCONF notifications.
Clients may determine if a server supports RESTCONF notifications by
using the HTTP OPTIONS, HEAD, or GET method on the
&quot;stream&quot;&nbsp;list. The server does not support
RESTCONF notifications if an HTTP error code is returned
(e.g., a &quot;404 Not Found&quot; status&nbhy;line).
    </t>
</section>
<section title="Event Streams">
    <t>
A RESTCONF server that supports notifications will populate a
stream resource for each notification delivery service access point.
A RESTCONF client can retrieve the list of supported event streams from
a RESTCONF server using the GET method on the &quot;stream&quot;&nbsp;list.
    </t>
    <t>
The &quot;restconf&#8209;state/streams&quot; container definition in
the &quot;ietf&#8209;restconf&#8209;monitoring&quot; module
(defined in <xref target="mon-mod"/>) is used to specify the structure
and syntax of the conceptual child resources within
the &quot;streams&quot; resource.
    </t>
    <t>
For example:
    </t>
    <t>
The client might send the following request:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf/data/ietf-restconf-monitoring:restconf-state/\
       streams HTTP/1.1
   Host: example.com
   Accept: application/yang-data+xml
            ]]></artwork>
        </figure>
    <t>
The server might send the following response:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <streams
     xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf-monitoring">
      <stream>
         <name>NETCONF</name>
         <description>default NETCONF event stream</description>
         <replay-support>true</replay-support>
         <replay-log-creation-time>\
            2007-07-08T00:00:00Z\
         </replay-log-creation-time>
         <access>
            <encoding>xml</encoding>
            <location>https://example.com/streams/NETCONF\
            </location>
         </access>
         <access>
            <encoding>json</encoding>
            <location>https://example.com/streams/NETCONF-JSON\
            </location>
         </access>
      </stream>
      <stream>
         <name>SNMP</name>
         <description>SNMP notifications</description>
         <replay-support>false</replay-support>
         <access>
            <encoding>xml</encoding>
            <location>https://example.com/streams/SNMP</location>
         </access>
      </stream>
      <stream>
         <name>syslog-critical</name>
         <description>Critical and higher severity</description>
         <replay-support>true</replay-support>
         <replay-log-creation-time>
            2007-07-01T00:00:00Z
         </replay-log-creation-time>
         <access>
            <encoding>xml</encoding>
            <location>\
              https://example.com/streams/syslog-critical\
            </location>
         </access>
      </stream>
   </streams>
            ]]></artwork>
        </figure>
</section>
<section title="Subscribing to Receive Notifications" anchor="receive-notifs">
    <t>
RESTCONF clients can determine the URL for the subscription resource
(to receive notifications) by sending an HTTP GET request for
the &quot;location&quot; leaf with the &quot;stream&quot;&nbsp;list entry.
The value returned by the server can be used for the actual notification
subscription.
    </t>
    <t>
The client will send an HTTP GET request for the URL returned by the
server with the &quot;Accept&quot; type &quot;text/event&#8209;stream&quot;.
    </t>
    <t>
The server will treat the connection as an event stream, using the
Server-Sent Events <xref target="W3C.REC-eventsource-20150203"/>
transport strategy.
    </t>
    <t>
The server MAY support query parameters for a GET method on this
resource.  These parameters are specific to each event stream.
    </t>
    <t>
For example:
    </t>
    <t>
The client might send the following request:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf/data/ietf-restconf-monitoring:restconf-state/\
       streams/stream=NETCONF/access=xml/location HTTP/1.1
   Host: example.com
   Accept: application/yang-data+xml
            ]]></artwork>
        </figure>
    <t>
The server might send the following response:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <location
     xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf-monitoring">\
     https://example.com/streams/NETCONF\
   </location>
            ]]></artwork>
        </figure>
    <t>
The RESTCONF client can then use this URL value to start
monitoring the event stream:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /streams/NETCONF HTTP/1.1
   Host: example.com
   Accept: text/event-stream
   Cache-Control: no-cache
   Connection: keep-alive
            ]]></artwork>
        </figure>
    <t>
A RESTCONF client MAY request that the server compress the events using
the HTTP header field &quot;Accept&#8209;Encoding&quot;.  For instance:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /streams/NETCONF HTTP/1.1
   Host: example.com
   Accept: text/event-stream
   Cache-Control: no-cache
   Connection: keep-alive
   Accept-Encoding: gzip, deflate
            ]]></artwork>
        </figure>
<section title="NETCONF Event Stream">
    <t>
The server SHOULD support the NETCONF event stream defined in
Section&nbsp;3.2.3 of <xref target="RFC5277"/>. The
notification messages for this stream are encoded in XML.
    </t>
    <t>
The server MAY support additional streams that represent
the semantic content of the NETCONF event stream, but
using a representation with a different media type.
    </t>
    <t>
The server MAY support the &quot;start&#8209;time&quot;, &quot;stop&#8209;time&quot;,
and &quot;filter&quot; query parameters, defined in <xref target="query-parameters"/>.
Refer to <xref target="ex-filters"/> for filter parameter examples.
    </t>
</section>
</section>
<section title="Receiving Event Notifications">
    <t>
RESTCONF notifications are encoded according to the
definition of the event stream.
    </t>
    <t>
The structure of the event data is based on the &lt;notification&gt;
element definition in Section&nbsp;4 of <xref target="RFC5277"/>.
It MUST conform to the schema for the &lt;notification&gt; element
in Section&nbsp;4 of <xref target="RFC5277"/>, using the XML namespace
as defined in the XSD as follows:
    </t>
        <figure>
            <artwork><![CDATA[
  urn:ietf:params:xml:ns:netconf:notification:1.0
            ]]></artwork>
        </figure>
    <t>
For JSON-encoding purposes, the module name for
the &quot;notification&quot; element is &quot;ietf&#8209;restconf&quot;.
    </t>
    <t>
Two child nodes within the &quot;notification&quot; container
are expected, representing the event time and
the event payload.  The &quot;eventTime&quot; node is
defined within the same XML namespace as the
&lt;notification&gt; element. It is defined to be
within the &quot;ietf&#8209;restconf&quot; module namespace
for JSON-encoding purposes.
    </t>
    <t>
The name and namespace of the payload element are determined
by the YANG module containing the notification-stmt
representing the notification message.
    </t>
    <t>
In the following example, the YANG module &quot;example&#8209;mod&quot;
is used:
    </t>
        <figure>
            <artwork><![CDATA[
  module example-mod {
    namespace "http://example.com/event/1.0";
    prefix ex;

    organization "Example, Inc.";
    contact "support at example.com";
    description "Example Notification Data Model Module.";
    revision "2016-07-07" {
      description "Initial version.";
      reference "example.com document 2-9976.";
    }

    notification event {
      description "Example notification event.";
      leaf event-class {
        type string;
        description "Event class identifier.";
      }
      container reporting-entity {
        description "Event specific information.";
        leaf card {
          type string;
          description "Line card identifier.";
        }
      }
      leaf severity {
        type string;
        description "Event severity description.";
      }
    }
  }
            ]]></artwork>
        </figure>
    <t>
An example SSE event notification encoded using XML:
    </t>
        <figure>
            <artwork><![CDATA[
   data: <notification
   data:    xmlns="urn:ietf:params:xml:ns:netconf:notification:1.0">
   data:    <eventTime>2013-12-21T00:01:00Z</eventTime>
   data:    <event xmlns="http://example.com/event/1.0">
   data:       <event-class>fault</event-class>
   data:       <reporting-entity>
   data:           <card>Ethernet0</card>
   data:       </reporting-entity>
   data:       <severity>major</severity>
   data:     </event>
   data: </notification>
            ]]></artwork>
        </figure>
    <t>
An example SSE event notification encoded using JSON:
    </t>
        <figure>
            <artwork><![CDATA[
   data: {
   data:   "ietf-restconf:notification" : {
   data:     "eventTime" : "2013-12-21T00:01:00Z",
   data:     "example-mod:event" : {
   data:       "event-class" : "fault",
   data:       "reporting-entity" : { "card" : "Ethernet0" },
   data:       "severity" : "major"
   data:     }
   data:   }
   data: }
            ]]></artwork>
        </figure>
    <t>
Alternatively, since neither XML nor JSON is whitespace sensitive,
the above messages can be encoded onto a single line.  For example:
    </t>
        <figure>
            <artwork><![CDATA[
   XML:

   data: <notification xmlns="urn:ietf:params:xml:ns:netconf:notif\
   ication:1.0"><eventTime>2013-12-21T00:01:00Z</eventTime><event \
   xmlns="http://example.com/event/1.0"><event-class>fault</event-\
   class><reportingEntity><card>Ethernet0</card></reporting-entity>\
   <severity>major</severity></event></notification>

   JSON:

   data: {"ietf-restconf:notification":{"eventTime":"2013-12-21\
   T00:01:00Z","example-mod:event":{"event-class": "fault","repor\
   tingEntity":{"card":"Ethernet0"},"severity":"major"}}}
            ]]></artwork>
        </figure>
    <t>
The SSE specification supports the following additional fields:
&quot;event&quot;, &quot;id&quot;, and &quot;retry&quot;.
A RESTCONF server MAY send the &quot;retry&quot; field, and if it does,
RESTCONF clients SHOULD use it. A RESTCONF server SHOULD NOT send the
&quot;event&quot; or &quot;id&quot; fields, as there are no meaningful
values that could be used for them that would not be redundant to the contents
of the notification itself. RESTCONF servers that do not send the
&quot;id&quot; field also do not need to support the HTTP header field
&quot;Last&#8209;Event&#8209;ID&quot;
<xref target="W3C.REC-eventsource-20150203"/>. RESTCONF servers that do send
the &quot;id&quot; field SHOULD support the &quot;start&#8209;time&quot; query
parameter as the preferred means for a client to specify where to
restart the event stream.
    </t>
</section>
</section>
<section title="Error Reporting" anchor="error-reporting">
    <t>
HTTP status codes are used to report success or failure
for RESTCONF operations. The error information that NETCONF error responses
contain in the &lt;rpc&#8209;error&gt; element is adapted for use in
RESTCONF, and &lt;errors&gt; data tree information is returned for
the &quot;4xx&quot; and &quot;5xx&quot; classes of status codes.
    </t>
    <t>
Since an operation resource is defined with a YANG &quot;rpc&quot;
statement and an action is defined with a YANG &quot;action&quot; statement,
a mapping from the NETCONF &lt;error&#8209;tag&gt; value to the
HTTP status code is needed.   The specific error-tag and response
code to use are specific to the data model and might be contained
in the YANG &quot;description&quot; statement for the
&quot;action&quot; or &quot;rpc&quot; statement.
    </t>

<texttable title="Mapping from &lt;error-tag&gt; to Status Code">
<ttcol align='left'> error-tag</ttcol>
<ttcol align='left'>status code</ttcol>
<c>in-use</c>
<c>409</c>
<c>invalid-value</c>
<c>400, 404, or 406</c>
<c>(request) too-big</c>
<c>413</c>
<c>(response) too-big</c>
<c>400</c>
<c>missing-attribute</c>
<c>400</c>
<c>bad-attribute</c>
<c>400</c>
<c>unknown-attribute</c>
<c>400</c>
<c>bad-element</c>
<c>400</c>
<c>unknown-element</c>
<c>400</c>
<c>unknown-namespace</c>
<c>400</c>
<c>access-denied</c>
<c>401 or 403</c>
<c>lock-denied</c>
<c>409</c>
<c>resource-denied</c>
<c>409</c>
<c>rollback-failed</c>
<c>500</c>
<c>data-exists</c>
<c>409</c>
<c>data-missing</c>
<c>409</c>
<c>operation-not-supported</c>
<c>405 or 501</c>
<c>operation-failed</c>
<c>412 or 500</c>
<c>partial-operation</c>
<c>500</c>
<c>malformed-message</c>
<c>400</c>
</texttable>

<section title="Error Response Message" anchor="errors">
    <t>
When an error occurs for a request message on any resource type
and the status code that will be returned is in the &quot;4xx&quot; range
(except for status code &quot;403 Forbidden&quot;), the server SHOULD
send a response message-body containing the information described by
the &quot;yang&#8209;errors&quot; YANG data template within the
&quot;ietf&#8209;restconf&quot; module found in <xref target="module"/>.
The Content-Type of this response message MUST be
&quot;application/yang&#8209;data&quot;, plus, optionally, a
structured syntax name suffix.
    </t>
    <t>
The client SHOULD specify the desired encoding(s) for response
messages by specifying the appropriate media&nbsp;type(s) in the
&quot;Accept&quot;&nbsp;header.  If the client did not specify an
&quot;Accept&quot;&nbsp;header, then the same structured syntax
name suffix used in the request message SHOULD be used, or the
server MAY choose any supported message-encoding format. If there
is no request message, the server MUST select
&quot;application&wj;/yang&#8209;data+xml&quot;
or &quot;application&wj;/yang&#8209;data+json&quot;,
depending on server preference. All of the examples in this
document, except for the one below, assume that XML encoding will be
returned if there is an error.
    </t>
    <t>
YANG tree diagram for &lt;errors&gt; data:
    </t>

        <figure>
            <artwork><![CDATA[
  +---- errors
        +---- error*
           +---- error-type       enumeration
           +---- error-tag        string
           +---- error-app-tag?   string
           +---- error-path?      instance-identifier
           +---- error-message?   string
           +---- error-info?
            ]]></artwork>
        </figure>

    <t>
The semantics and syntax for RESTCONF error messages are
defined with the &quot;yang&#8209;errors&quot; YANG data template
extension, found in <xref target="module"/>.
    </t>
    <t>
Examples:
    </t>
    <t>
The following example shows an error returned for
a &quot;lock&#8209;denied&quot; error that can occur if a NETCONF
client has locked a datastore. The RESTCONF client
is attempting to delete a data resource.  Note that
an &quot;Accept&quot; header field is used to specify the desired
encoding for the error message. There would be no response
message-body content if this operation was successful.
    </t>
        <figure>
            <artwork><![CDATA[
   DELETE /restconf/data/example-jukebox:jukebox/\
      library/artist=Foo%20Fighters/album=Wasting%20Light HTTP/1.1
   Host: example.com
   Accept: application/yang-data+json
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 409 Conflict
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Content-Type: application/yang-data+json

   {
     "ietf-restconf:errors" : {
       "error" : [
         {
           "error-type" : "protocol",
           "error-tag" : "lock-denied",
           "error-message" : "Lock failed; lock already held"
         }
       ]
     }
   }
            ]]></artwork>
        </figure>

    <t>
The following example shows an error returned for
a &quot;data&#8209;exists&quot; error on a data resource.
The &quot;jukebox&quot; resource already exists, so it cannot be created.
    </t>
    <t>
The client might send the following:
    </t>
        <figure>
            <artwork><![CDATA[
   POST /restconf/data/example-jukebox:jukebox HTTP/1.1
   Host: example.com
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 409 Conflict
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <errors xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf">
     <error>
       <error-type>protocol</error-type>
       <error-tag>data-exists</error-tag>
       <error-path
         xmlns:rc="urn:ietf:params:xml:ns:yang:ietf-restconf"
         xmlns:jbox="https://example.com/ns/example-jukebox">\
         /rc:restconf/rc:data/jbox:jukebox
       </error-path>
       <error-message>
         Data already exists; cannot create new resource
       </error-message>
     </error>
   </errors>
            ]]></artwork>
        </figure>
</section>
</section>
<section title="RESTCONF Module" anchor="module">
    <t>
The &quot;ietf&#8209;restconf&quot; module defines conceptual definitions
within an extension and two groupings, which are
not meant to be implemented as datastore contents by a server.
For example, the &quot;restconf&quot; container is not intended
to be implemented as a top-level data node (under
the &quot;/restconf/data&quot; URI).
    </t>
    <t>
Note that the &quot;ietf&#8209;restconf&quot; module does not have any
protocol&nbhy;accessible objects, so no YANG tree diagram is shown.
    </t>

        <figure>
            <artwork><![CDATA[
<CODE BEGINS>

file "ietf-restconf@2017-01-26.yang"

module ietf-restconf {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-restconf";
  prefix "rc";

  organization
    "IETF NETCONF (Network Configuration) Working Group";

  contact
    "WG Web:   <https://datatracker.ietf.org/wg/netconf/>
     WG List:  <mailto:netconf@ietf.org>

     Author:   Andy Bierman
               <mailto:andy@yumaworks.com>

     Author:   Martin Bjorklund
               <mailto:mbj@tail-f.com>

     Author:   Kent Watsen
               <mailto:kwatsen@juniper.net>";

  description
    "This module contains conceptual YANG specifications
     for basic RESTCONF media type definitions used in
     RESTCONF protocol messages.

     Note that the YANG definitions within this module do not
     represent configuration data of any kind.
     The 'restconf-media-type' YANG extension statement
     provides a normative syntax for XML and JSON
     message-encoding purposes.

     Copyright (c) 2017 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 8040; see
     the RFC itself for full legal notices.";

  revision 2017-01-26 {
    description
      "Initial revision.";
    reference
      "RFC 8040: RESTCONF Protocol.";
  }

  extension yang-data {
    argument name {
      yin-element true;
    }
    description
      "This extension is used to specify a YANG data template that
       represents conceptual data defined in YANG.  It is
       intended to describe hierarchical data independent of
       protocol context or specific message-encoding format.
       Data definition statements within a yang-data extension
       specify the generic syntax for the specific YANG data
       template, whose name is the argument of the 'yang-data'
       extension statement.

       Note that this extension does not define a media type.
       A specification using this extension MUST specify the
       message-encoding rules, including the content media type.

       The mandatory 'name' parameter value identifies the YANG
       data template that is being defined.  It contains the
       template name.

       This extension is ignored unless it appears as a top-level
       statement.  It MUST contain data definition statements
       that result in exactly one container data node definition.
       An instance of a YANG data template can thus be translated
       into an XML instance document, whose top-level element
       corresponds to the top-level container. 

       The module name and namespace values for the YANG module using
       the extension statement are assigned to instance document data
       conforming to the data definition statements within
       this extension.

       The substatements of this extension MUST follow the
       'data-def-stmt' rule in the YANG ABNF.

       The XPath document root is the extension statement itself,
       such that the child nodes of the document root are
       represented by the data-def-stmt substatements within
       this extension.  This conceptual document is the context
       for the following YANG statements:

         - must-stmt
         - when-stmt
         - path-stmt
         - min-elements-stmt
         - max-elements-stmt
         - mandatory-stmt
         - unique-stmt
         - ordered-by
         - instance-identifier data type

       The following data-def-stmt substatements are constrained
       when used within a 'yang-data' extension statement.

         - The list-stmt is not required to have a key-stmt defined.
         - The if-feature-stmt is ignored if present.
         - The config-stmt is ignored if present.
         - The available identity values for any 'identityref'
           leaf or leaf-list nodes are limited to the module
           containing this extension statement and the modules
           imported into that module.
      ";
  }

  rc:yang-data yang-errors {
    uses errors;
  }

  rc:yang-data yang-api {
    uses restconf;
  }

  grouping errors {
    description
      "A grouping that contains a YANG container
       representing the syntax and semantics of a
       YANG Patch error report within a response message.";

    container errors {
      description
        "Represents an error report returned by the server if
         a request results in an error.";

      list error {
        description
          "An entry containing information about one
           specific error that occurred while processing
           a RESTCONF request.";
        reference
          "RFC 6241, Section 4.3.";

        leaf error-type {
          type enumeration {
            enum transport {
              description
                "The transport layer.";
            }
            enum rpc {
              description
                "The rpc or notification layer.";
            }
            enum protocol {
              description
                "The protocol operation layer.";
            }
            enum application {
              description
                "The server application layer.";
            }
          }
          mandatory true;
          description
            "The protocol layer where the error occurred.";
        }

        leaf error-tag {
          type string;
          mandatory true;
          description
            "The enumerated error-tag.";
        }

        leaf error-app-tag {
          type string;
          description
            "The application-specific error-tag.";
        }

        leaf error-path {
          type instance-identifier;
          description
            "The YANG instance identifier associated
             with the error node.";
        }

        leaf error-message {
          type string;
          description
            "A message describing the error.";
        }

        anydata error-info {
           description
             "This anydata value MUST represent a container with
              zero or more data nodes representing additional
              error information.";
        }
      }
    }
  }

  grouping restconf {
    description
      "Conceptual grouping representing the RESTCONF
       root resource.";

    container restconf {
      description
        "Conceptual container representing the RESTCONF
         root resource.";

      container data {
        description
          "Container representing the datastore resource.
           Represents the conceptual root of all state data
           and configuration data supported by the server.
           The child nodes of this container can be any data
           resources that are defined as top-level data nodes
           from the YANG modules advertised by the server in
           the 'ietf-yang-library' module.";
      }

      container operations {
        description
          "Container for all operation resources.

           Each resource is represented as an empty leaf with the
           name of the RPC operation from the YANG 'rpc' statement.

           For example, the 'system-restart' RPC operation defined
           in the 'ietf-system' module would be represented as
           an empty leaf in the 'ietf-system' namespace.  This is
           a conceptual leaf and will not actually be found in
           the module:

              module ietf-system {
                leaf system-reset {
                  type empty;
                }
              }

           To invoke the 'system-restart' RPC operation:

              POST /restconf/operations/ietf-system:system-restart

           To discover the RPC operations supported by the server:

              GET /restconf/operations

           In XML, the YANG module namespace identifies the module:

             <system-restart
                xmlns='urn:ietf:params:xml:ns:yang:ietf-system'/>

           In JSON, the YANG module name identifies the module:

             { 'ietf-system:system-restart' : [null] }
          ";
      }

      leaf yang-library-version {
        type string {
          pattern '\d{4}-\d{2}-\d{2}';
        }
        config false;
        mandatory true;
        description
          "Identifies the revision date of the 'ietf-yang-library'
           module that is implemented by this RESTCONF server.
           Indicates the year, month, and day in YYYY-MM-DD
           numeric format.";
      }
    }
  }

}
            ]]></artwork>
        </figure>

<t>&lt;CODE ENDS></t>
</section>
<section title="RESTCONF Monitoring" anchor="restconf-mon">
    <t>
The &quot;ietf&#8209;restconf&#8209;monitoring&quot; module provides
information about the RESTCONF protocol capabilities and event streams
available from the server. A RESTCONF server MUST implement
the &quot;ietf&#8209;restconf&#8209;monitoring&quot; module.
    </t>
    <t>
YANG tree diagram for the
&quot;ietf&#8209;restconf&#8209;monitoring&quot; module:
    </t>
        <figure>
            <artwork><![CDATA[
   +--ro restconf-state
      +--ro capabilities
      |  +--ro capability*   inet:uri
      +--ro streams
         +--ro stream* [name]
            +--ro name                        string
            +--ro description?                string
            +--ro replay-support?             boolean
            +--ro replay-log-creation-time?   yang:date-and-time
            +--ro access* [encoding]
               +--ro encoding  string
               +--ro location  inet:uri
            ]]></artwork>
        </figure>
<section title="restconf-state/capabilities">
    <t>
This mandatory container holds the RESTCONF
protocol capability URIs supported by the server.
    </t>
    <t>
The server MAY maintain a last-modified timestamp for this
container and return the &quot;Last&#8209;Modified&quot; header field
when this data node is retrieved with the GET or HEAD methods.
Note that the last-modified timestamp for the datastore resource is not
affected by changes to this subtree.
    </t>
    <t>
The server SHOULD maintain an entity-tag for this
container and return the &quot;ETag&quot; header field when this
data node is retrieved with the GET or HEAD methods.
Note that the entity-tag for the datastore resource is not
affected by changes to this subtree.
    </t>
    <t>
The server MUST include a &quot;capability&quot; URI leaf-list entry for
the &quot;defaults&quot; mode used by the server, defined in <xref target="defaults-uri"/>.
    </t>
    <t>
The server MUST include a &quot;capability&quot; URI leaf-list entry identifying
each supported optional protocol feature. This includes optional
query parameters and MAY include other capability URIs defined
outside this document.
    </t>
<section title="Query Parameter URIs" anchor="query-parameter-uri">
    <t>
A new set of RESTCONF Capability URIs are defined to identify the specific
query parameters (defined in <xref target="query-parameters"/>)
supported by the server.
    </t>
    <t>
The server MUST include a &quot;capability&quot; leaf-list entry for each
optional query parameter that it supports.
    </t>

<texttable title="RESTCONF Query Parameter URIs">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Section</ttcol>
<ttcol align='left'>URI</ttcol>
<c>depth</c>
<c><xref format="counter" target="depth"/></c>
<c>urn:ietf:params:restconf:capability:depth:1.0</c>
<c>fields</c>
<c><xref format="counter" target="fields"/></c>
<c>urn:ietf:params:restconf:capability:fields:1.0</c>
<c>filter</c>
<c><xref format="counter" target="filter"/></c>
<c>urn:ietf:params:restconf:capability:filter:1.0</c>
<c>replay</c>
<c><xref format="counter" target="start-time"/> <xref format="counter" target="stop-time"/></c>
<c>urn:ietf:params:restconf:capability:replay:1.0</c>
<c>with-defaults</c>
<c><xref format="counter" target="with-defaults"/></c>
<c>urn:ietf:params:restconf:capability:with-defaults:1.0</c>
</texttable>

</section>
<section title="The &quot;defaults&quot; Protocol Capability URI" anchor="defaults-uri">
    <t>
This URI identifies the &quot;basic&#8209;mode&quot; default-handling mode
that is used by the server for processing default leafs in requests for
data resources. This protocol capability URI MUST be supported by the
server and MUST be listed in the &quot;capability&quot; leaf-list defined
in <xref target="mon-mod"/>.
    </t>

<texttable title="RESTCONF &quot;defaults&quot; Capability URI">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>URI</ttcol>
<c>defaults</c>
<c>urn:ietf:params:restconf:capability:defaults:1.0</c>
</texttable>

    <t>
The URI MUST contain a query parameter named &quot;basic&#8209;mode&quot;
with one of the values listed below:
    </t>

<texttable>
<ttcol align='left'>Value</ttcol>
<ttcol align='left'>Description</ttcol>
<c>report-all</c>
<c>No data nodes are considered default</c>
<c>trim</c>
<c>Values set to the YANG default-stmt value are default</c>
<c>explicit</c>
<c>Values set by the client are never considered default</c>
</texttable>

    <t>
The &quot;basic&#8209;mode&quot; definitions are specified in
&quot;With-defaults Capability for NETCONF&quot; <xref target="RFC6243"/>.
    </t>
    <t>
If the &quot;basic&#8209;mode&quot; is set to &quot;report&#8209;all&quot;,
then the server MUST adhere to the default-handling behavior defined in
Section&nbsp;2.1 of <xref target="RFC6243"/>.
    </t>
    <t>
If the &quot;basic&#8209;mode&quot; is set to &quot;trim&quot;, then the
server MUST adhere to the default-handling behavior defined in
Section&nbsp;2.2 of <xref target="RFC6243"/>.
    </t>
    <t>
If the &quot;basic&#8209;mode&quot; is set to &quot;explicit&quot;, then the
server MUST adhere to the default-handling behavior defined in
Section&nbsp;2.3 of <xref target="RFC6243"/>.
    </t>
    <t>
Example (split for display purposes only):
    </t>
        <figure>
            <artwork><![CDATA[
   urn:ietf:params:restconf:capability:defaults:1.0?
        basic-mode=explicit
            ]]></artwork>
        </figure>
</section>
</section>
<section title="restconf-state/streams">
    <t>
This optional container provides access to the
event streams supported by the server.
The server MAY omit this container if no
event streams are supported.
    </t>
    <t>
The server will populate this container with a &quot;stream&quot;&nbsp;list
entry for each stream type it supports.  Each stream contains a leaf
called &quot;events&quot;, which contains a URI that
represents an event stream resource.
    </t>
    <t>
Stream resources are defined in <xref target="stream-resource"/>.
Notifications are defined in <xref target="notifications"/>.
    </t>
</section>
<section title="RESTCONF Monitoring Module" anchor="mon-mod">
    <t>
The &quot;ietf&#8209;restconf&#8209;monitoring&quot; module defines monitoring
information for the RESTCONF protocol.
    </t>
    <t>
The &quot;ietf&#8209;yang&#8209;types&quot; and
&quot;ietf&#8209;inet&#8209;types&quot; modules
from <xref target="RFC6991"/> are used by this module
for some type definitions.
    </t>

        <figure>
            <artwork><![CDATA[
<CODE BEGINS>

file "ietf-restconf-monitoring@2017-01-26.yang"

module ietf-restconf-monitoring {
  namespace "urn:ietf:params:xml:ns:yang:ietf-restconf-monitoring";
  prefix "rcmon";

  import ietf-yang-types { prefix yang; }
  import ietf-inet-types { prefix inet; }

  organization
    "IETF NETCONF (Network Configuration) Working Group";

  contact
    "WG Web:   <https://datatracker.ietf.org/wg/netconf/>
     WG List:  <mailto:netconf@ietf.org>

     Author:   Andy Bierman
               <mailto:andy@yumaworks.com>

     Author:   Martin Bjorklund
               <mailto:mbj@tail-f.com>

     Author:   Kent Watsen
               <mailto:kwatsen@juniper.net>";

  description
    "This module contains monitoring information for the
     RESTCONF protocol.

     Copyright (c) 2017 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 8040; see
     the RFC itself for full legal notices.";

  revision 2017-01-26 {
    description
      "Initial revision.";
    reference
      "RFC 8040: RESTCONF Protocol.";
  }

  container restconf-state {
    config false;
    description
      "Contains RESTCONF protocol monitoring information.";

    container capabilities {
      description
        "Contains a list of protocol capability URIs.";

      leaf-list capability {
        type inet:uri;
        description
          "A RESTCONF protocol capability URI.";
      }
    }

    container streams {
      description
        "Container representing the notification event streams
         supported by the server.";
       reference
         "RFC 5277, Section 3.4, <streams> element.";

      list stream {
        key name;
        description
          "Each entry describes an event stream supported by
           the server.";

        leaf name {
          type string;
          description
            "The stream name.";
          reference
            "RFC 5277, Section 3.4, <name> element.";
        }

        leaf description {
          type string;
          description
            "Description of stream content.";
          reference
            "RFC 5277, Section 3.4, <description> element.";
        }

        leaf replay-support {
          type boolean;
          default false;
          description
            "Indicates if replay buffer is supported for this stream.
             If 'true', then the server MUST support the 'start-time'
             and 'stop-time' query parameters for this stream.";
          reference
            "RFC 5277, Section 3.4, <replaySupport> element.";
        }

        leaf replay-log-creation-time {
          when "../replay-support" {
            description
              "Only present if notification replay is supported.";
          }
          type yang:date-and-time;
          description
            "Indicates the time the replay log for this stream
             was created.";
          reference
            "RFC 5277, Section 3.4, <replayLogCreationTime>
             element.";
        }

        list access {
          key encoding;
          min-elements 1;
          description
            "The server will create an entry in this list for each
             encoding format that is supported for this stream.
             The media type 'text/event-stream' is expected
             for all event streams.  This list identifies the
             subtypes supported for this stream.";

          leaf encoding {
            type string;
            description
              "This is the secondary encoding format within the
               'text/event-stream' encoding used by all streams.
               The type 'xml' is supported for XML encoding.
               The type 'json' is supported for JSON encoding.";
          }

          leaf location {
            type inet:uri;
            mandatory true;
            description
              "Contains a URL that represents the entry point
               for establishing notification delivery via
               server-sent events.";
          }
        }
      }
    }
  }

}
            ]]></artwork>
        </figure>
<t>&lt;CODE ENDS></t>
</section>
</section>

<section title="YANG Module Library" anchor="yang-mod-lib">
    <t>
The &quot;ietf&#8209;yang&#8209;library&quot; module defined
in <xref target="RFC7895"/> provides information about
the YANG modules and submodules used by the RESTCONF server.
Implementation is mandatory for RESTCONF servers.
All YANG modules and submodules used by the server MUST
be identified in the YANG module library.
    </t>
<section title="modules-state/module">
    <t>
This mandatory list contains one entry
for each YANG data model module supported by the server.
There MUST be an instance of this list for every
YANG module that is used by the server.
    </t>
    <t>
The contents of this list are defined in
the &quot;module&quot; YANG list statement in <xref target="RFC7895"/>.
    </t>
    <t>
Note that there are no protocol-accessible objects in
the &quot;ietf&#8209;restconf&quot; module to implement, but
it is possible that a server will list the
&quot;ietf&#8209;restconf&quot; module in the YANG library
if it is imported (directly or indirectly) by an implemented module.
    </t>
</section>
</section>
<section title="IANA Considerations" anchor="iana">

<section title="The &quot;restconf&quot; Relation Type">
    <t>
This specification registers the &quot;restconf&quot; relation type in the
&quot;Link Relation Types&quot; registry defined by <xref target="RFC5988"/>:
    </t>
        <figure>
            <artwork><![CDATA[
   Relation Name: restconf

   Description: Identifies the root of the RESTCONF API as configured
                on this HTTP server.  The "restconf" relation
                defines the root of the API defined in RFC 8040.
                Subsequent revisions of RESTCONF will use alternate
                relation values to support protocol versioning.

   Reference: RFC 8040
            ]]></artwork>
        </figure>
</section>

<section title="Registrations for New URIs and YANG Modules">

    <t>
This document registers two URIs as namespaces in the
&quot;IETF XML Registry&quot; <xref target="RFC3688"/>:

    </t>
        <figure>
            <artwork><![CDATA[
     URI: urn:ietf:params:xml:ns:yang:ietf-restconf
     Registrant Contact: The IESG.
     XML: N/A; the requested URI is an XML namespace.

     URI: urn:ietf:params:xml:ns:yang:ietf-restconf-monitoring
     Registrant Contact: The IESG.
     XML: N/A; the requested URI is an XML namespace.
            ]]></artwork>
        </figure>
    <t>
This document registers two YANG modules in the &quot;YANG Module Names&quot;
registry <xref target="RFC6020"/>:
    </t>
        <figure>
            <artwork><![CDATA[
  name:         ietf-restconf
  namespace:    urn:ietf:params:xml:ns:yang:ietf-restconf
  prefix:       rc
  reference:    RFC 8040

  name:         ietf-restconf-monitoring
  namespace:    urn:ietf:params:xml:ns:yang:ietf-restconf-monitoring
  prefix:       rcmon
  reference:    RFC 8040
            ]]></artwork>
        </figure>
</section>
<section title="Media Types" anchor="media-types">
<section title="Media Type &quot;application/yang-data+xml&quot;" anchor="yang-data-xml">
        <figure>
            <artwork><![CDATA[
Type name: application

Subtype name: yang-data+xml

Required parameters: None

Optional parameters: None

Encoding considerations: 8-bit
   Each conceptual YANG data node is encoded according to the
   XML Encoding Rules and Canonical Format for the specific
   YANG data node type defined in [RFC7950].

Security considerations: Security considerations related
   to the generation and consumption of RESTCONF messages
   are discussed in Section 12 of RFC 8040.
   Additional security considerations are specific to the
   semantics of particular YANG data models.  Each YANG module
   is expected to specify security considerations for the
   YANG data defined in that module.

Interoperability considerations: RFC 8040 specifies the
   format of conforming messages and the interpretation
   thereof.

Published specification: RFC 8040

Applications that use this media type: Instance document
   data parsers used within a protocol or automation tool
   that utilize YANG-defined data structures.

Fragment identifier considerations: Fragment identifiers for
   this type are not defined.  All YANG data nodes are
   accessible as resources using the path in the request URI.

Additional information:

   Deprecated alias names for this type: N/A
   Magic number(s): N/A
   File extension(s): None
   Macintosh file type code(s): "TEXT"

Person & email address to contact for further information: See
   the Authors' Addresses section of RFC 8040.

Intended usage: COMMON

Restrictions on usage: N/A

Author: See the Authors' Addresses section of RFC 8040.

Change controller: Internet Engineering Task Force
   (mailto:iesg@ietf.org).

Provisional registration? (standards tree only): no
            ]]></artwork>
        </figure>
</section>

<section title="Media Type &quot;application/yang-data+json&quot;" anchor="yang-data-json">
        <figure>
            <artwork><![CDATA[
Type name: application

Subtype name: yang-data+json

Required parameters: None

Optional parameters: None

Encoding considerations: 8-bit
   Each conceptual YANG data node is encoded according to
   [RFC7951].  A metadata annotation is encoded according to
   [RFC7952].

Security considerations: Security considerations related
   to the generation and consumption of RESTCONF messages
   are discussed in Section 12 of RFC 8040.
   Additional security considerations are specific to the
   semantics of particular YANG data models.  Each YANG module
   is expected to specify security considerations for the
   YANG data defined in that module.

Interoperability considerations: RFC 8040 specifies the format
   of conforming messages and the interpretation thereof.

Published specification: RFC 8040

Applications that use this media type: Instance document
   data parsers used within a protocol or automation tool
   that utilize YANG-defined data structures.

Fragment identifier considerations: The syntax and semantics
   of fragment identifiers are the same as the syntax and semantics
   specified for the "application/json" media type.

Additional information:

   Deprecated alias names for this type: N/A
   Magic number(s): N/A
   File extension(s): None
   Macintosh file type code(s): "TEXT"

Person & email address to contact for further information: See
   the Authors' Addresses section of RFC 8040.

Intended usage: COMMON

Restrictions on usage: N/A

Author: See the Authors' Addresses section of RFC 8040.

Change controller: Internet Engineering Task Force
   (mailto:iesg@ietf.org).

Provisional registration? (standards tree only): no
            ]]></artwork>
        </figure>

</section>
</section>

<section title="RESTCONF Capability URNs">

    <t>
This document defines a registry for RESTCONF capability identifiers.
The name of the registry is &quot;RESTCONF Capability URNs&quot;.
The review policy for this registry is &quot;IETF Review&quot;
<xref target="RFC5226"/>. The registry shall record the following for each
entry: 
    </t>
<t>
 <list style="symbols">
 <t>
the name of the RESTCONF capability. By convention, this name begins
with the colon (&quot;:&quot;) character.
 </t>
 <t>
the URN for the RESTCONF capability.
 </t>
<t>
the reference for the document registering the value.
</t>
 </list>
</t>
    <t>
This document registers several capability identifiers in the
&quot;RESTCONF Capability URNs&quot; registry:
    </t>
        <figure>
            <artwork><![CDATA[
Index           Capability Identifier
---------------------------------------------------------------------
:defaults       urn:ietf:params:restconf:capability:defaults:1.0

:depth          urn:ietf:params:restconf:capability:depth:1.0

:fields         urn:ietf:params:restconf:capability:fields:1.0

:filter         urn:ietf:params:restconf:capability:filter:1.0

:replay         urn:ietf:params:restconf:capability:replay:1.0

:with-defaults  urn:ietf:params:restconf:capability:with-defaults:1.0
            ]]></artwork>
        </figure>
</section>
<section title="Registration of &quot;restconf&quot; URN Sub-namespace">
    <t>
IANA has registered a new URN sub-namespace within the "IETF URN Sub-namespace
for Registered Protocol Parameter Identifiers" registry
defined in <xref target="RFC3553"/>.
    </t>
        <figure>
            <artwork><![CDATA[
   Registry Name: restconf

   Specification: RFC 8040

   Repository: "RESTCONF Capability URNs" registry (Section 11.4)

   Index value:  Sub-parameters MUST be specified in UTF-8, using
      standard URI encoding where necessary.
            ]]></artwork>
        </figure>
</section>
</section>

<section title="Security Considerations">
    <t>
<xref target="integ-and-conf"/> states that
&quot;a RESTCONF server MUST support the
TLS protocol <xref target="RFC5246"/>.&quot;  This language
leaves open the possibility that a RESTCONF server might also support
future versions of the TLS protocol.  Of specific concern,
TLS&nbsp;1.3 <xref target="TLS1.3"/> introduces support for
0&nbhy;RTT handshakes that can lead to security issues for
RESTCONF APIs, as described in Appendix&nbsp;B.1 of the TLS&nbsp;1.3
document.  It is therefore RECOMMENDED that RESTCONF servers do not
support 0&nbhy;RTT at all (not even for idempotent requests) until an
update to this RFC guides otherwise.
    </t>
    <t>
<xref target="auth-client-id"/> recommends authentication based on
TLS client certificates but allows the use of any authentication
scheme defined in the &quot;Hypertext Transfer Protocol
(HTTP) Authentication Scheme Registry&quot;.  Implementations
need to be aware that the strengths of these methods
vary greatly and that some may be considered experimental.  Selection
of any of these schemes SHOULD be performed after reading the
Security Considerations section of the RFC associated with the
scheme&apos;s registry entry.
    </t>
    <t>
The &quot;ietf&#8209;restconf&#8209;monitoring&quot; YANG module defined
in this memo is designed to be accessed via the NETCONF protocol
<xref target="RFC6241"/>. The lowest NETCONF layer is the secure transport
layer, and the mandatory-to-implement secure transport is Secure Shell
(SSH) <xref target="RFC6242"/>. The NETCONF access control model
<xref target="RFC6536"/> provides the means to restrict access for
particular NETCONF users to a preconfigured subset of all available
NETCONF protocol operations and content.
    </t>
    <t>
The lowest RESTCONF layer is HTTPS, and the mandatory-to-implement
secure transport is TLS <xref target="RFC5246"/>.  The RESTCONF protocol
uses the NETCONF access control model <xref target="RFC6536"/>, which
provides the means to restrict access for particular RESTCONF users to a
preconfigured subset of all available RESTCONF protocol operations
and content.
    </t>
    <t>
This section provides security considerations for the resources
defined by the RESTCONF protocol.  Security considerations for
HTTPS are defined in <xref target="RFC7230"/>.  Aside from the
&quot;ietf&#8209;restconf&#8209;monitoring&quot; module
(<xref target="restconf-mon"/>) and the
&quot;ietf&nbhy;yang&nbhy;library&quot; module
(<xref target="yang-mod-lib"/>), RESTCONF does not specify which
YANG modules a server needs to support.  Security considerations for
the other modules manipulated by RESTCONF can be found in the documents
defining those YANG modules.
    </t>
    <t>
Configuration information is by its very nature sensitive.  Its
transmission in the clear and without integrity checking leaves
devices open to classic eavesdropping and false data injection
attacks.  Configuration information often contains passwords, user
names, service descriptions, and topological information, all of
which are sensitive.  There are many patterns of attack that have
been observed through operational practice with existing management
interfaces.  It would be wise for implementers to research them and
take them into account when implementing this protocol.
    </t>
    <t>
Different environments may well allow different rights prior to,
and then after, authentication.  When a RESTCONF operation is not
properly authorized, the RESTCONF server MUST return a
&quot;401 Unauthorized&quot; status-line. Note that authorization
information can be exchanged in the form of configuration information,
which is all the more reason to ensure the security of the connection.
Note that it is possible for a client to detect configuration changes
in data resources it is not authorized to access by monitoring changes
in the &quot;ETag&quot; and &quot;Last&nbhy;Modified&quot; header fields
returned by the server for the datastore resource.
    </t>
    <t>
A RESTCONF server implementation SHOULD attempt to prevent system
disruption due to excessive resource consumption required to
fulfill edit requests via the POST, PUT, and PATCH methods.
On such an implementation, it may be possible to construct an attack
that attempts to consume all available memory or other resource types.
    </t>
</section>
</middle>

<back>
<references title="Normative References">

 <?rfc include="reference.RFC.2046"?>
 <?rfc include="reference.RFC.2119"?>
 <?rfc include="reference.RFC.3553"?>
 <?rfc include="reference.RFC.3688"?>
 <?rfc include="reference.RFC.3986"?>
 <?rfc include="reference.RFC.5234"?>
 <?rfc include="reference.RFC.5246"?>
 <?rfc include="reference.RFC.5277"?>
 <?rfc include="reference.RFC.5280"?>
 <?rfc include="reference.RFC.5789"?>
 <?rfc include="reference.RFC.5988"?>
 <?rfc include="reference.RFC.6020"?>
 <?rfc include="reference.RFC.6241"?>
 <?rfc include="reference.RFC.6242"?>
 <?rfc include="reference.RFC.6243"?>
 <?rfc include="reference.RFC.6415"?>
 <?rfc include="reference.RFC.6536"?>
 <?rfc include="reference.RFC.6570"?>
 <?rfc include="reference.RFC.6991"?>
 <?rfc include="reference.RFC.7159"?>
 <?rfc include="reference.RFC.7230"?>
 <?rfc include="reference.RFC.7231"?>
 <?rfc include="reference.RFC.7232"?>
 <?rfc include="reference.RFC.7235"?>
 <?rfc include="reference.RFC.7320"?>
 <?rfc include="reference.RFC.7525"?>
 <?rfc include="reference.RFC.7589"?>
 <?rfc include="reference.RFC.7895"?>
 <?rfc include="reference.RFC.7950"?>
 <?rfc include="reference.RFC.7951"?>
 <?rfc include="reference.RFC.7952"?>

<reference anchor="W3C.REC-eventsource-20150203" target="http://www.w3.org/TR/2015/REC-eventsource-20150203">
<front>
<title>Server-Sent Events</title>
<author initials="I." surname="Hickson" fullname="Ian Hickson">
<organization/>
</author>
<date month="February" day="3" year="2015"/>
</front>
<seriesInfo name="World Wide Web Consortium Recommendation" value="REC-eventsource-20150203"/>
</reference>

<reference anchor='W3C.REC-xml-20081126'
           target='http://www.w3.org/TR/2008/REC&nbhy;xml-20081126'>
<front>
<title>Extensible Markup Language (XML) 1.0 (Fifth Edition)</title>
<author initials='T.' surname='Bray' fullname='Tim Bray'>
    <organization />
</author>
<author initials='J.' surname='Paoli' fullname='Jean Paoli'>
    <organization />
</author>
<author initials='M.' surname='Sperberg-McQueen' fullname='C. M. Sperberg-McQueen'>
    <organization />
</author>
<author initials='E.' surname='Maler' fullname='Eve Maler'>
    <organization />
</author>
<author initials='F.' surname='Yergeau' fullname='Francois Yergeau'>
    <organization />
</author>
<date month='November' day='26' year='2008' />
</front>
<seriesInfo name='World Wide Web Consortium Recommendation' value='REC-xml-20081126' />
</reference>

<reference anchor="XPath" target="http://www.w3.org/TR/1999/REC-xpath-19991116">
      <front>
        <title>XML Path Language (XPath) Version 1.0</title>
        <author initials="J." surname="Clark" fullname="James Clark">
          <organization/>
        </author>
        <author initials="S." surname="DeRose" fullname="Steven DeRose">
          <organization/>
        </author>
        <date month="November" day="16" year="1999"/>
      </front>
      <seriesInfo name="World Wide Web Consortium Recommendation" value="REC-xpath-19991116"/>
</reference>

</references>

<references title="Informative References">

 <?rfc include="reference.RFC.2818"?>
 <?rfc include="reference.RFC.5226"?>

  <reference anchor="REST-Dissertation">
      <front>
        <title>Architectural Styles and
the Design of Network-based Software Architectures</title>
        <author initials='R.F.' surname='Fielding' fullname='Roy Fielding'>
          <organization>University of California, Irvine</organization>
        </author>
        <date year='2000'/>
      </front>
  </reference>

<!-- draft-ietf-netconf-yang-patch (EDIT) -->
  <reference anchor="YANG-Patch">
     <front>
       <title>YANG Patch Media Type</title>
       <author initials="A.B." surname="Bierman" fullname="Andy Bierman">
         <organization />
       </author>
       <author initials="M.B." surname="Bjorklund" fullname="Martin Bjorklund">
         <organization />
       </author>
       <author initials="K.W." surname="Watsen" fullname="Kent Watsen">
         <organization />
       </author>
       <date year="2016" month="November"/>
     </front>
     <seriesInfo name="Work in Progress," value="draft-ietf-netconf-yang-patch-14"/>
</reference>

<!-- draft-ietf-tls-tls13 (I-D Exists) -->
<reference anchor="TLS1.3">
  <front>
    <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
    <author initials="E" surname="Rescorla" fullname="Eric Rescorla">
      <organization/>
    </author>
    <date month="October" year="2016"/>
  </front>
  <seriesInfo name="Work in Progress," value="draft-ietf-tls-tls13-18"/>
</reference>

</references>

<section title="Example YANG Module">
    <t>
The example YANG module used in this document represents
a simple media jukebox interface.
    </t>
    <t>
YANG tree diagram for the &quot;example&#8209;jukebox&quot; module:
    </t>
        <figure>
            <artwork><![CDATA[
   +--rw jukebox!
      +--rw library
      |  +--rw artist* [name]
      |  |  +--rw name     string
      |  |  +--rw album* [name]
      |  |     +--rw name     string
      |  |     +--rw genre?   identityref
      |  |     +--rw year?    uint16
      |  |     +--rw admin
      |  |     |  +--rw label?              string
      |  |     |  +--rw catalogue-number?   string
      |  |     +--rw song* [name]
      |  |        +--rw name        string
      |  |        +--rw location    string
      |  |        +--rw format?     string
      |  |        +--rw length?     uint32
      |  +--ro artist-count?   uint32
      |  +--ro album-count?    uint32
      |  +--ro song-count?     uint32
      +--rw playlist* [name]
      |  +--rw name           string
      |  +--rw description?   string
      |  +--rw song* [index]
      |     +--rw index    uint32
      |     +--rw id       instance-identifier
      +--rw player
         +--rw gap?   decimal64
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
  rpcs:
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
  +---x play
      +--ro input
         +--ro playlist       string
         +--ro song-number    uint32
            ]]></artwork>
        </figure>
<section title="&quot;example-jukebox&quot; YANG Module" anchor="example-module">

<figure>
            <artwork><![CDATA[
module example-jukebox {

   namespace "http://example.com/ns/example-jukebox";
   prefix "jbox";

   organization "Example, Inc.";
   contact "support at example.com";
   description "Example Jukebox Data Model Module.";
   revision "2016-08-15" {
     description "Initial version.";
     reference "example.com document 1-4673.";
   }

   identity genre {
     description
       "Base for all genre types.";
   }

   // abbreviated list of genre classifications
   identity alternative {
     base genre;
     description
       "Alternative music.";
   }
   identity blues {
     base genre;
     description
       "Blues music.";
   }
   identity country {
     base genre;
     description
       "Country music.";
   }
   identity jazz {
     base genre;
     description
       "Jazz music.";
   }
   identity pop {
     base genre;
     description
       "Pop music.";
   }
   identity rock {
     base genre;
     description
       "Rock music.";
   }

   container jukebox {
     presence
       "An empty container indicates that the jukebox
        service is available.";

     description
       "Represents a 'jukebox' resource, with a library, playlists,
        and a 'play' operation.";

     container library {

       description
         "Represents the 'jukebox' library resource.";

       list artist {
         key name;
         description
           "Represents one 'artist' resource within the
            'jukebox' library resource.";

         leaf name {
           type string {
             length "1 .. max";
           }
           description
             "The name of the artist.";
         }

         list album {
           key name;
           description
             "Represents one 'album' resource within one
              'artist' resource, within the jukebox library.";

           leaf name {
             type string {
               length "1 .. max";
             }
             description
               "The name of the album.";
           }

           leaf genre {
             type identityref { base genre; }
             description
               "The genre identifying the type of music on
                the album.";
           }

           leaf year {
             type uint16 {
               range "1900 .. max";
             }
             description
               "The year the album was released.";
           }

           container admin {
             description
               "Administrative information for the album.";

             leaf label {
               type string;
               description
                 "The label that released the album.";
             }
             leaf catalogue-number {
               type string;
               description
                 "The album's catalogue number.";
             }
           }

           list song {
             key name;
             description
               "Represents one 'song' resource within one
                'album' resource, within the jukebox library.";

             leaf name {
               type string {
                  length "1 .. max";
               }
               description
                 "The name of the song.";
             }
             leaf location {
               type string;
               mandatory true;
               description
                 "The file location string of the
                  media file for the song.";
             }
             leaf format {
               type string;
               description
                 "An identifier string for the media type
                  for the file associated with the
                  'location' leaf for this entry.";
             }
             leaf length {
               type uint32;
               units "seconds";
               description
                 "The duration of this song in seconds.";
             }
           }   // end list 'song'
         }   // end list 'album'
       }  // end list 'artist'

       leaf artist-count {
          type uint32;
          units "artists";
          config false;
          description
            "Number of artists in the library.";
       }
       leaf album-count {
          type uint32;
          units "albums";
          config false;
          description
            "Number of albums in the library.";
       }
       leaf song-count {
          type uint32;
          units "songs";
          config false;
          description
            "Number of songs in the library.";
       }
     }  // end library

     list playlist {
       key name;
       description
         "Example configuration data resource.";

       leaf name {
         type string;
         description
           "The name of the playlist.";
       }
       leaf description {
         type string;
         description
           "A comment describing the playlist.";
       }
       list song {
         key index;
         ordered-by user;

         description
           "Example nested configuration data resource.";

         leaf index {    // not really needed
           type uint32;
           description
             "An arbitrary integer index for this playlist song.";
         }
         leaf id {
           type instance-identifier;
           mandatory true;
           description
             "Song identifier.  Must identify an instance of
              /jukebox/library/artist/album/song/name.";
         }
       }
     }

     container player {
       description
         "Represents the jukebox player resource.";

       leaf gap {
         type decimal64 {
           fraction-digits 1;
           range "0.0 .. 2.0";
         }
         units "tenths of seconds";
         description
           "Time gap between each song.";
       }
     }
   }

   rpc play {
     description
       "Control function for the jukebox player.";
     input {
       leaf playlist {
         type string;
         mandatory true;
         description
           "The playlist name.";
       }
       leaf song-number {
         type uint32;
         mandatory true;
         description
           "Song number in playlist to play.";
       }
     }
   }
}
            ]]></artwork>
        </figure>
</section>

</section>
<section title="RESTCONF Message Examples" anchor="main-examples">
    <t>
The examples within this document use the normative
YANG module &quot;ietf&#8209;restconf&quot;
as defined in <xref target="module"/> and the non&nbhy;normative
example YANG module &quot;example&#8209;jukebox&quot;
as defined in <xref target="example-module"/>.
    </t>
    <t>
This section shows some typical RESTCONF message exchanges.
    </t>
<section title="Resource Retrieval Examples" anchor="ex-get">
<section title="Retrieve the Top-Level API Resource">
    <t>
The client starts by retrieving the RESTCONF root resource:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /.well-known/host-meta HTTP/1.1
   Host: example.com
   Accept: application/xrd+xml
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Content-Type: application/xrd+xml
   Content-Length: nnn
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <XRD xmlns='http://docs.oasis-open.org/ns/xri/xrd-1.0'>
       <Link rel='restconf' href='/restconf'/>
   </XRD>
            ]]></artwork>
        </figure>
    <t>
The client may then retrieve the top-level
API resource, using the root resource &quot;/restconf&quot;.
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf HTTP/1.1
   Host: example.com
   Accept: application/yang-data+json
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Content-Type: application/yang-data+json

   {
     "ietf-restconf:restconf" : {
       "data" : {},
       "operations" : {},
       "yang-library-version" : "2016-06-21"
     }
   }
            ]]></artwork>
        </figure>
    <t>
To request that the response content be encoded in XML,
the &quot;Accept&quot; header can be used, as in this example request:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf HTTP/1.1
   Host: example.com
   Accept: application/yang-data+xml
            ]]></artwork>
        </figure>
    <t>
The server will return the same conceptual data either way,
which might be as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <restconf xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf">
     <data/>
     <operations/>
     <yang-library-version>2016-06-21</yang-library-version>
   </restconf>
            ]]></artwork>
        </figure>
</section>
<section title="Retrieve the Server Module Information">
    <t>
It is possible that the YANG library module will change over time.
The client can retrieve the revision date of the
&quot;ietf-yang-library&quot; module supported by the server from
the API resource, as described in the previous section.
    </t>
    <t>
In this example, the client is retrieving the module information
from the server in JSON format:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf/data/ietf-yang-library:modules-state HTTP/1.1
   Host: example.com
   Accept: application/yang-data+json
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Last-Modified: Thu, 26 Jan 2017 14:00:14 GMT
   Content-Type: application/yang-data+json

   {
     "ietf-yang-library:modules-state" : {
       "module-set-id" : "5479120c17a619545ea6aff7aa19838b036ebbd7",
       "module" : [
         {
           "name" : "foo",
           "revision" : "2012-01-02",
           "schema" : "https://example.com/modules/foo/2012-01-02",
           "namespace" : "http://example.com/ns/foo",
           "feature" : [ "feature1", "feature2" ],
           "deviation" : [
             {
               "name" : "foo-dev",
               "revision" : "2012-02-16"
             }
           ],
           "conformance-type" : "implement"
         },
         {
           "name" : "ietf-yang-library",
           "revision" : "2016-06-21",
           "schema" : "https://example.com/modules/\
             ietf-yang-library/2016-06-21",
           "namespace" :
             "urn:ietf:params:xml:ns:yang:ietf-yang-library",
           "conformance-type" : "implement"
         },
         {
           "name" : "foo-types",
           "revision" : "2012-01-05",
           "schema" :
             "https://example.com/modules/foo-types/2012-01-05",
           "namespace" : "http://example.com/ns/foo-types",
           "conformance-type" : "import"
         },
         {
           "name" : "bar",
           "revision" : "2012-11-05",
           "schema" : "https://example.com/modules/bar/2012-11-05",
           "namespace" : "http://example.com/ns/bar",
           "feature" : [ "bar-ext" ],
           "conformance-type" : "implement",
           "submodule" : [
             {
               "name" : "bar-submod1",
               "revision" : "2012-11-05",
               "schema" :
                "https://example.com/modules/bar-submod1/2012-11-05"
             },
             {
               "name" : "bar-submod2",
               "revision" : "2012-11-05",
               "schema" :
                "https://example.com/modules/bar-submod2/2012-11-05"
             }
           ]
         }
       ]
     }
   }
            ]]></artwork>
        </figure>
</section>
<section title="Retrieve the Server Capability Information">
    <t>
In this example, the client is retrieving the capability information
from the server in XML format, and the server supports all of
the RESTCONF query parameters, plus one vendor parameter:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf/data/ietf-restconf-monitoring:restconf-state/\
       capabilities HTTP/1.1
   Host: example.com
   Accept: application/yang-data+xml
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Last-Modified: Thu, 26 Jan 2017 16:00:14 GMT
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <capabilities
       xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf-monitoring">
    <capability>\
     urn:ietf:params:restconf:capability:defaults:1.0?\
        basic-mode=explicit\
    </capability>
    <capability>\
     urn:ietf:params:restconf:capability:with-defaults:1.0\
    </capability>
    <capability>\
     urn:ietf:params:restconf:capability:depth:1.0\
    </capability>
    <capability>\
     urn:ietf:params:restconf:capability:fields:1.0\
    </capability>
    <capability>\
     urn:ietf:params:restconf:capability:filter:1.0\
    </capability>
    <capability>\
     urn:ietf:params:restconf:capability:start-time:1.0\
    </capability>
    <capability>\
     urn:ietf:params:restconf:capability:stop-time:1.0\
    </capability>
    <capability>\
     http://example.com/capabilities/myparam\
    </capability>
   </capabilities>
            ]]></artwork>
        </figure>
</section>
</section>
<section title="Data Resource and Datastore Resource Examples">

<section title="Create New Data Resources" anchor="ex-create">
    <t>
To create a new &quot;artist&quot; resource within the &quot;library&quot;
resource, the client might send the following request:
    </t>
        <figure>
            <artwork><![CDATA[
   POST /restconf/data/example-jukebox:jukebox/library HTTP/1.1
   Host: example.com
   Content-Type: application/yang-data+json

   {
     "example-jukebox:artist" : [
       {
         "name" : "Foo Fighters"
       }
     ]
   }
            ]]></artwork>
        </figure>
    <t>
If the resource is created, the server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Location: https://example.com/restconf/data/\
       example-jukebox:jukebox/library/artist=Foo%20Fighters
   Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
   ETag: "b3830f23a4c"
            ]]></artwork>
        </figure>
    <t>
To create a new &quot;album&quot; resource for this artist within
the &quot;jukebox&quot; resource, the client might send the
following request:
    </t>
        <figure>
            <artwork><![CDATA[
   POST /restconf/data/example-jukebox:jukebox/\
       library/artist=Foo%20Fighters HTTP/1.1
   Host: example.com
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <album xmlns="http://example.com/ns/example-jukebox">
     <name>Wasting Light</name>
     <year>2011</year>
   </album>
            ]]></artwork>
        </figure>
    <t>
If the resource is created, the server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Location: https://example.com/restconf/data/\
       example-jukebox:jukebox/library/artist=Foo%20Fighters/\
       album=Wasting%20Light
   Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
   ETag: "b8389233a4c"
            ]]></artwork>
        </figure>
</section>
<section title="Detect Datastore Resource Entity-Tag Change">
    <t>
In this example, the server just supports the
datastore last-changed timestamp.
Assume that the client has cached the &quot;Last&#8209;Modified&quot;
header from the response to the previous request.  This value is used
as in the &quot;If&nbhy;Unmodified&nbhy;Since&quot; header in the
following request to patch an &quot;album&quot; list entry with a
key value of &quot;Wasting Light&quot;.  Only the &quot;genre&quot; field
is being updated.
    </t>
        <figure>
            <artwork><![CDATA[
   PATCH /restconf/data/example-jukebox:jukebox/\
       library/artist=Foo%20Fighters/album=Wasting%20Light/\
       genre HTTP/1.1
   Host: example.com
   If-Unmodified-Since: Thu, 26 Jan 2017 20:56:30 GMT
   Content-Type: application/yang-data+json

   { "example-jukebox:genre" : "example-jukebox:alternative" }
            ]]></artwork>
        </figure>
    <t>
In this example, the datastore resource has changed
since the time specified in the &quot;If&#8209;Unmodified&#8209;Since&quot;
header.  The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 412 Precondition Failed
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Last-Modified: Thu, 26 Jan 2017 19:41:00 GMT
   ETag: "b34aed893a4c"
            ]]></artwork>
        </figure>
</section>
<section title="Edit a Datastore Resource">
    <t>
In this example, assume that there is a top-level data resource
named &quot;system&quot; from the example-system module,
and this container has a child leaf
called &quot;enable&#8209;jukebox&#8209;streaming&quot;:
    </t>
        <figure>
            <artwork><![CDATA[
   container system {
     leaf enable-jukebox-streaming {
       type boolean;
     }
   }
            ]]></artwork>
        </figure>
    <t>
In this example, PATCH is used by the client to modify two top-level
resources at once, in order to enable jukebox streaming
and add an &quot;album&quot; sub-resource to each of two
&quot;artist&quot; resources:
    </t>
        <figure>
            <artwork><![CDATA[
   PATCH /restconf/data HTTP/1.1
   Host: example.com
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <data xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf">
     <system xmlns="http://example.com/ns/example-system">
       <enable-jukebox-streaming>true</enable-jukebox-streaming>
     </system>
     <jukebox xmlns="http://example.com/ns/example-jukebox">
       <library>
         <artist>
           <name>Foo Fighters</name>
           <album>
             <name>One by One</name>
             <year>2012</year>
           </album>
         </artist>
         <artist>
           <name>Nick Cave and the Bad Seeds</name>
           <album>
             <name>Tender Prey</name>
             <year>1988</year>
           </album>
         </artist>
       </library>
     </jukebox>
   </data>
            ]]></artwork>
        </figure>
</section>
<section title="Replace a Datastore Resource" anchor="replace-datastore-ex">
    <t>
In this example, the entire configuration datastore contents
are being replaced. Any child nodes not present in the &lt;data&gt; element
but present in the server will be deleted.
    </t>
        <figure>
            <artwork><![CDATA[
   PUT /restconf/data HTTP/1.1
   Host: example.com
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <data xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf">
     <jukebox xmlns="http://example.com/ns/example-jukebox">
       <library>
         <artist>
           <name>Foo Fighters</name>
           <album>
             <name>One by One</name>
             <year>2012</year>
           </album>
         </artist>
         <artist>
           <name>Nick Cave and the Bad Seeds</name>
           <album>
             <name>Tender Prey</name>
             <year>1988</year>
           </album>
         </artist>
       </library>
     </jukebox>
   </data>
            ]]></artwork>
        </figure>
</section>
<section title="Edit a Data Resource">
    <t>
In this example, the client modifies one data node by
adding an &quot;album&quot; sub-resource by sending a PATCH for the data resource:
    </t>
        <figure>
            <artwork><![CDATA[
   PATCH /restconf/data/example-jukebox:jukebox/library/\
      artist=Nick%20Cave%20and%20the%20Bad%20Seeds HTTP/1.1
   Host: example.com
   Content-Type: application/yang-data+xml
            ]]></artwork>
        </figure>
        <figure>
            <artwork><![CDATA[
   <artist xmlns="http://example.com/ns/example-jukebox">
     <name>Nick Cave and the Bad Seeds</name>
     <album>
       <name>The Good Son</name>
       <year>1990</year>
     </album>
   </artist>
            ]]></artwork>
        </figure>
</section>
</section>
<section title="Query Parameter Examples" anchor="ex-query">
<section title="&quot;content&quot; Parameter">
    <t>
The &quot;content&quot; parameter is used to select the types of
data child resources (configuration and/or non-configuration)
that are returned by the server for a GET method request.
    </t>
    <t>
In this example, a simple YANG list is used that has configuration
and non&nbhy;configuration child resources.
    </t>
        <figure>
            <artwork><![CDATA[
  container events {
    list event {
      key name;
      leaf name { type string; }
      leaf description { type string; }
      leaf event-count {
        type uint32;
        config false;
      }
    }
  }
            ]]></artwork>
        </figure>
    <t>
Example 1: content=all
    </t>
    <t>
To retrieve all of the child resources, the &quot;content&quot; parameter
is set to &quot;all&quot;, or omitted, since this is the default value.
The client might send the following:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf/data/example-events:events?\
       content=all HTTP/1.1
   Host: example.com
   Accept: application/yang-data+json
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Content-Type: application/yang-data+json

   {
     "example-events:events" : {
       "event" : [
         {
           "name" : "interface-up",
           "description" : "Interface up notification count",
           "event-count" : 42
         },
         {
           "name" : "interface-down",
           "description" : "Interface down notification count",
           "event-count" : 4
         }
       ]
     }
   }
            ]]></artwork>
        </figure>
    <t>
Example 2: content=config
    </t>
    <t>
To retrieve only the configuration child resources,
the &quot;content&quot; parameter is set to &quot;config&quot;.
Note that the &quot;ETag&quot; and &quot;Last&#8209;Modified&quot; headers
are only returned if the &quot;content&quot; parameter value
is &quot;config&quot;.
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf/data/example-events:events?\
       content=config HTTP/1.1
   Host: example.com
   Accept: application/yang-data+json
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Last-Modified: Thu, 26 Jan 2017 16:45:20 GMT
   ETag: "eeeada438af"
   Cache-Control: no-cache
   Content-Type: application/yang-data+json

   {
     "example-events:events" : {
       "event" : [
         {
           "name" : "interface-up",
           "description" : "Interface up notification count"
         },
         {
           "name" : "interface-down",
           "description" : "Interface down notification count"
         }
       ]
     }
   }
            ]]></artwork>
        </figure>

    <t>
Example 3: content=nonconfig
    </t>
    <t>
To retrieve only the non-configuration child resources,
the &quot;content&quot; parameter is set to &quot;nonconfig&quot;. Note
that configuration ancestors (if any) and list key leafs
(if any) are also returned.  The client might send the following:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf/data/example-events:events?\
      content=nonconfig HTTP/1.1
   Host: example.com
   Accept: application/yang-data+json
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Content-Type: application/yang-data+json

   {
     "example-events:events" : {
       "event" : [
         {
           "name" : "interface-up",
           "event-count" : 42
         },
         {
           "name" : "interface-down",
           "event-count" : 4
         }
       ]
     }
   }
            ]]></artwork>
        </figure>
</section>
<section title="&quot;depth&quot; Parameter">
    <t>
The &quot;depth&quot; parameter is used to limit the number of levels
of child resources that are returned by the server for
a GET method request.
    </t>
    <t>
The &quot;depth&quot; parameter starts counting levels at the
level of the target resource that is specified,
so that a depth level of &quot;1&quot; includes just the target resource
level itself. A depth level of &quot;2&quot; includes the target resource
level and its child nodes.
    </t>
    <t>
This example shows how different values of the
&quot;depth&quot; parameter would affect the reply content for
the retrieval of the top-level &quot;jukebox&quot; data resource.
    </t>
    <t>
Example 1: depth=unbounded
    </t>
    <t>
To retrieve all of the child resources, the &quot;depth&quot; parameter
is not present or is set to the default value &quot;unbounded&quot;.
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf/data/example-jukebox:jukebox?\
       depth=unbounded HTTP/1.1
   Host: example.com
   Accept: application/yang-data+json
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Content-Type: application/yang-data+json

   {
     "example-jukebox:jukebox" : {
       "library" : {
         "artist" : [
           {
             "name" : "Foo Fighters",
             "album" : [
               {
                 "name" : "Wasting Light",
                 "genre" : "example-jukebox:alternative",
                 "year" : 2011,
                 "song" : [
                   {
                     "name" : "Wasting Light",
                     "location" :
                       "/media/foo/a7/wasting-light.mp3",
                     "format" : "MP3",
                     "length" : 286
                   },
                   {
                     "name" : "Rope",
                     "location" : "/media/foo/a7/rope.mp3",
                     "format" : "MP3",
                     "length" : 259
                   }
                 ]
               }
             ]
           }
         ]
       },
       "playlist" : [
         {
           "name" : "Foo-One",
           "description" : "example playlist 1",
           "song" : [
             {
               "index" : 1,
               "id" : "/example-jukebox:jukebox/library\
                  /artist[name='Foo Fighters']\
                  /album[name='Wasting Light']\
                  /song[name='Rope']"
             },
             {
               "index" : 2,
               "id" : "/example-jukebox:jukebox/library\
                  /artist[name='Foo Fighters']\
                  /album[name='Wasting Light']\
                  /song[name='Bridge Burning']"
             }
           ]
         }
       ],
       "player" : {
         "gap" : 0.5
       }
     }
   }
            ]]></artwork>
        </figure>
    <t>
Example 2: depth=1
    </t>
    <t>
To determine if one or more resource instances exist for
a given target resource, the value &quot;1&quot; is used.
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf/data/example-jukebox:jukebox?depth=1 HTTP/1.1
   Host: example.com
   Accept: application/yang-data+json
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Content-Type: application/yang-data+json

   {
     "example-jukebox:jukebox" : {}
   }
            ]]></artwork>
        </figure>
    <t>
Example 3: depth=3
    </t>
    <t>
To limit the depth level to the target resource plus
two child resource layers, the value &quot;3&quot; is used.
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf/data/example-jukebox:jukebox?depth=3 HTTP/1.1
   Host: example.com
   Accept: application/yang-data+json
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Content-Type: application/yang-data+json

   {
     "example-jukebox:jukebox" : {
       "library" : {
         "artist" : {}
       },
       "playlist" : [
         {
           "name" : "Foo-One",
           "description" : "example playlist 1",
           "song" : {}
         }
       ],
       "player" : {
         "gap" : 0.5
       }
     }
   }
            ]]></artwork>
        </figure>
</section>
<section title="&quot;fields&quot; Parameter">
    <t>
In this example, the client is retrieving the datastore resource
in JSON format, but retrieving only the
&quot;modules&#8209;state/module&quot; list, and
only the &quot;name&quot; and &quot;revision&quot; nodes
from each list entry. Note that the top node returned
by the server matches the target resource node (which is &quot;data&quot;
in this example). The &quot;module&#8209;set&#8209;id&quot; leaf is not
returned because it is not selected in the fields expression.
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf/data?fields=ietf-yang-library:modules-state/\
       module(name;revision) HTTP/1.1
   Host: example.com
   Accept: application/yang-data+json
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>

        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Content-Type: application/yang-data+json

   {
     "ietf-restconf:data" : {
       "ietf-yang-library:modules-state" : {
         "module" : [
           {
             "name" : "example-jukebox",
             "revision" : "2016-08-15"
           },
           {
             "name" : "ietf-inet-types",
             "revision" : "2013-07-15"
           },
           {
             "name" : "ietf-restconf-monitoring",
             "revision" : "2017-01-26"
           },
           {
             "name" : "ietf-yang-library",
             "revision" : "2016-06-21"
           },
           {
             "name" : "ietf-yang-types",
             "revision" : "2013-07-15"
           }
         ]
       }
     }
   }
            ]]></artwork>
        </figure>
</section>
<section title="&quot;insert&quot; Parameter">
    <t>
In this example, a new first song entry in the &quot;Foo&#8209;One&quot; playlist
is being created.
    </t>
    <t>
Request from client:
    </t>
        <figure>
            <artwork><![CDATA[
   POST /restconf/data/example-jukebox:jukebox/\
       playlist=Foo-One?insert=first HTTP/1.1
   Host: example.com
   Content-Type: application/yang-data+json

   {
     "example-jukebox:song" : [
        {
          "index" : 1,
          "id" : "/example-jukebox:jukebox/library\
             /artist[name='Foo Fighters']\
             /album[name='Wasting Light']\
             /song[name='Rope']"
        }
      ]
   }
            ]]></artwork>
        </figure>
    <t>
Response from server:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
   Location: https://example.com/restconf/data/\
       example-jukebox:jukebox/playlist=Foo-One/song=1
   ETag: "eeeada438af"
            ]]></artwork>
        </figure>
</section>
<section title="&quot;point&quot; Parameter">
    <t>
In this example, the client is inserting a new song entry in the
&quot;Foo&#8209;One&quot; playlist after the first song.
    </t>
    <t>
Request from client:
    </t>
        <figure>
            <artwork><![CDATA[
   POST /restconf/data/example-jukebox:jukebox/\
       playlist=Foo-One?insert=after&point=\
       %2Fexample-jukebox%3Ajukebox\
       %2Fplaylist%3DFoo-One%2Fsong%3D1 HTTP/1.1
   Host: example.com
   Content-Type: application/yang-data+json

   {
     "example-jukebox:song" : [
        {
          "index" : 2,
          "id" : "/example-jukebox:jukebox/library\
             /artist[name='Foo Fighters']\
             /album[name='Wasting Light']\
             /song[name='Bridge Burning']"
        }
      ]
   }
            ]]></artwork>
        </figure>
    <t>
Response from server:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
   Location: https://example.com/restconf/data/\
       example-jukebox:jukebox/playlist=Foo-One/song=2
   ETag: "abcada438af"
            ]]></artwork>
        </figure>
</section>
<section title="&quot;filter&quot; Parameter" anchor="ex-filters">
    <t>
The following URIs show some examples of notification filter
specifications:
    </t>
        <figure>
            <artwork><![CDATA[
   // filter = /event/event-class='fault'
   GET /streams/NETCONF?filter=%2Fevent%2Fevent-class%3D'fault'

   // filter = /event/severity<=4
   GET /streams/NETCONF?filter=%2Fevent%2Fseverity%3C%3D4

   // filter = /linkUp|/linkDown
   GET /streams/SNMP?filter=%2FlinkUp%7C%2FlinkDown

   // filter = /*/reporting-entity/card!='Ethernet0'
   GET /streams/NETCONF?\
      filter=%2F*%2Freporting-entity%2Fcard%21%3D'Ethernet0'

   // filter = /*/email-addr[contains(.,'company.com')]
   GET /streams/critical-syslog?\
      filter=%2F*%2Femail-addr[contains(.%2C'company.com')]

   // Note: The module name is used as the prefix.
   // filter = (/example-mod:event1/name='joe' and
   //           /example-mod:event1/status='online')
   GET /streams/NETCONF?\
     filter=(%2Fexample-mod%3Aevent1%2Fname%3D'joe'%20and\
             %20%2Fexample-mod%3Aevent1%2Fstatus%3D'online')

   // To get notifications from just two modules (e.g., m1 + m2)
   // filter=(/m1:* or /m2:*)
   GET /streams/NETCONF?filter=(%2Fm1%3A*%20or%20%2Fm2%3A*)
            ]]></artwork>
        </figure>
</section>
<section title="&quot;start-time&quot; Parameter">
    <t>
The following URI shows an example of the &quot;start&#8209;time&quot; query parameter:
    </t>
        <figure>
            <artwork><![CDATA[
   // start-time = 2014-10-25T10:02:00Z
   GET /streams/NETCONF?start-time=2014-10-25T10%3A02%3A00Z
            ]]></artwork>
        </figure>
</section>
<section title="&quot;stop-time&quot; Parameter">
    <t>
The following URI shows an example of the &quot;stop&#8209;time&quot; query parameter:
    </t>
        <figure>
            <artwork><![CDATA[
   // start-time = 2014-10-25T10:02:00Z
   // stop-time = 2014-10-25T12:31:00Z
   GET /mystreams/NETCONF?start-time=2014-10-25T10%3A02%3A00Z\
      &stop-time=2014-10-25T12%3A31%3A00Z
            ]]></artwork>
        </figure>
</section>
<section title="&quot;with-defaults&quot; Parameter" anchor="with-defaults-example">
    <t>
Assume that the server implements the module &quot;example&quot;
defined in Appendix&nbsp;A.1 of <xref target="RFC6243"/>,
and assume that the server&apos;s datastore is as defined in
Appendix&nbsp;A.2 of <xref target="RFC6243"/>.
    </t>
    <t>
If the server&apos;s &quot;basic-mode&quot; parameter in the
&quot;defaults&quot; protocol capability URI
(<xref target="defaults-uri"/>) is &quot;trim&quot;, the following
request for interface &quot;eth1&quot; might be as follows:
    </t>
    <t>
Without query parameter:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf/data/example:interfaces/interface=eth1 HTTP/1.1
   Host: example.com
   Accept: application/yang-data+json
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Content-Type: application/yang-data+json

   {
     "example:interface" : [
       {
         "name" : "eth1",
         "status" : "up"
       }
     ]
   }
            ]]></artwork>
        </figure>
    <t>
Note that the &quot;mtu&quot; leaf is missing because it is set to
the default &quot;1500&quot;, and the server&apos;s default-handling
&quot;basic&nbhy;mode&quot; parameter is &quot;trim&quot;.
    </t>
    <t>
With query parameter:
    </t>
        <figure>
            <artwork><![CDATA[
   GET /restconf/data/example:interfaces/interface=eth1\
       ?with-defaults=report-all HTTP/1.1
   Host: example.com
   Accept: application/yang-data+json
            ]]></artwork>
        </figure>
    <t>
The server might respond as follows:
    </t>
        <figure>
            <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Thu, 26 Jan 2017 20:56:30 GMT
   Server: example-server
   Content-Type: application/yang-data+json

   {
     "example:interface" : [
       {
         "name" : "eth1",
         "mtu" : 1500,
         "status" : "up"
       }
     ]
   }
            ]]></artwork>
        </figure>
    <t>
Note that the server returns the &quot;mtu&quot; leaf because the &quot;report&#8209;all&quot;
mode was requested with the &quot;with&#8209;defaults&quot; query parameter.
    </t>
</section>
</section>
</section>

<section title="Acknowledgements" numbered="no">
    <t>
The authors would like to thank the following people for
their contributions to this document: Ladislav Lhotka,
Juergen Schoenwaelder, Rex Fernando, Robert Wilton,
and Jonathan Hansford.
    </t>
    <t>
The authors would like to thank the following people for
their excellent technical reviews of this document:
Mehmet Ersue, Mahesh Jethanandani, Qin Wu, Joe Clarke, Bert Wijnen,
Ladislav Lhotka, Rodney Cummings, Frank Xialiang, Tom Petch, Robert Sparks,
Balint Uveges, Randy Presuhn, Sue Hares, Mark Nottingham,
Benoit Claise, Dale Worley, and Lionel Morand.
    </t>
    <t>
Contributions to this material by Andy Bierman are based upon work
supported by the United States Army,
Space &amp; Terrestrial Communications Directorate
(S&amp;TCD) under Contract No.&nbsp;W15P7T&nbhy;13&nbhy;C&nbhy;A616.
Any opinions, findings, and conclusions or recommendations expressed in
this material are those of the author(s) and do not necessarily reflect
the views of the S&amp;TCD.
    </t>
</section>

</back>
</rfc>
