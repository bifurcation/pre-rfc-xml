<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc rfcedstyle="yes" ?>
<?rfc subcompact="no" ?>
<?rfc toc="yes" ?>
<?rfc tocdepth="2" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<!-- <?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?> -->
<!-- <?rfc compact="yes" ?> -->
<!-- <?rfc tocindent="yes" ?> -->
<!-- <?rfc colonspace="yes" ?> -->
<!-- <?rfc iprnotified="yes" ?> -->
<!-- <?rfc strict="no" ?> -->
<!-- <?rfc editing="no"?> -->
<rfc category="std" ipr="full3978" number="4871" obsoletes="4870">
  <front>
    <title abbrev="DKIM Signatures">DomainKeys Identified Mail (DKIM)
    Signatures</title>

    <author fullname="Eric Allman" initials="E." surname="Allman">
      <organization>Sendmail, Inc.</organization>

      <address>
        <postal>
          <street>6425 Christie Ave, Suite 400</street>

          <city>Emeryville</city>

          <region>CA</region>

          <code>94608</code>

          <country>USA</country>
        </postal>

        <phone>+1 510 594 5501</phone>

        <email>eric+dkim@sendmail.org</email>

        <uri></uri>
      </address>
    </author>

    <author fullname="Jon Callas" initials="J." surname="Callas">
      <organization>PGP Corporation</organization>

      <address>
        <postal>
          <street>3460 West Bayshore</street>

          <city>Palo Alto</city>

          <region>CA</region>

          <code>94303</code>

          <country>USA</country>
        </postal>

        <phone>+1 650 319 9016</phone>

        <email>jon@pgp.com</email>
      </address>
    </author>

    <author fullname="Mark Delany" initials="M." surname="Delany">
      <organization>Yahoo! Inc</organization>

      <address>
        <postal>
          <street>701 First Avenue</street>

          <city>Sunnyvale</city>

          <region>CA</region>

          <code>95087</code>

          <country>USA</country>
        </postal>

        <phone>+1 408 349 6831</phone>

        <email>markd+dkim@yahoo-inc.com</email>

        <uri></uri>
      </address>
    </author>

    <author fullname="Miles Libbey" initials="M." surname="Libbey">
      <organization>Yahoo! Inc</organization>

      <address>
        <postal>
          <street>701 First Avenue</street>

          <city>Sunnyvale</city>

          <region>CA</region>

          <code>95087</code>

          <country>USA</country>
        </postal>

        <email>mlibbeymail-mailsig@yahoo.com</email>

        <uri></uri>
      </address>
    </author>

    <author fullname="Jim Fenton" initials="J." surname="Fenton">
      <organization>Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>MS SJ-9/2</street>

          <street>170 W. Tasman Drive</street>

          <city>San Jose</city>

          <region>CA</region>

          <code>95134-1706</code>

          <country>USA</country>
        </postal>

        <phone>+1 408 526 5914</phone>

        <email>fenton@cisco.com</email>

        <uri></uri>
      </address>
    </author>

    <author fullname="Michael Thomas" initials="M." surname="Thomas">
      <organization>Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>MS SJ-9/2</street>

          <street>170 W. Tasman Drive</street>

          <city>San Jose</city>

          <region>CA</region>

          <code>95134-1706</code>
        </postal>

        <phone>+1 408 525 5386</phone>

        <email>mat@cisco.com</email>
      </address>
    </author>

    <date month="May" year="2007" />

    <workgroup>DKIM</workgroup>

    <keyword>internet mail</keyword>

    <keyword>authentication</keyword>

    <keyword>spam</keyword>

    <keyword>phishing</keyword>

    <keyword>spoofing</keyword>

    <keyword>digital signature</keyword>

    <!-- 1. RFC Editor Comment: Please insert any keywords (beyond those that
appear in the title) for use on
http://www.rfc-editor.org/search.html. Please insert your keywords
using the keyword element (<keyword> insert here </keyword>). -->

    <abstract>
      <t>DomainKeys Identified Mail (DKIM) defines a domain-level
      authentication framework for email using public-key cryptography and key
      server technology to permit verification of the source and contents of
      messages by either Mail Transfer Agents (MTAs) or Mail User Agents
      (MUAs). The ultimate goal of this framework is to permit a signing
      domain to assert responsibility for a message, thus protecting message
      signer identity and the integrity of the messages they convey while
      retaining the functionality of Internet email as it is known today.
      Protection of email identity may assist in the global control of "spam"
      and "phishing".</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>DomainKeys Identified Mail (DKIM) defines a mechanism by which email
      messages can be cryptographically signed, permitting a signing domain to
      claim responsibility for the introduction of a message into the mail
      stream. Message recipients can verify the signature by querying the
      signer's domain directly to retrieve the appropriate public key, and
      thereby confirm that the message was attested to by a party in
      possession of the private key for the signing domain.</t>

      <t>The approach taken by DKIM differs from previous approaches to
      message signing (e.g., <xref target="RFC1847">Secure/Multipurpose
      Internet Mail Extensions (S/MIME)</xref>, <xref
      target="RFC2440">OpenPGP</xref>) in that: <list style="symbols">
          <t>the message signature is written as a message header field so
          that neither human recipients nor existing MUA (Mail User Agent)
          software is confused by signature-related content appearing in the
          message body;</t>

          <t>there is no dependency on public and private key pairs being
          issued by well-known, trusted certificate authorities;</t>

          <t>there is no dependency on the deployment of any new Internet
          protocols or services for public key distribution or revocation;</t>

          <t>signature verification failure does not force rejection of the
          message;</t>

          <t>no attempt is made to include encryption as part of the
          mechanism;</t>

          <t>message archiving is not a design goal.</t>
        </list></t>

      <t>DKIM: <list style="symbols">
          <t>is compatible with the existing email infrastructure and
          transparent to the fullest extent possible;</t>

          <t>requires minimal new infrastructure;</t>

          <t>can be implemented independently of clients in order to reduce
          deployment time;</t>

          <t>can be deployed incrementally;</t>

          <t>allows delegation of signing to third parties.</t>
        </list></t>

      <section title="Signing Identity">
        <t>DKIM separates the question of the identity of the signer of the
        message from the purported author of the message. In particular, a
        signature includes the identity of the signer. Verifiers can use the
        signing information to decide how they want to process the message.
        The signing identity is included as part of the signature header
        field.<list>
            <t>INFORMATIVE RATIONALE: The signing identity specified by a DKIM
            signature is not required to match an address in any particular
            header field because of the broad methods of interpretation by
            recipient mail systems, including MUAs.</t>
          </list></t>
      </section>

      <section title="Scalability">
        <t>DKIM is designed to support the extreme scalability requirements
        that characterize the email identification problem. There are
        currently over 70 million domains and a much larger number of
        individual addresses. DKIM seeks to preserve the positive aspects of
        the current email infrastructure, such as the ability for anyone to
        communicate with anyone else without introduction.</t>
      </section>

      <section title="Simple Key Management">
        <t>DKIM differs from traditional hierarchical public-key systems in
        that no Certificate Authority infrastructure is required; the verifier
        requests the public key from a repository in the domain of the claimed
        signer directly rather than from a third party.</t>

        <t>The DNS is proposed as the initial mechanism for the public keys.
        Thus, DKIM currently depends on DNS administration and the security of
        the DNS system. DKIM is designed to be extensible to other key
        fetching services as they become available.</t>
      </section>
    </section>

    <section title="Terminology and Definitions">
      <t>This section defines terms used in the rest of the document. Syntax
      descriptions use the form described in <xref target="RFC4234">Augmented
      BNF for Syntax Specifications </xref>.</t>

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref>.</t>

      <section anchor="def-signers" title="Signers">
        <t>Elements in the mail system that sign messages on behalf of a
        domain are referred to as signers. These may be MUAs (Mail User
        Agents), MSAs (Mail Submission Agents), MTAs (Mail Transfer Agents),
        or other agents such as mailing list exploders. In general, any signer
        will be involved in the injection of a message into the message system
        in some way. The key issue is that a message must be signed before it
        leaves the administrative domain of the signer.</t>
      </section>

      <section anchor="def-verifiers" title="Verifiers">
        <t>Elements in the mail system that verify signatures are referred to
        as verifiers. These may be MTAs, Mail Delivery Agents (MDAs), or MUAs.
        In most cases it is expected that verifiers will be close to an end
        user (reader) of the message or some consuming agent such as a mailing
        list exploder.</t>
      </section>

      <section title="Whitespace">
        <t>There are three forms of whitespace: <list style="symbols">
            <t>WSP represents simple whitespace, i.e., a space or a tab
            character (formal definition in <xref
            target="RFC4234"></xref>).</t>

            <t>LWSP is linear whitespace, defined as WSP plus CRLF (formal
            definition in <xref target="RFC4234"></xref>).</t>

            <t>FWS is folding whitespace. It allows multiple lines separated
            by CRLF followed by at least one whitespace, to be joined.</t>
          </list></t>

        <t>The formal ABNF for these are (WSP and LWSP are given for
        information only):</t>

        <figure>
          <artwork type="abnf"><![CDATA[    
    WSP =   SP / HTAB
    LWSP =  *(WSP / CRLF WSP)
    FWS =   [*WSP CRLF] 1*WSP]]></artwork>
        </figure>

        <t>The definition of FWS is identical to that in <xref
        target="RFC2822"></xref> except for the exclusion of obs-FWS.</t>
      </section>

      <section title="Common ABNF Tokens">
        <t>The following ABNF tokens are used elsewhere in this document:</t>

        <figure>
          <artwork type="abnf"><![CDATA[    
    hyphenated-word =  ALPHA [ *(ALPHA / DIGIT / "-") (ALPHA / DIGIT) ]
    base64string =     1*(ALPHA / DIGIT / "+" / "/" / [FWS])
                       [ "=" [FWS] [ "=" [FWS] ] ]]]></artwork>
        </figure>
      </section>

      <section title="Imported ABNF Tokens">
        <t>The following tokens are imported from other RFCs as noted. Those
        RFCs should be considered definitive.</t>

        <t>The following tokens are imported from <xref
        target="RFC2821"></xref>: <list style="symbols">
            <t><spanx style="verb">Local-part</spanx> (implementation warning:
            this permits quoted strings)</t>

            <!-- 2. RFC Editor Comment: What is the preferred capitalization for
Local-part vs local-part?  -->

            <!-- Author response: as ugly as it is, with a capital "L".  It's imported
from RFC2821 -->

            <t><spanx style="verb">sub-domain</spanx></t>
          </list></t>

        <t>The following tokens are imported from <xref
        target="RFC2822"></xref>: <list style="symbols">
            <t><spanx style="verb">field-name</spanx> (name of a header
            field)</t>

            <t><spanx style="verb">dot-atom-text</spanx> (in the Local-part of
            an email address)</t>
          </list></t>

        <t>The following tokens are imported from <xref
        target="RFC2045"></xref>:<list style="symbols">
            <t><spanx style="verb">qp-section</spanx> (a single line of
            quoted-printable-encoded text)</t>

            <t><spanx style="verb">hex-octet</spanx> (a quoted-printable
            encoded octet)</t>
          </list><list style="empty">
            <t>INFORMATIVE NOTE: Be aware that the ABNF in RFC 2045 does not
            obey the rules of RFC 4234 and must be interpreted accordingly,
            particularly as regards case folding.</t>
          </list></t>

        <t>Other tokens not defined herein are imported from <xref
        target="RFC4234"></xref>. These are intuitive primitives such as SP,
        HTAB, WSP, ALPHA, DIGIT, CRLF, etc.</t>
      </section>

      <section anchor="dkim-qp" title="DKIM-Quoted-Printable">
        <t>The DKIM-Quoted-Printable encoding syntax resembles that described
        in <xref target="RFC2045">Quoted-Printable</xref>, Section 6.7: any
        character MAY be encoded as an "=" followed by two hexadecimal digits
        from the alphabet "0123456789ABCDEF" (no lowercase characters
        permitted) representing the hexadecimal-encoded integer value of that
        character. All control characters (those with values &lt; %x20), 8-bit
        characters (values &gt; %x7F), and the characters DEL (%x7F), SPACE
        (%x20), and semicolon (";", %x3B) MUST be encoded. Note that all
        whitespace, including SPACE, CR, and LF characters, MUST be encoded.
        After encoding, FWS MAY be added at arbitrary locations in order to
        avoid excessively long lines; such whitespace is NOT part of the
        value, and MUST be removed before decoding.</t>

        <figure>
          <preamble>ABNF:</preamble>

          <artwork type="abnf"><![CDATA[    
    dkim-quoted-printable =
                       *(FWS / hex-octet / dkim-safe-char)
                  ; hex-octet is from RFC 2045
    dkim-safe-char =   %x21-3A / %x3C / %x3E-7E
                  ; '!' - ':', '<', '>' - '~'
                  ; Characters not listed as "mail-safe" in
                  ; RFC 2049 are also not recommended.]]></artwork>
        </figure>

        <t><list style="empty">
            <t>INFORMATIVE NOTE: DKIM-Quoted-Printable differs from
            Quoted-Printable as defined in RFC 2045 in several important
            ways:<list style="numbers">
                <t>Whitespace in the input text, including CR and LF, must be
                encoded. RFC 2045 does not require such encoding, and does not
                permit encoding of CR or LF characters that are part of a CRLF
                line break.</t>

                <t>Whitespace in the encoded text is ignored. This is to allow
                tags encoded using DKIM-Quoted-Printable to be wrapped as
                needed. In particular, RFC 2045 requires that line breaks in
                the input be represented as physical line breaks; that is not
                the case here.</t>

                <t>The "soft line break" syntax ("=" as the last
                non-whitespace character on the line) does not apply.</t>

                <t>DKIM-Quoted-Printable does not require that encoded lines
                be no more than 76 characters long (although there may be
                other requirements depending on the context in which the
                encoded text is being used).</t>
              </list></t>
          </list></t>
      </section>
    </section>

    <section title="Protocol Elements">
      <t>Protocol Elements are conceptual parts of the protocol that are not
      specific to either signers or verifiers. The protocol descriptions for
      signers and verifiers are described in later sections (<xref
      target="signer-actions">Signer Actions </xref> and <xref
      target="verifier-actions">Verifier Actions</xref>). NOTE: This section
      must be read in the context of those sections.</t>

      <section anchor="def-selectors" title="Selectors">
        <t>To support multiple concurrent public keys per signing domain, the
        key namespace is subdivided using "selectors". For example, selectors
        might indicate the names of office locations (e.g., "sanfrancisco",
        "coolumbeach", and "reykjavik"), the signing date (e.g.,
        "january2005", "february2005", etc.), or even the individual user.</t>

        <t>Selectors are needed to support some important use cases. For
        example: <list style="symbols">
            <t>Domains that want to delegate signing capability for a specific
            address for a given duration to a partner, such as an advertising
            provider or other outsourced function.</t>

            <t>Domains that want to allow frequent travelers to send messages
            locally without the need to connect with a particular MSA.</t>

            <t>"Affinity" domains (e.g., college alumni associations) that
            provide forwarding of incoming mail, but that do not operate a
            mail submission agent for outgoing mail.</t>
          </list></t>

        <t>Periods are allowed in selectors and are component separators. When
        keys are retrieved from the DNS, periods in selectors define DNS label
        boundaries in a manner similar to the conventional use in domain
        names. Selector components might be used to combine dates with
        locations, for example, "march2005.reykjavik". In a DNS
        implementation, this can be used to allow delegation of a portion of
        the selector namespace.</t>

        <figure>
          <preamble>ABNF:</preamble>

          <artwork type="abnf"><![CDATA[     
   selector =   sub-domain *( "." sub-domain )]]></artwork>

          <postamble></postamble>
        </figure>

        <t>The number of public keys and corresponding selectors for each
        domain is determined by the domain owner. Many domain owners will be
        satisfied with just one selector, whereas administratively distributed
        organizations may choose to manage disparate selectors and key pairs
        in different regions or on different email servers.</t>

        <t>Beyond administrative convenience, selectors make it possible to
        seamlessly replace public keys on a routine basis. If a domain wishes
        to change from using a public key associated with selector
        "january2005" to a public key associated with selector "february2005",
        it merely makes sure that both public keys are advertised in the
        public-key repository concurrently for the transition period during
        which email may be in transit prior to verification. At the start of
        the transition period, the outbound email servers are configured to
        sign with the "february2005" private key. At the end of the transition
        period, the "january2005" public key is removed from the public-key
        repository.<list style="empty">
            <t>INFORMATIVE NOTE: A key may also be revoked as described below.
            The distinction between revoking and removing a key selector
            record is subtle. When phasing out keys as described above, a
            signing domain would probably simply remove the key record after
            the transition period. However, a signing domain could elect to
            revoke the key (but maintain the key record) for a further period.
            There is no defined semantic difference between a revoked key and
            a removed key.</t>
          </list></t>

        <t>While some domains may wish to make selector values well known,
        others will want to take care not to allocate selector names in a way
        that allows harvesting of data by outside parties. For example, if
        per-user keys are issued, the domain owner will need to make the
        decision as to whether to associate this selector directly with the
        user name, or make it some unassociated random value, such as a
        fingerprint of the public key.<list style="empty">
            <t>INFORMATIVE OPERATIONS NOTE: Reusing a selector with a new key
            (for example, changing the key associated with a user's name)
            makes it impossible to tell the difference between a message that
            didn't verify because the key is no longer valid versus a message
            that is actually forged. For this reason, signers are ill-advised
            to reuse selectors for new keys. A better strategy is to assign
            new keys to new selectors.</t>
          </list></t>
      </section>

      <section anchor="def-tag-list" title="Tag=Value Lists">
        <t>DKIM uses a simple "tag=value" syntax in several contexts,
        including in messages and domain signature records.</t>

        <t>Values are a series of strings containing either plain text, <spanx
        style="verb">base64</spanx> text (as defined in <xref
        target="RFC2045"></xref>, Section 6.8), <spanx
        style="verb">qp-section</spanx> (ibid, Section 6.7), or <spanx
        style="verb">dkim-quoted-printable</spanx> (as defined in <xref
        target="dkim-qp"></xref>). The name of the tag will determine the
        encoding of each value. Unencoded semicolon (";") characters MUST NOT
        occur in the tag value, since that separates tag-specs.<list
            style="empty">
            <t>INFORMATIVE IMPLEMENTATION NOTE: Although the "plain text"
            defined below (as <spanx style="verb">tag-value</spanx>) only
            includes 7-bit characters, an implementation that wished to
            anticipate future standards would be advised not to preclude the
            use of UTF8-encoded text in tag=value lists.</t>
          </list></t>

        <figure>
          <preamble>Formally, the syntax rules are as follows:</preamble>

          <artwork type="abnf"><![CDATA[     
     tag-list  =  tag-spec 0*( ";" tag-spec ) [ ";" ]
     tag-spec  =  [FWS] tag-name [FWS] "=" [FWS] tag-value [FWS]
     tag-name  =  ALPHA 0*ALNUMPUNC
     tag-value =  [ tval 0*( 1*(WSP / FWS) tval ) ]
                       ; WSP and FWS prohibited at beginning and end
     tval      =  1*VALCHAR
     VALCHAR   =  %x21-3A / %x3C-7E
                       ; EXCLAMATION to TILDE except SEMICOLON
     ALNUMPUNC =  ALPHA / DIGIT / "_"]]></artwork>
        </figure>

        <t>Note that WSP is allowed anywhere around tags. In particular, any
        WSP after the "=" and any WSP before the terminating ";" is not part
        of the value; however, WSP inside the value is significant.</t>

        <t>Tags MUST be interpreted in a case-sensitive manner. Values MUST be
        processed as case sensitive unless the specific tag description of
        semantics specifies case insensitivity.</t>

        <t>Tags with duplicate names MUST NOT occur within a single tag-list;
        if a tag name does occur more than once, the entire tag-list is
        invalid.</t>

        <t>Whitespace within a value MUST be retained unless explicitly
        excluded by the specific tag description.</t>

        <t>Tag=value pairs that represent the default value MAY be included to
        aid legibility.</t>

        <t>Unrecognized tags MUST be ignored.</t>

        <t>Tags that have an empty value are not the same as omitted tags. An
        omitted tag is treated as having the default value; a tag with an
        empty value explicitly designates the empty string as the value. For
        example, "g=" does not mean "g=*", even though "g=*" is the default
        for that tag.</t>
      </section>

      <section anchor="sig-algs" title="Signing and Verification Algorithms">
        <t>DKIM supports multiple digital signature algorithms. Two algorithms
        are defined by this specification at this time: rsa-sha1 and
        rsa-sha256. The rsa-sha256 algorithm is the default if no algorithm is
        specified. Verifiers MUST implement both rsa-sha1 and rsa-sha256.
        Signers MUST implement and SHOULD sign using rsa-sha256.<list
            style="empty">
            <?rfc needLines="10" ?>

            <t>INFORMATIVE NOTE: Although sha256 is strongly encouraged, some
            senders of low-security messages (such as routine newsletters) may
            prefer to use sha1 because of reduced CPU requirements to compute
            a sha1 hash. In general, sha256 should always be used whenever
            possible.</t>
          </list></t>

        <section title="The rsa-sha1 Signing Algorithm">
          <t>The rsa-sha1 Signing Algorithm computes a message hash as
          described in <xref target="hashing"></xref> below using SHA-1 <xref
          target="FIPS.180-2.2002"></xref> as the hash-alg. That hash is then
          signed by the signer using the RSA algorithm (defined in <xref
          target="RFC3447">PKCS#1 version 1.5</xref>) as the crypt-alg and the
          signer's private key. The hash MUST NOT be truncated or converted
          into any form other than the native binary form before being signed.
          The signing algorithm SHOULD use a public exponent of 65537.</t>
        </section>

        <section title="The rsa-sha256 Signing Algorithm">
          <t>The rsa-sha256 Signing Algorithm computes a message hash as
          described in <xref target="hashing"></xref> below using SHA-256
          <xref target="FIPS.180-2.2002"></xref> as the hash-alg. That hash is
          then signed by the signer using the RSA algorithm (defined in <xref
          target="RFC3447">PKCS#1 version 1.5</xref>) as the crypt-alg and the
          signer's private key. The hash MUST NOT be truncated or converted
          into any form other than the native binary form before being
          signed.</t>
        </section>

        <section title="Key Sizes">
          <t>Selecting appropriate key sizes is a trade-off between cost,
          performance, and risk. Since short RSA keys more easily succumb to
          off-line attacks, signers MUST use RSA keys of at least 1024 bits
          for long-lived keys. Verifiers MUST be able to validate signatures
          with keys ranging from 512 bits to 2048 bits, and they MAY be able
          to validate signatures with larger keys. Verifier policies may use
          the length of the signing key as one metric for determining whether
          a signature is acceptable.</t>

          <t>Factors that should influence the key size choice include the
          following: <list style="symbols">
              <t>The practical constraint that large (e.g., 4096 bit) keys may
              not fit within a 512-byte DNS UDP response packet</t>

              <t>The security constraint that keys smaller than 1024 bits are
              subject to off-line attacks</t>

              <t>Larger keys impose higher CPU costs to verify and sign
              email</t>

              <t>Keys can be replaced on a regular basis, thus their lifetime
              can be relatively short</t>

              <t>The security goals of this specification are modest compared
              to typical goals of other systems that employ digital
              signatures</t>
            </list>See <xref target="RFC3766"></xref> for further discussion
          on selecting key sizes.</t>
        </section>

        <section title="Other Algorithms">
          <t>Other algorithms MAY be defined in the future. Verifiers MUST
          ignore any signatures using algorithms that they do not
          implement.</t>
        </section>
      </section>

      <section anchor="canonicalization" title="Canonicalization">
        <t>Empirical evidence demonstrates that some mail servers and relay
        systems modify email in transit, potentially invalidating a signature.
        There are two competing perspectives on such modifications. For most
        signers, mild modification of email is immaterial to the
        authentication status of the email. For such signers, a
        canonicalization algorithm that survives modest in-transit
        modification is preferred.</t>

        <t>Other signers demand that any modification of the email, however
        minor, result in a signature verification failure. These signers
        prefer a canonicalization algorithm that does not tolerate in-transit
        modification of the signed email.</t>

        <t>Some signers may be willing to accept modifications to header
        fields that are within the bounds of email standards such as <xref
        target="RFC2822"></xref>, but are unwilling to accept any modification
        to the body of messages.</t>

        <t>To satisfy all requirements, two canonicalization algorithms are
        defined for each of the header and the body: a "simple" algorithm that
        tolerates almost no modification and a "relaxed" algorithm that
        tolerates common modifications such as whitespace replacement and
        header field line rewrapping. A signer MAY specify either algorithm
        for header or body when signing an email. If no canonicalization
        algorithm is specified by the signer, the "simple" algorithm defaults
        for both header and body. Verifiers MUST implement both
        canonicalization algorithms. Note that the header and body may use
        different canonicalization algorithms. Further canonicalization
        algorithms MAY be defined in the future; verifiers MUST ignore any
        signatures that use unrecognized canonicalization algorithms.</t>

        <t>Canonicalization simply prepares the email for presentation to the
        signing or verification algorithm. It MUST NOT change the transmitted
        data in any way. Canonicalization of header fields and body are
        described below.</t>

        <t>NOTE: This section assumes that the message is already in "network
        normal" format (text is ASCII encoded, lines are separated with CRLF
        characters, etc.). See also <xref target="normalization"></xref> for
        information about normalizing the message.</t>

        <section title="The &quot;simple&quot; Header Canonicalization Algorithm">
          <t>The "simple" header canonicalization algorithm does not change
          header fields in any way. Header fields MUST be presented to the
          signing or verification algorithm exactly as they are in the message
          being signed or verified. In particular, header field names MUST NOT
          be case folded and whitespace MUST NOT be changed.</t>
        </section>

        <section title="The &quot;relaxed&quot; Header Canonicalization Algorithm">
          <t>The "relaxed" header canonicalization algorithm MUST apply the
          following steps in order: <list style="symbols">
              <t>Convert all header field names (not the header field values)
              to lowercase. For example, convert "SUBJect: AbC" to "subject:
              AbC".</t>

              <t>Unfold all header field continuation lines as described in
              <xref target="RFC2822"></xref>; in particular, lines with
              terminators embedded in continued header field values (that is,
              CRLF sequences followed by WSP) MUST be interpreted without the
              CRLF. Implementations MUST NOT remove the CRLF at the end of the
              header field value.</t>

              <t>Convert all sequences of one or more WSP characters to a
              single SP character. WSP characters here include those before
              and after a line folding boundary.</t>

              <t>Delete all WSP characters at the end of each unfolded header
              field value.</t>

              <t>Delete any WSP characters remaining before and after the
              colon separating the header field name from the header field
              value. The colon separator MUST be retained.</t>
            </list></t>
        </section>

        <section anchor="simple-body"
                 title="The &quot;simple&quot; Body Canonicalization Algorithm">
          <t>The "simple" body canonicalization algorithm ignores all empty
          lines at the end of the message body. An empty line is a line of
          zero length after removal of the line terminator. If there is no
          body or no trailing CRLF on the message body, a CRLF is added. It
          makes no <?rfc needLines="10" ?> other changes to the message body.
          In more formal terms, the "simple" body canonicalization algorithm
          converts "0*CRLF" at the end of the body to a single "CRLF".</t>

          <t>Note that a completely empty or missing body is canonicalized as
          a single "CRLF"; that is, the canonicalized length will be 2
          octets.</t>
        </section>

        <section title="The &quot;relaxed&quot; Body Canonicalization Algorithm">
          <t>The "relaxed" body canonicalization algorithm:<list
              style="symbols">
              <t>Ignores all whitespace at the end of lines. Implementations
              MUST NOT remove the CRLF at the end of the line.</t>

              <t>Reduces all sequences of WSP within a line to a single SP
              character.</t>

              <t>Ignores all empty lines at the end of the message body.
              "Empty line" is defined in <xref
              target="simple-body"></xref>.</t>
            </list><list>
              <t>INFORMATIVE NOTE: It should be noted that the relaxed body
              canonicalization algorithm may enable certain types of extremely
              crude "ASCII Art" attacks where a message may be conveyed by
              adjusting the spacing between words. If this is a concern, the
              "simple" body canonicalization algorithm should be used
              instead.</t>
            </list></t>
        </section>

        <section anchor="body-length-limits" title="Body Length Limits">
          <t>A body length count MAY be specified to limit the signature
          calculation to an initial prefix of the body text, measured in
          octets. If the body length count is not specified, the entire
          message body is signed.<list>
              <t>INFORMATIVE RATIONALE: This capability is provided because it
              is very common for mailing lists to add trailers to messages
              (e.g., instructions how to get off the list). Until those
              messages are also signed, the body length count is a useful tool
              for the verifier since it may as a matter of policy accept
              messages having valid signatures with extraneous data.</t>
            </list><list>
              <t>INFORMATIVE IMPLEMENTATION NOTE: Using body length limits
              enables an attack in which an attacker modifies a message to
              include content that solely benefits the attacker. It is
              possible for the appended content to completely replace the
              original content in the end recipient's eyes and to defeat
              duplicate message detection algorithms. To avoid this attack,
              signers should be wary of using <?rfc needLines="10" ?> this
              tag, and verifiers might wish to ignore the tag or remove text
              that appears after the specified content length, perhaps based
              on other criteria.</t>
            </list></t>

          <t>The body length count allows the signer of a message to permit
          data to be appended to the end of the body of a signed message. The
          body length count MUST be calculated following the canonicalization
          algorithm; for example, any whitespace ignored by a canonicalization
          algorithm is not included as part of the body length count. Signers
          of MIME messages that include a body length count SHOULD be sure
          that the length extends to the closing MIME boundary string. <list>
              <t>INFORMATIVE IMPLEMENTATION NOTE: A signer wishing to ensure
              that the only acceptable modifications are to add to the MIME
              postlude would use a body length count encompassing the entire
              final MIME boundary string, including the final "--CRLF". A
              signer wishing to allow additional MIME parts but not
              modification of existing parts would use a body length count
              extending through the final MIME boundary string, omitting the
              final "--CRLF". Note that this only works for some MIME types,
              e.g., multipart/mixed but not multipart/signed.</t>
            </list></t>

          <t>A body length count of zero means that the body is completely
          unsigned.</t>

          <t>Signers wishing to ensure that no modification of any sort can
          occur should specify the "simple" canonicalization algorithm for
          both header and body and omit the body length count.</t>
        </section>

        <section title="Canonicalization Examples (INFORMATIVE)">
          <t>In the following examples, actual whitespace is used only for
          clarity. The actual input and output text is designated using
          bracketed descriptors: "&lt;SP&gt;" for a space character,
          "&lt;HTAB&gt;" for a tab character, and "&lt;CRLF&gt;" for a
          carriage-return/line-feed sequence. For example, "X &lt;SP&gt; Y"
          and "X&lt;SP&gt;Y" represent the same three characters.</t>

          <figure>
            <preamble>Example 1: A message reading:</preamble>

            <artwork><![CDATA[    
    A: <SP> X <CRLF>
    B <SP> : <SP> Y <HTAB><CRLF>
    <HTAB> Z <SP><SP><CRLF>
    <CRLF>
    <SP> C <SP><CRLF>
    D <SP><HTAB><SP> E <CRLF>
    <CRLF>
    <CRLF>]]></artwork>
          </figure>

          <figure>
            <preamble>when canonicalized using relaxed canonicalization for
            both header and body results in a header reading:</preamble>

            <artwork><![CDATA[    
    a:X <CRLF>
    b:Y <SP> Z <CRLF>]]></artwork>
          </figure>

          <figure>
            <preamble>and a body reading:</preamble>

            <artwork><![CDATA[    
    <SP> C <CRLF>
    D <SP> E <CRLF>]]></artwork>
          </figure>

          <figure>
            <preamble>Example 2: The same message canonicalized using simple
            canonicalization for both header and body results in a header
            reading:</preamble>

            <artwork><![CDATA[    
    A: <SP> X <CRLF>
    B <SP> : <SP> Y <HTAB><CRLF>
    <HTAB> Z <SP><SP><CRLF>]]></artwork>
          </figure>

          <figure>
            <preamble>and a body reading:</preamble>

            <artwork><![CDATA[    
    <SP> C <SP><CRLF>
    D <SP><HTAB><SP> E <CRLF>]]></artwork>
          </figure>

          <figure>
            <preamble>Example 3: When processed using relaxed header
            canonicalization and simple body canonicalization, the
            canonicalized version has a header of:</preamble>

            <artwork><![CDATA[    
    a:X <CRLF>
    b:Y <SP> Z <CRLF>]]></artwork>
          </figure>

          <figure>
            <preamble>and a body reading:</preamble>

            <artwork><![CDATA[    
    <SP> C <SP><CRLF>
    D <SP><HTAB><SP> E <CRLF>]]></artwork>
          </figure>
        </section>
      </section>

      <section anchor="dkim-sig-hdr" title="The DKIM-Signature Header Field">
        <t>The signature of the email is stored in the DKIM-Signature header
        field. This header field contains all of the signature and
        key-fetching data. The DKIM-Signature value is a tag-list as described
        in <xref target="def-tag-list"></xref>.</t>

        <!-- 3. RFC Editor Comment: This is the first time that a hyphen has been
used in "DKIM-Signature".  Should this be "DKIM Signature" or
"DKIM-Signature"?  -->

        <!-- Author Response: hyphenated when it refers to the header field name, unhyphenated when it refers to the signature itself -->

        <t>The DKIM-Signature header field SHOULD be treated as though it were
        a trace header field as defined in Section 3.6 of <xref
        target="RFC2822"></xref>, and hence SHOULD NOT be reordered and SHOULD
        be prepended to the message.</t>

        <?rfc needLines="5" ?>

        <t>The DKIM-Signature header field being created or verified is always
        included in the signature calculation, after the rest of the header
        fields being signed; however, when calculating or verifying the
        signature, the value of the "b=" tag (signature value) of that
        DKIM-Signature header field MUST be treated as though it were an empty
        string. Unknown tags in the DKIM-Signature header field MUST be
        included in the signature calculation but MUST be otherwise ignored by
        verifiers. Other DKIM-Signature header fields that are included in the
        signature should be treated as normal header fields; in particular,
        the "b=" tag is not treated specially.</t>

        <t>The encodings for each field type are listed below. Tags described
        as qp-section are encoded as described in Section 6.7 of <xref
        target="RFC2045">MIME Part One</xref>, with the additional conversion
        of semicolon characters to "=3B"; intuitively, this is one line of
        quoted-printable encoded text. The dkim-quoted-printable syntax is
        defined in <xref target="dkim-qp"></xref>.</t>

        <t>Tags on the DKIM-Signature header field along with their type and
        requirement status are shown below. Unrecognized tags MUST be
        ignored.<list hangIndent="4" style="hanging">
            <t hangText="v=">Version (MUST be included). This tag defines the
            version of this specification that applies to the signature
            record. It MUST have the value "1". Note that verifiers must do a
            string comparison on this value; for example, "1" is not the same
            as "1.0".</t>

            <t>ABNF:<list style="empty">
                <t><figure>
                    <artwork type="abnf"><![CDATA[    sig-v-tag   = %x76 [FWS] "=" [FWS] "1"]]></artwork>
                  </figure></t>

                <t>INFORMATIVE NOTE: DKIM-Signature version numbers are
                expected to increase arithmetically as new versions of this
                specification are released.</t>
              </list></t>

            <t hangText="a=">The algorithm used to generate the signature
            (plain-text; REQUIRED). Verifiers MUST support "rsa-sha1" and
            "rsa-sha256"; signers SHOULD sign using "rsa-sha256". See <xref
            target="sig-algs"></xref> for a description of algorithms.</t>

            <?rfc needLines="10" ?>

            <!-- couldn't figure out how to eliminate the extra spacing that is -->

            <!-- present in the actual hardcopy file -->

            <t>ABNF:<list style="empty">
                <t><figure>
                    <artwork type="abnf"><![CDATA[    sig-a-tag       = %x61 [FWS] "=" [FWS] sig-a-tag-alg
    sig-a-tag-alg   = sig-a-tag-k "-" sig-a-tag-h
    sig-a-tag-k     = "rsa" / x-sig-a-tag-k
    sig-a-tag-h     = "sha1" / "sha256" / x-sig-a-tag-h
    x-sig-a-tag-k   = ALPHA *(ALPHA / DIGIT)   ; for later extension
    x-sig-a-tag-h   = ALPHA *(ALPHA / DIGIT)   ; for later extension]]></artwork>
                  </figure></t>
              </list></t>

            <t hangText="b=">The signature data (base64; REQUIRED). Whitespace
            is ignored in this value and MUST be ignored when reassembling the
            original signature. In particular, the signing process can safely
            insert FWS in this value in arbitrary places to conform to
            line-length limits. See <xref target="signer-actions">Signer
            Actions</xref> for how the signature is computed.</t>

            <!-- couldn't figure out how to eliminate the extra spacing that is -->

            <!-- present in the actual hardcopy file...reoccurring too -->

            <t>ABNF:<list style="empty">
                <t><figure>
                    <artwork type="abnf"><![CDATA[    sig-b-tag       = %x62 [FWS] "=" [FWS] sig-b-tag-data
    sig-b-tag-data  = base64string]]></artwork>
                  </figure></t>
              </list></t>

            <t hangText="bh=">The hash of the canonicalized body part of the
            message as limited by the "l=" tag (base64; REQUIRED). Whitespace
            is ignored in this value and MUST be ignored when reassembling the
            original signature. In particular, the signing process can safely
            insert FWS in this value in arbitrary places to conform to
            line-length limits. See <xref target="hashing"></xref> for how the
            body hash is computed.</t>

            <t>ABNF:<list style="empty">
                <t><figure>
                    <artwork type="abnf"><![CDATA[    sig-bh-tag      = %x62 %x68 [FWS] "=" [FWS] sig-bh-tag-data
    sig-bh-tag-data = base64string]]></artwork>
                  </figure></t>
              </list></t>

            <t hangText="c=">Message canonicalization (plain-text; OPTIONAL,
            default is "simple/simple"). This tag informs the verifier of the
            type of canonicalization used to prepare the message for signing.
            It consists of two names separated by a "slash" (%d47) character,
            corresponding to the header and body canonicalization algorithms
            respectively. These algorithms are described in <xref
            target="canonicalization"></xref>. If only one algorithm is named,
            that algorithm is used for the header and "simple" is used for the
            body. For example, "c=relaxed" is treated the same as
            "c=relaxed/simple".</t>

            <t>ABNF:<list style="empty">
                <t><figure>
                    <artwork type="abnf"><![CDATA[    sig-c-tag       = %x63 [FWS] "=" [FWS] sig-c-tag-alg
                  ["/" sig-c-tag-alg]
    sig-c-tag-alg   = "simple" / "relaxed" / x-sig-c-tag-alg
    x-sig-c-tag-alg = hyphenated-word    ; for later extension]]></artwork>
                  </figure></t>
              </list></t>

            <t hangText="d=">The domain of the signing entity (plain-text;
            REQUIRED). This is the domain that will be queried for the public
            key. This domain MUST be the same as or a parent domain of the
            "i=" tag (the signing identity, as described below), or it MUST
            meet the requirements for parent domain signing described in <xref
            target="parent-dom-signing"></xref>. When presented with a
            signature that does not meet these requirement, verifiers MUST
            consider the signature invalid.</t>

            <t>Internationalized domain names MUST be encoded as described in
            <xref target="RFC3490"></xref>.</t>

            <t>ABNF:<list style="empty">
                <t><figure>
                    <artwork type="abnf"><![CDATA[    sig-d-tag       = %x64 [FWS] "=" [FWS] domain-name
    domain-name     = sub-domain 1*("." sub-domain)
             ; from RFC 2821 Domain, but excluding address-literal]]></artwork>
                  </figure></t>
              </list></t>

            <t hangText="h=">Signed header fields (plain-text, but see
            description; REQUIRED). A colon-separated list of header field
            names that identify the header fields presented to the signing
            algorithm. The field MUST contain the complete list of header
            fields in the order presented to the signing algorithm. The field
            MAY contain names of header fields that do not exist when signed;
            nonexistent header fields do not contribute to the signature
            computation (that is, they are treated as the null input,
            including the header field name, the separating colon, the header
            field value, and any CRLF terminator). The field MUST NOT include
            the DKIM-Signature header field that is being created or verified,
            but may include others. Folding whitespace (FWS) MAY be included
            on either side of the colon separator. Header field names MUST be
            compared against actual header field names in a case-insensitive
            manner. This list MUST NOT be empty. See <xref
            target="choosing-header-fields"></xref> for a discussion of
            choosing header fields to sign.</t>

            <t>ABNF:<list>
                <t><figure>
                    <artwork type="abnf"><![CDATA[    sig-h-tag       = %x68 [FWS] "=" [FWS] hdr-name
                  0*( *FWS ":" *FWS hdr-name )
    hdr-name        = field-name]]></artwork>
                  </figure></t>
              </list> <list>
                <t>INFORMATIVE EXPLANATION: By "signing" header fields that do
                not actually exist, a signer can prevent insertion of those
                header fields before verification. However, since a signer
                cannot possibly know what header fields might be created in
                the future, and that some MUAs might present header fields
                that are embedded inside a message (e.g., as a message/rfc822
                content type), the security of this solution is not total.</t>
              </list> <list>
                <t>INFORMATIVE EXPLANATION: The exclusion of the header field
                name and colon as well as the header field value for
                non-existent header fields prevents an attacker from inserting
                an actual header field with a null value.</t>
              </list></t>

            <t hangText="i=">Identity of the user or agent (e.g., a mailing
            list manager) on behalf of which this message is signed
            (dkim-quoted-printable; OPTIONAL, default is an empty Local-part
            followed by an "@" followed by the domain from the "d=" tag). The
            syntax is a standard email address where the Local-part MAY be
            omitted. The domain part of the address MUST be the same as or a
            subdomain of the value of the "d=" tag.</t>

            <t>Internationalized domain names MUST be converted using the
            steps listed in Section 4 of <xref target="RFC3490"></xref> using
            the <spanx style="verb">ToASCII</spanx> function.</t>

            <t>ABNF:<list>
                <t><figure>
                    <artwork type="abnf"><![CDATA[    sig-i-tag =   %x69 [FWS] "=" [FWS] [ Local-part ] "@" domain-name]]></artwork>
                  </figure></t>
              </list> <list>
                <t>INFORMATIVE NOTE: The Local-part of the "i=" tag is
                optional because in some cases a signer may not be able to
                establish a verified individual identity. In such cases, the
                signer may wish to assert that although it is willing to go as
                far as signing for the domain, it is unable or unwilling to
                commit to an individual user name within their domain. It can
                do so by including the domain part but not the Local-part of
                the identity.</t>

                <t>INFORMATIVE DISCUSSION: This document does not require the
                value of the "i=" tag to match the identity in any message
                header fields. This is considered to be a verifier policy
                issue. Constraints between the value of the "i=" tag and other
                identities in other header fields seek to apply basic
                authentication into the semantics of trust associated with a
                role such as content author. Trust is a broad and complex
                topic and trust mechanisms are subject to highly creative
                attacks. The real-world efficacy of any but the most basic
                bindings between the "i=" value and other identities is not
                well established, nor is its vulnerability to subversion by an
                attacker. Hence reliance on the use of these options should be
                strictly limited. In particular, it is not at all clear to
                what extent a typical end-user recipient can rely on any
                assurances that might be made by successful use of the "i="
                options.</t>
              </list></t>

            <t hangText="l=">Body length count (plain-text unsigned decimal
            integer; OPTIONAL, default is entire body). This tag informs the
            verifier of the number of octets in the body of the email after
            canonicalization included in the cryptographic hash, starting from
            0 immediately following the CRLF preceding the body. This value
            MUST NOT be larger than the actual number of octets in the
            canonicalized message body.<list>
                <t>INFORMATIVE IMPLEMENTATION WARNING: Use of the "l=" tag
                might allow display of fraudulent content without appropriate
                warning to end users. The "l=" tag is intended for increasing
                signature robustness when sending to mailing lists that both
                modify their content and do not sign their messages. However,
                using the "l=" tag enables attacks in which an intermediary
                with malicious intent modifies a message to include content
                that solely benefits the attacker. It is possible for the
                appended content to completely replace the original content in
                the end recipient's eyes and to defeat duplicate message
                detection algorithms. Examples are described in <xref
                target="security-considerations">Security
                Considerations</xref>. To avoid this attack, signers should be
                extremely wary of using this tag, and verifiers might wish to
                ignore the tag or remove text that appears after the specified
                content length.</t>

                <t>INFORMATIVE NOTE: The value of the "l=" tag is constrained
                to 76 decimal digits. This constraint is not intended to
                predict the size of future messages or to require
                implementations to use an integer representation large enough
                to represent the maximum possible value, but is intended to
                remind the implementer to check the length of this and all
                other tags during verification and to test for integer
                overflow when decoding the value. Implementers may need to
                limit the actual value expressed to a value smaller than
                10^76, e.g., to allow a message to fit within the available
                storage space.</t>
              </list></t>

            <t>ABNF:<list style="empty">
                <t><figure>
                    <artwork type="abnf"><![CDATA[sig-l-tag    = %x6c [FWS] "=" [FWS] 1*76DIGIT]]></artwork>
                  </figure></t>
              </list></t>

            <t hangText="q=">A colon-separated list of query methods used to
            retrieve the public key (plain-text; OPTIONAL, default is
            "dns/txt"). Each query method is of the form "type[/options]",
            where the syntax and semantics of the options depend on the type
            and specified options. If there are multiple query mechanisms
            listed, the choice of query mechanism MUST NOT change the
            interpretation of the signature. Implementations MUST use the
            recognized query mechanisms in the order presented.</t>

            <t>Currently, the only valid value is "dns/txt", which defines the
            DNS TXT record lookup algorithm described elsewhere in this
            document. The only option defined for the "dns" query type is
            "txt", which MUST be included. Verifiers and signers MUST support
            "dns/txt".</t>

            <t>ABNF:<list style="empty">
                <t><figure>
                    <artwork type="abnf"><![CDATA[    sig-q-tag        = %x71 [FWS] "=" [FWS] sig-q-tag-method
                   *([FWS] ":" [FWS] sig-q-tag-method)
    sig-q-tag-method = "dns/txt" / x-sig-q-tag-type
                   ["/" x-sig-q-tag-args]
    x-sig-q-tag-type = hyphenated-word  ; for future extension
    x-sig-q-tag-args = qp-hdr-value]]></artwork>
                  </figure></t>
              </list></t>

            <t hangText="s=">The selector subdividing the namespace for the
            "d=" (domain) tag (plain-text; REQUIRED).</t>

            <t>ABNF:<list style="empty">
                <t><figure>
                    <artwork type="abnf"><![CDATA[    sig-s-tag    = %x73 [FWS] "=" [FWS] selector]]></artwork>
                  </figure></t>
              </list></t>

            <t hangText="t=">Signature Timestamp (plain-text unsigned decimal
            integer; RECOMMENDED, default is an unknown creation time). The
            time that this signature was created. The format is the number of
            seconds since 00:00:00 on January 1, 1970 in the UTC time zone.
            The value is expressed as an unsigned integer in decimal ASCII.
            This value is not constrained to fit into a 31- or 32-bit integer.
            Implementations SHOULD be prepared to handle values up to at least
            10^12 (until approximately AD 200,000; this fits into 40 bits). To
            avoid denial-of-service attacks, implementations MAY consider any
            value longer than 12 digits to be infinite. Leap seconds are not
            counted. Implementations MAY ignore signatures that have a
            timestamp in the future.</t>

            <t>ABNF:<list style="empty">
                <t><figure>
                    <artwork type="abnf"><![CDATA[    sig-t-tag    = %x74 [FWS] "=" [FWS] 1*12DIGIT]]></artwork>
                  </figure></t>
              </list></t>

            <t hangText="x=">Signature Expiration (plain-text unsigned decimal
            integer; RECOMMENDED, default is no expiration). The format is the
            same as in the "t=" tag, represented as an absolute date, not as a
            time delta from the signing timestamp. The value is expressed as
            an unsigned integer in decimal ASCII, with the same constraints on
            the value in the "t=" tag. Signatures MAY be considered invalid if
            the verification time at the verifier is past the expiration date.
            The verification time should be the time that the message was
            first received at the administrative domain of the verifier if
            that time is reliably available; otherwise the current time should
            be used. The value of the "x=" tag MUST be greater than the value
            of the "t=" tag if both are present.<list>
                <t>INFORMATIVE NOTE: The "x=" tag is not intended as an
                anti-replay defense.</t>
              </list></t>

            <t>ABNF:<list style="empty">
                <t><figure>
                    <artwork type="abnf"><![CDATA[    sig-x-tag    = %x78 [FWS] "=" [FWS] 1*12DIGIT]]></artwork>
                  </figure></t>
              </list></t>

            <t hangText="z=">Copied header fields (dkim-quoted-printable, but
            see description; OPTIONAL, default is null). A
            vertical-bar-separated list of selected header fields present when
            the message was signed, including both the field name and value.
            It is not required to include all header fields present at the
            time of signing. This field need not contain the same header
            fields listed in the "h=" tag. The header field text itself must
            encode the vertical bar ("|", %x7C) character (i.e., vertical bars
            in the "z=" text are metacharacters, and any actual vertical bar
            characters in a copied header field must be encoded). Note that
            all whitespace must be encoded, including whitespace between the
            colon and the header field value. After encoding, FWS MAY be added
            at arbitrary locations in order to avoid excessively long lines;
            such whitespace is NOT part of the value of the header field, and
            MUST be removed before decoding.</t>

            <t>The header fields referenced by the "h=" tag refer to the
            fields in the RFC 2822 header of the message, not to any copied
            fields in the "z=" tag. Copied header field values are for
            diagnostic use.</t>

            <t>Header fields with characters requiring conversion (perhaps
            from legacy MTAs that are not <xref target="RFC2822"></xref>
            compliant) SHOULD be converted as described in <xref
            target="RFC2047">MIME Part Three </xref>.</t>

            <t>ABNF:<figure>
                <artwork type="abnf"><![CDATA[    sig-z-tag      = %x7A [FWS] "=" [FWS] sig-z-tag-copy
                 *( [FWS] "|" sig-z-tag-copy )
sig-z-tag-copy = hdr-name ":" qp-hdr-value
qp-hdr-value   = dkim-quoted-printable    ; with "|" encoded]]></artwork>
              </figure></t>
          </list><list>
            <t>INFORMATIVE EXAMPLE of a signature header field spread across
            multiple continuation lines: <figure>
                <artwork><![CDATA[
DKIM-Signature: a=rsa-sha256; d=example.net; s=brisbane;
   c=simple; q=dns/txt; i=@eng.example.net;
   t=1117574938; x=1118006938;
   h=from:to:subject:date;
   z=From:foo@eng.example.net|To:joe@example.com|
     Subject:demo=20run|Date:July=205,=202005=203:44:08=20PM=20-0700;
   bh=MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTI=;
   b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZ
            VoG4ZHRNiYzR]]></artwork>
              </figure></t>
          </list></t>
      </section>

      <section anchor="keys" title="Key Management and Representation">
        <t>Signature applications require some level of assurance that the
        verification public key is associated with the claimed signer. Many
        applications achieve this by using public key certificates issued by a
        trusted third party. However, DKIM can achieve a sufficient level of
        security, with significantly enhanced scalability, by simply having
        the verifier query the purported signer's DNS entry (or some
        security-equivalent) in order to retrieve the public key.</t>

        <t>DKIM keys can potentially be stored in multiple types of key
        servers and in multiple formats. The storage and format of keys are
        irrelevant to the remainder of the DKIM algorithm.</t>

        <t>Parameters to the key lookup algorithm are the type of the lookup
        (the "q=" tag), the domain of the signer (the "d=" tag of the
        DKIM-Signature header field), and the selector (the "s=" tag).<list
            style="empty">
            <t><figure>
                <artwork><![CDATA[    public_key = dkim_find_key(q_val, d_val, s_val)]]></artwork>
              </figure></t>
          </list></t>

        <t>This document defines a single binding, using DNS TXT records to
        distribute the keys. Other bindings may be defined in the future.</t>

        <section anchor="key-text" title="Textual Representation">
          <t>It is expected that many key servers will choose to present the
          keys in an otherwise unstructured text format (for example, an XML
          form would not be considered to be unstructured text for this
          purpose). The following definition MUST be used for any DKIM key
          represented in an otherwise unstructured textual form.</t>

          <t>The overall syntax is a tag-list as described in <xref
          target="def-tag-list"></xref>. The current valid tags are described
          below. Other tags MAY be present and MUST be ignored by any
          implementation that does not understand them. <list hangIndent="4"
              style="hanging">
              <t hangText="v=">Version of the DKIM key record (plain-text;
              RECOMMENDED, default is "DKIM1"). If specified, this tag MUST be
              set to "DKIM1" (without the quotes). This tag MUST be the first
              tag in the record. Records beginning with a "v=" tag with any
              other value MUST be discarded. Note that verifiers must do a
              string comparison on this value; for example, "DKIM1" is not the
              same as "DKIM1.0".<vspace blankLines="1" />ABNF:<list
                  style="empty">
                  <t><figure>
                      <artwork type="abnf"><![CDATA[    key-v-tag    = %x76 [FWS] "=" [FWS] "DKIM1"]]></artwork>
                    </figure></t>
                </list></t>

              <t hangText="g=">Granularity of the key (plain-text; OPTIONAL,
              default is "*"). This value MUST match the Local-part of the
              "i=" tag of the DKIM-Signature header field (or its default
              value of the empty string if "i=" is not specified), with a
              single, optional "*" character matching a sequence of zero or
              more arbitrary characters ("wildcarding"). An email with a
              signing address that does not match the value of this tag
              constitutes a failed verification. The intent of this tag is to
              constrain which signing address can legitimately use this
              selector, for example, when delegating a key to a third party
              that should only be used for special purposes. Wildcarding
              allows matching for addresses such as "user+*" or "*-offer". An
              empty "g=" value never matches any addresses.</t>

              <t>ABNF:<list style="empty">
                  <t><figure>
                      <artwork type="abnf"><![CDATA[    key-g-tag       = %x67 [FWS] "=" [FWS] key-g-tag-lpart
    key-g-tag-lpart = [dot-atom-text] ["*" [dot-atom-text] ]]]></artwork>
                    </figure></t>
                </list></t>

              <t hangText="h=">Acceptable hash algorithms (plain-text;
              OPTIONAL, defaults to allowing all algorithms). A
              colon-separated list of hash algorithms that might be used.
              Signers and Verifiers MUST support the "sha256" hash algorithm.
              Verifiers MUST also support the "sha1" hash algorithm.<vspace
              blankLines="1" />ABNF:<list style="empty">
                  <t><figure>
                      <artwork type="abnf"><![CDATA[    key-h-tag       = %x68 [FWS] "=" [FWS] key-h-tag-alg
                  0*( [FWS] ":" [FWS] key-h-tag-alg )
    key-h-tag-alg   = "sha1" / "sha256" / x-key-h-tag-alg
    x-key-h-tag-alg = hyphenated-word   ; for future extension]]></artwork>
                    </figure></t>
                </list></t>

              <t hangText="k=">Key type (plain-text; OPTIONAL, default is
              "rsa"). Signers and verifiers MUST support the "rsa" key type.
              The "rsa" key type indicates that an ASN.1 DER-encoded <xref
              target="ITU.X660.1997"></xref> RSAPublicKey <xref
              target="RFC3447"></xref> (see Sections 3.1 and A.1.1) is being
              used in the "p=" tag. (Note: the "p=" tag further encodes the
              value using the base64 algorithm.)<vspace
              blankLines="1" />ABNF:<list style="empty">
                  <t><figure>
                      <artwork type="abnf"><![CDATA[    key-k-tag        = %x76 [FWS] "=" [FWS] key-k-tag-type
    key-k-tag-type   = "rsa" / x-key-k-tag-type
    x-key-k-tag-type = hyphenated-word   ; for future extension]]></artwork>
                    </figure></t>
                </list></t>

              <t hangText="n=">Notes that might be of interest to a human
              (qp-section; OPTIONAL, default is empty). No interpretation is
              made by any program. This tag should be used sparingly in any
              key server mechanism that has space limitations (notably DNS).
              This is intended for use by administrators, not end users.</t>

              <t>ABNF:<list style="empty">
                  <t><figure>
                      <artwork type="abnf"><![CDATA[    key-n-tag    = %x6e [FWS] "=" [FWS] qp-section]]></artwork>
                    </figure></t>
                </list></t>

              <t hangText="p=">Public-key data (base64; REQUIRED). An empty
              value means that this public key has been revoked. The syntax
              and semantics of this tag value before being encoded in base64
              are defined by the "k=" tag.<list style="empty">
                  <t>INFORMATIVE RATIONALE: If a private key has been
                  compromised or otherwise disabled (e.g., an outsourcing
                  contract has been terminated), a signer might want to
                  explicitly state that it knows about the selector, but all
                  messages using that selector should fail verification.
                  Verifiers should ignore any DKIM-Signature header fields
                  with a selector referencing a revoked key.</t>
                </list></t>

              <t>ABNF:<list style="empty">
                  <t><figure>
                      <artwork type="abnf"><![CDATA[    key-p-tag    = %x70 [FWS] "=" [ [FWS] base64string ]]]></artwork>
                    </figure></t>
                </list><list>
                  <t>INFORMATIVE NOTE: A base64string is permitted to include
                  white space (FWS) at arbitrary places; however, any CRLFs
                  must be followed by at least one WSP character. Implementors
                  and administrators are cautioned to ensure that selector TXT
                  records conform to this specification.</t>
                </list></t>

              <t hangText="s=">Service Type (plain-text; OPTIONAL; default is
              "*"). A colon-separated list of service types to which this
              record applies. Verifiers for a given service type MUST ignore
              this record if the appropriate type is not listed. Currently
              defined service types are as follows: <list style="hanging">
                  <t hangText="*  ">matches all service types</t>

                  <t hangText="email  ">electronic mail (not necessarily
                  limited to SMTP)</t>
                </list>This tag is intended to constrain the use of keys for
              other purposes, should use of DKIM be defined by other services
              in the future.</t>

              <t>ABNF: <list style="empty">
                  <t><figure>
                      <artwork type="abnf"><![CDATA[    key-s-tag        = %x73 [FWS] "=" [FWS] key-s-tag-type
                    0*( [FWS] ":" [FWS] key-s-tag-type )
    key-s-tag-type   = "email" / "*" / x-key-s-tag-type
    x-key-s-tag-type = hyphenated-word   ; for future extension]]></artwork>
                    </figure></t>
                </list></t>

              <t hangText="t=">Flags, represented as a colon-separated list of
              names (plain-text; OPTIONAL, default is no flags set). The
              defined flags are as follows: <list style="hanging">
                  <t hangText="y">This domain is testing DKIM. Verifiers MUST
                  NOT treat messages from signers in testing mode differently
                  from unsigned email, even should the signature fail to
                  verify. Verifiers MAY wish to track testing mode results to
                  assist the signer.</t>

                  <t hangText="s">Any DKIM-Signature header fields using the
                  "i=" tag MUST have the same domain value on the right-hand
                  side of the "@" in the "i=" tag and the value of the "d="
                  tag. That is, the "i=" domain MUST NOT be a subdomain of
                  "d=". Use of this flag is RECOMMENDED unless subdomaining is
                  required.</t>
                </list></t>

              <t>ABNF: <list style="empty">
                  <t><figure>
                      <artwork type="abnf"><![CDATA[    key-t-tag        = %x74 [FWS] "=" [FWS] key-t-tag-flag
                   0*( [FWS] ":" [FWS] key-t-tag-flag )
    key-t-tag-flag   = "y" / "s" / x-key-t-tag-flag
    x-key-t-tag-flag = hyphenated-word   ; for future extension ]]></artwork>
                    </figure></t>
                </list></t>

              <t>Unrecognized flags MUST be ignored.</t>
            </list></t>
        </section>

        <section title="DNS Binding">
          <t>A binding using DNS TXT records as a key service is hereby
          defined. All implementations MUST support this binding.</t>

          <section title="Namespace">
            <t>All DKIM keys are stored in a subdomain named <spanx
            style="verb">_domainkey</spanx>. Given a DKIM-Signature field with
            a "d=" tag of <spanx style="verb">example.com</spanx> and an "s="
            tag of <spanx style="verb">foo.bar</spanx>, the DNS query will be
            for <spanx
            style="verb">foo.bar._domainkey.example.com</spanx>.<list
                style="empty">
                <t>INFORMATIVE OPERATIONAL NOTE: Wildcard DNS records (e.g.,
                *.bar._domainkey.example.com) do not make sense in this
                context and should not be used. Note also that wildcards
                within domains (e.g., s._domainkey.*.example.com) are not
                supported by the DNS.</t>
              </list></t>
          </section>

          <section title="Resource Record Types for Key Storage">
            <t>The DNS Resource Record type used is specified by an option to
            the query-type ("q=") tag. The only option defined in this base
            specification is "txt", indicating the use of a TXT Resource
            Record (RR). A later extension of this standard may define another
            RR type.</t>

            <t>Strings in a TXT RR MUST be concatenated together before use
            with no intervening whitespace. TXT RRs MUST be unique for a
            particular selector name; that is, if there are multiple records
            in an RRset, the results are undefined.</t>

            <t>TXT RRs are encoded as described in <xref
            target="key-text"></xref>.</t>
          </section>
        </section>
      </section>

      <section anchor="hashing" title="Computing the Message Hashes">
        <t>Both signing and verifying message signatures start with a step of
        computing two cryptographic hashes over the message. Signers will
        choose the parameters of the signature as described in <xref
        target="signer-actions">Signer Actions</xref>; verifiers will use the
        parameters specified in the DKIM-Signature header field being
        verified. In the following discussion, the names of the tags in the
        DKIM-Signature header field that either exists (when verifying) or
        will be created (when signing) are used. Note that <xref
        target="canonicalization">canonicalization</xref> is only used to
        prepare the email for signing or verifying; it does not affect the
        transmitted email in any way.</t>

        <t>The signer/verifier MUST compute two hashes, one over the body of
        the message and one over the selected header fields of the message.
        Signers MUST compute them in the order shown. Verifiers MAY compute
        them in any order convenient to the verifier, provided that the result
        is semantically identical to the semantics that would be the case had
        they been computed in this order.</t>

        <t>In hash step 1, the signer/verifier MUST hash the message body,
        canonicalized using the body canonicalization algorithm specified in
        the "c=" tag and then truncated to the length specified in the "l="
        tag. That hash value is then converted to base64 form and inserted
        into (signers) or compared to (verifiers) the "bh=" tag of the
        DKIM-Signature header field.</t>

        <t>In hash step 2, the signer/verifier MUST pass the following to the
        hash algorithm in the indicated order.</t>

        <t><list style="numbers">
            <t>The header fields specified by the "h=" tag, in the order
            specified in that tag, and canonicalized using the header
            canonicalization algorithm specified in the "c=" tag. Each header
            field MUST be terminated with a single CRLF.</t>

            <t>The DKIM-Signature header field that exists (verifying) or will
            be inserted (signing) in the message, with the value of the "b="
            tag deleted (i.e., treated as the empty string), canonicalized
            using the header canonicalization algorithm specified in the "c="
            tag, and without a trailing CRLF.</t>
          </list></t>

        <t>All tags and their values in the DKIM-Signature header field are
        included in the cryptographic hash with the sole exception of the
        value portion of the "b=" (signature) tag, which MUST be treated as
        the null string. All tags MUST be included even if they might not be
        understood by the verifier. The header field MUST be presented to the
        hash algorithm after the body of the message rather than with the rest
        of the header fields and MUST be canonicalized as specified in the
        "c=" (canonicalization) tag. The DKIM-Signature header field MUST NOT
        be included in its own h= tag, although other DKIM-Signature header
        fields MAY be signed (see <xref
        target="multiple-signatures"></xref>).</t>

        <t>When calculating the hash on messages that will be transmitted
        using base64 or quoted-printable encoding, signers MUST compute the
        hash after the encoding. Likewise, the verifier MUST incorporate the
        values into the hash before decoding the base64 or quoted-printable
        text. However, the hash MUST be computed before transport level
        encodings such as SMTP "dot-stuffing" (the modification of lines
        beginning with a "." to avoid confusion with the SMTP end-of-message
        marker, as specified in <xref target="RFC2821"></xref>).</t>

        <t>With the exception of the canonicalization procedure described in
        <xref target="canonicalization"></xref>, the DKIM signing process
        treats the body of messages as simply a string of octets. DKIM
        messages MAY be either in plain-text or in MIME format; no special
        treatment is afforded to MIME content. Message attachments in MIME
        format MUST be included in the content that is signed.</t>

        <figure>
          <preamble>More formally, the algorithm for the signature is as
          follows:</preamble>

          <artwork><![CDATA[    body-hash = hash-alg(canon_body)
    header-hash = hash-alg(canon_header || DKIM-SIG)
    signature = sig-alg(header-hash, key)]]></artwork>
        </figure>

        <t>where <spanx style="verb">sig-alg</spanx> is the signature
        algorithm specified by the "a=" tag, <spanx
        style="verb">hash-alg</spanx> is the hash algorithm specified by the
        "a=" tag, <spanx style="verb">canon_header</spanx> and <spanx
        style="verb">canon_body</spanx> are the canonicalized message header
        and body (respectively) as defined in <xref
        target="canonicalization"></xref> (excluding the DKIM-Signature header
        field), and <spanx style="verb">DKIM-SIG</spanx> is the canonicalized
        DKIM-Signature header field sans the signature value itself, but with
        <spanx style="verb">body-hash</spanx> included as the "bh=" tag.<list
            style="empty">
            <t>INFORMATIVE IMPLEMENTERS' NOTE: Many digital signature APIs
            provide both hashing and application of the RSA private key using
            a single <spanx style="verb">sign()</spanx> primitive. When using
            such an API, the last two steps in the algorithm would probably be
            combined into a single call that would perform both the <spanx
            style="verb">hash-alg</spanx> and the <spanx
            style="verb">sig-alg</spanx>.</t>
          </list></t>
      </section>

      <section anchor="parent-dom-signing" title="Signing by Parent Domains">
        <t>In some circumstances, it is desirable for a domain to apply a
        signature on behalf of any of its subdomains without the need to
        maintain separate selectors (key records) in each subdomain. By
        default, private keys corresponding to key records can be used to sign
        messages for any subdomain of the domain in which they reside; e.g., a
        key record for the domain example.com can be used to verify messages
        where the signing identity ("i=" tag of the signature) is
        sub.example.com, or even sub1.sub2.example.com. In order to limit the
        capability of such keys when this is not intended, the <spanx
        style="verb">s</spanx> flag may be set in the "t=" tag of the key
        record to constrain the validity of the record to exactly the domain
        of the signing identity. If the referenced key record contains the
        <spanx style="verb">s</spanx> flag as part of the "t=" tag, the domain
        of the signing identity ("i=" flag) MUST be the same as that of the d=
        domain. If this flag is absent, the domain of the signing identity
        MUST be the same as, or a subdomain of, the d= domain. Key records
        that are not intended for use with subdomains SHOULD specify the
        <spanx style="verb">s</spanx> flag in the "t=" tag.</t>
      </section>
    </section>

    <section anchor="multiple-signatures"
             title="Semantics of Multiple Signatures">
      <section title="Example Scenarios">
        <t>There are many reasons why a message might have multiple
        signatures. For example, a given signer might sign multiple times,
        perhaps with different hashing or signing algorithms during a
        transition phase.<list style="empty">
            <t>INFORMATIVE EXAMPLE: Suppose SHA-256 is in the future found to
            be insufficiently strong, and DKIM usage transitions to SHA-1024.
            A signer might immediately sign using the newer algorithm, but
            continue to sign using the older algorithm for interoperability
            with verifiers that had not yet upgraded. The signer would do this
            by adding two DKIM-Signature header fields, one using each
            algorithm. Older verifiers that did not recognize SHA-1024 as an
            acceptable algorithm would skip that signature and use the older
            algorithm; newer verifiers could use either signature at their
            option, and all other things being equal might not even attempt to
            verify the other signature.</t>
          </list></t>

        <t>Similarly, a signer might sign a message including all headers and
        no "l=" tag (to satisfy strict verifiers) and a second time with a
        limited set of headers and an "l=" tag (in anticipation of possible
        message modifications in route to other verifiers). Verifiers could
        then choose which signature they preferred.<list style="empty">
            <t>INFORMATIVE EXAMPLE: A verifier might receive a message with
            two signatures, one covering more of the message than the other.
            If the signature covering more of the message verified, then the
            verifier could make one set of policy decisions; if that signature
            failed but the signature covering less of the message verified,
            the verifier might make a different set of policy decisions.</t>
          </list></t>

        <t>Of course, a message might also have multiple signatures because it
        passed through multiple signers. A common case is expected to be that
        of a signed message that passes through a mailing list that also signs
        all messages. Assuming both of those signatures verify, a recipient
        might choose to accept the message if either of those signatures were
        known to come from trusted sources.<list>
            <t>INFORMATIVE EXAMPLE: Recipients might choose to whitelist
            mailing lists to which they have subscribed and that have
            acceptable anti-abuse policies so as to accept messages sent to
            that list even from unknown authors. They might also subscribe to
            less trusted mailing lists (e.g., those without anti-abuse
            protection) and be willing to accept all messages from specific
            authors, but insist on doing additional abuse scanning for other
            messages.</t>
          </list></t>

        <t>Another related example of multiple signers might be forwarding
        services, such as those commonly associated with academic alumni
        sites.<list style="empty">
            <t>INFORMATIVE EXAMPLE: A recipient might have an address at
            members.example.org, a site that has anti-abuse protection that is
            somewhat less effective than the recipient would prefer. Such a
            recipient might have specific authors whose messages would be
            trusted absolutely, but messages from unknown authors that had
            passed the forwarder's scrutiny would have only medium trust.</t>
          </list></t>
      </section>

      <section title="Interpretation">
        <t>A signer that is adding a signature to a message merely creates a
        new DKIM-Signature header, using the usual semantics of the h= option.
        A signer MAY sign previously existing DKIM-Signature header fields
        using the method described in <xref
        target="choosing-header-fields"></xref> to sign trace header
        fields.<list style="empty">
            <t>INFORMATIVE NOTE: Signers should be cognizant that signing
            DKIM-Signature header fields may result in signature failures with
            intermediaries that do not recognize that DKIM-Signature header
            fields are trace header fields and unwittingly reorder them, thus
            breaking such signatures. For this reason, signing existing
            DKIM-Signature header fields is unadvised, albeit legal.</t>

            <t>INFORMATIVE NOTE: If a header field with multiple instances is
            signed, those header fields are always signed from the bottom up.
            Thus, it is not possible to sign only specific DKIM-Signature
            header fields. For example, if the message being signed already
            contains three DKIM-Signature header fields A, B, and C, it is
            possible to sign all of them, B and C only, or C only, but not A
            only, B only, A and B only, or A and C only.</t>
          </list></t>

        <t>A signer MAY add more than one DKIM-Signature header field using
        different parameters. For example, during a transition period a signer
        might want to produce signatures using two different hash
        algorithms.</t>

        <t>Signers SHOULD NOT remove any DKIM-Signature header fields from
        messages they are signing, even if they know that the signatures
        cannot be verified.</t>

        <?rfc needLines="5" ?>

        <t>When evaluating a message with multiple signatures, a verifier
        SHOULD evaluate signatures independently and on their own merits. For
        example, a verifier that by policy chooses not to accept signatures
        with deprecated cryptographic algorithms would consider such
        signatures invalid. Verifiers MAY process signatures in any order of
        their choice; for example, some verifiers might choose to process
        signatures corresponding to the From field in the message header
        before other signatures. See <xref target="extract-signatures"></xref>
        for more information about signature choices.<list style="empty">
            <t>INFORMATIVE IMPLEMENTATION NOTE: Verifier attempts to correlate
            valid signatures with invalid signatures in an attempt to guess
            why a signature failed are ill-advised. In particular, there is no
            general way that a verifier can determine that an invalid
            signature was ever valid.</t>
          </list></t>

        <t>Verifiers SHOULD ignore failed signatures as though they were not
        present in the message. Verifiers SHOULD continue to check signatures
        until a signature successfully verifies to the satisfaction of the
        verifier. To limit potential denial-of-service attacks, verifiers MAY
        limit the total number of signatures they will attempt to verify.</t>
      </section>
    </section>

    <section anchor="signer-actions" title="Signer Actions">
      <t>The following steps are performed in order by signers.</t>

      <section title="Determine Whether the Email Should Be Signed and by Whom">
        <t>A signer can obviously only sign email for domains for which it has
        a private key and the necessary knowledge of the corresponding public
        key and selector information. However, there are a number of other
        reasons beyond the lack of a private key why a signer could choose not
        to sign an email.<list style="empty">
            <t>INFORMATIVE NOTE: Signing modules may be incorporated into any
            portion of the mail system as deemed appropriate, including an
            MUA, a SUBMISSION server, or an MTA. Wherever implemented, signers
            should beware of signing (and thereby asserting responsibility
            for) messages that may be problematic. In particular, within a
            trusted enclave the signing address might be derived from the
            header according to local policy; SUBMISSION servers might only
            sign messages from users that are properly authenticated and
            authorized.</t>

            <?rfc needLines="10" ?>

            <t>INFORMATIVE IMPLEMENTER ADVICE: SUBMISSION servers should not
            sign Received header fields if the outgoing gateway MTA obfuscates
            Received header fields, for example, to hide the details of
            internal topology.</t>
          </list></t>

        <t>If an email cannot be signed for some reason, it is a local policy
        decision as to what to do with that email.</t>
      </section>

      <section anchor="choosing-key"
               title="Select a Private Key and Corresponding Selector Information">
        <t>This specification does not define the basis by which a signer
        should choose which private key and selector information to use.
        Currently, all selectors are equal as far as this specification is
        concerned, so the decision should largely be a matter of
        administrative convenience. Distribution and management of private
        keys is also outside the scope of this document.<list>
            <t>INFORMATIVE OPERATIONS ADVICE: A signer should not sign with a
            private key when the selector containing the corresponding public
            key is expected to be revoked or removed before the verifier has
            an opportunity to validate the signature. The signer should
            anticipate that verifiers may choose to defer validation, perhaps
            until the message is actually read by the final recipient. In
            particular, when rotating to a new key pair, signing should
            immediately commence with the new private key and the old public
            key should be retained for a reasonable validation interval before
            being removed from the key server.</t>
          </list></t>
      </section>

      <section anchor="normalization"
               title="Normalize the Message to Prevent Transport Conversions">
        <t>Some messages, particularly those using 8-bit characters, are
        subject to modification during transit, notably conversion to 7-bit
        form. Such conversions will break DKIM signatures. In order to
        minimize the chances of such breakage, signers SHOULD convert the
        message to a suitable MIME content transfer encoding such as
        quoted-printable or base64 as described in <xref target="RFC2045">MIME
        Part One </xref> before signing. Such conversion is outside the scope
        of DKIM; the actual message SHOULD be converted to 7-bit MIME by an
        MUA or MSA prior to presentation to the DKIM algorithm.</t>

        <t>If the message is submitted to the signer with any local encoding
        that will be modified before transmission, that modification to
        canonical <xref target="RFC2822"></xref> form MUST be done before
        signing. In particular, bare CR or LF characters (used by some systems
        as a local line separator convention) MUST be converted to the
        SMTP-standard CRLF sequence before the message is signed. Any
        conversion of this sort SHOULD be applied to the message actually sent
        to the recipient(s), not just to the version presented to the signing
        algorithm.</t>

        <t>More generally, the signer MUST sign the message as it is expected
        to be received by the verifier rather than in some local or internal
        form.</t>
      </section>

      <section anchor="choosing-header-fields"
               title="Determine the Header Fields to Sign">
        <t>The From header field MUST be signed (that is, included in the "h="
        tag of the resulting DKIM-Signature header field). Signers SHOULD NOT
        sign an existing header field likely to be legitimately modified or
        removed in transit. In particular, <xref target="RFC2821"></xref>
        explicitly permits modification or removal of the Return-Path header
        field in transit. Signers MAY include any other header fields present
        at the time of signing at the discretion of the signer.<list
            style="empty">
            <t>INFORMATIVE OPERATIONS NOTE: The choice of which header fields
            to sign is non-obvious. One strategy is to sign all existing,
            non-repeatable header fields. An alternative strategy is to sign
            only header fields that are likely to be displayed to or otherwise
            be likely to affect the processing of the message at the receiver.
            A third strategy is to sign only "well known" headers. Note that
            verifiers may treat unsigned header fields with extreme
            skepticism, including refusing to display them to the end user or
            even ignoring the signature if it does not cover certain header
            fields. For this reason, signing fields present in the message
            such as Date, Subject, Reply-To, Sender, and all MIME header
            fields are highly advised.</t>
          </list></t>

        <t>The DKIM-Signature header field is always implicitly signed and
        MUST NOT be included in the "h=" tag except to indicate that other
        preexisting signatures are also signed.</t>

        <t>Signers MAY claim to have signed header fields that do not exist
        (that is, signers MAY include the header field name in the "h=" tag
        even if that header field does not exist in the message). When
        computing the signature, the non-existing header field MUST be treated
        as the null string (including the header field name, header field
        value, all punctuation, and the trailing CRLF). <list>
            <t>INFORMATIVE RATIONALE: This allows signers to explicitly assert
            the absence of a header field; if that header field is added later
            the signature will fail.</t>

            <t>INFORMATIVE NOTE: A header field name need only be listed once
            more than the actual number of that header field in a message at
            the time of signing in order to prevent any further additions. For
            example, if there is a single Comments header field at the time of
            signing, listing Comments twice in the "h=" tag is sufficient to
            prevent any number of Comments header fields from being appended;
            it is not necessary (but is legal) to list Comments three or more
            times in the "h=" tag.</t>
          </list></t>

        <t>Signers choosing to sign an existing header field that occurs more
        than once in the message (such as Received) MUST sign the physically
        last instance of that header field in the header block. Signers
        wishing to sign multiple instances of such a header field MUST include
        the header field name multiple times in the h= tag of the
        DKIM-Signature header field, and MUST sign such header fields in order
        from the bottom of the header field block to the top. The signer MAY
        include more instances of a header field name in h= than there are
        actual corresponding header fields to indicate that additional header
        fields of that name SHOULD NOT be added.<list>
            <t>INFORMATIVE EXAMPLE:</t>

            <t>If the signer wishes to sign two existing Received header
            fields, and the existing header contains:<list>
                <t><figure>
                    <artwork><![CDATA[
    Received: <A>
    Received: <B>
    Received: <C>]]></artwork>
                  </figure></t>
              </list> then the resulting DKIM-Signature header field should
            read: <list>
                <t><figure>
                    <artwork><![CDATA[
    DKIM-Signature: ... h=Received : Received : ...]]></artwork>
                  </figure></t>
              </list> and Received header fields &lt;C&gt; and &lt;B&gt; will
            be signed in that order.</t>
          </list></t>

        <t>Signers should be careful of signing header fields that might have
        additional instances added later in the delivery process, since such
        header fields might be inserted after the signed instance or otherwise
        reordered. Trace header fields (such as Received) and Resent-* blocks
        are the only fields prohibited by <xref target="RFC2822"></xref> from
        being reordered. In particular, since DKIM-Signature header fields may
        be reordered by some intermediate MTAs, signing existing
        DKIM-Signature header fields is error-prone.</t>

        <t><list>
            <t>INFORMATIVE ADMONITION: Despite the fact that <xref
            target="RFC2822"></xref> permits header fields to be reordered
            (with the exception of Received header fields), reordering of
            signed header fields with multiple instances by intermediate MTAs
            will cause DKIM signatures to be broken; such anti-social behavior
            should be avoided.</t>

            <t>INFORMATIVE IMPLEMENTER'S NOTE: Although not required by this
            specification, all end-user visible header fields should be signed
            to avoid possible "indirect spamming". For example, if the Subject
            header field is not signed, a spammer can resend a previously
            signed mail, replacing the legitimate subject with a one-line
            spam.</t>
          </list></t>
      </section>

      <section title="Recommended Signature Content">
        <t>In order to maximize compatibility with a variety of verifiers, it
        is recommended that signers follow the practices outlined in this
        section when signing a message. However, these are generic
        recommendations applying to the general case; specific senders may
        wish to modify these guidelines as required by their unique
        situations. Verifiers MUST be capable of verifying signatures even if
        one or more of the recommended header fields is not signed (with the
        exception of From, which must always be signed) or if one or more of
        the disrecommended header fields is signed. Note that verifiers do
        have the option of ignoring signatures that do not cover a sufficient
        portion of the header or body, just as they may ignore signatures from
        an identity they do not trust.</t>

        <t>The following header fields SHOULD be included in the signature, if
        they are present in the message being signed:<list style="symbols">
            <t>From (REQUIRED in all signatures)</t>

            <t>Sender, Reply-To</t>

            <t>Subject</t>

            <t>Date, Message-ID</t>

            <t>To, Cc</t>

            <t>MIME-Version</t>

            <t>Content-Type, Content-Transfer-Encoding, Content-ID,
            Content-Description</t>

            <t>Resent-Date, Resent-From, Resent-Sender, Resent-To, Resent-Cc,
            Resent-Message-ID</t>

            <t>In-Reply-To, References</t>

            <t>List-Id, List-Help, List-Unsubscribe, List-Subscribe,
            List-Post, List-Owner, List-Archive</t>
          </list></t>

        <t>The following header fields SHOULD NOT be included in the
        signature:<list style="symbols">
            <t>Return-Path</t>

            <t>Received</t>

            <t>Comments, Keywords</t>

            <t>Bcc, Resent-Bcc</t>

            <t>DKIM-Signature</t>
          </list>Optional header fields (those not mentioned above) normally
        SHOULD NOT be included in the signature, because of the potential for
        additional header fields of the same name to be legitimately added or
        reordered prior to verification. There are likely to be legitimate
        exceptions to this rule, because of the wide variety of
        application-specific header fields that may be applied to a message,
        some of which are unlikely to be duplicated, modified, or
        reordered.</t>

        <t>Signers SHOULD choose canonicalization algorithms based on the
        types of messages they process and their aversion to risk. For
        example, e-commerce sites sending primarily purchase receipts, which
        are not expected to be processed by mailing lists or other software
        likely to modify messages, will generally prefer "simple"
        canonicalization. Sites sending primarily person-to-person email will
        likely prefer to be more resilient to modification during transport by
        using "relaxed" canonicalization.</t>

        <t>Signers SHOULD NOT use "l=" unless they intend to accommodate
        intermediate mail processors that append text to a message. For
        example, many mailing list processors append "unsubscribe" information
        to message bodies. If signers use "l=", they SHOULD include the entire
        message body existing at the time of signing in computing the count.
        In particular, signers SHOULD NOT specify a body length of 0 since
        this may be interpreted as a meaningless signature by some
        verifiers.</t>
      </section>

      <section anchor="compute-message-hash"
               title="Compute the Message Hash and Signature">
        <t>The signer MUST compute the message hash as described in <xref
        target="hashing"></xref> and then sign it using the selected
        public-key algorithm. This will result in a DKIM-Signature header
        field that will include the body hash and a signature of the header
        hash, where that header includes the DKIM-Signature header field
        itself.</t>

        <t>Entities such as mailing list managers that implement DKIM and that
        modify the message or a header field (for example, inserting
        unsubscribe information) before retransmitting the message SHOULD
        check any existing signature on input and MUST make such modifications
        before re-signing the message.</t>

        <t>The signer MAY elect to limit the number of bytes of the body that
        will be included in the hash and hence signed. The length actually
        hashed should be inserted in the "l=" tag of the DKIM-Signature header
        field.</t>
      </section>

      <section title="Insert the DKIM-Signature Header Field">
        <t>Finally, the signer MUST insert the DKIM-Signature header field
        created in the previous step prior to transmitting the email. The
        DKIM-Signature header field MUST be the same as used to compute the
        hash as described above, except that the value of the "b=" tag MUST be
        the appropriately signed hash computed in the previous step, signed
        using the algorithm specified in the "a=" tag of the DKIM-Signature
        header field and using the private key corresponding to the selector
        given in the "s=" tag of the DKIM-Signature header field, as chosen
        above in <xref target="choosing-key"></xref></t>

        <t>The DKIM-Signature header field MUST be inserted before any other
        DKIM-Signature fields in the header block. <list>
            <t>INFORMATIVE IMPLEMENTATION NOTE: The easiest way to achieve
            this is to insert the DKIM-Signature header field at the beginning
            of the header block. In particular, it may be placed before any
            existing Received header fields. This is consistent with treating
            DKIM-Signature as a trace header field.</t>
          </list></t>
      </section>
    </section>

    <section anchor="verifier-actions" title="Verifier Actions">
      <t>Since a signer MAY remove or revoke a public key at any time, it is
      recommended that verification occur in a timely manner. In many
      configurations, the most timely place is during acceptance by the border
      MTA or shortly thereafter. In particular, deferring verification until
      the message is accessed by the end user is discouraged.</t>

      <t>A border or intermediate MTA MAY verify the message signature(s). An
      MTA who has performed verification MAY communicate the result of that
      verification by adding a verification header field to incoming messages.
      This considerably simplifies things for the user, who can now use an
      existing mail user agent. Most MUAs have the ability to filter messages
      based on message header fields or content; these filters would be used
      to implement whatever policy the user wishes with respect to unsigned
      mail.</t>

      <t>A verifying MTA MAY implement a policy with respect to unverifiable
      mail, regardless of whether or not it applies the verification header
      field to signed messages.</t>

      <t>Verifiers MUST produce a result that is semantically equivalent to
      applying the following steps in the order listed. In practice, several
      of these steps can be performed in parallel in order to improve
      performance.</t>

      <section anchor="extract-signatures"
               title="Extract Signatures from the Message">
        <t>The order in which verifiers try DKIM-Signature header fields is
        not defined; verifiers MAY try signatures in any order they like. For
        example, one implementation might try the signatures in textual order,
        whereas another might try signatures by identities that match the
        contents of the From header field before trying other
        signatures. Verifiers MUST NOT attribute ultimate meaning to the order
        of multiple DKIM-Signature header fields. In particular, there is
        reason to believe that some relays will reorder the header fields in
        potentially arbitrary ways.<list>
            <t>INFORMATIVE IMPLEMENTATION NOTE: Verifiers might use the order
            as a clue to signing order in the absence of any other
            information. However, other clues as to the semantics of multiple
            signatures (such as correlating the signing host with Received
            header fields) may also be considered.</t>
          </list></t>

        <t>A verifier SHOULD NOT treat a message that has one or more bad
        signatures and no good signatures differently from a message with no
        signature at all; such treatment is a matter of local policy and is
        beyond the scope of this document.</t>

        <t>When a signature successfully verifies, a verifier will either stop
        processing or attempt to verify any other signatures, at the
        discretion of the implementation. A verifier MAY limit the number of
        signatures it tries to avoid denial-of-service attacks.<list
            style="empty">
            <t>INFORMATIVE NOTE: An attacker could send messages with large
            numbers of faulty signatures, each of which would require a DNS
            lookup and corresponding CPU time to verify the message. This
            could be an attack on the domain that receives the message, by
            slowing down the verifier by requiring it to do a large number of
            DNS lookups and/or signature verifications. It could also be an
            attack against the domains listed in the signatures, essentially
            by enlisting innocent verifiers in launching an attack against the
            DNS servers of the actual victim.</t>
          </list></t>

        <?rfc needLines="5" ?>

        <t>In the following description, text reading "return status
        (explanation)" (where "status" is one of "PERMFAIL" or "TEMPFAIL")
        means that the verifier MUST immediately cease processing that
        signature. The verifier SHOULD proceed to the next signature, if any
        is present, and completely ignore the bad signature. If the status is
        "PERMFAIL", the signature failed and should not be reconsidered. If
        the status is "TEMPFAIL", the signature could not be verified at this
        time but may be tried again later. A verifier MAY either defer the
        message for later processing, perhaps by queueing it locally or
        issuing a 451/4.7.5 SMTP reply, or try another signature; if no good
        signature is found and any of the signatures resulted in a TEMPFAIL
        status, the verifier MAY save the message for later processing. The
        "(explanation)" is not normative text; it is provided solely for
        clarification.</t>

        <t>Verifiers SHOULD ignore any DKIM-Signature header fields where the
        signature does not validate. Verifiers that are prepared to validate
        multiple signature header fields SHOULD proceed to the next signature
        header field, should it exist. However, verifiers MAY make note of the
        fact that an invalid signature was present for consideration at a
        later step. <list>
            <t>INFORMATIVE NOTE: The rationale of this requirement is to
            permit messages that have invalid signatures but also a valid
            signature to work. For example, a mailing list exploder might opt
            to leave the original submitter signature in place even though the
            exploder knows that it is modifying the message in some way that
            will break that signature, and the exploder inserts its own
            signature. In this case, the message should succeed even in the
            presence of the known-broken signature.</t>
          </list></t>

        <t>For each signature to be validated, the following steps should be
        performed in such a manner as to produce a result that is semantically
        equivalent to performing them in the indicated order.</t>

        <section anchor="validate-sig"
                 title="Validate the Signature Header Field">
          <t>Implementers MUST meticulously validate the format and values in
          the DKIM-Signature header field; any inconsistency or unexpected
          values MUST cause the header field to be completely ignored and the
          verifier to return PERMFAIL (signature syntax error). Being "liberal
          in what you accept" is definitely a bad strategy in this security
          context. Note however that this does not include the existence of
          unknown tags in a DKIM-Signature header field, which are explicitly
          permitted.</t>

          <t>Verifiers MUST ignore DKIM-Signature header fields with a "v="
          tag that is inconsistent with this specification and return PERMFAIL
          (incompatible version).<list>
              <t>INFORMATIVE IMPLEMENTATION NOTE: An implementation may, of
              course, choose to also verify signatures generated by older
              versions of this specification.</t>
            </list></t>

          <t>If any tag listed as "required" in <xref
          target="dkim-sig-hdr"></xref> is omitted from the DKIM-Signature
          header field, the verifier MUST ignore the DKIM-Signature header
          field and return PERMFAIL (signature missing required tag).<list
              style="empty">
              <t>INFORMATIONAL NOTE: The tags listed as required in <xref
              target="dkim-sig-hdr"></xref> are <spanx
              style="verb">v=</spanx>, <spanx style="verb">a=</spanx>, <spanx
              style="verb">b=</spanx>, <spanx style="verb">bh=</spanx>, <spanx
              style="verb">d=</spanx>, <spanx style="verb">h=</spanx>, and
              <spanx style="verb">s=</spanx>. Should there be a conflict
              between this note and <xref target="dkim-sig-hdr"></xref>, <xref
              target="dkim-sig-hdr"></xref> is normative.</t>
            </list></t>

          <t>If the DKIM-Signature header field does not contain the "i=" tag,
          the verifier MUST behave as though the value of that tag were "@d",
          where "d" is the value from the "d=" tag.</t>

          <t>Verifiers MUST confirm that the domain specified in the "d=" tag
          is the same as or a parent domain of the domain part of the "i="
          tag. If not, the DKIM-Signature header field MUST be ignored and the
          verifier should return PERMFAIL (domain mismatch).</t>

          <t>If the "h=" tag does not include the From header field, the
          verifier MUST ignore the DKIM-Signature header field and return
          PERMFAIL (From field not signed).</t>

          <t>Verifiers MAY ignore the DKIM-Signature header field and return
          PERMFAIL (signature expired) if it contains an "x=" tag and the
          signature has expired.</t>

          <t>Verifiers MAY ignore the DKIM-Signature header field if the
          domain used by the signer in the "d=" tag is not associated with a
          valid signing entity. For example, signatures with "d=" values such
          as "com" and "co.uk" may be ignored. The list of unacceptable
          domains SHOULD be configurable.</t>

          <t>Verifiers MAY ignore the DKIM-Signature header field and return
          PERMFAIL (unacceptable signature header) for any other reason, for
          example, if the signature does not sign header fields that the
          verifier views to be essential. As a case in point, if MIME header
          fields are not signed, certain attacks may be possible that the
          verifier would prefer to avoid.</t>
        </section>

        <section title="Get the Public Key">
          <t>The public key for a signature is needed to complete the
          verification process. The process of retrieving the public key
          depends on the query type as defined by the "q=" tag in the
          DKIM-Signature header field. Obviously, a public key need only be
          retrieved if the process of extracting the signature information is
          completely successful. Details of key management and representation
          are described in <xref target="keys"></xref>. The verifier MUST
          validate the key record and MUST ignore any public key records that
          are malformed.</t>

          <t>When validating a message, a verifier MUST perform the following
          steps in a manner that is semantically the same as performing them
          in the order indicated (in some cases, the implementation may
          parallelize or reorder these steps, as long as the semantics remain
          unchanged):<list style="numbers">
              <t>Retrieve the public key as described in <xref
              target="keys"></xref> using the algorithm in the "q=" tag, the
              domain from the "d=" tag, and the selector from the "s="
              tag.</t>

              <t>If the query for the public key fails to respond, the
              verifier MAY defer acceptance of this email and return TEMPFAIL
              (key unavailable). If verification is occurring during the
              incoming SMTP session, this MAY be achieved with a 451/4.7.5
              SMTP reply code. Alternatively, the verifier MAY store the
              message in the local queue for later trial or ignore the
              signature. Note that storing a message in the local queue is
              subject to denial-of-service attacks.</t>

              <t>If the query for the public key fails because the
              corresponding key record does not exist, the verifier MUST
              immediately return PERMFAIL (no key for signature).</t>

              <t>If the query for the public key returns multiple key records,
              the verifier may choose one of the key records or may cycle
              through the key records performing the remainder of these steps
              on each record at the discretion of the implementer. The order
              of the key records is unspecified. If the verifier chooses to
              cycle through the key records, then the "return ..." wording in
              the remainder of this section means "try the next key record, if
              any; if none, return to try another signature in the usual
              way".</t>

              <t>If the result returned from the query does not adhere to the
              format defined in this specification, the verifier MUST ignore
              the key record and return PERMFAIL (key syntax error). Verifiers
              are urged to validate the syntax of key records carefully to
              avoid attempted attacks. In particular, the verifier MUST ignore
              keys with a version code ("v=" tag) that they do not
              implement.</t>

              <t>If the "g=" tag in the public key does not match the
              Local-part of the "i=" tag in the message signature header
              field, the verifier MUST ignore the key record and return
              PERMFAIL (inapplicable key). If the Local-part of the "i=" tag
              on the message signature is not present, the "g=" tag must be
              "*" (valid for all addresses in the domain) or the entire g= tag
              must be omitted (which defaults to "g=*"), otherwise the
              verifier MUST ignore the key record and return PERMFAIL
              (inapplicable key). Other than this test, verifiers SHOULD NOT
              treat a message signed with a key record having a "g=" tag any
              differently than one without; in particular, verifiers SHOULD
              NOT prefer messages that seem to have an individual signature by
              virtue of a "g=" tag versus a domain signature.</t>

              <t>If the "h=" tag exists in the public key record and the hash
              algorithm implied by the a= tag in the DKIM-Signature header
              field is not included in the contents of the "h=" tag, the
              verifier MUST ignore the key record and return PERMFAIL
              (inappropriate hash algorithm).</t>

              <t>If the public key data (the "p=" tag) is empty, then this key
              has been revoked and the verifier MUST treat this as a failed
              signature check and return PERMFAIL (key revoked). There is no
              defined semantic difference between a key that has been revoked
              and a key record that has been removed.</t>

              <t>If the public key data is not suitable for use with the
              algorithm and key types defined by the "a=" and "k=" tags in the
              DKIM-Signature header field, the verifier MUST immediately
              return PERMFAIL (inappropriate key algorithm).</t>
            </list></t>
        </section>

        <section title="Compute the Verification">
          <t>Given a signer and a public key, verifying a signature consists
          of actions semantically equivalent to the following steps. <list
              style="numbers">
              <t>Based on the algorithm defined in the "c=" tag, the body
              length specified in the "l=" tag, and the header field names in
              the "h=" tag, prepare a canonicalized version of the message as
              is described in <xref target="hashing"></xref> (note that this
              version does not actually need to be instantiated). When
              matching header field names in the "h=" tag against the actual
              message header field, comparisons MUST be case-insensitive.</t>

              <t>Based on the algorithm indicated in the "a=" tag, compute the
              message hashes from the canonical copy as described in <xref
              target="hashing"></xref>.</t>

              <t>Verify that the hash of the canonicalized message body
              computed in the previous step matches the hash value conveyed in
              the "bh=" tag. If the hash does not match, the verifier SHOULD
              ignore the signature and return PERMFAIL (body hash did not
              verify).</t>

              <t>Using the signature conveyed in the "b=" tag, verify the
              signature against the header hash using the mechanism
              appropriate for the public key algorithm described in the "a="
              tag. If the signature does not validate, the verifier SHOULD
              ignore the signature and return PERMFAIL (signature did not
              verify).</t>

              <t>Otherwise, the signature has correctly verified.</t>
            </list> <list>
              <t>INFORMATIVE IMPLEMENTER'S NOTE: Implementations might wish to
              initiate the public-key query in parallel with calculating the
              hash as the public key is not needed until the final decryption
              is calculated. Implementations may also verify the signature on
              the message header before validating that the message hash
              listed in the "bh=" tag in the DKIM-Signature header field
              matches that of the actual message body; however, if the body
              hash does not match, the entire signature must be considered to
              have failed.</t>
            </list></t>

          <t>A body length specified in the "l=" tag of the signature limits
          the number of bytes of the body passed to the verification
          algorithm. All data beyond that limit is not validated by DKIM.
          Hence, verifiers might treat a message that contains bytes beyond
          the indicated body length with suspicion, such as by truncating the
          message at the indicated body length, declaring the signature
          invalid (e.g., by returning PERMFAIL (unsigned content)), or
          conveying the partial verification to the policy module.<list
              style="empty">
              <t>INFORMATIVE IMPLEMENTATION NOTE: Verifiers that truncate the
              body at the indicated body length might pass on a malformed MIME
              message if the signer used the "N-4" trick (omitting the final
              "--CRLF") described in the informative note in <xref
              target="body-length-limits"> </xref>. Such verifiers may wish to
              check for this case and include a trailing "--CRLF" to avoid
              breaking the MIME structure. A simple way to achieve this might
              be to append "--CRLF" to any "multipart" message with a body
              length; if the MIME structure is already correctly formed, this
              will appear in the postlude and will not be displayed to the end
              user.</t>
            </list></t>
        </section>
      </section>

      <section title="Communicate Verification Results">
        <t>Verifiers wishing to communicate the results of verification to
        other parts of the mail system may do so in whatever manner they see
        fit. For example, implementations might choose to add an email header
        field to the message before passing it on. Any such header field
        SHOULD be inserted before any existing DKIM-Signature or preexisting
        authentication status header fields in the header field block. <list>
            <t>INFORMATIVE ADVICE to MUA filter writers: Patterns intended to
            search for results header fields to visibly mark authenticated
            mail for end users should verify that such header field was added
            by the appropriate verifying domain and that the verified identity
            matches the author identity that will be displayed by the MUA. In
            particular, MUA filters should not be influenced by bogus results
            header fields added by attackers. To circumvent this attack,
            verifiers may wish to delete existing results header fields after
            verification and before adding a new header field.</t>
          </list></t>
      </section>

      <section anchor="interpret-results"
               title="Interpret Results/Apply Local Policy">
        <t>It is beyond the scope of this specification to describe what
        actions a verifier system should make, but an authenticated email
        presents an opportunity to a receiving system that unauthenticated
        email cannot. Specifically, an authenticated email creates a
        predictable identifier by which other decisions can reliably be
        managed, such as trust and reputation. Conversely, unauthenticated
        email lacks a reliable identifier that can be used to assign trust and
        reputation. It is reasonable to treat unauthenticated email as lacking
        any trust and having no positive reputation.</t>

        <t>In general, verifiers SHOULD NOT reject messages solely on the
        basis of a lack of signature or an unverifiable signature; such
        rejection would cause severe interoperability problems. However, if
        the verifier does opt to reject such messages (for example, when
        communicating with a peer who, by prior agreement, agrees to only send
        signed messages), and the verifier runs synchronously with the SMTP
        session and a signature is missing or does not verify, the MTA SHOULD
        use a 550/5.7.x reply code.</t>

        <t>If it is not possible to fetch the public key, perhaps because the
        key server is not available, a temporary failure message MAY be
        generated using a 451/4.7.5 reply code, such as: <list style="empty">
            <t>451 4.7.5 Unable to verify signature - key server
            unavailable</t>
          </list>Temporary failures such as inability to access the key server
        or other external service are the only conditions that SHOULD use a
        4xx SMTP reply code. In particular, cryptographic signature
        verification failures MUST NOT return 4xx SMTP replies.</t>

        <t>Once the signature has been verified, that information MUST be
        conveyed to higher-level systems (such as explicit allow/whitelists
        and reputation systems) and/or to the end user. If the message is
        signed on behalf of any address other than that in the From: header
        field, the mail system SHOULD take pains to ensure that the actual
        signing identity is clear to the reader.</t>

        <t>The verifier MAY treat unsigned header fields with extreme
        skepticism, including marking them as untrusted or even deleting them
        before display to the end user.</t>

        <t>While the symptoms of a failed verification are obvious &mdash; the
        signature doesn't verify &mdash; establishing the exact cause can be
        more difficult. If a selector cannot be found, is that because the
        selector has been removed, or was the value changed somehow in
        transit? If the signature line is missing, is that because it was
        never there, or was it removed by an overzealous filter? For
        diagnostic purposes, the exact reason why the verification fails
        SHOULD be made available to the policy module and possibly recorded in
        the system logs. If the email cannot be verified, then it SHOULD be
        rendered the same as all unverified email regardless of whether or not
        it looks like it was signed.</t>
      </section>
    </section>

    <section title="IANA Considerations">
      <t>DKIM introduces some new namespaces that have been registered with
      IANA. In all cases, new values are assigned only for values that have
      been documented in a published RFC that has IETF Consensus <xref
      target="RFC2434"></xref>.</t>

      <section title="DKIM-Signature Tag Specifications">
        <t>A DKIM-Signature provides for a list of tag specifications. IANA
        has established the DKIM-Signature Tag Specification Registry for tag
        specifications that can be used in DKIM-Signature fields.</t>

        <texttable title="DKIM-Signature Tag Specification Registry Initial Values">
          <preamble>The initial entries in the registry comprise:</preamble>

          <ttcol>TYPE</ttcol>

          <ttcol>REFERENCE</ttcol>

          <c>v</c>

          <c>(this document)</c>

          <c>a</c>

          <c>(this document)</c>

          <c>b</c>

          <c>(this document)</c>

          <c>bh</c>

          <c>(this document)</c>

          <c>c</c>

          <c>(this document)</c>

          <c>d</c>

          <c>(this document)</c>

          <c>h</c>

          <c>(this document)</c>

          <c>i</c>

          <c>(this document)</c>

          <c>l</c>

          <c>(this document)</c>

          <c>q</c>

          <c>(this document)</c>

          <c>s</c>

          <c>(this document)</c>

          <c>t</c>

          <c>(this document)</c>

          <c>x</c>

          <c>(this document)</c>

          <c>z</c>

          <c>(this document)</c>
        </texttable>
      </section>

      <section title="DKIM-Signature Query Method Registry">
        <t>The "q=" tag-spec (specified in <xref
        target="dkim-sig-hdr"></xref>) provides for a list of query
        methods.</t>

        <t>IANA has established the DKIM-Signature Query Method Registry for
        mechanisms that can be used to retrieve the key that will permit
        validation processing of a message signed using DKIM.</t>

        <texttable title="DKIM-Signature Query Method Registry Initial Values">
          <preamble>The initial entry in the registry comprises:</preamble>

          <ttcol>TYPE</ttcol>

          <ttcol>OPTION</ttcol>

          <ttcol>REFERENCE</ttcol>

          <c>dns</c>

          <c>txt</c>

          <c>(this document)</c>
        </texttable>
      </section>

      <section title="DKIM-Signature Canonicalization Registry">
        <t>The "c=" tag-spec (specified in <xref
        target="dkim-sig-hdr"></xref>) provides for a specifier for
        canonicalization algorithms for the header and body of the
        message.</t>

        <t>IANA has established the DKIM-Signature Canonicalization Algorithm
        Registry for algorithms for converting a message into a canonical form
        before signing or verifying using DKIM.</t>

        <texttable title="DKIM-Signature Header Canonicalization Algorithm Registry Initial Values">
          <preamble>The initial entries in the header registry
          comprise:</preamble>

          <ttcol>TYPE</ttcol>

          <ttcol>REFERENCE</ttcol>

          <c>simple</c>

          <c>(this document)</c>

          <c>relaxed</c>

          <c>(this document)</c>
        </texttable>

        <texttable title="DKIM-Signature Body Canonicalization Algorithm Registry Initial Values">
          <preamble>The initial entries in the body registry
          comprise:</preamble>

          <ttcol>TYPE</ttcol>

          <ttcol>REFERENCE</ttcol>

          <c>simple</c>

          <c>(this document)</c>

          <c>relaxed</c>

          <c>(this document)</c>
        </texttable>
      </section>

      <section title="_domainkey DNS TXT Record Tag Specifications">
        <!-- 5. RFC Editor Comment: Should the section title be DKIM _domainkey
DNS TXT Record Tag Specifications? -->

        <!-- Author Response: no; there is a chance that these keys might be used for other services someday -->

        <t>A _domainkey DNS TXT record provides for a list of tag
        specifications. IANA has established the DKIM _domainkey DNS TXT Tag
        Specification Registry for tag specifications that can be used in DNS
        TXT Records.</t>

        <texttable title="DKIM _domainkey DNS TXT Record Tag Specification Registry Initial Values">
          <preamble>The initial entries in the registry comprise:</preamble>

          <ttcol>TYPE</ttcol>

          <ttcol>REFERENCE</ttcol>

          <c>v</c>

          <c>(this document)</c>

          <c>g</c>

          <c>(this document)</c>

          <c>h</c>

          <c>(this document)</c>

          <c>k</c>

          <c>(this document)</c>

          <c>n</c>

          <c>(this document)</c>

          <c>p</c>

          <c>(this document)</c>

          <c>s</c>

          <c>(this document)</c>

          <c>t</c>

          <c>(this document)</c>

          <postamble></postamble>
        </texttable>
      </section>

      <section title="DKIM Key Type Registry">
        <t>The "k=" &lt;key-k-tag&gt; (specified in <xref
        target="key-text"></xref>) and the "a=" &lt;sig-a-tag-k&gt; (specified
        in <xref target="dkim-sig-hdr"></xref>) tags provide for a list of
        mechanisms that can be used to decode a DKIM signature.</t>

        <t>IANA has established the DKIM Key Type Registry for such
        mechanisms.</t>

        <texttable title="DKIM Key Type Initial Values">
          <preamble>The initial entry in the registry comprises:</preamble>

          <ttcol>TYPE</ttcol>

          <ttcol>REFERENCE</ttcol>

          <c>rsa</c>

          <c><xref target="RFC3447"></xref></c>

          <postamble></postamble>
        </texttable>
      </section>

      <section title="DKIM Hash Algorithms Registry">
        <t>The "h=" &lt;key-h-tag&gt; (specified in <xref
        target="key-text"></xref>) and the "a=" &lt;sig-a-tag-h&gt; (specified
        in <xref target="dkim-sig-hdr"></xref>) tags provide for a list of
        mechanisms that can be used to produce a digest of message data.</t>

        <t>IANA has established the DKIM Hash Algorithms Registry for such
        mechanisms.</t>

        <texttable title="DKIM Hash Algorithms Initial Values">
          <preamble>The initial entries in the registry comprise:</preamble>

          <ttcol>TYPE</ttcol>

          <ttcol>REFERENCE</ttcol>

          <c>sha1</c>

          <c><xref target="FIPS.180-2.2002"></xref></c>

          <c>sha256</c>

          <c><xref target="FIPS.180-2.2002"></xref></c>

          <postamble></postamble>
        </texttable>
      </section>

      <section title="DKIM Service Types Registry">
        <t>The "s=" &lt;key-s-tag&gt; tag (specified in <xref
        target="key-text"></xref>) provides for a list of service types to
        which this selector may apply.</t>

        <t>IANA has established the DKIM Service Types Registry for service
        types.</t>

        <texttable title="DKIM Service Types Registry Initial Values">
          <preamble>The initial entries in the registry comprise:</preamble>

          <ttcol>TYPE</ttcol>

          <ttcol>REFERENCE</ttcol>

          <c>email</c>

          <c>(this document)</c>

          <c>*</c>

          <c>(this document)</c>

          <postamble></postamble>
        </texttable>
      </section>

      <section title="DKIM Selector Flags Registry">
        <t>The "t=" &lt;key-t-tag&gt; tag (specified in <xref
        target="key-text"></xref>) provides for a list of flags to modify
        interpretation of the selector.</t>

        <t>IANA has established the DKIM Selector Flags Registry for
        additional flags.</t>

        <texttable title="DKIM Selector Flags Registry Initial Values">
          <preamble>The initial entries in the registry comprise:</preamble>

          <ttcol>TYPE</ttcol>

          <ttcol>REFERENCE</ttcol>

          <c>y</c>

          <c>(this document)</c>

          <c>s</c>

          <c>(this document)</c>

          <postamble></postamble>
        </texttable>
      </section>

      <section title="DKIM-Signature Header Field">
        <t>IANA has added DKIM-Signature to the "Permanent Message Header
        Fields" registry (see <xref target="RFC3864"></xref>) for the "mail"
        protocol, using this document as the reference.</t>
      </section>
    </section>

    <section anchor="security-considerations" title="Security Considerations">
      <t>It has been observed that any mechanism that is introduced that
      attempts to stem the flow of spam is subject to intensive attack. DKIM
      needs to be carefully scrutinized to identify potential attack vectors
      and the vulnerability to each. See also <xref
      target="RFC4686"></xref>.</t>

      <section title="Misuse of Body Length Limits (&quot;l=&quot; Tag)">
        <t>Body length limits (in the form of the "l=" tag) are subject to
        several potential attacks.</t>

        <section title="Addition of New MIME Parts to Multipart/*">
          <t>If the body length limit does not cover a closing MIME multipart
          section (including the trailing <spanx style="verb">--CRLF</spanx>
          portion), then it is possible for an attacker to intercept a
          properly signed multipart message and add a new body part. Depending
          on the details of the MIME type and the implementation of the
          verifying MTA and the receiving MUA, this could allow an attacker to
          change the information displayed to an end user from an apparently
          trusted source.</t>

          <t>For example, if attackers can append information to a <spanx
          style="verb">text/html</spanx> body part, they may be able to
          exploit a bug in some MUAs that continue to read after a <spanx
          style="verb">&lt;/html&gt;</spanx> marker, and thus display HTML
          text on top of already displayed text. If a message has a <spanx
          style="verb">multipart/alternative</spanx> body part, they might be
          able to add a new body part that is preferred by the displaying
          MUA.</t>
        </section>

        <section title="Addition of new HTML content to existing content">
          <t>Several receiving MUA implementations do not cease display after
          a "<spanx style="verb">&lt;/html&gt;</spanx>" tag. In particular,
          this allows attacks involving overlaying images on top of existing
          text. <list>
              <t>INFORMATIVE EXAMPLE: Appending the following text to an
              existing, properly closed message will in many MUAs result in
              inappropriate data being rendered on top of existing, correct
              data: <figure>
                  <artwork><![CDATA[<div style="position: relative; bottom: 350px; z-index: 2;">
<img src="http://www.ietf.org/images/ietflogo2e.gif"
  width=578 height=370>
</div>]]></artwork>
                </figure></t>
            </list></t>
        </section>
      </section>

      <section title="Misappropriated Private Key">
        <t>If the private key for a user is resident on their computer and is
        not protected by an appropriately secure mechanism, it is possible for
        malware to send mail as that user and any other user sharing the same
        private key. The malware would not, however, be able to generate
        signed spoofs of other signers' addresses, which would aid in
        identification of the infected user and would limit the possibilities
        for certain types of attacks involving socially engineered messages.
        This threat applies mainly to MUA-based implementations; protection of
        private keys on servers can be easily achieved through the use of
        specialized cryptographic hardware.</t>

        <t>A larger problem occurs if malware on many users' computers obtains
        the private keys for those users and transmits them via a covert
        channel to a site where they can be shared. The compromised users
        would likely not know of the misappropriation until they receive
        "bounce" messages from messages they are purported to have sent. Many
        users might not understand the significance of these bounce messages
        and would not take action.</t>

        <t>One countermeasure is to use a user-entered passphrase to encrypt
        the private key, although users tend to choose weak passphrases and
        often reuse them for different purposes, possibly allowing an attack
        against DKIM to be extended into other domains. Nevertheless, the
        decoded private key might be briefly available to compromise by
        malware when it is entered, or might be discovered via keystroke
        logging. The added complexity of entering a passphrase each time one
        sends a message would also tend to discourage the use of a secure
        passphrase.</t>

        <t>A somewhat more effective countermeasure is to send messages
        through an outgoing MTA that can authenticate the submitter using
        existing techniques (e.g., SMTP Authentication), possibly validate the
        message itself (e.g., verify that the header is legitimate and that
        the content passes a spam content check), and sign the message using a
        key appropriate for the submitter address. Such an MTA can also apply
        controls on the volume of outgoing mail each user is permitted to
        originate in order to further limit the ability of malware to generate
        bulk email.</t>
      </section>

      <section title="Key Server Denial-of-Service Attacks">
        <t>Since the key servers are distributed (potentially separate for
        each domain), the number of servers that would need to be attacked to
        defeat this mechanism on an Internet-wide basis is very large.
        Nevertheless, key servers for individual domains could be attacked,
        impeding the verification of messages from that domain. This is not
        significantly different from the ability of an attacker to deny
        service to the mail exchangers for a given domain, although it affects
        outgoing, not incoming, mail.</t>

        <t>A variation on this attack is that if a very large amount of mail
        were to be sent using spoofed addresses from a given domain, the key
        servers for that domain could be overwhelmed with requests. However,
        given the low overhead of verification compared with handling of the
        email message itself, such an attack would be difficult to mount.</t>
      </section>

      <section title="Attacks Against the DNS">
        <t>Since the DNS is a required binding for key services, specific
        attacks against the DNS must be considered.</t>

        <t>While the DNS is currently insecure <xref target="RFC3833"></xref>,
        these security problems are the motivation behind <xref
        target="RFC4033">DNS Security (DNSSEC)</xref>, and all users of the
        DNS will reap the benefit of that work.</t>

        <t>DKIM is only intended as a "sufficient" method of proving
        authenticity. It is not intended to provide strong cryptographic proof
        about authorship or contents. Other technologies such as <xref
        target="RFC2440">OpenPGP</xref> and <xref
        target="RFC3851">S/MIME</xref> address those requirements.</t>

        <t>A second security issue related to the DNS revolves around the
        increased DNS traffic as a consequence of fetching selector-based data
        as well as fetching signing domain policy. Widespread deployment of
        DKIM will result in a significant increase in DNS queries to the
        claimed signing domain. In the case of forgeries on a large scale, DNS
        servers could see a substantial increase in queries.</t>

        <t>A specific DNS security issue that should be considered by DKIM
        verifiers is the name chaining attack described in Section 2.3 of the
        <xref target="RFC3833">DNS Threat Analysis</xref>. A DKIM verifier,
        while verifying a DKIM-Signature header field, could be prompted to
        retrieve a key record of an attacker's choosing. This threat can be
        minimized by ensuring that name servers, including recursive name
        servers, used by the verifier enforce strict checking of "glue" and
        other additional information in DNS responses and are therefore not
        vulnerable to this attack.</t>
      </section>

      <section title="Replay Attacks">
        <t>In this attack, a spammer sends a message to be spammed to an
        accomplice, which results in the message being signed by the
        originating MTA. The accomplice resends the message, including the
        original signature, to a large number of recipients, possibly by
        sending the message to many compromised machines that act as MTAs. The
        messages, not having been modified by the accomplice, have valid
        signatures.</t>

        <t>Partial solutions to this problem involve the use of reputation
        services to convey the fact that the specific email address is being
        used for spam and that messages from that 