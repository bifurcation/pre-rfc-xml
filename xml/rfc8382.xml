<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY RFC2119 SYSTEM "reference.RFC.2119.xml">
<!ENTITY RFC3550 SYSTEM "reference.RFC.3550.xml">
<!ENTITY RFC4585 SYSTEM "reference.RFC.4585.xml">
<!ENTITY RFC5124 SYSTEM "reference.RFC.5124.xml">
<!ENTITY RFC5481 SYSTEM "reference.RFC.5481.xml">
<!ENTITY RFC6817 SYSTEM "reference.RFC.6817.xml">
<!ENTITY RFC8174 SYSTEM "reference.RFC.8174.xml">
<!ENTITY RFC1323 SYSTEM "reference.RFC.1323.xml">
<!ENTITY RFC7679 SYSTEM "reference.RFC.7679.xml">
<!ENTITY RFC7680 SYSTEM "reference.RFC.7680.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="exp" number="8382" ipr="trust200902"
   submissionType="IETF" consensus="yes">
  
  <front>
    
    <title abbrev="SBD for CCC for RTP Media">
      Shared Bottleneck Detection for Coupled Congestion Control for
      RTP Media
    </title>
    
    <author fullname="David Hayes" initials="D.A." role="editor"
            surname="Hayes">
      <organization>Simula Research Laboratory</organization>
      <address>
        <postal>
          <street>P.O. Box 134</street>
          <city>Lysaker</city>
          <region></region>
          <code>1325</code>
          <country>Norway</country>
        </postal>
        <email>davidh@simula.no</email>
      </address>
    </author>

   <author fullname="Simone Ferlin" initials="S."
           surname="Ferlin">
      <organization>Simula Research Laboratory</organization>
      <address>
        <postal>
          <street>P.O. Box 134</street>
          <city>Lysaker</city>
          <region></region>
          <code>1325</code>
          <country>Norway</country>
        </postal>
        <email>simone@ferlin.io</email>
      </address>
    </author>

    <author fullname="Michael Welzl" initials="M."
            surname="Welzl">
      <organization>University of Oslo</organization>
      <address>
        <postal>
          <street>P.O. Box 1080 Blindern</street>
          <city>Oslo</city>
          <region></region>
          <code>N-0316</code>
          <country>Norway</country>
        </postal>
        <email>michawe@ifi.uio.no</email>
      </address>
    </author>

    <author fullname="Kristian Hiorth" initials="K."
            surname="Hiorth">
      <organization>University of Oslo</organization>
      <address>
        <postal>
          <street>P.O. Box 1080 Blindern</street>
          <city>Oslo</city>
          <region></region>
          <code>N-0316</code>
          <country>Norway</country>
        </postal>
        <email>kristahi@ifi.uio.no</email>
      </address>
    </author>
    
    <date month="June" year="2018" />

    <keyword>SBD</keyword>

    <abstract>
     <t>This document describes a mechanism to detect whether end-to-end data
     flows share a common bottleneck. This mechanism relies on summary
     statistics that are calculated based on continuous measurements and used
     as input to a grouping algorithm that runs wherever the knowledge is needed.</t>
    </abstract>
  </front>

  <middle>
 
    <section title="Introduction">
      <t>In the Internet, it is not normally known whether flows (e.g., TCP
      connections or UDP data streams) traverse the same bottlenecks. Even
      flows that have the same sender and receiver may take different paths
      and may or may not share a bottleneck. Flows that share a bottleneck
      link usually compete with one another for their share of the
      capacity. This competition has the potential to increase packet loss and
      delays. This is especially relevant for interactive applications that
      communicate simultaneously with multiple peers (such as multi&nbhy;party
      video). For RTP media applications such as RTCWEB, <xref
      target="RTP-COUPLED-CC"></xref> describes a scheme that
      combines the congestion controllers of flows in order to honor their
      priorities and avoid unnecessary packet loss as well as delay. This
      mechanism relies on some form of Shared Bottleneck Detection (SBD);
      here, a measurement-based SBD approach is described.</t>

       <section title="The Basic Mechanism">
         <t>The mechanism groups flows that have similar statistical
         characteristics together. <xref target="flowgrouping"></xref>
         describes a simple method for achieving this; however, a major part
         of this document is concerned with collecting suitable statistics for
         this purpose.</t>
       </section>
       <section title="The Signals">

         <t>The current Internet is unable to explicitly inform endpoints as
         to which flows share bottlenecks, so endpoints need to infer this
         from whatever information is available to them. The mechanism
         described here currently utilizes packet loss and packet delay but
         is not restricted to these. As Explicit Congestion Notification (ECN)
         becomes more prevalent, it too will become a valuable base signal
         that can be correlated to detect shared bottlenecks.</t>

         <section title="Packet Loss">
           <t>Packet loss is often a relatively infrequent indication that a
           flow traverses a bottleneck. Therefore, on its own it is of
           limited use for SBD; however, it is a valuable supplementary
           measure when it is more prevalent (refer to
           <xref target="RFC7680"></xref>, Section&nbsp;2.5 for
           measuring packet loss).</t>
         </section>

         <section title="Packet Delay">
           <t>End-to-end delay measurements include noise from every
           device along the path, in addition to the delay
           perturbation at the bottleneck device. The noise is
           often significantly increased if the round-trip time is used. The
           cleanest signal is obtained by using One-Way Delay
           (OWD) (refer to <xref target="RFC7679"></xref>, Section&nbsp;3
           for a definition of OWD).</t>

           <t>Measuring absolute OWD is difficult, since it requires
           both the sender and receiver clocks to be
           synchronized. However, since the statistics being
           collected are relative to the mean OWD, a relative OWD
           measurement is sufficient. Clock skew is not usually
           significant over the time intervals used by this SBD
           mechanism (see <xref target="RFC6817"/>, Appendix&nbsp;A.2 for a
           discussion on clock skew and OWD measurements). However,
           in circumstances where it is significant, <xref
           target="clockskew"></xref> outlines a way of adjusting the
           calculations to cater to it.</t>

           <t>Each packet arriving at the bottleneck buffer may
           experience very different queue lengths and, therefore, different
           waiting times. A single OWD sample does not, therefore,
           characterize the path well. However, multiple OWD measurements
           do reflect the distribution of delays experienced at the
           bottleneck.</t>
         </section>
       
         <section title="Path Lag">
           <t>Flows that share a common bottleneck may traverse
           different paths, and these paths will often have different
           base delays. This makes it difficult to correlate changes
           in delay or loss. This technique uses the long-term shape
           of the delay distribution as a base for comparison to
           counter this.</t>
         </section>
       </section>
    </section>
      
    <section anchor="Definitions" title="Definitions">

    <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
    "SHALL&nbsp;NOT", "SHOULD", "SHOULD&nbsp;NOT", "RECOMMENDED",
    "NOT&nbsp;RECOMMENDED", "MAY", and "OPTIONAL" in this document
    are to be interpreted as described in BCP&nbsp;14
    <xref format="default" pageno="false" target="RFC2119"/>
    <xref format="default" pageno="false" target="RFC8174"/> when,
    and only when, they appear in all capitals, as shown here.</t>

      <t>Acronyms used in this document:
      <list>
       <t>OWD - One-Way Delay</t>
       <t>MAD - Mean Absolute Deviation</t>
       <t>SBD - Shared Bottleneck Detection</t>
      </list></t>

      <t>Conventions used in this document:</t>
      <t><list hangIndent="16" style="hanging">
       <t hangText="   T"> the base time interval over which measurements
       are&nbsp;made</t>
       <t hangText="   N"> the number of base time, T, intervals
       used in some calculations</t>
       <t hangText="   M"> the number of base time, T, intervals
       used in some calculations, where M &lt;= N</t>
       <t hangText="   sum(...)">  summation of terms of the variable in parentheses</t>
       <t hangText="   sum_T(...)">  summation of all the
       measurements of the variable in parentheses taken over the
       interval T</t>
       <t hangText="   sum_NT(...)"> summation of all
       measurements taken over the interval&nbsp;N*T</t>
       <t hangText="   sum_MT(...)"> summation of all
       measurements taken over the interval&nbsp;M*T</t>
       <t hangText="   E_T(...)">  the expectation or mean of the
       measurements of the variable in parentheses over T</t>
       <t hangText="   E_N(...)">  the expectation or mean of the last N values of
       the variable in parentheses</t>
       <t hangText="   E_M(...)">  the expectation or mean of the last M values of
       the variable in parentheses</t>
       <t hangText="   num_T(...)"> the count of measurements of the
       variable in parentheses taken in the interval T</t>
       <t hangText="   num_MT(...)"> the count of measurements of the
       variable in parentheses taken in the interval M*T</t>
       <t hangText="   PB"> a boolean variable indicating that the
       particular flow was identified transiting a bottleneck in
       the previous interval T (i.e., "Previously Bottleneck")</t>
       <t hangText="   skew_est"> a measure of skewness in an OWD
       distribution</t>
       <t hangText="   skew_base_T"> a variable used as an
       intermediate step in calculating skew_est</t>
       <t hangText="   var_est"> a measure of variability in
       OWD measurements</t>
       <t hangText="   var_base_T"> a variable used as an
       intermediate step in calculating var_est</t>
       <t hangText="   freq_est"> a measure of low-frequency oscillation
       in the OWD measurements</t>
       <t hangText="   pkt_loss"> a measure of the proportion of packets
       lost</t>
       <t hangText="   p_l, p_f, p_mad, c_s, c_h, p_s, p_d, p_v"><vspace/>
       various thresholds used in the mechanism</t>
       <t hangText="   M and F"> number of values related to N</t>
      </list></t>

      <section anchor="parameters" title="Parameters and Their Effects">
       <t><list hangIndent="10" style="hanging">
         <t hangText="T"> T should be long enough so that there are
         enough packets received during T for a useful estimate of the
         short-term mean OWD and variation statistics. Making T too
         large can limit the efficacy of freq_est. It will
         also increase the response time of the mechanism. Making T
         too small will make the metrics noisier.</t>

         <t hangText="N and M"> N should be large enough to provide a
         stable estimate of oscillations in OWD. Often, M=N is just fine,
         though having M&lt;N may be beneficial in certain circumstances.
         M*T needs to be long enough to provide stable estimates of
         skewness and MAD.</t>

         <t hangText="F"> F determines the number of intervals
         over which statistics are considered to be equally
         weighted. When F=M, recent and older measurements are
         considered equal. Making F&lt;M can increase the
         responsiveness of the SBD mechanism. If F is too small,
         statistics will be too noisy.</t>

         <t hangText="c_s"> c_s is the threshold in skew_est used for
         determining whether a flow is transiting a bottleneck or not.  Lower
         values of c_s require bottlenecks to be more congested to be
         considered for grouping by the mechanism. &nbsp;c_s should be
         set within the range of +0.2 to -0.1 -- low enough so that
         lightly loaded paths do not give a false indication.</t>

         <t hangText="p_l"> p_l is the threshold in pkt_loss used for
         determining whether a flow is transiting a bottleneck or
         not. When pkt_loss is high, it becomes a better indicator of
         congestion than skew_est.</t>
         
         <t hangText="c_h"> c_h adds hysteresis to the bottleneck
         determination. It should be large enough to avoid constant
         switching in the determination but low enough to ensure
         that grouping is not attempted when there is no bottleneck
         and the delay and loss signals cannot be relied upon.</t>

         <t hangText="p_v"> p_v determines the sensitivity of freq_est
         to noise. Making it smaller will yield higher but noisier
         values for freq_est. Making it too large will render it
         ineffective for determining groups.</t>

         <t hangText="p_*"> Flows are separated when the
         skew_est|var_est|freq_est|pkt_loss measure is greater than
         p_s|p_mad|p_f|p_d. Adjusting these is a compromise
         between false grouping of flows that do not share a
         bottleneck and false splitting of flows that do. Making them
         larger can help if the measures are very noisy, but reducing
         the noise in the statistical measures by adjusting T and N|M
         may be a better solution.</t>
         
       </list></t>
       
      </section>

      <section anchor="recommended-parameters" title="Recommended Parameter Values">
         <t><xref target="Hayes-LCN14"/> uses T=350ms and N=50.
         The other parameters have been tightened to reflect minor
         enhancements to the algorithm outlined in
         <xref target="enhancements"/>:
          c_s=0.1, p_f=p_d=0.1, p_s=0.15,
          p_mad=0.1, p_v=0.7. M=30, F=20, and c_h=0.3 are additional
          parameters defined in that document. These are values that seem
          to work well over a wide range of practical Internet conditions.</t>
      </section>
      
    </section>


    <section anchor="Mechanism" title="Mechanism">
      <t>The mechanism described in this document is based on the
      observation that when flows traverse a common bottleneck,
      each flow's distribution of packet delay measurements has similar
      shape characteristics. These shape characteristics are described
      using three key summary statistics --
      <list style="numbers">
       <t>variability estimate (var_est; see <xref target="sbd_mad"/>)</t>
       <t>skewness estimate (skew_est; see <xref target="sbd_skewest"/>)</t>
       <t>oscillation estimate (freq_est; see <xref target="sbd_freqest"/>)</t>
      </list>
      -- with packet loss (pkt_loss; see <xref target="sbd_pktloss"/>)
      used as a supplementary statistic.</t>
      
      <t>Summary statistics help to address both the noise and the path lag
      problems by describing the general shape over a relatively long period
      of time. Each summary statistic portrays a "view" of the bottleneck link
      characteristics, and when used together, they provide a robust
      discrimination for grouping flows.  An RTP media device may be both a
      sender and a receiver. SBD can be performed at either a sender or a
      receiver, or both.</t>

      <t>In <xref target="sbd-topo" />, there are two possible locations
      for shared bottleneck detection: the sender side and the
      receiver side.</t>

      <figure align="center" anchor="sbd-topo">

        <artwork align="left"><![CDATA[
                               +----+
                               | H2 |
                               +----+
                                  |
                                  | L2
                                  |
                      +----+  L1  |  L3  +----+
                      | H1 |------|------| H3 |
                      +----+             +----+
            ]]></artwork>

      <postamble>A network with three hosts (H1, H2, H3) and three links (L1, L2, L3)</postamble>
      </figure>

      <t><list style="numbers">
       <t>Sender side: Consider a situation where host H1 sends media
         streams to hosts H2 and H3, and L1 is a shared bottleneck.
         H2 and H3 measure the OWD and packet loss and periodically send
         either this raw data or the calculated summary statistics to H1
         every T. H1, having this knowledge, can determine the shared
         bottleneck and accordingly control the send rates.</t>

         <t>Receiver side: Consider that H2 is also sending media to
         H3, and L3 is a shared bottleneck. If H3 sends summary
         statistics to H1 and H2, neither H1 nor H2 alone obtains
         enough knowledge to detect this shared bottleneck; H3 can,
         however, determine it by combining the summary statistics
         related to H1 and H2, respectively.</t>
      </list></t>

      <section anchor="feedback" title="SBD Feedback Requirements">

       <t>There are three possible scenarios, each with different
       feedback requirements:
       <list style="numbers">
         <t>Both summary statistic calculations and SBD are performed at
         senders only. When sender-based congestion control is implemented,
         this method is RECOMMENDED.</t>
         <t>Summary statistics are calculated on the receivers, and SBD is
         performed at the senders.</t>
         <t>Summary statistic calculations are performed on receivers, and
         SBD is performed at both senders and receivers (beyond the
         scope of this document, but allows cooperative detection of
         bottlenecks).</t>
       </list> </t>

       <t>All three possibilities are discussed for completeness in this
       document; however, it is expected that feedback will take the form
       of scenario 1 and operate in conjunction with sender-based
       congestion control mechanisms.</t>

       <section anchor="sender-feedback" title="Feedback When All the Logic Is Placed at the Sender">

         <t>Having the sender calculate the summary statistics and
         determine the shared bottlenecks based on them has the
         advantage of placing most of the functionality in one place --
         the sender.</t>

         <t>For every packet, the sender requires accurate relative OWD
         measurements of adequate precision, along with an indication of lost
         packets (or the proportion of packets lost over an interval). A
         method to provide such measurement data with the RTP Control Protocol
         (RTCP) is described in <xref target="RTCP-CC-FEEDBACK"></xref>.</t>

         <t>Sums, var_base_T, and skew_base_T are calculated incrementally as
         relative OWD measurements are determined from the feedback
         messages. When the mechanism has received sufficient measurements to
         cover the base time interval T for all flows, the summary statistics
         (see <xref target="sbd-metrics"></xref>) are calculated for that
         T interval and flows are grouped (see <xref
         target="flowgrouping"></xref>). The exact timing of these
         calculations will depend on the frequency of the feedback message.</t>

       </section>

       <section anchor="receiver-feedback" title="Feedback When the Statistics Are Calculated at the Receiver and SBD Is Performed at the Sender">
       <t>This scenario minimizes feedback but requires receivers to
       send selected summary statistics at an agreed-upon regular
       interval. We envisage the following exchange of information to
       initialize the system:
       <list style="symbols">
         <t>An initialization message from the sender to the receiver
         will contain the following information:
         <list style="symbols">
           <t> A list of which key metrics should be collected and
           relayed back to the sender out of a possibly extensible set
           (pkt_loss, var_est, skew_est, and freq_est).  The grouping
           algorithm described in this document requires all four of
           these metrics, and receivers MUST be able to provide them, but
           future algorithms may be able to exploit other metrics
           (e.g., metrics based on explicit network signals).</t>
           
           <t> The values of T, N, and M, and the necessary resolution and
           precision of the relayed statistics.</t>
         </list> </t>        
         
         <t>A response message from the receiver acknowledges this message
         with a list of key metrics it supports (subset of the sender's list)
         and is able to relay back to the sender.</t>
         
       </list></t>

       <t>This initialization exchange may be repeated to finalize the
         set of metrics that will be used. All agreed&nbhy;upon metrics need
         to be supported by all receivers. It is also recommended that an
         identifier for the SBD algorithm version be included in the
         initialization message from the sender, so that potential advances in
         SBD technology can be easily deployed. For reference, the mechanism
         outlined in this document has the identifier "SBD=01".</t>

       <t>After initialization, the agreed-upon summary statistics are
       fed back to the sender (nominally every T).</t>

       </section>
       
        <section anchor="receiversender-feedback" title="Feedback When Bottlenecks Can Be Determined at Both Senders and Receivers">
         <t>This type of mechanism is currently beyond the scope of
         the SBD algorithm described in this document. It is mentioned here to
         ensure that sender/receiver cooperative shared bottleneck
         determination mechanisms that are more advanced remain possible in
         the future.</t>

         <t>It is envisaged that such a mechanism would be
         initialized in a manner similar to that described in <xref
         target="receiver-feedback" />.</t>

         <t>After initialization, both summary statistics and shared
         bottleneck determinations should be exchanged, nominally
         every T.</t>
       </section>

      </section>

      <section anchor="sbd-metrics" title="Key Metrics and Their Calculation">

       <t>Measurements are calculated over a base interval (T) and
       summarized over N or M such intervals.  All summary statistics
       can be calculated incrementally.</t>

       <section title="Mean Delay">

         <t>The mean delay is not a useful signal for comparisons
         between flows, since flows may traverse quite different paths
         and clocks will not necessarily be synchronized. However, it
         is a base measure for the three summary statistics. The mean
         delay, E_T(OWD), is the average OWD measured over T.</t>
         
         <t>To facilitate the other calculations, the last N
         E_T(OWD) values will need to be stored in a cyclic buffer
         along with the moving average of E_T(OWD):</t>

<figure><artwork><![CDATA[
   mean_delay = E_M(E_T(OWD)) = sum_M(E_T(OWD)) / M
]]></artwork></figure>

         <t>where M &le; N. Setting M to be less than N
         allows the mechanism to be more responsive to changes, but
         potentially at the expense of a higher error rate (see <xref
         target="improvingresponse"/> for a discussion on improving
         the responsiveness of the mechanism).</t>
       </section>
       
       <section anchor="sbd_skewest" title="Skewness Estimate">
         <t>Skewness is difficult to calculate efficiently and
         accurately. Ideally, it should be calculated over the entire
         period (M*T) from the mean OWD over that period. However, this
         would require storing every delay measurement over the
         period. Instead, an estimate is made over M*T based on a
         calculation every T using the previous T's calculation of
         mean_delay.</t>

         <t>The base for the skewness calculation is estimated using a
         counter initialized every T. It increments for OWD samples below
         the mean and decrements for OWD above the mean. So, for each
         OWD sample:</t>

<figure><artwork><![CDATA[
   if (OWD < mean_delay) skew_base_T++

   if (OWD > mean_delay) skew_base_T--
]]></artwork></figure>

         <t>mean_delay does not include the mean of the current T interval
         to enable it to be calculated iteratively.</t>

         <t>skew_est = sum_MT(skew_base_T) / num_MT(OWD)
         <list style="hanging">
           <t> where skew_est is a number between -1 and 1.</t>
         </list></t>
         
         <t>Note: Care must be taken when implementing the
         comparisons to ensure that rounding does not bias
         skew_est. It is important that the mean is calculated
         with a higher precision than the samples.
       </t>
       </section>

       <section anchor="sbd_mad" title="Variability Estimate">
         <t>Mean Absolute Deviation (MAD) is a robust variability measure
         that copes well with different send rates. It can be
         implemented in an online manner as follows:</t>

<figure><artwork><![CDATA[
   var_base_T = sum_T(|OWD - E_T(OWD)|)

      where

         |x| is the absolute value of x

         E_T(OWD) is the mean OWD calculated in the previous T

   var_est = MAD_MT = sum_MT(var_base_T) / num_MT(OWD)
]]></artwork></figure>

       </section>
       
       <section anchor="sbd_freqest" title="Oscillation Estimate">
         <t>An estimate of the low-frequency oscillation of the delay
         signal is calculated by counting and normalizing the significant mean,
         E_T(OWD), crossings of mean_delay:
         <list style="hanging">
           <t>freq_est = number_of_crossings / N
           <list style="hanging">
             <t>where we define a significant mean
             crossing as a crossing that extends p_v * var_est from
             mean_delay. In our experiments, we have found that
             p_v = 0.7 is a good value.</t>
           </list></t>
         </list>
         freq_est is a number between 0 and 1. &nbsp;freq_est
         can be approximated incrementally as follows:
         <list style="symbols">
           <t>With each new calculation of E_T(OWD), a decision is
           made as to whether this value of E_T(OWD) significantly
           crosses the current long-term mean, mean_delay, with respect to
           the previous significant mean crossing.</t>
           
           <t>A cyclic buffer, last_N_crossings, records a 1 if there is a
           significant mean crossing; otherwise, it records a 0.</t>

           <t>The counter, number_of_crossings, is incremented when there
           is a significant mean crossing and decremented when a
           non-zero value is removed from the last_N_crossings.</t>
         </list>
         This approximation of freq_est was not used in <xref
         target="Hayes-LCN14"/>, which calculated freq_est every T
         using the current E_N(E_T(OWD)). Our tests show that
         this approximation of freq_est yields results that are almost
         identical to when the full calculation is performed every&nbsp;T.</t>

       </section>

       <section anchor="sbd_pktloss" title="Packet Loss">
         <t>The proportion of packets lost over the period NT is used
         as a supplementary measure:
         <list style="hanging">
           <t>pkt_loss = sum_NT(lost packets) / sum_NT(total packets)</t>
         </list>
         Note: When pkt_loss is low, it is very variable; however,
         when pkt_loss is high, it becomes a stable measure for
         making grouping decisions.</t>
       </section>
      </section>

      <section  title="Flow Grouping">
       <section anchor="flowgrouping" title="Flow-Grouping Algorithm">
         <t>The following grouping algorithm is RECOMMENDED for the use of
         SBD with coupled congestion control for RTP media
         <xref target="RTP-COUPLED-CC"/> and is sufficient and
         efficient for small to moderate numbers of flows. For very large
         numbers of flows (e.g., hundreds), a more complex clustering
         algorithm may be substituted.</t>

         <t>Since no single metric is precise enough to group flows
         (due to noise), the algorithm uses multiple metrics. Each
         metric offers a different "view" of the bottleneck link
         characteristics, and used together they enable a more precise
         grouping of flows than would otherwise be possible.</t>

         <t>Flows determined to be transiting a bottleneck are
         successively divided into groups based on freq_est,
         var_est, skew_est, and pkt_loss.</t>
         
          <t>The first step is to determine which flows are transiting a
          bottleneck. This is important, since if a flow is not transiting a
          bottleneck its delay-based metrics will not describe the bottleneck
          but will instead describe the "noise" from the rest of the
          path. Skewness, with the proportion of packet loss as a
          supplementary measure, is used to do this:

         <list counter="grouping" style="format %d.">
           <t>Grouping will be performed on flows that are inferred
           to be traversing a bottleneck by:

           <list style="hanging">
              <t>skew_est &lt; c_s
                <list style="hanging">
                <t>|| ( skew_est &lt; c_h &amp; PB ) || pkt_loss > p_l</t>
              </list></t>
           </list></t>
         </list></t>

         <t>The parameter c_s controls how sensitive the mechanism is
         in detecting a bottleneck. &nbsp;c_s = 0.0 was used in  <xref
         target="Hayes-LCN14"/>. A value of c_s = 0.1 is a little
         more sensitive, and c_s = -0.1 is a little less
         sensitive. &nbsp;c_h controls the hysteresis on flows that were
         grouped as transiting a bottleneck the previous time. If the test
         result is TRUE, PB=TRUE; otherwise, PB=FALSE.</t>

         <t>These flows (i.e., flows transiting a bottleneck) are then
         progressively divided into groups based on the freq_est, var_est,
         and skew_est summary statistics. The process proceeds
         according to the following steps:

         <list counter="grouping" style="format %d.">
           <t>Group flows whose difference in sorted freq_est
           is less than a threshold:
           <list style="hanging">
             <t> diff(freq_est) &lt;  p_f</t>
           </list></t>
           <t>Subdivide the groups obtained in step 2 by grouping flows
           whose difference in sorted E_M(var_est) (highest to lowest) is
           less than a threshold:
           <list style="hanging">
             <t> diff(var_est) &lt;  (p_mad * var_est) </t>
           </list>The threshold, (p_mad * var_est), is with respect
           to the highest value in the difference.</t>
            <t>Subdivide the groups obtained in step 3 by grouping flows
            whose difference in sorted skew_est is less than a threshold:
           <list style="hanging">
             <t> diff(skew_est) &lt; p_s </t>
           </list></t>
           <t>When packet loss is high enough to be reliable
           (pkt_loss &gt; p_l), subdivide the groups obtained in step 4 by
           grouping flows whose difference is less than a threshold:
             <list style="hanging">
              <t>diff(pkt_loss) &lt; (p_d * pkt_loss)</t>
              </list>The threshold, (p_d * pkt_loss), is with respect to
              the highest value in the difference.</t>
         </list></t>
         
         <t>This procedure involves sorting estimates from highest to
         lowest. It is simple to implement and is efficient for small
         numbers of flows (up to 10-20).
         <xref target="sbd-grping" /> illustrates this algorithm.</t>

         <figure align="center" anchor="sbd-grping">
            <artwork align="left"><![CDATA[
                                     *********
                                     * Flows *
                                     ***.**.**
                                       /    '
                                      /     '--.
                                     /          \
                                .---v--.    .----v---.
1. Flows traversing             | Cong |    | UnCong |
   a bottleneck                 '-.--.-'    '--------'
                                 /    \
                                /      \
                               /        \
                           .--v--.       v-----.
2. Divide by               | g_1 |  ...  | g_n |
   freq_est                '---.-.       '----..
                              /   \          /  \
                             /     '--.     v    '------.
                            /          \                 \
                      .----v-.        .-v----.        .---v--.
3. Divide by          | g_1a |  ...   | g_1z |   ...  | g_nz |
   var_est            '---.-.'        '-----..        '-.-.--'
                         /   \             /  \        /  |
                        /     '-----.     v    v      v   |
                       /             \                    |
                    .-v-----.       .-v-----.         .---v---.
4. Divide by        | g_1ai |  ...  | g_1ax |   ...   | g_nzx |
   skew_est         '----.-.'       '------..         '-.-.---'
                        /   \             /  \         /  |
                       /     '--.        v    v       v   |
                      /          \                        |
               .-----v--.       .-v------.           .----v---.
5. Divide by   | g_1aiA |  ...  | g_1aiZ |    ...    | g_nzxZ |
   pkt_loss    '--------'       '--------'           '--------'
   (when applicable)
   ]]></artwork>
            <postamble>Simple grouping algorithm</postamble>
         </figure>

       </section>
       <section title="Using the Flow Group Signal">
         <t>Grouping decisions can be made every T from the second T;
         however, they will not attain their full design accuracy until
         after the 2*Nth&nbsp;T interval. We recommend that grouping
         decisions not be made until 2*M T intervals.</t>
         <t>Network conditions, and even the congestion controllers,
         can cause bottlenecks to fluctuate. A coupled congestion
         controller MAY decide only to couple groups that remain
         stable, say grouped together 90% of the time, depending on
         its objectives. Recommendations concerning this are beyond
         the scope of this document and will be specific to the coupled
         congestion controller's objectives.</t>
       </section>

      </section>
      
    </section>
    
    <section anchor="enhancements" title="Enhancements to the Basic SBD Algorithm">
      <t>The SBD algorithm as specified in <xref target="Mechanism"/> was
      found to work well for a broad variety of conditions. The following
      enhancements to the basic mechanisms have been found to
      significantly improve the algorithm's performance under some
      circumstances and SHOULD be implemented. These "tweaks" are
      described separately to keep the main description succinct.</t>
      
      <section anchor="improvingresponse" title="Reducing Lag and Improving Responsiveness">
       <t> This section describes how to improve the responsiveness of the
       basic algorithm.</t>
       
       <t>Measurement-based shared bottleneck detection makes
       decisions in the present based on what has been measured in the
       past. This means that there is always a lag in responding to
       changing conditions. This mechanism is based on summary
       statistics taken over (N*T) seconds. This mechanism can be made more
       responsive to changing conditions by:
       <list style="numbers">
         <t>Reducing N and/or M, but at the expense of having
         metrics that are less accurate, and/or</t>
         <t>Exploiting the fact that measurements that are more recent
         are more valuable than older measurements and weighting them
         accordingly.</t>
       </list></t>

       <t>Although measurements that are more recent are more valuable,
       older measurements are still needed to gain an accurate
       estimate of the distribution descriptor we are measuring.
       Unfortunately, the simple exponentially weighted moving
       average weights drop off too quickly for our requirements
       and have an infinite tail. A simple linearly declining
       weighted moving average also does not provide enough weight
       to the measurements that are most recent. We propose a piecewise
       linear distribution of weights, such that the first section
       (samples 1:F) is flat as in a simple moving average, and the second
       section (samples F+1:M) is linearly declining weights to the end of
       the averaging window. We choose integer weights; this allows
       incremental calculation without introducing rounding errors.</t>

       <section anchor="skewrespimp" title="Improving the Response of the Skewness Estimate">
         <t>The weighted moving average for skew_est, based on
         skew_est as defined in <xref target="sbd_skewest"/>, can be
         calculated as follows:</t>

<figure><artwork><![CDATA[
   skew_est = ((M-F+1)*sum(skew_base_T(1:F))

                   + sum([(M-F):1].*skew_base_T(F+1:M)))

              / ((M-F+1)*sum(numsampT(1:F))

                   + sum([(M-F):1].*numsampT(F+1:M)))
]]></artwork></figure>

         <t>where numsampT is an array of the number of OWD samples
         in each T (i.e., num_T(OWD)), and numsampT(1) is the most
         recent; skew_base_T(1) is the most recent calculation of
         skew_base_T; 1:F refers to the integer values 1 through to F, and
         [(M-F):1] refers to an array of the integer values (M-F)
         declining through to 1; and ".*" is the array scalar dot product
         operator.</t>
         
         <t>To calculate this weighted skew_est incrementally:

         <list hangIndent="13" style="hanging">
           <t hangText="Notation:">F_ = flat portion, D_ = declining portion,
             W_&nbsp;=&nbsp;weighted&nbsp;component</t>
           <t hangText="Initialize:">sum_skewbase = 0, F_skewbase = 0,
             W_D_skewbase = 0</t>
           <t>skewbase_hist = buffer of length M, initialized to 0</t>
           <t>numsampT = buffer of length M, initialized to 0</t>

           <t hangText="Steps per iteration:"></t>
         </list>
         <list style="numbers">
           <t>old_skewbase = skewbase_hist(M)</t>
           <t>old_numsampT = numsampT(M)</t>
           <t>cycle(skewbase_hist)</t>
           <t>cycle(numsampT)</t>
           <t>numsampT(1) = num_T(OWD)</t>
           <t>skewbase_hist(1) = skew_base_T</t>
           <t>F_skewbase = F_skewbase + skew_base_T - skewbase_hist(F+1)</t>
           <t>W_D_skewbase = W_D_skewbase + (M-F)*skewbase_hist(F+1) &nbsp;&nbsp;-&nbsp;sum_skewbase</t>
            <t>W_D_numsamp =
           W_D_numsamp + (M-F)*numsampT(F+1) - sum_numsamp &nbsp;&nbsp;+&nbsp;F_numsamp</t>
           <t>F_numsamp =  F_numsamp + numsampT(1) - numsampT(F+1)</t>
           <t>sum_skewbase = sum_skewbase + skewbase_hist(F+1) - old_skewbase</t>
           <t>sum_numsamp = sum_numsamp + numsampT(1) - old_numsampT</t>

           <t>skew_est = ((M-F+1)*F_skewbase +
           W_D_skewbase) / &nbsp;&nbsp;((M-F+1)*F_numsamp+W_D_numsamp)</t>
         </list>
         where cycle(...) refers to the operation on a cyclic buffer
         where the start of the buffer is now the next element in the
         buffer.</t>
       </section>

       <section anchor="varrespimp" title="Improving the Response of the Variability Estimate">
         <t>Similarly, the weighted moving average for var_est can be
         calculated as follows:</t>

<figure><artwork><![CDATA[
   var_est = ((M-F+1)*sum(var_base_T(1:F))

                  + sum([(M-F):1].*var_base_T(F+1:M)))

             / ((M-F+1)*sum(numsampT(1:F))

                  + sum([(M-F):1].*numsampT(F+1:M)))
]]></artwork></figure>

         <t>where numsampT is an array of the number of OWD samples
         in each T (i.e., num_T(OWD)), and numsampT(1) is the most
         recent; skew_base_T(1) is the most recent calculation of
         skew_base_T; 1:F refers to the integer values 1 through to F, and
         [(M-F):1] refers to an array of the integer values (M-F) declining
         through to 1; and ".*" is the array scalar dot product operator.
         When removing oscillation noise (see  <xref
         target="oscillationnoise"/>), this calculation must be adjusted to
         allow for invalid var_base_T records.</t>
         
         <t>var_est can be calculated incrementally in the same way
         as skew_est as shown in <xref target="skewrespimp"/>. However,
         note that the buffer numsampT is used for both calculations,
         so the operations on it should not be repeated.</t>
       </section>

      </section>
      
      <section anchor="oscillationnoise" title="Removing Oscillation Noise">
       <t>When a path has no bottleneck, var_est will be very small and
       the recorded significant mean crossings will be the result
       of path noise. Thus, up to N-1 meaningless mean crossings can
       be a source of error at the point where a link becomes a
       bottleneck and flows traversing it begin to be grouped.</t>
       
       <t>To remove this source of noise from freq_est:
       <list counter="oscn" style="format %d.">
         <t>Set the current var_base_T = NaN (a value representing
         an invalid record, i.e., Not a Number) for flows that are
         deemed to not be transiting a bottleneck by the first
         grouping test that is based on skew_est (see <xref
         target="flowgrouping"/>).</t>
         <t>Then, var_est =  sum_MT(var_base_T != NaN) / num_MT(OWD).</t>
         <t>For freq_est, only record a significant mean crossing
         if a given flow is deemed to be transiting a bottleneck.</t>
       </list>
       These three changes can help to remove the non-bottleneck noise
       from freq_est.</t>
      </section>
      
     </section>

    <section anchor="measureowd" title="Measuring OWD">

     <t>This section discusses the OWD measurements required for this
     algorithm to detect shared bottlenecks.
     </t>

     <t>The SBD mechanism described in this document relies on
     differences between OWD measurements to avoid the practical problems
     with measuring absolute OWD
     (see <xref target="Hayes-LCN14"/>, Section&nbsp;III.C). Since all
     summary statistics are relative to the mean OWD and sender/receiver
     clock offsets should be approximately constant over the measurement
     periods, the offset is subtracted out in the calculation.</t> 
     
     <section title="Timestamp Resolution">
       <t>The SBD mechanism requires timing information precise enough
       to be able to make comparisons. As a rule of thumb, the time
       resolution should be less than one hundredth of a typical path's range
       of delays. In general, the coarser the time resolution, the more
       care that needs to be taken to ensure that rounding errors do not
       bias the skewness calculation. Frequent timing information in
       millisecond resolution as described by <xref
       target="RTCP-CC-FEEDBACK"></xref> should be
       sufficient for the sender to calculate relative OWD.</t>

     </section>

     <section anchor="clockskew" title="Clock Skew">
       <t>Generally, sender and receiver clock skew will be too
       small to cause significant errors in the
       estimators. &nbsp;skew_est and freq_est are the most sensitive to
       this type of noise due to their use of a mean OWD calculated over a
       longer interval. In circumstances where clock skew is high, basing
       skew_est only on the previous T's mean and ignoring freq_est
       provide a noisier but reliable signal.</t>
       
       <t>A more sophisticated method is to estimate the effect the clock
       skew is having on the summary statistics and then adjust
       statistics accordingly. There are a number of techniques in
       the literature, including <xref target="Zhang-Infocom02"/>.</t>
       
     </section>
     
     </section>

     <section anchor="ExpectFB" title="Expected Feedback from Experiments">
      <t>The algorithm described in this memo has so far been evaluated using
      simulations and small-scale experiments. Real network tests using
      RTP Media Congestion Avoidance Techniques (RMCAT) congestion control
      algorithms will help confirm the default parameter choice. For example,
      the time interval T may need to be made longer if the packet rate is
      very low. Implementers and testers are invited to document their
      findings in an Internet-Draft.</t>
     </section>
     
    <section anchor="IANA" title="IANA Considerations">
      <t>This document has no IANA actions.</t>

     </section>

    <section anchor="Security" title="Security Considerations">

      <t>The security considerations of <xref target="RFC3550">RFC
      3550</xref>, <xref target="RFC4585">RFC 4585</xref>, and <xref
      target="RFC5124">RFC 5124</xref> are
      expected to apply.</t>
      
      <t>Non-authenticated RTCP packets carrying OWD measurements, shared
      bottleneck indications, and/or summary statistics could allow attackers
      to alter the bottleneck-sharing characteristics for private gain or
      disruption of other parties' communication. When using SBD for coupled
      congestion control as described in <xref target="RTP-COUPLED-CC"/>,
      the security considerations of <xref target="RTP-COUPLED-CC"/> apply.</t>
    </section>

  </middle>

  <back>

    <references title="Normative References">

      &RFC2119;
      &RFC8174;

    </references> 

    <references title="Informative References">

      &RFC3550;
      &RFC4585;
      &RFC5124;
      &RFC6817;
      &RFC7679;
      &RFC7680;

<!-- draft-ietf-rmcat-coupled-cc (MISSREF) -->
<reference anchor='RTP-COUPLED-CC'>
<front>
<title>Coupled congestion control for RTP media</title>
<author initials='S' surname='Islam' fullname='Safiqul Islam'>
    <organization />
</author>
<author initials='M' surname='Welzl' fullname='Michael Welzl'>
    <organization />
</author>
<author initials='S' surname='Gjessing' fullname='Stein Gjessing'>
    <organization />
</author>
<date month='September' year='2017' />
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-rmcat-coupled-cc-07'/>
</reference>

<!-- draft-ietf-avtcore-cc-feedback-message (I-D Exists) -->
<reference anchor='RTCP-CC-FEEDBACK'>
<front>
<title>RTP Control Protocol (RTCP) Feedback for Congestion Control</title>
<author initials='Z' surname='Sarker' fullname='Zaheduzzaman Sarker'>
    <organization />
</author>
<author initials='C' surname='Perkins' fullname='Colin Perkins'>
    <organization />
</author>
<author initials='V' surname='Singh' fullname='Varun Singh'>
    <organization />
</author>
<author initials='M' surname='Ramalho' fullname='Michael Ramalho'>
    <organization />
</author>
<date month='March' year='2018'/>
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-avtcore-cc-feedback-message-01'/>
</reference>

      <reference anchor="Hayes-LCN14"
                 target="http://heim.ifi.uio.no/davihay/hayes14__pract_passiv_shared_bottl_detec-abstract.html">
        <front>
          <title>Practical Passive Shared Bottleneck Detection using Shape Summary Statistics</title>
          <author initials="D. A." surname="Hayes">
            <organization>University of Oslo</organization>
          </author>
          <author initials="S." surname="Ferlin">
            <organization>Simula Research Laboratory</organization>
          </author>
          <author initials="M." surname="Welzl">
            <organization>University of Oslo</organization>
          </author>
          <date year="2014" month="September"/>
        </front>
         <seriesInfo name="Proc. IEEE Local Computer Networks
                         (LCN)," value="pp. 150-158"/>
         <seriesInfo name="DOI" value="10.1109/LCN.2014.6925767"/>
      </reference>

     <reference anchor="Zhang-Infocom02">
        <front>
          <title>Clock synchronization algorithms for network measurements</title>
          <author initials="L." surname="Zhang">
           <organization>IBM T. J. Watson Research Center</organization>
          </author>
          <author initials="Z." surname="Liu">
          </author>
          <author initials="H." surname="Xia">
          </author>
          <date year="2002" month="September"/>
        </front>
         <seriesInfo name="Proc. IEEE International Conference on
 Computer Communications (INFOCOM)," value="pp. 160-169"/>
         <seriesInfo name="DOI" value="10.1109/INFCOM.2002.1019257"/>
      </reference>

    </references>

     <section anchor="Acknowledgments" title="Acknowledgments" numbered="no">
       <t>This work was partially funded by the
       European Community under its Seventh Framework Programme through
       the Reducing Internet Transport Latency (RITE) project
       (ICT-317700). The views expressed are solely those of the
       authors.</t>
     </section>

  </back>

</rfc>
