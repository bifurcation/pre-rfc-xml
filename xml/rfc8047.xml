<?xml version="1.0" encoding="US-ASCII" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY RFC2119 PUBLIC '' 'reference.RFC.2119.xml'>
<!ENTITY RFC3552 PUBLIC '' 'reference.RFC.3552.xml'>
<!ENTITY RFC4218 PUBLIC '' 'reference.RFC.4218.xml' >
<!ENTITY RFC4225 PUBLIC '' 'reference.RFC.4225.xml' >
<!ENTITY RFC4303 PUBLIC '' 'reference.RFC.4303.xml' >
<!ENTITY RFC6724 PUBLIC '' 'reference.RFC.6724.xml' >
<!ENTITY RFC7401 PUBLIC '' 'reference.RFC.7401.xml' >
<!ENTITY RFC7402 PUBLIC '' 'reference.RFC.7402.xml' >
<!ENTITY RFC5533 PUBLIC '' 'reference.RFC.5533.xml' >
]>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>

<rfc number="8047" category="std" ipr="trust200902" submissionType="IETF" consensus="yes">

<front>
  <title abbrev="HIP Multihoming">
    Host Multihoming with the Host Identity Protocol
  </title>

  <author initials="T." surname="Henderson"
    fullname="Thomas R. Henderson" role="editor">
     <organization>University of Washington</organization>
     <address>
       <postal>
         <street>Campus Box 352500</street>
         <city>Seattle</city>
         <region>WA</region>
         <country>United States of America</country>
       </postal>
       <email>tomhend@u.washington.edu</email>
     </address>
  </author>

  <author initials="C." surname="Vogt"
    fullname="Christian Vogt">
    <organization>Independent</organization>
    <address>
      <postal>
        <street>3473 North First Street </street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95134</code>
        <country>United States of America</country>
      </postal>
      <phone />
      <email>mail@christianvogt.net</email>
    </address>
  </author>

  <author initials="J." surname="Arkko"
    fullname="Jari Arkko">
    <organization>Ericsson</organization>
    <address>
      <postal>
        <street />
        <city>Jorvas,</city>
        <code>FIN-02420</code>
        <country>Finland</country>
      </postal>
      <phone>+358 40 5079256</phone>
      <email>jari.arkko@piuha.net</email>
    </address>
  </author>
    <date month="February" year="2017"/>
    
    <area>Internet</area>


    <abstract>
      <t> This document defines host multihoming extensions to
          the Host Identity Protocol (HIP), by leveraging protocol 
          components defined for host mobility.  
      </t>
    </abstract>

  </front>

  <middle>

    <section title="Introduction and Scope">

      <t> The <xref target="RFC7401">Host Identity
      Protocol (HIP) </xref> supports an architecture that decouples the
      transport layer (TCP, UDP, etc.) from the internetworking layer
      (IPv4 and IPv6) by using public/private 
      key pairs, instead of IP addresses, as host identities.  When a host 
      uses HIP, the overlying protocol sublayers
      (e.g., transport-layer sockets and Encapsulating Security
      Payload (ESP) Security Associations (SAs)) are 
      instead bound to representations of these host identities, and the 
      IP addresses are only used for packet forwarding.  However, each host 
      must also know at least one IP address at which its peers are reachable.
      Initially, these IP addresses are the ones used during the HIP
      base exchange.</t>

      <t> One consequence of such a decoupling is that new solutions to
      network-layer mobility and host multihoming are possible.  
      Basic host mobility is defined in 
      <xref target="RFC8046" /> and covers
      the case in which a host has a single address and changes its
      network point of attachment while desiring to preserve the 
      HIP-enabled security association.  Host multihoming is somewhat
      of a dual case to host mobility, in that, a host may simultaneously
      have more than one network point of attachment.   
      There are potentially many variations of host multihoming 
      possible.  <xref target="RFC8046" /> 
      specifies the format of the HIP parameter (LOCATOR_SET parameter)
      used to convey IP addressing information between peers, the
      procedures for sending and processing this parameter to enable basic
      host mobility, and procedures for an address verification
      mechanism.  The scope of this document encompasses messaging
      and elements of procedure for some basic host multihoming
      scenarios of interest.  
      </t>

      <t> Another variation of multihoming that has been heavily studied
      is site multihoming.  Solutions for host multihoming in multihomed 
      IPv6 networks have been specified by the IETF shim6 working group.
      The <xref target="RFC5533">Shim6 protocol</xref> bears many 
      architectural similarities to HIP, but there are differences in 
      the security model and in the protocol.  
      </t>

      <t>While HIP can potentially be used with transports other than
      the <xref target="RFC7402">ESP transport format</xref>,
      this document largely assumes the use of ESP and leaves other
      transport formats for further study.</t>

      <t> Finally, making underlying 
      IP multihoming transparent to 
      the transport layer has implications on the proper response of
      transport congestion control, path MTU selection, and Quality of
      Service (QoS).
      Transport-layer mobility triggers, and the proper transport
      response to a HIP multihoming address change,
      are outside the scope of this document.</t>

      <t> This specification relies on implementing Sections 4 
      ("LOCATOR_SET Parameter Format") and 5 ("Processing Rules") of
      <xref target="RFC8046" /> as a starting point for this
      implementation.</t>

    </section>

    <section title="Terminology and Conventions">

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described
      in <xref target="RFC2119">RFC 2119</xref>.</t>

      <t>
      The following terms used in this document are defined in <xref target="RFC8046" />:  LOCATOR_SET, Locator, locator, Address, preferred locator, 
and Credit-Based Authorization.
      </t>

    </section>

    <section anchor="sec.protocol.model" title="Protocol Model">
      <t> The protocol model for HIP support of host multihoming extends the
      model for host mobility described in Section 3 of 
      <xref target="RFC8046" />.  This section only highlights
      the differences.</t>
    
      <t> In host multihoming, 
      a host has multiple locators simultaneously rather than sequentially,
      as in the case of mobility.  By using the LOCATOR_SET parameter defined 
      in <xref target="RFC8046" />,
      a host can inform its peers of additional (multiple) locators at which 
      it can be reached.  When multiple locators are available and announced
      to the peer, a host can designate a particular locator as a "preferred"
      locator, meaning that the host prefers that its peer send packets to
      the designated address before trying an alternative address.
      Although this document defines a basic mechanism for multihoming,
      it does not define all possible policies and procedures, such as 
      which locators to choose when more than one is available, the 
      operation of simultaneous mobility and multihoming, source address 
      selection policies 
      (beyond those specified in <xref target="RFC6724" />), 
      and the implications of multihoming on transport protocols.
      </t> 

      </section>

      <section anchor="sec.protocol.overview" title="Protocol Overview"> 

      <t>In this section, we briefly introduce a number of usage
      scenarios for HIP multihoming.
      These scenarios assume that HIP is being used with the 
      <xref target="RFC7402">ESP transport</xref>,
      although other scenarios may be defined in the
      future.  To understand these usage scenarios, the reader should
      be at least minimally familiar with the <xref
      target="RFC7401">HIP protocol specification</xref>, the use of the
      <xref target="RFC7402">ESP transport format</xref>, and the <xref
      target="RFC8046">HIP mobility specification</xref>.
      However, for the (relatively) uninitiated reader, it is most
      important to keep in mind that in HIP, the actual payload traffic
      is protected with ESP, and that the ESP Security Parameter Index (SPI)
      acts as an index to the right host-to-host context.  </t>

      <section anchor="background" title="Background">
      <t> The multihoming scenarios can be explained in contrast to the
      non-multihoming case described in the base protocol specification <xref target="RFC7401" />.
      We review the pertinent details here.  In the base specification,
      when used with the ESP transport format, the HIP base exchange will
      set up a single SA in each direction.  The IP addresses associated
      with the SAs are the same as those used to convey the HIP packets.
      For data traffic, a security policy database (SPD) and security
      association database (SAD) will likely exist, following the IPsec
      architecture.  One distinction between HIP and IPsec, however, is that
      the host IDs, and not the IP addresses, are conceptually used as 
      selectors in the SPD.  In the outbound direction, as a result of
      SPD processing, when an outbound SA is selected, the correct IP 
      destination address for the peer must also be assigned.  Therefore,
      outbound SAs are conceptually associated with the peer IP address
      that must be used as the destination IP address below the HIP layer.
      In the inbound direction, the IP addresses may be used as selectors
      in the SAD to look up the SA, but they are not strictly required;
      the ESP SPI may be used alone.  To summarize, in the non-multihoming 
      case, there is only one source IP address, one destination IP address,
      one inbound SA, and one outbound SA. </t>

      <t>The <xref target="RFC8046">HIP readdressing 
      protocol</xref> is an asymmetric protocol in which a mobile or 
      multihomed host informs a peer host
      about changes of IP addresses on affected SPIs.  
      IP address and ESP SPI information is carried in Locator fields
      in a HIP parameter called a LOCATOR_SET.
      The <xref target="RFC8046">HIP mobility
      specification</xref> describes how the LOCATOR_SET is carried in 
      a HIP UPDATE packet.</t>

      <t>To summarize the mobility elements of procedure, as background
      for multihoming, the basic idea of host mobility is to communicate
      a local IP address change to the peer when active HIP-maintained
      SAs are in use.  To do so, the IP address must be conveyed, any
      association between the IP address and an inbound SA (via the SPI 
      index) may be conveyed,
      and protection against flooding attacks must be ensured.  The
      association of an IP address with an SPI is performed by a Locator Type
      of "1", which is a concatenation of an ESP SPI with an IP address.
      </t>

        <t> An address verification method is specified in
        <xref target="RFC8046" />.  It is expected that
        addresses learned in multihoming scenarios also are subject to
        the same verification rules.
      At times, the scenarios describe addresses as being in either
      an ACTIVE, VERIFIED, or DEPRECATED state.  From the perspective of
      a host, newly learned addresses of the peer must be verified
      before put into active service, and addresses removed by the peer
      are put into a deprecated state.  Under limited conditions described
      in <xref target="RFC8046" />, an UNVERIFIED address 
      may be used. </t> 
 
      <t>With this background, we next describe an additional protocol to
      facilitate scenarios in which one or both hosts have multiple
      IP addresses available.  Increasingly, this is the common case
      with network-connected hosts on the Internet.</t>

      </section>
    <section anchor="sec.overview.usage" title="Usage Scenarios">
      <section anchor="sec.overview.addresses" title="Multiple Addresses">
 
      <t> Hosts may have multiple IP addresses within different address
      families (IPv4 and IPv6) and scopes
      available to support HIP messaging and HIP-enabled SAs.  The multiple
      addresses may be on a single network interface or multiple network interfaces.  It is
      outside of the scope of this document to specify how a host decides
      which of possibly multiple addresses may be used to support
      a HIP association.  Some IP addresses may be held back from usage
      due to privacy, security, or cost considerations.</t>

      <t> When multiple IP addresses are shared with a peer, the procedures
      described in the <xref target="RFC8046">HIP 
      mobility specification</xref> allow for a host to set a preferred
      locator ("P") bit, requesting that one of the multiple addresses be preferred for
      control- or data-plane traffic.  It is also permitted to leave
      the preferred bit unset for all addresses, allowing the peer to
      make address selection decisions.</t>
         
      <t> Hosts that use link-local addresses as source addresses
      in their HIP handshakes may not be reachable by a mobile peer.
      Such hosts SHOULD provide a globally routable address either in
      the initial handshake or via the LOCATOR_SET parameter.
      </t>

      <t> To support mobility, as described in the
      <xref target="RFC8046">HIP mobility 
      specification</xref>, the LOCATOR_SET may be sent in a HIP UPDATE
      packet.  To support multihoming, the LOCATOR_SET may also be sent
      in R1, I2, or R2 packets defined in the <xref target="RFC7401">HIP
      protocol specification</xref>. The reason to consider sending
      LOCATOR_SET parameters in base exchange packets is to convey
      all usable addresses for fault-tolerance or load-balancing 
      considerations. </t>

      </section>

      <section anchor="sec.overview.sas" title="Multiple Security Associations">
      <t>When multiple addresses are available between peer hosts, a 
      question that arises is whether to use one or multiple SAs. 
      The intent of this specification is to support different use
      cases but to leave the policy decision to the hosts.</t>

      <t> When one host has n addresses and the other host has m addresses,
      it is possible to set up as many as (n * m) SAs in each direction.
      In such a case, every combination of source and destination IP
      addresses would have a unique SA, and the possibility of the reordering
      of datagrams on each SA will be lessened (ESP SAs may have an 
      <xref target="RFC4303">anti-replay window</xref> 
      sensitive to reordering).  However, the downside to
      creating a mesh of SAs is the signaling overhead required (for
      exchanging UPDATE messages conveying ESP_INFO parameters) and the
      state maintenance required in the SPD/SAD. </t>

      <t>For load balancing, when multiple paths are to be used in 
      parallel, it may make sense to create different SAs for different
      paths.  In this use case, while a full mesh of 2 * (n * m) SAs 
      may not be required, it may be beneficial to create one SA pair per
      load-balanced path to avoid anti-replay window issues.</t>

      <t>For fault tolerance, it is more likely that a single SA 
      and multiple IP addresses associated with that SA can be used, and the
      alternative addresses can be used only upon failure detection of the
      addresses in use.  Techniques for path failure detection are 
      outside the scope of this specification.
	An implementation may use ICMP interactions, reachability
	checks, or other means to detect the failure of a locator. </t>

      <t>In summary, whether and how a host decides to leverage additional
      addresses in a load-balancing or fault-tolerant manner is outside
      the scope of the specification (although the academic literature 
      on multipath TCP schedulers may provide guidance on how to design
      such a policy).  However, in general, this document
      recommends that for fault tolerance, it is likely sufficient to use
      a single SA pair for all addresses, and for load balancing, to
      support a different SA pair for all active paths being balanced
      across.</t>

      </section>

      <section anchor="hostmhft" title="Host Multihoming for Fault Tolerance">

	    <t>A (mobile or stationary) host may have more than 
	    one interface or global address.  The host may choose to
      notify the peer host 
      of the additional interface or address by using the LOCATOR_SET 
      parameter.  The LOCATOR_SET parameter may be included in an I2, R1,
      or R2 packet, or it may be conveyed, after the base exchange completes
      in an UPDATE packet.</t>
        
	    <t> When more than one locator is provided to the peer host,
	    the host MAY indicate which locator is preferred 
            (the locator on which the host prefers to receive traffic).  
	    By default, the address that a host uses in the base exchange
            is its preferred locator (for the address family and address
            scope in use during the base exchange) until indicated otherwise.
            It may be the case
            that the host does not express any preferred locators.</t>

        <t> In the multihoming case, the sender may also have multiple
        valid locators from which to source traffic.  In practice,
        a HIP association in a multihoming configuration may have
        both a preferred peer locator and a preferred local locator.
        The host should try to use the peer's preferred locator unless
        policy or other circumstances prevent such usage.  A preferred
        local locator may be overridden if source address selection rules
        on the destination address (peer's preferred locator) suggest
        the use of a different source address.</t>

        <t>Although the protocol may allow for configurations
        in which there is an asymmetric number of SAs between the
        hosts (e.g., one host has two interfaces and two inbound
        SAs, while the peer has one interface and one inbound SA),
        it is suggested that inbound and outbound SAs be created
        pairwise between hosts.  When an ESP_INFO arrives to rekey a
        particular outbound SA, the corresponding inbound SA should also
        be rekeyed at that time.  <xref target="sec.interaction" />
        discusses the interaction between addresses and security 
        associations in more detail.</t>
	
	  <t>Consider the case of two hosts, one single-homed and
    one multihomed.  The multihomed host may decide to inform the 
    single-homed host about its other address(es).  It may choose to
    do so as follows.</t>

        <t>If the multihomed host wishes to convey the additional
        address(es) for fault tolerance, it should include all of its
        addresses in Locator fields, indicating the Traffic
        Type, Locator Type, and whether the locator is a preferred locator.
        If it wishes to bind any particular address to an existing SPI,
        it may do so by using a Locator Type of "1" as specified in
        the <xref target="RFC8046">HIP mobility 
        specification</xref>.  It does not need to rekey the existing SA
        or request additional SAs at this time.</t>

    <t><xref target="multi-home1" /> 
    illustrates this scenario.  Note that the
        conventions for message parameter notations in figures (use
        of parentheses and brackets) is defined in Section 2.2 of
        <xref target="RFC7401" />.

	  </t>

      <figure anchor="multi-home1" title="Basic Multihoming Scenario">
	<artwork>
  Multihomed Host                     Peer Host

           UPDATE(LOCATOR_SET, SEQ)
     -----------------------------------&gt;
           UPDATE(ACK)
     &lt;-----------------------------------
        </artwork>
      </figure>
    
     <t> In this scenario, the peer host associates the multiple addresses
         with the SA pair between it and the multihomed host.  It may
         also undergo address verification procedures to transition the
         addresses to ACTIVE state.  For inbound
         data traffic, it may choose to use the addresses along with the
         SPI as selectors.  For outbound data traffic, it must choose
         among the available addresses of the multihomed host, considering
         the state of <xref target="RFC8046">address
         verification</xref> of each address, and also 
         considering available information about whether an address is
         in a working state. </t>

      </section>

      <section anchor="hostmhlb" title="Host Multihoming for Load Balancing">

    <t> A multihomed host may decide to set up new SA pairs corresponding
    to new addresses, for the purpose of load balancing.  The decision to
    load balance and the mechanism for splitting load across multiple SAs
    is out of scope of this document.  The scenario can be supported by
    sending the LOCATOR_SET parameter with one or more ESP_INFO parameters
    to initiate new ESP SAs.  To do this, the multihomed host sends
	  a LOCATOR_SET with an ESP_INFO, indicating the request for a new SA
    by setting the OLD SPI value to zero and the NEW SPI
    value to the newly created incoming SPI.  A Locator Type of "1"
    is used to associate the new address with the new SPI.
    The LOCATOR_SET parameter also contains a second Type "1" Locator, that of
    the original address and SPI.  To simplify parameter processing
    and avoid explicit protocol extensions to remove locators, each
    LOCATOR_SET parameter MUST list all locators in use on a connection
    (a complete listing of inbound locators and SPIs for the host).
	  The multihomed host waits for a corresponding ESP_INFO 
    (new outbound SA) from the
	  peer and an ACK of its own UPDATE.  As in the mobility case,
	  the peer host must perform an address verification before actively
    using the new address. </t> 
    <t><xref target="multi-home1-lb" /> 
    illustrates this scenario.
	  </t>

      <figure anchor="multi-home1-lb" title="Host Multihoming for Load Balancing">
	<artwork>
  Multihomed Host                     Peer Host

           UPDATE(ESP_INFO, LOCATOR_SET, SEQ, [DIFFIE_HELLMAN])
     -----------------------------------&gt;
           UPDATE(ESP_INFO, SEQ, ACK, [DIFFIE_HELLMAN,] ECHO_REQUEST)  
     &lt;-----------------------------------
           UPDATE(ACK, ECHO_RESPONSE)
     -----------------------------------&gt;
        </artwork>
      </figure>
      
	  <t>In multihoming scenarios, it is important that hosts receiving
          UPDATEs associate them correctly with the destination address
          used in the packet carrying the UPDATE.  When processing 
          inbound LOCATOR_SETs that establish new security
	  associations on an interface with multiple addresses, a host uses 
          the destination address of the 
	  UPDATE containing the LOCATOR_SET as the local address to which the LOCATOR_SET
	  plus ESP_INFO is targeted.  This is because hosts may send 
          UPDATEs with the same (locator) IP address to different 
          peer addresses -- this has the effect of creating multiple 
          inbound SAs implicitly affiliated with
	  different peer source addresses. </t>

      </section>

      <section title="Site Multihoming">

	<t>A host may have an interface that has multiple globally
	routable IP addresses.  Such a situation may be a result of
	the site having multiple upper Internet Service Providers, or
	just because the site provides all hosts with both IPv4 and
	IPv6 addresses.  The host should stay reachable at all or any
subset of the currently available global routable addresses,
independent of how they are provided.
	</t>

	<t>This case is handled the same as if there were different
        IP addresses, described above in Sections <xref target="hostmhft" format="counter"/>  
        and <xref target="hostmhlb" format="counter"/>.  
	Note that a single interface may have addresses corresponding to site
	multihoming while the host itself may also have multiple network
	interfaces.</t>

	<t>Note that a host may be multihomed and mobile
	simultaneously, and that a multihomed host may want to
	protect the location of some of its interfaces while revealing
	the real IP address of some others.</t>

	<t>This document does not present additional site
	multihoming extensions to HIP; such extensions are for further
        study.  </t>
      </section>

      <section title="Dual-Host Multihoming">
	<t>Consider the case in which both hosts are multihomed and would 
        like to notify the peer of
	an additional address after the base exchange completes.
        It may be the case that both hosts choose to simply announce the
        second address in a LOCATOR_SET parameter using an UPDATE
        message exchange.  It may also be the case that one or both
        hosts decide to ask for new SA pairs to be created using the newly
        announced address.  In the case that both hosts request this, 
        the result will be a full mesh of SAs as depicted in 
	<xref target="dual-host-mh" />.  In such a scenario, consider 
        that host1, which
        used address addr1a in the base exchange to set up SPI1a and SPI2a,
	wants to add address addr1b.  It would send an UPDATE with LOCATOR_SET 
        (containing the address addr1b) to host2, using destination
        address addr2a, and a new ESP_INFO, and a new set of SPIs would be added
	between hosts 1 and 2 (call them SPI1b and SPI2b; not shown
        in the figure).  Next,
	consider host2 deciding to add addr2b to the relationship.
	Host2 must select one of host1's addresses towards which to
	initiate an UPDATE.  It may choose to initiate an UPDATE to
	addr1a, addr1b, or both.  If it chooses to send to both,
	then a full mesh (four SA pairs) of SAs would exist between
	the two hosts.  This is the most general case; the
	protocol is flexible enough to accommodate this choice. </t>

       <figure anchor="dual-host-mh"  title="Dual-Multihoming Case in
        which Each Host Uses LOCATOR_SET to Add a Second Address">
        <artwork>           
           -&lt;- SPI1a --                         -- SPI2a ->-
   host1 &lt;              > addr1a &lt;---> addr2a &lt;              > host2
           ->- SPI2a --                         -- SPI1a -&lt;-

                          addr1b &lt;---> addr2a  (second SA pair)   
                          addr1a &lt;---> addr2b  (third SA pair)               
                          addr1b &lt;---> addr2b  (fourth SA pair)             
        </artwork>
       </figure>

      </section>

      <section title="Combined Mobility and Multihoming">

	<t>Mobile hosts may
	be simultaneously mobile and multihomed, i.e., have multiple
	mobile interfaces.  Furthermore, if the interfaces use
	different access technologies, it is fairly likely that one of
	the interfaces may appear stable (retain its current IP
	address) while some others may experience mobility (undergo
	IP address change).</t>

	<t>The use of LOCATOR_SET plus ESP_INFO should be flexible enough to 
	handle most such scenarios, although more complicated scenarios
	have not been studied so far. </t>

      </section>

      <section title="Initiating the Protocol in R1, I2, or R2">

	<t>A Responder host MAY include a LOCATOR_SET parameter in
	the R1 packet that it sends to the Initiator.  This
	parameter MUST be protected by the R1 signature.  If the R1
	packet contains LOCATOR_SET parameters with a new preferred locator, 
        the Initiator SHOULD directly set the new preferred locator to
        status ACTIVE without performing address verification first, and 
        it MUST send the I2 packet to the new preferred locator.
	The I1 destination address and the new
	preferred locator may be identical.  All new non-preferred locators
        must still undergo address verification once the base exchange
        completes.  It is also possible for the host to send the LOCATOR_SET
        without any preferred bits set, in which case the exchange will
        continue as normal and the newly learned addresses will be in an
        UNVERIFIED state at the initiator.</t>

	<figure anchor="figure-protocol-over-R1" title="LOCATOR_SET Inclusion in R1">
	  <artwork>
         Initiator                                Responder

                           R1 with LOCATOR_SET
               &lt;-----------------------------------
record additional addresses
change Responder address
                  I2 sent to newly indicated preferred address
               -----------------------------------&gt;
                                                  (process normally)
                               R2 
               &lt;-----------------------------------
(process normally, later verification of non-preferred locators)
          </artwork>
	</figure>

	<t>An Initiator MAY include one or more LOCATOR_SET parameters in the
	I2 packet, independent of whether or not there was a LOCATOR_SET parameter
	in the R1.  These parameters MUST be protected by the
	I2 signature.  Even if the I2 packet contains LOCATOR_SET parameters,
	the Responder MUST still send the R2 packet to the source
	address of the I2.  The new preferred locator, if set, SHOULD be
	identical to the I2 source address.  If the I2 packet contains 
  LOCATOR_SET parameters, all new locators must undergo address verification
  as usual, and the ESP traffic that subsequently follows should use
  the preferred locator.  </t>

	<figure anchor="figure-protocol-over-I2" title="LOCATOR_SET Inclusion in I2">
	  <artwork>
         Initiator                                Responder

                          I2 with LOCATOR_SET
               -----------------------------------&gt;
                                                  (process normally)
                                          record additional addresses
                    R2 sent to source address of I2
               &lt;-----------------------------------
(process normally)
          </artwork>
	</figure>


     <t> The I1 and I2 may be arriving from different source addresses 
         if the LOCATOR_SET parameter is present in R1. In this case, 
         implementations simultaneously using multiple pre-created R1s,
         indexed by Initiator IP addresses, may inadvertently fail the 
         puzzle solution of I2 packets due to a perceived puzzle mismatch.
         See, for instance, the example in Appendix A of 
         <xref target="RFC7401" />.
         As a solution, the Responder's puzzle indexing mechanism must be 
         flexible enough to accommodate the situation when R1
         includes a LOCATOR_SET parameter.
     </t>

     <t> Finally, the R2 may be used to carry the LOCATOR_SET parameter.
         In this case, the LOCATOR_SET is covered by the HIP_MAC_2 and
         HIP_SIGNATURE. Including LOCATOR_SET in R2 as opposed to R1
         may have some advantages when a host prefers not to divulge
         additional locators until after the I2 is successfully processed.
    </t>
        <t> When the LOCATOR_SET parameter is sent in an UPDATE packet, the
        receiver will respond with an UPDATE acknowledgment.  When the
        LOCATOR_SET parameter is sent in an R1, I2, or R2 packet, the base exchange
        retransmission mechanism will confirm its successful delivery.</t>  
      </section>

      <section title="Using LOCATOR_SETs across Addressing Realms">
	<t>It is possible for HIP associations to use these mechanisms
     to migrate their HIP associations and security associations from
     addresses in the IPv4 addressing realm to IPv6, or vice versa.
     It may be possible for a state to arise in which 
     both hosts are only using locators in different
     addressing realms, but in such a case, some type of mechanism for
     interworking between the different realms must be employed;
     such techniques are outside the scope of the present text.
</t>
      </section>
    </section>

      <section anchor="sec.interaction" title="Interaction with Security Associations">

	<t>A host may establish any number of security associations
        (or SPIs) with a peer.  The main purpose of having multiple
        SPIs with a peer is to group the addresses into collections that
	are likely to experience fate sharing, or to perform load
        balancing. </t>  

	<t>A basic property of HIP SAs is that the inbound IP address
        is not used to look up the incoming SA.  
        However, the use of different source
	and destination addresses typically leads to different paths,
        with different latencies in the network, and if packets were
        to arrive via an arbitrary destination IP address (or path)
        for a given SPI, the reordering due to different latencies
	may cause some packets to fall outside of the ESP 
	anti-replay window.  For this reason, HIP provides a mechanism to
        affiliate destination addresses with inbound SPIs, when there
        is a concern that anti-replay windows might be violated.
	In this sense, we can say that a given inbound SPI has an 
	"affinity" for certain inbound IP addresses, and this affinity 
	is communicated to the peer host.  Each physical interface
        SHOULD have a separate SA, unless the ESP anti-replay window
        is extended or disabled.</t>

	<t>Moreover, even when the destination addresses used for a
        particular SPI are held constant, the use of different 
        source interfaces may also cause packets to fall outside of
        the ESP anti-replay window, since the path traversed is often
        affected by the source address or interface used.  A host 
        has no way to influence the source interface on which a peer 
        sends its packets on a given SPI.  A host SHOULD 
        consistently use the same source interface and address when 
        sending to a 
        particular destination IP address and SPI.  For this reason, 
	a host may find it useful to change its SPI or at least reset 
	its ESP anti-replay window when the peer host readdresses.</t>

      </section>

    </section>

    <section anchor="sec.processing.rules" title="Processing Rules">
 
      <t> Basic processing rules for the LOCATOR_SET parameter are specified 
      in <xref target="RFC8046" />.  This document focuses
      on multihoming-specific rules.  </t>

      <section anchor="sending-locators" title="Sending LOCATOR_SETs">

	<t>The decision of when to send a LOCATOR_SET, and which addresses
        to include, is a local policy issue. 
        <xref target="RFC8046" /> recommends that a host
        "send a LOCATOR_SET whenever it recognizes a change of its IP 
        addresses in use on an active HIP association and [when it] 
        assumes that the change is going to last at least for a few 
        seconds."
        It is possible to delay the exposure of additional locators to the
        peer, and to send data from previously unannounced locators, as
        might arise in certain mobility or multihoming situations.</t>

	<t>When a host decides to inform its peers about changes in its
	IP addresses, it has to decide how to group the various
	addresses with SPIs.  If hosts are deployed in an operational 
        environment in which HIP-aware NATs and firewalls (that may 
        perform parameter inspection) exist, and different such devices 
        may exist on different paths, hosts may take that knowledge into 
        consideration about how addresses are grouped, and may send 
        the same LOCATOR_SET in separate UPDATEs on the different paths.  
        However, more detailed guidelines about how to operate in the 
        presence of such HIP-aware NATs and firewalls are a topic for 
        further study.  Since each SPI is associated with
	a different security association, the grouping policy may also be
	based on ESP anti-replay protection considerations.  In the typical
	case, simply basing the grouping on actual kernel-level physical
	and logical interfaces may be the best policy.  The grouping policy
        is outside of the scope of this document.</t>

	<t>Locators corresponding to tunnel interfaces (e.g., IPsec tunnel
        interfaces or Mobile IP home addresses) or other virtual interfaces
        MAY be announced in a LOCATOR_SET, but implementations SHOULD
        avoid announcing such locators as preferred locators if more
        direct paths may be obtained by instead preferring locators from
        non-tunneling interfaces if such locators provide a more 
        direct path to the HIP peer. </t>  

        <t> <xref target="RFC8046" /> specifies that hosts MUST NOT 
        announce broadcast or multicast addresses in LOCATOR_SETs.  
        Link-local addresses MAY be announced to 
        peers that are known to be neighbors on the same link, such as 
        when the IP destination address of a peer is also link local.  
        The announcement of link-local addresses in this case is a 
        policy decision; link-local addresses used as preferred locators 
        will create reachability problems when the host moves to 
        another link.  In any case, link-local addresses MUST NOT
        be announced to a peer unless that peer is known to be on the same
        link. </t>

	<t>Once the host has decided on the groups and assignment of
	addresses to the SPIs, it creates a LOCATOR_SET parameter that serves
  as a complete representation of the addresses and associated SPIs
  intended for active use.
	We now describe a few cases introduced in 
  <xref target="sec.protocol.overview" />.  We assume that the
  Traffic Type for each locator is set to "0" (other values for Traffic
  Type may be specified in documents that separate the HIP control plane from
  data-plane traffic).  Other mobility and
  multihoming cases are possible but are left for further experimentation.
	  <list style="numbers">

    <t>Host multihoming (addition of an address).  We only describe the
       simple case of adding an additional address to a (previously) 
       single-homed, non-mobile host.  The host MAY choose to simply 
       announce this address to the peer, for fault tolerance.  
       To do this, the multihomed host creates a LOCATOR_SET parameter
       including the existing address and SPI as a Type "1" Locator, and
       the new address as a Type "0" Locator.  The host sends this
       in an UPDATE message with the SEQ parameter, which is acknowledged
       by the peer.
    </t>

    <t> The host MAY set up a new SA pair between
       this new address and an address of the peer host.
       To do this, the multihomed host creates a new inbound SA and 
       creates a new SPI. For the outgoing UPDATE message, it inserts 
       an ESP_INFO parameter
       with an OLD SPI field of "0", a NEW SPI field 
       corresponding to the new
       SPI, and a KEYMAT Index as selected by local policy.
       The host adds 
       to the UPDATE message a LOCATOR_SET with two Type "1" Locators:  the 
       original address and SPI active on the association, and the
       new address and new SPI being added (with the 
       SPI matching the NEW SPI contained in the ESP_INFO).  The preferred
       bit SHOULD be set depending on the policy to tell the peer host
       which of the two locators is preferred.  The UPDATE also contains
       a SEQ parameter and optionally a DIFFIE_HELLMAN parameter
       and follows rekeying procedures with respect to this new address.
       The UPDATE message SHOULD be sent to the peer's preferred
       address with a source address corresponding to the new locator.
       </t>

    </list>
  </t>

  <t> The sending of multiple LOCATOR_SETs is unsupported.  Note
      that the inclusion of LOCATOR_SET in an R1 packet requires the use
      of Type "0" Locators since no SAs are set up at that point.</t>

      </section>  

      <section anchor="receiving-locators" title="Handling Received LOCATOR_SETs"> 

	<t>A host SHOULD be prepared to receive a LOCATOR_SET parameter in 
        the following HIP packets:  R1, I2, R2, and UPDATE.  </t>

  <t>  This document describes sending both ESP_INFO and LOCATOR_SET parameters
       in an UPDATE.  The ESP_INFO parameter is included when there is a
       need to rekey or key a new SPI and can otherwise be included for the
       possible benefit of HIP-aware middleboxes.  The LOCATOR_SET parameter
       contains a complete map of the locators that the host wishes to
       make or keep active for the HIP association. </t>

	<t> In general, the processing of a LOCATOR_SET depends upon the 
         packet type in which it is included.
         Here, we describe only the case in which ESP_INFO is present and a 
         single LOCATOR_SET and ESP_INFO are sent in an UPDATE message; other
         cases are for further study.  The steps below cover each of the
         cases described in <xref target="sending-locators" />.
         </t>

      <t> The processing of ESP_INFO and LOCATOR_SET parameters is intended to be
          modular and support future generalization to the inclusion of
          multiple ESP_INFO and/or multiple LOCATOR_SET parameters.  A host
          SHOULD first process the ESP_INFO before the LOCATOR_SET, since the
          ESP_INFO may contain a new SPI value mapped to an existing SPI,
          while a Type "1" Locator will only contain a reference to the new SPI.
      </t>

	<t> When a host receives a validated HIP UPDATE with a LOCATOR_SET
        and ESP_INFO parameter, it processes the ESP_INFO as follows.
	 The ESP_INFO parameter indicates whether an SA is being
            rekeyed, created, deprecated, or just identified for the
            benefit of middleboxes.  The host examines the  
            OLD SPI and NEW SPI values in the ESP_INFO parameter:

	  <list style="numbers">

         <t> (no rekeying) If the 
             OLD SPI is equal to the NEW SPI and both correspond to an
             existing SPI, the ESP_INFO is gratuitous (provided for 
             middleboxes), and no rekeying is necessary.  </t>
         <t> (rekeying) If the OLD SPI indicates an existing SPI and 
             the NEW SPI is
             a different non-zero value, the existing SA is being rekeyed
             and the host follows HIP ESP rekeying procedures by
             creating a new outbound SA with an SPI corresponding to the
             NEW SPI, with no addresses bound to this SPI.  Note that
             locators in the LOCATOR_SET parameter will reference this 
             new SPI instead of the old SPI.</t>
         <t> (new SA) If the OLD SPI value is zero and the 
             NEW SPI is a new non-zero
             value, then a new SA is being requested by the peer.  This case
             is also treated like a rekeying event; the receiving host
             must create a new SA and respond with an UPDATE ACK. </t>
         <t> (deprecating the SA) 
             If the OLD SPI indicates an existing SPI and the NEW SPI is
             zero, the SA is being deprecated and all locators uniquely
             bound to the SPI are put into the DEPRECATED state. </t>
         </list>
         </t>
         <t> If none of the above cases apply, a protocol error has 
             occurred and the processing of the UPDATE is stopped.</t>

	    <t>Next, the locators in the LOCATOR_SET parameter are processed.
            For each locator listed in the LOCATOR_SET parameter, check
	    that the address therein is a legal unicast or anycast address.
	    That is, the address MUST NOT be a broadcast or multicast
	    address.  Note that some implementations MAY accept
	    addresses that indicate the local host, since it may be
	    allowed that the host runs HIP with itself.</t>

            <t>For each Type "1" address listed in the LOCATOR_SET parameter, 
            the host checks whether the address is already bound 
            to the SPI indicated.  
            If the address is already bound, its lifetime is updated.  If the
            status of the address is DEPRECATED, the status is changed
            to UNVERIFIED.  If the address is not already bound, the address
            is added, and its status is set to UNVERIFIED.
            If there exist remaining addresses corresponding to the SPI that
            were NOT listed in the LOCATOR_SET parameter, the host sets
            the status of such addresses to DEPRECATED.
            </t>
            <t>
            For each Type "0" address listed in the LOCATOR_SET parameter,
            if the status of the address is DEPRECATED, or the address was
            not previously known, the status is changed to UNVERIFIED.
            The host MAY choose to associate this address with one or more
            SAs.  The association with different SAs is a local policy 
            decision, unless the peer has indicated that the address is
            preferred, in which case the address should be put into use
            on an SA that is prioritized in the security policy database.
            </t>
         
            <t>
            As a result, at the end of processing, the addresses listed 
            in the LOCATOR_SET parameter have a state of either UNVERIFIED 
            or ACTIVE, and any old addresses on the old SA not listed in the
            LOCATOR_SET parameter have a state of DEPRECATED.</t>


	<t>Once the host has processed the locators, if the LOCATOR_SET
	parameter contains a new preferred locator, the host SHOULD
	initiate a change of the preferred locator.  This
	requires that the host first verifies reachability of the associated
	address and only then changes the preferred locator; see
        <xref target="sec-change" />.</t>

            <t> If a host receives a locator with an unsupported Locator
            Type, and when such a locator is also declared to be the preferred
            locator for the peer, the host SHOULD send a NOTIFY error
            with a Notify Message Type of LOCATOR_TYPE_UNSUPPORTED,
            with the Notification Data field containing the locator(s)
            that the receiver failed to process.  Otherwise, a host
            MAY send a NOTIFY error if a (non-preferred) locator with
            an unsupported Locator Type is received in a LOCATOR_SET parameter.
            </t>

      </section>  

      <section anchor="sec-reach" title="Verifying Address Reachability">

	<t>Address verification is defined in
        <xref target="RFC8046" />.
        </t>

<t>
When address verification is in progress for a new preferred locator,
the host SHOULD select a different locator listed as ACTIVE, if one such
locator is available, to continue communications until address
verification completes.  Alternatively, the host MAY use the new
preferred locator while in UNVERIFIED status to the extent Credit-Based
Authorization permits.  Credit-Based Authorization is explained in
<xref target="RFC8046" />.
Once address verification succeeds, the status of the new
preferred locator changes to ACTIVE.
</t>

      </section>

      <section anchor="sec-change" title="Changing the Preferred Locator">

	<t>A host MAY want to change the preferred outgoing locator
	for different reasons, e.g., because traffic information or ICMP
	error messages indicate that the currently used preferred
	address may have become unreachable.  Another reason may be due to 
	receiving a LOCATOR_SET parameter that has the preferred bit set.</t>


	    

	<t>To change the preferred locator, the host initiates the
	following procedure:

	  <list style="numbers">

	    <t>If the new preferred locator has ACTIVE status, the
	    preferred locator is changed and the procedure succeeds.</t>

      <t>If the new preferred locator has UNVERIFIED status, the host
        starts to verify its reachability.  The host SHOULD use a
        different locator listed as ACTIVE until address verification
        completes if one such locator is available.  Alternatively, the
        host MAY use the new preferred locator, even though in UNVERIFIED
        status, to the extent Credit-Based Authorization permits.  Once
        address verification succeeds, the status of the new preferred
        locator changes to ACTIVE, and its use is no longer governed by
        Credit-Based Authorization. </t>

	    <t>If the peer host has not indicated a preference for any
	    address, then the host picks one of the peer's ACTIVE 
	    addresses randomly or according to policy.  This case may
	    arise if, for example, ICMP error messages that deprecate
	    the preferred locator arrive, but the peer has not yet indicated
	    a new preferred locator. </t>

      <t>  If the new preferred locator has DEPRECATED status and there is
        at least one non-deprecated address, the host selects one of the
        non-deprecated addresses as a new preferred locator and
        continues.  If the selected address is UNVERIFIED, the address
verification procedure described above will apply.
      </t>

	  </list>
	</t>

      </section>

    </section>

    <section title="Security Considerations">

       <t> This document extends the scope of host mobility solutions 
       defined in <xref target="RFC8046" /> to also include 
       host multihoming, and as a result, many of the same 
       security considerations for mobility also pertain to multihoming.
       In particular, <xref target="RFC8046" /> 
       describes how HIP host mobility is resistant to different types
       of impersonation attacks and denial-of-service (DoS) attacks.
       </t>

       <t> The security considerations for this document are similar
       to those of <xref target="RFC8046" /> because
       the strong authentication capabilities for mobility also carry
       over to end-host multihoming.  <xref target="RFC4218" /> 
       provides a threat analysis for IPv6 multihoming, and the remainder 
       of this section first describes how HIP host multihoming addresses 
       those previously described threats, and then it discusses some
       additional security considerations. </t>

       <t> The high-level threats discussed in <xref target="RFC4218" />
       involve redirection attacks for the purposes of packet recording,
       data manipulation, and availability.  There are a few types of
       attackers to consider: on-path attackers, off-path attackers,
       and malicious hosts. </t>

       <t> <xref target="RFC4218" /> also makes the comment that 
       in identifier/locator split solutions such as HIP, application
       security mechanisms should be tied to the identifier, not the
       locator, and attacks on the identifier mechanism and on the
       mechanism binding locators to the identifier are of concern.  
       This document does not consider the former issue (application-layer 
       security bindings) to be within scope.  The latter issue (locator 
       bindings to identifier) is directly addressed by the cryptographic 
       protections of the HIP protocol, in that locators associated to an 
       identifier are listed in HIP packets that are signed using the 
       identifier key. </t>

       <t> Section 3.1 of <xref target="RFC4218" /> lists several classes
       of security configurations in use in the Internet.  HIP maps to
       the fourth (strong identifier) and fifth ("leap-of-faith") 
       categories, the latter being associated with the optional 
       opportunistic mode of HIP operation.  The remainder of Section 3
       describes existing security problems in the Internet and 
       comments that the goal of a multihoming solution is not to 
       solve them specifically but rather not to make any of them 
       worse.  HIP multihoming should not increase the severity of
       the identified risks.  One concern for both HIP mobility and
       multihoming is the susceptibility of the mechanisms to misuse
       flooding-based redirections due to a malicious host.
       The mechanisms described in 
       <xref target="RFC8046" /> for address verification
       are important in this regard.  </t>

       <t> Regarding the new types of threats introduced by multihoming
       (Section 4 of <xref target="RFC4218" />), HIP multihoming 
       should not introduce new concerns.  Classic and premeditated
       redirection are prevented by the strong authentication in HIP 
       messages.   Third-party DoS attacks are prevented
       by the address verification mechanism.  Replay attacks can be
       avoided via use of replay protection in ESP SAs.  In addition, accepting
       packets from unknown locators is protected by either the strong
       authentication in the HIP control packets or by the ESP-based
       encryption in use for data packets.
       </t>

       <t> The HIP mechanisms are designed to limit the ability
       to introduce DoS on the mechanisms themselves (Section 7 of
       <xref target="RFC4218" />).  Care is taken in the HIP base
       exchange to avoid creating state or performing much work before 
       hosts can authenticate one another.  A malicious host involved
       in HIP multihoming with another host might attempt to misuse the
       mechanisms for multihoming by, for instance, increasing the state
       required or inducing a resource limitation attack by sending too
       many candidate locators to the peer host.  Therefore, 
       implementations supporting the multihoming extensions should
       consider avoiding accepting large numbers of peer locators and
       rate limiting any UPDATE messages being exchanged. </t> 

       <t>
       The exposure of a host's IP addresses through HIP mobility and 
       multihoming extensions may raise the following privacy concern.  
       The administrator
       of a host may be trying to hide its location in some context
       through the use of a VPN or other virtual interfaces.  Similar
       privacy issues also arise in other frameworks such as WebRTC
       and are not specific to HIP.  Implementations SHOULD provide
       a mechanism to allow the host administrator to block the
       exposure of selected addresses or address ranges.
       </t>
       <t>
       Finally, some implementations of VPN tunneling have experienced
       instances of 'leakage' of flows that were intended to have been
       protected by a security tunnel but are instead sent in the clear,
       perhaps because some of the addresses used fall outside of the
       range of addresses configured for the tunnel in the security
       policy or association database.   Implementors are advised
       to take steps to ensure that the usage of multiple addresses
       between hosts does not cause accidental leakage of some data 
       session traffic outside of the ESP-protected envelope.
       </t>

     </section>

    </middle>
    <back>

     <references title="Normative References">

       &RFC2119; 
       &RFC6724; 
       &RFC7401;
       &RFC7402;


<reference anchor='RFC8046' target="http://www.rfc-editor.org/info/rfc8046">
<front>
<title>Host Mobility with the Host Identity Protocol</title>
<author initials='T' surname='Henderson' fullname='Thomas Henderson'>
    <organization />
</author>
<author initials='C' surname='Vogt' fullname='Christian Vogt'>
    <organization />
</author>
<author initials='J' surname='Arkko' fullname='Jari Arkko'>
    <organization />
</author>
<date month='February' year='2017' />
</front>
<seriesInfo name='RFC' value='8046' />
<seriesInfo name='DOI' value='10.17487/RFC8046' />

</reference>

     </references>

     <references title="Informative References">

       &RFC4218;
       &RFC4303;
       &RFC5533;
     </references>

        <section title="Acknowledgments" numbered="no">
     <t>
     This document contains content that was originally included in RFC 5206.
     Pekka Nikander and Jari Arkko originated RFC 5206, and Christian
     Vogt and Thomas Henderson (editor) later joined as coauthors. Also
     in RFC 5206, Greg Perkins contributed the initial draft of the security 
     section, and Petri Jokela was a coauthor of the initial individual 
     submission.
     </t>
     <t>
     The authors thank Miika Komu, Mika Kousa, Jeff Ahrenholz, and
     Jan Melen for many improvements to the document.  Concepts from a paper
     on host multihoming across address families, by Samu Varjonen, Miika
     Komu, and Andrei Gurtov, contributed to this revised specification.
     </t>     
     </section>
  </back>
</rfc>
