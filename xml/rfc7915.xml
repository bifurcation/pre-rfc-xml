<?xml version="1.0" encoding="us-ascii"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc='yes'?>
<?rfc tocompact='yes'?>
<?rfc tocdepth='3'?>
<?rfc symrefs='yes'?>
<?rfc sortrefs='yes' ?>
<?rfc compact='yes' ?>
<?rfc subcompact='no' ?>

<rfc number="7915" category="std" submissionType="IETF" consensus="yes" ipr="trust200902" obsoletes="6145">
  <front>
    <title abbrev="IPv4/IPv6 Translation">IP/ICMP Translation Algorithm</title>

    <author fullname="Congxiao Bao" initials="C."  surname="Bao">
      <organization>CERNET Center/Tsinghua University</organization>
      <address>
        <postal>
          <street>Room 225, Main Building, Tsinghua University</street>
          <city>Beijing</city>
          <code>100084</code>
          <region></region>
          <country>China</country>
        </postal>
        <phone>+86 10-62785983</phone>
        <email>congxiao@cernet.edu.cn</email>
      </address>
    </author>

    <author fullname="Xing Li" initials="X."  surname="Li">
      <organization>CERNET Center/Tsinghua University</organization>
      <address>
        <postal>
          <street>Room 225, Main Building, Tsinghua University</street>
          <city>Beijing</city>
          <code>100084</code>
          <region></region>
          <country>China</country>
        </postal>
        <phone>+86 10-62785983</phone>
        <email>xing@cernet.edu.cn</email>
      </address>
    </author>

    <author fullname="Fred Baker" initials="F.J." 
            surname="Baker">
      <organization>Cisco Systems</organization>
      <address>
        <postal>
          <street></street>
          <city>Santa Barbara</city>
          <code>93117</code>
          <region>California</region>
          <country>United States</country>
        </postal>
        <phone>+1-408-526-4257</phone>
        <email>fred@cisco.com</email>
      </address>
    </author>

    <author fullname="Tore Anderson" initials="T." 
            surname="Anderson">
      <organization>Redpill Linpro</organization>
      <address>
        <postal>
          <street>Vitaminveien 1A</street>
                <city>0485 Oslo</city>
          <country>Norway</country>
        </postal>
        <phone>+47 959 31 212</phone>
        <email>tore@redpill-linpro.com</email>
        <uri>http://www.redpill-linpro.com</uri>
      </address>
    </author>

<author fullname="Fernando Gont"
       initials="F."
       surname="Gont">
       <organization abbrev="Huawei Technologies">Huawei
	Technologies</organization>
       <address>
           <postal>
	     <street>Evaristo Carriego 2644</street>
	     <code>1706</code><city>Haedo</city>
	     <region>Provincia de Buenos Aires</region>
	     <country>Argentina</country>
           </postal>
           <phone>+54 11 4650 8472</phone>
           <email>fgont@si6networks.com</email>
	   <uri>http://www.si6networks.com</uri>
       </address>
   </author>

     <date month="June" year="2016" /> 

    <area>Transport</area>

    <workgroup>v6ops</workgroup>

<keyword>SIIT</keyword>
<keyword>internet</keyword>
<keyword>protocol</keyword>
<keyword>control</keyword>
<keyword>message</keyword>
<keyword>IPv4</keyword>
<keyword>IPv6</keyword>
<keyword>Stateless IP/ICMP Translation Algorithm</keyword>
<keyword>RFC6145bis</keyword>

    <abstract>
      <t>
      This document describes the Stateless IP/ICMP
      Translation Algorithm (SIIT), which translates 
      between IPv4 and IPv6 packet headers (including ICMP
      headers). This document obsoletes RFC 6145.
      </t>
    </abstract>
  </front>

  <middle>
    <section anchor="introduction" title="Introduction and Motivation">
<t>
This document obsoletes
	<xref target="RFC6145"></xref>.
</t>

<t>
Readers of this document are expected to have read and understood the
framework described in 
<xref target="RFC6144"></xref>.
Implementations of this IPv4/IPv6 translation specification MUST support
one or more address mapping algorithms, which are defined in <xref target="addr-algos"/>.
</t>

      <section anchor="translation-model" title="IPv4-IPv6 Translation Model">

        <t>The translation model consists of two or more network domains
        connected by one or more IP/ICMP translators (XLATs) as shown
        in <xref target="cloud1"/>. 
	</t>

        <figure anchor="cloud1" title="IPv4-IPv6 Translation Model">
          <artwork align="center"><![CDATA[      
     ---------          ---------
   //        \\       //         \\
 /             +----+              \
|              |XLAT|               | XLAT: IP/ICMP
|   IPv4       +----+   IPv6        |       Translator
|   Domain     |    |   Domain      |  
|              |    |               |        
 \             |    |              /   
  \\         //      \\          //
     --------          ---------
]]></artwork>
        </figure>
	<t>
	 The scenarios of the translation model are discussed in
        <xref target="RFC6144"></xref>.
</t>

      </section>

      <section anchor="applicability" title="Applicability and Limitations">

	<t>
       This document specifies the
       translation algorithms between IPv4 packets and IPv6 packets.  	
       </t>

        <t>

	As with 
	<xref target="RFC6145"></xref>,
	the translating function specified in this document does not 
	translate any IPv4 options, and it does not translate IPv6 extension headers 
	except the Fragment Header. 
	</t>

        <t>
       The issues and algorithms in the translation of datagrams
       containing
       TCP segments are described in 
	<xref target="RFC5382"></xref>. 
	 </t>

        <t>

   Fragmented IPv4 UDP packets that do not contain a UDP checksum (i.e.,
   the UDP checksum field is zero) are not of significant use on the
   Internet, and in general will not be translated by the IP/ICMP translator (<xref target="transport46"></xref>). 
   However, when the translator is configured to forward the packet 
   without a UDP checksum, the fragmented IPv4 UDP packets will be translated. 

	 </t>

<t>
Fragmented ICMP/ICMPv6 packets will not be translated by IP/ICMP translators.
</t>

        <t>
The IP/ICMP header translation
specified in this document is consistent with requirements of
multicast IP/ICMP headers.  
However, IPv4 multicast
addresses 
<xref target="RFC5771"></xref> 
cannot be mapped to IPv6 multicast addresses
<xref target="RFC3307"></xref> 
based on the unicast mapping rule 
<xref target="RFC6052"></xref>. An example of experiments of the multicast address mapping can be found in
<xref target="RFC6219"></xref>.
       </t>
      </section>

      <section anchor="mode" title="Stateless vs. Stateful Mode">
        <t>An IP/ICMP translator has two possible modes of operation:
        stateless and stateful
        <xref target="RFC6144"></xref>.


        In both cases, we assume that a system (a node or an application) that
        has an IPv4 address but not an IPv6 address is communicating with a
        system that has an IPv6 address but no IPv4 address, or that the two
        systems do not have contiguous routing connectivity,

or they might have contiguous routing connectivity but are interacting via masking addresses (i.e., hairpinning) 
        <xref target="RFC4787"></xref>, and hence are forced to have their communications translated.</t>

	<t>In the stateless mode, an IP/ICMP translator will convert IPv4
	addresses to IPv6 and vice versa solely based on the configuration of
	the stateless IP/ICMP translator and information contained within the
	packet being translated.
      For example, for the default behavior defined in
        <xref target="RFC6052"></xref>,
   a specific IPv6 address range will represent
   IPv4 systems (IPv4-converted addresses), and the IPv6 systems have
   addresses (IPv4-translatable addresses) that can be algorithmically
   mapped to a subset of the service provider's IPv4 addresses.  

Other stateless translation algorithms are defined in <xref target="addr-algos"/>.

 
      The stateless translator does not keep
	any dynamic session or binding state, thus there is no requirement that
	the packets in a single session or flow traverse a single
	translator.</t>

	<t>In the stateful mode, a specific IPv6 address range (consisting of
	IPv4-converted IPv6 addresses) will typically represent IPv4 systems.
	The IPv6 nodes may use any IPv6 addresses <xref
	target="RFC4291"></xref> except in that range. A stateful IP/ICMP
	translator continuously maintains a dynamic translation table containing
	bindings between the IPv4 and IPv6 addresses, and likely also the
	Layer-4 identifiers, that are used in the translated packets. The exact
	address translations of any given packet thus become dependent on how
	packets belonging to the same session or flow have been translated. For
	this reason, stateful translation generally requires that all packets
	belonging to a single flow must traverse the same translator.</t>

	<t>In order to be able to successfully translate a packet from IPv4 to
	IPv6 or vice versa, the translator must implement an address mapping
	algorithm.  This document does not specify any such algorithms, instead
	these are referenced from <xref target="addr-algos"/>.</t>
      </section>

<section anchor="PMTU" title="Path MTU Discovery and Fragmentation">
<t>
Due to the different sizes of the IPv4 and IPv6 header, which are 20+ octets and 40
octets respectively, handling the maximum packet size is critical for the operation 
of the IPv4/IPv6 translator. 

There are three mechanisms to handle this issue: 
path MTU discovery (PMTUD), fragmentation, and transport-layer negotiation such as 
the TCP Maximum Segment Size (MSS) option
<xref target="RFC6691"></xref>.

Note that the translator MUST behave as a router, i.e., 
the translator MUST send a Packet Too Big error message or fragment the packet when the packet size exceeds 
the MTU of the next-hop interface. 
</t>

<t>
Don't Fragment, ICMP Packet Too Big, and packet fragmentation are discussed
in Sections <xref target="v4tov6" format="counter"/> and
<xref target="v6tov4" format="counter"/> of this document.


The reassembling of fragmented packets   in the stateful translator is discussed in
<xref target="RFC6146"/>,
since it requires state maintenance in the translator.
</t>
</section>
    </section>


	<section anchor="changes"  title="Changes from RFC 6145">
	<t>
	The changes from RFC 6145 are the following:
	
<list style="numbers">


<t>
Inserted the notes about IPv6 extension header handling:
<xref target="Err3059"/>, <xref target="Err3060"/>,
<xref target="Err3061"/>, and <xref target="Err4090"/>.
</t>

<t>
Deprecated the algorithm that generates the IPv6 atomic fragments, as a result
 of the analysis in
<xref target="ATOMIC"></xref> and the specification in 
<xref target="IPv6"></xref>.
</t>

<t>
Inserted the notes for stateless source address mapping for ICMPv6 
packets
<xref target="RFC6791"></xref>.
</t>

<t>
Supported new address mapping algorithms and moved the discussion of these algorithms to <xref target="addr-algos"></xref>.
</t>


</list>
</t>
	</section> 

	<section anchor="conventions" title="Conventions">
	<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      <xref target="RFC2119"></xref>. 
	</t>
	</section>

    <section anchor="v4tov6" title="Translating from IPv4 to IPv6">
 
<t>
   When an IP/ICMP translator receives an IPv4 datagram addressed to a
   destination towards the IPv6 domain, it translates the IPv4 header of
   that packet into an IPv6 header.  The original IPv4 header on the
   packet is removed and replaced by an IPv6 header, and the transport
   checksum is updated as needed, if that transport is supported by the
   translator.  The data portion of the packet is left
   unchanged.  The IP/ICMP translator then forwards the packet based on
   the IPv6 destination address.
</t>
      <figure anchor="v4v6xlat" title="IPv4-to-IPv6 Translation">
        <artwork align="center"><![CDATA[
+-------------+                 +-------------+
|    IPv4     |                 |    IPv6     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|  Transport- |                 |  Fragment   |
|   Layer     |      ===>       |   Header    |
|   Header    |                 | (if needed) |
+-------------+                 +-------------+
|             |                 |  Transport- |
~    Data     ~                 |   Layer     |
|             |                 |   Header    |
+-------------+                 +-------------+
                                |             |
                                ~    Data     ~
                                |             |
                                +-------------+
]]></artwork>
      </figure>
      <t>
   Path MTU discovery is mandatory in IPv6, but it is optional in IPv4.
IPv6 routers never fragment a packet -- only the sender can do
fragmentation.

     </t>

      <t>When an IPv4 node performs path MTU discovery (by setting the Don't Fragment (DF) bit
      in the header), path MTU discovery can operate end-to-end, i.e., across
      the translator. In this case, either IPv4 or IPv6 routers (including the translator) might send back
      ICMP Packet Too Big messages to the sender. When the IPv6 routers send
      these ICMPv6 errors, they will pass through a translator that will
      translate the ICMPv6 error to a form that the IPv4 sender can understand.
      As a result, an IPv6 Fragment Header is only included if the IPv4 packet
      is already fragmented.</t>

<t>
  However, when the IPv4 sender does not set the DF
  bit, the translator MUST ensure that the packet does not exceed the
  path MTU on the IPv6 side.  This is done by fragmenting the IPv4
  packet (with Fragment Headers) so that it fits in 1280-byte
  IPv6 packets, since that is the minimum IPv6 MTU.  The IPv6
  Fragment Header has been shown to cause operational
  difficulties in practice due to limited firewall fragmentation
  support, etc. In an environment where the network
  owned/operated by the same entity that owns/operates the translator,
  the translator MUST provide a configuration function for the network
  administrator to adjust the threshold of the minimum IPv6 MTU to
  a value that reflects the real value of the minimum IPv6 MTU in
  the network (greater than 1280 bytes). This will help reduce the
  chance of including the Fragment Header in the packets. 
</t>

<t>
When the IPv4 sender does not set the DF bit, the translator MUST NOT include the Fragment Header for the non-fragmented IPv6 packets.
</t>

<t>
 The rules in <xref target="header46"/> ensure that when packets are fragmented, either by the sender or by IPv4 routers, the low-order 16 bits of the fragment identification are carried end-to-end, ensuring that packets are correctly reassembled.
</t>

      <t>Other than the special rules for handling fragments and path MTU
      discovery, the actual translation of the packet header consists of a
      simple translation as defined below. Note that ICMPv4 packets require special
      handling in order to translate the content of ICMPv4 error messages and
      also to add the ICMPv6 pseudo-header checksum.</t>
<t>
   The translator SHOULD make sure that the packets belonging to the 
   same flow leave the translator in the same order in which they 
   arrived.
</t>

      <section anchor="header46"
               title="Translating IPv4 Headers into IPv6 Headers">

<t>
If the DF flag is not set and the IPv4 packet will result in 
an IPv6 packet 
larger than a user-defined length (hereinafter referred to as 
"lowest-ipv6-mtu", and which defaults to 1280 bytes), the packet
SHOULD be fragmented so that the resulting IPv6 packet (with 
Fragment Header added to each fragment) will be less than or 
equal to lowest-ipv6-mtu, 

  For example, if the packet
  is fragmented prior to the translation, the IPv4 packets should be
  fragmented so that their length, excluding the IPv4 header, is at
  most 1232 bytes (1280 minus 40 for the IPv6 header and 8 for the
  Fragment Header). The translator MUST provide a configuration function
  for the network administrator to adjust the threshold of the minimum
  IPv6 MTU to a value greater than 1280 bytes if the real value of the
  minimum IPv6 MTU in the network is known to the administrator.
  The resulting fragments are then translated
  independently using the logic described below. 
</t>


<t>
If the DF bit is set and the MTU of the next-hop interface is less than the
total length value of the IPv4 packet plus 20, the translator MUST send an ICMPv4 "Fragmentation Needed" error message
to the IPv4 source address. 
</t>

<t>
The IPv6 header fields are set
        as follows: <list style="hanging">
            <t hangText="Version:">6</t>

            <t hangText="Traffic Class:">By default, copied from the IP Type Of
            Service (TOS) octet. According to <xref target="RFC2474"></xref>, the
            semantics of the bits are identical in IPv4 and IPv6. However, in
            some IPv4 environments these fields might be used with the old
            semantics of "Type Of Service and Precedence". 

An implementation of a translator SHOULD support an
administratively configurable option to ignore the IPv4 TOS and always
set the IPv6 traffic class (TC) to zero.

In addition, if the translator is at an administrative boundary, the filtering
and update considerations of <xref target="RFC2475"></xref> may be applicable.

		</t>

            <t hangText="Flow Label:">0 (all zero bits)</t>

            <t hangText="Payload Length:">Total length value from the IPv4 header,
            minus the size of the IPv4 header and IPv4 options, if
            present.</t>

            <t hangText="Next Header:">
		For ICMPv4 (1), it is changed to ICMPv6 (58);
		otherwise, the protocol field MUST be copied from the IPv4 header. 
		</t>

            <t hangText="Hop Limit:">The hop limit is derived from the TTL value in the IPv4 header.  Since
            the translator is a router, as part of forwarding the packet it
            needs to decrement either the IPv4 TTL (before the translation) or
            the IPv6 Hop Limit (after the translation). As part of
            decrementing the TTL or Hop Limit, the translator (as any router)
            MUST check for zero and send the ICMPv4 "TTL Exceeded" or ICMPv6 "Hop Limit
            Exceeded" error.</t>

            <t hangText="Source Address:">
		Mapped to an IPv6 address based on the algorithms presented in
		<xref target="addr-algos"/>.

 		<vspace blankLines="1" /> 
If the translator gets an illegal source address (e.g., 0.0.0.0,
127.0.0.1, etc.), the translator SHOULD silently discard the packet (as
discussed in Section 5.3.7 of
<xref target="RFC1812"></xref>).
Note when translating ICMPv4 Error Messages into ICMPv6, the
"illegal" source address will be translated for the purpose of trouble shooting.
</t>

            <t hangText="Destination Address:">
		Mapped to an IPv6 address based on the algorithms presented in
		<xref target="addr-algos"/>.
</t>

          </list></t>

        <t>

   If any IPv4 options are present in the IPv4 packet, they
   MUST be ignored and the packet translated normally; there is no
attempt to translate the options.

        However, if an unexpired
        source route option is present, then the packet MUST instead be
        discarded, and an ICMPv4 "Destination Unreachable, Source Route Failed"
        (Type 3, Code 5) error message SHOULD be returned to the sender.

	</t>

        <t>If there is a need to add a Fragment Header
 (the packet is a fragment or
the DF bit is not set and the packet size is greater than the minimum IPv6 MTU 
in the network set by the translator configuration function), the header fields are set as above with the
        following exceptions: <list style="hanging">

            <t hangText="IPv6 fields:"><list style="hanging">
                <t hangText="Payload Length:">Total length value from
                the IPv4
                header, plus 8 for the Fragment Header, minus the size of the
                IPv4 header and IPv4 options, if present.</t>

                <t hangText="Next Header:">Fragment Header (44).</t>
              </list></t>

            <t hangText="Fragment Header fields:"><list style="hanging">
                <t hangText="Next Header:">

For ICMPv4 (1), it is changed to ICMPv6 (58); otherwise, the protocol
field MUST be copied from the IPv4 header. 

</t>

                <t hangText="Fragment Offset:">Fragment Offset copied from the
                IPv4 header.</t>

                <t hangText="M flag:">More Fragments bit copied from the IPv4
                header.</t>

                <t hangText="Identification:">The low-order 16 bits copied from
                the Identification field in the IPv4 header. The high-order 16
                bits set to zero.</t>
              </list></t>
          </list></t>
      </section>

      <section anchor="icmp46"
               title="Translating ICMPv4 Headers into ICMPv6 Headers">
        <t>All ICMPv4 messages that are to be translated require that the ICMPv6
        checksum field be calculated as part of the translation since ICMPv6,
        unlike ICMPv4, has a pseudo-header checksum just like UDP and TCP.</t>

        <t>In addition, all ICMPv4 packets MUST have the Type translated
        and, for ICMPv4 error messages, the included IP header also MUST be
        translated.</t>

        <t>The actions needed to translate various ICMPv4 messages are as follows: <list
            style="hanging">
            <t hangText="ICMPv4 query messages:"><list style="hanging">
                <t hangText="Echo and Echo Reply (Type 8 and Type 0):">Adjust
                the Type values to 128 and 129, respectively, and adjust the ICMP
                checksum both to take the type change into account and to
                include the ICMPv6 pseudo-header.</t>

                <t
                hangText="Information Request/Reply (Type 15 and Type 16):">Obsoleted
                in ICMPv6. Silently drop.</t>

                <t
                hangText="Timestamp and Timestamp Reply (Type 13 and Type 14):">Obsoleted
                in ICMPv6. Silently drop.</t>

                <t
                hangText="Address Mask Request/Reply (Type 17 and Type 18):">Obsoleted
                in ICMPv6. Silently drop.</t>

                <t hangText="ICMP Router Advertisement (Type 9):">Single-hop
                message. Silently drop.</t>

                <t hangText="ICMP Router Solicitation (Type 10):">Single-hop
                message. Silently drop.</t>

                <t hangText="Unknown ICMPv4 types:">Silently drop.</t>

                <t hangText="IGMP messages:">While the Multicast
		  Listener Discovery (MLD) messages specified in <xref
		  target="RFC2710"></xref>, <xref
		  target="RFC3590"></xref>, and <xref
		  target="RFC3810"></xref> are the logical IPv6
		  counterparts for the IPv4 IGMP messages, all the
		  "normal" IGMP messages are single-hop messages and
		  SHOULD be silently dropped by the translator.

		Other IGMP messages might be used by multicast
                routing protocols and, since it would be a configuration error
                to try to have router adjacencies across IP/ICMP translators,
                those packets SHOULD also be silently dropped.</t>


              <t hangText=" ICMPv4 error messages:"><list style="hanging">
                    <t hangText="Destination Unreachable (Type 3):">
			Translate the Code as 
            		described below, set the Type to 1, and adjust
            		the ICMP checksum both to take the type/code change into account
            		and to include the ICMPv6 pseudo-header.


                    <vspace blankLines="1" /> Translate the Code as
                    follows: 

			<list style="hanging">
                        <t hangText="Code 0, 1 (Net Unreachable, Host Unreachable):">Set
                        the Code to 0 (No route to destination).</t>

                        <t hangText="Code 2 (Protocol Unreachable):">Translate
                        to an ICMPv6 Parameter Problem (Type 4, Code 1) and
                        make the Pointer point to the IPv6 Next Header
                        field.</t>

                        <t hangText="Code 3 (Port Unreachable):">Set the Code to 4
                        (Port unreachable).</t>

<t hangText="Code 4 (Fragmentation Needed and DF was Set):">

               Translate to
               an ICMPv6 Packet Too Big message (Type 2) with Code set
               to 0.  The MTU field MUST be adjusted for the difference
               between the IPv4 and IPv6 header sizes, but MUST NOT be
               set to a value smaller than the minimum IPv6 MTU
               (1280 bytes). 

That is, it should be set to 
<figure><artwork>
            maximum(1280,
              minimum((MTU value in the Packet Too Big Message) + 20, 
                      MTU_of_IPv6_nexthop,
                      (MTU_of_IPv4_nexthop) + 20)).  
</artwork></figure>
Note that if the IPv4 router
               set the MTU field to zero, i.e., the router does not
               implement 
		   <xref target="RFC1191"></xref>, 
		   then the translator MUST use the
               plateau values specified in 
	         <xref target="RFC1191"></xref>
		   to determine a
               likely path MTU and include that path MTU in the ICMPv6
               packet.  (Use the greatest plateau value that is less
               than the returned Total Length field, but that is larger
               than or equal to 1280.)
</t>

			<t>
			See also the requirements in <xref target="icmp6-tbg"/>.
                       </t>

                        <t hangText="Code 5 (Source Route Failed):">Set the Code 
                        to 0 (No route to destination). Note that this error
                        is unlikely since source routes are not
                        translated.</t>

                        <t hangText="Code 6, 7, 8:">Set the Code to 0 (No route to
                        destination).</t>

                        <t hangText="Code 9, 10">(Communication with Destination
				  Host Administratively Prohibited): Set the Code to 1 (Communication with destination
                        administratively prohibited).
                                </t>

                      <t hangText="Code 11, 12:">Set the Code to 0 (No route
		      to
 destination).</t>


                        <t hangText="Code 13 (Communication Administratively Prohibited):">Set the Code to 1 (Communication with destination administratively prohibited).                                                                </t>

                        <t hangText="Code 14 (Host Precedence Violation):">Silently drop.                                        </t>


                        <t hangText="Code 15 (Precedence cutoff in effect):">Set the Code to 1 (Communication with destination administratively prohibited).                                                                              </t>

                                <t hangText="Other Code values:">Silently drop.</t>

                    </list></t>


                    <t hangText="Redirect (Type 5):">Single-hop message.
                    Silently drop.</t>

                    <t hangText="Alternative Host Address (Type 6):">
                    Silently drop.</t>

                    <t hangText="Source Quench (Type 4):">Obsoleted in ICMPv6.
                    Silently drop.</t>

                    <t hangText="Time Exceeded (Type 11):">Set the Type 
                    to 3, and adjust the ICMP checksum both to
         		take the type change into account and to include the ICMPv6
         		pseudo-header. The Code is unchanged.</t>

                    <t hangText="Parameter Problem (Type 12):">Set the Type
      to 4, and adjust the ICMP checksum both to
         		take the type/code change into account and to include the ICMPv6
        		 pseudo-header. 
			<vspace blankLines="1" /> Translate the Code as
                    follows: 

			<list style="hanging">
                        <t hangText="Code 0 (Pointer indicates the error):">
				Set the Code to 0 (Erroneous header field encountered) and update the pointer as defined in <xref target="figure-pointervalue-v4-v6"/>.
				(If the Original IPv4 Pointer Value is not listed or the Translated IPv6 Pointer 
				Value is listed as "n/a", silently drop the packet.)
			</t>

                        <t hangText="Code 1 (Missing a required option):">
				Silently drop.				
				</t>

                        <t hangText="Code 2 (Bad length):">
				Set the Code to 0 (Erroneous header field encountered) and update the pointer as defined in <xref target="figure-pointervalue-v4-v6"/>.
				(If the Original IPv4 Pointer Value is not listed or the Translated IPv6 Pointer 
				Value is listed as "n/a", silently drop the packet.)
				</t>

                        <t hangText="Other Code values:">
				Silently drop.				
				</t>
                      </list>
			</t>
                    <t hangText="Unknown ICMPv4 types:">Silently drop.
			</t>
<t>
        <figure anchor="figure-pointervalue-v4-v6" title="Pointer Value for Translating from IPv4 to IPv6">
          <artwork align="center"><![CDATA[   
 +--------------------------------+--------------------------------+
 |   Original IPv4 Pointer Value  | Translated IPv6 Pointer Value  |
 +--------------------------------+--------------------------------+
 |  0  | Version/IHL              |  0  | Version/Traffic Class    |
 |  1  | Type Of Service          |  1  | Traffic Class/Flow Label |
 | 2,3 | Total Length             |  4  | Payload Length           |
 | 4,5 | Identification           | n/a |                          |
 |  6  | Flags/Fragment Offset    | n/a |                          |
 |  7  | Fragment Offset          | n/a |                          |
 |  8  | Time to Live             |  7  | Hop Limit                |
 |  9  | Protocol                 |  6  | Next Header              |
 |10,11| Header Checksum          | n/a |                          |
 |12-15| Source Address           |  8  | Source Address           |
 |16-19| Destination Address      | 24  | Destination Address      |
 +--------------------------------+--------------------------------+
]]></artwork>
        </figure>
</t>
                    <t hangText="ICMP Error Payload:">
If the received ICMPv4 packet contains an ICMPv4 Extension 
<xref target="RFC4884"></xref>, 
the translation of the ICMPv4 packet will cause the ICMPv6 packet to change length. 
When this occurs, the ICMPv6 Extension length attribute MUST be adjusted accordingly 
(e.g., longer due to the translation from IPv4 to IPv6). 
If the ICMPv4 Extension exceeds the maximum size of an ICMPv6 message on the outgoing 
interface, the ICMPv4 extension SHOULD be simply truncated. 
For extensions not defined in 
<xref target="RFC4884"></xref>,
the translator passes the extensions 
as opaque bit strings, and those containing IPv4 address literals will not have 
their  included addresses translated to IPv6 address literals; this may cause problems 
with processing of those ICMP extensions.

				</t>
                  </list></t>
              </list></t>
          </list></t>

      </section>

      <section anchor="error46"
               title="Translating ICMPv4 Error Messages into ICMPv6">
        <t>There are some differences between the ICMPv4 and the ICMPv6 error
        message formats as detailed above. The ICMP error
        messages containing the packet in error MUST
        be translated just like a normal IP packet
(except the TTL value of the inner IPv4/IPv6 packet). 


If the translation of this "packet in error" changes the length of
the datagram, the Total
   Length field in the outer IPv6 header MUST be updated.
       </t>
        <figure anchor="v4v6icmp" title="IPv4-to-IPv6 ICMP Error Translation">
          <artwork align="center"><![CDATA[
+-------------+                 +-------------+
|    IPv4     |                 |    IPv6     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|   ICMPv4    |                 |   ICMPv6    |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|    IPv4     |      ===>       |    IPv6     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|   Partial   |                 |   Partial   |
|  Transport- |                 |  Transport- |
|   Layer     |                 |   Layer     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
]]></artwork>
        </figure>
        <t>
   The translation of the inner IP header can be done by invoking the function 
that translated the outer IP headers. This process MUST stop at the first embedded 
header and drop the packet if it contains more embedded headers.

</t>
      </section>

      <section anchor="sending-icmp4" title="Generation of ICMPv4 Error Message">
        <t>
		If the IPv4 packet is discarded, then the translator SHOULD be able to send back an ICMPv4 error message to the original sender of the packet, 

		unless the discarded packet is itself an ICMPv4 error message.

		The ICMPv4 message, if sent, has a Type of 3 (Destination Unreachable) and a Code of 13 (Communication Administratively Prohibited),
		unless otherwise specified in this document or in 
		<xref target="RFC6146"></xref>.
		The translator SHOULD allow an administrator to configure whether the ICMPv4 error messages are sent, rate-limited, or not sent. 
	</t>
      </section>

      <section anchor="transport46" title="Transport-Layer Header Translation">

<t>
   If the address translation algorithm is not checksum neutral
   (see Section 4.1 of 
   <xref target="RFC6052"></xref>),
   the recalculation
   and updating of the transport-layer headers that contain pseudo-headers need to be performed.  Translators MUST do this for TCP 
   and ICMP packets and for UDP packets that contain a UDP checksum 
   (i.e., the UDP checksum field is not zero).
</t>

<t>
  For UDP packets that do not contain a UDP checksum 
(i.e., the UDP checksum field is zero), the translator 
SHOULD provide a configuration function to
   allow:
<list style="numbers">
<t>
Dropping the packet and generating a system management
   event that specifies at least the IP addresses and port numbers of the
   packet. 
</t>


<t>Calculating an IPv6 checksum and forwarding the packet
   (which has performance implications).
	<vspace blankLines="1" /> 
A stateless translator cannot compute the
   UDP checksum of fragmented packets, so when a stateless translator
   receives the first fragment of a fragmented UDP IPv4 packet and the
   checksum field is zero, the translator SHOULD drop the packet and
   generate a system management event that specifies at least the IP
   addresses and port numbers in the packet. 
	<vspace blankLines="1" /> 
 For a stateful translator,
   the handling of fragmented UDP IPv4 packets with a zero checksum is
   discussed in 
   <xref target="RFC6146"></xref>,
  Section 3.4.

</t>

</list>
</t>

<t>
   Other transport protocols (e.g., the Datagram Congestion Control Protocol (DCCP)) are OPTIONAL to support.  In
   order to ease debugging and troubleshooting, translators MUST forward
   all transport protocols as described in the "Next Header" step of <xref target="header46"/>.
</t>

      </section>

      <section anchor="when46" title="Knowing When to Translate">
        <t>

   If the IP/ICMP translator also provides a normal forwarding function, and the destination IPv4 address is reachable by a
   more specific route without translation, the translator MUST forward it
   without translating it.  Otherwise, when an IP/ICMP translator
   receives an IPv4 datagram addressed to an IPv4 destination representing a host in the IPv6
   domain, the packet MUST be translated to IPv6.
</t>
      </section>
    </section>

    <section anchor="v6tov4" title="Translating from IPv6 to IPv4">

      <t>When an IP/ICMP translator receives an IPv6 datagram addressed to a
      destination towards the IPv4 domain, it translates the IPv6 header of
      the received IPv6 packet into an IPv4 header. 
	The
      original IPv6 header on the packet is removed and replaced by an IPv4
      header. 
	Since the ICMPv6      <xref target="RFC4443"></xref>, 
      TCP <xref target="RFC0793"></xref>, 
      UDP <xref target="RFC0768"></xref>, and
	DCCP <xref target="RFC4340"></xref> 
      headers
      contain checksums that cover the IP header, 
      if the address mapping algorithm is not checksum neutral, 
      the checksum MUST be evaluated before translation and the ICMP and transport-layer headers MUST be updated. 
      
	The
      data portion of the packet is left unchanged. The IP/ICMP translator
      then forwards the packet based on the IPv4 destination address. </t>
      <figure anchor="v6v4xlat" title="IPv6-to-IPv4 Translation">
        <artwork align="center"><![CDATA[
+-------------+                 +-------------+
|    IPv6     |                 |    IPv4     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|  Fragment   |                 |  Transport  |
|   Header    |      ===>       |   Layer     |
|(if present) |                 |   Header    |
+-------------+                 +-------------+
|  Transport  |                 |             |
|   Layer     |                 ~    Data     ~
|   Header    |                 |             |
+-------------+                 +-------------+
|             |
~    Data     ~
|             |
+-------------+
]]></artwork>
      </figure>
<t>
    There are some differences between IPv6 and IPv4 (in the areas of
    fragmentation and the minimum link MTU) that affect the translation.
    An IPv6 link has to have an MTU of 1280 bytes or greater.  The
    corresponding limit for IPv4 is 68 bytes.  Path MTU discovery across
    a translator relies on ICMP Packet Too Big messages being received
    and processed by IPv6 hosts.
</t>

<t>
    The difference in the minimum MTUs of IPv4 and IPv6 is accommodated
    as follows:
<list style="symbols">
	<t>
         When translating an ICMPv4 "Fragmentation Needed" packet, the
         indicated MTU in the resulting ICMPv6 "Packet Too Big" will
         never be set to a value lower than 1280. This ensures that the
         IPv6 nodes will never have to encounter or handle Path MTU
         values lower than the minimum IPv6 link MTU of 1280. See
         <xref target="icmp46"></xref>.
	</t>

<t>
         When the resulting IPv4 packet is smaller than or equal to 1260
         bytes, the translator MUST send the packet with a cleared Don't
         Fragment bit. Otherwise, the packet MUST be sent with the Don't
         Fragment bit set. 
         See <xref target="header64"></xref>.
</t>

</list>
</t>

<t>
    This approach allows Path MTU Discovery to operate end-to-end for
    paths whose MTU are not smaller than the minimum IPv6 MTU of 1280 (which
    corresponds to an MTU of 1260 in the IPv4 domain). On paths that have
    IPv4 links with MTU &lt; 1260, the IPv4 router(s) connected to those
    links will fragment the packets in accordance with Section 2.3 of
   <xref target="RFC0791"></xref>. 
</t>

      <t>Other than the special rules for handling fragments and path MTU
      discovery, the actual translation of the packet header consists of a
      simple translation as defined below. Note that ICMPv6 packets require special
      handling in order to translate the contents of ICMPv6 error messages and
      also to remove the ICMPv6 pseudo-header checksum.</t>

	<t>
	   The translator SHOULD make sure that the packets belonging to the 
   	same flow leave the translator in the same order in which they 
   	arrived.
	</t>

      <section anchor="header64"
               title="Translating IPv6 Headers into IPv4 Headers">

        <t>If there is no IPv6 Fragment Header, the IPv4 header fields are set
        as follows: <list style="hanging">
            <t hangText="Version:">4</t>

            <t hangText="Internet Header Length:">5 (no IPv4 options)</t>

            <t hangText="Type of Service (TOS) Octet:">By default, copied from
            the IPv6 Traffic Class (all 8 bits). According to <xref
            target="RFC2474"></xref>, the semantics of the bits are identical
            in IPv4 and IPv6. However, in some IPv4 environments, these bits
            might be used with the old semantics of "Type Of Service and
            Precedence". An implementation of a translator SHOULD provide the
            ability to ignore the IPv6 traffic class and always set the IPv4
            TOS Octet to a specified value. In addition, if the translator is
            at an administrative boundary, the filtering and update
            considerations of <xref target="RFC2475"></xref> may be
            applicable.</t>

            <t hangText="Total Length:">Payload length value from the IPv6 header,
            plus the size of the IPv4 header.</t>

            <t hangText="Identification:">


Set according to a Fragment Identification generator at the translator.

            </t>

            <t hangText="Flags:">
                 
        The More Fragments flag is set to zero.  The Don't Fragment
        (DF) flag is set as follows: If the size of the translated IPv4
        packet is less than or equal to 1260 bytes, it is set to zero;
        otherwise, it is set to one.

            </t>

            <t hangText="Fragment Offset:">All zeros.</t>

            <t hangText="Time to Live:">

 Time to Live is derived from the Hop Limit value in the IPv6 header.  
Since the translator is a router, as part of forwarding
            the packet it needs to decrement either the IPv6 Hop Limit (before
            the translation) or the IPv4 TTL (after the translation). As part
            of decrementing the TTL or Hop Limit, the translator (as any
            router) MUST check for zero and send the ICMPv4 "TTL Exceeded" or ICMPv6 "Hop Limit
            Exceeded" error.</t>

            <t hangText="Protocol:">

	The IPv6-Frag (44) header is handled as discussed in
      <xref target="ipv6-fragment"/>. 
      ICMPv6 (58) is changed to ICMPv4 (1), and the
      payload is translated as discussed in <xref target="icmp64"/>.
The IPv6
      headers HOPOPT (0), IPv6-Route (43), and IPv6-Opts (60) are skipped
      over during processing as they have no meaning in IPv4.  For the
      first 'next header' that does not match one of the cases above, its
      Next Header value (which contains the transport protocol number) is
      copied to the protocol field in the IPv4 header.  This means that
      all transport protocols are translated.

<list style="hanging">
<t hangText="Note:">
                Some translated protocols will fail at the receiver
                for various reasons:  some are known to fail when
                translated (e.g., IPsec Authentication Header (51)), and others will fail 
                checksum validation if the address translation is not
                checksum neutral 
                <xref target="RFC6052"></xref>
                and the translator does not update the transport
                protocol's checksum (because the translator doesn't
                support recalculating the checksum for that
                transport protocol; see <xref target="transport64"/>).
		</t> 
</list>
</t>

            <t hangText="Header Checksum:">Computed once the IPv4 header has
            been created.</t>

            <t hangText="Source Address:">
		Mapped to an IPv4 address based on the algorithms presented in
		<xref target="addr-algos"/>.
		<vspace blankLines="1" /> 
      If the translator gets an illegal source address (e.g., ::1,
      etc.), the translator SHOULD silently drop the packet.

</t>
            <t hangText="Destination Address:">
		Mapped to an IPv4 address based on the algorithms presented in 
		<xref target="addr-algos"/>.
</t>

          </list></t>

<t>
If any of an IPv6 Hop-by-Hop Options header, Destination Options  header, or Routing header with the Segments Left field equal to zero  are present in the IPv6 packet, those IPv6 extension headers MUST be ignored (i.e., there is no attempt to translate the extension  headers) and the packet translated normally.  However, the Total Length field and the Protocol field are adjusted to "skip" these extension headers.
</t>

        <t>If a Routing header with a non-zero Segments Left field is present,
        then the packet MUST NOT be translated, and an ICMPv6 "parameter
        problem/erroneous header field encountered" (Type 4, Code 0) error
        message, with the Pointer field indicating the first byte of the
        Segments Left field, SHOULD be returned to the sender.</t>

<section anchor="ipv6-fragment" title="IPv6 Fragment Processing">

        <t>If the IPv6 packet contains a Fragment Header, the header fields are
        set as above with the following exceptions: <list style="hanging">

            <t hangText="Total Length:">
If the Next Header field of the Fragment Header is an extension header (except
ESP, but including the Authentication Header (AH)), then the packet SHOULD be dropped and logged.
For other cases, the
Total Length MUST be set to
Payload Length value from IPv6 header, minus the length of the extension
headers up to the Fragmentation Header, minus 8 for the Fragment
Header, plus the size of the IPv4 header.  

		</t>


            <t hangText="Identification:">Copied from the low-order 16
            bits in
            the Identification field in the Fragment Header.</t>

            <t hangText="Flags:">
	The IPv4 More Fragments (MF) flag is copied from the M 
      flag in the IPv6 Fragment Header.  The IPv4 Don't Fragment (DF) 
      flag is cleared (set to zero), allowing this packet to be further 
      fragmented by IPv4 routers.
		</t>

            <t hangText="Fragment Offset:">
If the Next Header field of the Fragment Header is not an extension header (except ESP), then Fragment Offset MUST be copied from the Fragment Offset field of the IPv6 Fragment Header. If the Next Header field of the Fragment Header is an extension header (except ESP), then the packet SHOULD be dropped and logged.
</t>

            <t hangText="Protocol:">
   For ICMPv6 (58), it is changed to ICMPv4 (1);
      otherwise, extension headers are skipped, and the Next
      Header field is copied from the last IPv6 header.

		</t>
          </list></t>

<t>
   If an IPv6 packet that is smaller than or equal to 1280 bytes results
   (after translation) in an IPv4 packet that is larger than the MTU of
   the next-hop interface, then the translator MUST perform IPv4
   fragmentation on that packet such that it can be transferred over the
   constricting link.
</t>
      </section>
      </section>

      <section anchor="icmp64"
               title="Translating ICMPv6 Headers into ICMPv4 Headers">
       	<t>
   If a non-checksum-neutral translation address is being used, 
   ICMPv6 messages MUST have their ICMPv4 checksum field be updated 
   as part of the translation since ICMPv6 (unlike ICMPv4) includes a 
   pseudo-header in the checksum just like UDP and TCP.
	</t>

        <t>In addition, all ICMP packets MUST have the Type translated
        and, for ICMP error messages, the included IP header MUST also be translated.
</t>

        <t>The actions needed to translate various ICMPv6 messages are:<list style="hanging">
            <t hangText="ICMPv6 informational messages:"><list style="hanging">
                <t
                hangText="Echo Request and Echo Reply">(Type 128 and 129): Adjust
                the Type values to 8 and 0, respectively, and adjust the ICMP
                checksum both to take the type change into account and to
                exclude the ICMPv6 pseudo-header.</t>

                <t
                hangText="MLD Multicast Listener Query/Report/Done">(Type
		130, 131, 132): Single-hop message. Silently drop.</t>

                <t
                hangText="Neighbor Discover messages">(Type 133 through 137):
		Single-hop message. Silently drop.</t>

                <t
                hangText="Unknown informational messages:">Silently
                drop.</t>
              </list></t>

            <t hangText="ICMPv6 error messages:"><list style="hanging">
                <t hangText="Destination Unreachable (Type 1)">Set the Type to 3, and adjust the ICMP checksum both to
         	take the type/code change into account and to exclude the ICMPv6
         	pseudo-header. <vspace blankLines="1" /> Translate the Code as follows: 

			<list style="hanging">
                    <t hangText="Code 0 (No route to destination):">Set the Code
                    to 1 (Host unreachable).</t>

                    <t
                    hangText="Code 1">(Communication with destination
		    administratively prohibited): Set the
                    Code to 10 (Communication with destination host
                    administratively prohibited).</t>

                    <t hangText="Code 2 (Beyond scope of source address):">Set the
                    Code to 1 (Host unreachable). Note that this error is very
                    unlikely since an IPv4-translatable source address is typically
                    considered to have global scope.</t>

                    <t hangText="Code 3 (Address unreachable):">Set the Code to 1
                    (Host unreachable).</t>

                    <t hangText="Code 4 (Port unreachable):">Set the Code to 3
                    (Port unreachable).</t>


			<t  hangText="Other Code values:">
				Silently drop.
			</t>
                  </list></t>

                <t hangText="Packet Too Big (Type 2):">Translate to an ICMPv4
                Destination Unreachable (Type 3) with Code 4,
		and
         adjust the ICMPv4 checksum both to take the type change into
         account and to exclude the ICMPv6 pseudo-header. The MTU field MUST be
                adjusted for the difference between the IPv4 and IPv6 header
                sizes, taking into account whether or not the packet in error
                includes a Fragment Header, i.e., minimum((MTU value in the Packet Too Big Message)-20, MTU_of_IPv4_nexthop, (MTU_of_IPv6_nexthop)-20).
			</t>
		<t>
		See also the requirements in <xref target="icmp6-tbg"/>.
		</t>

                <t hangText="Time Exceeded (Type 3):">Set the Type to 11,
		and
         adjust the ICMPv4 checksum both to take the type change into
         account and to exclude the ICMPv6 pseudo-header.  
			The
                Code is unchanged.</t>

                <t hangText="Parameter Problem (Type 4):"> Translate the Type and Code as follows,
		and
         adjust the ICMPv4 checksum both to take the type/code change into
         account and to exclude the ICMPv6 pseudo-header.  

			<vspace blankLines="1" /> Translate the Code as
                    follows: 

			<list style="hanging">

                    <t hangText="Code 0 (Erroneous header field encountered):">
 			Set to Type 12, Code 0, and update the pointer as
			defined in <xref target="figure-pointervalue-v6-v4"/>. (If the Original 
			IPv6 Pointer Value is not listed or the Translated 
			IPv4 Pointer Value is listed as "n/a", silently drop the packet.)
			</t>

                    <t hangText="Code 1 (Unrecognized Next Header type encountered):">
				Translate this to an
         			ICMPv4 protocol unreachable (Type 3, Code 2).  
			</t>

                    <t hangText="Code 2 (Unrecognized IPv6 option encountered):">
 Silently drop. 
			</t>

                  </list>

</t>

                <t hangText="Unknown error messages:">Silently drop.</t>
<t>
        <figure anchor="figure-pointervalue-v6-v4" title="Pointer Value for Translating from IPv6 to IPv4">
          <artwork align="center"><![CDATA[   
 +--------------------------------+--------------------------------+
 |   Original IPv6 Pointer Value  | Translated IPv4 Pointer Value  |
 +--------------------------------+--------------------------------+
 |  0  | Version/Traffic Class    |  0  | Version/IHL, Type Of Ser |
 |  1  | Traffic Class/Flow Label |  1  | Type Of Service          |
 | 2,3 | Flow Label               | n/a |                          |
 | 4,5 | Payload Length           |  2  | Total Length             |
 |  6  | Next Header              |  9  | Protocol                 |
 |  7  | Hop Limit                |  8  | Time to Live             |
 | 8-23| Source Address           | 12  | Source Address           |
 |24-39| Destination Address      | 16  | Destination Address      |
 +--------------------------------+--------------------------------+
]]></artwork>
        </figure>
</t>
                <t hangText="ICMP Error Payload:">

If the received ICMPv6 packet contains an ICMPv6 Extension 
<xref target="RFC4884"></xref>,
the translation of the ICMPv6 packet will cause the ICMPv4 packet 
to change length. When this occurs, the ICMPv6 Extension length 
attribute MUST be adjusted accordingly (e.g., shorter due to the 
translation from IPv6 to IPv4). 
For extensions not defined in 
<xref target="RFC4884"></xref>,
the translator passes the extensions as opaque bit strings and  
any IPv6 address literals contained therein will not be translated to IPv4 address literals; this may
cause problems with processing of those ICMP extensions.

			</t>
              </list></t>
          </list></t>
      </section>

      <section anchor="error64"
               title="Translating ICMPv6 Error Messages into ICMPv4">

        <t>There are some differences between the ICMPv4 and the ICMPv6 error
        message formats as detailed above. 


The ICMP error messages  containing the packet in error MUST be translated just like a normal IP packet (except that the TTL/Hop Limit value of the inner IPv4/IPv6 packet are not decremented).


        The translation of this
        "packet in error" is likely to change the length of the datagram; thus,
        the Total Length field in the outer IPv4 header MUST be
        updated.</t>
        <figure anchor="v6v4icmp" title="IPv6-to-IPv4 ICMP Error Translation">
          <artwork align="center"><![CDATA[
+-------------+                 +-------------+
|    IPv6     |                 |    IPv4     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|   ICMPv6    |                 |   ICMPv4    |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|    IPv6     |      ===>       |    IPv4     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|   Partial   |                 |   Partial   |
|  Transport- |                 |  Transport- |
|   Layer     |                 |   Layer     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
]]></artwork>
        </figure>
        <t>
   The translation of the inner IP header can be done by invoking 
the function that translated the outer IP headers. 
This process MUST stop at the first embedded header and drop the packet 
if it contains more embedded headers.
</t>
      </section>


      <section anchor="sending-icmp6" title="Generation of ICMPv6 Error Messages">
        <t>
		If the IPv6 packet is discarded, then the translator SHOULD send back an ICMPv6 error message to the original sender of the packet, 
		unless the discarded packet is itself an ICMPv6 message. 
	</t>

	<t>     The ICMPv6 message MUST have Type 1 (Destination Unreachable) and Code 1 (Communication with destination administratively prohibited),
		unless otherwise specified in this document or
		<xref target="RFC6146"/>.
		The translator SHOULD allow an administrator to configure whether the ICMPv6 error messages are sent, rate-limited, or not sent. 
	</t>
      </section>


      <section anchor="transport64" title="Transport-Layer Header Translation">

<t>
   If the address translation algorithm is not checksum neutral
   (see Section 4.1 of 
	<xref target="RFC6052"/>),
   the
   recalculation and updating of the transport-layer headers that
   contain pseudo-headers need to be performed.  Translators MUST do this for TCP, UDP,
   and ICMP.  
</t>

<t>
   Other transport protocols (e.g., DCCP) are OPTIONAL to support.
   In order to ease debugging and troubleshooting, translators MUST 
   forward all transport protocols as described in the "Protocol" step
   of <xref target="header64"/>.

</t>

      </section>

      <section anchor="when64" title="Knowing When to Translate">
        <t>
  If the IP/ICMP translator also provides a normal forwarding function, 
and the destination address is reachable by a
   more specific route without translation, the router MUST forward it
   without translating it. 

 When an IP/ICMP translator receives an IPv6
   datagram addressed to an IPv6 address representing a host in the IPv4 domain, the
   IPv6 packet MUST be translated to IPv4.

</t>
      </section>
    </section>


<section anchor="addr-algos" title="Mapping of IP Addresses">

<t>
The translator MUST support the stateless address mapping algorithm defined in <xref target="RFC6052"></xref>, which is the default behavior.  A workflow example is shown in 
<xref target="Appendix"></xref>
of this document.
Note that 
<xref target="RFC7136"></xref> updates 
<xref target="RFC4291"></xref>, which allows the use of unicast
addresses without u-bit, as long as they're not derived
from an IEEE MAC-layer address. Therefore, the address mapping algorithm defined in
<xref target="RFC6219"></xref> also complies with the IPv6 address architecture.
</t>

<t>
The stateless translator SHOULD support the explicit address mapping algorithm defined in <xref target="RFC7757"></xref>. 
</t>

<t>
The stateless translator SHOULD support 
<xref target="RFC6791"></xref> 
for handling ICMP/ICMPv6 packets.
</t>

<t>
Implementations may support both stateless and stateful translation modes
(e.g., <xref target="RFC6146">Network Address and Protocol Translation from
IPv6 Clients to IPv4 Servers (NAT64)</xref>).
</t>

<t>
Implementations may support stateless NAT64 function, e.g., MAP-T Customer
Edge (CE) or MAP-T Border Relay (BR) <xref target="RFC7599"></xref>.
</t>

</section>


<section anchor="icmp6-tbg" title="Special Considerations for ICMPv6 Packet Too Big">
<t>
A number of studies <xref target="ATOMIC" />
indicate that it not unusual for networks to drop ICMPv6 Packet Too Big error
messages. Such packet drops will result in PMTUD black holes <xref target="RFC2923"></xref>,
which can only be overcome with Packetization Layer Path MTU Discovery (PLPMTUD) 
<xref target="RFC4821"></xref>.
</t>
</section>

    <section anchor="Security" title="Security Considerations">
      <t>The use of stateless IP/ICMP translators does not introduce any new
      security issues beyond the security issues that are already present in
      the IPv4 and IPv6 protocols and in the routing protocols that are used
      to make the packets reach the translator.</t>

	<t>
There are potential issues that might arise by deriving an IPv4 address from 
an IPv6 address -- particularly addresses like broadcast or loopback addresses 
and the non-IPv4-translatable IPv6 addresses, etc.  
<xref target="RFC6052"/> 
addresses these issues.
	</t>

<t>
   The IPsec Authentication Header <xref target="RFC4302"></xref> cannot be
   used for NAT44 or NAT64.
</t>

<t>
   As with the network address translation of IPv4 to IPv4, packets with 
   tunnel mode Encapsulating Security Payload (ESP) can be translated since tunnel mode ESP does not 
   depend on header fields prior to the ESP header.  Similarly,
   transport mode ESP will fail with IPv6-to-IPv4 translation 
   unless checksum-neutral addresses are used.  In both cases, 
   the IPsec ESP endpoints will normally detect the presence of
   the translator and encapsulate ESP in UDP packets 
   <xref target="RFC3948"></xref>.
</t>

    </section>



  </middle>

  <back>

<references title="Normative References">

<?rfc include="reference.RFC.0768" ?>
<?rfc include="reference.RFC.0791" ?>
      <?rfc include="reference.RFC.0793" ?>
      <?rfc include="reference.RFC.2119" ?>
      <?rfc include="reference.RFC.1812" ?>
      <?rfc include="reference.RFC.4340" ?>
      <?rfc include="reference.RFC.4291" ?>
      <?rfc include="reference.RFC.4443" ?>
      <?rfc include="reference.RFC.5382" ?>
      <?rfc include="reference.RFC.4884" ?>
      <?rfc include="reference.RFC.5771" ?>
      <?rfc include="reference.RFC.3948" ?>
      <?rfc include="reference.RFC.6791" ?>
      <?rfc include="reference.RFC.6146" ?>
      <?rfc include="reference.RFC.6052" ?>
      <?rfc include="reference.RFC.6145" ?>
      <?rfc include="reference.RFC.7757" ?>

    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.6144" ?>
      <?rfc include="reference.RFC.1191" ?>
      <?rfc include="reference.RFC.2474" ?>
      <?rfc include="reference.RFC.2475" ?>
      <?rfc include="reference.RFC.2710" ?>
      <?rfc include="reference.RFC.2923" ?>
      <?rfc include="reference.RFC.3307" ?>
      <?rfc include="reference.RFC.3590" ?> 
      <?rfc include="reference.RFC.3810" ?>
      <?rfc include="reference.RFC.3849" ?>
      <?rfc include="reference.RFC.5737" ?>
      <?rfc include="reference.RFC.4302" ?>
      <?rfc include="reference.RFC.4821" ?>
      <?rfc include="reference.RFC.6219" ?>
      <?rfc include="reference.RFC.6691" ?>
      <?rfc include="reference.RFC.7136" ?>
      <?rfc include="reference.RFC.7599" ?>
      <?rfc include="reference.RFC.4787" ?>

      <!--draft-ietf-6man-deprecate-atomfrag-generation-06 IESG state AD
      Evaluation::Revised I-D Needed -->

<reference anchor='ATOMIC'>
<front>
<title>Generation of IPv6 Atomic Fragments Considered Harmful</title>

<author initials='F' surname='Gont' fullname='Fernando Gont'>
    <organization />
</author>

<author initials='S' surname='LIU' fullname='Shucheng LIU'>
    <organization />
</author>

<author initials='T' surname='Anderson' fullname='Tore Anderson'>
    <organization />
</author>

<date month='April' day='4' year='2016' />

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-6man-deprecate-atomfrag-generation-06' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-6man-deprecate-atomfrag-generation-06.txt' />
</reference>

<!--draft-ietf-6man-rfc2460bis-04 IESG state: I-D Exists -->
 
<reference anchor='IPv6'>
<front>
<title>Internet Protocol, Version 6 (IPv6) Specification</title>

<author initials='S' surname='Deering' fullname='Steve Deering'>
    <organization />
</author>

<author initials='R' surname='Hinden' fullname='Robert Hinden'>
    <organization />
</author>

<date month='March' day='21' year='2016' />

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-6man-rfc2460bis-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-6man-rfc2460bis-04.txt' />
</reference>


<reference anchor="Err3059" quote-title="false">
<front>
<title>Erratum ID 3059</title>
<author><organization>RFC Errata</organization></author>
<date month="" year="" />
</front>
<seriesInfo name="RFC" value="6145"/>
	</reference>

<reference anchor="Err3060" quote-title="false">
<front>
<title>Erratum ID 3060</title>
<author><organization>RFC Errata</organization></author>
<date month="" year="" />
</front>
<seriesInfo name="RFC" value="6145"/>
	</reference>

<reference anchor="Err3061" quote-title="false">
<front>
<title>Erratum ID 3061</title>
<author><organization>RFC Errata</organization></author>
<date month="" year="" />
</front>
<seriesInfo name="RFC" value="6145"/>
	</reference>

<reference anchor="Err4090" quote-title="false">
<front>
<title>Erratum ID 4090</title>
<author><organization>RFC Errata</organization></author>
<date month="" year="" />
</front>
<seriesInfo name="RFC" value="6145"/>
	</reference>

    </references>

  <section anchor="Appendix" title="Stateless Translation Workflow Example">
<t>

   A stateless translation workflow example is depicted in the following figure. The
documentation address blocks 2001:db8::/32 
<xref target="RFC3849"></xref>,
192.0.2.0/24, and 198.51.100.0/24 
<xref target="RFC5737"></xref>
are used in this example.

        <figure anchor="work-flow-example" title="Stateless Translation Workflow">
          <artwork align="center"><![CDATA[   
+--------------+                   +--------------+
| IPv4 network |                   | IPv6 network |
|              |     +-------+     |              |
|   +----+     |-----| XLAT  |---- |  +----+      |
|   | H4 |-----|     +-------+     |--| H6 |      |
|   +----+     |                   |  +----+      |
+--------------+                   +--------------+
]]></artwork>
        </figure>
</t>

<t>
A translator (XLAT) connects the IPv6 network to the IPv4 network. 
This XLAT uses the Network-Specific Prefix (NSP) 2001:db8:100::/40 
defined in
<xref target="RFC6052"/> 
to represent IPv4 addresses 
in the IPv6 address space (IPv4-converted addresses) and to represent 
IPv6 addresses (IPv4-translatable addresses) in the IPv4 address space. 
In this example, 192.0.2.0/24 is the IPv4 block of the corresponding IPv4-translatable 
addresses.
</t>

<t>
Based on the address mapping rule, the IPv6 node H6 has an 
IPv4-translatable IPv6 address 2001:db8:1c0:2:21:: 
(address mapping from 192.0.2.33).  The IPv4 node H4 has 
IPv4 address 198.51.100.2.
</t>

<t>
The IPv6 routing is configured in such a way that the 
IPv6 packets addressed to a destination address in 
2001:db8:100::/40 are routed to the IPv6 interface of the XLAT. 
</t>

<t>
The IPv4 routing is configured in such a way that the 
IPv4 packets addressed to a destination address in 
192.0.2.0/24 are routed to the IPv4 interface of the XLAT. 
</t>

<section anchor="h6" title="H6 Establishes Communication with H4">
<t>
The steps by which H6 establishes communication with H4 are:

<list style="numbers">
<t>
H6 performs the destination address mapping, so the IPv4-converted 
address 2001:db8:1c6:3364:2:: is formed from 198.51.100.2 based on 
the address mapping algorithm 
<xref target="RFC6052"/>.
</t>

<t>
H6 sends a packet to H4. The packet is sent from a source address 
2001:db8:1c0:2:21:: to a destination address 2001:db8:1c6:3364:2::.
</t>

<t>
The packet is routed to the IPv6 interface of the XLAT 
(since IPv6 routing is configured that way).
</t>

<t>
The XLAT receives the packet and performs the following actions:
<list style="symbols">
<t>
The XLAT translates the IPv6 header into an IPv4 header using 
the IP/ICMP Translation Algorithm defined in this document.
</t>
<t>
The XLAT includes 192.0.2.33 as the source address in the packet 
and 198.51.100.2 as the destination address in the packet.  
Note that 192.0.2.33 and 198.51.100.2 are extracted directly from 
the source IPv6 address 2001:db8:1c0:2:21:: (IPv4-translatable address) 
and destination IPv6 address 2001:db8:1c6:3364:2::
(IPv4-converted address) of the received IPv6 packet that is 
being translated.  
</t>
</list>
</t>

<t>
The XLAT sends the translated packet out of its IPv4 interface,
and the packet arrives at H4.
</t>

<t>
H4 node responds by sending a packet with destination 
address 192.0.2.33 and source address 198.51.100.2.
</t>

<t>
The packet is routed to the IPv4 interface of the XLAT 
(since IPv4 routing is configured that way). The XLAT 
performs the following operations:
<list style="symbols">
<t>
The XLAT translates the IPv4 header into an IPv6 header 
using the IP/ICMP Translation Algorithm defined in this 
document.
</t>
<t>
The XLAT includes 2001:db8:1c0:2:21:: as the destination 
address in the packet and 2001:db8:1c6:3364:2::
as the source address in the packet.  Note that 2001:db8:1c0:2:21:: 
and 2001:db8:1c6:3364:2:: are formed directly from the destination 
IPv4 address 192.0.2.33 and the source IPv4 address 198.51.100.2 of 
the received IPv4 packet that is being translated.
</t>

</list>
</t>

<t>
The translated packet is sent out of the IPv6 interface to H6.
</t>

</list>

</t>

<t>
The packet exchange between H6 and H4 continues until 
the session is finished.
</t>

</section>

<section anchor="h4" title="H4 Establishes Communication with H6">
<t>
The steps by which H4 establishes communication with H6 are:
<list style="numbers">
<t>
H4 performs the destination address mapping, 
so 192.0.2.33 is formed from the IPv4-translatable address 
2001:db8:1c0:2:21:: based on the address mapping algorithm <xref target="RFC6052"/>.
</t>

<t>
H4 sends a packet to H6. The packet is sent from a source 
address 198.51.100.2 to a destination address 192.0.2.33.
</t>

<t>
The packet is routed to the IPv4 interface of the XLAT 
(since IPv4 routing is configured that way).
</t>

<t>
The XLAT receives the packet and performs the following actions:
<list style="symbols">
<t>
The XLAT translates the IPv4 header into an IPv6 header using 
the IP/ICMP Translation Algorithm defined in this document.
</t>

<t>
The XLAT includes 2001:db8:1c6:3364:2:: as the source address 
in the packet and 2001:db8:1c0:2:21:: as the destination address 
in the packet.  Note that 2001:db8:1c6:3364:2:: 
(IPv4-converted address) and 2001:db8:1c0:2:21:: 
(IPv4-translatable address) are obtained directly from 
the source IPv4 address 198.51.100.2 and destination IPv4 
address 192.0.2.33 of the received IPv4 packet that 
is being translated.  
</t>

</list>
</t>

<t>
The XLAT sends the translated packet out its IPv6 interface, 
and the packet arrives at H6.
</t>

<t>
H6 node responds by sending a packet with destination 
address 2001:db8:1c6:3364:2:: and source 
address 2001:db8:1c0:2:21::.
</t>

<t>
The packet is routed to the IPv6 interface of the 
XLAT (since IPv6 routing is configured that way). 
The XLAT performs the following operations:
<list style="symbols">
<t>
The XLAT translates the IPv6 header into an IPv4 
header using the IP/ICMP Translation Algorithm 
defined in this document.
</t>

<t>
The XLAT includes 198.51.100.2 as the destination address in the packet 
and 192.0.2.33   as the source address in the packet.  
Note that 198.51.100.2 and 192.0.2.33 are formed directly from 
the destination IPv6 address 2001:db8:1c6:3364:2:: and 
source IPv6 address 2001:db8:1c0:2:21:: of the received 
IPv6 packet that is being translated. 
</t>

</list>
</t>

<t>
The translated packet is sent out the IPv4 interface to H4.
</t>

</list>
</t>

<t>
The packet exchange between H4 and H6 continues until the session is finished.
</t>

</section>

    </section> 

    <section anchor="Acknowledgements" title="Acknowledgements" numbered="no">
<t>

 Gandhar Gokhale, Wesley Eddy, and Fernando Gont submitted and
 handled the errata reports on <xref target="RFC6145"/>.  Fernando Gont, Will
 (Shucheng) Liu, and Tore Anderson provided the security analysis
 and the suggestions for updates concerning atomic fragments.  In
 addition, Tore Anderson and Alberto Leiva provided the proposal of
 the Explicit Address Mapping (EAM) algorithm.
</t>
    </section>

  </back>
</rfc>
