<?xml version="1.0" encoding="US-ASCII"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc sortrefs="yes"?>
<?rfc iprnotified="no"?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc number="8138"
     ipr="trust200902" 
     submissionType="IETF"
     consensus="yes"
     category="std">

  <front>

    <title abbrev="6LoWPAN Routing Header">IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Routing Header</title>

    <author initials="P." surname="Thubert" fullname="Pascal Thubert" role="editor">
      <organization abbrev="Cisco">Cisco Systems</organization>
      <address>
        <postal>
          <street>Building D - Regus</street> <street>45 Allee des Ormes</street> <street>BP1200</street>
          <city>MOUGINS - Sophia Antipolis</city>
          <code>06254</code>
          <country>France</country>
        </postal>
        <phone>+33 4 97 23 26 34</phone>
        <email>pthubert@cisco.com</email>
      </address>
    </author>
    <author initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization abbrev="Uni Bremen TZI">Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </author>
    <author initials="L." surname="Toutain" fullname="Laurent Toutain">
      <organization abbrev="IMT Atlantique">IMT Atlantique</organization>
      <address>
        <postal>
          <street>2 rue de la Chataigneraie</street> <street>CS 17607</street>
          <city>Cesson-Sevigne Cedex</city>
          <code>35576</code>
          <country>France</country>
        </postal>
        <email>Laurent.Toutain@IMT-Atlantique.fr</email>
      </address>
    </author>
    <author initials="R." surname="Cragie" fullname="Robert Cragie">
      <organization abbrev="ARM">ARM Ltd.</organization>
      <address>
        <postal>
          <street>110 Fulbourn Road</street>
          <city>Cambridge</city>
          <code>CB1 9NJ</code>
          <country>United Kingdom</country>
        </postal>
        <email>robert.cragie@arm.com</email>
      </address>
    </author>

    <date year="2017" month="April"/>

    <area>Internet</area>
    <workgroup>roll</workgroup>
    
<abstract>

<t>This specification introduces a new IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) dispatch type for use in
6LoWPAN route-over topologies, which initially covers the needs of Routing
Protocol for Low-Power and Lossy Networks (RPL) data packet compression (RFC 6550). Using this dispatch type,
this specification defines a method to compress the RPL Option (RFC 6553) information and Routing Header
type 3 (RFC 6554), an efficient IP-in-IP technique, and is extensible for more applications.</t>



    </abstract>


  </front>

  <middle>



<section anchor="introduction" title="Introduction">

<t>The design of Low-Power and Lossy Networks (LLNs) is generally
focused on saving
energy, a very constrained resource in most cases. The other
constraints, such as the memory capacity and the duty cycling of the LLN
devices, derive from that primary concern. Energy is often available
from primary batteries that are expected to last for years, or it is scavenged from the
environment in very limited quantities. Any protocol that is intended for
use in LLNs must be designed with the primary concern of saving energy as
a strict requirement.</t>

<t>Controlling the amount of data transmission is one possible venue to save
energy. In a number of LLN standards, the frame size is limited to much
smaller values than the guaranteed IPv6 Maximum Transmission Unit (MTU) of 1280 bytes.
In particular, an LLN that relies on the classical Physical Layer (PHY)
of IEEE 802.15.4 <xref target="IEEE.802.15.4"/> is limited to 127 bytes
per frame. The need to compress IPv6 packets over IEEE 802.15.4 led to
the writing of <xref target="RFC6282">"Compression Format for IPv6 Datagrams over IEEE 802.15.4-Based Networks"</xref>.</t>

<t>Innovative route-over techniques have been and still are being developed for
routing inside an LLN. Generally, such techniques require additional
information in the packet to provide loop prevention and to indicate
information such as flow identification,
source routing information, etc.</t>

<t>For reasons such as security and the capability to send ICMPv6 errors
(see <xref target="RFC4443">"Internet Control Message Protocol (ICMPv6) for the
Internet Protocol Version 6 (IPv6) Specification"</xref>)
back to the source, an original packet must not be tampered with, and any
information that must be inserted in or removed from an IPv6 packet must be
placed in an extra IP-in-IP encapsulation.</t>

<t>This is the case when the additional routing information is inserted by a router
on the path of a packet, for instance, the root of a mesh, as opposed to the
source node, with the Non-Storing mode of the
<xref target="RFC6550">"RPL: IPv6 Routing Protocol for Low-Power and Lossy Networks"</xref>.</t>

<t>This is also the case when some routing information must be removed from a
packet that flows outside the LLN.</t>

<t><xref target="RPL-INFO">"When to use RFC 6553, RFC 6554 and IPv6-in-IPv6"</xref>
details different cases where IPv6 headers defined in
<xref target="RFC6553">the RPL Option for Carrying RPL Information in Data-Plane Datagrams</xref>,
<xref target="RFC6554">Header for Source Routes with RPL</xref>, and IPv6-in-IPv6 encapsulation,
are inserted or removed from packets in LLN environments operating RPL.</t>

<t>When using RFC 6282 <xref target="RFC6282"/>, the outer IP header of an IP-in-IP encapsulation 
may be compressed down to 2 octets in stateless compression and down to 3 octets
in stateful compression when context information must be added.</t>

<figure title="LOWPAN_IPHC Base Encoding (RFC 6282)" anchor="encaps6282"><artwork><![CDATA[
   0                                       1
   0   1   2   3   4   5   6   7   8   9   0   1   2   3   4   5
 +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 | 0 | 1 | 1 |  TF   |NH | HLIM  |CID|SAC|  SAM  | M |DAC|  DAM  |
 +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
]]></artwork></figure>

<t>The stateless compression of an IPv6 address can only happen if the IPv6 address
can de deduced from the Media Access Control (MAC) addresses, meaning that the IP endpoint is also the
MAC-layer endpoint. This is usually not the case in a RPL network, which is
generally a multi-hop route-over (i.e., operated at Layer 3) network.
A better compression,
which does not involve variable compressions depending on the hop in the mesh,
can be achieved based on the fact that the outer encapsulation is usually between
the source (or destination) of the inner packet and the root. 
Also, the inner IP header can only be compressed by RFC 6282 <xref target="RFC6282"/> if all the fields
preceding it are also compressed.  This specification makes the inner IP header
the first header to be compressed by RFC  6282 <xref target="RFC6282"/>, and it keeps the inner packet
encoded the same way whether or not it is encapsulated, thus preserving existing
implementations.</t>

<t>As an example, RPL <xref target="RFC6550"/> is designed to optimize the routing operations in
constrained LLNs.
As part of this optimization, RPL requires the addition of RPL Packet Information
(RPI) in every packet, as defined in Section 11.2 of RFC 6550 <xref target="RFC6550"/>.</t>

<t><xref target="RFC6553">"The Routing Protocol for Low-Power and Lossy
Networks (RPL) Option for Carrying RPL Information in Data-Plane Datagrams"</xref>
specification indicates how the RPI can be placed in a RPL Option (RPL-OPT) that 
is placed in an IPv6 Hop-by-Hop header.</t>

<t>This representation demands a total of 8 bytes, while, in most cases, the actual
RPI payload requires only 19 bits.  Since the Hop-by-Hop header must not
flow outside of the RPL domain, it must be inserted in packets 
entering the domain and be removed from packets that leave the domain.
In both cases, this operation implies an IP-in-IP encapsulation.</t>

<t>Additionally, in the case of the Non-Storing Mode of Operation (MOP), RPL
requires a Source Routing Header (SRH) in all packets that are routed down a RPL
graph. For that purpose, 
<xref target="RFC6554">"An IPv6 Routing Header for Source Routes with the
Routing Protocol for Low-Power and Lossy Networks (RPL)"</xref> 
 defines the type 3 Routing Header for IPv6 (RH3).</t>

<figure title="IP-in-IP Encapsulation within the LLN" anchor="encaps"><artwork><![CDATA[
       ------+---------                           ^
             |          Internet                  |
             |                                    | Native IPv6
          +-----+                                 |
          |     | Border Router (RPL Root)      + | +
          |     |                               | | |
          +-----+                               | | | tunneled
             |                                  | | | using
       o    o   o    o                          | | | IPv6-in-
   o o   o  o   o  o  o o   o                   | | | IPv6 and
  o  o o  o o    o   o   o  o  o                | | | RPL SRH
  o   o    o  o     o  o    o  o  o             | | |
 o  o   o  o   o         o   o o                | | |
 o          o             o     o               + v +
                   LLN                                       

]]></artwork></figure>

<t>With Non-Storing RPL, even if the source is a node in the same LLN, the packet must first
reach up the graph to the root so that the root can insert the SRH to go down
the graph. In any fashion, whether the packet was originated in a node
in the LLN or outside the LLN, and regardless of whether or not the packet stays within
the LLN, as long as the source of the packet is not the root itself,
the source-routing operation also implies an IP-in-IP encapsulation at the root
in order to insert the SRH.</t>

<t><xref target="IPv6-ARCH">"An Architecture for IPv6 over the TSCH mode of IEEE 802.15.4"</xref> specifies the
operation of IPv6 over the mode of operation described in <xref target="RFC7554">"Using IEEE 802.15.4e
Time-Slotted Channel Hopping (TSCH) in the Internet of Things (IoT): Problem Statement"</xref>. The architecture requires the
use of both RPL and the 6lo adaptation layer over IEEE 802.15.4.
Because it inherits the constraints on frame size
from the MAC layer, 6TiSCH cannot afford to allocate 8 bytes per packet
on the RPI, hence the requirement for 6LoWPAN header compression of the RPI.</t>

<t>An extensible compression technique is required that simplifies IP-in-IP
encapsulation when it is needed and optimally compresses existing routing
artifacts found in RPL LLNs.</t>

<t>This specification extends the 6lo adaptation layer framework
(<xref target="RFC4944"/> <xref target="RFC6282"/>) so
as to carry routing information for route-over networks based on RPL.
It includes the formats necessary for RPL and is extensible
for additional formats.</t>

</section>
<section anchor="terminology" title="Terminology">

<!-- [rfced] Throughout the text, the following terminology appears to be used 
inconsistently.  

type vs Type

Please review these occurrences and let us know if/how they may be made 
consistent.  

-->


<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
"SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY",
and "OPTIONAL" in this document are to be interpreted as
described in RFC 2119 <xref target="RFC2119"/>.</t>

<t>This document uses the terms from, and is consistent with, <xref target="RFC7102">"Terms Used in Routing for Low-Power and
Lossy Networks"</xref>
and RPL
<xref target="RFC6550"/>.</t>

<t>The terms "route-over" and "mesh-under" are defined in RFC 6775 <xref target="RFC6775"/>.</t>

<t>Other terms in use in LLNs are found in
<xref target="RFC7228">"Terminology for Constrained-Node Networks"</xref>.</t>

<t>The term "byte" is used in its now customary sense as a synonym for "octet".</t>

</section>
<section anchor="updating-rfc-4944" title="Using the Page Dispatch">

<t>The <xref target="RFC8025">"IPv6 over Low-Power Wireless Personal Area
Network (6LoWPAN) Paging Dispatch"</xref> specification extends 
the 6lo adaptation layer framework (<xref target="RFC4944"/> <xref target="RFC6282"/>)
by introducing a concept of "context" in the 6LoWPAN parser,
a context being identified by a Page number. The specification defines 16 Pages.</t>

<t>This document operates within Page 1, which is indicated by a
dispatch value of binary 11110001.</t>

<section anchor="NewLoRH" title="New Routing Header Dispatch (6LoRH)">

<t>This specification introduces a new 6LoWPAN Routing Header (6LoRH) 
to carry IPv6 routing information. The 6LoRH may contain source routing
information such as a compressed form of SRH, as well as other sorts of
routing information such as the RPI and IP-in-IP encapsulation.</t>

<t>The 6LoRH is expressed in a 6loWPAN packet as a Type-Length-Value (TLV) field,
which is extensible for future use.</t>

<t>It is expected that a router that does not recognize the 6LoRH general format
detailed in <xref target="rhf"/> will drop the packet when a 6LoRH is present.</t>
<t>This specification uses the bit pattern 10xxxxxx 
in Page 1 for the new 6LoRH Dispatch.

<xref target="rhf"/> describes how RPL artifacts in data packets can be compressed
as 6LoRH headers.</t>
</section>
<section anchor="placement_6LoRHC" title="Placement of 6LoRH Headers">

<section anchor="placement_out_6LoRHC" title="Relative to Non-6LoRH Headers">

<t>In a zone of a packet where Page 1 is active (that is, once the Page 1 Paging
Dispatch is parsed, and until another Paging Dispatch is parsed as described in
the 6LoWPAN Paging Dispatch specification <xref target="RFC8025"/>),
the parsing of the packet MUST follow this specification if the 6LoRH Bit Pattern
(see <xref target="NewLoRH"/>) is found.</t>

<t>With this specification, the 6LoRH Dispatch is only defined in
Page&nbsp;1, so it MUST be placed in the packet in a zone where the
Page 1 context is active.</t>

<t>Because a 6LoRH header requires a Page 1 context, it MUST always be placed
after any Fragmentation Header and/or Mesh Header as defined in RFC 4944 <xref target="RFC4944"/>.</t>

<t>A 6LoRH header MUST always be placed before the LOWPAN_IPHC as defined in RFC 6282
<xref target="RFC6282"/>. It is designed in such a fashion that
placing or removing a header that is encoded with 6LoRH does not modify the part
of the packet that is encoded with LOWPAN_IPHC, whether or not there is an IP-in-IP
encapsulation. For instance, the final destination of the packet is
always the one in the LOWPAN_IPHC, whether or not there is a Routing Header.</t>

</section>
<section anchor="placement_in_6LoRHC" title="Relative to Other 6LoRH Headers">

<t>The <xref target="RFC2460">"Internet Protocol, Version 6 (IPv6) Specification"</xref>
defines chains of headers that are introduced by an IPv6 header
and terminated by either another IPv6 header (IP-in-IP) or an Upper-Layer Protocol
(ULP) header. When an outer header is stripped from the packet, the whole chain
goes with it. When one or more headers are inserted by an intermediate router,
that router normally chains the headers and encapsulates the result in IP-in-IP.</t>

<t>With this specification, the chains of headers MUST be compressed in the same
order as they appear in the uncompressed form of the packet. This means that if
there is more than one nested IP-in-IP encapsulation, the first IP-in-IP
encapsulation, with all its chain of headers, is encoded first in the compressed
form.</t>

<t>In the compressed form of a packet that has a Source Route or a Hop-by-Hop (HbH)
Options Header <xref target="RFC2460"/> after the inner
IPv6 header (e.g., if there is no IP-in-IP encapsulation), these headers are
placed in the 6LoRH form before the 6LOWPAN_IPHC that represents the IPv6 header
(see <xref target="placement_out_6LoRHC"/>). If this packet gets encapsulated and some other SRH or
HbH Options Headers are added as part of the encapsulation, placing the 6LoRH
headers next to one another may present an ambiguity on which header belongs to
which chain in the uncompressed form.</t>

<t>In order to disambiguate the headers that follow the inner IPv6 header in the
uncompressed form from the headers that follow the outer IP-in-IP header, it is
REQUIRED that the compressed IP-in-IP header is placed last in the encoded chain.
This means that the 6LoRH headers that are found after the last compressed
IP-in-IP header are to be inserted after the IPv6 header that is encoded with
the 6LOWPAN_IPHC when decompressing the packet.</t>

<t>With regard to the relative placement of the SRH and the RPI in the compressed
form, it is a design point for this specification that the SRH entries are
consumed as the packet progresses down the LLN (see <xref target="SRH-design-pop"/>).
In order to make this operation simpler in the compressed form, it is REQUIRED
that in the compressed form, the addresses along the source route path are
encoded in the order of the path, and that the compressed SRH are placed before
the compressed RPI.</t>

</section>
</section>
</section>
<section anchor="rhf" title="6LoWPAN Routing Header General Format">

<t>The 6LoRH uses the Dispatch Value Bit Pattern of 10xxxxxx in Page 1.</t>

<t>The Dispatch Value Bit Pattern is split in two forms of 6LoRH:</t>

<t><list style='empty'>
  <t>Elective (6LoRHE), which may skipped if not understood</t>
</list></t>

<t><list style='empty'>
  <t>Critical (6LoRHC), which may not be ignored</t>
</list></t>

<t>For each form, a Type field is used to encode the type of 6LoRH.</t>

<t>Note that there is a different registry for the Type field of each form of 6LoRH.</t>

<t>This means that a value for the Type that is defined for one form of 6LoRH
may be redefined in the future for the other form.</t>

<section anchor="LoRHE" title="Elective Format">

<t>The 6LoRHE uses the Dispatch Value Bit Pattern of 101xxxxx.
A 6LoRHE may be ignored and skipped in parsing.
If it is ignored, the 6LoRHE is forwarded with no change inside the LLN.</t>

<figure title="Elective 6LoWPAN Routing Header" anchor="rtghe"><artwork><![CDATA[
    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-       ...        -+
   |1|0|1| Length  |      Type     |                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-       ...        -+
                                    <--    Length    -->
]]></artwork></figure>

<t><list style="hanging" hangIndent="6">
  <t hangText='Length:'>
  Length of the 6LoRHE expressed in bytes, excluding the first 2 bytes. 
This enables a node to skip a 6LoRHE header that it does not support and/or 
cannot parse, for instance, if the Type is not recognized.</t>
  <t hangText='Type:'>
  Type of the 6LoRHE</t>
</list></t>

</section>
<section anchor="LoRHC" title="Critical Format">

<t>The 6LoRHC uses the Dispatch Value Bit Pattern of 100xxxxx.</t>

<t>A node that does not support the 6LoRHC Type MUST silently discard the packet.</t>

<t>Note: A situation where a node receives a message with a Critical 6LoWPAN Routing Header
that it does not understand should not occur and is an administrative error,
see <xref target="management-considerations"/>.</t>

<figure title="Critical 6LoWPAN Routing Header" anchor="rtghc"><artwork><![CDATA[
  0                   1
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-              ...               -+
 |1|0|0|   TSE   |      Type     |                                  |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-              ...               -+
                                  <-- Length implied by Type/TSE -->
]]></artwork></figure>

<t><list style="hanging" hangIndent="6">
  <t hangText='Type-Specific Extension (TSE):'>
  The meaning depends on the Type, which must be known in all of the nodes.  The interpretation of the TSE depends on the Type field that follows. For instance, it may be used to transport control bits, the number of elements in an array, or the length of the remainder of the 6LoRHC expressed in a unit other than bytes.</t>
  <t hangText='Type:'>
  Type of the 6LoRHC</t>
</list></t>

</section>
<section anchor="SRH-6LoRH-addrcomp" title="Compressing Addresses">

<t>The general technique used in this document to compress an address is first to determine
a reference that has a long prefix match with this address and then elide that matching
piece. In order to reconstruct the compressed address, the receiving node will perform
the process of coalescence described in <xref target="SRH-6LoRH-coalescence"/>.</t>

<t>One possible reference is the root of the RPL Destination-Oriented Directed
Acyclic Graph (DODAG) that is being traversed. It
is used by 6LoRH as the reference to compress an outer IP header in case of an
IP-in-IP encapsulation. If the root is the source of the packet, this
technique allows one to fully elide the source address in the compressed form of the IP
header. If the root is not the encapsulator, then the Encapsulator Address may still be
compressed using the root as a reference. How the address of the root is determined is
discussed in <xref target="find-root"/>.</t>

<t>Once the address of the source of the packet is determined, it becomes the reference
for the compression of the addresses that are located in compressed SRH headers that
are present inside the IP-in-IP encapsulation in the uncompressed form.</t>

<section anchor="SRH-6LoRH-coalescence" title="Coalescence">

<t>An IPv6 compressed address is coalesced with a reference address by overriding
the N rightmost bytes of the reference address with the compressed address,
where N is the length of the compressed address, as indicated by the Type of the
SRH-6LoRH header in <xref target="SRHLoRHtype"/>.</t>

<t>The reference address MAY be a compressed address as well, in which case,
it MUST be compressed in a form that is of an equal or greater length than
the address that is being coalesced.</t>

<t>A compressed address is expanded by coalescing it with a reference address. In
the particular case of a Type 4 SRH-6LoRH, the address is expressed in full and
the coalescence is a complete override as illustrated in <xref target="SRHCoalesce"/>.</t>

<figure title="Coalescing Addresses" anchor="SRHCoalesce"><artwork><![CDATA[
RRRRRRRRRRRRRRRRRRR  A reference address, which may be 
                     compressed or not

            CCCCCCC  A compressed address, which may be 
                     shorter or the same as the reference
             
RRRRRRRRRRRRCCCCCCC  A coalesced address, which may be the 
                     same compression as the reference
]]></artwork></figure>

</section>
<section anchor="find-root" title="DODAG Root Address Determination">

<t>Stateful address compression requires that some state is installed in the devices
to store the compression information that is elided from the packet.
That state is stored in an abstract context table, and some form of index is found
in the packet to obtain the compression information from the context table.</t>

<t>With RFC 6282 <xref target="RFC6282"/>, the state is provided to the stack by the
<xref target="RFC6775">6LoWPAN Neighbor Discovery Protocol (NDP)</xref>. 
NDP exchanges the context through the 6LoWPAN
Context Option in Router Advertisement (RA) messages. In the compressed form of
the packet, the context can be signaled in a Context Identifier Extension.</t>

<t>With this specification, the compression information is provided to the stack by
RPL, and RPL exchanges it through the DODAGID field in the DAG Information Object
(DIO) messages, as described in more detail below. In the compressed form of
the packet, the context can be signaled by the RPLInstanceID in the RPI.</t>

<t>With RPL <xref target="RFC6550"/>, the address of the DODAG root is known from the DODAGID 
field 
of the DIO messages. For a Global Instance, the RPLInstanceID that is present in
the RPI is enough information to identify the DODAG that this node participates
with and its associated root. But, for a Local Instance, the address of the root
MUST be explicit, either in some device configuration or signaled in the packet,
as the source or the destination address, respectively.</t>

<t>When implicit, the address of the DODAG root MUST be determined as follows:</t>

<t><list style='empty'>
  <t>If the whole network is a single DODAG, then the root can be well-known and does
not need to be signaled in the packets. But, since RPL does not expose that
property, it can only be known by a configuration applied to all nodes.</t>
</list></t>

<t><list style='empty'>
  <t>Else, the router that encapsulates the packet and compresses it with this
specification MUST also place an RPI in the packet as prescribed by RPL 
to enable the identification of the DODAG. The RPI must be present even in the
case when the router also places an SRH header in the packet.</t>
</list></t>

<t>It is expected that the RPL implementation maintains an abstract context table,
indexed by Global RPLInstanceID, that provides the address of the root of the
DODAG that this node participates in for that particular RPL Instance.</t>

</section>
</section>
</section>
<section anchor="SRH-6LoRH" title="The SRH-6LoRH Header">

<section anchor="SRH-6LoRH-encoding" title="Encoding">


<t>A Source Routing Header 6LoRH (SRH-6LoRH)
provides a compressed form for the SRH, as defined
in RFC 6554 <xref target="RFC6554"/>, for use by RPL routers.</t>

<t>One or more SRH-6LoRH header(s) MAY be placed in a 6LoWPAN packet.</t>

<t>If a non-RPL router receives a packet with an SRH-6LoRH header, 
there was a routing or a configuration error (see <xref target="management-considerations"/>).</t>

<t>The desired reaction for the non-RPL router is to drop the packet, as
opposed to skipping the header and forwarding the packet.</t>

<t>The Dispatch Value Bit Pattern for the SRH-6LoRH header indicates it is Critical.
Routers that understand the 6LoRH general format detailed in <xref target="rhf"/> cannot
ignore a 6LoRH header of this type and will drop the packet if it is unknown to them.</t>

<figure title="The SRH-6LoRH" anchor="SRHLoRH"><artwork><![CDATA[
    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    -+-    -+ ... +-    -+
   |1|0|0|  Size   |6LoRH Type 0..4| Hop1 | Hop2 |     | HopN |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    -+-    -+ ... +-    -+
   
             Where N = Size + 1
]]></artwork></figure>

<t>The 6LoRH Type of an SRH-6LoRH header indicates the compression level used for that header.</t>

<t>The fields following the 6LoRH Type are compressed addresses indicating the consecutive
hops and are ordered from the first to the last hop.</t>

<t>All the addresses in a given SRH-6LoRH header MUST be compressed in
an identical fashion, so the Length of the compressed form is the same for all.</t>

<t>In order to get different degrees of compression, multiple consecutive SRH-6LoRH
headers MUST be used.</t>

<t>Type 0 means that the address is compressed down to one byte, whereas Type 4
means that the address is provided in full in the SRH-6LoRH with no compression.
The complete list of Types of SRH-6LoRH and the corresponding compression level 
are provided in <xref target="SRHLoRHtype"/>:</t>

<figure title="The SRH-6LoRH Types" anchor="SRHLoRHtype"><artwork><![CDATA[
  +-----------+----------------------+
  |   6LoRH   | Length of compressed |
  |   Type    | IPv6 address (bytes) |
  +-----------+----------------------+
  |    0      |       1              |
  |    1      |       2              |
  |    2      |       4              |
  |    3      |       8              |
  |    4      |      16              |
  +-----------+----------------------+
]]></artwork></figure>

<t>In the case of an SRH-6LoRH header, the TSE field is used as a Size,
which encodes the number of hops minus 1; so a Size of 0 means one
hop, and the maximum that can be encoded is 32 hops.  (If more than
32 hops need to be expressed, a sequence of SRH-6LoRH elements can be
employed.) The result is that the Length, in bytes, of an SRH-6LoRH header is:</t>

<t>2 + Length_of_compressed_IPv6_address * (Size + 1)</t>

</section>
<section anchor="SRH-6LoRH-operation" title="SRH-6LoRH General Operation">

<section anchor="SRH-6LoRH-operation-uncomp" title="Uncompressed SRH Operation">

<t>In the uncompressed form, when the root generates or forwards a packet in
Non-Storing mode, it needs to include a Source Routing Header <xref target="RFC6554"/>
to signal a strict source route path to a final destination down the DODAG.</t>

<t>All the hops along the path, except the first one, are encoded in order in the SRH.
The last entry in the SRH is the final destination; the destination in the
IPv6 header is the first hop along the source route path. The intermediate hops
perform a swap and the Segments Left field indicates the active entry in the
Routing Header <xref target="RFC2460"/>.</t>

<t>The current destination of the packet, which is the
termination of the current segment, is indicated at all times by the destination
address of the IPv6 header.</t>

</section>
<section anchor="SRH-6LoRH-operation-comp" title="6LoRH-Compressed SRH Operation">

<t>The handling of the SRH-6LoRH is different: there is no swap, and a forwarding
router that corresponds to the first entry in the first SRH-6LoRH, upon reception
of a packet, effectively consumes that entry when forwarding. This means that the
size of a compressed source-routed packet decreases as the packet progresses
along its path and that the routing information is lost along the way. This also
means that an SRH encoded with 6LoRH is not recoverable and cannot be protected.</t>

<t>When compressed with this specification, all the remaining hops MUST be encoded
in order in one or more consecutive SRH-6LoRH headers. Whether or not there
is an SRH-6LoRH header present, the address of the final destination is indicated
in the LOWPAN_IPHC at all times along the path. Examples of this are provided in
<xref target="examples"/>.</t>

<t>The current destination (termination of the current segment) for a compressed
source-routed packet is indicated in the first entry of the first SRH-6LoRH.
In strict source routing, that entry MUST match an address of the router that
receives the packet.</t>

<t>The last entry in the last SRH-6LoRH is the last router on the way to the final
destination in the LLN. This router can be the final destination if it is found
desirable to carry a whole IP-in-IP encapsulation all the way. Else, it is the
RPL parent of the final destination, or a router acting at 6LoWPAN Router (6LR) <xref target="RFC6775"/> for
the destination host, and it is advertising the host as an external route to RPL.</t>

<t>If the SRH-6LoRH header is contained in an IP-in-IP encapsulation, the last router
removes the whole chain of headers. Otherwise, it removes the SRH-6LoRH header
only.</t>

</section>
<section anchor="SRH-6LoRH-operation-iphc" title="Inner LOWPAN_IPHC Compression">

<t>6LoWPAN ND <xref target="RFC6282"/> is designed to support more than one IPv6 address
per node and per Interface Identifier (IID); an IID is typically derived
from a MAC address to optimize the LOWPAN_IPHC compression.</t>

<t>Link-local addresses are compressed with stateless address compression (S/DAC=0).
The other addresses are derived from different prefixes, and they can be compressed
with stateful address compression based on a context (S/DAC=1).</t>

<t>But, stateless compression is only defined for the specific link-local prefix as
opposed to the prefix in an encapsulating header. And with stateful compression,
the compression reference is found in a context, as opposed to an encapsulating
header.</t>

<t>The result is that, in the case of an IP-in-IP encapsulation, it is possible to
compress an inner source (respective destination) IP address in a LOWPAN_IPHC
based on the encapsulating IP header only if stateful (context-based) compression
is used. The compression will operate only if the IID in the source
(respective destination) IP address in the outer and inner headers match, which usually
means that they refer to the same node. This is encoded as S/DAC = 1 and S/AM=11.
It must be noted that the outer destination address that is used to compress the
inner destination address is the last entry in the last SRH-6LoRH header.</t>

</section>
</section>
<section anchor="SRH-design-pop" title="The Design Point of Popping Entries">

<t>In order to save energy and to optimize the chances of transmission success on
lossy media, it is a design point for this specification that the entries in the
SRH that have been used are removed from the packet. This creates a discrepancy
from the art of IPv6, where Routing Headers are mutable but recoverable.</t>

<t>With this specification, the packet can be expanded at any hop into a valid IPv6 
packet, including an SRH, and compressed back. But the packet, as decompressed
along the way, will not carry all the consumed addresses that packet would have
if it had been forwarded in the uncompressed form.</t>

<t>It is noted that:</t>

<t><list style='empty'>
  <t>The value of keeping the whole RH in an IPv6 header is for the receiver to
  reverse it to use the symmetrical path on the way back.</t>
</list></t>

<t><list style='empty'>
  <t>It is generally not a good idea to reverse a Routing Header. The RH may have
  been used to stay away from the shortest path for some reason that is only
  valid on the way in (segment routing).</t>
</list></t>

<t><list style='empty'>
  <t>There is no use in reversing an RH in the present RPL specifications.</t>
</list></t>

<t><list style='empty'>
  <t>Point-to-Point (P2P) RPL reverses a path that was learned reactively as a part of the protocol
  operation, which is probably a cleaner way than a reversed echo on the data
  path.</t>
</list></t>

<t><list style='empty'>
  <t>Reversing a header is discouraged (by RFC 2460 <xref target="RFC2460"/>)
  for Redirected Header Option (RHO) unless it is
  authenticated, which requires an Authentication Header (AH). There is no
  definition of an AH operation for SRH, and there is no indication that the
  need exists in LLNs.</t>
</list></t>

<t><list style='empty'>
  <t>AH does not protect the RH on the way. AH is a validation at
  the receiver with the sole value of enabling the receiver to reverse it.</t>
</list></t>

<t><list style='empty'>
  <t>A RPL domain is usually protected by L2 security, which secures both RPL
  itself and the RH in the packets at every hop. This is a better security than
  that provided by AH.</t>
</list></t>

<t>In summary, the benefit of saving energy and lowering the chances of loss by
sending smaller frames over the LLN are seen as overwhelming compared to the
value of possibly reversing the header.</t>

</section>
<section anchor="sig-comp-ref" title="Compression Reference for SRH-6LoRH Header Entries">

<t>In order to optimize the compression of IP addresses present in the SRH headers,
this specification requires that the 6LoWPAN layer identifies an address that is
used as a reference for the compression.</t>

<t>With this specification, the Compression Reference for the first address found
in an SRH header is the source of the IPv6 packet, and then the reference for
each subsequent entry is the address of its predecessor once it is uncompressed.</t>

<t>With RPL <xref target="RFC6550"/>, an SRH header may only be present in Non-Storing mode, and 
it may only be placed in the packet by the root of the DODAG, which must be the
source of the resulting IPv6 packet <xref target="RFC2460"/>. In this case, the address used
as Compression Reference is the address of the root.</t>

<t>The Compression Reference MUST be determined as follows:</t>
<t><list style="empty">

<t>The reference address may be obtained by configuration. The configuration may
indicate either the address in full or the identifier of a 6LoWPAN Context that
carries the address <xref target="RFC6775"/>, for instance, one of the 16 Context Identifiers
used in LOWPAN_IPHC <xref target="RFC6282"/>.</t>

<t>Else, if there is no IP-in-IP encapsulation, the source address in the IPv6
header that is compressed with LOWPAN_IPHC is the reference for the compression.</t>

<t>Else, if the IP-in-IP compression specified in this document is used and the
Encapsulator Address is provided, then the Encapsulator Address is the reference.</t>

<t>Else, meaning that the IP-in-IP compression specified in this document is used and
the encapsulator is implicitly the root, the address of the root is the
reference.</t>
</list></t>

</section>
<section anchor="SRH-6LoRH-popping" title="Popping Headers">

<t>Upon reception, the router checks whether the address in the first entry of the
first SRH-6LoRH is one of its own addresses. If that is the case, the router MUST consume that
entry before forwarding, which is an action of popping from a stack, where the
stack is effectively the sequence of entries in consecutive SRH-6LoRH headers.</t>

<t>Popping an entry of an SRH-6LoRH header is a recursive action performed as
follows:</t>
<t><list style="empty">
<t>If the Size of the current SRH-6LoRH header is 1 or more (indicating that
there are at least 2 entries in the header), the router removes the first
entry and decrements the Size by 1.</t>

<t>If the Size of the current SRH-6LoRH header is 0 (indicating that there is
only 1 entry in the header) and there is no subsequent SRH-6LoRH after this,
then the current SRH-6LoRH is removed.</t>

<t>If the Size of the current SRH-6LoRH header is 0 and there is a subsequent
SRH-6LoRH and the Type of the subsequent SRH-6LoRH is equal to or greater than
the Type of the current SRH-6LoRH header (indicating the same or lesser
compression yielding the same or larger compressed forms), then the current
SRH-6LoRH is removed.</t>

<t>If the Size of the current SRH-6LoRH header is 0 and there is a subsequent
SRH-6LoRH and the Type of the subsequent SRH-6LoRH is less the Type of the
current SRH-6LoRH header, the first entry of the subsequent SRH-6LoRH is
removed and coalesced with the first entry of the current SRH-6LoRH.</t>

<t>At the end of the process, if there are no more SRH-6LoRH in the packet,
then the processing node is the last router along the source route path.</t>
</list></t>

<t>An example of this operation is provided in <xref target="examplesSRHfwd"/>.</t>

</section>
<section anchor="SRH-6LoRH-forwarding" title="Forwarding">

<t>When receiving a packet with an SRH-6LoRH, a router determines the IPv6 address
of the current segment endpoint.</t>

<t>If strict source routing is enforced and this router is not the segment endpoint
for the packet, then this router MUST drop the packet.</t>

<t>If this router is the current segment endpoint, then the router pops its address
as described in <xref target="SRH-6LoRH-popping"/> and continues processing the packet.</t>

<t>If there is still an SRH-6LoRH, then the router determines the new segment
endpoint and routes the packet towards that endpoint.</t>

<t>Otherwise, the router uses the destination in the inner IP header to forward or
accept the packet.</t>

<t>The segment endpoint of a packet MUST be determined as follows:</t>
<t><list style="empty">
<t>The router first determines the Compression Reference as discussed in
<xref target="SRH-6LoRH-coalescence"/>.</t>

<t>The router then coalesces the Compression Reference with the first entry of the
first SRH-6LoRH header as discussed in <xref target="sig-comp-ref"/>. If the
SRH-6LoRH header is Type 4, then the coalescence is a full override.</t>
</list></t>
<t>Since the Compression Reference is an uncompressed address, the coalesced IPv6
address is also expressed in the full 128 bits.</t>

</section>
</section>
<section anchor="rpl6LoRHenc" title="The RPL Packet Information 6LoRH (RPI-6LoRH)">

<t>Section 11.2 of the RPL document <xref target="RFC6550"/> specifies the RPL Packet Information (RPI) as
a set of fields that are placed by RPL routers in IP packets to identify the
RPL Instance, detect anomalies, and trigger corrective actions.</t>

<t>In particular, the SenderRank, which is the scalar
metric computed by a specialized Objective Function such as described in RFC 6552 <xref target="RFC6552"/>,
indicates the Rank of the sender and is modified at each hop.
The SenderRank field is used to validate that the packet progresses
in the expected direction, either upwards or downwards, along the DODAG.</t>

<t>RPL defines the <xref target="RFC6553">"The Routing Protocol for Low-Power
and Lossy Networks (RPL) Option for Carrying RPL Information in Data-Plane Datagrams"</xref>
to transport the RPI, which is carried in an IPv6 Hop-by-Hop Options Header <xref target="RFC2460"/>,
typically consuming 8 bytes per packet.</t>

<t>With RFC 6553 <xref target="RFC6553"/>, the RPL Option is encoded as 6 octets, which must
be placed in a Hop-by-Hop header that consumes two additional octets
for a total of 8 octets.  To limit the header's range to just the
RPL domain, the Hop-by-Hop header must be added to (or removed from)
packets that cross the border of the RPL domain.</t>

<t>The 8-byte overhead is detrimental to LLN operation, particularly
with regard to bandwidth and battery constraints.  These
bytes may cause a containing frame to grow above maximum frame size,
leading to Layer 2 or 6LoWPAN <xref target="RFC4944"/> fragmentation, which in turn
leads to even more energy expenditure and issues discussed in
<xref target="FORWARD-FRAG">"LLN Fragment Forwarding and Recovery"</xref>.</t>

<t>An additional overhead comes from the need, in certain cases,
to add an IP-in-IP encapsulation to carry the Hop-by-Hop header.
This is needed when the router that inserts the Hop-by-Hop header is not the
source of the packet so that an error can be returned to the router. This
is also the case when a packet originated by a RPL node must be stripped from
the Hop-by-Hop header to be routed outside the RPL domain.</t>

<t>For that reason, this specification defines an IP-in-IP-6LoRH header
in <xref target="IP-in-IPencoding"/>, but it must be noted that removal of a 6LoRH header
does not require manipulation of the packet in the LOWPAN_IPHC, and
thus, if the source address in the LOWPAN_IPHC is the node that
inserted the IP-in-IP-6LoRH header, then this situation alone does not
mandate an IP-in-IP-6LoRH header.</t>

<t>Note: It was found that some implementations omit the RPI for packets
going down the RPL graph in Non-Storing mode, even though RPL indicates that
the RPI should be placed in the packet. With this specification,
the RPI is important to indicate the RPLInstanceID, so the RPI should
not be omitted.</t>

<t>As a result, a RPL packet may bear only an RPI-6LoRH header and no
IP-in-IP-6LoRH header.  In that case, the source and destination of the
packet are specified by the LOWPAN_IPHC.</t>

<t>As with RFC 6553 <xref target="RFC6553"/>, the fields in the RPI include an 'O', an 'R', and
an 'F' bit, an 8-bit RPLInstanceID (with some internal structure), and
a 16-bit SenderRank.</t>

<t>The remainder of this section defines the RPI-6LoRH header, which is
a Critical 6LoWPAN Routing Header that is designed to transport the
RPI in 6LoWPAN LLNs.</t>

<section anchor="ints6LoRH" title="Compressing the RPLInstanceID">

<t>RPL Instances are discussed in Section 5 of the RPL specification <xref target="RFC6550"/>.
A number of simple use cases do not require more than one RPL Instance, and in
such cases, the RPL Instance is expected to be the Global Instance 0.
A global RPLInstanceID is encoded in a RPLInstanceID field as follows:</t>

<figure title="RPLInstanceID Field Format for Global Instances" anchor="rplgid"><artwork><![CDATA[
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |0|     ID      |  Global RPLInstanceID in 0..127
   +-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>For the particular case of the Global Instance 0, the
RPLInstanceID field is all zeros.
This specification allows the compressor to elide a RPLInstanceID field that is all
zeros and defines an I flag that, when set, signals that the field is elided.</t>

</section>
<section anchor="rank6LoRH" title="Compressing the SenderRank">

<t>The SenderRank is the result of the DAGRank operation on the Rank of the
sender; here, the DAGRank operation is defined in Section 3.5.1 of the RPL 
specification <xref target="RFC6550"/> as:</t>

<t><list style='empty'>
  <t>DAGRank(rank) = floor(rank/MinHopRankIncrease)</t>
</list></t>

<t>If MinHopRankIncrease is set to a multiple of 256,
the least significant eight bits of the SenderRank will be all zeroes; by
eliding those, the SenderRank can be compressed into a single byte.
This idea is used in RFC 6550 <xref target="RFC6550"/>, by defining
DEFAULT_MIN_HOP_RANK_INCREASE as 256, and in RFC 6552 <xref target="RFC6552"/>, which defaults
MinHopRankIncrease to DEFAULT_MIN_HOP_RANK_INCREASE.</t>

<t>This specification allows for the SenderRank to be encoded as either 1 or
2 bytes and defines a K flag that, when set, signals that a
single byte is used.</t>

</section>
<section anchor="rpi-6LoRH-encoding" title="The Overall RPI-6LoRH Encoding">

<t>The RPI-6LoRH header provides a compressed form for the RPL RPI.
Routers that need to forward a packet with a RPI-6LoRH header are
expected to be RPL routers that support this specification.</t>

<t>If a non-RPL router receives a packet with a RPI-6LoRH header, 
there was a routing or a configuration error (see <xref target="management-considerations"/>).</t>

<t>The desired reaction for the non-RPL router is to drop the packet as opposed to
skip the header and forward the packet, which could end up forming loops by 
reinjecting the packet in the wrong RPL Instance.</t>

<t>The Dispatch Value Bit Pattern for the SRH-6LoRH header indicates it is Critical.
Routers that understand the 6LoRH general format detailed in <xref target="rhf"/> cannot
ignore a 6LoRH header of this type and will drop the packet if it is unknown to them.</t>

<t>Since the RPI-6LoRH header is a Critical header, the TSE field does not need to
be a length expressed in bytes. Here, the field is fully reused
for control bits that encode the O, R, and F flags from the RPI, as
well as the I and K flags that indicate the compression format.</t>

<t>The RPI-6LoRH is Type 5.</t>

<t>The RPI-6LoRH header is immediately followed by the RPLInstanceID field,
unless that field is fully elided, and then the SenderRank, which is
either compressed into one byte or fully in-lined as 2
bytes.  The I and K flags in the RPI-6LoRH header indicate whether the
RPLInstanceID is elided and/or the SenderRank is compressed.
Depending on these bits, the Length of the RPI-6LoRH may vary as
described hereafter.</t>

<figure title="The Generic RPI-6LoRH Format" anchor="rpl6LoRH"><artwork><![CDATA[
    0                   1                   2
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  ...  -+-+-+
   |1|0|0|O|R|F|I|K| 6LoRH Type=5  |   Compressed fields  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  ...  -+-+-+
]]></artwork></figure>

<t><list style="hanging" hangIndent="6">
  <t hangText='O, R, and F bits:'>
  The O, R, and F bits are defined in Section 11.2 of RFC 6550 <xref target="RFC6550"/>.</t>
  <t hangText='I flag:'>
  If it is set, the RPLInstanceID is elided and the
RPLInstanceID is the Global RPLInstanceID 0.  If it is not set,
the octet immediately following the Type field contains the
RPLInstanceID as specified in Section 5.1 of RFC 6550 <xref target="RFC6550"/>.</t>
  <t hangText='K flag:'>
  If it is set, the SenderRank is compressed into 1 octet,
with the least significant octet elided.  If it is not set,
the SenderRank is fully inlined as 2 octets.</t>
</list></t>

<t>In <xref target="rpl6LoRH1"/>, the RPLInstanceID is the Global RPLInstanceID 0,
and the MinHopRankIncrease is a multiple of 256, so the least significant
byte is all zeros and can be elided:</t>

<figure title="The Most Compressed RPI-6LoRH" anchor="rpl6LoRH1"><artwork><![CDATA[
    0                   1                   2
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|0|0|O|R|F|1|1| 6LoRH Type=5  | SenderRank    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             I=1, K=1
]]></artwork></figure>

<t>In <xref target="rpl6LoRH2"/>, the RPLInstanceID is the Global RPLInstanceID 0, but
both bytes of the SenderRank are significant so it cannot be compressed:</t>

<figure title="Eliding the RPLInstanceID" anchor="rpl6LoRH2"><artwork><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|0|0|O|R|F|1|0| 6LoRH Type=5  |        SenderRank             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             I=1, K=0
]]></artwork></figure>

<t>In <xref target="rpl6LoRH4"/>, the RPLInstanceID is not the Global RPLInstanceID
0, and the MinHopRankIncrease is a multiple of 256:</t>

<figure title="Compressing SenderRank" anchor="rpl6LoRH4"><artwork><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|0|0|O|R|F|0|1| 6LoRH Type=5  | RPLInstanceID |  SenderRank   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             I=0, K=1
]]></artwork></figure>

<t>In <xref target="rpl6LoSRH"/>, the RPLInstanceID is not the Global RPLInstanceID
0, and both bytes of the SenderRank are significant:</t>

<figure title="The Least Compressed Form of RPI-6LoRH" anchor="rpl6LoSRH"><artwork><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|0|0|O|R|F|0|0| 6LoRH Type=5  | RPLInstanceID |    Sender-...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     ...-Rank      |
   +-+-+-+-+-+-+-+-+
             I=0, K=0
]]></artwork></figure>

</section>
</section>
<section anchor="IP-in-IPencoding" title="The IP-in-IP 6LoRH Header">

<t>The IP-in-IP 6LoRH (IP-in-IP-6LoRH) header is an Elective 6LoWPAN Routing Header
that provides a compressed form for the encapsulating
IPv6 Header in the case of an IP-in-IP encapsulation.</t>

<t>An IP-in-IP encapsulation is used to insert a field such as a Routing Header or
an RPI at a router that is not the source of the packet. In order to send an
error back regarding the inserted field, the address of the router that performs
the insertion must be provided.</t>

<t>The encapsulation can also enable the last router prior to the Destination to
remove a field such as the RPI, but this can be done in the compressed form
by removing the RPI-6LoRH, so an IP-in-IP-6LoRH encapsulation is not required for
that sole purpose.</t>

<t>The Dispatch Value Bit Pattern for the SRH-6LoRH header indicates it is Elective.
This field is not Critical for routing since it does not indicate the destination
of the packet, which is either encoded in an SRH-6LoRH header or in the inner IP header.
A 6LoRH header of this type can be skipped if not understood (per <xref target="rhf"/>),
and the 6LoRH header indicates the Length in bytes.</t>

<figure title="The IP-in-IP-6LoRH" anchor="IP-in-IPLoRH"><artwork><![CDATA[
  0                   1                   2
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-       ...      -+
 |1|0|1| Length  | 6LoRH Type 6  |  Hop Limit    | Encaps. Address  |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-       ...      -+

]]></artwork></figure>

<t>The Length of an IP-in-IP-6LoRH header is expressed in bytes and MUST be at
least 1,
to indicate a Hop Limit (HL) that is decremented at each hop. When the HL
reaches 0, the packet is dropped per RFC 2460 <xref target="RFC2460"/>.</t>

<t>If the Length of an IP-in-IP-6LoRH header is exactly 1, then the Encapsulator Address
is elided, which means that the encapsulator is a well-known router, for
instance, the root in a RPL graph.</t>

<t>The most efficient compression of an IP-in-IP encapsulation that can be
achieved with this specification is obtained when an endpoint of the packet is
the root of the RPL DODAG associated to the RPL Instance that is used to
forward the packet, and the root address is known implicitly as opposed to
signaled explicitly in the data packets.</t>

<t>If the Length of an IP-in-IP-6LoRH header is greater than 1, then an Encapsulator
Address is placed in a compressed form after the Hop Limit field.
The value of the Length indicates which compression is performed on the
Encapsulator Address. For instance, a Length of 3 indicates that the Encapsulator
Address is compressed to 2 bytes. The reference for the compression is the 
address of the root of the DODAG. The way the address of the root is determined
is discussed in <xref target="find-root"/>.</t>

<t>With RPL, the destination address in the IP-in-IP header is implicitly the
root in the RPL graph for packets going upwards; in Storing mode,
it is the destination address in the LOWPAN_IPHC for packets going downwards.
In Non-Storing mode, there is no implicit value for packets going downwards.</t>

<t>If the implicit value is correct, the destination IP address of the IP-in-IP
encapsulation can be elided. Else, the destination IP address of the IP-in-IP 
header is transported in an SRH-6LoRH header as the first entry of the first of
these headers.</t>

<t>If the final destination of the packet is a leaf that does not support 
this specification, then the chain of 6LoRH headers must be stripped by the RPL/6LR router
to which the leaf is attached. In that example, the destination IP address of the
IP-in-IP header cannot be elided.</t>

<t>In the special case where a 6LoRH header is used to route 6LoWPAN fragments, 
the destination address is not accessible in the LOWPAN_IPHC on all fragments and can be
elided only for the first fragment and for packets going upwards.</t>
</section>
<section anchor="management-considerations" title="Management Considerations">

<t>Though it is possible to decompress a packet at any hop, this specification is optimized to
enable that a packet is forwarded in its compressed form all the way, and it makes sense
to deploy homogeneous networks where all nodes, or no nodes at all, use the compression
technique detailed therein.</t>

<t>This specification aims at a simple implementation running in constrained nodes,
so it does indeed expect a homogeneous network and, as a consequence, it does not
provide a method to determine the level of support by the next hops at
forwarding time.</t>

<t>Should an extension to this specification provide such a method, forwarding nodes
could compress or decompress the RPL artifacts appropriately and enable a backward
compatibility between nodes that support this specification and nodes that do not.</t>

<t>It results that this specification does not attempt to enable such backwards
compatibility. It does not require extraneous code to exchange and handle error
messages to automatically correct mismatch situations either.</t>

<t>When a packet is expected to carry a 6LoRH header but does not, 
the node that discovers the issue is expected to send an ICMPv6 error message
to the root. 

It should be sent at an adapted rate-limitation and with a type 4 (indicating
a "Parameter Problem") and a code 0 (indicating an "Unrecognized Next Header
field encountered"). The relevant portion of the 
received packet should be embedded and the offset therein where the 6LoRH header
was expected should be pointed out.</t>

<t>When a packet is received with a 6LoRH header that is not recognized,
the node that discovers the issue is expected to send an ICMPv6 error message
to the root.  
It should be sent at an adapted rate-limitation and with a type 4 (indicating
a "Parameter Problem") and a code 1 (indicating an "Unrecognized Next Header
type encountered").
The relevant portion of the 
received packet should be embedded and the offset therein where the 6LoRH header
was expected should be pointed out.</t>

<t>In both cases, the node SHOULD NOT place a 6LoRH header as defined in this
specification in the resulting message, and the node should either omit the RPI or
place it uncompressed after the IPv6 header.</t>

<t>Additionally, in both cases, an alternate management method may be preferred in order
to notify the network administrator that there is a configuration error.</t>

<t>Keeping the network homogeneous is either a deployment issue, by deploying only
devices with a same capability, or a management issue, by configuring all
devices to either use or not use a certain level of this compression technique
and its future additions.</t>

<t>In particular, the situation where a node receives a message with a Critical
6LoWPAN Routing Header that it does not understand is an administrative error 
whereby the wrong device is placed in a network, or the device is misconfigured.</t>

<t>When a mismatch situation is detected, it is expected that the device raises some management
alert indicating the issue, e.g., that it has to drop a packet with a Critical 6LoRH.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>The security considerations of RFC 4944 <xref target="RFC4944"/>, RFC 6282 <xref target="RFC6282"/>,
and RFC 6553 <xref target="RFC6553"/> apply.</t>

<t>Using a compressed format as opposed to the full in-line format is
logically equivalent and is believed not to create an opening for a new threat when
compared to RFC 6550 <xref target="RFC6550"/>, RFC 6553 <xref target="RFC6553"/>, and RFC 6554 <xref target="RFC6554"/>,
noting that, even though
intermediate hops are removed from the SRH header as they are consumed, a node may still
identify that the rest of the source-routed path includes a loop or not
(see the "Security" section of RFC 6554). 
It must be noted that if the attacker is not part of the loop, then there is always a node
at the beginning of the loop that can detect it and remove it.</t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<section anchor="reserving-space-in-6lowpan-dispatch-page-1" title="Reserving Space in 6LoWPAN Dispatch Page 1">

<t>This specification reserves Dispatch Value Bit Patterns within
the 6LoWPAN Dispatch Page 1 as follows:</t>

<t><list style='empty'>
  <t>10 1xxxxx: for Elective 6LoWPAN Routing Headers</t>
</list></t>

<t><list style='empty'>
  <t>10 0xxxxx: for Critical 6LoWPAN Routing Headers</t>
</list></t>

<t>Additionally, this document creates two IANA registries: one for the Critical 6LoWPAN
Routing Header Type and one for the Elective 6LoWPAN Routing Header Type, 
each with 256 possible values, from 0 to 255, as described below.</t>

<t>Future assignments are made by IANA using the "RFC Required" procedure <xref target="RFC5226"/>.</t>

</section>
<section anchor="new-critical-6lowpan-routing-header-type-registry" 
	 title="New Critical 6LoWPAN Routing Header Type Registry">

<t>This document creates an IANA registry titled "Critical 6LoWPAN Routing Header Type"
and assigns the following values:</t>

<t><list style='empty'>
  <t>0-4: SRH-6LoRH [RFC8138]</t>
</list></t>

<t><list style='empty'>
  <t>5: RPI-6LoRH [RFC8138]</t>
</list></t>
</section>

<section anchor="new-elective-6lowpan-routing-header-type-registry" 
	 title="New Elective 6LoWPAN Routing Header Type Registry">

<t>This document creates an IANA registry titled "Elective 6LoWPAN Routing Header Type"
and assigns the following value:</t>

<t><list style='empty'>
  <t>6: IP-in-IP-6LoRH [RFC8138]</t>
</list></t>
</section>
</section>

  </middle>
  <back>

    <references title='Normative References'>
<?rfc include="reference.RFC.2119"?>

<?rfc include="reference.RFC.2460"?>

<?rfc include="reference.RFC.4944"?>

<?rfc include="reference.RFC.4443"?>

<?rfc include="reference.RFC.6282"?>

<?rfc include="reference.RFC.6550"?>

<?rfc include="reference.RFC.6552"?>

<?rfc include="reference.RFC.6553"?>

<?rfc include="reference.RFC.6554"?>

<?rfc include="reference.RFC.5226"?>

<!-- draft-ietf-6lo-paging-dispatch-05: I-D Updated to RFC 8025-->
<?rfc include="reference.RFC.8025"?>

<reference anchor="IEEE.802.15.4" target="http://ieeexplore.ieee.org/document/7460875/">
  <front>
    <title>IEEE Standard for Low-Rate Wireless Networks</title>
    <author >
      <organization>IEEE</organization>
    </author>
    <date/>
  </front>
  <seriesInfo name="IEEE" value="802.15.4-2015"/>
  <seriesInfo name="DOI" value="10.1109/IEEESTD.2016.7460875"/>
</reference>




    </references>

    <references title='Informative References'>

<?rfc include="reference.RFC.7102"?>

<?rfc include="reference.RFC.7228"?>

<?rfc include="reference.RFC.6775"?>

<?rfc include="reference.RFC.7554"?>

<!-- draft-thubert-6lo-forwarding-fragments-03: I-D Updated to Version 04; I-D Exists  -->

<reference anchor='FORWARD-FRAG'>
<front>
<title>LLN Fragment Forwarding and Recovery</title>

<author initials='P' surname='Thubert' fullname='Pascal Thubert' role="editor">
    <organization />
</author>

<author initials='J' surname='Hui' fullname='Jonathan Hui'>
    <organization />
</author>

<date month='January' year='2017' />

<abstract><t>In order to be routed, a fragmented 6LoWPAN packet must be reassembled at every hop of a multihop link where lower layer fragmentation occurs.  Considering that the IPv6 minimum MTU is 1280 bytes and that an an 802.15.4 frame can have a payload limited to 74 bytes in the worst case, a packet might end up fragmented into as many as 18 fragments at the 6LoWPAN shim layer.  If a single one of those fragments is lost in transmission, all fragments must be resent, further contributing to the congestion that might have caused the initial packet loss.  This draft introduces a simple protocol to forward and recover individual fragments that might be lost over multiple hops between 6LoWPAN endpoints.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-thubert-6lo-forwarding-fragments-04'/>

</reference>

<!-- draft-ietf-6tisch-architecture-10: I-D Updated to Version -11; I-D Exists (IESG: Dead) -->

<reference anchor='IPv6-ARCH'>
<front>
<title>An Architecture for IPv6 over the TSCH mode of IEEE 802.15.4</title>

<author initials='P' surname='Thubert' fullname='Pascal Thubert' role="editor">
    <organization />
</author>

<date month='January' year='2017' />

<abstract><t>This document describes a network architecture that provides low- latency, low-jitter and high-reliability packet delivery.  It combines a high speed powered backbone and subnetworks using IEEE 802.15.4 time-slotted channel hopping (TSCH) to meet the requirements of LowPower wireless deterministic applications.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-6tisch-architecture-11' />

</reference>

<!-- draft-ietf-roll-useofrplinfo-09: I-D Updated to Version -12; I-D Exists -->

<reference anchor='RPL-INFO'>
<front>
<title>When to use RFC 6553, 6554 and IPv6-in-IPv6</title>

<author initials='I' surname='Robles' fullname='Maria Ines Robles'>
    <organization />
</author>

<author initials='M' surname='Richardson' fullname='Michael Richardson'>
    <organization />
</author>

<author initials='P' surname='Thubert' fullname='Pascal Thubert'>
    <organization />
</author>

<date month='March' year='2017' />

<abstract><t>This document looks at different data flows through LLN (Low-Power and Lossy Networks) where RPL (IPv6 Routing Protocol for Low-Power and Lossy Networks) is used to establish routing.  The document enumerates the cases where RFC 6553, RFC 6554 and IPv6-in-IPv6 encapsulation is required.  This analysis provides the basis on which to design efficient compression of these headers.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-roll-useofrplinfo-12' />

</reference>

    </references>


<section anchor="examples" title="Examples">

<section anchor="examplesRPI" title="Examples Compressing the RPI">

<t>The example in <xref target="XMPrpi"/> illustrates the 6LoRH compression of 
a classical packet in Storing mode in all directions, as well
as in Non-Storing mode for a packet going up the DODAG
following the default route to the root. 
In this particular example, a fragmentation process takes place
per RFC 4944 <xref target="RFC4944"/>, and the fragment headers must be placed in
Page 0 before switching to Page 1:</t>

<figure title="Example Compressed Packet with RPI" anchor="XMPrpi"><artwork><![CDATA[
+-  ...  -+-  ...  -+-+ ... -+- ... +-+-+ ... -+-+-+-+-+-+-+-+-+-+... 
|Frag type|Frag hdr |11110001|  RPI-  |IP-in-IP| LOWPAN_IPHC | ...
|RFC 4944 |RFC 4944 | Page 1 | 6LoRH  | 6LoRH  |             |
+-  ...  -+-  ...  -+-+ ... -+- ... +-+-+ ... -+-+-+-+-+-+-+-+-+-+...
                                                <-  RFC 6282  ->
                                                 No RPL artifact
                                                 
+-  ...  -+-  ...  -+-+ ... -+-+ ... -+- ... +-+-+-+-+-+-+-+-+-+-+...
|Frag type|Frag hdr | 
|RFC 4944 |RFC 4944 |  Payload (cont)
+-  ...  -+-  ...  -+-+ ... -+-+ ... -+- ... +-+-+-+-+-+-+-+-+-+-+...

+-  ...  -+-  ...  -+-+ ... -+-+ ... -+- ... +-+-+-+-+-+-+-+-+-+-+...
|Frag type|Frag hdr | 
|RFC 4944 |RFC 4944 |  Payload (cont)
+-  ...  -+-  ...  -+-+ ... -+-+ ... -+- ... +-+-+-+-+-+-+-+-+-+-+...



]]></artwork></figure>

<t>In Storing mode, if the packet stays within the RPL domain, then it
is possible to save the IP-in-IP encapsulation, in which case, only the 
RPI is compressed with a 6LoRH, as illustrated in <xref target="XMPrpi2"/> in the 
case of a non-fragmented ICMP packet:</t>

<figure title="Example ICMP Packet with RPI in Storing Mode" anchor="XMPrpi2"><artwork><![CDATA[
+- ...  -+-+- ... -+-+-+-+ ... -+-+-+-+ ... -+-+-+-+-+-+-+-+-+-+-+...
|11110001| RPI-6LoRH |  NH = 0      | NH = 58  |  ICMP message ...
|Page 1  |  Type 5   | 6LOWPAN_IPHC | (ICMP)   |  (no compression) 
+- ...  -+-+- ... -+-+-+-+ ... -+-+-+-+ ... -+-+-+-+-+-+-+-+-+-+-+...
                      <-      RFC 6282       ->
                          No RPL artifact
]]></artwork></figure>

<t>The format in <xref target="XMPrpi2"/> is logically equivalent to the
uncompressed format illustrated in <xref target="XMPrpi3"/>:</t>

<figure title="Uncompressed ICMP Packet with RPI" anchor="XMPrpi3"><artwork><![CDATA[
+-+-+-+- ... -+-+-+-+ ... -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
|  IPv6 Header  | Hop-by-Hop |  RPI in       |  ICMP message ...
|  NH = 58      | Header     |  RPL Option   | 
+-+-+-+- ... -+-+-+-+ ... -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
]]></artwork></figure>

<t>For a UDP packet, the transport header can be compressed with 6LoWPAN
HC <xref target="RFC6282"/> as illustrated in <xref target="XMPrpi4"/>:</t>

<figure title="Uncompressed ICMP Packet with RPI" anchor="XMPrpi4"><artwork><![CDATA[

+-+ ... -+-+-...-+-+- ... -+-+-+-+ ... -+-+-+ ... -+-+-+-+-+...
|11110001| RPI-  | NH=1        |11110CPP| Compressed | UDP
|Page 1  | 6LoRH | LOWPAN_IPHC | UDP    | UDP header | Payload
+-+ ... -+-+-...-+-+- ... -+-+-+-+ ... -+-+-+ ... -+-+-+-+-+...
                  <-         RFC 6282              ->
                             No RPL artifact
]]></artwork></figure>

<t>If the packet is received from the Internet in Storing mode, then the root is
supposed to encapsulate the packet to insert the RPI. The resulting format 
would be as represented in  <xref target="XMPrpi3b"/>:</t>

<figure title="RPI Inserted by the Root in Storing Mode" anchor="XMPrpi3b"><artwork><![CDATA[
+-+ ... -+-+-...-+-+-- ... -+-+-+-+- ... -+-+ ... -+-+-+ ... -+-+-+...
|11110001| RPI-  | IP-in-IP | NH=1        |11110CPP| Compressed | UDP
|Page 1  | 6LoRH |  6LoRH   | LOWPAN_IPHC | UDP    | UDP header | Payld
+-+ ... -+-+-...-+-+-- ... -+-+-+-+- ... -+-+ ... -+-+-+ ... -+-+-+...
                             <-         RFC 6282              ->
                                        No RPL artifact

]]></artwork></figure>

</section>
<section anchor="examplesRH4" title="Example of a Downward Packet in Non-Storing Mode">

<t>The example illustrated in <xref target="XMPSRH"/> is a classical packet in Non-Storing mode
for a packet going down the DODAG following a source-routed path from the root.
Say that we have four forwarding hops to reach a destination. In the uncompressed
form, when the root generates the packet, the last 3 hops are encoded in a
Routing Header Type 3 (SRH) and the first hop is the destination of the packet.
The intermediate hops perform a swap; the hop count indicates the current 
active hop as defined in RFC 2460 <xref target="RFC2460"/> and RFC 6554 <xref target="RFC6554"/>.</t>

<t>When compressed with this specification, the 4 hops are encoded in SRH-6LoRH
when the root generates the packet, and the final destination is left in the
LOWPAN_IPHC. There is no swap; the forwarding node that corresponds to the
first entry effectively consumes it when forwarding, which means that the size
of the encoded packet decreases and that the hop information is lost.</t>

<t>If the last hop in an SRH-6LoRH is not the final destination, then it removes
the SRH-6LoRH before forwarding.</t>

<t>In the particular example illustrated in <xref target="XMPSRH"/>, all addresses in the DODAG
are assigned from the same /112 prefix and the last 2 octets encoding an identifier
such as an IEEE 802.15.4 short address. In that case, all addresses can be
compressed to 2 octets, using the root address as reference. There will be
one SRH_6LoRH header with, in this example, three compressed addresses:</t>

<figure title="Example Compressed Packet with SRH" anchor="XMPSRH"><artwork><![CDATA[
+-+ ... -+-+ ... +-+- ... -+-+- ... +-+-+-+ ... +-+-+ ... -+ ... +-...
|11110001|SRH-6LoRH| RPI-  | IP-in-IP | NH=1      |11110CPP| UDP | UDP
|Page 1  |Type1 S=2| 6LoRH |  6LoRH   |LOWPAN_IPHC| UDP    | hdr |Payld
+-+ ... -+-+ ... +-+- ... -+-+-- ... -+-+-+ ... +-+-+ ... -+ ... +-...
           <-8bytes->                  <-        RFC 6282      ->
                                               No RPL artifact
]]></artwork></figure>

<t>One may note that the RPI is provided. This is because the address of the root
that is the source of the IP-in-IP header is elided and inferred from the
RPLInstanceID in the RPI. Once found from a local context, that address is
used as a Compression Reference to expand addresses in the SRH-6LoRH.</t>

<t>With the RPL specifications available at the time of writing, the root
is the only node that may incorporate an SRH in an IP packet. When the root forwards
a packet that it did not generate, it has to encapsulate the packet with IP-in-IP.</t>

<t>But, if the root generates the packet towards a node in its DODAG, then it should
avoid the extra IP-in-IP as illustrated in <xref target="XMPSRH1"/>:</t>

<figure title="Compressed SRH 4*2bytes Entries Sourced by Root" anchor="XMPSRH1"><artwork><![CDATA[
+- ...  -+-+-+ ... +-+-+-+ ... -+-+-+-+-+-+-+-++-+- ... -+-+-+-+-+...
|11110001| SRH-6LoRH | NH=1       | 11110CPP  | Compressed | UDP
|Page 1  | Type1 S=3 | LOWPAN_IPHC| LOWPAN-NHC| UDP header | Payload
+- ...  -+-+-+ ... +-+-+-+ ... -+-+-+-+-+-+-+-++-+- ... -+-+-+-+-+...
                                       <-        RFC 6282        ->
]]></artwork></figure>

<t>Note: The RPI is not represented, though RPL <xref target="RFC6550"/> generally expects it.
In this particular case, since the Compression Reference for the SRH-6LoRH is the source
address in the LOWPAN_IPHC, and the routing is strict along the source route path,
the RPI does not appear to be absolutely necessary.</t>

<t>In <xref target="XMPSRH1"/>, all the nodes along the source route path share the same /112
prefix. This is typical of IPv6 addresses derived from an IEEE802.15.4 short
address, as long as all the nodes share the same PAN-ID. In that case, a Type 1
SRH-6LoRH header can be used for encoding. The IPv6 address of the root is taken
as reference, and only the last 2 octets of the address of the intermediate hops
are encoded. The Size of 3 indicates 4 hops, resulting in an SRH-6LoRH of 10 bytes.</t>

</section>
<section anchor="examplesSRHfwd" title="Example of SRH-6LoRH Life Cycle">

<t>This section illustrates the operation specified in <xref target="SRH-6LoRH-forwarding"/>
of forwarding a packet with a compressed SRH along an A-&gt;B-&gt;C-&gt;D source route
path. The operation of popping addresses is exemplified at each hop.</t>

<figure title="Processing at Node A" anchor="SRHfwdA"><artwork><![CDATA[
Packet as received by node A
----------------------------
  Type 3 SRH-6LoRH Size = 0   AAAA AAAA AAAA AAAA
  Type 1 SRH-6LoRH Size = 0                  BBBB
  Type 2 SRH-6LoRH Size = 1             CCCC CCCC
                                        DDDD DDDD
                                      
 Step 1: Popping BBBB, the first entry of the next SRH-6LoRH
 Step 2: If larger value (2 vs. 1), the SRH-6LoRH is removed 
 
  Type 3 SRH-6LoRH Size = 0   AAAA AAAA AAAA AAAA
  Type 2 SRH-6LoRH Size = 1             CCCC CCCC
                                        DDDD DDDD   
                                      
 Step 3: Recursion ended; coalescing BBBB with the first entry
  Type 3 SRH-6LoRH Size = 0   AAAA AAAA AAAA BBBB

 Step 4: Routing based on next segment endpoint to B

]]></artwork></figure>

<figure title="Processing at Node B" anchor="SRHfwdB"><artwork><![CDATA[
 
Packet as received by node B
---------------------------- 
  Type 3 SRH-6LoRH Size = 0   AAAA AAAA AAAA BBBB
  Type 2 SRH-6LoRH Size = 1             CCCC CCCC
                                        DDDD DDDD   
                                      
 Step 1: Popping CCCC CCCC, the first entry of the next SRH-6LoRH
 Step 2: Removing the first entry and decrementing the Size (by 1)
  
  Type 3 SRH-6LoRH Size = 0   AAAA AAAA AAAA BBBB
  Type 2 SRH-6LoRH Size = 0             DDDD DDDD 

 Step 3: Recursion ended; coalescing CCCC CCCC with the first entry
  Type 3 SRH-6LoRH Size = 0   AAAA AAAA CCCC CCCC 

 Step 4: Routing based on next segment endpoint to C
 
]]></artwork></figure>

<figure title="Processing at Node C" anchor="SRHfwdC"><artwork><![CDATA[
 
Packet as received by node C
----------------------------
                   
  Type 3 SRH-6LoRH Size = 0   AAAA AAAA CCCC CCCC 
  Type 2 SRH-6LoRH Size = 0             DDDD DDDD

 Step 1: Popping DDDD DDDD, the first entry of the next SRH-6LoRH
 Step 2: The SRH-6LoRH is removed
  
  Type 3 SRH-6LoRH Size = 0   AAAA AAAA CCCC CCCC

 Step 3: Recursion ended; coalescing DDDD DDDDD with the first entry
  Type 3 SRH-6LoRH Size = 0   AAAA AAAA DDDD DDDD

 Step 4: Routing based on next segment endpoint to D

]]></artwork></figure>

<figure title="Processing at Node D" anchor="SRHfwdD"><artwork><![CDATA[
 
 
Packet as received by node D
----------------------------
  Type 3 SRH-6LoRH Size = 0   AAAA AAAA DDDD DDDD

 Step 1: The SRH-6LoRH is removed
 Step 2: No more header; routing based on inner IP header

]]></artwork></figure>

</section>
</section>

<section anchor="acknowledgements" title="Acknowledgements" numbered="no">
<t>The authors wish to thank Tom Phinney, Thomas Watteyne, Tengfei Chang,
Martin Turon, James Woodyatt, Samita Chakrabarti, Jonathan Hui, Gabriel
Montenegro, and Ralph Droms for constructive reviews to the design in the 6lo
working group. The overall discussion involved participants to the 6MAN,
6TiSCH, and ROLL WGs; thank you all.
Special thanks to Michael Richardson and Ines Robles (the Chairs of the ROLL WG), Brian Haberman (the Internet Area AD), and Alvaro Retana and Adrian
Farrel (Routing Area ADs) for driving this complex effort across working
groups and areas.</t>
</section>
  </back>
</rfc>

