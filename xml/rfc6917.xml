<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc rfcedstyle="yes"?>

<rfc category="std" number="6917" ipr="trust200902" submissionType="IETF"
consensus="yes">

        <front>

                <title abbrev="Media Resource Brokering">Media Resource
                Brokering</title>
                
        <author fullname="Chris Boulton" initials="C." surname="Boulton">
                        <organization>NS-Technologies</organization>
                        <address>
                                <email>chris@ns-technologies.com</email>
                        </address>
                </author>

        <author initials="L." surname="Miniero" fullname="Lorenzo Miniero">
        <organization>Meetecho</organization>
        <address>
                <postal>
                        <street>Via Carlo Poerio 89</street>
                        <code>80100</code> 
                        <city>Napoli</city> 
                        <country>Italy</country>
                </postal>
                <email>lorenzo@meetecho.com</email>
        </address>
        </author>


        <author initials="G." surname="Munson" fullname="Gary Munson">
        <organization>AT&amp;T</organization>
        <address>
                <postal>
                        <street>200 Laurel Avenue South</street>
                        <city>Middletown</city> 
                        <region>New Jersey</region>
                        <code>07748</code>
                        <country>USA</country>
                </postal>
                <email>gamunson@gmail.com</email>
        </address>
        </author>
        
                <date month="April" year="2013"/>
                <workgroup/>

                <abstract>

                <t>The MediaCtrl working group in the IETF has proposed an architecture 
                for controlling media services.  The Session Initiation Protocol (SIP) is used as 
                the signaling protocol that provides many inherent capabilities for 
                message routing.  In addition to such signaling properties, a need 
                exists for intelligent, application-level media service selection based 
                on non-static signaling properties.  This is especially true when considered in 
                conjunction with deployment architectures that include 1:M and M:N combinations 
                of Application Servers and Media Servers.  This document introduces a Media
                Resource Broker (MRB) entity, which manages the availability of Media Servers and the
                media resource demands of Application Servers.  The document includes potential deployment
                options for an MRB and appropriate interfaces to Application Servers and Media Servers.        
                        </t>

                </abstract>
                <!-- Abstract -->
        </front>
        <middle>

          <section anchor="sec:Introduction" title="Introduction">

                <t>As IP-based multimedia infrastructures mature, the complexity and demands from 
                deployments increase.  Such complexity will result in a wide variety of capabilities
                from a range of vendors that should all be interoperable using the architecture
                and protocols produced by the MediaCtrl working group.  It should be possible 
                for a controlling entity to be assisted in Media Server selection so that 
                the most appropriate resource is selected for a particular operation.  The
                       importance increases when one introduces a flexible level of deployment scenarios, 
                as specified in RFC 5167 <xref target="RFC5167"></xref> and
RFC 5567  <xref target="RFC5567"></xref>.
                These documents make statements like
                &quot;it should be possible to have a many-to-many relationship between Application 
                Servers and Media Servers that use this protocol&quot;.  This leads to the following 
                deployment architectures being possible when considering media resources, to provide
                what can be effectively described as media resource brokering.
                </t>

                <t>The simplest deployment view is illustrated in <xref target="fig:arch1"/>. 
                </t>
                        
                <figure anchor="fig:arch1" title="Basic Architecture">
                        <artwork><![CDATA[
+---+-----+---+                         +---+-----+---+
| Application |                         |    Media    |
|   Server    |<-------MS Control------>|    Server   |
+-------------+                         +-------------+
                        ]]></artwork> </figure>

                <t>This simply involves a single Application Server and Media Server.  Expanding 
                on this view, it is also possible for an Application Server to control 
                multiple (greater than 1) Media Server instances at any one time.  This deployment view is illustrated in 
                <xref target="fig:arch2"/>.  Typically, such architectures are associated with 
                application logic that requires high-demand media services.  It is more than possible 
                that each Media Server possesses a different media capability set.  Media Servers 
                may offer different media services as specified in the
MediaCtrl architecture document <xref target="RFC5567"/>. 
                A Media Server may have similar media functionality but may have different capacity 
                or media codec support.</t>

<figure anchor="fig:arch2" title="Multiple Media Servers">
                        <artwork><![CDATA[
                                        +---+-----+---+
                                        |    Media    |
                                 +----->|    Server   |
                                 |      +-------------+
                                 |    
+---+-----+---+                  |      +---+-----+---+
| Application |                  |      |    Media    |
|   Server    |<--MS Control-----+----->|    Server   |
+-------------+                  |      +-------------+
                                 |
                                 |      +---+-----+---+
                                 +----->|    Media    |
                                        |    Server   |
                                        +-------------+
                        ]]></artwork> </figure>

                <t><xref target="fig:arch3"/> conveys the opposite view to that in <xref target="fig:arch2"/>.  
                In this model, there are a number of (greater than 1) Application Servers, possibly supporting
                dissimilar applications, controlling a single Media Server.  Typically, such architectures are
                associated with application logic that requires low-demand media services.        
                </t>

<figure anchor="fig:arch3" title="Multiple Application Servers">
                        <artwork><![CDATA[
+---+-----+---+                        
| Application |                  
|   Server    |<-----+               
+-------------+      |           
                     |   
+---+-----+---+      |                  +---+-----+---+
| Application |      |                  |    Media    |
|   Server    |<-----+-----MS Control-->|    Server   |
+-------------+      |                  +-------------+
                     |
+---+-----+---+      |                
| Application |      |              
|   Server    |<-----+
+-------------+                        
                        ]]></artwork> </figure>

        <t>The final deployment view is the most complex (<xref target="fig:arch4"/>).  In this model (M:N), there 
        exist any number of Application Servers and any number of Media Servers.  It is  
        again possible in this model that Media Servers might not be
homogeneous, and they might have different capability sets and capacities.</t>

<figure anchor="fig:arch4" title="Many-to-Many Architecture">
                        <artwork><![CDATA[
+---+-----+---+                         +---+-----+---+
| Application |                         |    Media    | 
|   Server    |<-----+            +---->|    Server   |
+-------------+      |            |     +-------------+
                     |            |
+---+-----+---+      |            |     +---+-----+---+
| Application |      |            |     |    Media    |
|   Server    |<-----+-MS Control-+---->|    Server   |
+-------------+      |            |     +-------------+
                     |            |
+---+-----+---+      |            |     +---+-----+---+
| Application |      |            +---->|    Media    |
|   Server    |<-----+                  |    Server   |
+-------------+                         +---+-----+---+
                        ]]></artwork> </figure>

                <t>The remaining sections in this specification will focus on a new entity called
                a Media Resource Broker (MRB), which can be utilized in the deployment architectures
                       described previously in this section.  The MRB entity provides the ability to obtain
                media resource information and appropriately allocate (broker) on behalf of client
                       applications.</t>
                
                <t>The high-level deployment options discussed in this section rely
                on network architecture and policy to prohibit inappropriate use.  Such
                policies are out of scope for this document.</t>

                <t>This document will take a look at the specific problem areas related 
                to such deployment architectures.  It is recognized that the solutions 
                proposed in this document should be equally adaptable to all of the 
                previously described deployment models.  It is also recognized that 
                the solution is far more relevant to some of the previously discussed 
                       deployment models and can almost be viewed as redundant
                on others.</t>
        
          </section>
                
<!-- Introduction -->
                
<section anchor="Terminology" title="Conventions and Terminology">

        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      <xref target="RFC2119">RFC 2119</xref>.</t>

        <t>This document inherits terminology proposed in
        <xref target="RFC5567">RFC 5567</xref> and in
        <xref target="RFC6230">"Media Control Channel Framework"</xref>.  
        In addition, the following terms are defined for use in this document and for 
        use in the context of the MediaCtrl working group in the IETF:
                        
<list style="hanging">

        <t hangText="Media Resource Broker (MRB):">A logical entity that is responsible for
             both collection of appropriate published Media Server (MS)
              information and selecting appropriate Media Server resources on behalf of
              consuming entities.</t>

        <t hangText="Query MRB:">An instantiation of an MRB (see previous definition) that provides 
        an interface for an Application Server to retrieve the address of an appropriate Media Server.  The result 
        returned to the Application Server can be influenced by information contained in the query 
        request.</t>

        <t hangText="In-line MRB:">An instantiation of an MRB (see previous definition) that
              directly receives requests on the signaling path. There is no
        separate query.</t>

        <t hangText="CFW:">Media Control Channel Framework, as specified in <xref target="RFC6230"/>.</t>

</list>

        Within the context of In-line MRBs, additional terms are defined:

<list style="hanging">

        <t hangText="In-line Aware MRB Mode (IAMM):">Defined in <xref target="sec:IAMM_CFW"/>.</t>

        <t hangText="In-line Unaware MRB Mode (IUMM):">Defined in <xref target="sec:In_Line"/>.</t>

</list>
        
        The document will often specify when a specific identifier in a protocol message
        needs to be unique. Unless stated otherwise, such uniqueness will always
        be within the scope of the Media Servers controlled by the same MRB.
        The interaction between different MRB instances, e.g., the
        partitioning of a logical MRB, is out of scope for this document.
</t>

</section>

<!-- Terminology -->


        <section anchor="sec:Problem" title="Problem Discussion">
     
                <t>As discussed in <xref target="sec:Introduction"/>, a goal of
the MediaCtrl working group
                is to produce a solution that will service a wide variety of deployment architectures.  
                Such architectures range from the simplest 1:1 relationship between Media Servers and Application 
                Servers to potentially linearly scaling 1:M, M:1, and M:N deployments.</t>

                <t>Managing such deployments is itself non-trivial for the proposed solution until 
                an additional number of factors that increase complexity are
included in the equation.  As Media Servers evolve, it must be taken into consideration that, 
                where many can exist in a deployment, they may not have been produced by the same 
                vendor and may not have the same capability set.  It should be possible for an 
                Application Server that exists in a deployment to select a media service based 
                on a common, appropriate capability set.  In conjunction with capabilities, it is 
                also important to take available resources into consideration.  The ability 
                to select an appropriate media service function is an extremely useful  
                feature but becomes even more powerful when considered with 
                available resources for servicing a request.</t>
                
                <t>In conclusion, the intention is to create a toolkit that allows MediaCtrl 
                deployments to effectively utilize the available media resources.  It should 
                be noted that in the simplest deployments where only a single Media Server exists, 
                an MRB function is probably not required.  Only a single capability set exists,
                and resource availability can be handled using the appropriate underlying 
                signaling, e.g., SIP response.  This document does not prohibit such uses of 
                an MRB; it simply provides the tools for various entities to interact 
                where appropriate.  It is also worth noting that the functions specified 
                       in this document aim to provide a 'best effort' view of media resources 
                at the time of request for initial Media Server routing decisions.  Any 
                dramatic change in media capabilities or capacity after a request has taken place
                should be handled by the underlying protocol.</t>
                
                <t>It should be noted that there may be additional information
                that is desirable for the MRB to have for purposes of selecting a Media Server resource, such as
                resource allocation rules across different applications, planned or unplanned
                downtime of Media Server resources, the planned addition of future Media Server
                resources, or Media Server resource capacity models. How the MRB acquires such information
                is outside the scope of this document.  The specific techniques used for selecting an
                appropriate media resource by an MRB is also outside the scope of this document.</t>

        </section>
        <!-- Problem -->

        <section anchor="sec:Deployment" title="Deployment Scenario Options ">
     
                <t>Research into media resource brokering concluded that a couple of high-level 
                models provided an appropriate level of flexibility.  The general principles
                of &quot;in-line&quot; and &quot;query&quot; 
                MRB concepts are discussed in the rest of this section.  It should be noted that while
                the interfaces are different, they both use common underlying mechanisms defined in this
                specification.
                </t>

                <section anchor="sec:Query" title="Query MRB">
     
                <t>The &quot;Query&quot; model for MRB interactions provides the ability for 
                a client of media services (for example, an Application Server) to 
                &quot;ask&quot; an MRB for an appropriate Media Server, as illustrated 
                in <xref target="fig:arch5"/>.
                </t>

                <figure anchor="fig:arch5" title="Query MRB">
                        <artwork><![CDATA[
                     +---+-----+---+ 
       +------------>|     MRB     |<----------+----<-----+---+
       |             +-------------+        (1)|          |   |
       |                                       |          |   |
       |(2)                             +---+--+--+---+   |   |
       |                                |    Media    |   |   |
       |                          +---->|    Server   |   |   |
       |                          |     +-------------+   |   |
       |                          |                    (1)|   |
+---+--+--+---+                   |     +---+-----+---+   |   |
| Application |                   |     |    Media    |   |   |
|   Server    |<-----+-MS Control-+---->|    Server   |->-+   |
+-------------+          (3)      |     +-------------+       |
                                  |                           |
                                  |     +---+-----+---+    (1)|
                                  +---->|    Media    |       |
                                        |    Server   |--->---+
                                        +---+-----+---+
                        ]]></artwork> </figure>
                
                <t>In this deployment, the Media Servers use the Media Server Resource 
                Publish interface, as discussed in <xref target="sec:MS_Pub"/>, to 
                convey capability sets as well as resource information.  This is depicted 
                by (1) in <xref target="fig:arch5"/>.  It is then the MRB's responsibility to 
                accumulate all appropriate information relating to media services in the 
                logical deployment cluster.  The Application Server (or other media 
                services client) is then able to query the MRB for an appropriate resource (as 
                identified by (2) in <xref target="fig:arch5"/>).  Such a query would carry 
                       specific information related to the media service required and enable the MRB 
                to provide increased accuracy in its response.  This particular interface 
                is discussed in &quot;Media Service Resource Consumer
Interface&quot; (<xref target="sec:Res_Cons"/>). The Application Server is then
                able 
                to direct control commands (for example, create a conference) and media dialogs 
                to the appropriate Media Server, as shown by (3) in <xref target="fig:arch5"/>. 
                Additionally, with Query mode, the MRB is not directly in the signaling path
                between the Application Server and the selected Media Server resource.</t>

                <section anchor="sec:Query_hybrid" title="Hybrid Query MRB">
     
                <t>As mentioned previously, it is the intention that a toolkit is provided 
                for MRB functionality within a MediaCtrl architecture.  It is expected that in
                specific deployment scenarios the role of the MRB might be co-hosted as a hybrid 
                logical entity with an Application Server, as shown in <xref target="fig:arch6"/>.
                </t>

        <figure anchor="fig:arch6" title="Hybrid Query MRB - Application Server Hosted">
                        <artwork><![CDATA[
       +------------<----------------<---------+----<-----+---+
       |                     (1)               |          |   |
       |                                       |          |   |
       |                                +---+--+--+---+   |   |
       |                                |    Media    |   |   |
       V                          +---->|    Server   |   |   |
+------+------+                   |     +-------------+   |   |
|     MRB     |                   |                       |   |
+---+--+--+---+                   |     +---+-----+---+   |   |
| Application |                   |     |    Media    |   |   |
|   Server    |<-----+-MS Control-+---->|    Server   |->-+   |
+-------------+                   |     +-------------+       |
                                  |                           |
                                  |     +---+-----+---+       |
                                  +---->|    Media    |       |
                                        |    Server   |--->---+
                                        +---+-----+---+
                        ]]></artwork> </figure>

                <t>This diagram is identical to that in <xref target="fig:arch5"/> with the exception 
                that the MRB is now hosted on the Application Server.  The Media Server 
                Publish interface is still being used to accumulate resource information 
                at the MRB, but as it is co-hosted on the Application Server, the Media
                Server Consumer interface has collapsed.  It might still exist within the 
                Application Server/MRB interaction, but this is an implementation issue.  This 
                type of deployment suits a single Application Server environment, but it should be noted 
                that a Media Server Consumer interface could then be offered from the
                hybrid if required.        
                </t>

                <t>In a similar manner, the Media Server could also act as a hybrid for the deployment 
                cluster, as illustrated in <xref target="fig:arch7"/>.
                </t>

        <figure anchor="fig:arch7" title="Hybrid Query MRB - MS Hosted">
                        <artwork><![CDATA[
                                (1)                 +---+-----+---+ 
+---+---+------------->---------------->----------->|     MRB     |
|   |   |   +---+--+--+---+                         +---+-----+---+   
|   |   +-<-| Application |                         |    Media    |   
|   |       |   Server    |<--+-MS Control-+------->|    Server   |   
|   |       +-------------+                   |     +-------------+
|   |                                         |
|   |       +---+--+--+---+                   | 
|   +---<---| Application |                   |   
|           |   Server    |<--+-MS Control-+--+   
|           +-------------+                   | 
|                                             |
|           +---+--+--+---+                   | 
+---<-------| Application |                   |   
            |   Server    |<--+-MS Control-+--+   
            +-------------+            
                        ]]></artwork> </figure>
                
                <t>In this example, the MRB has collapsed and is co-hosted by the Media Server.  The 
                Media Server Consumer interface is still available to the Application 
                Servers (1) to query Media Server resources.  The Media
                Server Publish interface has collapsed onto the Media Server.  It might 
                still exist within the Media Server/MRB interaction, but this is an implementation 
                issue.  This type of deployment suits a single Media Server environment, but 
                it should be noted that a Media Server Publish interface could
                then 
                be offered from the hybrid if required. A typical use case scenario for such a
                topology would be a single Media Server representing a pool of MSs in a cluster. In this case,
                the MRB would actually be handling a cluster of Media Servers, rather than one.
                </t>

                </section>
                <!-- Hybrid Query MRB -->

                </section>
                <!-- Query MRB -->

        <section anchor="sec:Inline" title="In-Line MRB">
     
        <t>The &quot;In-line&quot; MRB is architecturally different from the &quot;Query&quot; model 
        discussed in the previous section.  The concept of a separate
        query disappears.  The client of the MRB simply uses the media resource
        control and media dialog signaling to involve the MRB.  This type of deployment is illustrated
        in <xref target="fig:arch8"/>.</t>

        <figure anchor="fig:arch8" title="In-Line MRB">
                        <artwork><![CDATA[
                            +-------<----------+----<-------+---+
                            |                  | (1)        |   |
                            |                  |            |   |
                            |             +---+--+--+---+   |   |
                            |             |    Media    |   |   |
                            |     +------>|    Server   |   |   |
                            |     |(3)    +-------------+   |   |
                            |     |                      (1)|   |
+---+--+--+---+             |     |       +---+-----+---+   |   |
| Application |  (2) +---+--V--+---+  (3) |    Media    |   |   |
|   Server    |----->|     MRB     |----->|    Server   |->-+   |
+-------------+      +---+-----+---+      +-------------+       |
                                  |                             |
                                  |   (3) +---+-----+---+    (1)|
                                  +------>|    Media    |       |
                                          |    Server   |--->---+
                                          +---+-----+---+
                        ]]></artwork> </figure>
        
        <t>The Media Servers still use the Media Server Publish interface to convey 
        capabilities and resources to the MRB, as illustrated by (1).  The
        Media Server Control Channels (and media dialogs as well, if required)
are sent to the MRB
(2), which then selects an appropriate Media Server (3) and remains in the
signaling path between the Application Server and the Media Server
resources.
</t>

        <t>The In-line MRB can be split into two distinct logical roles that can be applied on a per-request basis.  They are:

        <list style="hanging">

                <t hangText="In-line Unaware MRB Mode (IUMM):">Allows an MRB to act on behalf of clients requiring
              media services who are not aware of an MRB or its operation.  In this case, the Application Server does not
              provide explicit information on the kind of Media Server resource it needs
              (as in <xref target="sec:Res_Cons"/>), and the
              MRB is left to deduce it by potentially inspecting other information in the request from
              the Application Server (for example, Session Description
              Protocol (SDP) content, or address of the requesting
              Application Server, or additional Request-URI
              parameters as per <xref target="RFC4240">RFC 4240</xref>).</t>

                <t hangText="In-line Aware MRB Mode (IAMM):">Allows an MRB to act on behalf of clients requiring 
                        media services who are aware of an MRB and its operation.  In particular, it allows the Application Server
                        to explicitly convey matching characteristics to those provided by Media Servers, as does the Query MRB
                        mode (as in <xref target="sec:Res_Cons"/>).
                
                </t>

        </list>

        In either of the previously described roles, signaling as specified by the Media Control Channel
        Framework (<xref target="RFC6230"/>) would be involved, and the MRB would deduce
        that the selected Media Server resources are no longer needed when the Application Server 
        or Media Server terminates the corresponding SIP dialog.  The two modes are discussed in more detail
        in <xref target="sec:In_Line"/>.</t>

        </section>
        <!-- In-Line -->

        </section>
        <!-- Deployment -->


<section anchor="sec:Interfaces" title="MRB Interface Definitions">
     
        <t>The intention of this specification is to 
        provide a toolkit for a variety of deployment architectures where media resource 
        brokering can take place.  Two main interfaces are required to 
        support the differing requirements.  The two interfaces are described in the 
        remainder of this section and have been named the Media Server Resource
        Publish and Media Server Resource Consumer interfaces.
        </t>

        <t>It is beyond the scope of this document to define exactly how to 
        construct an MRB using the interfaces described.  It 
        is, however, important that the two interfaces are complimentary so that 
        development of appropriate MRB functionality is supported.</t>

        <section anchor="sec:MS_Pub" title="Media Server Resource Publish Interface">
        
                <t>The Media Server Resource Publish interface is responsible for 
                providing an MRB with appropriate Media Server resource information.  
                As such, this interface is assumed to provide both general 
                and specific details related to Media Server resources.  This 
                information needs to be conveyed using an industry standard mechanism 
                to provide increased levels of adoption and interoperability.  A
                Control Package for the Media Control Channel Framework will be specified to fulfill this interface
                requirement.  It provides an establishment and monitoring
                mechanism to enable a Media Server to report appropriate statistics
                to an MRB.  The Publish interface is used with both the Query
mode and In-line mode of MRB operation.
                </t>

                <t>As already discussed in <xref target="sec:Introduction"/>, the MRB view
                   of Media Server resource availability will in reality be approximate -- i.e.,
                partial and imperfect. The MRB Publish interface does not provide an exhaustive
                   view of current Media Server resource consumption; the Media Server may in some cases
                provide a best-effort computed view of resource consumption 
                   parameters conveyed in the Publish interface (e.g., 
Digital Signal Processors (DSPs) with a
                fixed number of streams versus Graphics Processing Units
(GPUs) with CPU availability).
  Media resource information may only be
                reported periodically over the Publish interface to an MRB.</t>

                <t>It is also worth noting that while the scope of the MRB is in providing interested
                Application Servers with
                the available resources, the MRB also allows for the retrieval of information about
                consumed resources. While this is of course a relevant piece of information (e.g., for monitoring
                purposes), such functionality inevitably raises security considerations, and implementations
                should take this into account. See <xref target="sec:security"/> for more details.</t>

                <t>The MRB Publish interface uses the Media Control Channel
                Framework (<xref target="RFC6230"/>) as the basis for interaction
                between a Media Server and an MRB.  The Media Control Channel Framework uses an extension mechanism
                to allow specific usages that are known as Control Packages.  <xref target="sec:Control_Package_Definition"/>
                defines the Control Package that MUST be implemented by any Media Server wanting to interact
                with an MRB entity.</t>
                
<section anchor="sec:Control_Package_Definition" title="Control Package Definition">

<t>This section fulfills the requirement for information that
must be specified during the definition of a Control Framework package,
as detailed in Section 8 of <xref target="RFC6230"/>.</t>
                  
<section anchor="sec:Control_Package_Name" title="Control Package Name">

<t>The Media Channel Control Framework requires a Control Package definition to
specify and register a unique name and version.</t>

<t>The name and version of this Control Package is "mrb-publish/1.0".  </t>
                     
</section>

<!-- Control Package Name -->

<section anchor="sec:Message_Usage" title="Framework Message Usage">

        <t>The MRB Publish interface allows a Media Server to convey available capabilities
        and resources to an MRB entity.</t>

        <t>This package defines XML elements in <xref target="definitions"/> and provides an XML
        schema in <xref target="sec:publisher_xml"/>. </t>

        <t>The XML elements in this package are split into requests, responses,
           and event notifications.

            Requests are carried in CONTROL message bodies; the &lt;mrbrequest> element is defined as a package request.
            This request can be used for creating new subscriptions and updating/removing existing subscriptions.

            Event notifications are also carried in CONTROL message bodies; the
        &lt;mrbnotification> element is defined for package event notifications.

            Responses are carried either in REPORT message or Control Framework
        200 response bodies; the &lt;mrbresponse> element is defined as a
        package-level response. 
</t>

        <t>Note that package responses are different from framework response
        codes. Framework error response codes (see Section 7 of
        <xref target="RFC6230"/>) are
        used when the request or event notification is
        invalid; for example, a request has invalid XML (400) or is not
        understood (500). Package-level responses are carried in framework 200 
        response or
        REPORT message bodies. This package's response codes are defined
        in  <xref target="sec:responses"/>. </t>

</section>

<!--Framework Message Usage -->

<section anchor="sec:Common_XML" title="Common XML Support">

        <t>The Media Control Channel Framework <xref target="RFC6230"/>
        requires a Control Package definition to
        specify if the attributes for media dialog or conference references are required.</t>

        <t>The Publish interface defined in <xref target="sec:publisher_xml"/> does import and make use of the
        common XML schema defined in the Media Control Channel Framework.</t>

        <t>The Consumer interface defined in <xref target="sec:consumer_xml"/> does import and make use of the
        common XML schema defined in the Media Control Channel Framework.</t>

</section>

<!-- Common XML Support -->

<section anchor="sec:Control_Body" title="CONTROL Message Body">

<t>A valid CONTROL message body MUST conform to the schema defined in <xref target="sec:publisher_xml"/> and described in
    <xref target="definitions"/>. XML messages appearing in CONTROL messages
    MUST contain either an &lt;mrbrequest> or &lt;mrbnotification> element.</t>


</section>

<!-- CONTROL Message Body -->

<section anchor="sec:REPORT_Body" title="REPORT Message Body">

<t>A valid REPORT message body MUST conform to the schema defined in <xref
target="sec:publisher_xml"/> and described in <xref target="definitions"/>. XML
messages appearing in REPORT messages MUST contain an &lt;mrbresponse> element.
</t>

</section>

<!-- REPORT Message Body -->

<section anchor="sec:Audit" title="Audit">

        <t>The 'mrb-publish/1.0' Media Control Channel Framework package does not require any
        additional auditing capability.</t>
        

</section>

<!-- Audit -->

</section>
<!-- Package Definition -->


<section anchor="definitions" title="Element Definitions">

        <t>This section defines the XML elements for the Publish interface Media Control Channel package
        defined in <xref target="sec:MS_Pub"/>.  The formal XML schema definition for the Publish
        interface can be found in <xref target="sec:publisher_xml"/>.</t>

        <t>The root element is &lt;mrbpublish>.  All other XML elements (requests, responses, notifications) are
        contained within it.  The MRB Publish interface request element is detailed in <xref target="sec:requests"/>. 
        The MRB Publish interface notification element is detailed in <xref target="sec:notifications"/>.
        The MRB Publish interface response element is detailed in <xref target="sec:responses"/>.</t>

<t>The &lt;mrbpublish> element has the following attributes:

        <list style="hanging">
        <t hangText="version:">a token specifying the mrb-publish package version.  The value
              is fixed as '1.0' for this version of the package.  The attribute MUST be present.</t>
        </list>
        </t>

        <t>The &lt;mrbpublish> element has the following child elements, and there
           MUST NOT be more than one such child element in any &lt;mrbpublish>
           message:

        <list style="hanging">
                <t>&lt;mrbrequest> for sending an MRB request.  See <xref target="sec:requests"/>.</t>
                <t>&lt;mrbresponse> for sending an MRB response.  See <xref target="sec:responses"/>.</t>
                <t>&lt;mrbnotification> for sending an MRB notification.  See <xref target="sec:notifications"/>.</t>
        </list>
        </t>
        
</section>
<!-- Element Definitions -->

<section anchor="sec:requests" title="&lt;mrbrequest>">

        <t>This section defines the &lt;mrbrequest> element used to initiate requests from an
        MRB to a Media Server.  The element describes information relevant for the interrogation
        of a Media Server.</t>

        <t>The &lt;mrbrequest> element has no defined attributes.</t>

        <t>The &lt;mrbrequest> element has the following child element:

        <list style="hanging">
        <t>&lt;subscription> for initiating a subscription to a Media Server from an MRB.  See <xref target="sec:subscription"/>.</t>
        </list>
        </t>

<section anchor="sec:subscription" title="&lt;subscription>">

        <t>The &lt;subscription> element is included in a request from an MRB to a Media Server to provide the
        details relating to the configuration of updates (known as a subscription session).  This element can
        be used either to request a new subscription
        or to update an existing one (e.g., to change the frequency of the updates), and to remove ongoing subscriptions as
        well (e.g., to stop an indefinite update). The MRB will inform the
Media Server regarding how long
        it wishes to receive updates and the frequency that updates should be sent. Updates related
        to the subscription are sent using the &lt;mrbnotification> element.</t>

        <t>The &lt;subscription> element has the following attributes:
        
        <list style="hanging">
                <t hangText="id:">Indicates a unique token representing the subscription session between the MRB
                and the Media Server.  The attribute MUST be present.</t>
                <t hangText="seqnumber:">Indicates a sequence number to be used in conjunction
                with the subscription session ID to identify a specific
                subscription command.  The first subscription MUST contain a non-zero number
                'seqnumber', and subsequent subscriptions MUST contain a higher number than the
                previous 'seqnumber' value.  If a subsequent 'seqnumber' is not higher, a 405 response code is generated
                as per <xref target="sec:responses"/>.  The attribute MUST be present.</t>

                <t hangText="action:">Provides the operation that should be carried out on the subscription:
                <list style="symbols">
                <t>The value of 'create' instructs the Media Server to attempt to set up a new subscription.</t>
                <t>The value of 'update' instructs the Media Server to attempt to update an existing subscription.</t>
                <t>The value of 'remove' instructs the Media Server to attempt to remove an existing subscription
                and consequently stop any ongoing related notification.</t>
                </list>
                The attribute MUST be present.</t>
        </list>
        </t>

        <t>The &lt;subscription> element has zero or more of the following child elements:

        <list style="hanging">
                <t hangText="&lt;expires>:">Provides the amount of time in seconds that a subscription should be installed for
                notifications at the Media Server.  Once the amount of time has passed, the subscription expires, and the MRB
                has to subscribe again if it is still interested in receiving notifications from the Media Server. The element MAY
                be present.</t>
                <t hangText="&lt;minfrequency>:">Provides the minimum frequency in seconds that the MRB wishes to receive notifications
                from the Media Server.  The element MAY be present.</t>
                <t hangText="&lt;maxfrequency>:">Provides the maximum frequency in seconds that the MRB wishes to receive notifications
                from the Media Server.  The element MAY be present.</t>
        </list>
        </t>
        
        <t>
        Please note that these three optional pieces of
        information provided by the MRB only act as a suggestion: the Media Server MAY change the proposed values if it considers
        the suggestions unacceptable (e.g., if the MRB has requested a
notification frequency that is too high). In such a case,
        the request would not fail, but the updated, acceptable values would be reported in the &lt;mrbresponse> accordingly.
        </t>

</section>
<!--subscription -->

</section>
<!-- mrbrequest -->

<section anchor="sec:responses" title="&lt;mrbresponse>">

        <t>Responses to requests are indicated by an &lt;mrbresponse> element. </t>

<t>The &lt;mrbresponse> element has the following attributes:

<list style="hanging">

<t hangText="status:">numeric code indicating the response status. The
attribute MUST be present.</t>

<t hangText="reason:">string specifying a reason for the response status. The
attribute MAY be present.</t>

</list>
</t>
        <t>The &lt;mrbresponse> element has a single child element:

        <list style="hanging">
        <t>&lt;subscription> for providing details related to a subscription
requested by a Media Server (see below in this section).</t>

        </list>
        </t>


    <t>The following status codes are defined for 'status': </t>
<?rfc compact="no" ?>

       <texttable anchor="defn.response.statuscodes"
                title="&lt;mrbresponse> Status Codes" >
                <ttcol align="left" width="15%">code</ttcol>
                <ttcol align="left" width="85%">description</ttcol>
                                <c>200</c>
                                        <c>OK</c>
                                <c>400</c>
                                        <c>Syntax error</c>
                                <c>401</c>
                                        <c>Unable to create Subscription</c>
                                <c>402</c>
                                        <c>Unable to update Subscription</c>
                                <c>403</c>
                                        <c>Unable to remove Subscription</c>
                                <c>404</c>
                                        <c>Subscription does not exist</c>
                                <c>405</c>
                                        <c>Wrong sequence number</c>
                                <c>406</c>
                                        <c>Subscription already exists</c>
                                <c>420</c>
                                        <c>Unsupported attribute or element</c>
       </texttable>
<?rfc compact="yes" ?>
<t>
If a new subscription request made by an MRB (action='create') has been accepted,
the Media Server MUST reply with an &lt;mrbresponse> with status code 200. The same rule applies
whenever a request to update (action='update') or remove (action='remove') an
existing transaction can be fulfilled by the Media Server.
</t>
<t>
A subscription request, nevertheless, may fail for several reasons. In such
a case, the status codes defined in <xref target="defn.response.statuscodes"/>
must be used instead. Specifically, if the Media Server fails to handle a request
due to a syntax error in the request itself (e.g., incorrect XML,
violation of the schema constraints, or invalid values in any of the
attributes/elements), the Media Server MUST reply with an &lt;mrbresponse> with status code 400.
If a syntactically correct request fails because the request also includes any
attribute/element the Media Server doesn't understand, the Media Server MUST reply with an &lt;mrbresponse> with status code 420.
If a syntactically correct request fails because the MRB wants to create a new subscription,
but the provided unique 'id' for the subscription already exists, the Media Server MUST reply
with an &lt;mrbresponse> with status code 406. If a syntactically correct request
fails because the MRB wants to update/remove a subscription that doesn't exist,
the Media Server MUST reply with an &lt;mrbresponse> with status code 404.
If the Media Server is unable to accept a request for any other
reason (e.g., the MRB has no more resources to fulfill the request),
the Media Server MUST reply with an &lt;mrbresponse> with status code 401/402/403,
depending on the action the MRB provided in its request:
<list style="symbols">
<t>action='create' --&gt; 401;</t>
<t>action='update' --&gt; 402;</t>
<t>action='remove' --&gt; 403;</t>
</list>
</t>

<t>
    A response to a subscription request that has a status code of 200
    indicates that the request is successful.  The response MAY also
    contain a &lt;subscription>  child that describes the subscription.
    The &lt;subscription>  child MAY contain 'expires', 'minfrequency', and
    'maxfrequency' values even if they were not contained in the
    request.
</t>
<t>
    The Media Server can choose to change the suggested 'expires',
'minfrequency', and
    'maxfrequency' values provided by the MRB in its &lt;mrbrequest> if
    it considers them unacceptable (e.g., the requested frequency range
    is too high).  In such a case, the response MUST contain a
    &lt;subscription>  element describing the subscription as the Media Server
    accepted it, and the Media Server MUST include in the &lt;subscription>  element
    all of those values that it modified relative to the request, to
    inform the MRB about the change.</t>

</section>
<!-- Responses -->

<section anchor="sec:notifications" title="&lt;mrbnotification>">

        <t>The &lt;mrbnotification> element is included in a request from a Media Server to an MRB to provide the
        details relating to current status.  The Media Server will inform the MRB of its current status as defined by
        the information in the &lt;subscription> element.  Updates are sent
        using the &lt;mrbnotification> element.</t>

        <t>The &lt;mrbnotification> element has the following attributes:
        
        <list style="hanging">
                <t hangText="id:"> indicates a unique token representing the session between the MRB
                and the Media Server and is the same as the one appearing in the &lt;subscription> element. 
                The attribute MUST be present.</t>
        <t hangText="seqnumber:">indicates a sequence number to be used in conjunction
                      with the subscription session ID to identify a specific
                      notification update.  The first notification update MUST contain a non-zero number
                      'seqnumber', and subsequent notification updates MUST contain a higher number than the
                      previous 'seqnumber' value.  If a subsequent 'seqnumber' is not higher, the situation should
                      be considered an error by the entity receiving the
notification update.  How the receiving entity deals with this situation is
implementation specific.  The attribute MUST be present.</t>
        </list>
        </t>

        <t>It's important to point out that the 'seqnumber' that appears in an
&lt;mrbnotification> is not related to the 'seqnumber' appearing in a
&lt;subscription>.
 In fact, the latter is associated with subscriptions and would increase at every command issued by the MRB, while
        the former is associated with the asynchronous notifications the Media Server would trigger according
        to the subscription and as such would increase at every notification message to enable
        the MRB to keep track of them.</t>
        
        <t>The following sub-sections provide details of the child elements
that make up the contents of the &lt;mrbnotification> element.</t>

<section anchor="sec:media-server-id" title="&lt;media-server-id>">

        <t>The &lt;media-server-id> element provides a unique system-wide identifier for a Media Server
        instance.  The element MUST be present and MUST be chosen such that it is extremely unlikely
        that two different Media Servers would present the same id to a given MRB.</t>

</section>
<!--media-server-id -->

<section anchor="sec:supported-pacakges" title="&lt;supported-packages>">

        <t>The &lt;supported-packages> element provides the list of Media Control
        Channel packages supported by the Media Server.  The element MAY be present.</t>

        <t>The &lt;supported-packages> element has no attributes.</t>

        <t>The &lt;supported-packages> element has a single child element:

        <list style="hanging">
                <t hangText="&lt;package>:">Gives the name of a package
                supported by the Media Server.  The &lt;package> element has a single attribute,
                'name', which provides the name of the supported Media Control Channel Framework
                package, compliant with Section 13.1.1 of <xref target="RFC6230"/>.</t>
        </list>
        </t>

</section>
<!--supported-packages -->

<section anchor="sec:active-rtp-sessions" title="&lt;active-rtp-sessions>">

        <t>The &lt;active-rtp-sessions> element provides information detailing the current active
        Real-time Transport Protocol (RTP) sessions.  The element MAY be present.</t>

        <t>The &lt;active-rtp-sessions> element has no attributes.</t>

        <t>The &lt;active-rtp-sessions> element has a single child element:

        <list style="hanging">
                <t hangText="&lt;rtp-codec>:"> Describes a supported codec and the number of active sessions using that codec. 
                The &lt;rtp-codec> element has one attribute.  The value of the attribute, 'name', is a media type
                     (which can include parameters per <xref target="RFC6381"/>). The &lt;rtp-codec> element has two child
                      elements.  The child element &lt;decoding> has as content the decimal number of
                    RTP sessions being decoded using the specified codec, and
the child element &lt;encoding> has as content
                the decimal number of RTP sessions being encoded using the specified codec.</t>
        </list>
        </t>

</section>
<!--active-rtp-sessions -->

<section anchor="sec:active-mixer-sessions" title="&lt;active-mixer-sessions>">

        <t>The &lt;active-mixer-sessions> element provides information detailing the current active
        mixed RTP sessions.  The element MAY be present.</t>

        <t>The &lt;active-mixer-sessions> element has no attributes.</t>
        <t>The &lt;active-mixer-sessions> element has a single child element:

        <list style="hanging">
                <t hangText="&lt;active-mix>:"> Describes a mixed active RTP session. 
                The &lt;active&nbhy;mix> element has one attribute.  The value of the attribute, 'conferenceid', is the name of the mix. 
                The &lt;active-mix> element has one child element.  The child element,
                &lt;rtp-codec>, contains the same information relating to RTP
sessions as that defined in
                     <xref target="sec:active-rtp-sessions"/>.  The element MAY be present.</t>
        </list>
        </t>

</section>
<!--active-mixer-sessions -->

<section anchor="sec:non-active-rtp-sessions" title="&lt;non-active-rtp-sessions>">

        <t>The &lt;non-active-rtp-sessions> element provides information detailing the currently available inactive
        RTP sessions, that is, how many more RTP streams this Media Server can support.  The element MAY be present.</t>

        <t>The &lt;non-active-rtp-sessions> element has no attributes.</t>

        <t>The &lt;non-active-rtp-sessions> element has a single child element:

        <list style="hanging">

        <t hangText="&lt;rtp-codec>:">  Describes a supported codec and the number of non-active sessions for that codec. 
                The &lt;rtp-codec> element has one attribute.  The value of the attribute, 'name', is a media type
                     (which can include parameters per <xref target="RFC6381"/>). The &lt;rtp-codec> element has two child
                      elements.  The child element &lt;decoding> has as content the decimal number of
                    RTP sessions available for decoding using the specified
codec, and the child element &lt;encoding> has as content
                the decimal number of RTP sessions available for encoding using the specified codec.</t>

        </list>
        </t>

</section>
<!--non-active-rtp-sessions -->

<section anchor="sec:non-active-mixer-sessions" title="&lt;non-active-mixer-sessions>">

        <t>The &lt;non-active-mixer-sessions> element provides information detailing the current inactive
        mixed RTP sessions, that is, how many more mixing sessions this Media Server can support.  The element MAY be present.</t>

        <t>The &lt;non-active-mixer-sessions> element has no attributes.</t>

        <t>The &lt;non-active-mixer-sessions> element has a single child element:

        <list style="hanging">
                <t hangText="&lt;non-active-mix>:"> Describes available mixed RTP sessions. 
                The &lt;non&nbhy;active-mix> element has one attribute.  The value of the attribute, 'available', is the number
                of mixes that could be used using that profile.  The &lt;non-active-mix> element has one child element. 
                The child element, &lt;rtp-codec>, contains the same
information relating to RTP sessions as that defined in
                     <xref target="sec:non-active-rtp-sessions"/>.  The element MAY be present.</t>
        </list>
        </t>

</section>
<!--non-active-mixer-sessions -->

<section anchor="sec:media-server-status" title="&lt;media-server-status>">

        <t>The &lt;media-server-status> element provides information detailing the current status of the Media
        Server.  The element MUST be present.  It can return one of the following values:
        
        <list style="hanging">
                <t hangText="active:"> Indicates that the Media Server is available for service.</t>
                <t hangText="deactivated:"> Indicates that the Media Server has been withdrawn from service,
                and as such requests should not be sent to it before it becomes 'active' again.</t>
                <t hangText="unavailable:"> Indicates that the Media Server continues to process past requests but
                cannot accept new requests, and as such should not be contacted before it becomes 'active' again.</t>
                        
        </list>
</t>

        <t>The &lt;media-server-status> element has no attributes.</t>

        <t>The &lt;media-server-status> element has no child elements.</t>

</section>
<!--media-server-status -->

<section anchor="sec:supported-codecs" title="&lt;supported-codecs>">

        <t>The &lt;supported-codecs> element provides information detailing the current codecs
        supported by a Media Server and associated actions.  The element MAY be present.</t>

        <t>The &lt;supported-codecs> element has no attributes.</t>

        <t>The &lt;supported-codecs> element has a single child element:

        <list style="hanging">
                <t hangText="&lt;supported-codec>:">Has a single attribute, 'name', which provides the
                name of the codec about which this element provides information.  A valid value is a media type
                that, depending on its definition, can include
                      additional parameters (e.g., <xref target="RFC6381"/>). The &lt;supported-codec> element then has
                a further child element, &lt;supported-codec-package>.  The &lt;supported-codec-package>
                element has a single attribute, 'name', which provides the name of the Media Control Channel
                Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>,
                for which the codec support applies.  The &lt;supported-codec-package> 
                element has zero or more &lt;supported&nbhy;action> children, each one of which describes an action
                       that a Media Server can apply to this codec:
               <list style="symbols">
               <t>'decoding', meaning a decoder for this codec is available;</t>
               <t>'encoding', meaning an encoder for this codec is available;</t>
               <t>'passthrough', meaning the Media Server is able to pass a stream encoded using that codec through, without re-encoding.</t>
               </list></t>
        </list>
        </t>

</section>
<!--supported-codecs -->

<section anchor="sec:application-data" title="&lt;application-data>">

        <t>The &lt;application-data> element provides an arbitrary string of
    characters as application-level data.  This data is meant to only
    have meaning at the application-level logic and as such is not
    otherwise restricted by this specification.  The set of allowed
    characters is the same as those in XML (viz., tab, carriage
    return, line feed, and the legal characters of Unicode and
    ISO/IEC&nbsp;10646 <xref target="ISO.10646.2012"/> (see also
    Section 2.2 of &lt;http://www.w3.org/TR/xml/>)).
    The element MAY be present.</t>

        <t>The &lt;application-data> element has no attributes.</t>

        <t>The &lt;application-data> element has no child elements.</t>

</section>
<!--application-data -->

<section anchor="sec:file-formats" title="&lt;file-formats>">

        <t>The &lt;file-formats> element provides a list of file formats supported for the
        purpose of playing media.  The element MAY be present.</t>

        <t>The &lt;file-formats> element has no attributes.</t>

        <t>The &lt;file-formats> element has zero of more the following child elements:


        <list style="hanging">
                <t hangText="&lt;supported-format>:">Has a single attribute, 'name', which provides the
                type of file format that is supported. A valid value is a media type
                that, depending on its definition, can include
      additional parameters (e.g., <xref target="RFC6381"/>). The &lt;supported-format> element then has
                a further child element, &lt;supported&nbhy;file&nbhy;package>.  The &lt;supported-file-package>
                element provides the name of the Media Control Channel
                Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the file format support applies.</t>
        </list>
        </t>

</section>
<!--file-formats -->

<section anchor="sec:max-prepared-duration" title="&lt;max-prepared-duration>">

        <t>The &lt;max-prepared-duration> element provides the maximum amount of time a media dialog
        will be kept in the prepared state before timing out (see Section
        4.4.2.2.6 of RFC 6231 <xref target="RFC6231"/>.  The element MAY be present.</t>

        <t>The &lt;max-prepared-duration> element has no attributes.</t>

        <t>The &lt;max-prepared-duration> element has a single child element:

        <list style="hanging">
                <t hangText="&lt;max-time>:">Has a single attribute, 'max-time-seconds', which provides the
                amount of time in seconds that a media dialog can be in the prepared state.  The &lt;max-time> element then has
                a further child element, &lt;max-time-package>.  The &lt;max-time-package>
                element provides the name of the Media Control Channel
                Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the time period applies.</t>
        </list>
        </t>

</section>
<!--max-prepared-duration -->


<section anchor="sec:dtmf-support" title="&lt;dtmf-support>">

        <t>The &lt;dtmf-support> element specifies the supported methods to
detect Dual-Tone Multi-Frequency (DTMF) tones and to generate them. 
        The element MAY be present.</t>

        <t>The &lt;dtmf-support> element has no attributes.</t>

        <t>The &lt;dtmf-support> element has zero of more of the following child elements:


        <list style="hanging">
                <t hangText="&lt;detect>:">Indicates the support for DTMF detection.
                The &lt;detect> element has no attributes.  The &lt;detect> element then has
                a further child element, &lt;dtmf-type>.  The &lt;dtmf-type>
                element has two attributes: 'name' and 'package'.  The 'name' attribute provides the
                type of DTMF being used, and it can only be a case-insensitive string containing
                either 'RFC4733' <xref target="RFC4733"/> or 'Media' (detecting tones as signals from the audio stream).
                The 'package' attribute provides the name of the Media Control Channel
                Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the DTMF type applies.</t>

                <t hangText="&lt;generate>:">Indicates the support for DTMF generation.
                The &lt;generate> element has no attributes.  The &lt;generate> element then has
                a further child element, &lt;dtmf-type>.  The &lt;dtmf-type>
                element has two attributes: 'name' and 'package'.  The 'name' attribute provides the
                type of DTMF being used, and it can only be a case-insensitive string containing
                either 'RFC4733' <xref target="RFC4733"/> or 'Media' (generating tones as signals in the audio stream).
                The 'package' attribute provides the name of the Media Control Channel
                Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the DTMF type applies.</t>

                <t hangText="&lt;passthrough>:">Indicates the support for passing DTMF through without re-encoding.
                The &lt;passthrough> element has no attributes.  The &lt;passthrough> element then has
                a further child element, &lt;dtmf&nbhy;type>.  The &lt;dtmf-type>
                element has two attributes: 'name' and 'package'.  The 'name' attribute provides the
                type of DTMF being used, and it can only be a case-insensitive string containing
                either 'RFC4733' <xref target="RFC4733"/> or 'Media' (passing tones as signals through the audio stream).
                The 'package' attribute provides the name of the Media Control Channel
                Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the DTMF type applies.</t>
        
        </list>
        </t>

</section>
<!--dtmf-support -->

<section anchor="sec:mixing-modes" title="&lt;mixing-modes>">

        <t>The &lt;mixing-modes> element provides information about the support for audio
        and video mixing of a Media Server, specifically a list of supported algorithms
        to mix audio and a list of supported video presentation layouts. The element MAY be present.</t>

        <t>The &lt;mixing-modes> element has no attributes.</t>

        <t>The &lt;mixing-modes> element has zero or more of the following child elements:


        <list style="hanging">
        <t hangText="&lt;audio-mixing-modes>:"> Describes the available algorithms for
        audio mixing. The &lt;audio-mixing-modes> element has no attributes. The
        &lt;audio-mixing-modes> element has one child element. The child element,
        &lt;audio-mixing-mode>, contains a specific available algorithm. Valid values
        for the &lt;audio-mixing-mode> element are algorithm names, e.g., 'nbest' and 'controller'
        as defined in <xref target="RFC6505"/>. The element has a single
        attribute, 'package'. The attribute 'package' provides the name of the Media
        Control Channel Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the algorithm support applies.</t>

        <t hangText="&lt;video-mixing-modes>:"> Describes the available video
        presentation layouts and the supported functionality related to
video mixing.
        The &lt;video-mixing-modes> element has two attributes: 'vas' and 'activespeakermix'.
        The 'vas' attribute is of type boolean with a value of 'true'
indicating that the Media Server
        supports automatic Voice Activated Switching. The 'activespeakermix' is of type boolean
        with a value of 'true' indicating that the Media Server is able to prepare an
        additional video stream for the loudest speaker participant without its contribution.
        The &lt;video&nbhy;mixing-modes> element has one child element.
        The child element, &lt;video-mixing-mode>, contains the name of a specific video presentation
        layout. The name may refer to one of the predefined video layouts defined in the XCON
        conference information data model <xref target="RFC6501"/>,
or to non-XCON layouts as well, as long as they are properly prefixed
        according to the schema they belong to.
        The &lt;video-mixing-mode> element has a single attribute, 'package'. The attribute 'package' provides the
        name of the Media Control Channel Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the algorithm
        support applies.</t>

        </list>
        </t>

</section>
<!--mixing-modes -->

<section anchor="sec:supported-tones" title="&lt;supported-tones>">

        <t>The &lt;supported-tones> element provides information about which
        tones a Media Server is able to play and recognize. In particular, the
support is reported by
        referring to both support for country codes (ISO 3166-1 <xref target="ISO.3166-1"/>) and supported
        functionality (ITU-T Recommendation Q.1950 <xref target="ITU-T.Q.1950"/>). The element MAY be present.</t>

        <t>The &lt;supported-tones> element has no attributes.</t>

        <t>The &lt;supported-tones> element has zero or more of the following child elements:


        <list style="hanging">
                <t hangText="&lt;supported-country-codes>:"> Describes the supported
                country codes with respect to tones. The &lt;supported-country-codes>
                element has no attributes. The &lt;supported-country-codes>
element has one
                child element. The child element, &lt;country-code>, reports support
                for a specific country code, compliant with the ISO 3166-1 <xref target="ISO.3166-1"/>
                specification. The &lt;country-code> element has a single attribute,
                'package'. The attribute 'package' provides the name of the Media
                Control Channel Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, in which the tones from the
                specified country code are supported.</t>

                <t hangText="&lt;supported-h248-codes>:"> Describes the supported
                H.248 codes with respect to tones. The &lt;supported-h248-codes>
                element has no attributes. The &lt;supported-h248-codes>
element has one
                child element. The child element, &lt;h248-code>, reports support
                for a specific H.248 code, compliant with the ITU-T Recommendation Q.1950 <xref target="ITU-T.Q.1950"/>
                specification. The codes can be either specific (e.g., cg/dt to
                only report the Dial Tone from the Call Progress Tones package)
                or generic (e.g., cg/* to report all the tones from the Call Progress
                Tones package), using wildcards. The &lt;h248-code> element has a
                single attribute, 'package'. The attribute 'package' provides
                the name of the Media Control Channel Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, in which
                the specified codes are supported.</t>
        </list>
        </t>

</section>
<!--supported-tones -->

<section anchor="sec:file-transfer-modes" title="&lt;file-transfer-modes>">

        <t>The &lt;file-transfer-modes> element allows the Media Server to specify which scheme names are supported
        for transferring files to a Media Server for each Media Control Channel Framework package type, for example, whether the Media Server
        supports fetching resources via HTTP, HTTPS, NFS, etc.  The element MAY be present.</t>

        <t>The &lt;file-transfer-modes> element has no attributes.</t>

        <t>The &lt;file-transfer-modes> element has a single child element:

        <list style="hanging">
                <t hangText="&lt;file-transfer-mode>:">Has two attributes: 'name' and 'package'.  The 'name' attribute provides the
                scheme name of the protocol that can be used for file transfer (e.g., HTTP, HTTPS, NFS, etc.); the value of the
                attribute is case insensitive. The 'package' attribute provides the name of the Media
                Control Channel Framework package, compliant with the specification in the related
                IANA registry (e.g., "msc-ivr/1.0"), for which the scheme name applies.</t>
        
        </list>
        </t>
        
        <t>It is important to point out that this element provides no information about whether or not the Media Server supports any
        flavor of live streaming: for instance, a value of "HTTP" for the IVR (Interactive Voice Response) Package would only mean the 'http' scheme makes
        sense to the Media Server within the context of that package. Whether or not the Media Server can make use of HTTP to only fetch resources,
        or also to attach an HTTP live stream to a call, is to be considered implementation specific to the Media Server and irrelevant to the Application Server and/or MRB.
        Besides, the Media Server supporting a scheme does not imply that it also supports the related secure versions: for instance, if the Media Server
        supports both HTTP and HTTPS, both the schemes will appear in the element. A lack of the "HTTPS" value would need
        to be interpreted as a lack of support for the 'https' scheme.</t>

</section>
<!--file-transfer-modes -->

<section anchor="sec:asr-tts-support" title="&lt;asr-tts-support>">


        <t>The &lt;asr-tts-support> element provides information about the support for
        Automatic Speech Recognition (ASR) and Text-to-Speech (TTS) functionality
        in a Media Server. The functionality is reported by referring to the supported
        languages (using <xref target="ISO.639.2002">ISO 639-1</xref> codes)
regarding both ASR and TTS.
        The element MAY be present.</t>
        
        <t>The &lt;asr-tts-support> element has no attributes.</t>

        <t>The &lt;asr-tts-support> element has zero or more of the following child elements:
                
        <list style="hanging">
                
        <t hangText="&lt;asr-support>:"> Describes the available languages for ASR. The
        &lt;asr&nbhy;support> element has no attributes. The &lt;asr&nbhy;support>
element has one child element.
        The child element, &lt;language>, reports that the Media Server
supports ASR for a specific language.
        The &lt;language> element has a single attribute, <vspace/>'xml:lang'. The attribute 'xml:lang'
        contains the <xref target="ISO.639.2002">ISO 639-1</xref> code of the supported language.</t>

        <t hangText="&lt;tts-support>:"> Describes the available languages for TTS. The
        &lt;tts&nbhy;support> element has no attributes. The &lt;tts-support>
element has one child element.
        The child element, &lt;language>, reports that the Media Server
supports TTS for a specific language.
        The &lt;language> element has a single attribute, <vspace/>'xml:lang'. The attribute 'xml:lang'
        contains the <xref target="ISO.639.2002">ISO 639-1</xref> code of the supported language.</t>

        </list>
        </t>

</section>
<!--asr-tts-support -->

<section anchor="sec:vxml-support" title="&lt;vxml-support>">

        <t>The &lt;vxml-support> element specifies if the Media Server supports
VoiceXML (VXML) and, if it does, through which
        protocols the support is exposed (e.g., via the control framework, RFC 4240 <xref target="RFC4240"/>, or RFC 5552 <xref target="RFC5552"/>). 
        The element MAY be present.</t>

        <t>The &lt;vxml-support> element has no attributes.</t>

        <t>The &lt;vxml-support> element has a single child element:

        <list style="hanging">
                <t hangText="&lt;vxml-mode>:">Has two attributes: 'package' and 'support'.  The 'package' attribute
                provides the name of the Media Control Channel Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the VXML support
                applies.  The 'support' attribute provides the type of VXML support provided by the
                Media Server (e.g., RFC 5552 <xref target="RFC5552"/>, RFC 4240
<xref target="RFC4240"/>, or the IVR Package <xref target="RFC6231"/>),
                and valid values are case-insensitive RFC references (e.g.,
"rfc6231" to specify that the Media Server supports
                VoiceXML as provided by the IVR Package <xref target="RFC6231"/>).</t>
        
        </list>
        </t>
        
        <t>The presence of at least one &lt;vxml-mode> child element would indicate that the Media Server
        does support VXML as specified by the child element itself.  An empty
&lt;vxml> element would otherwise indicate that the Media Server does not
support VXML at all.</t>

</section>
<!--vxml-support -->

<section anchor="sec:media-server-location" title="&lt;media-server-location>">

        <t>The &lt;media-server-location> element provides information about the civic
        location of a Media Server. Its description makes use of the Civic Address
        Schema standardized in <xref target="RFC5139">RFC 5139</xref>. The element MAY be present. More precisely,
        this section is entirely optional, and it's implementation specific to fill it with just the details each
        implementer deems necessary for any optimization that may be needed.</t>

        <t>The &lt;media-server-location> element has no attributes.</t>

        <t>The &lt;media-server-location> element has a single child element:

        <list style="hanging">
        <t hangText="&lt;civicAddress>:"> Describes the civic
        address location of the Media Server, whose representation refers to
        Section 4 of <xref target="RFC5139">RFC 5139</xref>.</t>
        
        </list>
        </t>

</section>
<!--media-server-location -->

<section anchor="sec:label" title="&lt;label>">

        <t>The &lt;label> element allows a Media Server to declare a piece of information that will be understood by the MRB. 
        For example, the Media Server can declare if it's a blue or green one.  It's a string to allow arbitrary values to be returned 
        to allow arbitrary classification.  The element MAY be present.</t>

        <t>The &lt;label> element has no attributes.</t>

        <t>The &lt;label> element has no child elements.</t>

</section>
<!--label -->

<section anchor="sec:media-server-address" title="&lt;media-server-address>">

        <t>The &lt;media-server-address> element allows a Media Server to provide
        a direct SIP URI where it can be reached (e.g., the URI that the
Application Server would call in order to set up a Control Channel and relay
SIP media dialogs). The element MAY be present.</t>

        <t>The &lt;media-server-address> element has no attributes.</t>

        <t>The &lt;media-server-address> element has no child elements.</t>

</section>
<!--media-server-address -->

<section anchor="sec:encryption" title="&lt;encryption>">

        <t>The &lt;encryption> element allows a Media Server to declare support for encrypting RTP media streams
        using <xref target="RFC3711">RFC 3711</xref>.  The element MAY be present.  If the element is present,
        then the Media Server supports DTLS-SRTP (a Secure Real-time Transport
Protocol (SRTP) extension for Datagram Transport Layer Security (DTLS)) <xref
target="RFC5763"/>.</t>

        <t>The &lt;encryption> element has no attributes.</t>

        <t>The &lt;encryption> element has no child elements.</t>
        
</section>
<!--encryption -->

</section>
<!-- mrbnotification -->

</section>

<!-- Media Server Publish Interface -->

        <section anchor="sec:Res_Cons" title="Media Service Resource Consumer Interface">
     
                <t>The Media Server Consumer interface provides the ability for clients of an MRB, 
                such as Application Servers, to request an appropriate Media Server to satisfy
                specific criteria.  This interface allows a client to pass detailed meta-information 
                to the MRB to help select an appropriate Media Server.  The MRB is then able to make 
                       an informed decision and provide the client with an appropriate Media Server 
                resource.  The MRB Consumer interface includes both 1) the
In-line Aware MRB Mode (IAMM), which uses the Session Initiation Protocol (SIP)
and 2) the Query mode, which uses the Hypertext Transfer Protocol (HTTP)
                <xref target="RFC2616"/>.  The MRB Consumer interface does not
include the In-line Unaware Mode
                      (IUMM), which is further explained in <xref target="sec:In_Line"/>.  The following sub-sections provide guidance on
                using the Consumer interface, which is represented by the 'application/mrb-consumer+xml' media
                type in <xref target="sec:consumer_xml"/>, with HTTP and SIP.</t>

        <section anchor="sec:http_Consumer" title="Query Mode/HTTP Consumer Interface Usage">

                <t>An appropriate interface for such a 'query' style interface is
                in fact an HTTP usage.  Using HTTP and XML combined reduces complexity
                and encourages the use of common tools that are widely available in the industry today.
                The following information explains the primary operations required to request and then
                receive information from an MRB, by making use of
                HTTP <xref target="RFC2616"/> and HTTPS <xref target="RFC2818"/> as
                transport for a query for a media resource, and the appropriate response.</t>

                <t>The media resource query, as defined by the &lt;mediaResourceRequest> element from
                       <xref target="sec:consumer_xml"/>, MUST be carried in the body of an HTTP/HTTPS
                POST request.  The media type contained in the HTTP/HTTPS
                request/response MUST be 'application/mrb-consumer+xml'.  This value MUST
                be reflected in the appropriate HTTP headers, such as
'Content-Type' and
                'Accept'.  The body of the HTTP/HTTPS POST request MUST only contain an &lt;mrbconsumer> root element with only one child
                &lt;mediaResourceRequest> element as defined 
                in <xref target="sec:consumer_xml"/>.</t>

                <t>The media resource response to a query, as defined by the &lt;mediaResourceResponse> element from
                       <xref target="sec:consumer_xml"/>, MUST be carried in the body of an HTTP/HTTPS
                200 response to the original HTTP/HTTPS POST request.  The media type contained in the HTTP/HTTPS
                request/response MUST be 'application/mrb-consumer+xml'.  This value MUST
                be reflected in the appropriate HTTP headers, such as
'Content-Type' and
                'Accept'.  The body of the HTTP/HTTPS 200 response MUST only contain
                 an &lt;mrbconsumer> root element with only one child
                &lt;mediaResourceResponse> element as defined 
                in <xref target="sec:consumer_xml"/>.</t>

                <t>When an Application Server wants to release previously awarded media resources granted through a
                prior request/response exchange with an MRB, it will send a new request with an &lt;action> element with value
                'remove', as described in <xref target="sec:lease"/> ("Consumer
Interface Lease Mechanism").</t>

                </section>

                <!-- HTTP Consumer Interface Usage -->
                
                <section anchor="sec:sip_Consumer" title="In-Line Aware Mode/SIP Consumer Interface Usage">

                <t>This document provides a complete toolkit for MRB deployment that includes the ability
                to interact with an MRB using SIP for the Consumer interface.
                The following information explains the primary operations required to request and then
                receive information from an MRB, by making use of
                SIP <xref target="RFC3261"/> as transport for a request for
media resources, and the appropriate
                response when using IAMM as the mode of operation (as discussed
in <xref target="sec:IAMM_CFW"/>).</t>

                <t>The use of IAMM, besides having the MRB select appropriate media resources on behalf of a client
                application, includes setting up either a Control Framework Control Channel  between an Application
                Server and one of the Media Servers (<xref target="sec:IAMM_CFW"/>) or a media dialog session between an Application
                Server and one of the Media Servers (<xref target="sec:IAMM_CALL_LEG"/>). Note that in either case the SIP URIs of the selected
                Media Servers are made known to the requesting Application Server in the SIP 200 OK response by means of one
                or more &lt;media-server-address> child elements in the  &lt;response-session-info> element (<xref target="sec:Media_Response"/>).</t>


                <section anchor="sec:IAMM_CFW" title="IAMM and Setting Up a Control Framework Control Channel">

                <t>The media resource request information, as defined by the &lt;mediaResourceRequest> element from
                <xref target="sec:consumer_xml"/>, is carried in a SIP INVITE request.  The INVITE
                request will be constructed as it would have been to connect to a Media Server, as
                defined by the Media Control
                Channel Framework <xref target="RFC6230"/>.  It should be noted that this
                   specification does not exclude the use of an offerless INVITE as
                defined in <xref target="RFC3261">RFC 3261</xref>.  Using
offerless INVITE messages
                   to an MRB can potentially cause confusion when applying resource selection
                   algorithms, and an MRB, like any other SIP device, can choose to reject with
                   a 4xx response.  For an offerless INVITE to be treated appropriately,
                   additional contextual information would need to be provided
                   with the request; this is out of scope for this document.  The following
                additional steps MUST be followed when using the Consumer interface:        

                <list style="symbols">
                        <t>The Consumer client will include a payload in the SIP INVITE request of type
                        'multipart/mixed' <xref target="RFC2046"/>.  One of the parts to be included
                        in the 'multipart/mixed' payload MUST be the 'application/sdp' format, which is constructed as
                        specified in the Media Control Channel
                        Framework <xref target="RFC6230"/>. </t>
                        <t> Another part of the 'multipart/mixed' payload MUST be of type
                        'application/mrb-consumer+xml', as specified in this document and defined in
                        <xref target="sec:consumer_xml"/>.  The body part MUST be an XML document without prolog and whose
                        root element is &lt;mediaResourceRequest>.</t>
                        <t> The INVITE request will then be dispatched to the MRB, as defined
                        by <xref target="RFC6230"/>.</t>
                </list>
        </t>

        <t>On receiving a SIP INVITE request containing the multipart/mixed payload as specified previously, the MRB
        will complete a number of steps to fulfill the request. It will:

                <list style="symbols">
                        <t>Extract the multipart MIME payload from the SIP INVITE request. It will then use the contextual
                        information provided by the client in the 'application/mrb-consumer+xml' part to determine which
                        Media Server (or Media Servers, if more than one is deemed to be needed) should be selected to service the request.</t>

                        <t>Extract the 'application/sdp' part from the payload and use it as the body of a new SIP INVITE
                        request for connecting the client to one of the selected Media Servers, as defined in the Media Channel
                        Control Framework <xref target="RFC6230"/>. The policy the MRB follows to pick a specific Media Server out
                        of the Media Servers it selects is implementation specific and out of scope for this document. It is important to 
                        configure the SIP elements between the MRB and the Media Server in such a way
                        that the INVITE will not fork.  In the case of a failure in reaching
                        the chosen Media Server, the MRB SHOULD proceed to the next one, if available.</t>
        </list>
        </t>

        <t>If none of the available Media Servers can be reached, the MRB MUST
reply with a SIP 503 error message that includes a
        Retry-After header with a non-zero value.  The Application Server MUST
NOT attempt to set up a new session
        before the time that the MRB asked it to wait has passed.</t>
        
        <t>If at least one Media Server is reachable, the MRB acts as a
Back-to-Back User Agent (B2BUA) that
        extracts the 'application/mrb-consumer+xml' information from the SIP INVITE request and then
        sends a corresponding SIP INVITE request to the Media Server it has selected, to negotiate a Control Channel
        as defined in the Media Channel Control Framework <xref target="RFC6230"/>.</t>

        <t>In the case of a failure in negotiating the Control Channel with the Media Server, the MRB SHOULD proceed to the next one,
        if available, as explained above. If none of the available Media Servers can be reached, or the negotiations of the Control
        Channel with all of them fail, the MRB MUST reply with a SIP 503 error
message that includes a
        Retry-After header with a non-zero value. The Application Server MUST
NOT attempt to set up a new session
        before the time that the MRB asked it to wait has expired.</t>
        
        <t>Once the MRB receives the SIP response from the selected media resource (i.e., Media Server), it will in turn
        respond to the requesting client (i.e., Application Server).</t>

                <t>The media resource response generated by an MRB to a request, as defined by the &lt;mediaResourceResponse>
                element from <xref target="sec:consumer_xml"/>, MUST be carried in the payload of a SIP
                200 OK response to the original SIP INVITE request.  The SIP 200 OK
                response will be constructed as it would have been to connect from a Media Server, as
                defined by the Media Control
                Channel Framework <xref target="RFC6230"/>.  The following
                additional steps MUST be followed when using the Consumer interface:

                <list style="symbols">
                        <t>Include a payload in the SIP 200 response of type
                        'multipart/mixed' as per <xref target="RFC2046">RFC 2046</xref>.  One of the parts to be included
                        in the 'multipart/mixed' payload MUST be the 'application/sdp' format, which is constructed as
                        specified in the Media Control Channel
                        Framework <xref target="RFC6230"/> and based on the incoming response from the selected media resource.</t>
                        <t> Another part of the 'multipart/mixed' payload MUST be of type
                        'application/mrb-consumer+xml', as specified in this document and defined in
                        <xref target="sec:consumer_xml"/>.  Only the &lt;mediaResourceResponse> and its child
                        elements can be included in the payload.</t>
                        <t> The SIP 200 response will then be dispatched from the MRB.</t>
                        <t>A SIP ACK to the 200 response will then be sent back to the MRB.</t>
                </list>
        </t>

        <t>Considering that the use of SIP as a transport for Consumer transactions may result in failure,
        the IAMM relies on a successful INVITE transaction to address the previously discussed sequence
        (using the 'seq' XML element) increment mechanism. This means that
        if the INVITE is unsuccessful for any reason, the Application Server MUST use the same 'seq' value as previously used
        for the next Consumer request that it may want to send to the MRB for the same session.</t>
        
        <t>An MRB implementation may be programmed to conclude that the requested resources are no longer needed when
        it receives a SIP BYE from the Application Server or Media Server that concludes the SIP dialog that initiated
        the request, or when the lease (<xref target="sec:lease"/>) interval expires.</t>
</section>

        <section anchor="sec:IAMM_CALL_LEG" title="IAMM and Setting Up a Media Dialog">
        
                <t>This scenario is identical to the description in the previous section for setting up a Control Framework
                Control Channel, with the exception that the application/sdp payload conveys content appropriate
                for setting up the media dialog to the media resource, as per <xref target="RFC3261">RFC 3261</xref>, instead
                of setting up a Control Channel.</t>
        </section>
        <!-- HTTP Consumer Interface Usage -->

</section>

                <!-- SIP Consumer Interface Usage -->

                <section anchor="sec:lease" title="Consumer Interface Lease Mechanism">
                        
                        <t>The Consumer interface defined in
Sections <xref target="sec:Res_Cons" format="counter"/> and <xref target="sec:consumer_xml" format="counter"/> allows a client to request an appropriate
                        media resource based on information included in the request (either an HTTP POST
                        or SIP INVITE message).  In the case of success, the response that is returned to the client MUST contain
                        a &lt;response-session-info> element in either the SIP 200 or HTTP 200 response.
                        The success response contains the description of certain
                   resources that have been reserved to a specific Consumer client in a (new
                   or revised) &quot;resource session&quot;, which is identified in the
                   &lt;response-session-info>.  The resource session is a &quot;lease&quot;, in
                   that the reservation is scheduled to expire at a particular time in
                   the future, releasing the resources to be assigned for other uses.
                   The lease may be extended or terminated earlier by future
Consumer client requests that identify and reference a specific resource
session.</t>

                        <t>Before delving into the details of such a lease mechanism, it is worth
                        clarifying its role within the context of the Consumer interface. As
                        explained in <xref target="sec:MS_Pub"/>, the knowledge the MRB has of the resources
                        of all the Media Servers it is provisioned to manage is not real-time. How an MRB actually manages such
                        resources is implementation specific -- for example, an implementation may choose to have the MRB keeping
                        track and state of the allocated resources, or simply rely on the Media Servers themselves
                        to provide the information using the Publish interface.
                        Further information may also be inferred by the signaling, in the case where an MRB is in
                        the path of media dialogs.</t>

                        <t>The &lt;mediaResourceResponse> element returned from the MRB contains a &lt;response-session-info>
                        element if the request is successful.  The &lt;response-session-info> element has zero or more of
                        the following child elements, which provide the appropriate resource session information:

                        <list style="symbols">

                        <t>&lt;session-id> is a unique identifier that enables a Consumer client and MRB to
                        correlate future media resource requests related to an initial media resource request. 
                        The &lt;session-id> MUST be included in all future
related requests (see the &lt;session-id> paragraph
                        later in this section, where constructing a subsequent
request is discussed).</t>
                
                        <t>&lt;seq> is a numeric value returned to the Consumer client.  On issuing any
                        future requests related to the media resource session (as determined by the
                        &lt;session-id> element), the Consumer client MUST increment the value returned in the
                        &lt;seq> element and include it in the request
(see the &lt;seq> paragraph later in this section, where constructing a
subsequent request is discussed).
                        Its value is a non-negative integer that MUST be limited within the 0..2^31-1 range.</t>
                
                        <t>&lt;expires> provides a value indicating the number
of seconds that the
                        request for media resources is deemed alive.  The Consumer client should issue a refresh
                        of the request, as discussed later in this section, if the expiry is due to fire
                        and the media resources are still required.</t>
                
                        <t>&lt;media-server-address> provides information representing an assigned Media Server. More instances
                        of this element may appear should the MRB assign more Media Servers to a Consumer request.
                        </t>
        
                        </list>

                        </t>
                                
                        <t>The &lt;mediaResourceRequest> element is used in subsequent Consumer interface
                        requests if the client wishes to manipulate the session.  The Consumer client
                        MUST include the  &lt;session-info> element, which enables the receiving MRB
                        to determine an existing media resource allocation session.  The &lt;session-info>
                        element has the following child elements, which provide the appropriate resource session
                        information to the MRB:

                        <list style="symbols">
                        <t>&lt;session-id> is a unique identifier that allows a Consumer client to indicate the
                        appropriate existing media resource session to be manipulated by the MRB for this request.  The
                        value was provided by the MRB in the initial request for media resources, as discussed
                        earlier in this section (&lt;session-id> element included as part of the &lt;session-info>
                        element in the initial &lt;mediaResourceResponse>).</t>
                        <t>&lt;seq> is a numeric value returned to the Consumer client in the initial request for
                        media resources, as discussed earlier in this section (&lt;seq> element included as
                        part of the &lt;session-info> element in the initial &lt;mediaResourceResponse>).  On issuing any
                        future requests related to the specific media resource session (as determined by the
                        &lt;session-id> element), the Consumer client MUST increment the value returned in the
                        &lt;seq> element from the initial response (contained in the &lt;mediaResourceResponse>) for
                        every new request.  The value of the &lt;seq> element in requests acts as a counter
                        and when used in conjunction with the unique &lt;session-id> allows for unique identification of a request.
                        As anticipated before, the &lt;seq> value is limited to the 0..2^31-1 range: in the
                        unlikely case that the counter increases to reach the
highest allowed value, the &lt;seq> value MUST be set to 0.
                        The first numeric value for the &lt;seq> element is not meant to be '1' but SHOULD be generated
                        randomly by the MRB: this is to reduce the chances of a malicious MRB disrupting the session created by this MRB,
                        as explained in <xref target="sec:security"/>.
                        </t>
                        <t>&lt;action> provides the operation to be carried out by the MRB on receiving the request:
                                <list style="symbols">
                                <t>The value of 'update' is a request by the Consumer client to update the existing session on the MRB
                                with alternate media resource requirements.  If the requested
                                resource information is identical to the existing MRB session, the MRB will attempt a session refresh. 
                                If the information has changed, the MRB
                                will attempt to update the existing session with the new information.  If the operation is successful, the
                                200 status code in the response is returned in the status attribute of the &lt;mediaResourceResponseType> element. 
                                If the operation is not successful, a 409 status code in the response is
                                returned in the status attribute of the &lt;mediaResourceResponseType> element.</t>
                                <t>The value of 'remove' is a request by the Consumer client to remove
                                the session on the MRB.  This provides a mechanism for Consumer clients to release unwanted
                                resources before they expire.  If the operation is successful, a
                                200 status code in the response is returned in the status attribute of the &lt;mediaResourceResponseType> element. 
                                If the operation is not successful, a 410 status code in the response is returned in the status attribute of
                                the &lt;mediaResourceResponseType> element.</t>
                                </list>
                        </t>
                        </list>
                        </t>
                        
                        <t>Omitting the 'action' attribute means requesting a new set of resources.</t>
                                
                        <t>
                        When used with HTTP, the &lt;session-info> element MUST be included in an HTTP POST
                        message (as defined in <xref target="RFC2616"/>).
                        When used with SIP, the &lt;session-info> element MUST
instead be included in either a SIP INVITE or a
                        SIP re-INVITE (as defined in <xref target="RFC3261"/>),
or in a SIP UPDATE (as defined in <xref target="RFC3311"/>) request:
                        in fact, any SIP dialog, be it a new or an existing one, can be exploited to carry leasing information,
                        and as such new SIP INVITE messages can update other leases as well as request a new one.
                        </t>

                        <t>With IAMM, the Application Server or Media Server will eventually
                        send a SIP BYE to end the SIP session, whether it was for a
                        Control Channel or a media dialog.  That BYE contains no Consumer
                        interface lease information.</t>

                </section>

                <!-- Consumer Interface Lease Mechanism -->
        

        <section anchor="sec:mrbconsumer" title="&lt;mrbconsumer>">

        <t>This section defines the XML elements for the Consumer interface.  The formal XML schema definition
        for the Consumer interface can be found in <xref target="sec:consumer_xml"/>.</t>

        <t>The root element is &lt;mrbconsumer>.  All other XML elements (requests, responses) are
        contained within it.  The MRB Consumer interface request element is detailed in <xref target="sec:mediaResourceRequest"/>. The
        MRB Consumer interface response element is detailed in <xref target="sec:mediaResourceResponse"/>.</t>

        <t>The &lt;mrbconsumer> element has the following attributes:

        <list style="hanging">
        <t hangText="version:"> a token specifying the mrb-consumer package version.  The value
              is fixed as '1.0' for this version of the package.  The attribute
              MUST be present.</t>
        </list>
        </t>

        <t>The &lt;mrbconsumer> element may have zero or more children of one of
   the following child element types:

        <list style="hanging">
                <t>&lt;mediaResourceRequest> for sending a Consumer request.  See <xref target="sec:mediaResourceRequest"/>.</t>
                <t>&lt;mediaResourceResponse> for sending a Consumer response.  See <xref target="sec:mediaResourceResponse"/>.</t>
        </list>
        </t>
        
        </section>
        <section anchor="sec:Media_Request" title="Media Service Resource Request">

        <t>This section provides the element definitions for use in Consumer
   interface requests.  The requests are carried in the
   &lt;mediaResourceRequest> element.</t>
   
        <section anchor="sec:mediaResourceRequest" title="&lt;mediaResourceRequest>">

                <t>The &lt;mediaResourceRequest> element provides information for clients
                wishing to query an external MRB entity.  The &lt;mediaResourceRequest> element has
                a single mandatory attribute, 'id': this attribute contains a random identifier, generated
                by the client, that will be included in the response in order to map it to a specific
                request.  The &lt;mediaResourceRequest> element has
                &lt;generalInfo>, &lt;ivrInfo>, and &lt;mixerInfo> as
                child elements.  These three elements are used to describe the requirements of a
                client requesting a Media Server and are covered in
Sections <xref target="sec:requestGeneral" format="counter"/>, <xref
target="sec:requestivrInfo" format="counter"/>, and <xref
target="sec:requestMixerInfo" format="counter"/>, respectively.</t>

        <section anchor="sec:requestGeneral" title="&lt;generalInfo>">
                <t>The &lt;generalInfo> element provides general Consumer request information
                that is neither IVR specific nor mixer specific.  This includes session information that can be used for
                subsequent requests as part of the leasing mechanism described in <xref target="sec:lease"/>. 
                The following sub-sections describe the
                &lt;session-info> and &lt;packages> elements, as used by the
                &lt;generalInfo> element.</t>

                <section anchor="sec:session-info" title="&lt;session-info>">

                <t>The &lt;session-info> element is included in Consumer requests when an update is being made
                to an existing media resource session.  The ability to change and remove an existing media resource
                session is described in more detail in <xref target="sec:lease"/>.  The element MAY be present.</t>

                <t>The &lt;session-info> element has no attributes.</t>

                <t>The &lt;session-info> element has zero or more of the following child elements:

                <list style="hanging">
                <t hangText="&lt;session-id>:">A unique identifier that explicitly references an existing media
                resource session on the MRB.  The identifier is included to update the existing session and is
                described in more detail in <xref target="sec:lease"/>.</t>
                <t hangText="&lt;seq>:">Used in association with the &lt;session-id> element in a subsequent
                request to update an existing media resource session on an MRB.  The &lt;seq> number is incremented
                from its original value returned in response to the initial request for media resources.
                Its value is a non-negative integer that MUST be limited within the 0..2^31-1 range.
                In the unlikely case that the counter increases to reach the
highest allowed value, the &lt;seq> value MUST be set to 0.
                More information about its use is provided in <xref target="sec:lease"/>.</t>
                <t hangText="&lt;action>:">Provides the operation that should be carried out on an existing media
                resource session on an MRB:
                <list style="symbols">
                <t>The value of 'update' instructs the MRB to attempt to update the
                existing media resource session with the information contained in the &lt;ivrInfo> and &lt;mixerInfo>
                elements.</t>
                <t>The value of 'remove' instructs the MRB to attempt to remove the existing
                media resource session.  More information on its use is provided in <xref target="sec:lease"/>.</t>
                </list></t>
                </list>
                </t>
                </section>

                <section anchor="sec:packages" title="&lt;packages>">

                <t>The &lt;packages> element provides a list of Media Control Channel Framework compliant
                packages that are required by the Consumer client.  The element MAY be present.</t>

                <t>The &lt;packages> element has no attributes.</t>

                <t>The &lt;packages> element has a single child element:

                <list style="hanging">
                        <t hangText="&lt;package>:">Contains a string representing the Media Control
                        Channel Framework package required by the Consumer client.  The &lt;package> element
                        can appear multiple times. A valid value is a Control Package name compliant with Section 13.1.1 of <xref target="RFC6230"/>.</t>
                </list>
                </t>
                </section>

        </section>
        
        <!-- generalInfo -->
        
        <section anchor="sec:requestivrInfo" title="&lt;ivrInfo>">

                <t>The &lt;ivrInfo> element provides information for general Consumer request information
                that is IVR specific.  The following sub-sections describe the elements of the &lt;ivrInfo>
                element: &lt;ivr-sessions>, &lt;file-formats>,
                &lt;dtmf>, &lt;tones>, &lt;asr-tts>, &lt;vxml>, &lt;location>, &lt;encryption>,
                       &lt;application-data>, &lt;max-prepared-duration>, and
&lt;file-transfer-modes>.</t>

        <section anchor="sec:ivr-sessions" title="&lt;ivr-sessions>">

                <t>The &lt;ivr-sessions> element indicates the number of IVR
sessions that a Consumer client requires from a media resource.  The element
MAY be present.</t>

                <t>The &lt;ivr-sessions> element has no attributes.</t>

                <t>The &lt;ivr-sessions> element has a single child element:

                <list style="hanging">

                <t hangText="&lt;rtp-codec>:">  Describes a required codec and the number of sessions using that codec. 
                The &lt;rtp-codec> element has one attribute.  The value of the attribute, 'name', is a media type
                     (which can include parameters per <xref target="RFC6381"/>). The &lt;rtp-codec> element has two child
                      elements.  The child element &lt;decoding> contains the number of
                    RTP sessions required for decoding using the specified
codec, and the child element &lt;encoding> contains
                the number of RTP sessions required for encoding using the specified codec.</t>

                </list>
                </t>
        </section>

        <!--ivr-sessions -->

        <section anchor="sec:file-formats_consumer" title="&lt;file-formats>">

                <t>The &lt;file-formats> element provides a list of file formats required for the
                purpose of playing media.  It should be noted that this element describes media types and might
                better have been named "media-formats", but due to existing
implementations the name "file-formats" is being used.
The element MAY be present.</t>

                <t>The &lt;file-formats> element has no attributes.</t>

                <t>The &lt;file-formats> element has a single child element:

                <list style="hanging">
                <t hangText="&lt;required-format>:">Has a single attribute, 'name', which provides the
                type of file format that is required.  A valid value is a media type
                that, depending on its definition, can include
                      additional parameters (e.g., <xref target="RFC6381"/>). The &lt;required-format> element then has
                a further child element, &lt;required-file-package>.  The &lt;required-file-package>
                element has a single attribute, 'required-file-package-name', which contains the name of the Media Control Channel
                Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the file format support applies.</t>
                </list>
                </t>
        </section>

        <!--file-formats -->


        <section anchor="sec:dtmf" title="&lt;dtmf>">

                <t>The &lt;dtmf> element specifies the required methods to detect DTMF tones and to generate them. 
                The element MAY be present.</t>

                <t>The &lt;dtmf> element has no attributes.</t>

                <t>The &lt;dtmf> element has zero or more of the following child elements:

                <list style="hanging">
                <t hangText="&lt;detect>:">Indicates the required support for DTMF detection.
                The &lt;detect> element has no attributes.  The &lt;detect> element has
                a further child element, &lt;dtmf-type>.  The &lt;dtmf-type>
                element has two attributes: 'name' and 'package'.  The 'name' attribute provides the
                type of DTMF required and is a case-insensitive string containing
                 either 'RFC4733' <xref target="RFC4733"/> or 'Media' (detecting tones as signals from the audio stream).
                The 'package' attribute provides the name of the Media Control Channel
                Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the DTMF type applies.</t>

                <t hangText="&lt;generate>:">Indicates the required support for DTMF generation.
                The &lt;generate> element has no attributes.  The &lt;generate> element has
                a single child element, &lt;dtmf-type>.  The &lt;dtmf-type>
                element has two attributes: 'name' and 'package'.  The 'name' attribute provides the
                type of DTMF required and is a case-insensitive string containing
                either 'RFC4733' <xref target="RFC4733"/> or 'Media' (generating tones as signals in the audio stream).
                The 'package' attribute provides the name of the Media Control Channel
                Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the DTMF type applies.</t>

                <t hangText="&lt;passthrough>:">Indicates the required support for passing DTMF through without re-encoding.
                The &lt;passthrough> element has no attributes.  The &lt;passthrough> element then has
                a further child element, &lt;dtmf-type>.  The &lt;dtmf-type>
                element has two attributes: 'name' and 'package'.  The 'name' attribute provides the
                type of DTMF required and is a case-insensitive string containing
                either 'RFC4733' <xref target="RFC4733"/> or 'Media' (passing tones as signals through the audio stream).
                The 'package' attribute provides the name of the Media Control Channel
                Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the DTMF type applies.</t>
        
                </list>
                </t>
        </section>

        <!--DTMF -->

        <section anchor="sec:tones" title="&lt;tones>">


        <t>The &lt;tones> element provides requested
        tones that a Media Server must support for IVR. In particular, the request refers
        to both support for country codes (ISO 3166-1 <xref target="ISO.3166-1"/>) and requested
        functionality (ITU-T Recommendation Q.1950 <xref target="ITU-T.Q.1950"/>). The element MAY be present.</t>

        <t>The &lt;tones> element has no attributes.</t>

        <t>The &lt;tones> element has zero or more of the following child elements:

        <list style="hanging">
                <t hangText="&lt;country-codes>:"> Describes the requested
                country codes in relation to tones. The &lt;country-codes>
                element has no attributes. The &lt;country-codes> element has
                one child element. The child element, &lt;country-code>, requests
                a specific country code, compliant with the ISO 3166-1 <xref target="ISO.3166-1"/>
                specification. The &lt;country-code> element has a single attribute,
                'package'. The attribute 'package' provides the name of the Media
                Control Channel Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, in which the tones from the specified country code are
                requested.</t>

                <t hangText="&lt;h248-codes>:"> Describes the requested
                H.248 codes in relation to tones. The &lt;h248-codes>
                element has no attributes. The &lt;h248&nbhy;codes> element has one
                child element. The child element, &lt;h248-code>, requests
                a specific H.248 code, compliant with the ITU-T Recommendation Q.1950 <xref target="ITU-T.Q.1950"/>
                specification. The codes can be either specific (e.g., cg/dt to
                only report the Dial Tone from the Call Progress Tones package)
                or generic (e.g., cg/* to report all the tones from the Call Progress
                Tones package), using wildcards. The &lt;h248-code> element has a
                single attribute, 'package'. The attribute 'package' provides
                the name of the Media Control Channel Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, in which the specified codes are
                requested.</t>
        </list>
        </t>

        </section>
        
        <!--tones -->

        <section anchor="sec:asr-tts" title="&lt;asr-tts>">

        <t>The &lt;asr-tts> element requests information about the support for
        Automatic Speech Recognition (ASR) and Text-to-Speech (TTS) functionality
        in a Media Server. The functionality is requested by referring to the supported
        languages (using <xref target="ISO.639.2002">ISO 639-1</xref> codes) in relation to both ASR and TTS.

        The &lt;asr-tts> element has no attributes.

        The &lt;asr-tts> element has zero or more of the following child elements:
                
                
        <list style="hanging">
                
        <t hangText="&lt;asr-support>:"> Describes the available languages for ASR. The
        &lt;asr&nbhy;support> element has no attributes. The &lt;asr-support>
element has one child element.
        The child element, &lt;language>, requests that the Media Server supports ASR for a specific language.
        The &lt;language> element has a single attribute, <vspace/>'xml:lang'. The attribute 'xml:lang'
        contains the <xref target="ISO.639.2002">ISO 639-1</xref> code of the supported language.</t>

        <t hangText="&lt;tts-support>:"> Describes the available languages for TTS. The
        &lt;tts&nbhy;support> element has no attributes. The &lt;tts-support>
element has one child element.
        The child element, &lt;language>, requests that the Media Server
supports TTS for a specific language.
        The &lt;language> element has a single attribute, <vspace/>'xml:lang'. The attribute 'xml:lang'
        contains the <xref target="ISO.639.2002">ISO 639-1</xref> code of the supported language.</t>

        </list>
        </t>

        </section>
        
        <!--asr-tts -->


        <section anchor="sec:vxml" title="&lt;vxml>">

                <t>The &lt;vxml> element specifies if the Consumer client
requires VoiceXML and, if so, which protocols are supported
                (e.g., via the control framework,
                RFC 4240 <xref target="RFC4240"/>, or RFC 5552 <xref target="RFC5552"/>). 
                The element MAY be present.</t>

                <t>The &lt;vxml> element has a single child element:

                <list style="hanging">
                <t hangText="&lt;vxml-mode>:">Has two attributes: 'package' and 'require'.  The 'package' attribute
                provides the name of the Media Control Channel Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the VXML support
                applies.  The 'require' attribute specifies the type of VXML support required by the
                Consumer client (e.g., RFC 5552 <xref target="RFC5552"/>, RFC 4240 <xref target="RFC4240"/>, or IVR Package <xref target="RFC6231"/>),
                and valid values are case-insensitive RFC references (e.g.,
"rfc6231" to specify that the client requests support for
                VoiceXML as provided by the IVR Package <xref target="RFC6231"/>).</t>
        
                </list>
                </t>
                
                <t>The presence of at least one &lt;vxml> child element would indicate that the Consumer client requires VXML support
                as specified by the child element itself.  An empty &lt;vxml>
element would otherwise indicate that the Consumer client does not require VXML
support.</t>

        </section>

        <!--vxml -->

        <section anchor="sec:location" title="&lt;location>">

        <t>The &lt;location> element requests a civic
        location for an IVR Media Server.  The request makes use of the Civic Address
        Schema standardized in <xref target="RFC5139">RFC 5139</xref>. The element MAY be present.  More precisely,
        this section is entirely optional and is implementation specific in
        its level of population.</t>

        <t>The &lt;location> element has no attributes.</t>

        <t>The &lt;location> element has a single child element:

        <list style="hanging">
        <t hangText="&lt;civicAddress>:"> Describes the civic
        address location of the requested Media Server, whose representation refers to
        Section 4 of <xref target="RFC5139">RFC 5139</xref>.</t>
        
        </list>
        </t>
        </section>

        <!--location -->

        <section anchor="sec:encryption_consumer" title="&lt;encryption>">

        <t>The &lt;encryption> element allows a Consumer client to request support for encrypting RTP media streams
        using <xref target="RFC3711">RFC 3711</xref>.  The element MAY be present.  If the element is present,
        then the Media Server supports DTLS-SRTP <xref target="RFC5763"/>.</t>

        <t>The &lt;encryption> element has no attributes.</t>

        <t>The &lt;encryption> element has no child elements.</t>
        
        </section>
        
        <!--encryption -->

        <section anchor="sec:application-data_consumer" title="&lt;application-data>">

        <t>The &lt;application-data> element provides an arbitrary string of
    characters as IVR application-level data.  This data is meant to only
    have meaning at the application-level logic and as such is not
    otherwise restricted by this specification.  The set of allowed
    characters is the same as those in XML (viz., tab, carriage
    return, line feed, and the legal characters of Unicode and
    ISO/IEC&nbsp;10646 <xref target="ISO.10646.2012"/> (see also
    Section 2.2 of &lt;http://www.w3.org/TR/xml/>)).
    The element MAY be present.</t>

        <t>The &lt;application-data> element has no attributes.</t>

        <t>The &lt;application-data> element has no child elements.</t>

        </section>

        <!--application-data -->

        <section anchor="sec:max-prepared-duration_consumer" title="&lt;max-prepared-duration>">

        <t>The &lt;max-prepared-duration> element indicates the amount of time required by the Consumer client representing
        media dialog preparation in the system before it is executed.  The element MAY be present.</t>

        <t>The &lt;max-prepared-duration> element has no attributes.</t>

        <t>The &lt;max-prepared-duration> element has a single child element:


        <list style="hanging">
                <t hangText="&lt;max-time>:">Has a single attribute, 'max-time-seconds', which provides the
                amount of time in seconds that a media dialog can be in the prepared state.  The &lt;max-time> element then has
                a further child element, &lt;max-time-package>.  The &lt;max-time-package>
                element provides the name of the Media Control Channel
                Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the time period applies.</t>
        </list>
        </t>

        </section>

        <!--max-prepared-duration -->

        <section anchor="sec:file-transfer-modes_consumer" title="&lt;file-transfer-modes>">

        <t>The &lt;file-transfer-modes> element allows the Consumer client to specify which scheme names are required
        for file transfer to a Media Server for each Media Control Channel Framework package type. For example, does the Media Server
        support fetching media resources via HTTP, HTTPS, NFS, etc.?  The element MAY be present.</t>

        <t>The &lt;file-transfer-modes> element has no attributes.</t>

        <t>The &lt;file-transfer-modes> element has a single child element:

        <list style="hanging">
                <t hangText="&lt;file-transfer-mode>:">Has two attributes: 'name' and 'package'.  The 'name' attribute provides the
                scheme name of the protocol required for fetching resources: valid values are case-insensitive scheme names (e.g., HTTP,
                HTTPS, NFS, etc.).  The 'package' attribute provides the name of the Media Control Channel Framework package,
                compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the scheme name applies.</t>
        
        </list>
        </t>
        
        <t>The same considerations relating to file transfer and live streaming
are explained further in <xref target="sec:file-transfer-modes"/>
and apply here as well.</t>

</section>
<!--file-transfer-modes -->


</section>
        
<!-- ivrInfo -->
        
        <section anchor="sec:requestMixerInfo" title="&lt;mixerInfo>">

                <t>The &lt;mixerInfo> element provides information for general Consumer request information
                that is mixer specific.  The following sub-sections describe the elements of the &lt;mixerInfo>
                element: &lt;mixers>, &lt;file-formats>,
                &lt;dtmf>, &lt;tones>, &lt;mixing-modes>, &lt;application&nbhy;data>, &lt;location>, and &lt;encryption>.</t>

                <section anchor="sec:mixers" title="&lt;mixers>">

                <t>The &lt;mixers> element provides information detailing the required
                mixed RTP sessions.  The element MAY be present.</t>

                <t>The &lt;mixers> element has no attributes.</t>
                <t>The &lt;mixers> element has a single child element:


                <list style="hanging">
                <t hangText="&lt;mix>:"> Describes the required mixed RTP sessions. 
                The &lt;mix> element has one attribute.  The value of the attribute, 'users', is the number of
                participants required in the mix.  The &lt;mix> element has one child element.  The child element,
                &lt;rtp-codec>, contains the same information relating to RTP
sessions as that defined in
                     <xref target="sec:active-rtp-sessions"/>.  The element MAY be present.</t>
                </list>
                </t>

                </section>
                
                <!--active-mixer-sessions -->

                <section anchor="sec:file-formats_mixer" title="&lt;file-formats>">

                <t>The &lt;file-formats> element provides a list of file formats required by
                the Consumer client for the purpose of playing media to a mix.  The element MAY be present.</t>

                <t>The &lt;file-formats> element has no attributes.</t>

                <t>The &lt;file-formats> element has a single child element:


                <list style="hanging">
                <t hangText="&lt;required-format>:">Has a single attribute, 'name', which provides the
                type of file format supported.  A valid value is a media type
                that, depending on its definition, can include
      additional parameters (e.g., <xref target="RFC6381"/>). The &lt;required-format> element has
                a child element, &lt;required-file-package>.  The &lt;required&nbhy;file&nbhy;package>
                element contains a single attribute, 'required-file-package-name', which contains the name of the Media Control Channel
                Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the file format support applies.</t>
                </list>
                </t>
                </section>
                
                <!--file-formats -->

                <section anchor="sec:dtmf_mixer" title="&lt;dtmf>">

                <t>The &lt;dtmf> element specifies the required methods to detect DTMF tones and to generate them in a mix. 
                The element MAY be present.</t>

                <t>The &lt;dtmf> element has no attributes.</t>

                <t>The &lt;dtmf> element has zero or more of the following child elements:

                <list style="hanging">
                <t hangText="&lt;detect>:">Indicates the required support for DTMF detection.
                The &lt;detect> element has no attributes.  The &lt;detect> element then has
                a further child element, &lt;dtmf-type>.  The &lt;dtmf-type>
                element has two attributes: 'name' and 'package'.  The 'name' attribute provides the
                type of DTMF being used and is a case-insensitive string containing
                either 'RFC4733' <xref target="RFC4733"/> or 'Media' (detecting tones as signals from the audio stream).
                The 'package' attribute provides the name of the Media Control Channel
                Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the DTMF type applies.</t>

                <t hangText="&lt;generate>:">Indicates the required support for DTMF generation.
                The &lt;generate> element has no attributes.  The &lt;generate> element has
                a single child element, &lt;dtmf-type>.  The &lt;dtmf-type>
                element has two attributes: 'name' and 'package'.  The 'name' attribute provides the
                type of DTMF being used and is a case-insensitive string containing
                either 'RFC4733' <xref target="RFC4733"/> or 'Media' (generating tones as signals in the audio stream).
                The 'package' attribute provides the name of the Media Control Channel
                Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the DTMF type applies.</t>

                <t hangText="&lt;passthrough>:">Indicates the required support for passing DTMF through without re-encoding.
                The &lt;passthrough> element has no attributes.  The &lt;passthrough> element has
                a single child element, &lt;dtmf-type>.  The &lt;dtmf-type>
                element has two attributes: 'name' and 'package'.  The 'name' attribute provides the
                type of DTMF being used and is a case-insensitive string containing
                either 'RFC4733' <xref target="RFC4733"/> or 'Media' (passing tones as signals through the audio stream).
                The 'package' attribute provides the name of the Media Control Channel
                Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the DTMF type applies.</t>
        
                </list>
                </t>
        </section>

        <!--DTMF -->

        <section anchor="sec:tones_mixer" title="&lt;tones>">


        <t>The &lt;tones> element provides requested
        tones that a Media Server must support for a mix. In particular, the request refers
        to both support for country codes (ISO 3166-1 <xref target="ISO.3166-1"/>) and requested
        functionality (ITU-T Recommendation Q.1950 <xref target="ITU-T.Q.1950"/>). The element MAY be present.</t>

        <t>The &lt;tones> element has no attributes.</t>

        <t>The &lt;tones> element has zero or more of the following child elements:

        <list style="hanging">
                <t hangText="&lt;country-codes>:"> Describes the requested
                country codes in relation to tones. The &lt;country-codes>
                element has no attributes. The &lt;country-codes> element has a single
                child element. The child element, &lt;country-code>, requests
                a specific country code, compliant with the ISO 3166-1 <xref target="ISO.3166-1"/>
                specification. The &lt;country-code> element has a single attribute,
                'package'. The attribute 'package' provides the name of the Media
                Control Channel Framework package, compliant with the specification in the related
                IANA registry (e.g., "msc-ivr/1.0"), in which the tones from the specified country
                code are requested.</t>

                <t hangText="&lt;h248-codes>:"> Describes the requested
                H.248 codes with respect to tones. The &lt;h248-codes>
                element has no attributes. The &lt;h248&nbhy;codes> element has a single
                child element. The child element, &lt;h248-code>, requests
                a specific H.248 code, compliant with the ITU-T Recommendation Q.1950 <xref target="ITU-T.Q.1950"/>
                specification. The codes can be either specific (e.g., cg/dt to
                only report the Dial Tone from the Call Progress Tones package)
                or generic (e.g., cg/* to report all the tones from the Call Progress
                Tones package), using wildcards. The &lt;h248-code> element has a
                single attribute, 'package'. The attribute 'package' provides
                the name of the Media Control Channel Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, in which
                the specified codes are requested.</t>
        </list>
        </t>

        </section>
        
        <!--tones -->

        <section anchor="sec:mixing-modes_mixer" title="&lt;mixing-modes>">


        <t>The &lt;mixing-modes> element requests information relating to support for audio
        and video mixing, more specifically a list of supported algorithms
        to mix audio and a list of supported video presentation layouts. The element MAY be present.</t>

        <t>The &lt;mixing-modes> element has no attributes.</t>

        <t>The &lt;mixing-modes> element has zero or more of the following child elements:


        <list style="hanging">
        <t hangText="&lt;audio-mixing-modes>:"> Describes the requested algorithms for
        audio mixing. The &lt;audio-mixing-modes> element has no attributes. The
        &lt;audio-mixing-modes> element has one child element. The child element,
        &lt;audio-mixing-mode>, contains a requested mixing algorithm. Valid values
        for the &lt;audio-mixing-mode> element are algorithm names, e.g., 'nbest' and 'controller'
        as defined in <xref target="RFC6505"/>. The element has a single
        attribute, 'package'. The attribute 'package' provides the name of the Media
        Control Channel Framework package, compliant with Section 13.1.1 of
<xref target="RFC6230"/>, for which the algorithm support is requested.</t>

        <t hangText="&lt;video-mixing-modes>:"> Describes the requested video
        presentation layouts for video mixing. The &lt;video-mixing-modes> element
        has two attributes: 'vas' and 'activespeakermix'. The 'vas' attribute is of
        type boolean with a value of 'true' indicating that the Consumer client requires
        automatic Voice Activated Switching. The 'activespeakermix' attribute is of
        type boolean with a value of 'true' indicating that the Consumer client requires
        an additional video stream for the loudest speaker participant without its contribution.
        The &lt;video-mixing-modes> element has one child element.
        The child element, &lt;video-mixing-mode>, contains the name of a specific video presentation
        layout. The name may refer to one of the predefined video layouts defined in the XCON
        conference information data model, or to non-XCON layouts as well, as long as they are appropriately prefixed.
        The &lt;video&nbhy;mixing&nbhy;mode> element has a single attribute, 'package'. The attribute 'package' provides the
        name of the Media Control Channel Framework package, compliant with Section 13.1.1 of <xref target="RFC6230"/>, for which the algorithm
        support is requested.</t>

        </list>
        </t>


        </section>
        
        <!--mixing-modes -->


        <section anchor="sec:application-data_mixer" title="&lt;application-data>">

        <t>The &lt;application-data> element provides an arbitrary string of
    characters as mixer application-level data.  This data is meant to only
    have meaning at the application-level logic and as such is not
    otherwise restricted by this specification.  The set of allowed
    characters is the same as those in XML (viz., tab, carriage
    return, line feed, and the legal characters of Unicode and
    ISO/IEC&nbsp;10646 <xref target="ISO.10646.2012"/> (see also
    Section 2.2 of &lt;http://www.w3.org/TR/xml/>)).
    The element MAY be present.</t>

        <t>The &lt;application-data> element has no attributes.</t>

        <t>The &lt;application-data> element has no child elements.</t>

        </section>

        <!--application-data -->


        <section anchor="sec:location_mixer" title="&lt;location>">

        <t>The &lt;location> element requests a civic
        location for a mixer Media Server.  The request makes use of the Civic Address
        Schema standardized in <xref target="RFC5139">RFC 5139</xref>. The element MAY be present.  More precisely,
        this section is entirely optional, and it's implementation specific to fill it with just the details each
        implementer deems necessary for any optimization that may be needed.</t>

        <t>The &lt;location> element has no attributes.</t>

        <t>The &lt;location> element has a single child element:

        <list style="hanging">
        <t hangText="&lt;civicAddress>:"> Describes the civic
        address location of the requested Media Server, whose representation refers to
        Section 4 of <xref target="RFC5139">RFC 5139</xref>.</t>
        
        </list>
        </t>

        </section>

        <!--location -->

        <section anchor="sec:encryption_mixer" title="&lt;encryption>">

        <t>The &lt;encryption> element allows a Consumer client to request support for encrypting mixed RTP media streams
        using <xref target="RFC3711">RFC 3711</xref>.  The element MAY be present.  If the element is present,
        then the Media Server supports DTLS-SRTP <xref target="RFC5763"/>.</t>

        <t>The &lt;encryption> element has no attributes.</t>

        <t>The &lt;encryption> element has no child elements.</t>
        
        </section>
        
        <!--encryption -->


        </section>
        
        <!-- MixerInfo -->

        </section>

        <!-- MediaResourceRequest -->

</section>

<!-- Consumer -->

        <section anchor="sec:Media_Response" title="Media Service Resource Response">

                <t>This section provides the element definitions for use in Consumer interface
                responses.  The responses are carried in the &lt;mediaResourceResponse>
                element.</t>

        <section anchor="sec:mediaResourceResponse" title="&lt;mediaResourceResponse>">

        <t>The &lt;mediaResourceResponse> element provides information for clients
                receiving response information from an external MRB entity.</t>

                <t>The &lt;mediaResourceResponse> element has two mandatory attributes: 'id' and 'status'.
                The 'id' attribute must contain the same value that the client provided
                in the 'id' attribute in the &lt;mediaResourceRequest> to which
the response is mapped. The 'status' attribute
                indicates the status code of the operation.  The following status codes are defined for 'status': </t>

<?rfc compact="no" ?>
       <texttable anchor="defn.response.statuscodes.consumer"
                title="&lt;mediaResourceResponse> Status Codes" >
                <ttcol align="left" width="15%">code</ttcol>
                <ttcol align="left" width="85%">description</ttcol>
                                <c>200</c>
                                        <c>OK</c>
                                <c>400</c>
                                        <c>Syntax error</c>
                                <c>405</c>
                                        <c>Wrong sequence number</c>
                                <c>408</c>
                                        <c>Unable to find Resource</c>
                                <c>409</c>
                                        <c>Unable to update Resource</c>
                                <c>410</c>
                                        <c>Unable to remove Resource</c>
                                <c>420</c>
                                        <c>Unsupported attribute or element</c>
       </texttable>
<?rfc compact="yes" ?>
<t>
                If a new media resource request made by a client application has been accepted,
                the MRB MUST reply with a &lt;mediaResourceResponse> with status code 200. The same rule applies
                whenever a request to update (action='update') or remove (action='remove') an
                existing transaction can be fulfilled by the MRB.
</t>
<t>
                A media resource request, nevertheless, may fail for several reasons. In such
                a case, the status codes defined in <xref target="defn.response.statuscodes.consumer"/>
                must be used instead. Specifically, if the MRB fails to handle a request
                due to a syntax error in the request itself (e.g., incorrect XML,
                violation of the schema constraints, or invalid values in any of the
                attributes/elements), the MRB MUST reply with a &lt;mediaResourceResponse> with status code 400.
                If a syntactically correct request fails because the request also includes any
                attribute/element the MRB doesn't understand, the MRB MUST reply with a &lt;mediaResourceResponse> with status code 420.
                If a syntactically correct request fails because it contains a wrong sequence number,
                that is, a 'seq' value not consistent with the increment the MRB expects according to <xref target="sec:lease"/>,
                the MRB MUST reply with a &lt;mediaResourceResponse> with status code 405.
                If a syntactically correct request fails because the MRB couldn't find any Media Server able to
                fulfill the requirements presented by the Application Server in its request, the MRB MUST reply
                with a &lt;mediaResourceResponse> with status code 408.
                If a syntactically correct request fails because the MRB couldn't update an
                existing request according to the new requirements presented by the Application Server in
                its request, the MRB MUST reply with a &lt;mediaResourceResponse> with status code 409.
                If a syntactically correct request fails because the MRB couldn't remove an
                existing request and release the related resources as requested by the Application Server,
                the MRB MUST reply with a &lt;mediaResourceResponse> with status code 410.
</t>
<t>
                Further details on status codes 409 and 410 are included in <xref target="sec:lease"/>,
                where the leasing mechanism, along with its related scenarios, is described in more detail.
</t>


        
                     <t>The &lt;mediaResourceResponse>
                element has &lt;response-session-info> as a
                child element.  This element is used to describe the response of a Consumer interface
                query and is covered in the following sub-section.</t>


                <section anchor="sec:response-session-info" title="&lt;response-session-info>">

                <t>The &lt;response-session-info> element is included in Consumer responses. This applies to responses
                to both requests for new resources and requests to update an existing media resource session.
                The ability to change and remove an existing media resource
                session is described in more detail in <xref target="sec:lease"/>.
                If the request was successful, the &lt;mediaResourceResponse> MUST
           have one &lt;response&nbhy;session&nbhy;info> child, which describes the media
           resource session addressed by the request.  If the
           request was not successful, the &lt;mediaResourceResponse> MUST NOT
           have a &lt;response-session-info> child.
                </t>

                <t>The &lt;response-session-info> element has no attributes.</t>

                <t>The &lt;response-session-info> element has zero or more of the following child elements:

                <list style="hanging">
                <t hangText="&lt;session-id>:">A unique identifier that explicitly references an existing media
                resource session on the MRB.  The identifier is included to update the existing session and is
                described in more detail in <xref target="sec:lease"/>.</t>
                <t hangText="&lt;seq>:">Used in association with the &lt;session-id> element in a subsequent
                request to update an existing media resource session on an MRB.  The &lt;seq> number is incremented
                from its original value returned in response to the initial
request for media resources.  More information on
                its use is provided in <xref target="sec:lease"/>.</t>
                <t hangText="&lt;expires>:">Includes the number of seconds that the media resources are reserved as part of this
                interaction.  If the lease is not refreshed before expiry, the MRB will reclaim the resources and they will
                no longer be guaranteed.  It is RECOMMENDED that a minimum value of 300 seconds be used for the value 
                of the 'expires' attribute.  It is also RECOMMENDED that a Consumer client refresh the lease at an
                interval that is not too close to the expiry time.  A value of 80% of the timeout period could be used.
                   For example, if the timeout period is 300 seconds, the Consumer client would
                   refresh the transaction at 240 seconds.  More information on its use is provided in <xref target="sec:lease"/>.</t>

                <t hangText="&lt;media-server-address>:">Provides information to reach the Media Server handling the requested media resource.  One or
                more instances of these elements may appear.  The &lt;media&nbhy;server&nbhy;address> element has a single attribute named
                'uri', which supplies a SIP URI that reaches the specified Media Server.  It also has three optional elements:
                &lt;connection-id>, &lt;ivr&nbhy;sessions>, and &lt;mixers>.  The
&lt;ivr-sessions> and &lt;mixers> elements are defined in Sections <xref target="sec:ivr-sessions" format="counter"/> and
                       <xref target="sec:mixers" format="counter"/>,
respectively, and have the same meaning but are applied to individual Media Server instances as a
                subset of the overall resources reported in the &lt;connection-id>
                element.  If multiple Media Servers are assigned in an IAMM operation, exactly one &lt;media-server-address>
                        element, more specifically the Media Server that provided the media dialog or CFW response, will have a
                        &lt;connection-id> element. Additional information relating to the use of the &lt;connection-id> element
                        for media dialogs is included in <xref target="sec:b2bua"/>.</t>
                </list>
                </t>
                </section>


        </section>

        
        </section>


        </section>
        <!-- Media Server Consumer Interface -->

        <section anchor="sec:In_Line" title="In-Line Unaware MRB Interface">
                <t>An entity acting as an In-line MRB can act in one of two roles for a request, as introduced
                in <xref target="sec:Inline"/>: the In-line Unaware
                MRB Mode (IUMM) of operation and the In-line Aware MRB Mode (IAMM) of operation.  This section
                further describes IUMM.</t>

                <t>It should be noted that the introduction of an MRB entity into the network, as specified in this document, 
                requires interfaces to be implemented by those requesting Media Server resources (for example, an Application 
                Server).  This applies when using the Consumer interface as discussed in
                Sections <xref target="sec:http_Consumer" format="counter"/>
(Query mode) and <xref target="sec:sip_Consumer" format="counter"/> (IAMM). An
                MRB entity can also act in a client-unaware mode when deployed into the network. 
                This allows any SIP-compliant client entity, as defined by <xref target="RFC3261">RFC 3261</xref> and its
                extensions, to send requests to an MRB that in turn will select an appropriate Media Server based on
                knowledge of Media Server resources it currently has available transparently to the client entity.
                Using an MRB in this mode allows for
                easy migration of current applications and services that are unaware of the MRB concept and would simply require
                a configuration change resulting in the MRB being set as a SIP outbound proxy for clients requiring media
                services.</t>

                <t>With IUMM, the MRB may conclude that an assigned media resource is no longer needed when it receives a SIP
                BYE from the Application Server or Media Server that ends the SIP dialog that initiated the request.</t>

                <t>As with IAMM, in IUMM the SIP INVITE from the Application
Server could convey the application/sdp payload to either
                set up a media dialog or a Control Framework Control Channel.  In either case, in order to permit the Application Server
                to associate a media dialog with a Control Channel to the same Media Server, using the
                   procedures of <xref target="RFC6230"/> Section 6, the MRB should be acting as a SIP
                   proxy (and not a B2BUA).  This allows the SIP URI of the targeted
                   Media Server to be transparently passed back to the Application
                   Server in the SIP response, resulting in a direct SIP dialog
between the Application Server and the Media Server.</t>

                <t>While IUMM has the least impact on legacy Application Servers, it also provides the least versatility.
                See <xref target="sec:merits"/>.</t>

        </section>
        <!-- IUMM -->

</section>
<!-- MRB Interface Definitions -->

<section anchor="sec:b2bua" title="MRB Acting as a B2BUA">

        <t>An MRB entity can act as a SIP Back-to-Back User Agent (B2BUA) or a SIP Proxy Server as defined in
        <xref target="RFC3261">RFC 3261</xref>.  When an MRB acts as a B2BUA, issues can arise when using Media Control Channel
        packages such as the IVR <xref target="RFC6231"/> and mixer <xref target="RFC6505"/>
        packages.  Specifically, the framework attribute 'connectionid' as
provided in Appendix A ("Common Package Components") of 
        <xref target="RFC6230"/> uses a concatenation of the SIP dialog identifiers to be
        used for referencing SIP dialogs within the Media Control Channel.  When a request traverses an MRB acting as a
        B2BUA, the SIP dialog identifiers change, and so the 'connectionid'
cannot be used as intended due to this change.
        For this reason, when an MRB wishes to act as a SIP B2BUA when handling a request from an Application Server to set
        up a media dialog to a Media Server, it MUST include the optional
        &lt;connection-id> element in a Consumer interface response with a value that provides the equivalent for the 'connectionid'
        ('Local Dialog Tag' + 'Remote Dialog Tag') for the far side of the B2BUA.  If present, this value MUST be used
        as the value for the 'connectionid' in packages where the Common Package Components are used.  The &lt;connection-id>
        element MUST NOT be included in an HTTP Consumer interface response.</t>
        <t>It is important to point out that although more Media Server instances may be returned in a Consumer response (i.e., the
        MRB has assigned more than one Media Server to a Consumer request to fulfill the Application Server requirements), in IAMM the MRB will
        only act as a B2BUA with a single Media Server.  In this case, exactly one &lt;media-server-address> element,
        describing the media dialog or CFW response, will have a
&lt;connection-id> element that will not be included
        in any additional &lt;media-server-address> elements.</t>

</section>
<!-- MRB Acting as a B2BUA -->

<section anchor="sec:multi" title="Multi-Modal MRB Implementations">

        <t>An MRB implementation may operate multi-modally with a collection of Application Server clients all sharing the same
        pool of media resources. That is, an MRB may be simultaneously operating in Query mode, IAMM, and IUMM. It knows in which
        mode to act on any particular request from a client, depending on the context of the request:

        <list style="symbols">

        <t>If the received request is an HTTP POST message with
application/mrb-consumer+xml content, then the MRB processes it in Query mode.</t>
        <t>If the received request is a SIP INVITE with
application/mrb-consumer+xml content and application/sdp content, then the
        MRB processes it in IAMM.</t>
        <t>If the received request is a SIP INVITE without application/mrb-consumer+xml content but with application/sdp content,
                then the MRB processes it in IUMM.</t>
        </list>
        </t>
</section>
<!-- Multi-modal MRB Implementations -->

<section anchor="sec:merits" title="Relative Merits of Query Mode, IAMM, and IUMM">

        <t>At a high level, the possible Application Server MRB interactions
can be distinguished by the following basic types:

        <list style="letters">

                <t>Query mode - the client is requesting the assignment by the
MRB of suitable Media Server resources;</t>
                <t>IAMM/media dialog - the client is requesting the assignment
by the MRB of suitable Media Server resources and the
                establishment of a media dialog to one of the Media
Servers;</t>
                <t>IAMM/Control Channel - the client is requesting
the assignment by the MRB of suitable Media Server resources and the
establishment of a CFW Control Channel to one of the Media Servers;</t>
                <t>IUMM/media dialog - the client is requesting the
establishment of a media dialog to a Media Server resource;</t>
                <t>IUMM/Control Channel - the client is requesting the
establishment of a CFW Control Channel to a Media Server resource.</t>
        </list>
        Each type of interaction has advantages and disadvantages, where such considerations relate to
        the versatility of what the MRB can provide, technical aspects such as efficiency in different application scenarios,
        complexity, delay, use with legacy Application Servers, or use with the Media Control Channel Framework. Depending on
        the characteristics of a particular setting that an MRB is intended to support, some of the above interaction types may
        be more appropriate than others.  This section provides a few observations on relative merits but is not intended to be
        exhaustive. Some constraints of a given interaction type may be subtle.
        

        <list style="symbols">
                
                <t>Operation with other types of media control: Any of the
types of interactions work with the mechanisms described in
                <xref target="RFC4240">RFC 4240</xref> and <xref target="RFC5552">RFC 5552</xref> where initial control
                instructions are conveyed in the SIP INVITE from the Application
                Server for the media dialog to the Media Server and subsequent instructions may be fetched using HTTP. Query mode
                (a), IAMM/media dialog (b), and IUMM/media dialog (d) work with
the Media Server Markup Language (MSML) as per <xref target="RFC5707">RFC
5707</xref> or the Media Server Control Markup Language (MSCML)
as per <xref target="RFC5022">RFC 5022</xref>.</t>

                <t>As stated previously, IUMM has no interface impacts on an Application Server. When using IUMM,
                the Application Server does not specify the characteristics of the type of media resource it requires, as
                the &lt;mediaResourceRequest> element is not passed to the MRB. For IUMM/media dialog (d), the MRB can
                deduce an appropriate media resource on a best-effort basis using information gleaned from examining information
                in the SIP INVITE.  This includes the SDP information for the media dialog, or initial control information in
                the SIP Request-URI as per <xref target="RFC4240">RFC 4240</xref>. With
                IUMM/Control Channel (e), there is even less information for the MRB to use. </t>

                <t>If using IUMM/Control Channel (e), the subsequent sending of the media dialog to the Media Server should not
                be done using IUMM/media dialog. That is, the SIP signaling to send the media dialog to the selected Media Server must be
                directly between the Application Server and that Media Server, and not through the MRB. Unless resources can
                be confidentially identified, the MRB could
                send the media dialog to a different Media Server. Likewise, if
using IUMM/media dialog (d), the subsequent
                establishment of a Control Channel should not be done with IUMM/Control Channel (e) unless definitive information
                is available.</t>

                <t>Query mode (a) and IAMM/Control Channel (c) lend themselves to requesting a pool of media
                resources (e.g., a number of IVR or conferencing ports) in advance of use and retaining use over a
                period of time, independent of whether there are media dialogs to those resources at any given moment, whereas
                the other types of interactions do not.  This also applies to
making a subsequent request to increase or decrease
                the amount of resources previously awarded.</t>

        <t>While Query mode (a) and IAMM/Control Channel (c) are the most versatile interaction types, the former
        is completely decoupled from the use or non-use of a Control Channel,
whereas the latter requires the use of a Control Channel.</t>

        <t>When Media Control Channel Framework Control Channels are to be used
in conjunction with the use of an MRB, Query
        mode (a) would typically result in fewer such channels being established over time, as compared to IAMM/Control Channel
        (c). That is because the latter would involve setting up an additional Control Channel every time an Application Server has a new
        request for an MRB for media resources.</t>

        </list>
        </t>
</section>
<!-- Relative Merits of Query Mode, IAMM, and IUMM -->

<section anchor="sec:Examples" title="Examples">

        <t>This section provides examples of both the Publish and Consumer
interfaces. Both the Query mode and In-line mode are addressed.</t>
        <t>
                Note that due to RFC formatting conventions, this section often splits
                HTTP, SIP/SDP, and CFW across lines whose content would exceed 72 characters.
                A backslash character marks where this line folding has taken place.  This
                backslash, and its trailing CRLF and whitespace, would not appear in the actual
                protocol contents.  Also note that the indentation of the XML
                content is only provided for readability: actual messages will follow strict
                XML syntax, which allows for but does not require indentation.
        </t>

        <section anchor="sec:ExPub" title="Publish Example">
        
           <t>
                   The following example assumes that a Control Channel has
been established and synced as described in the Media Control Channel Framework
                   (<xref target="RFC6230"/>).
           </t>
           <t>
                        <xref target="fig-expub"/> shows the subscription/notification mechanism
                        the Publish interface is based on, as defined in <xref target="sec:MS_Pub"/>.
                        The MRB subscribes for information at the Media Server (message A1.), and the Media Server accepts the subscription (A2.).
                        Notifications are triggered by the Media Server (B1.) and acknowledged by the MRB (B2.).
           </t>

                                <figure anchor="fig-expub" title="Publish Example: Sequence Diagram"> <artwork><![CDATA[
        MRB                                            MS
         |                                              |
         | A1. CONTROL (MRB subscription)               |
         |--------------------------------------------->|
         |                                   A2. 200 OK |
         |<---------------------------------------------|
         |                                              |
         .                                              .
         .                                              .
         |                                              |
         |                                              |--+ collect
         |                                              |  | up-to-date
         |                                              |<-+ info
         |               B1. CONTROL (MRB notification) |
         |<---------------------------------------------|
         | B2. 200 OK                                   |
         |--------------------------------------------->|
         |                                              |
         .                                              .
         .                                              .
                                      ]]></artwork> </figure>

               <t>
              The rest of this section includes a full dump of the messages
              associated with the previous sequence diagram, specifically:
               </t>
               <t>
                  <list style="numbers">
                    <t>the subscription (A1.), in an &lt;mrbrequest&gt; (CFW
CONTROL);</t>

                    <t>the Media Server accepting the subscription (A2.), in an
&lt;mrbresponse&gt; (CFW 200);</t>

                    <t>a notification (B1.), in an &lt;mrbnotification&gt; (CFW
CONTROL);</t>

                     <t>the ack to the notification (B2.), in a framework-level 200 message (CFW 200).</t>
                  </list>
               </t>

                                <figure> <artwork> <![CDATA[
A1. MRB -> MS (CONTROL, publish request)
----------------------------------------
CFW lidc30BZObiC CONTROL
Control-Package: mrb-publish/1.0
Content-Type: application/mrb-publish+xml
Content-Length: 337

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<mrbpublish version="1.0" xmlns="urn:ietf:params:xml:ns:mrb-publish">
    <mrbrequest>
        <subscription action="create" seqnumber="1" id="p0T65U">
            <expires>600</expires>
            <minfrequency>20</minfrequency>
            <maxfrequency>20</maxfrequency>
        </subscription>
    </mrbrequest>
</mrbpublish>


A2. MRB <- MS (200 to CONTROL, request accepted)
------------------------------------------------
CFW lidc30BZObiC 200
Timeout: 10
Content-Type: application/mrb-publish+xml
Content-Length: 139

<mrbpublish version="1.0" xmlns="urn:ietf:params:xml:ns:mrb-publish">
        <mrbresponse status="200" reason="OK: Request accepted"/>
</mrbpublish>


B1. MRB <- MS (CONTROL, event notification from MS)
---------------------------------------------------
CFW 03fff52e7b7a CONTROL
Control-Package: mrb-publish/1.0
Content-Type: application/mrb-publish+xml
Content-Length: 4226

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <mrbpublish version="1.0"
             xmlns="urn:ietf:params:xml:ns:mrb-publish">
    <mrbnotification seqnumber="1" id="QQ6J3c">
        <media-server-id>a1b2c3d4</media-server-id>
        <supported-packages>
            <package name="msc-ivr/1.0"/>
            <package name="msc-mixer/1.0"/>
            <package name="mrb-publish/1.0"/>
            <package name="msc-example-pkg/1.0"/>
        </supported-packages>
        <active-rtp-sessions>
            <rtp-codec name="audio/basic">
                <decoding>10</decoding>
                <encoding>20</encoding>
            </rtp-codec>
        </active-rtp-sessions>
        <active-mixer-sessions>
            <active-mix conferenceid="7cfgs43">
                <rtp-codec name="audio/basic">
                    <decoding>3</decoding>
                    <encoding>3</encoding>
                </rtp-codec>
            </active-mix>
        </active-mixer-sessions>
        <non-active-rtp-sessions>
            <rtp-codec name="audio/basic">
                <decoding>50</decoding>
                <encoding>40</encoding>
            </rtp-codec>
        </non-active-rtp-sessions>
        <non-active-mixer-sessions>
            <non-active-mix available="15">
                <rtp-codec name="audio/basic">
                    <decoding>15</decoding>
                    <encoding>15</encoding>
                </rtp-codec>
            </non-active-mix>
        </non-active-mixer-sessions>
        <media-server-status>active</media-server-status>
        <supported-codecs>
            <supported-codec name="audio/basic">
                <supported-codec-package name="msc-ivr/1.0">
                    <supported-action>encoding</supported-action>
                    <supported-action>decoding</supported-action>
                </supported-codec-package>
                <supported-codec-package name="msc-mixer/1.0">
                    <supported-action>encoding</supported-action>
                    <supported-action>decoding</supported-action>
                </supported-codec-package>
            </supported-codec>
        </supported-codecs>
        <application-data>TestbedPrototype</application-data>
        <file-formats>
            <supported-format name="audio/x-wav">
                <supported-file-package>
                    msc-ivr/1.0
                </supported-file-package>
            </supported-format>
        </file-formats>
        <max-prepared-duration>
            <max-time max-time-seconds="3600">
                <max-time-package>msc-ivr/1.0</max-time-package>
            </max-time>
        </max-prepared-duration>
        <dtmf-support>
            <detect>
                <dtmf-type package="msc-ivr/1.0" name="RFC4733"/>
                <dtmf-type package="msc-mixer/1.0" name="RFC4733"/>
            </detect>
            <generate>
                <dtmf-type package="msc-ivr/1.0" name="RFC4733"/>
                <dtmf-type package="msc-mixer/1.0" name="RFC4733"/>
            </generate>
            <passthrough>
                <dtmf-type package="msc-ivr/1.0" name="RFC4733"/>
                <dtmf-type package="msc-mixer/1.0" name="RFC4733"/>
            </passthrough>
        </dtmf-support>
        <mixing-modes>
            <audio-mixing-modes>
                <audio-mixing-mode package="msc-ivr/1.0">
                     nbest
                </audio-mixing-mode>
            </audio-mixing-modes>
            <video-mixing-modes activespeakermix="true" vas="true">
                <video-mixing-mode package="msc-mixer/1.0">
                     single-view
                </video-mixing-mode>
                <video-mixing-mode package="msc-mixer/1.0">
                     dual-view
                </video-mixing-mode>
                <video-mixing-mode package="msc-mixer/1.0">
                     dual-view-crop
                </video-mixing-mode>
                <video-mixing-mode package="msc-mixer/1.0">
                     dual-view-2x1
                </video-mixing-mode>
                <video-mixing-mode package="msc-mixer/1.0">
                     dual-view-2x1-crop
                </video-mixing-mode>
                <video-mixing-mode package="msc-mixer/1.0">
                     quad-view
                </video-mixing-mode>
                <video-mixing-mode package="msc-mixer/1.0">
                     multiple-5x1
                </video-mixing-mode>
                <video-mixing-mode package="msc-mixer/1.0">
                     multiple-3x3
                </video-mixing-mode>
                <video-mixing-mode package="msc-mixer/1.0">
                     multiple-4x4
                </video-mixing-mode>
            </video-mixing-modes>
        </mixing-modes>
        <supported-tones>
            <supported-country-codes>
                <country-code package="msc-ivr/1.0">GB</country-code>
                <country-code package="msc-ivr/1.0">IT</country-code>
                <country-code package="msc-ivr/1.0">US</country-code>
            </supported-country-codes>
            <supported-h248-codes>
                <h248-code package="msc-ivr/1.0">cg/*</h248-code>
                <h248-code package="msc-ivr/1.0">biztn/ofque</h248-code>
                <h248-code package="msc-ivr/1.0">biztn/erwt</h248-code>
                <h248-code package="msc-mixer/1.0">conftn/*</h248-code>
            </supported-h248-codes>
        </supported-tones>
        <file-transfer-modes>
            <file-transfer-mode package="msc-ivr/1.0" name="HTTP"/>
        </file-transfer-modes>
        <asr-tts-support>
            <asr-support>
                <language xml:lang="en"/>
            </asr-support>
            <tts-support>
                <language xml:lang="en"/>
            </tts-support>
        </asr-tts-support>
        <vxml-support>
            <vxml-mode package="msc-ivr/1.0" support="RFC6231"/>
        </vxml-support>
        <media-server-location>
            <civicAddress xml:lang="it">
                <country>IT</country>
                <A1>Campania</A1>
                <A3>Napoli</A3>
                <A6>Via Claudio</A6>
                <HNO>21</HNO>
                <LMK>University of Napoli Federico II</LMK>
                <NAM>Dipartimento di Informatica e Sistemistica</NAM>
                <PC>80210</PC>
            </civicAddress>
        </media-server-location>
        <label>TestbedPrototype-01</label>
     <media-server-address>sip:MS1@ms.example.net</media-server-address>
     <encryption/>
    </mrbnotification>
   </mrbpublish>


B2. MRB -> MS (200 to CONTROL)
------------------------------
CFW 03fff52e7b7a 200
                                        ]]> </artwork> </figure>

        </section>

        <!-- Publish Example -->

        <section anchor="sec:ExCons" title="Consumer Examples">

                <t>
                As specified in <xref target="sec:Res_Cons"/>, the Consumer interface
                can be involved in two different modes: Query and In-line aware. When in Query mode,
                Consumer messages are transported in HTTP messages: an example of such an
                approach is presented in <xref target="sec:ExConsQuery"/>. When in
                In-line aware mode, messages are instead transported as part of SIP negotiations:
                considering that SIP negotiations may be related to either the creation of a
                Control Channel or to a User Agent Client (UAC) media dialog, two separate examples of such an approach are
                presented in <xref target="sec:ExConsIAMM"/>.
                </t>
                
                <section anchor="sec:ExConsQuery" title="Query Example">

           <t>
                   The following example assumes that the interested
Application Server already knows the HTTP URL where an MRB is listening for
Consumer messages.
           </t>
           <t>
                        <xref target="fig-excons"/> shows the HTTP-based
transaction between the Application Server (AS, as shown in the figure) and
                        the MRB. The Application Server sends a Consumer request as payload of an HTTP POST message (1.),
                        and the MRB provides an answer in an HTTP 200 OK message (2.). Specifically,
                        as will be shown in the examples, the Application Server is interested in 100 IVR ports: the MRB
                        finds two Media Servers that can satisfy the request
(one providing 60 ports and the other providing 40 ports)
                        and reports them to the Application Server.
           </t>

           <figure anchor="fig-excons" title="Consumer Example (Query):
Sequence Diagram"> <artwork> <![CDATA[
    AS                                             MRB
     |                                              |
     | 1. HTTP POST (Consumer request)              |
     |--------------------------------------------->|
     |                                              |
     |                                              |
     |                                              |--+ Parse request
     |                                              |  | and see if any
     |                                              |<-+ MS applies
     |                                              |
     |                2. 200 OK (Consumer response) |
     |<---------------------------------------------|
     |                                              |
     |--+ Parse response and                        |
     |  | start session (SIP/COMEDIA/CFW)           |
     |<-+ with first MS reported by MRB             |
     |                                              |
     .                                              .
     .                                              .
 ]]> </artwork> </figure>

                        <t>
                                The rest of this section includes a full dump of the messages
                                associated with the previous sequence diagram, specifically:
                        </t>
                        <t>
                        <list style="numbers">
                                <t>the Consumer request (1.), in a &lt;mediaResourceRequest&gt; (HTTP POST, Content-Type 'application/mrb-consumer+xml');</t>
                                <t>the Consumer response (2.), in a &lt;mediaResourceResponse&gt; (HTTP 200 OK, Content-Type 'application/mrb-consumer+xml').</t>
                        </list>
                        </t>

                                <figure> <artwork> <![CDATA[
1. AS -> MRB (HTTP POST, Consumer request)
------------------------------------------
POST /Mrb/Consumer HTTP/1.1
Content-Length: 893
Content-Type: application/mrb-consumer+xml
Host: mrb.example.net:8080
Connection: Keep-Alive
User-Agent: Apache-HttpClient/4.0.1 (java 1.5)

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<mrbconsumer version="1.0" xmlns="urn:ietf:params:xml:ns:mrb-consumer">
    <mediaResourceRequest id="gh11x23v">
        <generalInfo>
            <packages>
                <package>msc-ivr/1.0</package>
                <package>msc-mixer/1.0</package>
            </packages>
        </generalInfo>
        <ivrInfo>
            <ivr-sessions>
                <rtp-codec name="audio/basic">
                    <decoding>100</decoding>
                    <encoding>100</encoding>
                </rtp-codec>
            </ivr-sessions>
            <file-formats>
                <required-format name="audio/x-wav"/>
            </file-formats>
            <file-transfer-modes>
                <file-transfer-mode package="msc-ivr/1.0" name="HTTP"/>
            </file-transfer-modes>
        </ivrInfo>
    </mediaResourceRequest>
</mrbconsumer>


2. AS <- MRB (200 to POST, Consumer response)
---------------------------------------------
HTTP/1.1 200 OK
X-Powered-By: Servlet/2.5
Server: Sun GlassFish Communications Server 1.5
Content-Type: application/mrb-consumer+xml;charset=ISO-8859-1
Content-Length: 1133
Date: Mon, 12 Apr 2011 14:59:26 GMT

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<mrbconsumer version="1.0" xmlns="urn:ietf:params:xml:ns:mrb-consumer" >
    <mediaResourceResponse reason="Resource found" status="200"
                           id="gh11x23v">
        <response-session-info>
            <session-id>5t3Y4IQ84gY1</session-id>
            <seq>9</seq>
            <expires>3600</expires>
            <media-server-address
                              uri="sip:MediaServer@ms.example.com:5080">
                <ivr-sessions>
                    <rtp-codec name="audio/basic">
                        <decoding>60</decoding>
                        <encoding>60</encoding>
                    </rtp-codec>
                </ivr-sessions>
            </media-server-address>
            <media-server-address
                       uri="sip:OtherMediaServer@pool.example.net:5080">
                <ivr-sessions>
                    <rtp-codec name="audio/basic">
                        <decoding>40</decoding>
                        <encoding>40</encoding>
                    </rtp-codec>
                </ivr-sessions>
            </media-server-address>
        </response-session-info>
    </mediaResourceResponse>
</mrbconsumer>
                                        ]]> </artwork> </figure>

                        <t>As the example shows, the request and response are associated by means of the
                        'id' attribute (id=&quot;gh11x23v&quot;). The MRB has picked '9' as the
                        random sequence number that needs to be incremented by
the Application Server for the subsequent request associated with the same
session.</t>
                        <t>
                                The rest of the scenario is omitted for brevity. After having received
                                the 'mediaResourceResponse', the Application Server has the URIs of two Media Servers able to
                                fulfill its media requirements and can start a
control dialog with one or both of them.
                        </t>

                </section>

                <!-- Query Example -->

                <section anchor="sec:ExConsIAMM" title="IAMM Examples">

                <t>
                        Two separate examples are presented for the IAMM case: in fact,
                        IAMM can take advantage of two different approaches with respect to the
                        SIP dialogs to be exploited to carry Consumer messages, i.e., i) a SIP control
                        dialog to create a Control Channel, and ii) a UAC media dialog to attach to a Media Server.
                        To make things clearer for the reader, the same Consumer request as the one
                        presented in the Query mode will be sent, in order to clarify how the
                        behavior of the involved parties may differ.
                </t>

                <section anchor="sec:ExConsIAMMCFW" title="IAMM Example: CFW-Based Approach">

           <t>
                   The following example assumes that the interested
Application Server already knows the SIP URI of an MRB.
           </t>
           <t>
                        <xref target="fig-exiamm"/> shows the first approach, i.e., SIP-based transactions
                        between the Application Server, the MRB, and one Media Server that the MRB chooses from the two that are
                        allocated to fulfill the request. The diagram is more complex than before.
                        This is basically a scenario envisaging the MRB as a B2BUA. The Application Server sends a SIP
                        INVITE (1.) containing both a CFW-related SDP and a Consumer request (multipart body).
                        The MRB sends a provisional response to the Application Server (2.) and starts working on the request.
                        First of all, it makes use of the Consumer request from the Application Server to determine which Media Servers
                        should be exploited. Once the right Media Servers have been chosen (MS1 and MS2 in the example),
                        the MRB sends a new SIP INVITE (3.) to one of the Media Servers (MS1 in the example)
                        by just including the SDP part of the original
request. That Media Server
                        negotiates this INVITE as specified in <xref target="RFC6230"/>
                        (4., 5., 6.), providing the MRB with its own CFW-related SDP. The MRB replies to the
                        original Application Server INVITE preparing a SIP 200 OK with another multipart body (7.): this
                        multipart body includes the Consumer response used by the MRB to determine the right Media Servers
                        and the SDP returned by the Media Server (MS1) in (5.). The Application Server finally acknowledges the 200 OK (8.), and
                        can start a CFW connection towards that Media Server (MS1). Since the MRB provided the Application Server with two
                        Media Server instances to fulfill its requirements, the Application Server can use the URI in the &lt;media-server-address>
                        element in the &lt;mediaResourceResponse> that describes the other Media Server to establish a CFW
                        channel with that Media Server (MS2) as well.
           </t>
           <t>
                        Please note that to ease the reading of the protocol contents a simple '=_Part' is
                        used whenever a boundary for a 'multipart/mixed' payload is provided, instead of
                        the actual boundary that would be inserted in the SIP messages.
           </t>

                                <figure anchor="fig-exiamm" title="Consumer
Example (IAMM/Control Channel): Sequence Diagram"> <artwork> <![CDATA[
 AS                     MRB                        MS1              MS2
 |                       |                           |                |
 | 1. INVITE             |                           |                |
 | (multipart/mixed)     |                           |                |
 |---------------------->|                           |                |
 |       2. 100 (Trying) |                           |                |
 |<----------------------|                           |                |
 |                       |--+ Extract SDP and        |                |
 |                       |  | MRB payloads; handle   |                |
 |                       |<-+ Consumer request to    |                |
 |                       |    pick MSs (MS1 and MS2) |                |
 |                       |                           |                |
 |                       | 3. INVITE                 |                |
 |                       | (only copy SDP from 1.)   |                |
 |                       |-------------------------->|                |
 |                       |           4. 100 (Trying) |                |
 |                       |<--------------------------|                |
 |                       |                           |--+ Negotiate   |
 |                       |                           |  | CFW Control |
 |                       |                           |<-+ Channel     |
 |                       |                 5. 200 OK |                |
 |                       |<--------------------------|                |
 |                       | 6. ACK                    |                |
 |                       |-------------------------->|                |
 |        Prepare new +--|                           |                |
 |       payload with |  |                           |                |
 |    SDP from MS and +->|                           |                |
 |     Consumer reply    |                           |                |
 |                       |                           |                |
 |             7. 200 OK |                           |                |
 |     (multipart/mixed) |                           |                |
 |<----------------------|                           |                |
 | 8. ACK                |                           |                |
 |---------------------->|                           |                |
 |                       |                           |                |
 |--+ Read Cons. reply   |                           |                |
 |  | and use SDP to     |                           |                |
 |<-+ create CFW Chn.    |                           |                |
 |                       |                           |                |
 |                                                   |                |
 |   Create TCP CFW channel towards MS1 (if needed)  |                |
 |-------------------------------------------------->|                |
 |                                                   |                |
 |<<############## TCP CONNECTION #################>>|                |
 |                                                   |                |
 | CFW SYNC                                          |                |
 |++++++++++++++++++++++++++++++++++++++++++++++++++>|                |
 |                                                   |                |
 .                       .                           .                .
 .                       .                           .                .
 |                                                   |                |
 |   Negotiate SIP control dialog with MS2                            |
 |<------------------------------------------------------------------>|
 |   Create TCP CFW channel towards MS2 as well (if needed)           |
 |------------------------------------------------------------------->|
 |                                                                    |
 |<<######################## TCP CONNECTION ########################>>|
 |                                                                    |
 | CFW SYNC                                                           |
 |+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++>|
 |                                                                    |
 |                       |                           |                |
 .                       .                           .                .
 .                       .                           .                .
                                       ]]> </artwork> </figure>

                        <t>
                                The rest of this section includes an almost full trace of the messages
                                associated with the previous sequence diagram. Only the relevant SIP messages
                                are shown (both the INVITEs and the 200 OKs), and only the relevant headers
                                are preserved for brevity (Content-Type and multipart-related information).
                                Specifically:
                        </t>
                        <t>
                        <list style="numbers">
                                <t>the original INVITE (1.) containing both a
CFW-related SDP (Connection-Oriented Media (COMEDIA) information
                                to negotiate a new Control Channel) and a Consumer &lt;mediaResourceRequest&gt;;</t>
                                <t>the INVITE sent by the MRB (acting as a
B2BUA) to the Media Server (3.), containing only the
                                CFW-related SDP from the original INVITE;</t>
                                <t>the 200 OK sent by the Media Server back to the MRB (5.) to complete the CFW-related negotiation (SDP only);</t>
                                <t>the 200 OK sent by the MRB back to the Application Server in response to the original INVITE (7.),
                                containing both the CFW-related information sent by the Media Server and a Consumer
                                &lt;mediaResourceRequest&gt; documenting the MRB's decision to use that Media Server.</t>
                        </list>
                        </t>

                                <figure> <artwork> <![CDATA[
1. AS -> MRB (INVITE multipart/mixed)
-------------------------------------
   [..]
   Content-Type: multipart/mixed;boundary="=_Part"

   =_Part
   Content-Type: application/sdp

   v=0
   o=- 2890844526 2890842807 IN IP4 as.example.com
   s=MediaCtrl
   c=IN IP4 as.example.com
   t=0 0
   m=application 48035 TCP cfw
   a=connection:new
   a=setup:active
   a=cfw-id:vF0zD4xzUAW9
   a=ctrl-package:msc-mixer/1.0
   a=ctrl-package:msc-ivr/1.0

   =_Part
   Content-Type: application/mrb-consumer+xml

   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <mrbconsumer version="1.0"
                xmlns="urn:ietf:params:xml:ns:mrb-consumer">
    <mediaResourceRequest id="pz78hnq1">
        <generalInfo>
            <packages>
                <package>msc-ivr/1.0</package>
                <package>msc-mixer/1.0</package>
            </packages>
        </generalInfo>
        <ivrInfo>
            <ivr-sessions>
                <rtp-codec name="audio/basic">
                    <decoding>100</decoding>
                    <encoding>100</encoding>
                </rtp-codec>
            </ivr-sessions>
            <file-formats>
                <required-format name="audio/x-wav"/>
            </file-formats>
            <file-transfer-modes>
                <file-transfer-mode package="msc-ivr/1.0" name="HTTP"/>
            </file-transfer-modes>
        </ivrInfo>
    </mediaResourceRequest>
   </mrbconsumer>

   =_Part


3. MRB -> MS (INVITE sdp only)
------------------------------
   [..]
   Content-Type: application/sdp

   v=0
   o=- 2890844526 2890842807 IN IP4 as.example.com
   s=MediaCtrl
   c=IN IP4 as.example.com
   t=0 0
   m=application 48035 TCP cfw
   a=connection:new
   a=setup:active
   a=cfw-id:vF0zD4xzUAW9
   a=ctrl-package:msc-mixer/1.0
   a=ctrl-package:msc-ivr/1.0


5. MRB <- MS (200 OK sdp)
-------------------------
   [..]
   Content-Type: application/sdp

   v=0
   o=lminiero 2890844526 2890842808 IN IP4 ms.example.net
   s=MediaCtrl
   c=IN IP4 ms.example.net
   t=0 0
   m=application 7575 TCP cfw
   a=connection:new
   a=setup:passive
   a=cfw-id:vF0zD4xzUAW9
   a=ctrl-package:msc-mixer/1.0
   a=ctrl-package:msc-ivr/1.0
   a=ctrl-package:mrb-publish/1.0
   a=ctrl-package:msc-example-pkg/1.0


7. AS <- MRB (200 OK multipart/mixed)
-------------------------------------
   [..]
   Content-Type: multipart/mixed;boundary="=_Part"

   =_Part
   Content-Type: application/sdp

   v=0
   o=lminiero 2890844526 2890842808 IN IP4 ms.example.net
   s=MediaCtrl
   c=IN IP4 ms.example.net
   t=0 0
   m=application 7575 TCP cfw
   a=connection:new
   a=setup:passive
   a=cfw-id:vF0zD4xzUAW9
   a=ctrl-package:msc-mixer/1.0
   a=ctrl-package:msc-ivr/1.0
   a=ctrl-package:mrb-publish/1.0
   a=ctrl-package:msc-example-pkg/1.0

   =_Part
   Content-Type: application/mrb-consumer+xml

   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <mrbconsumer version="1.0"
                xmlns="urn:ietf:params:xml:ns:mrb-consumer" >
    <mediaResourceResponse reason="Resource found" status="200"
                           id="pz78hnq1">
        <response-session-info>
            <session-id>z1skKYZQ3eFu</session-id>
            <seq>9</seq>
            <expires>3600</expires>
            <media-server-address
                              uri="sip:MediaServer@ms.example.com:5080">
                <connection-id>32pbdxZ8:KQw677BF</connection-id>
                <ivr-sessions>
                    <rtp-codec name="audio/basic">
                        <decoding>60</decoding>
                        <encoding>60</encoding>
                    </rtp-codec>
                </ivr-sessions>
            </media-server-address>
            <media-server-address
                       uri="sip:OtherMediaServer@pool.example.net:5080">
                <ivr-sessions>
                    <rtp-codec name="audio/basic">
                        <decoding>40</decoding>
                        <encoding>40</encoding>
                    </rtp-codec>
                </ivr-sessions>
            </media-server-address>
        </response-session-info>
    </mediaResourceResponse>
   </mrbconsumer>

   =_Part
                                        ]]> </artwork> </figure>

                        <t>
                                As the previous example illustrates, the only
difference in the response that
                                the MRB provides to the Application Server is in the 'connection-id' attribute that
                                is added to the first allocated Media Server instance: this allows the Application Server to
                                understand that the MRB has sent the CFW channel negotiation to that
                                specific Media Server and that the connection-id to be used is the
                                one provided. This will be described in more detail in the following section
                                for the media dialog-based approach.
                        </t>
                        <t>
                                The continuation of the scenario (the Application Server connecting to MS1 to start the Control Channel and
                                the related SYNC message, the Application Server connecting to MS2 as well later on, all the media dialogs
                                being attached to either Media Server) is omitted for brevity.
                        </t>
                </section>

                <!-- IAMM Example CFW -->

                <section anchor="sec:ExConsIAMMCallLeg" title="IAMM Example: Media Dialog-Based Approach">

           <t>
                   The following example assumes that the interested
Application Server already knows the SIP URI of an MRB.
           </t>
           <t>
                        <xref target="fig-exiamm2"/> shows the second approach, i.e., SIP-based transactions
                        between a SIP client, the Application Server, the MRB, and the Media Server that the MRB chooses. The interaction is basically the
                        same as previous examples (e.g., contents of the
multipart body), but considering that a new
                        party is involved in the communication, the diagram is slightly more complex than before.
                        As before, the MRB acts as a B2BUA. A UAC sends a SIP INVITE to a SIP URI handled by the Application Server,
                        since it is interested to its services (1.). The Application Server sends a provisional response (2.) and,
                        since it doesn't have the resources yet, sends to the MRB a new SIP
                        INVITE (3.) containing both the UAC media-related SDP and a Consumer request (multipart body).
                        The MRB sends a provisional response to the Application Server (4.) and starts working on the request.
                        First of all, it makes use of the Consumer request from the Application Server to determine which Media Servers
                        should be chosen. Once the Media Server has been chosen, the MRB sends a new SIP INVITE
                        to one of the Media Servers by including the SDP part of the original request (5.). The Media Server
                        negotiates this INVITE as specified in <xref target="RFC6230"/>
                        (6., 7., 8.) to allocate the needed media resources to handle the new media dialog,
                        eventually providing the MRB with its own media-related SDP. The MRB replies to the
                        original Application Server INVITE preparing a SIP 200 OK with a multipart body (9.): this
                        multipart body includes the Consumer response from the MRB indicating the chosen Media Servers
                        and the SDP returned by the Media Server in (7.). The Application Server finally acknowledges the 200 OK (10.) and
                        ends the scenario by eventually providing the UAC with the SDP it needs to set up
                        the RTP channels with the chosen Media Server: a separate direct SIP control dialog may be initiated
                        by the Application Server to the same Media Server in order to set up a Control Channel to manipulate the media dialog.
                </t>
                <t>
                        As with the IAMM/Control Channel example in the prior section, this example has
                        the MRB selecting Media Server resources across two Media Server instances. 
                        The convention could be that the MRB sent the SIP INVITE to the first Media Server
                        in the list provided to the Application Server in the Consumer response information. For the sake
                        of brevity, considerations related to connecting to the other Media Servers as well are omitted,
                        since they have already been addressed in the previous section.
                </t>
                   <t>
                        Please note that to ease the reading of the protocol contents, a simple '=_Part' is
                        used whenever a boundary for a 'multipart/mixed' payload is provided, instead of
                        the actual boundary that would be inserted in the SIP messages.
           </t>

                                <figure anchor="fig-exiamm2" title="Consumer
Example (IAMM/Media Dialog): Sequence Diagram">
                                        <artwork> <![CDATA[
UAC              AS                     MRB                          MS
 |               |                       |                           |
 | 1. INVITE     |                       |                           |
 | (media SDP)   |                       |                           |
 |-------------->|                       |                           |
 | 2. 100 Trying |                       |                           |
 |<--------------|                       |                           |
 |               | 3. INVITE             |                           |
 |               | (multipart/mixed)     |                           |
 |               |---------------------->|                           |
 |               |       4. 100 (Trying) |                           |
 |               |<----------------------|                           |
 |               |                       |--+ Extract SDP and        |
 |               |                       |  | MRB payloads; handle   |
 |               |                       |<-+ Consumer request to    |
 |               |                       |    pick Media Servers     |
 |               |                       |                           |
 |               |                       | 5. INVITE                 |
 |               |                       | (only copy SDP from 3.)   |
 |               |                       |-------------------------->|
 |               |                       |           6. 100 (Trying) |
 |               |                       |<--------------------------|
 |               |                       |                        +--|
 |               |                       |    Handle media dialog |  |
 |               |                       |        (connection-id) +->|
 |               |                       |                           |
 |               |                       |                 7. 200 OK |
 |               |                       |<--------------------------|
 |               |                       | 8. ACK                    |
 |               |                       |-------------------------->|
 |               |        Prepare new +--|                           |
 |               |       payload with |  |                           |
 |               |    SDP from MS and +->|                           |
 |               |     Consumer reply    |                           |
 |               |                       |                           |
 |               |             9. 200 OK |                           |
 |               |     (multipart/mixed) |                           |
 |               |<----------------------|                           |
 |               | 10. ACK               |                           |
 |               |---------------------->|                           |
 |               |                       |                           |
 |               |--+ Read Cons. reply   |                           |
 |               |  | and send SDP       |                           |
 |               |<-+ back to UAC        |                           |
 |    11. 200 OK |                       |                           |
 |<--------------|                       |                           |
 | 12. ACK       |                       |                           |
 |-------------->|                       |                           |
 |               |                       |                           |
 |<<*************************** RTP *******************************>>|
 |               |                       |                           |
 |               |--+ Negotiate          |                           |
 |               |  | CFW channel        |                           |
 |               |<-+ towards MS         |                           |
 |               |    (if needed)        |                           |
 .               .                       .                           .
 .               .                       .                           .
 |               |                       |                           |
 |               |                                                   |
 |               |    Create TCP CFW channel towards MS (if needed)  |
 |               |-------------------------------------------------->|
 |               |                                                   |
 |               |<<############## TCP CONNECTION #################>>|
 |               |                                                   |
 |               | CFW SYNC                                          |
 |               |++++++++++++++++++++++++++++++++++++++++++++++++++>|
 |               |                                                   |
 .               .                       .                           .
 .               .                       .                           .
                                        ]]> </artwork> </figure>

                        <t>
                                The rest of this section includes a trace of the messages
                                associated with the previous sequence diagram. Only the relevant SIP messages
                                are shown (both the INVITEs and the 200 OKs), and only the relevant headers
                                are preserved for brevity (Content-Type, From/To, and multipart-related information).
                                Specifically:
                        </t>
                        <t>
                        <list style="numbers">
                                <t>the original INVITE (1.) containing the media-related SDP sent by a UAC;</t>
                                <t>the INVITE sent by the AS to the MRB (3.),
containing both the media-related SDP and a
                                Consumer &lt;mediaResourceRequest&gt;;</t>

                                <t>the INVITE sent by the MRB (acting as a
B2BUA) to the Media Server (5.), containing only the
                                media-related SDP from the original INVITE;</t>
                                <t>the 200 OK sent by the Media Server back to the MRB (7.) to complete the media-related negotiation (SDP only);</t>
                                <t>the 200 OK sent by the MRB back to the Application Server in response to the original INVITE (9.),
                                containing both the media-related information sent by the Media Server and a Consumer
                                &lt;mediaResourceRequest&gt; documenting the MRB's decision to use that Media Server;</t>
                                <t>the 200 OK sent by the Application Server back to the UAC to have it set up the RTP channel(s) with
                                the Media Server (11.).</t>
                        </list>
                        </t>

                                <figure> <artwork> <![CDATA[
1. UAC -> AS (INVITE with media SDP)
------------------------------------
   [..]
   From: <sip:lminiero@users.example.com>;tag=1153573888
   To: <sip:mediactrlDemo@as.example.com>
   [..]
   Content-Type: application/sdp

   v=0
   o=lminiero 123456 654321 IN IP4 203.0.113.2
   s=A conversation
   c=IN IP4 203.0.113.2
   t=0 0
   m=audio 7078 RTP/AVP 0 3 8 101
   a=rtpmap:0 PCMU/8000/1
   a=rtpmap:3 GSM/8000/1
   a=rtpmap:8 PCMA/8000/1
   a=rtpmap:101 telephone-event/8000
   a=fmtp:101 0-11
   m=video 9078 RTP/AVP 98
   
   
3. AS -> MRB (INVITE multipart/mixed)
-------------------------------------
   [..]
   From: <sip:ApplicationServer@as.example.com>;tag=fd4fush5
   To: <sip:Mrb@mrb.example.org>
   [..]
   Content-Type: multipart/mixed;boundary="=_Part"

   =_Part
   Content-Type: application/sdp

   v=0
   o=lminiero 123456 654321 IN IP4 203.0.113.2
   s=A conversation
   c=IN IP4 203.0.113.2
   t=0 0
   m=audio 7078 RTP/AVP 0 3 8 101
   a=rtpmap:0 PCMU/8000/1
   a=rtpmap:3 GSM/8000/1
   a=rtpmap:8 PCMA/8000/1
   a=rtpmap:101 telephone-event/8000
   a=fmtp:101 0-11
   m=video 9078 RTP/AVP 98

   =_Part
   Content-Type: application/mrb-consumer+xml

   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <mrbconsumer version="1.0"
                xmlns="urn:ietf:params:xml:ns:mrb-consumer">
    <mediaResourceRequest id="ns56g1x0">
        <generalInfo>
            <packages>
                <package>msc-ivr/1.0</package>
                <package>msc-mixer/1.0</package>
            </packages>
        </generalInfo>
        <ivrInfo>
            <ivr-sessions>
                <rtp-codec name="audio/basic">
                    <decoding>100</decoding>
                    <encoding>100</encoding>
                </rtp-codec>
            </ivr-sessions>
            <file-formats>
                <required-format name="audio/x-wav"/>
            </file-formats>
            <file-transfer-modes>
                <file-transfer-mode package="msc-ivr/1.0" name="HTTP"/>
            </file-transfer-modes>
        </ivrInfo>
    </mediaResourceRequest>
   </mrbconsumer>

   =_Part


5. MRB -> MS (INVITE sdp only)
------------------------------
   [..]
   From: <sip:Mrb@mrb.example.org:5060>;tag=32pbdxZ8
   To: <sip:MediaServer@ms.example.com:5080>
   [..]
   Content-Type: application/sdp

   v=0
   o=lminiero 123456 654321 IN IP4 203.0.113.2
   s=A conversation
   c=IN IP4 203.0.113.2
   t=0 0
   m=audio 7078 RTP/AVP 0 3 8 101
   a=rtpmap:0 PCMU/8000/1
   a=rtpmap:3 GSM/8000/1
   a=rtpmap:8 PCMA/8000/1
   a=rtpmap:101 telephone-event/8000
   a=fmtp:101 0-11
   m=video 9078 RTP/AVP 98


7. MRB <- MS (200 OK sdp)
-------------------------
   [..]
   From: <sip:Mrb@mrb.example.org:5060>;tag=32pbdxZ8
   To: <sip:MediaServer@ms.example.com:5080>;tag=KQw677BF
   [..]
   Content-Type: application/sdp

   v=0
   o=lminiero 123456 654322 IN IP4 203.0.113.1
   s=MediaCtrl
   c=IN IP4 203.0.113.1
   t=0 0
   m=audio 63442 RTP/AVP 0 3 8 101
   a=rtpmap:0 PCMU/8000
   a=rtpmap:3 GSM/8000
   a=rtpmap:8 PCMA/8000
   a=rtpmap:101 telephone-event/8000
   a=fmtp:101 0-15
   a=ptime:20
   a=label:7eda834
   m=video 33468 RTP/AVP 98
   a=rtpmap:98 H263-1998/90000
   a=fmtp:98 CIF=2
   a=label:0132ca2


9. AS <- MRB (200 OK multipart/mixed)
-------------------------------------
   [..]
   From: <sip:ApplicationServer@as.example.com>;tag=fd4fush5
   To: <sip:Mrb@mrb.example.org>;tag=117652221
   [..]
   Content-Type: multipart/mixed;boundary="=_Part"

   =_Part
   Content-Type: application/sdp

   v=0
   o=lminiero 123456 654322 IN IP4 203.0.113.1
   s=MediaCtrl
   c=IN IP4 203.0.113.1
   t=0 0
   m=audio 63442 RTP/AVP 0 3 8 101
   a=rtpmap:0 PCMU/8000
   a=rtpmap:3 GSM/8000
   a=rtpmap:8 PCMA/8000
   a=rtpmap:101 telephone-event/8000
   a=fmtp:101 0-15
   a=ptime:20
   a=label:7eda834
   m=video 33468 RTP/AVP 98
   a=rtpmap:98 H263-1998/90000
   a=fmtp:98 CIF=2
   a=label:0132ca2

   =_Part
   Content-Type: application/mrb-consumer+xml

   <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   <mrbconsumer version="1.0"
                xmlns="urn:ietf:params:xml:ns:mrb-consumer" >
    <mediaResourceResponse reason="Resource found" status="200"
                           id="ns56g1x0">
        <response-session-info>
            <session-id>z1skKYZQ3eFu</session-id>
            <seq>9</seq>
            <expires>3600</expires>
            <media-server-address
                              uri="sip:MediaServer@ms.example.com:5080">
                <connection-id>32pbdxZ8:KQw677BF</connection-id>
                <ivr-sessions>
                    <rtp-codec name="audio/basic">
                        <decoding>60</decoding>
                        <encoding>60</encoding>
                    </rtp-codec>
                </ivr-sessions>
            </media-server-address>
            <media-server-address
                       uri="sip:OtherMediaServer@pool.example.net:5080">
                <ivr-sessions>
                    <rtp-codec name="audio/basic">
                        <decoding>40</decoding>
                        <encoding>40</encoding>
                    </rtp-codec>
                </ivr-sessions>
            </media-server-address>
        </response-session-info>
    </mediaResourceResponse>
   </mrbconsumer>

   =_Part


11. UAC <- AS (200 OK sdp)
--------------------------
   [..]
   From: <sip:lminiero@users.example.com>;tag=1153573888
   To: <sip:mediactrlDemo@as.example.com>;tag=bcd47c32
   [..]
   Content-Type: application/sdp

   v=0
   o=lminiero 123456 654322 IN IP4 203.0.113.1
   s=MediaCtrl
   c=IN IP4 203.0.113.1
   t=0 0
   m=audio 63442 RTP/AVP 0 3 8 101
   a=rtpmap:0 PCMU/8000
   a=rtpmap:3 GSM/8000
   a=rtpmap:8 PCMA/8000
   a=rtpmap:101 telephone-event/8000
   a=fmtp:101 0-15
   a=ptime:20
   a=label:7eda834
   m=video 33468 RTP/AVP 98
   a=rtpmap:98 H263-1998/90000
   a=fmtp:98 CIF=2
   a=label:0132ca2
                                   ]]> </artwork> </figure>

                        <t>
                           As the examples illustrate, as in the IAMM/Control Channel example, the MRB provides
                           the Application Server with a &lt;media-server-address> element in the Consumer
                           response: the 'uri' attribute identifies the specific Media Server to which
                           the MRB has sent the SDP media negotiation, and the 'connection-id'
                           enables the Application Server to identify to the Media Server the dialog between the MRB and
                           Media Server.  This attribute is needed, since according to the framework
                           specification <xref target="RFC6230"/> the connection-id is built out of the From/To tags
                           of the dialog between the MRB and Media Server; since the MRB acts as a B2BUA
                           in this scenario, without that attribute the Application Server does not know the
                           relevant tags, thus preventing the CFW protocol from working as expected.
                        </t>

                        <t>
                        The continuation of the scenario (the Application Server connecting to the Media Server to start the Control
                        Channel, the SYNC message, etc.) is omitted for brevity.
                        </t>
                </section>

                <!-- IAMM Example media dialog -->

                </section>

                <!-- IAMM Example -->

        </section>

        <!-- Consumer Example -->

</section>

<!-- Examples -->

<section anchor="sec:publisher_xml" title="Media Service Resource Publisher Interface XML Schema">

        <t>This section gives the XML Schema Definition
<xref target="W3C.REC-xmlschema-1-20041028"/> <xref
target="W3C.REC-xmlschema-2-20041028"/> of the "application/mrb-publish+xml" 
format.</t>

<figure> <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema targetNamespace="urn:ietf:params:xml:ns:mrb-publish"
 elementFormDefault="qualified" blockDefault="#all"
 xmlns="urn:ietf:params:xml:ns:mrb-publish"
 xmlns:fw="urn:ietf:params:xml:ns:control:framework-attributes"
 xmlns:ca="urn:ietf:params:xml:ns:pidf:geopriv10:civicAddr"
 xmlns:xsd="http://www.w3.org/2001/XMLSchema">

 <xsd:annotation>
  <xsd:documentation>
   IETF MediaCtrl MRB 1.0

   This is the schema of the IETF MediaCtrl MRB package.

   The schema namespace is urn:ietf:params:xml:ns:mrb-publish

  </xsd:documentation>
 </xsd:annotation>


 <!--
  #############################################################

  SCHEMA IMPORTS

  #############################################################
 -->

 <xsd:import namespace="http://www.w3.org/XML/1998/namespace"
  schemaLocation="http://www.w3.org/2001/xml.xsd">
  <xsd:annotation>
   <xsd:documentation>
    This import brings in the XML attributes for
    xml:base, xml:lang, etc.
   </xsd:documentation>
  </xsd:annotation>
 </xsd:import>

 <xsd:import 
  namespace="urn:ietf:params:xml:ns:control:framework-attributes" 
  schemaLocation="framework.xsd">
  <xsd:annotation>
   <xsd:documentation>
    This import brings in the framework attributes for
    conferenceid and connectionid.
   </xsd:documentation>
  </xsd:annotation>
 </xsd:import>

 <xsd:import 
  namespace="urn:ietf:params:xml:ns:pidf:geopriv10:civicAddr" 
  schemaLocation="civicAddress.xsd">
  <xsd:annotation>
   <xsd:documentation>
    This import brings in the civicAddress specification
    from RFC 5139.
   </xsd:documentation>
  </xsd:annotation>
 </xsd:import>

<!--
  #####################################################

  Extensible core type

  #####################################################
 -->


 <xsd:complexType name="Tcore">
  <xsd:annotation>
   <xsd:documentation>
    This type is extended by other (non-mixed) component types to
    allow attributes from other namespaces.
   </xsd:documentation>
  </xsd:annotation>
  <xsd:sequence/>
  <xsd:anyAttribute namespace="##other" processContents="lax" />
 </xsd:complexType>


<!--
  #####################################################

  TOP-LEVEL ELEMENT: mrbpublish

  #####################################################
 -->

<xsd:complexType name="mrbpublishType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:choice>
      <xsd:element ref="mrbrequest" />
      <xsd:element ref="mrbresponse" />
      <xsd:element ref="mrbnotification" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
     </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="version" type="version.datatype"
      use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="mrbpublish" type="mrbpublishType" />

<!--
  #####################################################

  mrbrequest TYPE

  #####################################################
 -->

<!--  mrbrequest -->

 <xsd:complexType name="mrbrequestType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="subscription" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="mrbrequest" type="mrbrequestType" />

<!--  subscription -->

<xsd:complexType name="subscriptionType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element name="expires" type="xsd:nonNegativeInteger"
      minOccurs="0" maxOccurs="1" />
     <xsd:element name="minfrequency" type="xsd:nonNegativeInteger"
      minOccurs="0" maxOccurs="1" />
     <xsd:element name="maxfrequency" type="xsd:nonNegativeInteger"
      minOccurs="0" maxOccurs="1" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="id" type="id.datatype" use="required" />
    <xsd:attribute name="seqnumber" type="xsd:nonNegativeInteger"
      use="required" />
    <xsd:attribute name="action" type="action.datatype"
      use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="subscription" type="subscriptionType" />


<!--
  #####################################################

  mrbresponse TYPE

  #####################################################
 -->

<!--  mrbresponse -->

 <xsd:complexType name="mrbresponseType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="subscription" minOccurs="0" maxOccurs="1" />
     <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="status" type="status.datatype"
     use="required" />
    <xsd:attribute name="reason" type="xsd:string" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>


 <xsd:element name="mrbresponse" type="mrbresponseType" />

<!--
  #####################################################

  mrbnotification TYPE

  #####################################################
 -->

<!--  mrbnotification -->

<xsd:complexType name="mrbnotificationType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element name="media-server-id" 
        type="subscriptionid.datatype"/>
     <xsd:element ref="supported-packages" minOccurs="0" />
     <xsd:element ref="active-rtp-sessions" minOccurs="0" />
     <xsd:element ref="active-mixer-sessions" minOccurs="0" />
     <xsd:element ref="non-active-rtp-sessions" minOccurs="0" />
     <xsd:element ref="non-active-mixer-sessions" minOccurs="0" />
     <xsd:element ref="media-server-status" minOccurs="0" />
     <xsd:element ref="supported-codecs" minOccurs="0" />
     <xsd:element ref="application-data" minOccurs="0"
      maxOccurs="unbounded" />
     <xsd:element ref="file-formats" minOccurs="0" />
     <xsd:element ref="max-prepared-duration" minOccurs="0" />
     <xsd:element ref="dtmf-support" minOccurs="0" />
     <xsd:element ref="mixing-modes" minOccurs="0" />
     <xsd:element ref="supported-tones" minOccurs="0" />
     <xsd:element ref="file-transfer-modes" minOccurs="0" />
     <xsd:element ref="asr-tts-support" minOccurs="0" />
     <xsd:element ref="vxml-support" minOccurs="0" />
     <xsd:element ref="media-server-location" minOccurs="0" />
     <xsd:element ref="label" minOccurs="0" />
     <xsd:element ref="media-server-address" minOccurs="0" />
     <xsd:element ref="encryption" minOccurs="0" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
     <xsd:attribute name="id" type="subscriptionid.datatype"
      use="required" />
     <xsd:attribute name="seqnumber" type="xsd:nonNegativeInteger"
      use="required" />
     <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="mrbnotification" type="mrbnotificationType" />


<!--  supported-packages -->

 <xsd:complexType name="supported-packagesType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="package" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="supported-packages" type="supported-packagesType"/>


 <xsd:complexType name="packageType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="package" type="packageType" />


<!--  active-rtp-sessions -->

 <xsd:complexType name="active-rtp-sessionsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="rtp-codec" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="active-rtp-sessions" type="active-rtp-sessionsType"/>


 <xsd:complexType name="rtp-codecType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element name="decoding" type="xsd:nonNegativeInteger" />
      <xsd:element name="encoding" type="xsd:nonNegativeInteger" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="rtp-codec" type="rtp-codecType" />


<!--  active-mixer-sessions -->

<xsd:complexType name="active-mixer-sessionsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="active-mix" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="active-mixer-sessions"
  type="active-mixer-sessionsType" />


<xsd:complexType name="active-mixType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="rtp-codec" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attributeGroup ref="fw:framework-attributes" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="active-mix" type="active-mixType" />


<!--  non-active-rtp-sessions -->

<xsd:complexType name="non-active-rtp-sessionsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="rtp-codec" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="non-active-rtp-sessions"
  type="non-active-rtp-sessionsType" />

<!--  non-active-mixer-sessions -->

<xsd:complexType name="non-active-mixer-sessionsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="non-active-mix" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="non-active-mixer-sessions"
  type="non-active-mixer-sessionsType" />

 <xsd:complexType name="non-active-mixType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="rtp-codec" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="available" type="xsd:nonNegativeInteger"
      use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="non-active-mix" type="non-active-mixType" />

<!--  media-server-status -->

 <xsd:element name="media-server-status" type="msstatus.datatype" />

<!--  supported-codecs -->

<xsd:complexType name="supported-codecsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="supported-codec"
         minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
         maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="supported-codecs" type="supported-codecsType" />

 <xsd:complexType name="supported-codecType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="supported-codec-package"
         minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="supported-codec" type="supported-codecType" />

 <xsd:complexType name="supported-codec-packageType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element name="supported-action" type="actions.datatype"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="supported-codec-package"
  type="supported-codec-packageType" />


<!--  application-data -->

<xsd:element name="application-data" type="appdata.datatype" />

<!--  file-formats -->

<xsd:complexType name="file-formatsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="supported-format"
         minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
         maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="file-formats" type="file-formatsType" />

 <xsd:complexType name="supported-formatType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="supported-file-package"
         minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="supported-format" type="supported-formatType" />

 <xsd:element name="supported-file-package"
  type="xsd:string" />

<!--  max-prepared-duration -->

<xsd:complexType name="max-prepared-durationType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="max-time" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="max-prepared-duration"
  type="max-prepared-durationType" />


 <xsd:complexType name="max-timeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element name="max-time-package" type="xsd:string" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="max-time-seconds" type="xsd:nonNegativeInteger"
     use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="max-time" type="max-timeType" />

<!--  dtmf-support -->

<xsd:complexType name="dtmf-supportType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="detect" />
       <xsd:element ref="generate" />
       <xsd:element ref="passthrough" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="dtmf-support" type="dtmf-supportType" />

 <xsd:complexType name="detectType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="dtmf-type"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="detect" type="detectType" />

 <xsd:complexType name="generateType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="dtmf-type"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="generate" type="generateType" />

 <xsd:complexType name="passthroughType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="dtmf-type"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="passthrough" type="passthroughType" />


 <xsd:complexType name="dtmf-typeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="dtmf.datatype" use="required" />
    <xsd:attribute name="package" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="dtmf-type" type="dtmf-typeType" />


<!--  mixing-modes -->

<xsd:complexType name="mixing-modesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
      <xsd:element ref="audio-mixing-modes"
        minOccurs="0" maxOccurs="1" />
      <xsd:element ref="video-mixing-modes"
        minOccurs="0" maxOccurs="1" />
      <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="mixing-modes" type="mixing-modesType" />

<xsd:complexType name="audio-mixing-modesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="audio-mixing-mode"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="audio-mixing-modes" type="audio-mixing-modesType" />

<xsd:complexType name="audio-mixing-modeType" mixed="true">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
     maxOccurs="unbounded" processContents="lax" />
 </xsd:sequence>
 <xsd:attribute name="package" type="xsd:string" use="required" />
 <xsd:anyAttribute namespace="##other" processContents="lax" />
</xsd:complexType>

<xsd:element name="audio-mixing-mode" type="audio-mixing-modeType" />

<xsd:complexType name="video-mixing-modesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="video-mixing-mode"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:attribute name="vas" type="boolean.datatype"
     default="false" />
   <xsd:attribute name="activespeakermix" type="boolean.datatype"
     default="false" />
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="video-mixing-modes" type="video-mixing-modesType" />

<xsd:complexType name="video-mixing-modeType" mixed="true">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
     maxOccurs="unbounded" processContents="lax" />
 </xsd:sequence>
 <xsd:attribute name="package" type="xsd:string" use="required" />
 <xsd:anyAttribute namespace="##other" processContents="lax" />
</xsd:complexType>

<xsd:element name="video-mixing-mode" type="video-mixing-modeType" />


<!--  supported-tones -->

<xsd:complexType name="supported-tonesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
      <xsd:element ref="supported-country-codes"
        minOccurs="0" maxOccurs="1" />
      <xsd:element ref="supported-h248-codes"
        minOccurs="0" maxOccurs="1" />
      <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="supported-tones" type="supported-tonesType" />

<xsd:complexType name="supported-country-codesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="country-code"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="supported-country-codes" 
  type="supported-country-codesType" />

<xsd:complexType name="country-codeType" mixed="true">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
     maxOccurs="unbounded" processContents="lax" />
 </xsd:sequence>
 <xsd:attribute name="package" type="xsd:string" use="required" />
 <xsd:anyAttribute namespace="##other" processContents="lax" />
</xsd:complexType>

<xsd:element name="country-code" type="country-codeType" />

<xsd:complexType name="supported-h248-codesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="h248-code"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="supported-h248-codes" 
  type="supported-h248-codesType" />

<xsd:complexType name="h248-codeType" mixed="true">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
     maxOccurs="unbounded" processContents="lax" />
 </xsd:sequence>
 <xsd:attribute name="package" type="xsd:string" use="required" />
 <xsd:anyAttribute namespace="##other" processContents="lax" />
</xsd:complexType>

<xsd:element name="h248-code" type="h248-codeType" />


<!--  file-transfer-modes -->

 <xsd:complexType name="file-transfer-modesType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="file-transfer-mode"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="file-transfer-modes"
              type="file-transfer-modesType" />

 <xsd:complexType name="file-transfer-modeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="transfermode.datatype"
     use="required" />
    <xsd:attribute name="package" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>
 <xsd:element name="file-transfer-mode" type="file-transfer-modeType" />


<!--  asr-tts-support -->

<xsd:complexType name="asr-tts-supportType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
      <xsd:element ref="asr-support"
        minOccurs="0" maxOccurs="1" />
      <xsd:element ref="tts-support"
        minOccurs="0" maxOccurs="1" />
      <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="asr-tts-support" type="asr-tts-supportType" />

<xsd:complexType name="asr-supportType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="language"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="asr-support" type="asr-supportType" />

<xsd:complexType name="tts-supportType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="language"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="tts-support" type="tts-supportType" />

<xsd:complexType name="languageType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:attribute ref="xml:lang" />
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="language" type="languageType" />


<!--  media-server-location -->

<xsd:complexType name="media-server-locationType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element name="civicAddress" type="ca:civicAddress"
                        minOccurs="1" maxOccurs="1" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="media-server-location" 
  type="media-server-locationType" />


<!--  vxml-support -->

 <xsd:complexType name="vxml-supportType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="vxml-mode"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="vxml-support" type="vxml-supportType" />

 <xsd:complexType name="vxml-modeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="package" type="xsd:string" use="required" />
    <xsd:attribute name="support" type="vxml.datatype" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="vxml-mode" type="vxml-modeType" />


<!--  label -->

 <xsd:element name="label" type="label.datatype" />


<!-- media-server-address -->

 <xsd:element name="media-server-address" type="xsd:anyURI" />

<!--  encryption -->

 <xsd:complexType name="encryptionType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="encryption" type="encryptionType" />

 
<!--
  ####################################################

  DATATYPES

  ####################################################
 -->


 <xsd:simpleType name="version.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="1.0" />
  </xsd:restriction>
 </xsd:simpleType>

<xsd:simpleType name="id.datatype">
  <xsd:restriction base="xsd:NMTOKEN" />
 </xsd:simpleType>

 <xsd:simpleType name="status.datatype">
  <xsd:restriction base="xsd:positiveInteger">
   <xsd:pattern value="[0-9][0-9][0-9]" />
  </xsd:restriction>
 </xsd:simpleType>

 <xsd:simpleType name="msstatus.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="active" />
   <xsd:enumeration value="deactivated" />
   <xsd:enumeration value="unavailable" />
  </xsd:restriction>
 </xsd:simpleType>

 <xsd:simpleType name="action.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="create" />
   <xsd:enumeration value="update" />
   <xsd:enumeration value="remove" />
  </xsd:restriction>
 </xsd:simpleType>

 <xsd:simpleType name="actions.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="encoding" />
   <xsd:enumeration value="decoding" />
   <xsd:enumeration value="passthrough" />
  </xsd:restriction>
 </xsd:simpleType>

 <xsd:simpleType name="appdata.datatype">
  <xsd:restriction base="xsd:string" />
 </xsd:simpleType>

 <xsd:simpleType name="dtmf.datatype">
  <xsd:restriction base="xsd:NMTOKEN"/>
 </xsd:simpleType>

 <xsd:simpleType name="transfermode.datatype">
  <xsd:restriction base="xsd:NMTOKEN" />
 </xsd:simpleType>

 <xsd:simpleType name="boolean.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="true" />
   <xsd:enumeration value="false" />
  </xsd:restriction>
 </xsd:simpleType>

 <xsd:simpleType name="vxml.datatype">
  <xsd:restriction base="xsd:NMTOKEN"/>
 </xsd:simpleType>

 <xsd:simpleType name="label.datatype">
  <xsd:restriction base="xsd:NMTOKEN" />
 </xsd:simpleType>

 <xsd:simpleType name="subscriptionid.datatype">
  <xsd:restriction base="xsd:NMTOKEN" />
 </xsd:simpleType>

</xsd:schema>
 ]]></artwork> </figure>

</section>

<!-- publisher_xml -->


<section anchor="sec:consumer_xml" title="Media Service Resource Consumer Interface XML Schema">

        <t>This section gives the XML Schema Definition
<xref target="W3C.REC-xmlschema-1-20041028"/> <xref
target="W3C.REC-xmlschema-2-20041028"/> of the "application/mrb-consumer+xml"
format.</t>

<figure> <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema targetNamespace="urn:ietf:params:xml:ns:mrb-consumer"
 elementFormDefault="qualified" blockDefault="#all"
 xmlns="urn:ietf:params:xml:ns:mrb-consumer"
 xmlns:ca="urn:ietf:params:xml:ns:pidf:geopriv10:civicAddr"
 xmlns:xsd="http://www.w3.org/2001/XMLSchema">

 <xsd:annotation>
  <xsd:documentation>
   IETF MediaCtrl MRB 1.0 

   This is the schema of the IETF MediaCtrl MRB Consumer interface.

   The schema namespace is urn:ietf:params:xml:ns:mrb-consumer

  </xsd:documentation>
 </xsd:annotation>


 <!--
  #############################################################

  SCHEMA IMPORTS

  #############################################################
 -->

 <xsd:import namespace="http://www.w3.org/XML/1998/namespace"
  schemaLocation="http://www.w3.org/2001/xml.xsd">
  <xsd:annotation>
   <xsd:documentation>
    This import brings in the XML attributes for
    xml:base, xml:lang, etc.
   </xsd:documentation>
  </xsd:annotation>
 </xsd:import>

 <xsd:import 
  namespace="urn:ietf:params:xml:ns:pidf:geopriv10:civicAddr" 
  schemaLocation="civicAddress.xsd">
  <xsd:annotation>
   <xsd:documentation>
    This import brings in the civicAddress specification
    from RFC 5139.
   </xsd:documentation>
  </xsd:annotation>
 </xsd:import>

<!--
  #####################################################

  Extensible core type

  #####################################################
 -->


 <xsd:complexType name="Tcore">
  <xsd:annotation>
   <xsd:documentation>
    This type is extended by other (non-mixed) component types to
    allow attributes from other namespaces.
   </xsd:documentation>
  </xsd:annotation>
  <xsd:sequence/>
  <xsd:anyAttribute namespace="##other" processContents="lax" />
 </xsd:complexType>


<!--
  #####################################################

  TOP-LEVEL ELEMENT: mrbconsumer

  #####################################################
 -->

<xsd:complexType name="mrbconsumerType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:choice>
      <xsd:element ref="mediaResourceRequest" />
      <xsd:element ref="mediaResourceResponse" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
     </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="version" type="version.datatype"
      use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

 <xsd:element name="mrbconsumer" type="mrbconsumerType" />

<!--
  #####################################################

  mediaResourceRequest TYPE

  #####################################################
 -->

<!--  mediaResourceRequest -->

 <xsd:complexType name="mediaResourceRequestType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="generalInfo" minOccurs="0" />
      <xsd:element ref="ivrInfo" minOccurs="0" />
      <xsd:element ref="mixerInfo" minOccurs="0" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:string"
      use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="mediaResourceRequest" 
         type="mediaResourceRequestType" />

<!--
  #####################################################

  generalInfo TYPE

  #####################################################
-->

<!--  generalInfo -->

<xsd:complexType name="generalInfoType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="session-info" minOccurs="0" />
      <xsd:element ref="packages" minOccurs="0" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="generalInfo" type="generalInfoType" />


<!--  session-info -->

<xsd:complexType name="session-infoType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element name="session-id" type="id.datatype"/>
       <xsd:element name="seq" type="xsd:nonNegativeInteger"/>
       <xsd:element name="action" type="action.datatype"/>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="session-info" type="session-infoType" />

<!--  packages -->

<xsd:complexType name="packagesType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element name="package" type="xsd:string" minOccurs="0"
        maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="packages" type="packagesType"/>


<!--
  #####################################################

  ivrInfo TYPE

  #####################################################
-->

<!--  ivrInfo -->

<xsd:complexType name="ivrInfoType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="ivr-sessions" minOccurs="0" />
      <xsd:element ref="file-formats" minOccurs="0" />
      <xsd:element ref="dtmf-type" minOccurs="0" />
      <xsd:element ref="tones" minOccurs="0" />
      <xsd:element ref="asr-tts" minOccurs="0" />
      <xsd:element ref="vxml" minOccurs="0" />
      <xsd:element ref="location" minOccurs="0" />
      <xsd:element ref="encryption" minOccurs="0" />
      <xsd:element ref="application-data" minOccurs="0" />
      <xsd:element ref="max-prepared-duration" minOccurs="0" />
      <xsd:element ref="file-transfer-modes" minOccurs="0" />
      <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence> 
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="ivrInfo" type="ivrInfoType" />


<!--
  #####################################################

  mixerInfo TYPE

  #####################################################
--> 
 
<!--  mixerInfo -->

<xsd:complexType name="mixerInfoType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="mixers" minOccurs="0"/>
      <xsd:element ref="file-formats" minOccurs="0"/>
      <xsd:element ref="dtmf-type" minOccurs="0"/>
      <xsd:element ref="tones" minOccurs="0"/>
      <xsd:element ref="mixing-modes" minOccurs="0"/>
      <xsd:element ref="application-data" minOccurs="0"/>
      <xsd:element ref="location" minOccurs="0"/>
      <xsd:element ref="encryption" minOccurs="0"/>
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence> 
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="mixerInfo" type="mixerInfoType" />


<!--
  #####################################################

  mediaResourceResponse TYPE

  #####################################################
 -->

<!--  mediaResourceResponse -->

 <xsd:complexType name="mediaResourceResponseType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="response-session-info" minOccurs="0" />
       <xsd:any namespace="##other" minOccurs="0"
          maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="id" type="xsd:string"
     use="required" />
    <xsd:attribute name="status" type="status.datatype"
     use="required" />
    <xsd:attribute name="reason" type="xsd:string" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>
 

 <xsd:element name="mediaResourceResponse" 
         type="mediaResourceResponseType" />
 

<!--
  ####################################################

  ELEMENTS

  ####################################################
 -->

<!--  response-session-info -->

<xsd:complexType name="response-session-infoType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element name="session-id" type="id.datatype"/>
       <xsd:element name="seq" type="xsd:nonNegativeInteger"/>
       <xsd:element name="expires" type="xsd:nonNegativeInteger"/>
       <xsd:element ref="media-server-address" 
          minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
         maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="response-session-info" 
   type="response-session-infoType" />

<!-- media-server-address -->

<xsd:complexType name="media-server-addressTYPE">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element name="connection-id" type="xsd:string"
         minOccurs="0" maxOccurs="unbounded" />
     <xsd:element ref="ivr-sessions" minOccurs="0"/>
     <xsd:element ref="mixers" minOccurs="0"/>
     <xsd:any namespace="##other" minOccurs="0"
         maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="uri" type="xsd:anyURI" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="media-server-address" 
    type="media-server-addressTYPE" />

<!--  ivr-sessions -->

<xsd:complexType name="ivr-sessionsType">
 <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="rtp-codec" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="ivr-sessions" type="ivr-sessionsType" />

<xsd:complexType name="rtp-codecType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element name="decoding" type="xsd:nonNegativeInteger" />
      <xsd:element name="encoding" type="xsd:nonNegativeInteger" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="rtp-codec" type="rtp-codecType" />


<!-- file-formats -->

<xsd:complexType name="file-formatsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="required-format"
         minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
         maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="file-formats" type="file-formatsType" />

<xsd:complexType name="required-formatType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="required-file-package"
         minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="required-format" type="required-formatType" />

<xsd:complexType name="required-file-packageType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element name="required-file-package-name" type="xsd:string"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="required-file-package"
  type="required-file-packageType" />

<!--  dtmf-type -->

<xsd:complexType name="dtmfType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="detect" />
       <xsd:element ref="generate" />
       <xsd:element ref="passthrough" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="dtmf" type="dtmfType" />

<xsd:complexType name="detectType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="dtmf-type"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="detect" type="detectType" />

<xsd:complexType name="generateType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="dtmf-type"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="generate" type="generateType" />

<xsd:complexType name="passthroughType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="dtmf-type"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="passthrough" type="passthroughType" />

<xsd:complexType name="dtmf-typeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="dtmf.datatype" use="required" />
    <xsd:attribute name="package" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="dtmf-type" type="dtmf-typeType" />

<!--  tones -->

<xsd:complexType name="required-tonesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
      <xsd:element ref="country-codes"
        minOccurs="0" maxOccurs="1" />
      <xsd:element ref="h248-codes"
        minOccurs="0" maxOccurs="1" />
      <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="tones" type="required-tonesType" />

<xsd:complexType name="required-country-codesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="country-code"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="country-codes" 
   type="required-country-codesType" />

<xsd:complexType name="country-codeType" mixed="true">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
     maxOccurs="unbounded" processContents="lax" />
 </xsd:sequence>
 <xsd:attribute name="package" type="xsd:string" use="required" />
 <xsd:anyAttribute namespace="##other" processContents="lax" />
</xsd:complexType>

<xsd:element name="country-code" type="country-codeType" />

<xsd:complexType name="required-h248-codesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="h248-code"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="h248-codes" 
   type="required-h248-codesType" />

<xsd:complexType name="h248-codeType" mixed="true">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
     maxOccurs="unbounded" processContents="lax" />
 </xsd:sequence>
 <xsd:attribute name="package" type="xsd:string" use="required" />
 <xsd:anyAttribute namespace="##other" processContents="lax" />
</xsd:complexType>

<xsd:element name="h248-code" type="h248-codeType" />

<!--  asr-tts -->

<xsd:complexType name="asr-ttsType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
      <xsd:element ref="asr-support"
        minOccurs="0" maxOccurs="1" />
      <xsd:element ref="tts-support"
        minOccurs="0" maxOccurs="1" />
      <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="asr-tts" type="asr-ttsType" />

<xsd:complexType name="asr-supportType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="language"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="asr-support" type="asr-supportType" />

<xsd:complexType name="tts-supportType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="language"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="tts-support" type="tts-supportType" />

<xsd:complexType name="languageType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:attribute ref="xml:lang" />
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="language" type="languageType" /> 


<!--  vxml -->

<xsd:complexType name="vxmlType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="vxml-mode"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="vxml" type="vxmlType" />

<xsd:complexType name="vxml-modeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="package" type="xsd:string" use="required" />
    <xsd:attribute name="require" type="vxml.datatype" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="vxml-mode" type="vxml-modeType" />

<!--  location -->

<xsd:complexType name="locationType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:element ref="ca:civicAddress"
                        minOccurs="1" maxOccurs="1" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

<xsd:element name="location" type="locationType" /> 


<!--  encryption -->

 <xsd:complexType name="encryptionType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="encryption" type="encryptionType" />

<!--  application-data -->

<xsd:element name="application-data" type="appdata.datatype" />

<!--  max-prepared-duration -->

<xsd:complexType name="max-prepared-durationType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="max-time" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="max-prepared-duration"
  type="max-prepared-durationType" />


<xsd:complexType name="max-timeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element name="max-time-package" type="xsd:string" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="max-time-seconds" type="xsd:nonNegativeInteger"
     use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="max-time" type="max-timeType" />


<!--  file-transfer-modes -->

<xsd:complexType name="file-transfer-modesType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="file-transfer-mode"
        minOccurs="0" maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="file-transfer-modes"
             type="file-transfer-modesType" />

<xsd:complexType name="file-transfer-modeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="name" type="transfermode.datatype"
     use="required" />
    <xsd:attribute name="package" type="xsd:string" use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="file-transfer-mode" type="file-transfer-modeType" />

<!--  mixers -->

<xsd:complexType name="mixerssessionsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="mix" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="mixers" type="mixerssessionsType" />

<xsd:complexType name="mixType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
      <xsd:element ref="rtp-codec" minOccurs="0"
        maxOccurs="unbounded" />
       <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="users" type="xsd:nonNegativeInteger" 
     use="required" />
    <xsd:anyAttribute namespace="##other" processContents="lax" />
   </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="mix" type="mixType" />


<!--  mixing-modes -->

<xsd:complexType name="mixing-modesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
      <xsd:element ref="audio-mixing-modes"
        minOccurs="0" maxOccurs="1" />
      <xsd:element ref="video-mixing-modes"
        minOccurs="0" maxOccurs="1" />
      <xsd:any namespace="##other" minOccurs="0"
        maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="mixing-modes" type="mixing-modesType" />

<xsd:complexType name="audio-mixing-modesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="audio-mixing-mode"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="audio-mixing-modes" type="audio-mixing-modesType" />

<xsd:complexType name="audio-mixing-modeType" mixed="true">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
     maxOccurs="unbounded" processContents="lax" />
 </xsd:sequence>
 <xsd:attribute name="package" type="xsd:string" use="required" />
 <xsd:anyAttribute namespace="##other" processContents="lax" />
</xsd:complexType>

<xsd:element name="audio-mixing-mode" type="audio-mixing-modeType" />

<xsd:complexType name="video-mixing-modesType">
 <xsd:complexContent>
  <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="video-mixing-mode"
        minOccurs="0" maxOccurs="unbounded" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
   </xsd:sequence>
   <xsd:attribute name="vas" type="boolean.datatype"
     default="false" />
   <xsd:attribute name="activespeakermix" type="boolean.datatype"
     default="false" />
   <xsd:anyAttribute namespace="##other" processContents="lax" />
  </xsd:extension>
 </xsd:complexContent>
</xsd:complexType>

<xsd:element name="video-mixing-modes" type="video-mixing-modesType" />

<xsd:complexType name="video-mixing-modeType" mixed="true">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
     maxOccurs="unbounded" processContents="lax" />
 </xsd:sequence>
 <xsd:attribute name="package" type="xsd:string" use="required" />
 <xsd:anyAttribute namespace="##other" processContents="lax" />
</xsd:complexType>

<xsd:element name="video-mixing-mode" type="video-mixing-modeType" /> 


<!--
  ####################################################

  DATATYPES

  ####################################################
 -->

<xsd:simpleType name="version.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="1.0" />
  </xsd:restriction>
</xsd:simpleType>

<xsd:simpleType name="id.datatype">
  <xsd:restriction base="xsd:NMTOKEN" />
</xsd:simpleType>

<xsd:simpleType name="status.datatype">
  <xsd:restriction base="xsd:positiveInteger">
   <xsd:pattern value="[0-9][0-9][0-9]" />
  </xsd:restriction>
</xsd:simpleType>

<xsd:simpleType name="transfermode.datatype">
  <xsd:restriction base="xsd:NMTOKEN"/>
</xsd:simpleType>

<xsd:simpleType name="action.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="remove" />
   <xsd:enumeration value="update" />
  </xsd:restriction>
</xsd:simpleType> 

<xsd:simpleType name="dtmf.datatype">
  <xsd:restriction base="xsd:NMTOKEN"/>
</xsd:simpleType>

<xsd:simpleType name="boolean.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="true" />
   <xsd:enumeration value="false" />
  </xsd:restriction>
</xsd:simpleType>

<xsd:simpleType name="vxml.datatype">
  <xsd:restriction base="xsd:NMTOKEN"/>
</xsd:simpleType>

<xsd:simpleType name="appdata.datatype">
  <xsd:restriction base="xsd:string" />
 </xsd:simpleType>
 
</xsd:schema>

        ]]></artwork> </figure>

</section>

<!-- XML Schema -->


<section anchor="sec:security" title="Security Considerations">
                        
        <t>The MRB network entity has two primary interfaces -- Publish and
Consumer -- that carry sensitive information and must therefore be
appropriately protected and secured.</t>

        <t>The Publish interface, as defined in and described in <xref target="sec:MS_Pub"/>,
        uses the Media Control Channel Framework <xref target="RFC6230"/>
        as a mechanism to connect an MRB to a Media Server. It is very important that the 
        communication between the MRB and the Media Server is secured: a malicious entity
        may change or even delete subscriptions to a Media Server, thus affecting the view the MRB
        has of the resources actually available on a Media Server, leading it to incorrect selection when
        media resources are being requested by an Application Server. A
malicious entity may even manipulate available
        resources on a Media Server, for example, to make the MRB think no resources
        are available at all. Considering that the Publish interface is a CFW Control Package, the same security
        considerations included in the Media Control Channel Framework specification apply
        here to protect interactions between an MRB and a Media Server.</t>

        <t>The Publish interface also allows a Media Server, as explained in
        <xref target="sec:media-server-location"/>, to provide more or less accurate information about
        its geographic location, should Application Servers be interested in such details
        when looking for services at an MRB.  While the usage of this information is
        entirely optional and the level of detail to be provided is implementation specific, it is
        important to draw attention to the potential security issues that the disclosure
        of such addresses may introduce.  As such, it is important to make sure MRB implementations 
        don't disclose this information as is to interested Application Servers but only
        exploit those addresses as part of computation algorithms to pick the most adequate resources
        Application Servers may be looking for.
        </t>
        
        <t>The Consumer interface, as defined in and described in <xref target="sec:Res_Cons"/>,
        conceives transactions based on a session ID. These transactions may be transported either
        by means of HTTP messages or SIP dialogs. This means that malicious users could
        be able to disrupt or manipulate an MRB session should they have access to the above-mentioned
        session ID or replicate it somehow: for instance, a malicious entity could modify an
        existing session between an Application Server and the MRB, e.g., requesting less resources than originally
        requested to cause media dialogs to be rejected by the Application Server, or requesting many more resources
        instead to try and lock as many of (if not all) the resources an MRB can provide, thus making
        them unavailable to other legitimate Application Servers in subsequent requests. In order to prevent this,
        it is strongly advised that MRB implementations generate session
identifiers that are very hard to replicate,
        in order to minimize the chances that malicious users could gain access
to valid identifiers by just guessing or by means of
        brute-force attacks. It is very important, of course, to also secure
the way that these identifiers are transported
        by the involved parties, in both requests and responses, in order to prevent network attackers from
        intercepting Consumer messages and having access to session IDs.  The
Consumer interface uses either the Hypertext Transfer Protocol (HTTP) or
the Session Initiation Protocol (SIP) as the mechanism
        for clients to connect to an MRB to request media resources.  In the
case where HTTP is used, any binding using the Consumer
        interface MUST be capable of being transacted over Transport Layer
Security (TLS), as described in <xref target="RFC2818">RFC 2818</xref>. 
        In the case where SIP is used, the same security considerations included in the Media Control
        Channel Framework specification apply here to protect interactions between a client
        requesting media resources and an MRB.</t>
        
        <t>Should a valid session ID be compromised somehow (that is, intercepted or just guessed by a
        malicious user), as a further means to prevent disruption the Consumer interface also prescribes the use
        of a sequence number in its transactions.  This sequence number is to be increased
        after each successful transaction, starting from a first value randomly generated by the MRB
        when the session is first created, and it must match in every request/response.  While this adds
        complexity to the protocol (implementations must pay attention to those sequence numbers, since
        wrong values will cause "Wrong sequence number" errors and the failure of the related requests),
        it is an important added value for security. In fact, considering that different transactions related to the same
        session could be transported in different, unrelated HTTP messages (or SIP INVITEs
        in cases where the In-line mode is being used), this sequence number
        protection prevents the chances of session replication or disruption, especially in
        cases where the session ID has been compromised: that is, it should make it harder for malicious
        users to manipulate or remove a session for which they have obtained the session ID.  It is strongly
        advised that the MRB doesn't choose 1 as the first sequence number for a new session but rather
        picks a random value to start from. The reaction to transactions that
are out of sequence is left to
        MRB implementations: a related error code is available, but implementations may decide to
        enforce further limitations or actions upon the receipt of too many failed attempts in a row or
        of what looks like blatant attempts to guess what the current, valid sequence number is.</t>
        
        <t>It is also worth noting that in In-line mode (both IAMM and IUMM) the MRB
        may act as a Back-to-Back User Agent (B2BUA). This means that when
acting as a B2BUA the
        MRB may modify SIP bodies: it is the case, for instance, for the IAMM
        handling multipart/mixed payloads. This impacts the ability to use any
        SIP security feature that protects the body (e.g., RFC 4474 <xref
target="RFC4474"/>, S/MIME, etc.), unless the MRB acts as a mediator for
the security association. This should be taken into
        account when implementing an MRB compliant with this specification.</t>
        
        <t>Both the Publishing interface and Consumer interface may address the location of a Media Server: the
        Publishing interface may be used to inform the MRB where a Media Server is located
        (approximately or precisely), and the Consumer interface may be used to ask for a Media Server
        located somewhere in a particular region (e.g., a conference bridge close to San Francisco).
        Both Media Server and MRB implementers need to take this into account
        when deciding whether or not to make this location information available, and if so
        how many bits of information really need to be made available for brokering purposes.</t>
        
        <t>It is worthwhile to cover authorization issues related
        to this specification. Neither the Publishing interface nor the
        Consumer interface
        provides an explicit means for implementing authentication, i.e., they
        do not contain specific protocol interactions to ensure that
        authorized Application Servers can make use of the services provided
        by an MRB instance. Considering that both interfaces are transported
        using well-established protocols (HTTP, SIP, CFW), support for such
        functionality can be expressed by means of the authentication mechanisms
        provided by the protocols themselves. Therefore, any MRB-aware entity
        (Application Servers, Media Servers, MRBs themselves)
        MUST support HTTP and SIP Digest access
        authentication. The usage of such Digest access authentications
        is recommended and not mandatory, which means MRB-aware entities MAY
        exploit it in deployment.</t>
                
        <t>An MRB may want to enforce further constraints on the interactions between an Application Server/Media
        Server and an MRB.
        For example, it may choose to only accept requests associated with a specific session ID
        from the IP address that originated the first request or may just make use of pre-shared certificates
        to assess the identity of legitimate Application Servers and/or Media Servers.</t>
        
</section>

<!-- Security Considerations -->

<section anchor="sec:IANA_Considerations" title="IANA Considerations">

        <t>There are several IANA considerations associated with this specification.</t>

        <section anchor="sec:IANA_Package" title="Media Control Channel Framework Package Registration">

   <t>This section registers a new Media Control Channel Framework package,
   per the instructions in Section 13.1 of <xref target="RFC6230"/>.</t>

        <t>
        <list style="hanging">

      <t hangText="Package Name:">mrb-publish/1.0</t>
      <t hangText="Published Specification(s):">RFC 6917</t>
      <t hangText="Person and email address to contact for further information:">
      IETF MediaCtrl working group (mediactrl@ietf.org),
      Chris Boulton (chris@ns-technologies.com).</t>
        </list>
        </t>

        </section>

        <section anchor="sec:IANA_Publish" title="application/mrb-publish+xml Media Type">

        <t>
        <list style="hanging">

                <t hangText="To:">application</t>
                <t hangText="Subject:">Registration of media type application/mrb-publish+xml</t>
                
                <t hangText="Type name:">application</t>

                 <t hangText="Subtype name:">mrb-publish+xml</t>

                 <t hangText="Required parameters:">none</t>

                 <t hangText="Optional parameters:">Same as charset parameter of application/xml as
 specified in RFC 3023 <xref target="RFC3023"/>.</t>

                 <t hangText="Encoding considerations:">Same as encoding considerations of
 application/xml as specified in RFC 3023 <xref target="RFC3023"/>.</t>

                 <t hangText="Security considerations:">See Section 10 of RFC 3023 <xref target="RFC3023"/> and
 <xref target="sec:security"/> of RFC 6917.</t>

                 <t hangText="Interoperability considerations:">none.</t>

                 <t hangText="Published specification:"><xref target="sec:publisher_xml"/> of
                        RFC 6917.</t>

                 <t hangText="Applications that use this media type:">This media type is used to
support a Media Resource Broker (MRB) entity.</t>

                 <t hangText="Additional Information:"></t>

                 <t hangText="Magic Number:">None</t>

                 <t hangText="File Extension:">.xdf</t>

                 <t hangText="Macintosh file type code:">&quot;TEXT&quot;</t>

                 <t hangText="Person and email address to contact for further information:">Chris Boulton (chris@ns-technologies.com).</t>

                 <t hangText="Intended usage: COMMON"></t>

                 <t hangText="Author/Change controller:">The IETF.</t>

        </list>
        </t>

        </section>

        <!-- IANA Publish -->

        <section anchor="sec:IANA_Consumer" title="application/mrb-consumer+xml Media Type">


        <t>
        <list style="hanging">

                <t hangText="To:">application</t>
                <t hangText="Subject:">Registration of media type application/mrb-consumer+xml</t>
                
                <t hangText="Type name:">application</t>

                 <t hangText="Subtype name:">mrb-consumer+xml</t>

                 <t hangText="Mandatory parameters:">none</t>

                 <t hangText="Optional parameters:">Same as charset parameter of application/xml as
 specified in RFC 3023 <xref target="RFC3023"/>.</t>

                 <t hangText="Encoding considerations:">Same as encoding considerations of
 application/xml as specified in RFC 3023 <xref target="RFC3023"/>.</t>

                 <t hangText="Security considerations:">See Section 10 of RFC 3023 <xref target="RFC3023"/> and
 <xref target="sec:security"/> of RFC 6917.</t>

                 <t hangText="Interoperability considerations:">none.</t>

                 <t hangText="Published specification:"><xref target="sec:consumer_xml"/> of
                        RFC 6917.</t>

                 <t hangText="Applications that use this media type:">This media type is used to
support a Media Resource Broker (MRB) entity.</t>

                 <t hangText="Additional Information:"></t>

                 <t hangText="Magic Number:">None</t>

                 <t hangText="File Extension:">.xdf</t>

                 <t hangText="Macintosh file type code:">&quot;TEXT&quot;</t>

                 <t hangText="Person and email address to contact for further information:">Chris Boulton (chris@ns-technologies.com).</t>

                 <t hangText="Intended usage: COMMON"></t>

                 <t hangText="Author/Change controller:">The IETF.</t>

        </list>
        </t>

        </section>

        <!-- IANA Consumer -->

        <section anchor="sec:IANA_mrbpub" title="URN Sub-Namespace Registration for mrb-publish">
<t>
   IANA has registered the URN "urn:ietf:params:xml:ns:mrb-publish", with the ID of "mrb-publish".  The schema of the XML namespace named
urn:ietf:params:xml:ns:mrb-publish is in <xref
target="sec:publisher_xml"/>.
</t>
        </section>

        <!-- IANA MrbPub -->

        <section anchor="sec:IANA_mrbcons" title="URN Sub-Namespace Registration for mrb-consumer">
<t>
   IANA has registered the URN "urn:ietf:params:xml:ns:mrb-consumer", with the ID of "mrb-consumer".  The schema of the XML namespace named
urn:ietf:params:xml:ns:mrb-consumer is in <xref target="sec:consumer_xml"/>.
</t>
        </section>

        <!-- IANA MrbCons -->

        <section anchor="sec:IANA_PubSchema" title="XML Schema Registration for mrb-publish">

        <t>IANA has registered the schema for mrb-publish:</t>

        <t>
        <list style="hanging">

                <t hangText="URI:">urn:ietf:params:xml:schema:mrb-publish</t>
                <t hangText="ID:">mrb-publish</t>
                <t hangText="Filename:">mrb-publish</t>
                <t hangText="Registrant Contact:">IETF MediaCtrl working group (mediactrl@ietf.org)</t>
                <t hangText="Schema:">The XML for the schema is in <xref target="sec:publisher_xml"/> of this document.</t>

        </list>
        </t>
        
        </section>

        <!-- IANA Publisher Schema -->

        <section anchor="sec:IANA_ConsSchema" title="XML Schema Registration for mrb-consumer">

        <t>Please register the schema for mrb-consumer:</t>
        
        <t>
        <list style="hanging">

                <t hangText="URI:">urn:ietf:params:xml:schema:mrb-consumer</t>
                <t hangText="ID:">mrb-consumer</t>
                <t hangText="Filename:">mrb-consumer</t>
                <t hangText="Registrant Contact:">IETF MediaCtrl working group (mediactrl@ietf.org)</t>
                <t hangText="Schema:">The XML for the schema is in <xref target="sec:consumer_xml"/> of this document.</t>

        </list>
        </t>
        
        </section>

        <!-- IANA Publisher Schema -->

</section>

<!-- IANA Considerations -->

<section title="Acknowledgements">

        <t>The authors would like to thank the members of the Publish Interface
        design team, who provided valuable input into this document.  The
        design team consisted of Adnan Saleem, Michael Trank, Victor Paulsamy,
        Martin Dolly, and Scott McGlashan.  The authors would also like to
        thank John Dally, Bob Epley, Simon Romano, Henry Lum, Christian Groves,
        and Jonathan Lennox for input into this specification.</t>
        
        <t>Ben Campbell carried out the RAI expert review on an early
        version of this specification and provided a great deal of invaluable
        input.</t>

</section>

<!-- Acknowledgements -->

        </middle>

        <!-- Middle -->

        <back>

       <?rfc rfcedstyle="no"?>
          <references title="Normative References">
                <?rfc include="reference.RFC.2119"?>
                <?rfc include="reference.RFC.2616"?>
                <?rfc include="reference.RFC.2046"?>
                <?rfc include="reference.RFC.3023"?>
                <?rfc include="reference.RFC.3261"?>
                <?rfc include="reference.RFC.3311"?>
                <?rfc include="reference.RFC.3711"?>
                <?rfc include="reference.RFC.5139"?>
                <?rfc include="reference.RFC.5763"?>

<reference anchor="ISO.10646.2012">
<front>
<title>Information technology -- Universal Coded Character Set (UCS)
</title>
<author>
<organization>International Organization for Standardization</organization>
</author>
<date month="" year="2012" />
</front>
<seriesInfo name="ISO" value="Standard 10646" />
</reference>

<reference anchor="ISO.639.2002">
<front>
<title>Codes for the representation of names of languages -- Part 1: Alpha-2 code</title>
<author>
<organization>International Organization for Standardization</organization>
</author>
<date month="" year="2002" />
</front>
<seriesInfo name="ISO" value="Standard 639" />
</reference>

                <reference anchor="ITU-T.Q.1950">
                   <front>
                     <title>Bearer independent call bearer control protocol</title>
                       <author>
                          <organization>International Telecommunication Union</organization>
                       </author>
                       <date month="December" year="2002"/>
                       </front>
                       <seriesInfo name="ITU-T" value="Recommendation Q.1950"/>
                </reference>

                <reference anchor="ISO.3166-1">
                  <front>
                     <title>Codes for the representation of names of countries and their subdivisions - Part 1: Country codes</title>
                        <author>
                           <organization>International Organization for Standardization</organization>
                        </author>
                        <date year="2006"/>
                        </front>
                        <seriesInfo name="ISO" value="Standard 3166-1:2006"/>
                </reference>


<reference anchor='W3C.REC-xmlschema-1-20041028'
           target='http://www.w3.org/TR/2004/REC-xmlschema-1-20041028'>
<front>
<title>XML Schema Part 1: Structures Second Edition</title>
<author initials='H.' surname='Thompson' fullname='Henry S. Thompson'>
    <organization />
</author>
<author initials='D.' surname='Beech' fullname='David Beech'>
    <organization />
</author>
<author initials='M.' surname='Maloney' fullname='Murray Maloney'>
    <organization />
</author>
<author initials='N.' surname='Mendelsohn' fullname='Noah Mendelsohn'>
    <organization />
</author>
<date month='October' year='2004' />
</front>
<seriesInfo name='World Wide Web Consortium Recommendation'
value='REC-xmlschema-1-20041028' />
</reference>

<reference anchor='W3C.REC-xmlschema-2-20041028'
           target='http://www.w3.org/TR/2004/REC-xmlschema-2-20041028'>
<front>
<title>XML Schema Part 2: Datatypes Second Edition</title>
<author initials='P.' surname='Biron' fullname='Paul V. Biron'>
    <organization />
</author>
<author initials='A.' surname='Malhotra' fullname='Ashok Malhotra'>
    <organization />
</author>
<date month='October' year='2004' />
</front>
<seriesInfo name='World Wide Web Consortium Recommendation'
value='REC-xmlschema-2-20041028' />
</reference>

          </references>

          <references title="Informative References">
                    <?rfc include="reference.RFC.2818"?>
                    <?rfc include="reference.RFC.5022"?>
                    <?rfc include="reference.RFC.4240"?>
                    <?rfc include="reference.RFC.6381"?>
                    <?rfc include="reference.RFC.4474"?>
                    <?rfc include="reference.RFC.4733"?>
                    <?rfc include="reference.RFC.5167"?>
                    <?rfc include="reference.RFC.5707"?>
                    <?rfc include="reference.RFC.5552"?>
                    <?rfc include="reference.RFC.5567"?>
                    <?rfc include="reference.RFC.6230"?>
                    <?rfc include="reference.RFC.6231"?>
                    <?rfc include="reference.RFC.6501"?>
                    <?rfc include="reference.RFC.6505"?>
              </references>
             <?rfc rfcedstyle="yes"?>
          </back>

        <!-- Back -->

</rfc>
