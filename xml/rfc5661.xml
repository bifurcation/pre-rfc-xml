<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>


<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc symrefs="no"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<?rfc rfcedstyle="yes" ?>

<rfc
    category="std"
    number="5661">
     

<front>
    <title abbrev="NFSv4.1">
    Network File System (NFS) Version 4 Minor Version 1 Protocol

    </title>

    <author fullname="Spencer Shepler" 
            initials="S." 
            surname="Shepler" role="editor">
        <organization>Storspeed, Inc.</organization>
        <address>
            <postal>
                <street>7808 Moonflower Drive</street>
                <city>Austin</city>
                <region>TX</region>
                <code>78750</code>
                <country>USA</country>
            </postal>
            <phone>+1-512-402-5811 ext 8530</phone>
            <email>shepler@storspeed.com</email>
        </address>
    </author>
    <author fullname="Mike Eisler" 
            initials="M." 
            surname="Eisler" role="editor">
        <organization abbrev="NetApp">NetApp</organization>
        <address>
            <postal>
                <street>5765 Chase Point Circle</street>
                <city>Colorado Springs</city>
                <region>CO</region>
                <code>80919</code>
                <country>USA</country>
            </postal>
            <phone>+1-719-599-9026</phone>
            <email>mike@eisler.com</email>
            <uri>http://www.eisler.com</uri>
        </address>
    </author>
    <author fullname="David Noveck" 
            initials="D." 
            surname="Noveck" role="editor">
        <organization abbrev="NetApp">NetApp</organization>
        <address>
            <postal>
                <street>1601 Trapelo Road, Suite 16</street>
                <city>Waltham</city>
                <region>MA</region>
                <code>02451</code>
                <country>USA</country>
            </postal>
            <phone>+1-781-768-5347</phone>
            <email>dnoveck@netapp.com</email>
        </address>
    </author>

    <date year="2010" month="January"/>

    <area>Transport</area>
    <workgroup>NFSv4</workgroup>

    <abstract>
      <t>
      This document describes the Network File System (NFS) version 4 minor version 1,
      including features retained from the base protocol (NFS version 4 minor
      version 0, which is specified in RFC 3530) and protocol
      extensions made subsequently.  Major extensions introduced in
      NFS version 4 minor version 1 include Sessions, Directory
      Delegations, and parallel NFS (pNFS). NFS version 4 minor version 1
      has no dependencies on NFS version 4 minor version 0, and it
      is considered a separate protocol. Thus,
      this document neither updates nor obsoletes RFC 3530.
      NFS minor version 1 is deemed superior to NFS minor version 0
      with no loss of functionality, and its use is preferred over
      version 0. Both NFS minor versions 0 and 1 can be used
      simultaneously on the same network, between the same client and server.
      </t>
    </abstract>

</front>

<middle>

<section anchor="intro" title="Introduction" >
  <section anchor="intro_the_protocol" title="The NFS Version 4 Minor Version 1 Protocol">
    <t>
      The NFS version 4 minor version 1 (NFSv4.1) protocol
      is the second minor version of the NFS version 4
      (NFSv4) protocol. The first minor version, NFSv4.0, is
      described in <xref target="RFC3530" />.  It generally
      follows the guidelines for minor versioning that are
      listed in Section 10 of RFC 3530.  However, it
      diverges from guidelines 11 ("a client and server
      that support minor version X must support minor
      versions 0 through X-1") and 12 ("no new features may be
      introduced as mandatory in a minor version"). These
      divergences are due to the introduction of
      the sessions model for managing non-idempotent
      operations and the RECLAIM_COMPLETE operation.
      These two new features are infrastructural in
      nature and simplify implementation of existing and
      other new features.  Making them anything but REQUIRED
      would add undue complexity to protocol definition and
      implementation.  NFSv4.1 accordingly updates the
      <xref target="minor_versioning">minor versioning
      guidelines</xref>.

    </t>
    <t>
      As a minor version, NFSv4.1 is consistent with the overall
      goals for NFSv4, but extends the protocol so as to
      better meet those goals, based on experiences with NFSv4.0.
      In addition, NFSv4.1 has adopted some additional goals, which
      motivate some of the major extensions in NFSv4.1.
    </t>
  </section>
    <section title="Requirements Language">
<t>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;,
&quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be
interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
</t>

    </section>

  <section anchor="scope_of_doc" title="Scope of This Document">
  <t>

   This document describes the NFSv4.1 protocol. With
   respect to NFSv4.0, this document does not:

   <list style='symbols'>
   <t>
       describe the NFSv4.0 protocol, except where needed
       to contrast with NFSv4.1.

   </t> 

   <t>
       modify the specification of the NFSv4.0 protocol.

   </t>

   <t>
       clarify the NFSv4.0 protocol.

   </t>
   </list>
  </t>

  </section>
  <section anchor="version4_goals" title="NFSv4 Goals">
    <t>
      The NFSv4 protocol is a further revision of the NFS protocol
      defined already by NFSv3
      <xref target="RFC1813" />.  It retains
      the essential characteristics of previous versions: easy
      recovery; independence of transport protocols, operating systems, and
      file systems; simplicity; and good performance.  NFSv4 has the following goals:

      <list style='symbols'>
        <t>
          Improved access and good performance on the Internet
        <vspace blankLines='1' />
          The protocol is designed to transit firewalls easily, perform well
          where latency is high and bandwidth is low, and scale to very
          large numbers of clients per server.
        </t>
        <t>
          Strong security with negotiation built into the protocol
        <vspace blankLines='1' />
          The protocol builds on the work of the ONCRPC working group in
          supporting the RPCSEC_GSS protocol.  Additionally, the
        NFSv4.1 protocol provides a mechanism to allow clients and
        servers the ability to negotiate security and require clients and servers to
          support a minimal set of security schemes.
        </t>
        <t>
          Good cross-platform interoperability
        <vspace blankLines='1' />
          The protocol features a file system model that provides a useful,
          common set of features that does not unduly favor one file system
          or operating system over another.
        </t>
        <t>
          Designed for protocol extensions
        <vspace blankLines='1' />
          The protocol is designed to accept standard extensions within a
          framework that enables and encourages backward compatibility.
        </t>
      </list>
    </t>
  </section>
  <section anchor="minor_version1_goals" title="NFSv4.1 Goals">
    <t>
      NFSv4.1 has the following goals, within the framework 
      established by the overall NFSv4 goals.
      <list style="symbols">
        <t>
          To correct significant structural weaknesses and oversights 
          discovered in the base protocol.
        </t>
        <t>
          To add clarity and specificity to areas left
          unaddressed or not addressed in sufficient
          detail in the base protocol. However, as stated
          in <xref target="scope_of_doc" />, it is not
          a goal to clarify the NFSv4.0 protocol in the
          NFSv4.1 specification.

        </t>
        <t>
          To add specific features based on experience with the existing
          protocol and recent industry developments. 
        </t>
        <t>
          To provide protocol support to take advantage of clustered 
          server deployments including the ability to provide scalable
          parallel access to files distributed among multiple servers.
        </t>
      </list>
    </t>
  </section>
  <section anchor="intro_definitions" title="General Definitions">
    <t>
      The following definitions provide an appropriate context for the reader.
      <list style='hanging'>
        <t hangText="Byte:" anchor="byte">
          In this document, a byte is an octet, i.e., a datum
          exactly 8 bits in length.
        </t>
        <t hangText="Client:" anchor="client_def">
          The client is the entity that accesses the NFS server's
          resources.  The client may be an application that contains
          the logic to access the NFS server directly.  The client
          may also be the traditional operating system client that
	  provides remote file system services for a set of applications.
        <vspace blankLines='1' />
          A client is uniquely identified by a client owner.
        <vspace blankLines='1' />
          With reference to byte-range locking, the client is also the entity that
          maintains a set of locks on behalf of one or more
          applications.  This client is responsible for crash or
          failure recovery for those locks it manages.
        <vspace blankLines='1' />
          Note that multiple clients may share the same transport and
          connection and
          multiple clients may exist on the same network node.
        </t>
        <t hangText="Client ID:">
          The client ID is a 64-bit quantity used as a unique, short-hand reference to
          a client-supplied verifier and client owner.  The server is
          responsible for supplying the client ID.
        </t>
        <t hangText="Client Owner:">
          The client owner is a unique string, opaque to the server,
          that identifies a client. Multiple network connections and source
          network addresses originating from those connections may share
          a client owner. The server is expected to treat requests
          from connections with the same client owner as coming from
          the same client.
        </t>

        <t hangText="File System:">
          The file system is the collection of objects on a server (as
          identified by the major identifier of a server
          owner, which is defined later in this section)
          that share the same fsid attribute (see <xref
          target="attrdef_fsid"/>).

        </t>
        <t hangText="Lease:">
          A lease is an interval of time defined by the server for which the
          client is irrevocably granted locks.  At the end of a
          lease period, locks may be revoked if the lease has not
          been extended.  A lock must be revoked if a conflicting
          lock has been granted after the lease interval.
        <vspace blankLines='1' />
          A server grants a client a single lease for all state.
        </t>
        <t hangText="Lock:">
          The term "lock" is used to refer to byte-range (in UNIX environments,
          also known as record)
          locks, share reservations, delegations, or layouts unless
          specifically stated otherwise.
        </t>

        <t hangText="Secret State Verifier (SSV):">
          The SSV is a unique secret key shared between a client and
          server.  The SSV serves as the secret key for an internal (that
          is, internal to NFSv4.1) Generic Security Services (GSS)
          mechanism (the SSV GSS mechanism;
          see <xref target="ssv_mech"/>).  The SSV GSS mechanism uses the
          SSV to compute message integrity code (MIC) and Wrap tokens.
          See <xref target="protect_state_change"/> for more details on how NFSv4.1 uses
          the SSV and the SSV GSS mechanism.

        </t>

        <t hangText="Server:">
          The Server is the entity responsible for coordinating
          client access to a set of file systems and is identified by a server
          owner. A server can span multiple network addresses.
        </t>
        <t hangText="Server Owner:">
          The server owner identifies the server to the client.
          The server owner consists of a major identifier and a minor identifier.
          When the client has two connections each to a peer with the
          same major identifier, the client assumes that both peers are
          the same server (the server namespace is the
          same via each connection) and that
          lock state is sharable across both connections. When each peer
          has both the same major and minor identifiers, the client
          assumes that each connection might be associable with the same session.
        </t>
        <t hangText="Stable Storage:">
          Stable storage is storage from which data stored by
          an NFSv4.1 server can be recovered without data
          loss from multiple power failures (including cascading
          power failures, that is, several power failures in quick
          succession), operating system failures, and/or hardware
          failure of components other than the storage medium itself
          (such as disk, nonvolatile RAM, flash memory, etc.).
        <vspace blankLines='1' />
          Some examples of stable storage that are allowable for an
          NFS server include:
          <list style='numbers'>
             <t>
               Media commit of data; that is, the modified data has
               been successfully written to the disk media, for
               example, the disk platter.
             </t>
             <t>
               An immediate reply disk drive with battery-backed,
               on-drive intermediate storage or uninterruptible power
               system (UPS).
             </t>
             <t>
               Server commit of data with battery-backed intermediate
               storage and recovery software.
             </t>
             <t>
               Cache commit with uninterruptible power system (UPS) and
               recovery software.
             </t>
           </list>
        </t>
        <t hangText="Stateid:">
          A stateid is a 128-bit quantity returned by a server that uniquely
          defines the open and locking states provided by the server
          for a specific open-owner or lock-owner/open-owner pair
          for a specific file and type of lock.
        </t>
        <t hangText="Verifier:">
          A verifier is a 64-bit quantity generated by the client that the server
          can use to determine if the client has restarted and lost
           all previous lock state.        
        </t>
      </list>
    </t>
  </section>
  <section anchor="feature overview" 
           title="Overview of NFSv4.1 Features">
    <t>
      The major features of
      the NFSv4.1 protocol will be reviewed in brief.  This will be done
      to provide an appropriate context for both the reader who is familiar
      with the previous versions of the NFS protocol and the reader
      who is new to the NFS protocols.  For the reader new to the NFS protocols,
      there is still a set of fundamental knowledge that is expected.  
      The reader should be familiar with the External Data
      Representation (XDR) and Remote Procedure Call (RPC) protocols 
      as described in <xref target="RFC4506" /> and <xref target="RFC5531" />.
      A basic knowledge of file systems and distributed file systems is expected as well.
    </t>
    <t>
      In general, this specification of NFSv4.1 will
      not distinguish those features added in minor version
      1 from those present in the base protocol but
      will treat NFSv4.1 as a unified whole.  See <xref
      target="intro_differences" /> for a summary of
      the differences between NFSv4.0 and NFSv4.1.

    </t>
    <section anchor="rpc_and_security" title="RPC and Security">
      <t>
        As with previous versions of NFS, the External Data Representation
        (XDR) and Remote Procedure Call (RPC) mechanisms used for the NFSv4.1 protocol are those defined in 
        <xref target="RFC4506" /> and <xref target="RFC5531" />.  To
        meet end-to-end security requirements, the RPCSEC_GSS framework
        <xref target="RFC2203" /> is used to extend the basic 
        RPC security.  With the
        use of RPCSEC_GSS, various mechanisms can be provided to offer
        authentication, integrity, and privacy to the NFSv4 protocol.
        Kerberos V5 is used as described in 
        <xref target="RFC4121" /> to provide one
        security framework.
        With the use of
        RPCSEC_GSS, other mechanisms may also be specified and used for NFSv4.1 security.
      </t>
      <t>
        To enable in-band security negotiation, the NFSv4.1 protocol
        has operations that provide the client a method of
        querying the server about its policies regarding which security
        mechanisms must be used for access to the server's file system
        resources.  With this, the client can securely match the security
        mechanism that meets the policies specified at both the client and
        server.
      </t>
      <t>
	NFSv4.1 introduces parallel access (see <xref
	target="parallel_access"/>), which is
	called pNFS.  

The security framework
	described in this section is
	significantly modified by the
	introduction of pNFS (see <xref
	target="security_considerations_pnfs"/>),
	because data access is sometimes not over
	RPC.  The level of significance varies
	with the storage protocol (see <xref
	target="storage_protocol"/>) and can be as low as zero
        impact (see <xref target="file_security_considerations"/>).

      </t>
    </section>
    <section anchor="protocol_structure" 
             title="Protocol Structure">
      <section anchor="core_protocol" 
               title="Core Protocol">
        <t>
          Unlike NFSv3, which used a series of ancillary 
          protocols (e.g., NLM, NSM (Network Status Monitor), MOUNT), within all minor versions
          of NFSv4 a single RPC protocol is used to make requests to 
          the server.  

Facilities that had been separate protocols, such
          as locking, are now integrated within a single unified
          protocol.
        </t>
      </section>
      <section anchor="parallel_access" 
               title="Parallel Access">
        <t>
          Minor version 1 supports high-performance data access to a
          clustered server implementation by enabling a separation of
          metadata access and data access, with the latter done to 
          multiple servers in parallel.
        </t>
        <t>
          Such parallel data access is controlled by recallable 
          objects known as "layouts", which are integrated into the
          protocol locking model.  Clients direct requests for
          data access to a set of data servers specified by the
          layout via a data
          storage protocol which may be NFSv4.1 or may be another
          protocol.
        </t>

        <t>
	  Because the protocols used for parallel
	  data access are not necessarily
	  RPC-based, the RPC-based security model
	  (<xref target="rpc_and_security"/>) is
	  obviously impacted (see <xref
	  target="security_considerations_pnfs"/>).
	  The degree of impact varies with the
	  storage protocol (see <xref
	  target="storage_protocol"/>) used for
	  data access, and can be as low as zero (see 
	  <xref target="file_security_considerations"/>).

        </t>
      </section>
    </section>
    <section anchor="file system_model" title="File System Model">
      <t>
        The general file system
        model used for the NFSv4.1 protocol 
        is the same as previous versions.  The server file system is 
        hierarchical with the regular files contained within being 
        treated as opaque byte
        streams.  In a slight departure, file and directory names are encoded
        with UTF-8 to deal with the basics of internationalization.
      </t>
      <t>
        The NFSv4.1 protocol does not require a separate 
        protocol to provide for the initial mapping between path 
        name and filehandle.  All file systems exported by a server
        are presented as a tree so that all file systems are reachable
        from a special per-server global root filehandle.  This
        allows LOOKUP operations to be used to perform functions
        previously provided by the MOUNT protocol.  The server
        provides any necessary pseudo file systems to bridge any
        gaps that arise due to unexported gaps between exported
        file systems.
      </t>
      <section anchor="intro_filehandles" title="Filehandles">
        <t>
          As in previous versions of the NFS protocol, opaque 
          filehandles are used to identify individual files
          and directories.  Lookup-type and create operations
          translate file and directory names to
          filehandles, which are then used to identify objects
          in subsequent operations.
        </t>
        <t>
          The NFSv4.1 protocol provides support for 
          persistent filehandles, guaranteed to be valid
          for the lifetime of the file system object designated.
          In addition, it provides support to servers to provide
          filehandles with more limited validity guarantees,
          called volatile filehandles. 
        </t>
      </section>
      <section anchor="intro_attributes" title="File Attributes">
        <t>
	  The NFSv4.1 protocol has a rich and extensible
	  file object attribute structure, which is divided
	  into REQUIRED, RECOMMENDED, and named attributes
	  (see <xref target="file_attributes"/>).

        </t>
        <t>
	  Several (but not all) of the REQUIRED attributes
	  are derived from the attributes of NFSv3 (see
	  the definition of the fattr3 data type in <xref
	  target="RFC1813"/>). An example of a REQUIRED
	  attribute is the file object's type (<xref
	  target="attrdef_type"/>) so that regular files
	  can be distinguished from directories (also known
	  as folders in some operating environments) and
	  other types of objects. REQUIRED attributes are
	  discussed in <xref
	  target="mandatory_attributes_intro"/>.

        </t>

        <t>
	  An example of three RECOMMENDED attributes are
	  acl, sacl, and dacl.  These attributes define an
	  Access Control List (ACL) on a file object
	  (<xref target="acl"/>).  An ACL provides
	  directory and file access control beyond the
	  model used in NFSv3.   The ACL definition allows
	  for specification of specific sets of permissions
	  for individual users and groups.  In addition,
	  ACL inheritance allows propagation of access
	  permissions and restrictions down a directory tree
	  as file system objects are created.  RECOMMENDED
	  attributes are discussed in <xref
	  target="recommended_attributes_intro"/>.


        </t>
        <t>
          A named attribute is an opaque byte stream that is associated 
          with a directory or file and referred to by a string name.  
          Named attributes are meant to be used by client applications 
          as a method to associate application-specific data with a 
          regular file or directory.  NFSv4.1 modifies named attributes
          relative to NFSv4.0 by tightening the allowed operations in
          order to prevent the development of non-interoperable
          implementations.  Named attributes are discussed in <xref target="named_attributes_intro" />.

        </t>
      </section>
      <section anchor="intro_ms_namespace" title="Multi-Server Namespace">
        <t>
          NFSv4.1 contains a number of features to allow
          implementation of namespaces that cross server boundaries
          and that allow and facilitate a non-disruptive transfer of 
          support for individual file systems between servers.  They 
          are all based upon attributes that allow one file system to
          specify alternate or new locations for that file system.   
        </t>
        <t>
          These attributes may be used together with the concept
          of absent file systems, which provide specifications
          for additional locations but no actual file system 
          content.  This allows a number of important facilities:
          <list style="symbols">
            <t>
              Location attributes may be used with absent file systems
              to implement referrals whereby one server may direct the
              client to a file system provided by another server.  This
              allows extensive multi-server namespaces to be constructed.
            </t>
            <t>
              Location attributes may be provided for present file systems
              to provide the locations of alternate file system instances
              or replicas to be used in the event that the current 
              file system instance becomes unavailable.
            </t>
            <t>
              Location attributes may be provided when a previously
              present file system becomes absent.  This allows 
              non-disruptive migration of file systems to alternate
              servers.
            </t>
          </list>
        </t>
      </section>
    </section>
    <section anchor="intro_locking" title="Locking Facilities">
      <t>
        As mentioned previously, NFSv4.1 is a single protocol that
        includes locking facilities.  These locking facilities 
        include support for many types of locks including a number
        of sorts of recallable locks.  Recallable locks such as
        delegations allow the client to be assured that certain 
        events will not occur so long as that lock is held.  When
        circumstances change, the lock is recalled 
        via a callback request.  The assurances provided by 
        delegations allow more extensive caching to be done safely
        when circumstances allow it.
      </t>
      <t>
	The types of locks are:
      </t>
      <t>
        <list style="symbols">
          <t>
            Share reservations as established by OPEN operations.
          </t>
          <t>
            Byte-range locks.
          </t>
          <t>
            File delegations, which are recallable locks that assure
            the holder that inconsistent opens and file changes cannot
            occur so long as the delegation is held.  
          </t>
          <t>
            Directory delegations, which are recallable locks
            that assure the holder that inconsistent directory 
            modifications cannot occur so long as the delegation 
            is held.
          </t>
          <t>
            Layouts, which are recallable objects that assure the
            holder that direct access to the file data may be 
            performed directly by the client and that no change
            to the data's location that is inconsistent with that access
            may be made so long as the layout is held.  
          </t>
        </list>
      </t>
      <t>
        All locks for a given client are tied together under a
        single client-wide lease.  All requests made on sessions
        associated with the client renew that lease.  When the client's
        lease
        is not promptly renewed, the client's locks are subject to revocation.
        In the event of server restart, clients have the
        opportunity to safely reclaim their locks within a special
        grace period.
      </t>
    </section>
  </section>
  <section anchor="intro_differences" title="Differences from NFSv4.0">
    <t>
      The following summarizes the major differences between minor version 
      1 and the base protocol:
      <list style="symbols">
        <t>
          Implementation of the sessions model (<xref target="Session"/>).
        </t>
        <t>
          Parallel access to data (<xref target="pnfs"/>).
        </t>
        <t>
          Addition of the RECLAIM_COMPLETE operation to better structure
          the lock reclamation process (<xref target="OP_RECLAIM_COMPLETE"/>).
        </t>

        <t>
         Enhanced delegation support as follows.

         <list style="symbols">
	 <t>
	   Delegations on directories and other
	   file types in addition to regular files (<xref
	   target="OP_GET_DIR_DELEGATION"/>, <xref
	   target="OP_WANT_DELEGATION"/>).

	 </t>
	 <t>
	   Operations to optimize acquisition of recalled
	   or denied delegations (<xref
	   target="OP_WANT_DELEGATION"/>, <xref
	   target="OP_CB_PUSH_DELEG"/>, <xref
	   target="OP_CB_RECALLABLE_OBJ_AVAIL"/>).

	 </t>

	 <t>
	   Notifications of changes to files and directories
	   (<xref target="OP_GET_DIR_DELEGATION"/>, <xref
	   target="OP_CB_NOTIFY"/>).

	 </t>

	 <t>
	   A method to allow a server to indicate that it is
	   recalling one or more delegations for resource
	   management reasons, and thus a method to allow
	   the client to pick which delegations to return
	   (<xref target="OP_CB_RECALL_ANY"/>).

        </t>

        </list>

        </t>

        <t>
	  Attributes can be set atomically
	  during exclusive file create via the OPEN operation
	  (see the new EXCLUSIVE4_1 creation method in
	  <xref target="OP_OPEN"/>).

        </t>
        <t>
	  Open files can be preserved if removed and the
	  hard link count ("hard link" is defined in
	  an <xref target="hardlink">Open Group</xref> standard) goes
	  to zero, thus obviating the
	  need for clients to rename deleted files to
	  partially hidden names -- colloquially called
	  "silly rename" (see the new
	  OPEN4_RESULT_PRESERVE_UNLINKED reply flag in
	  <xref target="OP_OPEN"/>).

        </t>
        <t>
	  Improved compatibility with Microsoft Windows for
	  Access Control Lists (<xref
	  target="attrdef_sacl"/>, <xref
	  target="attrdef_dacl"/>, <xref
	  target="auto_inherit"/>).

        </t>
        <t>
          Data retention (<xref target="retention"/>).

        </t>
        <t>
          Identification of the implementation of the NFS client
          and server (<xref target="OP_EXCHANGE_ID"/>).

        </t>

        <t>
	  Support for notification of the availability of
	  byte-range locks (see the new
	  OPEN4_RESULT_MAY_NOTIFY_LOCK reply flag in <xref
	  target="OP_OPEN"/> and see <xref
	  target="OP_CB_NOTIFY_LOCK"/>).

        </t>

        <t>
          In NFSv4.1, LIPKEY and SPKM-3 are not required security mechanisms
          <xref target="RFC2847"/>.
        </t>
         

      </list>
    </t>
  </section>
</section>


<section anchor="Core Infrastructure" title="Core Infrastructure">

 <section anchor="Introduction" title="Introduction">
 <t>
  NFSv4.1 relies on core infrastructure common to nearly
  every operation. This core infrastructure is described in the remainder
  of this section.
 </t>
 </section> <!-- Introduction -->

 <section anchor="RPC and XDR" title="RPC and XDR">
 <t>
  The NFSv4.1 protocol is a Remote Procedure Call (RPC)
  application that uses RPC version 2 and the corresponding eXternal
  Data Representation (XDR) as defined in
  <xref target="RFC5531"/> and
  <xref target="RFC4506"/>.
 </t>

  <section anchor="RPC-based Security" title="RPC-Based Security">
  <t>
   Previous NFS versions have been thought of as having a
   host-based authentication model, where the NFS server
   authenticates the NFS client, and trusts the client
   to authenticate all users.
   Actually, NFS has always depended on RPC for
   authentication. One of the first forms of RPC authentication,
   AUTH_SYS, had no strong authentication and
   required a host-based authentication
   approach. NFSv4.1 also depends on RPC for basic security
   services and mandates RPC support for a user-based
   authentication model. The user-based authentication
   model has user principals authenticated by a server, and
   in turn the server authenticated by user principals.
   RPC provides some basic security services that are used
   by NFSv4.1.
  </t>

   <section anchor="RPC Security Flavors" title="RPC Security Flavors">
    <t>
     As described in Section 7.2 ("Authentication") of <xref target="RFC5531"/>,
     RPC security is encapsulated in the RPC header, via a
     security or authentication flavor, and information
     specific to the specified security flavor.
     Every RPC header conveys information used to identify
     and authenticate a client and server. As discussed in
     <xref target="RPCSEC_GSS and Security Services" />,
     some security flavors provide additional security
     services.
    </t>
    <t>
     NFSv4.1 clients and servers MUST implement RPCSEC_GSS.
     (This requirement to implement is not a requirement to
     use.)  Other flavors, such as AUTH_NONE and
     AUTH_SYS, MAY be implemented as well.
    </t>

    <section anchor="RPCSEC_GSS and Security Services" title="RPCSEC_GSS and Security Services">
     <t>
      RPCSEC_GSS <xref target="RFC2203" /> uses the
      functionality of GSS-API <xref target="RFC2743"/>.  This allows for the
      use of various security mechanisms by the RPC layer
      without the additional implementation overhead of
      adding RPC security flavors.
     </t>

     <section anchor="Authentication, Integrity, Privacy" title="Identification, Authentication, Integrity, Privacy">
     <t>
      Via the GSS-API, RPCSEC_GSS can be used to identify and authenticate
      users on clients to servers, and servers to users. It can also
      perform integrity checking on the entire RPC message, including
      the RPC header, and on the arguments or results. Finally, privacy,
      usually via encryption, is a service available with RPCSEC_GSS.
      Privacy is performed on the arguments and results. Note that
      if privacy is selected, integrity, authentication, and identification
      are enabled.
      If privacy is not selected, but integrity is selected, authentication
      and identification are enabled. If integrity and privacy are not
      selected, but authentication is enabled,
      identification is enabled. RPCSEC_GSS does not provide identification as
      a separate service.
     </t>
     <t>
      Although GSS-API has an authentication service distinct from its
      privacy and integrity services, GSS-API's
      authentication service is not used for RPCSEC_GSS's authentication
      service. Instead, each RPC request and response header is
      integrity protected with the GSS-API integrity service, and
      this allows RPCSEC_GSS to offer per-RPC authentication and
      identity. See <xref target="RFC2203" /> for more information.
     </t>
     <t>
      NFSv4.1 client and servers MUST support RPCSEC_GSS's integrity and authentication
      service. NFSv4.1 servers MUST support RPCSEC_GSS's privacy service.
      NFSv4.1 clients SHOULD support  RPCSEC_GSS's privacy service.

     </t>
     </section> <!-- Identity, Authentication, Integrity, Privacy -->

     <section anchor="security_mechs" title="Security Mechanisms for NFSv4.1">
     <t>
      RPCSEC_GSS, via GSS-API, normalizes access to mechanisms that
      provide security services. Therefore, NFSv4.1 clients and servers
      MUST support the Kerberos V5 security mechanism.
     </t>
     <t>
      The use of RPCSEC_GSS requires selection of mechanism,
      quality of protection (QOP), and service (authentication,
      integrity, privacy).  For the mandated security mechanisms,
      NFSv4.1 specifies that a QOP of zero is used, leaving it up 
      to the mechanism or the mechanism's configuration to map
      QOP zero to
      an appropriate level of protection.
      Each mandated mechanism specifies a minimum set of cryptographic
      algorithms for implementing integrity and privacy. NFSv4.1
      clients and servers MUST be implemented on operating environments
      that comply with the REQUIRED cryptographic algorithms
      of each REQUIRED mechanism.
     </t>

      <section anchor="kerberosv5" title="Kerberos V5">
      <t>
       The Kerberos V5 GSS-API mechanism as described in
       <xref target="RFC4121"/> MUST be implemented with
       the RPCSEC_GSS services as specified in the following
       table:
      </t>
      <t>
      <figure>
      <artwork>
   column descriptions:
   1 == number of pseudo flavor
   2 == name of pseudo flavor
   3 == mechanism's OID
   4 == RPCSEC_GSS service
   5 == NFSv4.1 clients MUST support
   6 == NFSv4.1 servers MUST support

   1      2        3                    4                     5   6
   ------------------------------------------------------------------
   390003 krb5     1.2.840.113554.1.2.2 rpc_gss_svc_none      yes yes
   390004 krb5i    1.2.840.113554.1.2.2 rpc_gss_svc_integrity yes yes
   390005 krb5p    1.2.840.113554.1.2.2 rpc_gss_svc_privacy    no yes
      </artwork>
      </figure>
      </t>
      <t>
       Note that the number and name of the pseudo flavor
       are presented here as a mapping aid to the implementor.
       Because the NFSv4.1 protocol includes a method to negotiate
       security and it understands the GSS-API mechanism, the pseudo flavor
       is not needed.  The pseudo flavor is needed for the NFSv3 since the security negotiation is done via
       the MOUNT protocol as described in <xref target="RFC2623"/>.
      </t>
      <t>
       At the time NFSv4.1 was specified, the Advanced Encryption
       Standard (AES) with HMAC-SHA1 was
       a REQUIRED algorithm set for Kerberos V5. In contrast, when
       NFSv4.0 was specified, weaker algorithm sets were REQUIRED for
       Kerberos V5, and were REQUIRED in the NFSv4.0 specification, because
       the Kerberos V5 specification at the time did not specify stronger
       algorithms.
       The NFSv4.1 specification does not specify REQUIRED algorithms
       for Kerberos V5, and instead, the implementor is expected
       to track the evolution of the Kerberos V5 standard if and when
       stronger algorithms are specified.
       
       
      </t>
        <section anchor="krb5_sec_consider"
 title="Security Considerations for Cryptographic Algorithms in Kerberos V5">
        <t>
          When deploying NFSv4.1, the strength of the security achieved depends
          on the existing Kerberos V5 infrastructure. The algorithms
          of Kerberos V5 are not directly exposed to or selectable by the
          client or server, so there is some due diligence required by
          the user of NFSv4.1 to ensure that security is acceptable 
          where needed.
        </t>
        </section>
        
      </section> <!-- Kerberos V5  -->

      </section> <!-- Security mechanisms for NFSv4.1  -->

     <section anchor="GSS Server Principal" title="GSS Server Principal">
     <t>
      Regardless of what security mechanism under RPCSEC_GSS
      is being used, the NFS server MUST identify itself
      in GSS-API via a GSS_C_NT_HOSTBASED_SERVICE name type.
      GSS_C_NT_HOSTBASED_SERVICE names are of the form:
     <figure>
     <artwork>
     service@hostname
     </artwork>
     </figure>
     </t>
     <t>
      For NFS, the "service" element is
     <figure>
     <artwork>
     nfs
     </artwork>
     </figure>
     </t>
     <t>
      Implementations of security mechanisms will convert
      nfs@hostname to various different forms.  For Kerberos
      V5, the following form is RECOMMENDED:
     <figure>
     <artwork>
     nfs/hostname
     </artwork>
     </figure>
     </t>
     </section> <!-- GSS Server Principal -->
    </section> <!-- RPCSEC_GSS and Security Services -->
   </section> <!-- RPC Security Flavors -->
  </section> <!-- RPC-based Security -->
 </section> <!-- RPC and XDR -->

 <section anchor="COMPOUND and CB_COMPOUND" title="COMPOUND and CB_COMPOUND">
 <t>
   A significant departure from the versions of the NFS
   protocol before NFSv4 is the introduction of the 
   COMPOUND procedure.  For the NFSv4 protocol, 
   in all minor versions, there are exactly two RPC procedures, 
   NULL and COMPOUND.  The COMPOUND procedure is defined 
   as a series of individual operations and these operations 
   perform the sorts of functions performed by traditional 
   NFS procedures.
 </t>
 <t>
   The operations combined within a COMPOUND
   request are evaluated in order by the server, without
   any atomicity guarantees.  A limited set of facilities
   exist to pass results from one operation to another.  Once an 
   operation returns a failing result, the evaluation ends 
   and the results of all
   evaluated operations are returned to the client.
 </t>
 <t>
   With the use of the COMPOUND procedure, the client is able to build
   simple or complex requests.  These COMPOUND requests allow for a
   reduction in the number of RPCs needed for logical file system
   operations.  For example, multi-component look up requests can
   be constructed by combining multiple LOOKUP operations.  Those
   can be further combined with operations such as GETATTR, READDIR,
   or OPEN plus READ to do more complicated sets of operation without
   incurring additional latency.
 </t>
 <t>
   NFSv4.1 also contains a considerable set of
   callback operations in which the server makes an RPC
   directed at the client.  Callback RPCs have a similar
   structure to that of the normal server requests.
   In all minor versions of the NFSv4 protocol,
   there are two callback RPC procedures:
   CB_NULL and CB_COMPOUND.  The CB_COMPOUND procedure is defined 
   in an analogous fashion to that of COMPOUND 
   with its own set of callback operations.
 </t>
 <t>
   The addition of new server and callback operations within the 
   COMPOUND and CB_COMPOUND request
   framework provides a means of extending the protocol in
   subsequent minor versions.
 </t>
 <t>
   Except for a small number of operations needed for session
   creation, server requests and callback requests are performed
   within the context of a session.  Sessions provide a client
   context for every request and support robust reply 
   protection for non-idempotent requests.
 </t>
 </section> <!-- COMPOUND and CB_COMPOUND -->

 <section anchor="Client Identifiers"
  title="Client Identifiers and Client Owners">
  <t>
    For each operation that obtains or depends on locking state, the 
    specific client needs to be identifiable by the server.

  </t>
  <t>
    Each distinct client instance is represented
    by a client ID.  A client ID is a 64-bit identifier
    representing a specific client at a given time.
    The client ID is changed whenever the client re-initializes,
    and may change when the server re-initializes.
    Client IDs are used to support lock identification
    and crash recovery.

  </t>
  <t>
    During steady state operation,
    the client ID associated with each operation
    is derived from the session (see <xref target="Session"
    />) on which the operation is sent. A session is associated with
    a client ID when the session is created. 
  </t>
  <t>
    Unlike NFSv4.0, the only NFSv4.1 operations possible before a
    client ID is established are those needed to
    establish the client ID.
  </t>
  <t>
    A sequence of an EXCHANGE_ID operation followed by a 
    CREATE_SESSION operation using that client ID 
    (eir_clientid as returned from EXCHANGE_ID)
    is required to establish and confirm the
    client ID on the server.  Establishment of identification by a
    new incarnation of the client also has the effect of immediately
    releasing any locking state that a previous incarnation of that 
    same client might have had on the server.  Such released state 
    would include all byte-range lock, share reservation, layout state, and -- where the server supports neither the CLAIM_DELEGATE_PREV nor CLAIM_DELEG_CUR_FH claim types -- all delegation state associated with the same client with the same
    identity. For discussion of delegation state recovery, see
    <xref target="delegation_recovery" />. For discussion of layout state
    recovery, see <xref target="pnfs_client_recovery" />.
  </t>
  <t>
    Releasing such state requires that the server be able to determine
    that one client instance is the successor of another.  Where this
    cannot be done, for any of a number of reasons, the locking state
    will remain for a time subject to lease expiration 
    (see <xref target="lease_renewal" />)
    and the new client will need to wait for
    such state to be removed, if it makes conflicting lock requests. 
  </t>
  <t>
    Client identification is encapsulated in the following client owner
    data type:
  </t>
  <t>
<figure>
 <artwork>
struct client_owner4 {
        verifier4       co_verifier;
        opaque          co_ownerid&lt;NFS4_OPAQUE_LIMIT>;
};
 </artwork>
</figure>
  </t>
  <t>
    The first field, co_verifier, is a client incarnation
    verifier.  The server will start the process of
    canceling the client's leased state if co_verifier
    is different than what the server has previously
    recorded for the identified client (as specified in
    the co_ownerid field).

  </t>
  <t>
    The second field, co_ownerid, is a variable length string that uniquely defines
    the client so that subsequent instances of the same client bear the
    same co_ownerid with a different verifier.
  </t>
  <t>
    There are several considerations for how the client
    generates the co_ownerid string:
    <list style='symbols'>
      <t>
        The string should be unique so that multiple clients
        do not present the same string. The consequences of
        two clients presenting the same string range from
        one client getting an error to one client having its
        leased state abruptly and unexpectedly cancelled.
      </t>
      <t> 
        The string should be selected so that subsequent incarnations
        (e.g., restarts) of the same client cause the client to present 
        the same string. The implementor 
        is cautioned from an approach that requires the string to 
        be recorded in a local file because this precludes the use
        of the implementation in an environment where there is no local
        disk and all file access is from an NFSv4.1 server.
      </t>
      <t>
        The string should be the same for each server network address that
        the client accesses.
        This way, if a server has multiple interfaces, the client
        can trunk traffic over multiple network paths
        as described in <xref target="Trunking" />.
        (Note: the precise opposite was advised in the NFSv4.0
        specification <xref target="RFC3530" />.) 
      </t>
      <t>
        The algorithm for generating the string should not
        assume that the client's network address will not
        change, unless the client implementation knows it
        is using statically assigned network addresses.
        This includes changes between client incarnations
        and even changes while the client is still running
        in its current incarnation.  Thus, with dynamic
        address assignment, if the
        client includes just the client's network address
        in the co_ownerid string, there is a real risk
        that after the
        client gives up the network address, another
        client, using a similar algorithm for generating
        the co_ownerid string, would generate a conflicting
        co_ownerid string.

      </t>
    </list>
  </t>
  <t>
    Given the above considerations, an example of a well-generated co_ownerid
    string is one that includes:
  </t>
  <t>
    <list style='symbols'>
      <t>
        If applicable, the client's statically assigned network address.
      </t>
      <t>
        Additional information that tends to be unique, such as one or more
        of:
        <list style='symbols'>
          <t>
            The client machine's serial number (for privacy reasons, it is best
            to perform some one-way function on the serial number).
          </t>
          <t>
            A Media Access Control (MAC) address (again, a one-way function should be performed).
          </t>
          <t>
            The timestamp of when the NFSv4.1 software was first installed
            on the client (though this is subject to the previously mentioned
            caution about using information that is stored in a file, because the
            file might only be accessible over NFSv4.1).
          </t>
          <t>
            A true random number. However, since this number ought to be the same
            between client incarnations, this shares the same problem as that of
            using the timestamp of the software installation.
          </t>
        </list>
      </t>
      <t>
        For a user-level NFSv4.1 client, it should contain additional
        information to distinguish the client from other user-level clients
        running on the same host, such as a process identifier or other unique
        sequence.
      </t>
    </list>
  </t>
  <t>
    The client ID is assigned by the server (the eir_clientid result from EXCHANGE_ID)
    and should be chosen so that it will not
    conflict with a client ID previously assigned by the
    server.  This applies across server restarts.
   </t>
   <t>
    In the event of a server restart, a client may find
    out that its current client ID is no longer valid when
    it receives an NFS4ERR_STALE_CLIENTID error.  The precise
    circumstances depend on the characteristics of the
    sessions involved, specifically whether the session is
    persistent (see <xref target="Persistence" />), but in
    each case the client will receive this error when it attempts
    to establish a new session with the existing client ID and
    receives the error NFS4ERR_STALE_CLIENTID, indicating that a new
    client ID needs to be obtained via EXCHANGE_ID and the new session
    established with that client ID.

  </t>
  <t>
    When a session is not persistent, the client will find out that
    it needs to create a new session as a result of getting an 
    NFS4ERR_BADSESSION, since the session in question was lost
    as part of a server restart.  When the existing client ID is 
    presented to a server as part of creating a session
    and that client ID is not recognized, as would happen after a server
    restart, the server will reject the request with the error
    NFS4ERR_STALE_CLIENTID.  
  </t>
  <t>
    In the case of the session being persistent, the
    client will re-establish communication using the
    existing session after the restart.  This session
    will be associated with the existing client ID but
    may only be used to retransmit operations that the
    client previously transmitted and did not see replies
    to. Replies to operations that the server previously performed
    will come from the reply cache; otherwise,
    NFS4ERR_DEADSESSION will be returned.
    Hence, such a session is referred to as "dead". In this situation,
    in order to perform new operations, the client needs to 
    establish a new session.  If an attempt is made to 
    establish this new session with the existing client ID,
    the server will reject the request with 
    NFS4ERR_STALE_CLIENTID.
  </t>
  <t>
    When NFS4ERR_STALE_CLIENTID is received in either of
    these situations, the client needs to obtain a
    new client ID by use of the EXCHANGE_ID operation, then 
    use that client ID as the basis of a new session, and
    then proceed to
    any other necessary recovery for the server restart case (see 
    <xref target="server_failure" />). 
  </t>
  <t>
    See the descriptions of EXCHANGE_ID 
    (<xref target="OP_EXCHANGE_ID" />) and CREATE_SESSION
    (<xref target="OP_CREATE_SESSION" />) for a complete
    specification of these operations.
  </t>
  <section title="Upgrade from NFSv4.0 to NFSv4.1" >
  <t>
    To facilitate upgrade from NFSv4.0 to NFSv4.1, a server
    may compare a value of data type client_owner4 in an EXCHANGE_ID with a
    value of data type nfs_client_id4 that was established using the SETCLIENTID operation of
    NFSv4.0. A server that does so will allow
    an upgraded client to avoid waiting
    until the lease (i.e., the lease established by the NFSv4.0 instance
    client) expires.
    This requires that the value of data type client_owner4 be constructed
    the same way as the value of data type nfs_client_id4.  If the latter's
    contents included the server's network address (per the
    recommendations of the NFSv4.0 specification <xref target="RFC3530" />), and
    the NFSv4.1 client does not wish to use a client
    ID that prevents trunking, it should send two
    EXCHANGE_ID operations.  The first EXCHANGE_ID will
    have a client_owner4 equal to the nfs_client_id4.
    This will clear the state created by the NFSv4.0
    client. The second EXCHANGE_ID will not have the
    server's network address. The state created for the
    second EXCHANGE_ID will not have to wait for lease
    expiration, because there will be no state to expire.

  </t>
  </section>

   <section title="Server Release of Client ID" >
   <t>
     NFSv4.1 introduces a new operation called 
     DESTROY_CLIENTID (<xref target="OP_DESTROY_CLIENTID" />), 
     which the client SHOULD use to destroy a client ID it
     no longer needs. This permits graceful, bilateral release of
     a client ID. The operation cannot be used if there are sessions
     associated with the client ID, or state with an unexpired lease.
   </t>
   <t>
     If the server determines that the client holds no associated state
     for its client ID (associated state includes unrevoked sessions,
     opens, locks, delegations, layouts, and wants), the server MAY
     choose to unilaterally release the client ID in order to
     conserve resources.

     If the client
     contacts the server after this release, the server
     MUST ensure that the client receives the appropriate error
     so that it will use the EXCHANGE_ID/CREATE_SESSION
     sequence to establish a new client ID.
     The server ought to be very hesitant to
     release a client ID since the resulting work on the
     client to recover from such an event will be the same
     burden as if the server had failed and restarted.
     Typically, a server would not release a client ID
     unless there had been no activity from that client
     for many minutes.  As long as there are sessions,
     opens, locks, delegations, layouts, or wants, the
     server MUST NOT release the client ID. See <xref
     target="loss_of_session" /> for discussion on
     releasing inactive sessions.

   </t>
   </section> <!-- Server Release of Client ID -->
   <section title="Resolving Client Owner Conflicts" anchor="cowner_conflicts">
   <t>
     When the server gets an EXCHANGE_ID for a client owner that
     currently has no state, or that has state but the lease has expired,
     the server MUST allow the
     EXCHANGE_ID and confirm the new client ID if followed by the
     appropriate CREATE_SESSION.
   </t>
   <t>
     When the server gets an EXCHANGE_ID for a 
     new incarnation of a client owner that
     currently has an old incarnation with state and an unexpired lease, the
     server is allowed to dispose of the state of the
     previous incarnation of the client owner if
     one of the following is true:

     <list style="symbols">
     <t>
       The principal that created the client ID for the client owner
       is the same as the principal that is sending the EXCHANGE_ID operation.
       Note that if the client ID was created with
       SP4_MACH_CRED state protection (<xref target="OP_EXCHANGE_ID" />),
       the principal MUST be based on RPCSEC_GSS authentication,
       the RPCSEC_GSS service used MUST be integrity or
       privacy, and the
       same GSS mechanism and principal
       MUST be used as that used when the client ID
       was created.
     </t>
     <t>
       The client ID was established with SP4_SSV
       protection (<xref target="OP_EXCHANGE_ID" />,

    <xref target="protect_state_change" />)

       and the client sends the EXCHANGE_ID with the
       security flavor set to RPCSEC_GSS using the GSS
       SSV mechanism (<xref target="ssv_mech" />).

     </t>
     <t>
       The client ID was established with SP4_SSV
       protection, and under the conditions described herein,
       the EXCHANGE_ID was sent with SP4_MACH_CRED state protection.
       Because the SSV might not persist
       across client and server restart, and because
       the first time a client sends EXCHANGE_ID to
       a server it does not have an SSV, the client
       MAY send the subsequent EXCHANGE_ID without
       an SSV RPCSEC_GSS handle.  Instead, as with
       SP4_MACH_CRED protection, the principal MUST be
       based on RPCSEC_GSS authentication, the RPCSEC_GSS
       service used MUST be integrity or privacy, and the
       same GSS mechanism and principal MUST be used as
       that used when the client ID was created.

     </t>
     </list>
     If none of the above situations apply, the server
     MUST return NFS4ERR_CLID_INUSE.

    </t>
    <t>
     If the server accepts the principal and co_ownerid
     as matching that which created the client ID, and
     the co_verifier in the EXCHANGE_ID differs from the
     co_verifier used when the client ID was created,
     then after the server receives a CREATE_SESSION that
     confirms the client ID, the server deletes state.

     If the co_verifier values are the same (e.g., the
     client either is updating properties of the client ID
     (<xref target="OP_EXCHANGE_ID" />) or
     is attempting trunking (<xref target="Trunking" />),
     the server MUST NOT delete state.

   </t>

   </section> <!-- Handling Client Owner Conflicts -->
 </section> <!-- Client Identifiers -->
 <section anchor="Server Owners" title="Server Owners">
 <t>
  The server owner is similar to a client owner
  (<xref target="Client Identifiers" />), but unlike the
  client owner, there is no shorthand server ID.
  The server owner is defined in the following data type:
  </t>
  <t>
<figure>
 <artwork>
struct server_owner4 {
 uint64_t       so_minor_id;
 opaque         so_major_id&lt;NFS4_OPAQUE_LIMIT>;
};
 </artwork>
</figure>
  </t>
  <t>
   The server owner is returned from
   EXCHANGE_ID. When the so_major_id fields are the same in
   two EXCHANGE_ID results, the connections that each EXCHANGE_ID
   were sent over can be assumed to address the same server
   (as defined in <xref target="intro_definitions" />). If
   the so_minor_id fields are also the same, then not only
   do both connections connect to the same server, but the
   session can be shared across both
   connections. The reader is cautioned that multiple
   servers may deliberately or accidentally claim to have
   the same so_major_id or so_major_id/so_minor_id; the
   reader should examine Sections <xref target="Trunking" format="counter" /> and
   <xref target="OP_EXCHANGE_ID" format="counter" /> in order to avoid
   acting on falsely matching server owner values.
  </t>
  <t>
   The considerations for generating a so_major_id are
   similar to that for generating a co_ownerid string (see
   <xref target="Client Identifiers" />). The consequences
   of two servers generating conflicting so_major_id values
   are less dire than they are for co_ownerid conflicts
   because the client can use RPCSEC_GSS to compare the
   authenticity of each server
   (see <xref target="Trunking" />).
  </t>
 </section> <!-- Server Owners -->

 <section anchor="Security Service Negotiation" title="Security Service Negotiation">
 <t>
    With the NFSv4.1 server potentially offering
    multiple security mechanisms, the client needs a method
    to determine or negotiate which mechanism is to be
    used for its communication with the server.  The NFS
    server may have multiple points within its file system
    namespace that are available for use by NFS clients.
    These points can be considered security policy boundaries,
    and, in some NFS implementations, are tied to NFS export points.
    In turn, the NFS server may be configured such that each
    of these security policy boundaries may have different or multiple
    security mechanisms in use.
 </t>
 <t>
    The security negotiation between client and server
    SHOULD be done with a secure channel to eliminate
    the possibility of a third party intercepting the
    negotiation sequence and forcing the client and server
    to choose a lower level of security than required or
    desired.  See 
    <xref target="securityconsider" /> for further discussion.
 </t>

  <section anchor="NFSv4 Security Tuples" title="NFSv4.1 Security Tuples">
  <t>
   An NFS server can assign one or more "security tuples" to each
   security policy boundary in its namespace. Each security tuple
   consists of a security flavor
   (see <xref target="RPC Security Flavors" />) and, if the flavor
   is RPCSEC_GSS, a GSS-API mechanism Object Identifier (OID), a GSS-API quality of
   protection, and an RPCSEC_GSS service. 
  </t>
  </section> <!-- NFSv4.1 Security Tuples -->

  <section anchor="SECINFO and SECINFO_NO_NAME" title="SECINFO and SECINFO_NO_NAME">
  <t>
   The SECINFO and SECINFO_NO_NAME operations allow the client to
   determine, on a per-filehandle basis, what security tuple is to be
   used for server access.  In general, the client will not have to
   use either operation except during initial communication with the
   server or when the client crosses security policy boundaries at the
   server.  However, the server's policies may also change at any time
   and force the client to negotiate a new security tuple.
  </t>
  <t>
   Where the use of different security tuples would affect the type of
   access that would be allowed if a request was sent over the same
   connection used for the SECINFO or SECINFO_NO_NAME operation
   (e.g., read-only vs. read-write) access, security tuples that allow
   greater access should be presented first.  Where the general level
   of access is the same and different security flavors limit the
   range of principals whose privileges are recognized (e.g., allowing
   or disallowing root access), flavors supporting the greatest range
   of principals should be listed first.
  </t>
  </section> <!-- SECINFO and SECINFO_NO_NAME -->

  <section anchor="Security Error" title="Security Error">
  <t>
   Based on the assumption that each NFSv4.1 client
   and server MUST support a minimum set of security (i.e.,
   Kerberos V5 under RPCSEC_GSS),
   the NFS client will initiate file access to the server
   with one of the minimal security tuples.  During
   communication with the server, the client may receive an
   NFS error of NFS4ERR_WRONGSEC.  This error allows the
   server to notify the client that the security tuple
   currently being used contravenes the server's
   security policy. The client is then responsible for
   determining (see <xref target="using_secinfo" />) what
   security tuples are available at the server and choosing
   one that is appropriate for the client.

  </t>

  <section anchor="using_secinfo" title="Using NFS4ERR_WRONGSEC, SECINFO, and SECINFO_NO_NAME">
  <t>
   This section explains the mechanics of NFSv4.1 security negotiation.
  </t>

  <section anchor="putfh_series" title="Put Filehandle Operations">

  <t>

   The term "put filehandle operation" refers to
   PUTROOTFH, PUTPUBFH, PUTFH, and RESTOREFH. Each of the subsections
   herein describes how the server handles a subseries of operations
   that starts with a put filehandle operation.
  </t>

   <section anchor="PUTFH + SAVEFH"
    title="Put Filehandle Operation + SAVEFH">
   <t>
    The client is saving a filehandle for a future
    RESTOREFH, LINK, or RENAME.  SAVEFH MUST NOT
    return NFS4ERR_WRONGSEC. To determine whether or not the put
    filehandle operation returns NFS4ERR_WRONGSEC,
    the server implementation pretends SAVEFH is not in
    the series of operations and examines which of the
    situations described in the other subsections of <xref
    target="putfh_series"/> apply.

   </t>
   </section> <!-- Put Filehandle Operation + SAVEFH -->
   <section anchor="PUTFH + PUTFH"
    title="Two or More Put Filehandle Operations">
   <t>
    For a series of N put filehandle operations, the server
    MUST NOT return NFS4ERR_WRONGSEC to the first N-1 put
    filehandle operations. 

The Nth put filehandle operation
    is handled as if it is the first in a subseries of
    operations.
    For example, if the
    server received a COMPOUND request with this series of
    operations -- PUTFH, PUTROOTFH, LOOKUP -- then the
    PUTFH operation is ignored for NFS4ERR_WRONGSEC purposes, and the
    PUTROOTFH, LOOKUP subseries is processed as according
    to <xref target="PUTFH + LOOKUP"/>.
   </t>
   </section> <!-- PUTFH + PUTFH -->
   <section anchor="PUTFH + LOOKUP"
    title="Put Filehandle Operation + LOOKUP (or OPEN of an Existing Name)">
   <t>
    This situation also applies to a put filehandle operation followed
    by a LOOKUP or an OPEN operation that specifies an existing component name.
   </t>
   <t>
    In this situation, the client is potentially crossing
    a security policy boundary, and the set of security tuples
    the parent directory supports may differ from those of
    the child.
    The server implementation may decide whether to impose
    any restrictions on security policy administration.
    There are at least three approaches (sec_policy_child is
    the tuple set of the child export, sec_policy_parent is
    that of the parent).
   </t>
   <t>
   <list style="format (%c)">
   <t>
    sec_policy_child &lt;= sec_policy_parent (&lt;= for subset).
    This means that the set of security tuples specified on the
    security policy of a child directory is always a subset
    of its parent directory.
   </t>
   <t>
    sec_policy_child ^ sec_policy_parent != {} (^ for intersection, {}
    for the empty set). This means that the set of security tuples specified
    on the security policy of a child directory always has a non-empty intersection
    with that of the parent.
   </t>
   <t>
    sec_policy_child ^ sec_policy_parent == {}. This means that the
    set of security tuples specified on the security policy of a child directory
    may not intersect with that of the parent. In other words, there
    are no restrictions on how the system administrator may
    set up these tuples.
   </t>
   </list>
   </t>
   <t>
    In order for a server to support approaches (b)
    (for the case when a client chooses a flavor that is
    not a member of sec_policy_parent) and (c), the put
    filehandle operation cannot return NFS4ERR_WRONGSEC
    when there is a security tuple mismatch.  Instead,
    it should be returned from the LOOKUP (or OPEN by
    existing component name) that follows.

   </t>
   <t>
    Since the above guideline does not contradict approach
    (a), it should be followed in general. Even if approach
    (a) is implemented, it is possible for the security
    tuple used to be acceptable for the target of LOOKUP
    but not for the filehandles used in the put filehandle operation. The 
    put filehandle operation
    could be a PUTROOTFH or PUTPUBFH, where the
    client cannot know the security tuples for the root
    or public filehandle. Or the security policy for the
    filehandle used by the put filehandle operation
    could have changed since the
    time the filehandle was obtained.
   </t>
   <t>
    Therefore, an NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC
    in response to the put filehandle operation
    if the operation
    is immediately followed by a LOOKUP or an OPEN by component name.
   </t>
   </section> <!-- PUTFH + LOOKUP -->

   <section anchor="PUTFH + LOOKUPP" title="Put Filehandle Operation + LOOKUPP">
   <t>
    Since SECINFO only works its way down, there is no way LOOKUPP can
    return NFS4ERR_WRONGSEC without SECINFO_NO_NAME. SECINFO_NO_NAME
    solves this issue via style
    SECINFO_STYLE4_PARENT, which works in the opposite direction as SECINFO.
    As with <xref target="PUTFH + LOOKUP" />, a put filehandle operation
    that is followed by a LOOKUPP
    MUST NOT return NFS4ERR_WRONGSEC.
    If the server does not support SECINFO_NO_NAME, the client's
    only recourse is to send the put filehandle operation,
    LOOKUPP, GETFH sequence
    of operations with every security tuple it supports.
   </t>
   <t>
    Regardless of whether SECINFO_NO_NAME is supported, an
    NFSv4.1 server  MUST NOT return NFS4ERR_WRONGSEC in
    response to a put filehandle operation if the
    operation is immediately followed by a LOOKUPP.
   </t>
   </section> <!-- PUTFH + LOOKUPP -->

   <section title="Put Filehandle Operation + SECINFO/SECINFO_NO_NAME"
    anchor="PUTFH+SECINFO">
   <t>
    A security-sensitive client is allowed to choose
    a strong security tuple when querying a server to
    determine a file object's permitted security tuples.
    The security tuple chosen by the client does not have
    to be included in the tuple list of the security policy
    of either the parent directory indicated in the put filehandle
    operation or the child file object indicated in SECINFO (or any parent directory
    indicated in SECINFO_NO_NAME). Of course, the server has to be
    configured for whatever security
    tuple the client selects; otherwise, the request will
    fail at the RPC layer with an appropriate authentication error.
   </t>
   <t>
    In theory, there is no connection between the security
    flavor used by SECINFO or SECINFO_NO_NAME and those
    supported by the security policy.  But in practice, the
    client may start looking for strong flavors from those
    supported by the security policy, followed by those in
    the REQUIRED set.
   </t>
   <t>
    The NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC to a
    put filehandle operation that
    is immediately followed by SECINFO or SECINFO_NO_NAME.
    The NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC from SECINFO or
    SECINFO_NO_NAME.
   </t>
   </section> <!-- PUTFH + SECINFO -->

   <section anchor="PUTFH + Nothing" title="Put Filehandle Operation + Nothing">
   <t>
    The NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC.
   </t>
   </section> <!-- PUTFH + Nothing -->

   <section anchor="PUTFH+AnythingElse" title="Put Filehandle Operation + Anything Else">
   <t>
    "Anything Else" includes OPEN by filehandle.
   </t>
   <t>
    The security policy enforcement applies to the
    filehandle specified in the put filehandle operation. Therefore, the
    put filehandle operation MUST
    return NFS4ERR_WRONGSEC when there is a security tuple
    mismatch. This avoids the complexity of
    adding NFS4ERR_WRONGSEC as an allowable error to every
    other operation.
   </t>
   <t>
    A COMPOUND containing the series put filehandle
    operation + SECINFO_NO_NAME (style SECINFO_STYLE4_CURRENT_FH) is an
    efficient way for the client to recover from
    NFS4ERR_WRONGSEC.
   </t>
   <t>
    The NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC to
    any operation other than a put filehandle operation,
    LOOKUP, LOOKUPP, and OPEN (by component name).
   </t>
   </section> <!-- PUTFH + Anything Else -->

   <section anchor="aftersecinfo" title="Operations after SECINFO and SECINFO_NO_NAME">
   <t>

     Suppose a client sends a COMPOUND procedure
     containing the series SEQUENCE, PUTFH,
     SECINFO_NONAME, READ, and suppose the security tuple
     used does not match that required for the target
     file. By rule (see <xref target="PUTFH+SECINFO"/>),
     neither PUTFH nor SECINFO_NO_NAME can
     return NFS4ERR_WRONGSEC. By rule (see <xref
     target="PUTFH+AnythingElse"/>), READ cannot return
     NFS4ERR_WRONGSEC. The issue is resolved by the fact
     that SECINFO and SECINFO_NO_NAME consume the current
     filehandle (note that this is a change from NFSv4.0). This leaves no current filehandle for
     READ to use, and READ returns NFS4ERR_NOFILEHANDLE.

   </t>

   </section> <!-- Operations after SECINFO and SECINFO_NO_NAME" -->


  </section>
  <section anchor="link_rename" title="LINK and RENAME" >
  <t>
   The LINK and RENAME operations use both the current
   and saved filehandles.
   Technically, the server MAY return NFS4ERR_WRONGSEC from
   LINK or RENAME
   if the security policy of the
   saved filehandle rejects the security flavor used in the
   COMPOUND request's credentials.  If the server does so,
   then if there is no intersection between the security
   policies of saved and current filehandles, this means that it
   will be impossible for the client to perform the intended
   LINK or RENAME operation.

  </t>
  <t>
   For example, suppose the client sends this COMPOUND
   request: SEQUENCE, PUTFH bFH, SAVEFH, PUTFH aFH,
   RENAME "c" "d", where filehandles bFH and aFH refer
   to different directories.  Suppose no common security
   tuple exists between the security policies of aFH and
   bFH. If the client sends the request using credentials
   acceptable to bFH's security policy but not aFH's
   policy, then the PUTFH aFH operation will fail with
   NFS4ERR_WRONGSEC. After a SECINFO_NO_NAME request,
   the client sends SEQUENCE, PUTFH bFH, SAVEFH, PUTFH
   aFH, RENAME "c" "d", using credentials acceptable to
   aFH's security policy but not bFH's policy. The server
   returns NFS4ERR_WRONGSEC on the RENAME operation.

  </t>
  <t>
   To prevent a client from an endless sequence of a
   request containing LINK or RENAME, followed by a request
   containing SECINFO_NO_NAME or SECINFO, the server MUST detect
   when the security policies of the current and saved
   filehandles have no mutually acceptable security tuple,
   and MUST NOT return NFS4ERR_WRONGSEC from LINK or RENAME
   in that situation. Instead
   the server MUST do one of two things:
   <list style='symbols'>

   <t>
    The server can return NFS4ERR_XDEV.
   </t>

   <t>
    The server can 
    allow the security policy of the current filehandle to
    override that of the saved filehandle, and so return NFS4_OK.
   </t>

   </list>

  </t>
  </section>

  </section> <!-- Using NFS4ERR_WRONGSEC, SECINFO, and SECINFO_NO_NAME -->
 </section> <!-- Security Error -->
 </section> <!-- Security Service Negotiation -->

 <section anchor="minor_versioning" title="Minor Versioning">
 <t>
  To address the requirement of an NFS protocol that can evolve as the
  need arises, the NFSv4.1 protocol contains the rules and
  framework to allow for future minor changes or versioning.
 </t>
 <t>
  The base assumption with respect to minor versioning is that any
  future accepted minor version will be
  documented in one or more Standards Track RFCs.
  Minor version 0 of the NFSv4 protocol is represented by
  <xref target="RFC3530" />, and minor version 1 is represented by
  this RFC.
  The COMPOUND and CB_COMPOUND
  procedures support the encoding of the minor version
  being requested by the client.
 </t>
 <t>
  The following items represent the basic rules for the development of
  minor versions.  Note that a future minor version may modify
  or add to the following rules as part of the minor version definition.
 <list style='numbers'>
 <t>
  Procedures are not added or deleted.
  <vspace blankLines='1' />
  To maintain the general RPC model, NFSv4 minor versions will
  not add to or delete procedures from the NFS program.
 </t>

 <t>
  Minor versions may add operations to the COMPOUND and CB_COMPOUND
  procedures.
  <vspace blankLines='1' />
  The addition of operations to the COMPOUND and CB_COMPOUND procedures
  does not affect the RPC model.

  <list style='symbols'>
  <t>
  Minor versions may append attributes to the bitmap4 that represents
  sets of attributes and to the fattr4 that represents sets of attribute 
  values.
  <vspace blankLines='1' />
  This allows for the expansion of the attribute model to allow for
  future growth or adaptation.
  </t>

  <t>
  Minor version X must append any new attributes after the last
  documented attribute.
  <vspace blankLines='1' />
  Since attribute results are specified as an opaque array of
  per-attribute, XDR-encoded results, the complexity of adding new
  attributes in the midst of the current definitions would be too
  burdensome.
  </t>
  </list>
 </t>

 <t>
 Minor versions must not modify the structure of an existing
 operation's arguments or results.
 <vspace blankLines='1' />
 Again, the complexity of handling multiple structure definitions for a
 single operation is too burdensome.  New operations should be added
 instead of modifying existing structures for a minor version.
 <vspace blankLines='1' />
 This rule does not preclude the following adaptations in a minor version:
 <list style='symbols'>
 <t>
 adding bits to flag fields, such as new attributes to GETATTR's bitmap4
 data type, and providing corresponding variants of opaque arrays,
 such as a notify4 used together with such bitmaps
 </t>
 <t>
 adding bits to existing attributes like ACLs that have flag words
 </t>
 <t>
 extending enumerated types (including NFS4ERR_*) with new values
 </t>
 <t>
 adding cases to a switched union
 </t>
 </list>
 </t>

 <t>
 Minor versions must not modify the structure of existing attributes.
 </t>

 <t>
 Minor versions must not delete operations.
 <vspace blankLines='1' />
 This prevents the potential reuse of a particular operation "slot" in
 a future minor version.
 </t>

 <t>
 Minor versions must not delete attributes.
 </t>

 <t>
 Minor versions must not delete flag bits or enumeration values.
 </t>

 <t>
 Minor versions may declare an operation MUST NOT be implemented.
 <vspace blankLines='1' />
 Specifying that an operation MUST NOT be implemented is equivalent
 to obsoleting an operation.  For the client, it means that the
 operation MUST NOT be sent to the server.  For the server, an NFS
 error can be returned as opposed to "dropping" the request as an XDR
 decode error.  This approach allows for the obsolescence of an
 operation while maintaining its structure so that a future minor version can reintroduce the operation.
 <list style='numbers'>
 <t>
 Minor versions may declare that an attribute MUST NOT be implemented.
 </t>
 <t>
 Minor versions may declare that a flag bit or enumeration value MUST NOT
 be implemented.
 </t>
 </list>
 </t>

 <t>
 Minor versions may downgrade features from REQUIRED to RECOMMENDED,
 or RECOMMENDED to OPTIONAL.
 </t>

 <t>
 Minor versions may upgrade features from OPTIONAL to RECOMMENDED, or
 RECOMMENDED to REQUIRED.
 </t>

 <t>
 A client and server that support minor version X SHOULD support minor
 versions zero through X-1 as well.

 </t>

 <t>
 Except for infrastructural changes, a minor version must not
 introduce REQUIRED new features.
 <vspace blankLines='1' />
 This rule allows for the introduction of new functionality and forces
 the use of implementation experience before designating a feature as
 REQUIRED. On the other hand, some classes of features are
 infrastructural and have broad effects. Allowing infrastructural features
 to be RECOMMENDED or OPTIONAL complicates implementation of the minor version.
 </t>

 <t>
 A client MUST NOT attempt to use a stateid, filehandle, or similar
 returned object from the COMPOUND procedure with minor version X for
 another COMPOUND procedure with minor version Y, where X != Y.
 </t>
 </list>
 </t>
 </section> <!-- Minor Versioning -->

 <section anchor="Non-RPC-based Security Services" title="Non-RPC-Based Security Services">
 <t>
  As described in
  <xref target="Authentication, Integrity, Privacy" />,
  NFSv4.1 relies on RPC for identification,
  authentication, integrity, and privacy. NFSv4.1 itself
  provides or enables additional security services as described in the
  next several subsections.
 </t>

  <section anchor="Authorization" title="Authorization">
  <t>
   Authorization to access a file object via an NFSv4.1
   operation is ultimately determined by the NFSv4.1
   server. A client can predetermine its access to a file
   object via the OPEN (<xref target="OP_OPEN" />)
   and the ACCESS (<xref target="OP_ACCESS" />)
   operations.
  </t>
  <t>
   Principals with appropriate access rights can modify the
   authorization on a file object via the SETATTR
   (<xref target="OP_SETATTR" />) operation.  Attributes that affect
   access rights include mode, owner, owner_group, acl, dacl, and
   sacl. See <xref target="file_attributes" />.
   </t>
  </section> <!-- Authorization -->

  <section anchor="Auditing" title="Auditing">
  <t>
   NFSv4.1 provides auditing on a per-file object basis, via the acl
   and sacl attributes as described in <xref target="acl" />.  It is
   outside the scope of this specification to specify audit log
   formats or management policies.
  </t>
  </section> <!-- Auditing -->

  <section anchor="Intrusion Detection" title="Intrusion Detection">
  <t>
   NFSv4.1 provides alarm control on a per-file object basis, via the
   acl and sacl attributes as described in <xref target="acl" />.
   Alarms may serve as the basis for intrusion detection.  It is
   outside the scope of this specification to specify heuristics for
   detecting intrusion via alarms.
  </t>
  </section> <!-- Intrusion Detection -->
 </section> <!-- Non-RPC-based Security Services -->

 <section anchor="Transport Layers" title="Transport Layers">

  <section anchor="Required and Recommended Transport Attributes"
   title="REQUIRED and RECOMMENDED Properties of Transports">
  <t>
   NFSv4.1 works over Remote Direct Memory Access (RDMA) and non-RDMA-based transports with
   the following attributes: 
   <list style='symbols'>
   <t>
    The transport supports reliable delivery of data, which
    NFSv4.1 requires but neither NFSv4.1 nor RPC has facilities
    for ensuring  <xref target="Chet" />.
   </t>
   <t>
    The transport delivers data in the order it was sent.
    Ordered delivery simplifies detection of transmit
    errors, and simplifies the sending of arbitrary sized
    requests and responses via the record marking
    protocol <xref target="RFC5531" />.
   </t>
   </list>
  </t>
  <t>
   Where an NFSv4.1 implementation supports operation
   over the IP network protocol, any transport used between
   NFS and IP MUST be among the IETF-approved congestion
   control transport protocols.  At the time this document
   was written, the only two transports that had the above
   attributes were TCP and the Stream
   Control Transmission Protocol (SCTP).  To enhance the
   possibilities for interoperability, an NFSv4.1
   implementation MUST support operation over the TCP
   transport protocol.
  </t>
  <t>
   Even if NFSv4.1 is used over a non-IP network
   protocol, it is RECOMMENDED that the transport support
   congestion control.
  </t>
  <t>
   It is permissible for a connectionless transport to
   be used under NFSv4.1; however, reliable and in-order
   delivery of data combined with congestion control
   by the connectionless transport is
   REQUIRED.  As a consequence, UDP by itself MUST NOT be used
   as an NFSv4.1 transport. NFSv4.1 assumes that a client transport
   address and server transport address used to send data
   over a transport together constitute a connection,
   even if the underlying transport eschews the concept
   of a connection.

  </t>
  </section> <!-- Required and Recommended Transport Attributes -->

  <section anchor="Client and Server Transport Behavior" title="Client and Server Transport Behavior">
  <t>
   If a connection-oriented transport (e.g., TCP) is used,
   the client and server SHOULD use long-lived connections
   for at least three reasons:
   <list style='numbers'>
   <t>
    This will prevent the weakening of the transport's
    congestion control mechanisms via short-lived
    connections.
   </t>
   <t>
    This will improve performance for the WAN environment
    by eliminating the need for connection setup
    handshakes.
   </t>
   <t>
    The NFSv4.1 callback model differs from NFSv4.0, and
    requires the client and server to maintain a
    client-created backchannel (see <xref target="conn_chann_assoc" />) for the server to use.
   </t>
   </list>
  </t>
  <t>
   In order to reduce congestion, if a connection-oriented
   transport is used, and the request is not the NULL
   procedure:
   <list style='symbols'>
   <t>
    A requester MUST
    NOT retry a request unless the connection the request
    was sent over was lost before the reply was
    received.
   </t>
   <t>
    A replier MUST
    NOT silently drop a request, even if the request is a
    retry.  (The silent drop behavior of RPCSEC_GSS
    <xref target="RFC2203" /> does not apply
    because this behavior happens at the RPCSEC_GSS layer,
    a lower layer in the request processing.)  Instead, the
    replier SHOULD return an appropriate error (see
    <xref target="Slot Identifiers and Server Reply Cache" />),
    or it MAY disconnect the connection.
   </t>
   </list>
  </t>


  <t>

    When sending a reply, the replier MUST send the reply
    to the same full network address (e.g., if using an
    IP-based transport, the source port of the requester
    is part of the full network address) from which the requester
    sent the request. If using a connection-oriented
    transport, replies MUST be sent on the same connection from which
    the request was received.

  </t>

  <t>

    If a connection is dropped after the replier receives
    the request but before the replier sends the reply, the
    replier might have a pending reply.
    If a connection is established with the same
    source and destination full network address as the
    dropped connection, then the replier MUST NOT send
    the reply until the requester retries the request. The
    reason for this prohibition is that the requester MAY
    retry a request over a different connection (provided that connection
    is associated with the original request's session).

   </t>


  <t>
   When using RDMA transports, there are other reasons for not
   tolerating retries over the same connection:
   <list style='symbols'>
    <t>
     RDMA transports use "credits" to enforce flow control, where
     a credit is a right to a peer to transmit a message.
     If one peer were to retransmit a request (or reply), it would
     consume an additional credit.
     If the replier
     retransmitted a reply, it would certainly result in an RDMA
     connection loss, since the requester would typically only post a
     single receive buffer for each request.  If the requester
     retransmitted a request, the additional credit consumed on the
     server might lead to RDMA connection failure unless the client
     accounted for it and decreased its available credit, leading to
     wasted resources.
    </t>
    <t>
     RDMA credits present a new issue to the reply cache in
     NFSv4.1.  The reply cache may be used when a connection within a
     session is lost, such as after the client reconnects.  Credit
     information is a dynamic property of the RDMA connection, and stale
     values must not be replayed from the cache.  This implies that the
     reply cache contents must not be blindly used when replies are
     sent from it, and credit information appropriate to the channel
     must be refreshed by the RPC layer.
    </t>
   </list>
  </t>
  <t>
   In addition, as described in
   <xref target="Retry and Replay" />, while a session is active,
   the NFSv4.1 requester MUST NOT stop waiting for a reply.
  </t>
  </section> <!-- Client and Server Transport Behavior -->

  <section anchor="Ports" title="Ports">
  <t>
   Historically, NFSv3 servers have listened over
   TCP port 2049.  The registered port 2049 <xref target="RFC3232"/>
   for the NFS protocol should be the default configuration.  NFSv4.1
   clients SHOULD NOT use the RPC binding protocols as described in
   <xref target="RFC1833"/>.
  </t>
  </section> <!-- Ports -->

 </section> <!-- Transport Layers -->

 <section anchor="Session" title="Session">
  <t>
   NFSv4.1 clients and servers MUST support and MUST use the session
   feature as described in this section.

  </t>

  <section anchor="Motivation and Overview" title="Motivation and Overview">
  <t>
   Previous versions and minor versions of NFS have suffered from
   the following:
   <list style='symbols'>
   <t>
    Lack of support for Exactly Once Semantics (EOS). This includes
    lack of support for EOS through server failure and recovery.
   </t>
   <t>
    Limited callback support, including no support for sending callbacks
    through firewalls, and races between replies to normal requests
    and callbacks.
   </t>
   <t>
    Limited trunking over multiple network paths.
   </t>
   <t>
    Requiring machine credentials for fully secure operation.
   </t>
   </list>
   Through the introduction of a session, NFSv4.1 addresses the
   above shortfalls with practical solutions:
   <list style='symbols'>
   <t>
    EOS is enabled by a reply cache with a bounded size,
    making it feasible to keep the cache in persistent storage and enable
    EOS through server failure and recovery. One reason that
    previous revisions of NFS did not support EOS was
    because some EOS approaches often limited parallelism.
    As will be explained in
    <xref target="Exactly Once Semantics" />,
    NFSv4.1 supports both EOS and unlimited parallelism.
   </t>
   <t>
    The NFSv4.1 client (defined in <xref target="intro_definitions" />,
    <xref target="client_def"/>) creates transport
    connections and provides them to the server to use for sending
    callback requests, thus solving the firewall issue
    (<xref target="OP_BIND_CONN_TO_SESSION" />). Races between
    responses from client requests and callbacks caused by
    the requests are detected via the session's sequencing
    properties that are a consequence of EOS
    (<xref target="sessions_callback_races" />).
   </t>
   <t>
    The NFSv4.1 client can associate an arbitrary number of connections with
    the session, and thus provide trunking (<xref target="Trunking" />).
   </t>
   <t>
    The NFSv4.1 client and server produces a session key independent of client
    and server machine credentials which can be
    used to compute a digest for protecting critical session management operations
    (<xref target="protect_state_change" />).
   </t>
   <t>
    The NFSv4.1 client can also create secure RPCSEC_GSS contexts
    for use by the session's backchannel that do not require
    the server to authenticate to a client machine principal
    (<xref target="Backchannel RPC Security" />).
   </t>
   </list>
  </t>
  <t>
   A session is a dynamically created, long-lived server object
   created by a client and used over time from one or more transport
   connections.  Its function is to maintain the server's state
   relative to the connection(s) belonging to a client instance.  This
   state is entirely independent of the connection itself, and indeed
   the state exists whether or not the connection exists. A client may
   have one or more sessions associated with it so that
   client-associated state may be accessed using any of the sessions
   associated with that client's client ID, when connections are
   associated with those sessions. When no connections are associated
   with any of a client ID's sessions for an extended time, such
   objects as locks, opens, delegations, layouts, etc. are subject to
   expiration.  The session serves as an object representing a means
   of access by a client to the associated client state on the server,
   independent of the physical means of access to that state.
  </t>
  <t>
   A single client may create multiple sessions. A single session MUST
   NOT serve multiple clients.
  </t>
  </section> <!-- Motivation and Overview -->

  <section anchor="NFSv4 Integration" title="NFSv4 Integration">
  <t>
   Sessions are part of NFSv4.1 and not NFSv4.0. Normally, a major
   infrastructure change such as sessions would require a new major
   version number to an Open Network Computing (ONC) RPC program like
   NFS. However, because NFSv4 encapsulates its functionality in a single procedure, COMPOUND,
   and because COMPOUND can support an arbitrary number of
   operations, sessions have been added to NFSv4.1 with little difficulty. COMPOUND includes
   a minor version number field, and for NFSv4.1 this minor version
   is set to 1. When the NFSv4 server processes a COMPOUND with 
   the minor version set to 1, it expects a different set of
   operations than it does for NFSv4.0. NFSv4.1 defines the
   SEQUENCE operation, which is required for every
   COMPOUND that operates over an established session, with the
   exception of some session administration operations, such
   as DESTROY_SESSION (<xref target="OP_DESTROY_SESSION" />).
  </t>

   <section anchor="SEQUENCE and CB_SEQUENCE" title="SEQUENCE and CB_SEQUENCE">
    <t>
     In NFSv4.1, when the SEQUENCE operation is present, it MUST be
     the first operation in the COMPOUND procedure. The primary purpose
     of SEQUENCE is to carry the session identifier. The session identifier
     associates all other operations in the COMPOUND procedure with
     a particular session. SEQUENCE also contains required information
     for maintaining EOS (see <xref target="Exactly Once Semantics" />).
     Session-enabled NFSv4.1 COMPOUND requests thus have the form:
    </t>
    <figure>
    <artwork>
    +-----+--------------+-----------+------------+-----------+----
    | tag | minorversion | numops    |SEQUENCE op | op + args | ...
    |     |   (== 1)     | (limited) |  + args    |           |
    +-----+--------------+-----------+------------+-----------+----
    </artwork>
    </figure>

    <t>
    and the replies have the form:
    </t>

    <figure>
    <artwork>
    +------------+-----+--------+-------------------------------+--//
    |last status | tag | numres |status + SEQUENCE op + results |  //
    +------------+-----+--------+-------------------------------+--//
            //-----------------------+----
            // status + op + results | ...
            //-----------------------+----
    </artwork>
    </figure>
    <t>
     A CB_COMPOUND procedure request and reply has a similar form to
     COMPOUND, but
     instead of a SEQUENCE operation, there is a CB_SEQUENCE operation.
     CB_COMPOUND also has an additional field called "callback_ident", which
     is superfluous in NFSv4.1 and MUST be ignored by
     the client. CB_SEQUENCE has the same information
     as SEQUENCE, and also includes other information needed to resolve
     callback races
    (<xref target="sessions_callback_races" />).
    </t>
   </section> <!-- SEQUENCE and CB_SEQUENCE -->

   <section anchor="Client ID and Session Association" title="Client ID and Session Association">
   <t>
    Each client ID (<xref target="Client Identifiers" />) can have
    zero or more active sessions. A client ID and associated
    session are required to perform file access in 
    NFSv4.1. Each time a session is used (whether by a client sending
    a request to the server or the client replying to a callback
    request from the server), the state leased to its associated
    client ID is automatically renewed.

   </t>
   <t>
    State (which can consist of share reservations, locks, delegations,
    and layouts (<xref target="intro_locking" />)) is tied to
    the client ID. Client state is not tied to any individual session.
    Successive state changing operations from a given state
    owner MAY go over different sessions, provided the
    session is associated with the same client ID. A callback
    MAY arrive over a different session than that of the request
    that originally acquired the state pertaining to the
    callback. For example, if session A is used to
    acquire a delegation, a request to recall the
    delegation MAY arrive over session B if both sessions are
    associated with the same client ID. Sections
    <xref target="Session Callback Security" format="counter"/> and
    <xref target="Backchannel RPC Security" format="counter"/> discuss
    the security considerations around callbacks.
   </t>
    
   </section> <!-- Client ID and Session Association -->
  </section> <!-- NFSv4 Integration -->

  <section anchor="Channels" title="Channels">
  <t>
   A channel is not a connection. A channel represents the
   direction ONC RPC requests are sent.
  </t>
  <t>
   Each session has one or two channels: the fore channel and the backchannel.
   Because there are at most two channels per session, and because each
   channel has a distinct purpose, channels are not assigned
   identifiers.
  </t>
  <t>
   The fore channel is
   used for ordinary requests from the client to the server, and
   carries COMPOUND requests and responses.
   A session always has a fore channel.
  </t>
  <t>
   The backchannel is used for callback requests from server
   to client, and carries CB_COMPOUND requests and responses.
   Whether or not there is a backchannel is a decision made by the
   client; however, many features of NFSv4.1 require a backchannel.
   NFSv4.1 servers MUST support backchannels.
  </t>
  <t>
   Each session has resources for each channel,
   including separate reply caches (see
   <xref target="Slot Identifiers and Server Reply Cache" />).

   Note that even the backchannel requires a reply cache (or, at least,
   a slot table in order to detect retries) because
   some callback operations are nonidempotent.
  </t>

   <section anchor="conn_chann_assoc" title="Association of Connections, Channels, and Sessions"> 
   <t>
    Each channel is associated with zero or more transport
    connections (whether of the same transport protocol or different
    transport protocols).  A connection can be associated with
    one channel or both channels of a session; the client
    and server negotiate whether a connection will carry
    traffic for one channel or both channels via the
    CREATE_SESSION (<xref target="OP_CREATE_SESSION"
    />) and the BIND_CONN_TO_SESSION (<xref
    target="OP_BIND_CONN_TO_SESSION" />) operations. When a
    session is created via CREATE_SESSION, the connection
    that transported the CREATE_SESSION request is
    automatically associated with the fore channel, and
    optionally the backchannel. If the client specifies no
    state protection (<xref target="OP_EXCHANGE_ID" />)
    when the session is created, then when SEQUENCE is
    transmitted on a different connection, the connection
    is automatically associated with the fore channel of
    the session specified in the SEQUENCE operation.

   </t>
   <t>
    A connection's association with a session is
    not exclusive.  A connection associated with the channel(s)
    of one session may be simultaneously
    associated with the channel(s) of other sessions including
    sessions associated with other client IDs.

   </t>
   <t>
    It is permissible for connections of multiple transport
    types to be associated with the same channel. For
    example, both TCP and RDMA connections can be
    associated with the fore channel.  In the event an
    RDMA and non-RDMA connection are associated with the
    same channel, the maximum number of slots SHOULD be
    at least one more than the total number of RDMA credits
    (<xref target="Slot Identifiers and Server Reply Cache" />).
   This way, if all RDMA credits are used, the non-RDMA
   connection can have at least one outstanding request.
   If a server supports multiple transport types, it MUST
   allow a client to associate connections from each transport
   to a channel.

   </t>
   <t>
    It is permissible for a connection of one type of
    transport to be associated with the fore channel,
    and a connection of a different type to be associated
    with the backchannel.

   </t>
   </section>
  </section> <!-- Channels -->
  <section anchor="Server Scope" title="Server Scope">
    <t>
      Servers each specify a server scope value in the form
      of an opaque string eir_server_scope returned as part of
      the results of an EXCHANGE_ID operation.  The purpose of
      the server scope is to allow a group of servers to 
      indicate to clients that a set of servers sharing the 
      same server scope value has arranged to use compatible 
      values of otherwise opaque identifiers. Thus, the identifiers
      generated by one server of that set may be presented to
      another of that same scope.
    </t>
    <t>
      The use of such compatible values does not imply that
      a value generated by one server will always be accepted
      by another.  In most cases, it will not.  However, a
      server will not accept a value generated by another
      inadvertently.  When it does accept it, it will be because
      it is recognized as valid and carrying the same meaning  
      as on another server of the same scope.
    </t>
    <t>
      When servers are of the same server scope, this compatibility
      of values applies to the follow identifiers:
      <list style="symbols">
        <t>
          Filehandle values.  A filehandle value accepted by two 
          servers of the same server scope denotes the same object.
          A WRITE operation sent to one server is reflected immediately
          in a READ sent to the other, and locks obtained on one
          server conflict with those requested on the other. 
        </t>
        <t>
          Session ID values.  A session ID value accepted by two
          servers of the same server scope denotes the same session. 
        </t>
        <t>
          Client ID values.  A client ID value accepted as valid by
          two servers of the same server scope is associated with 
          two clients with the same client owner and verifier.
        </t>
        <t>
         State ID values.  A state ID value is recognized as valid
when the corresponding client ID is recognized as valid.

If the same stateid value is accepted as valid
          on two servers of the same scope and the client IDs on
          the two servers represent the same client owner and 
          verifier, then the two stateid values designate the
          same set of locks and are for the same file.
        </t>
        <t>
          Server owner values.  When the server scope values are 
          the same, server owner value may be validly compared.  
          In cases where the server scope values are different, server 
          owner values are treated as different even if they 
          contain all identical bytes.
        </t>
      </list>
    </t>
    <t>
      The coordination among servers required to provide such
      compatibility can be quite minimal, and limited to a simple
      partition of the ID space.  The recognition of common values
      requires additional implementation, but this can be tailored
      to the specific situations in which that recognition is 
      desired.
    </t>
    <t>
      Clients will have occasion to compare the server scope values
      of multiple servers under a number of circumstances, each of
      which will be discussed under the appropriate functional 
      section:
      <list style="symbols">
        <t>
          When server owner values received in response to 
          EXCHANGE_ID operations sent to multiple network
          addresses are compared for the purpose of determining
          the validity of various forms of trunking, as described
          in <xref target="Trunking" />. 
        </t>
        <t>
          When network or server reconfiguration causes the same
          network address to possibly be directed to different
          servers, with the necessity for the client to determine
          when lock reclaim should be attempted, as described
          in <xref target="reclaim_locks" />.
        </t>
        <t>
          When file system migration causes the transfer of
          responsibility for a file system between servers and
          the client needs to determine whether state has been
          transferred with the file system (as described in <xref
          target="transition_state"/>) or whether the
          client needs to reclaim state on a similar basis as in the
	  case of server restart, as described in <xref
	  target="server_failure"/>.

        </t>
      </list>
    </t>
    <t>
      When two replies from EXCHANGE_ID, each from two different
      server network addresses, have the same server scope, there
      are a number of ways a client can validate that the common
      server scope is due to two servers cooperating in a group.
      <list style="symbols">
        <t>
          If both EXCHANGE_ID requests were sent with RPCSEC_GSS
          authentication and the server principal is the same for 
          both targets, the equality of server scope is validated. 
          It is RECOMMENDED that two servers intending to share the
          same server scope also share the same principal name.
        </t>
        <t>
          The client may accept the appearance of the second
          server in the fs_locations or fs_locations_info attribute
          for a relevant file system.  For example, if there is
          a migration event for a particular file system
          or there are locks to be reclaimed on a particular file
          system, the attributes for that particular file system
          may be used.  The client sends the GETATTR request to 
          the first server for the fs_locations or 
          fs_locations_info attribute with RPCSEC_GSS 
          authentication.  It may need to do this in advance
          of the need to verify the common server scope.
          If the client successfully authenticates the reply 
          to GETATTR, and the GETATTR request and reply containing 
          the fs_locations or fs_locations_info attribute refers 
          to the second server, then the equality of server scope 
          is supported.  A client may choose to limit the use of
          this form of support to information relevant to the
          specific file system involved (e.g. a file system 
          being migrated).
        </t>
      </list>  
    </t>
  </section> <!-- Server Scope -->
  <section anchor="Trunking" title="Trunking">
    <t>
     Trunking is the use of multiple connections between a
     client and server in order to increase the speed of data
     transfer. NFSv4.1 supports two types of trunking:
     session trunking and client ID trunking. 
    </t>
    <t>
     NFSv4.1
     servers MUST support both forms of trunking within
     the context of a single server network address and
     MUST support both forms within the context of the
     set of network addresses used to access a single server.
     NFSv4.1 servers in a clustered configuration MAY allow
     network addresses for different servers to use client ID
     trunking.
    </t>
    <t> 
     Clients may use either form of trunking as long as they
     do not, when trunking between different server network 
     addresses, violate the servers' mandates as to the 
     kinds of trunking to be allowed (see below).  With regard 
     to callback channels, the client MUST allow the server to 
     choose among all callback channels valid for a given 
     client ID and MUST support trunking when the connections
     supporting the backchannel allow session or client ID 
     trunking to be used for callbacks.
    </t>
    <t>
     Session trunking is essentially the association of multiple
     connections, each with potentially different target and/or source
     network addresses, to the same session.  When the target network
     addresses (server addresses) of the two connections are the same, 
     the server MUST
     support such session trunking.  When the target network addresses
     are different, the server MAY indicate such support using the
     data returned by the EXCHANGE_ID operation (see below).
    </t>
    <t>
     Client ID trunking is the association of multiple
     sessions to the same client ID.  Servers MUST support client ID
     trunking for two target network addresses whenever they allow 
     session trunking for those same two network addresses.
     In addition, a server MAY, by presenting the same
     major server owner ID
     (<xref target="Server Owners" />) and server scope
     (<xref target="Server Scope" />), allow an additional 
     case of client ID trunking.  When two
     servers return the same major server owner and server
     scope, it means that the two servers are cooperating on
     locking state management, which is a prerequisite
     for client ID trunking.

    </t>
    <t>
     Distinguishing when the client is allowed to use session and
     client ID trunking requires understanding how the results of the
     EXCHANGE_ID (<xref target="OP_EXCHANGE_ID" />)
     operation identify a server.
     Suppose a client sends EXCHANGE_IDs over two different
     connections, each with a possibly different target
     network address, but each EXCHANGE_ID operation has the same
     value in the eia_clientowner field.  If the same
     NFSv4.1 server is listening over each connection,
     then each EXCHANGE_ID result MUST return the same
     values of eir_clientid, eir_server_owner.so_major_id,
     and eir_server_scope. The client can then treat each
     connection as referring to the same server (subject
     to verification; see
     <xref target="trust_but_verify" /> later in this section),
     and it can use each connection to trunk requests and
     replies.  

The client's choice is whether session trunking
     or client ID trunking applies.

    <list style="hanging">

    <t hangText="Session Trunking.">

     If the eia_clientowner argument is the same in
     two different EXCHANGE_ID requests, and
     the eir_clientid, eir_server_owner.so_major_id,
     eir_server_owner.so_minor_id, and eir_server_scope
     results match in both EXCHANGE_ID results, then
     the client is permitted to perform session trunking.
     If the client has no session mapping to the tuple of
     eir_clientid, eir_server_owner.so_major_id, eir_server_scope, and
     eir_server_owner.so_minor_id, then it creates
     the session via a CREATE_SESSION operation over one
     of the connections, which associates the connection
     to the session. If there is a session for the tuple,
     the client can send BIND_CONN_TO_SESSION to associate
     the connection to the session. 
      <vspace blankLines='1' />
     Of course, if the client
     does not desire to use session trunking, it is not 
     required to do so.  It can invoke
     CREATE_SESSION on the connection. This will result
     in client ID trunking as described below.  It can also
     decide to drop the connection if it does not choose to
     use trunking.
      <vspace blankLines='1' />

    </t>

    <t hangText="Client ID Trunking.">

     If the eia_clientowner argument is the same in
     two different EXCHANGE_ID requests, and
     the eir_clientid, eir_server_owner.so_major_id,
     and eir_server_scope
     results match in both EXCHANGE_ID results, then
     the client is permitted to perform client ID trunking
     (regardless of whether the eir_server_owner.so_minor_id results match).
     The client can associate
     each connection with different sessions, where
     each session is associated with the same server.

      <vspace blankLines='1' />

     The client completes the act of client ID trunking by invoking
     CREATE_SESSION on each connection, using the same
     client ID that was returned in eir_clientid. These
     invocations create two sessions and also associate
     each connection with its respective session.  The client 
     is free to decline to use client ID trunking by simply
     dropping the connection at this point.

      <vspace blankLines='1' />

     When doing client ID trunking, locking state
     is shared across sessions associated with that same
     client ID. This requires the server to coordinate
     state across sessions.

    </t>

    </list>

    </t>
    <t>
      The client should be prepared for the possibility
      that eir_server_owner values may be different on
      subsequent EXCHANGE_ID requests made to the same 
      network address, as a result of  various sorts of 
      reconfiguration events.  When this happens and the
      changes result in the invalidation of previously 
      valid forms of trunking, the client should cease 
      to use those forms, either by dropping connections 
      or by adding sessions.  For a discussion of lock 
      reclaim as it relates to such reconfiguration events,
      see <xref target="reclaim_locks" />. 
    </t>

    <section title="Verifying Claims of Matching Server Identity" anchor="trust_but_verify">
    <t>
     When two servers over two connections claim
     matching or partially matching eir_server_owner,
     eir_server_scope, and eir_clientid values, the client
     does not have to trust the servers' claims. The client
     may verify these claims before trunking traffic in
     the following ways:

    <list style='symbols'>

     <t>
      For session trunking,
      clients SHOULD
      reliably verify if connections between different
      network paths are in fact associated with the same NFSv4.1
      server and usable on the same session, and servers
      MUST allow clients to perform reliable verification.
      When a client ID is created, the client SHOULD specify that
      BIND_CONN_TO_SESSION is to be verified according to the
      SP4_SSV or SP4_MACH_CRED (<xref target="OP_EXCHANGE_ID" />)
      state protection options.  For SP4_SSV, reliable
      verification depends on a shared secret (the
      SSV) that is established via the SET_SSV (<xref
      target="OP_SET_SSV" />) operation. 

      <vspace blankLines='1' />

      When a new connection is associated with the
      session (via the BIND_CONN_TO_SESSION operation,
      see <xref target="OP_BIND_CONN_TO_SESSION" />), if
      the client specified SP4_SSV state protection for the
      BIND_CONN_TO_SESSION operation, the client MUST send
      the BIND_CONN_TO_SESSION with RPCSEC_GSS protection,
      using integrity or privacy, and an RPCSEC_GSS handle created
      with the GSS SSV mechanism (<xref
      target="ssv_mech" />).

      <vspace blankLines='1' />

      If the client mistakenly tries to associate a
      connection to a session of a wrong server, the
      server will either reject the attempt because
      it is not aware of the session identifier of the
      BIND_CONN_TO_SESSION arguments, or it will reject
      the attempt because the RPCSEC_GSS authentication
      fails.  Even if the server mistakenly or maliciously
      accepts the connection association attempt, the
      RPCSEC_GSS verifier it computes in the response
      will not be verified by the client, so the client will
      know it cannot use the connection for trunking the
      specified session.  <vspace blankLines='1' /> If the
      client specified SP4_MACH_CRED state protection, the
      BIND_CONN_TO_SESSION operation will use RPCSEC_GSS
      integrity or privacy, using the same credential that
      was used when the client ID was created. Mutual
      authentication via RPCSEC_GSS assures the client
      that the connection is associated with the correct
      session of the correct server.

      <vspace blankLines='1' />
     </t>
     <t>
      For client ID trunking, the client has at least two
      options for verifying that the same client ID
      obtained from two different EXCHANGE_ID operations
      came from the same server.  The first option is
      to use RPCSEC_GSS authentication when sending each
      EXCHANGE_ID operation. Each time an EXCHANGE_ID is sent with
      RPCSEC_GSS authentication, the client notes the
      principal name of the GSS target.  If the EXCHANGE_ID
      results indicate that client ID trunking is possible,
      and the GSS targets' principal names are the same,
      the servers are the same and client ID trunking is
      allowed.

      <vspace blankLines='1' />

      The second option for verification is to
      use SP4_SSV protection.  When the client sends
      EXCHANGE_ID, it specifies SP4_SSV protection. The
      first EXCHANGE_ID the client sends always has to
      be confirmed by a CREATE_SESSION call. The client
      then sends SET_SSV. Later, the client
      sends EXCHANGE_ID to a second destination
      network address different from the one the first 
      EXCHANGE_ID was sent to.
      The client checks that each EXCHANGE_ID reply has the
      same eir_clientid, eir_server_owner.so_major_id, and
      eir_server_scope. If so, the client verifies the
      claim by sending a CREATE_SESSION operation to the second
      destination address, protected with RPCSEC_GSS integrity
      using an RPCSEC_GSS handle returned by the second
      EXCHANGE_ID. If the server accepts the CREATE_SESSION
      request, and if the client verifies the RPCSEC_GSS
      verifier and integrity codes, then the client has
      proof the second server knows the SSV, and thus
      the two servers are cooperating for the purposes of
      specifying server scope and client ID trunking.

     </t>
    </list>
    </t>
    </section> <!-- Verifying Claims of Matching Server Identity -->
  </section> <!-- Trunking -->

  <section anchor="Exactly Once Semantics" title="Exactly Once Semantics">
  <t>
   Via the session, NFSv4.1 offers exactly once semantics (EOS)
   for requests sent over a channel. EOS is supported on both the
   fore channel and backchannel.
  </t>
  <t>
   Each COMPOUND or CB_COMPOUND request that is sent
   with a leading SEQUENCE or CB_SEQUENCE operation MUST
   be executed by the receiver exactly once. This requirement
   holds regardless of whether the request is sent with reply
   caching specified (see <xref target="optional_reply_caching" />).
   The requirement holds even if the requester is sending the
   request over a session created between a pNFS data client
   and pNFS data server. To understand the rationale for this requirement,
   divide the requests into three
   classifications:
   <list style='symbols'>
   <t>
    Non-idempotent requests.
   </t>
   <t>
    Idempotent modifying requests. 
   </t>
   <t>
    Idempotent non-modifying requests. 
   </t>
   </list>
    An example of a non-idempotent request is
    RENAME. Obviously, if a replier executes the
    same RENAME request twice, and the first execution succeeds,
    the re-execution will fail. If the replier returns the
    result from the re-execution, this result is incorrect.
    Therefore, EOS is required for non-idempotent requests.
   </t>
   <t>
    An example of an idempotent modifying request is
    a COMPOUND request containing a WRITE operation.
    Repeated execution of the same WRITE
    has the same effect as execution of that WRITE a single time.
    Nevertheless, enforcing EOS for WRITEs and other idempotent
    modifying requests is necessary
    to avoid data corruption.
   </t>
   <t>
    Suppose a client sends WRITE A to a
    noncompliant server that does not enforce EOS, and
    receives no response, perhaps due to a network
    partition.  The client reconnects to the server and
    re-sends WRITE A. Now, the server has
    outstanding two instances of A.  The
    server can be in a situation in which it executes and
    replies to the retry of A, while the first
    A is still waiting in the server's internal I/O system for some
    resource.  Upon receiving the
    reply to the second attempt of WRITE A,
    the client believes its WRITE is done so it is free
    to send WRITE B, which overlaps the byte-range of
    A.  When the original A is dispatched from the server's
    I/O system and
    executed (thus the second time A will have
    been written), then what has been
    written by B can be overwritten and thus corrupted.
   </t>
   <t>
    An example of an idempotent non-modifying request
    is a COMPOUND containing SEQUENCE, PUTFH, READLINK,
    and nothing else. The re-execution of such a
    request will not cause data corruption or
    produce an incorrect result. Nonetheless,
    to keep the implementation simple,
    the replier MUST enforce EOS for all requests, whether or not
    idempotent and non-modifying.
   </t>
   <t>
    Note that true and complete EOS is not possible unless the
    server persists the reply cache in stable storage, and unless the
    server is somehow implemented to never require a restart
    (indeed, if such a server exists, the distinction between a
    reply cache kept in stable storage versus one that is not is
    one without meaning). See <xref target="Persistence" /> for
    a discussion of persistence in the reply cache.
    Regardless, even if the server does not persist the reply cache,
    EOS improves robustness and correctness over previous versions
    of NFS because the legacy duplicate request/reply caches were
    based on the ONC RPC transaction identifier (XID). 
    <xref target="Slot Identifiers and Server Reply Cache" />
    explains the shortcomings of the XID as a basis for
   a reply cache and describes how NFSv4.1 sessions improve
   upon the XID.
   </t>

    <section anchor="Slot Identifiers and Server Reply Cache"
     title="Slot Identifiers and Reply Cache">
    <t>
     The RPC layer provides a transaction ID (XID), which,
     while required to be unique, is not
     convenient for tracking requests for two reasons.
     First, the XID is only
     meaningful to the requester; it cannot be interpreted
     by the replier except to test for equality with
     previously sent requests. When consulting an RPC-based
     duplicate request cache, the opaqueness of the XID requires
     a computationally expensive look up (often via a hash that
     includes XID and source address). NFSv4.1 requests use
     a non-opaque slot ID, which is an index into a slot table,
     which is far more efficient. Second, because RPC requests
     can be executed by the replier in any order, there is
     no bound on the number of requests that may be outstanding
     at any time. To achieve perfect EOS, using ONC RPC
     would require storing all replies in the reply cache.
     XIDs are 32 bits; storing over four billion (2^32) replies
     in the reply cache is not practical. In practice, previous versions
     of NFS have chosen to store a fixed number of replies in
     the cache, and to use a least recently used (LRU) approach to
     replacing cache entries with new entries when the cache
     is full. In NFSv4.1, the number of outstanding requests is
     bounded by the size of the slot table, and a sequence ID
     per slot is used to tell the replier when it is safe to
     delete a cached reply.
    </t>
    <t>
     In the NFSv4.1 reply cache, when the requester sends a new request,
     it selects a slot ID in the
     range 0..N, where N is the replier's current maximum slot ID
     granted to the requester on the session over which the request is to be
     sent. The value of N starts out as equal to
     ca_maxrequests - 1 (<xref target="OP_CREATE_SESSION" />), but
     can be adjusted by the response to SEQUENCE or CB_SEQUENCE as described
     later in this section.
     The slot ID must be unused by any of the requests that the
     requester has already active on the session.  "Unused" here means the
     requester has no outstanding request for that slot ID.
    </t>
    <t>
     A slot contains a sequence ID and the cached reply corresponding to
     the request sent with that sequence ID. The sequence ID is a
     32-bit unsigned value, and is therefore in the range 0..0xFFFFFFFF (2^32 - 1).
     The first time a slot is used, the requester MUST specify
     a sequence ID of one (<xref target="OP_CREATE_SESSION" />).
     Each time a slot is reused, the request MUST specify a sequence ID
     that is one greater than that of the previous request on the
     slot. If the previous sequence ID was 0xFFFFFFFF, then the next
     request for the slot MUST have the sequence ID set to zero (i.e.,
     (2^32 - 1) + 1 mod 2^32).
    </t>
    <t>
     The sequence ID accompanies the slot ID in each request. It is
     for the critical check at the replier: it used to efficiently
     determine whether a request using a certain
     slot ID is a retransmit or a new, never-before-seen request.  It is
     not feasible for the requester to assert that it is retransmitting to
     implement this, because for any given request the requester cannot
     know whether the replier has seen it unless the replier actually replies.  Of
     course, if the requester has seen the reply, the requester would
     not retransmit.
    </t>
    <t>
     The replier compares each received request's
     sequence ID with the last one previously received for that slot ID,
     to see if the new request is:
    </t>
    <t>
    <list style="symbols">
     <t>
      A new request, in which the sequence ID is one greater
      than that previously seen in the slot (accounting for sequence
      wraparound).  The replier proceeds to execute the new request,
      and the replier
      MUST increase the slot's sequence ID by one.
     </t>
     <t>
      A retransmitted request, in which the sequence ID is equal to
      that currently recorded in the slot. 
      If the original request has
      executed to completion, the replier returns the cached
      reply. See <xref target="Retry and Replay" /> for direction on how the replier
      deals with retries of requests that are still in progress.
     </t>
     <t>
      A misordered retry, in which the sequence ID
      is less than (accounting for sequence wraparound)
      that previously seen in the slot.  The
      replier MUST return NFS4ERR_SEQ_MISORDERED (as the
      result from SEQUENCE or CB_SEQUENCE).
     </t>
     <t>
      A misordered new request, in which the sequence ID
      is two or more than (accounting for sequence
      wraparound) that previously seen in the
      slot. Note that because the sequence ID MUST
      wrap around to zero once it reaches 0xFFFFFFFF, a
      misordered new request and a misordered retry
      cannot be distinguished. Thus, the replier MUST
      return NFS4ERR_SEQ_MISORDERED (as the result from
      SEQUENCE or CB_SEQUENCE).
     </t>
    </list>
    </t>
    <t>
     Unlike the XID, the slot ID is always within a specific
     range; this has two implications.  The first
     implication is that for a given session, the replier
     need only cache the results of a limited number of
     COMPOUND requests.
     The second implication derives
     from the first, which is that unlike XID-indexed reply
     caches (also known as duplicate request caches - DRCs),
     the slot ID-based reply cache cannot be overflowed.
     Through use of the sequence ID to identify
     retransmitted requests, the replier does not need to
     actually cache the request itself, reducing the
     storage requirements of the reply cache further.  These
     facilities make it practical to maintain all the
     required entries for an effective reply cache.

    </t>
    <t>
     The slot ID, sequence ID, and session ID therefore take over the traditional role
     of the XID and source network address in the replier's
     reply cache implementation.
     This approach is considerably
     more portable and completely robust -- it is not subject to the
     reassignment of ports as clients reconnect over IP
     networks.  In addition, the RPC XID is not used in the reply cache,
     enhancing robustness of the cache in the face of any rapid reuse of
     XIDs by the requester. While the replier does not care
     about the XID for the purposes of reply cache management
     (but the replier MUST return the same XID that was in the request),
     nonetheless there are considerations for the XID in NFSv4.1
     that are the same as all other previous versions of NFS.
     The RPC XID remains in each message and needs to be formulated
     in NFSv4.1 requests as in any other ONC RPC request. The reasons
     include:
    <list style="symbols">
    <t>
     The RPC layer retains its existing semantics and implementation.
    </t>
    <t>
     The requester and replier must be able to interoperate at the
     RPC layer, prior to the NFSv4.1 decoding of the SEQUENCE or CB_SEQUENCE
     operation.
    </t>
    <t>
     If an operation is being used that does not start with
     SEQUENCE or CB_SEQUENCE (e.g., BIND_CONN_TO_SESSION),
     then the RPC XID is needed for correct operation to
     match the reply to the request.

    </t>
    <t>
     The SEQUENCE or CB_SEQUENCE operation may generate an error.
     If so, the embedded slot ID, sequence ID, and session ID (if
     present) in the request will not be in the reply, and the
     requester has only the XID to match the reply to the request.
    </t>
    </list>
    </t>
    <t>
     Given that well-formulated XIDs continue to be required,
     this begs the question: why do SEQUENCE and CB_SEQUENCE replies
     have a session ID, slot ID, and sequence ID? Having the session ID
     in the reply means that the requester does not have to use the
     XID to look up
     the session ID, which would be necessary if the connection were
     associated with multiple sessions. Having the slot ID and sequence ID
     in the reply means that the requester does not have to use the XID to
     look up the slot ID and sequence ID.
     Furthermore, since the XID is only 32 bits, it is too small to
     guarantee the re-association of a reply with its request 
     <xref target="rpc_xid_issues" />; having
     session ID, slot ID, and sequence ID in the reply allows the
     client to validate that the reply in fact belongs to the matched request.
    </t>
    <t>
     The SEQUENCE (and CB_SEQUENCE) operation also carries
     a "highest_slotid" value, which carries additional
     requester slot usage information.  The requester MUST
     always indicate the slot ID representing the outstanding request with the
     highest-numbered slot
     value.
     The requester should in all cases provide the most
     conservative value possible, although it can be increased somewhat
     above the actual instantaneous usage to maintain some minimum or
     optimal level.  This provides a way for the requester to yield unused
     request slots back to the replier, which in turn can use the
     information to reallocate resources. 
    </t>
    <t>
     The replier
     responds with both a new target highest_slotid and an
     enforced highest_slotid, described as follows:
     <list style="symbols">
     <t>
      The target highest_slotid is
      an indication to the requester of the highest_slotid the replier
      wishes the requester to be using.  This permits the replier to withdraw
      (or add) resources from a requester that has been found to not be
      using them, in order to more fairly share resources among a varying
      level of demand from other requesters.  The requester must always comply
      with the replier's value updates, since they indicate newly
      established hard limits on the requester's access to session
      resources.  However, because of request pipelining, the requester may
      have active requests in flight reflecting prior values; therefore,
      the replier must not immediately require the requester to comply.
      <vspace blankLines='1' />
     </t>
     <t>
      The enforced highest_slotid indicates the highest slot ID
      the requester is permitted to use on a subsequent SEQUENCE or
      CB_SEQUENCE operation. The replier's enforced highest_slotid SHOULD
      be no less than the highest_slotid the requester indicated
      in the SEQUENCE or CB_SEQUENCE arguments.

      <vspace blankLines='1' />

      A requester can be intransigent with respect to lowering its
      highest_slotid argument to a Sequence operation, i.e. the requester
      continues to ignore the target highest_slotid in the response to
      a Sequence operation, and continues to set its highest_slotid
      argument to be higher than the target highest_slotid. This can
      be considered particularly egregious behavior when the replier
      knows there are no outstanding requests with slot IDs higher than
      its target highest_slotid.  When faced with such intransigence,
      the replier is free to take more forceful action, and MAY reply with
      a new enforced highest_slotid that is less than its previous
      enforced highest_slotid.  Thereafter, if the requester continues
      to send requests with a highest_slotid that is greater than
      the replier's new enforced highest_slotid, the server MAY return
      NFS4ERR_BAD_HIGH_SLOT, unless the slot ID in the request is greater
      than the new enforced highest_slotid and the request is a retry.

      <vspace blankLines='1' />

      The replier SHOULD retain the slots it wants to retire
      until
      the requester sends a request with a highest_slotid less than
      or equal to the replier's new enforced highest_slotid. 

      <vspace blankLines='1' />

      The requester can also be intransigent with
      respect to sending non-retry requests that have a slot ID that
      exceeds the replier's highest_slotid.
      Once the replier has forcibly lowered the enforced
      highest_slotid, the requester is only allowed to
      send retries on slots that exceed the replier's highest_slotid.
      If a request is received with a slot ID that is higher than
      the new enforced highest_slotid, and the sequence ID
      is one higher than what is in the slot's reply cache, then
      the server can both retire the slot and return NFS4ERR_BADSLOT
      (however, the server MUST NOT do one and not the other).
      The reason it is safe to retire the slot
      is because by using the next sequence ID, the requester
      is indicating it has received the previous reply for the
      slot.
      <vspace blankLines='1' />
    </t>
    <t>
     The requester SHOULD use the lowest available
     slot when sending a new request.  This way, the
     replier may be able to retire slot entries faster.
     However, where the replier is actively adjusting
     its granted highest_slotid,
     it will not be able
     to use only the receipt of the slot ID and highest_slotid
     in the request.  Neither the slot ID nor the
     highest_slotid used in a request may reflect the
     replier's current idea of the requester's session
     limit, because the request may have been sent from the
     requester before the update was received.  Therefore,
     in the downward adjustment case, the replier may have
     to retain a number of reply cache entries at least as
     large as the old value of maximum requests
     outstanding, until it can infer that the requester 
     has seen a reply containing the new granted highest_slotid.
     The replier can infer that the requester has seen such a 
     reply when it receives a new request with the same
     slot ID as the request replied to and the next higher 
     sequence ID.      
    </t>
    </list>
   </t>
     <section title="Caching of SEQUENCE and CB_SEQUENCE Replies" anchor="cacheseq">

     <t>
      When a SEQUENCE or CB_SEQUENCE operation is
      successfully executed, its reply MUST always be
      cached. Specifically, session ID, sequence ID,
      and slot ID MUST be cached in the reply cache.
      The reply from SEQUENCE also includes the highest
      slot ID, target highest slot ID, and status flags. Instead
      of caching these values, the server MAY
      re-compute the values from the current
      state of the fore channel, session, and/or client
      ID as appropriate.  Similarly, the reply from
      CB_SEQUENCE includes a highest slot ID and target
      highest slot ID. The client
      MAY re-compute the values from the
      current state of the session as appropriate.

     </t>

     <t>

       Regardless of whether or not a replier is re-computing highest slot ID,
       target slot ID, and status on replies to retries, the requester
       MUST NOT assume that the values are being re-computed whenever it
       receives a reply after a retry is sent, since it has no way
       of knowing whether the reply it has received was sent by the 
       replier in response to the retry or is a delayed response to
       the original request.  Therefore, it may be the case that 
       highest slot ID, target slot ID, or status bits may reflect
       the state of affairs when the request was first executed.  
       Although acting based on such delayed information is valid,
       it may cause the receiver of the reply to do unneeded work.  Requesters
       MAY choose to send additional requests to get the current 
       state of affairs or use the state of affairs reported by 
       subsequent requests, in preference to acting immediately
       on data that might be out of date.

     </t>

     </section>

     <section title="Errors from SEQUENCE and CB_SEQUENCE"
       anchor="err_sequence">
     <t>
      Any time SEQUENCE or CB_SEQUENCE returns an error, the
      sequence ID of the slot MUST NOT change. The replier MUST NOT
      modify the reply cache entry for the slot whenever an error
      is returned from SEQUENCE or CB_SEQUENCE.
     </t>
     </section> <!-- Errors from SEQUENCE and CB_SEQUENCE -->
     <section title="Optional Reply Caching"
      anchor="optional_reply_caching">
      <t>
       On a per-request basis, the requester can choose to
       direct the replier to cache the reply to all operations
       after the first operation (SEQUENCE or CB_SEQUENCE) via
       the sa_cachethis or csa_cachethis fields of the arguments
       to SEQUENCE or CB_SEQUENCE.
       The reason it would not direct the replier to cache
       the entire reply is that the request is composed of all
       idempotent operations <xref target="Chet" />.
       Caching the reply may offer little benefit. If
       the reply is too large (see

       <xref target="COMPOUND Sizing Issues" />),

       it may not be cacheable anyway. Even if the reply to
       idempotent request is small enough to cache, unnecessarily
       caching the reply slows down the server and increases
       RPC latency.
      </t>
      <t>
       Whether or not the requester requests the reply to be cached
       has no effect on the slot processing. If the
       results of SEQUENCE or CB_SEQUENCE are NFS4_OK, then
       the slot's sequence ID MUST be incremented by one.
       If a requester does not direct the replier to cache
       the reply, the replier MUST do one of following:
       <list style='symbols'>
       <t>
        The replier can cache the entire original reply.
        Even though sa_cachethis or csa_cachethis is FALSE,
        the replier is always free to cache. It may choose
        this approach in order to simplify implementation.
       </t>
       <t>
        The replier enters into its reply cache a reply consisting
        of the original results to the SEQUENCE or CB_SEQUENCE
        operation, and with the next operation in
        COMPOUND or CB_COMPOUND having the error NFS4ERR_RETRY_UNCACHED_REP.
        Thus, if the requester later retries the request, it will
        get NFS4ERR_RETRY_UNCACHED_REP.

        If a replier receives a retried Sequence operation where the reply
        to the COMPOUND or CB_COMPOUND was not cached, then the replier,

        <list style='symbols'>

        <t>
	  MAY return NFS4ERR_RETRY_UNCACHED_REP
	  in reply to a Sequence operation if the
	  Sequence operation is not the first
	  operation (granted, a requester that
	  does so is in violation of the NFSv4.1
	  protocol).

        </t>

        <t>
	  MUST NOT return
	  NFS4ERR_RETRY_UNCACHED_REP in reply to
	  a Sequence operation if the Sequence
	  operation is the first operation.

        </t>

        </list>

       </t>

       <t>
        If the second operation is an illegal operation, or an
        operation that was legal in a previous minor version of
        NFSv4 and MUST NOT
        be supported in the current minor version (e.g., SETCLIENTID), the
        replier MUST NOT ever return NFS4ERR_RETRY_UNCACHED_REP.
        Instead the replier MUST return NFS4ERR_OP_ILLEGAL or
        NFS4ERR_BADXDR or NFS4ERR_NOTSUPP as appropriate.
       </t>

       <t>
        If the second operation can result in another error status,
        the replier MAY return a status other than NFS4ERR_RETRY_UNCACHED_REP,
        provided the operation is not executed in such a way that the state
        of the replier is changed. Examples of such
        an error status include: NFS4ERR_NOTSUPP returned for an
        operation that is legal but not REQUIRED in the current 
        minor versions, and thus not supported by the replier;
        NFS4ERR_SEQUENCE_POS; and NFS4ERR_REQ_TOO_BIG.
       </t>

       </list>
      </t>
    
      <t>
	The discussion above assumes that the
	retried request matches the original
	one.  <xref target="false_retry"/>
	discusses what the replier might do, and
	MUST do when original and retried requests do not match.
        Since the replier may
	only cache a small amount of the
	information that would be required to
	determine whether this is a case of a
	false retry, the replier may send to the
	client any of the following responses:

	<list style='symbols'>

	<t>
         The cached reply to the original request (if the replier has cached
         it in its entirety and the users of the original request and retry match).
        </t>

	<t>
          A reply that consists only of the Sequence operation with the error
	  NFS4ERR_FALSE_RETRY.
        </t>

        <t>
	A reply consisting of the response to Sequence  with the status
	NFS4_OK, together with the second operation as it appeared in the retried
	request with an error of NFS4ERR_RETRY_UNCACHED_REP or other error as
	described above.
        </t>

	<t>
          A reply that consists of the response to Sequence with the status
	NFS4_OK, together with the second operation as it appeared in the original
	request with an error of NFS4ERR_RETRY_UNCACHED_REP or other error as
	described above.
        </t>
        </list>

      </t>

        <section anchor="false_retry" title="False Retry">
          <t>
	If a requester sent a Sequence operation
	with a slot ID and sequence ID that are
	in the reply cache but the replier
	detected that the retried request is not
	the same as the original request,
	including a retry that has different
	operations or different arguments in the
	operations from the original and a retry
	that uses a different principal in the
	RPC request's credential field that
	translates to a different user, then this
	is a false retry. When the replier
	detects a false retry, it is permitted 
	(but not always obligated) to return
	NFS4ERR_FALSE_RETRY in response to the
	Sequence operation when it detects a
	false retry.

          </t>
         
          <t>
	Translations of particularly privileged
	user values to other users due to the
	lack of appropriately secure credentials,
	as configured on the replier, should be
	applied before determining whether the
	users are the same or different. If the
	replier determines the users are
	different between the original request
	and a retry, then the replier MUST return
	NFS4ERR_FALSE_RETRY.

          </t>

          <t>
	If an operation of the retry is an
	illegal operation, or an operation that
	was legal in a previous minor version of
	NFSv4 and MUST NOT be supported in the 
	current minor version (e.g., SETCLIENTID),
	the replier MAY return
	NFS4ERR_FALSE_RETRY (and MUST do so if
	the users of the original request and
	retry differ). Otherwise, the replier MAY return
	NFS4ERR_OP_ILLEGAL or NFS4ERR_BADXDR or
	NFS4ERR_NOTSUPP as appropriate.  Note
	that the handling is in contrast for how the
	replier deals with retries requests with
	no cached reply. The difference is due to
	NFS4ERR_FALSE_RETRY being a valid error
	for only Sequence operations, whereas
	NFS4ERR_RETRY_UNCACHED_REP is a valid
	error for all operations except illegal
	operations and operations that MUST NOT be
	supported in the current minor version of
	NFSv4.

          </t>
        </section>
        
     </section> <!-- Optional Reply Caching -->
    </section> <!-- Slot Identifiers and Server Reply Cache -->


    <section anchor="Retry and Replay" title="Retry and Replay of Reply">
    <t>
     A requester MUST NOT retry a request, unless
     the connection it used to send the request
     disconnects. The requester can then reconnect
     and re-send the request, or it can re-send the
     request over a different connection that is
     associated with the same session.
    </t>
    <t>
     If the requester is a server wanting to re-send a callback
     operation over the backchannel of a session, the requester
     of course cannot reconnect because only the client can
     associate connections with the backchannel. The
     server can re-send the request over another connection that
     is bound to the same session's backchannel. If there is no
     such connection, the server
     MUST indicate that the session has no backchannel by setting
     the SEQ4_STATUS_CB_PATH_DOWN_SESSION flag bit in the response
     to the next SEQUENCE operation from the client. The client MUST
     then associate a connection with the session (or destroy
     the session).
    </t>
    <t>
     Note that it is not fatal for a requester to retry
     without a disconnect between the request and retry.
     However, the retry does consume resources, especially
     with RDMA, where each request, retry or not, consumes
     a credit. Retries for no reason, especially retries
     sent shortly after the previous attempt, are a poor
     use of network bandwidth and defeat the purpose of a
     transport's inherent congestion control system.
    </t>
    <t>
     A requester MUST wait for a reply to a request before using
     the slot for another request. If it does not wait for
     a reply, then the requester does not know what
     sequence ID to use for the slot on its next request.
     For example, suppose a requester sends a request with sequence ID
     1, and does not wait for the response. The next time it uses
     the slot, it sends the new request with sequence ID 2.
     If the replier has not seen the request with sequence ID 1, then
     the replier is not expecting sequence ID 2, and rejects the
     requester's new request with NFS4ERR_SEQ_MISORDERED (as the
     result from SEQUENCE or CB_SEQUENCE).
    </t>
    <t>
     RDMA fabrics do not guarantee that the memory handles
     (Steering Tags) within each RPC/RDMA "chunk" <xref target="RPCRDMA" />
     are valid on a scope
     outside that of a single connection.  Therefore, handles used by
     the direct operations become invalid after connection loss.  The
     server must ensure that any RDMA operations that must be replayed
     from the reply cache use the newly provided handle(s) from the
     most recent request.
    </t>
    <t>
     A retry might be sent while the original request is still in
     progress on the replier. The replier SHOULD deal with the issue
     by returning NFS4ERR_DELAY as the reply to SEQUENCE or CB_SEQUENCE
     operation, but implementations MAY return NFS4ERR_MISORDERED.
     Since errors from SEQUENCE and CB_SEQUENCE are
     never recorded in the reply cache, this approach allows the
     results of the execution of the original request to be
     properly recorded in the reply cache (assuming that the requester
     specified the reply to be cached).
    </t>
 
 
     
    </section> <!-- Retry and Replay -->

    <section anchor="sessions_callback_races" title="Resolving Server Callback Races">
    <t>
     It is possible for server callbacks to arrive at the
     client before the reply from related fore channel
     operations. For example, a client may have been
     granted a delegation to a file it has opened, but the
     reply to the OPEN (informing the client of the
     granting of the delegation) may be delayed in the
     network. If a conflicting operation arrives at the
     server, it will recall the delegation using the
     backchannel, which may be on a different
     transport connection, perhaps even a different
     network, or even a different session associated with
     the same client ID.
    </t>
    <t>
     The presence of a session between the client and server
     alleviates this issue. When a session is in place,
     each client request is uniquely identified by its {
     session ID, slot ID, sequence ID } triple. By the rules under which
     slot entries (reply cache entries) are
     retired, the server has knowledge whether the client
     has "seen" each of the server's replies. The server
     can therefore provide sufficient information to the
     client to allow it to disambiguate between an
     erroneous or conflicting callback race
     condition.
    </t>
    <t>
     For each client operation that might result in some
     sort of server callback, the server SHOULD "remember"
     the { session ID, slot ID, sequence ID } triple of the client request
     until the slot ID retirement rules allow the server to
     determine that the client has, in fact, seen the
     server's reply. Until the time the { session ID, slot ID,
     sequence ID } request triple can be retired, any recalls
     of the associated object MUST carry an array of these
     referring identifiers (in the CB_SEQUENCE operation's
     arguments), for the benefit of the client.  After this
     time, it is not necessary for the server to provide
     this information in related callbacks, since it is
     certain that a race condition can no longer occur.
    </t>
    <t>
     The CB_SEQUENCE operation that begins each server
     callback carries a list of "referring" { session ID, slot ID,
     sequence ID } triples.  If the client finds the request
     corresponding to the referring session ID, slot ID, and sequence ID
     to be currently outstanding (i.e., the server's reply has
     not been seen by the client), it can determine that
     the callback has raced the reply, and act
     accordingly. If the client does not find the request
     corresponding to the referring triple to be outstanding (including
     the case of a session ID referring to a destroyed session),
     then there is no race with respect to this triple.
     The server SHOULD limit the referring triples
     to requests that refer to just those that apply to the objects 
     referred to in
     the CB_COMPOUND procedure.
    </t>
    <t>
     The client must not simply wait forever for the
     expected server reply to arrive before responding to the
     CB_COMPOUND that won the race,
     because it is possible
     that it will be delayed indefinitely. The client should
     assume the likely case that the reply will arrive within
     the average round-trip time for COMPOUND requests to the
     server, and wait that period of time. If
     that period of time
     expires, it can respond to the CB_COMPOUND with
     NFS4ERR_DELAY.
    </t>
    <t>
     There are other scenarios under which callbacks may race replies.
     Among them are pNFS layout recalls as described in
     <xref target="pnfs_operation_sequencing" />.
    </t>
    </section> <!-- Resolving server callback races with sessions -->
   <section anchor="COMPOUND Sizing Issues" title="COMPOUND and CB_COMPOUND Construction Issues">

   <t>
    Very large requests and replies may pose both buffer
    management issues (especially with RDMA) and reply
    cache issues. When the session is created
    (<xref target="OP_CREATE_SESSION" />), for each channel (fore and
    back), the client and server
    negotiate the maximum-sized request they will
    send or process (ca_maxrequestsize), the maximum-sized reply
    they will return or process (ca_maxresponsesize), and the 
    maximum-sized reply they will store in the reply cache
    (ca_maxresponsesize_cached).
   </t>
   <t>
    If a request exceeds ca_maxrequestsize, the reply will
    have the status NFS4ERR_REQ_TOO_BIG. A replier MAY
    return NFS4ERR_REQ_TOO_BIG as the status for the first operation
    (SEQUENCE or CB_SEQUENCE) in the request (which means that
    no operations in the request executed and that the
    state of the slot in the reply cache is unchanged), or it MAY
    opt to return it on a subsequent operation in the same
    COMPOUND or CB_COMPOUND request (which means that at least one
    operation did execute and that the state of the slot in the reply cache does
    change). The replier SHOULD set NFS4ERR_REQ_TOO_BIG on the
    operation that exceeds ca_maxrequestsize.
   </t>
   <t>
    If a reply exceeds ca_maxresponsesize, the reply will
    have the status NFS4ERR_REP_TOO_BIG. A replier MAY
    return NFS4ERR_REP_TOO_BIG as the status for the first operation
    (SEQUENCE or CB_SEQUENCE) in the request, or it MAY
    opt to return it on a subsequent operation (in the same
    COMPOUND or CB_COMPOUND reply). A replier MAY return NFS4ERR_REP_TOO_BIG
    in the reply to SEQUENCE or CB_SEQUENCE, even if the response
    would still exceed ca_maxresponsesize.
   </t>
   <t>
    If sa_cachethis or csa_cachethis is TRUE, then the
    replier MUST cache a reply except if an error is
    returned by the SEQUENCE or CB_SEQUENCE operation (see
    <xref target="err_sequence" />). If the reply exceeds
    ca_maxresponsesize_cached (and sa_cachethis or
    csa_cachethis is TRUE), then the server MUST return
    NFS4ERR_REP_TOO_BIG_TO_CACHE. Even if
    NFS4ERR_REP_TOO_BIG_TO_CACHE (or any other error for
    that matter) is returned on an operation other than the
    first operation (SEQUENCE or CB_SEQUENCE), then
    the reply MUST be cached if sa_cachethis or
    csa_cachethis is TRUE.
    For example, if a COMPOUND has eleven
    operations, including SEQUENCE, the fifth operation is
    a RENAME, and the tenth operation is a READ for one
    million bytes, the server may return
    NFS4ERR_REP_TOO_BIG_TO_CACHE on the tenth operation.
    Since the server executed several operations, especially
    the non-idempotent RENAME, the client's request to
    cache the reply needs to be honored in order for the
    correct operation of exactly once semantics. If the
    client retries the request, the server will have cached
    a reply that contains results for ten of the eleven requested
    operations, with
    the tenth operation having a status of NFS4ERR_REP_TOO_BIG_TO_CACHE.
   </t>
   <t>
    A client needs to take care that when sending
    operations that change the current filehandle (except for
    PUTFH, PUTPUBFH, PUTROOTFH, and RESTOREFH), it
    not exceed the maximum reply buffer before the GETFH
    operation. Otherwise, the client will have to retry
    the operation that changed the current filehandle, in order
    to obtain the desired filehandle.
    For the OPEN operation (see <xref target="OP_OPEN" />),
    retry is not always available as an option.
    The following guidelines for the handling of
    filehandle-changing operations are advised:
    <list style="symbols">
    <t>
     Within the same COMPOUND procedure, a client
     SHOULD send GETFH immediately after a current
     filehandle-changing operation. A client
     MUST send GETFH after a current filehandle-changing operation
     that is also non-idempotent (e.g., the OPEN operation), unless
     the operation is RESTOREFH. RESTOREFH is
     an exception, because even though it is
     non-idempotent, the filehandle RESTOREFH
     produced originated from an operation that
     is either idempotent (e.g., PUTFH, LOOKUP),
     or non-idempotent (e.g., OPEN, CREATE). If the
     origin is non-idempotent, then because the client
     MUST send GETFH after the origin operation, the
     client can recover if RESTOREFH returns an error.

    </t>
    <t>
     A server MAY return NFS4ERR_REP_TOO_BIG or
     NFS4ERR_REP_TOO_BIG_TO_CACHE (if sa_cachethis is TRUE)
     on a filehandle-changing operation if the reply would
     be too large on the next operation.
    </t>
    <t>
     A server SHOULD return NFS4ERR_REP_TOO_BIG or
     NFS4ERR_REP_TOO_BIG_TO_CACHE (if sa_cachethis is TRUE)
     on a filehandle-changing, non-idempotent operation if the reply would
     be too large on the next operation, especially if the operation
     is OPEN.
    </t>
    <t>
     A server MAY return NFS4ERR_UNSAFE_COMPOUND to a non-idempotent
     current filehandle-changing operation, if
     it looks at the next operation (in the same COMPOUND procedure)
     and finds it is
     not GETFH. The server SHOULD do this if it is unable to
     determine in advance whether the total response size
     would exceed ca_maxresponsesize_cached or ca_maxresponsesize.
    </t>
    </list>
   </t>
   </section> <!-- COMPOUND and CB_COMPOUND Construction Issues -->
   <section anchor="Persistence" title="Persistence">
   <t>
    Since the reply cache is bounded, it is practical for
    the reply cache to persist across server restarts.
    The replier MUST persist the following information
    if it agreed to persist the session (when the session
    was created; see <xref target="OP_CREATE_SESSION" />):

    <list style='symbols'>
    <t>
     The session ID.
    </t>
    <t>
     The slot table including the sequence ID and cached reply for
     each slot.
    </t>
    </list>
    The above are sufficient for a replier to provide EOS semantics
    for any requests that were sent and executed before the server
    restarted.
    If the replier is a client, then there is no need for
    it to persist any more information, unless the client will
    be persisting all other state across client restart, in which case,
    the server will never see any NFSv4.1-level protocol manifestation
    of a client restart.
    If the replier is a server, with just the
    slot table and session ID persisting,
    any requests the client retries after the server restart will 
    return the results that are cached in the reply cache, 
    and any new requests (i.e., the sequence ID is one greater than the
    slot's sequence ID) MUST be rejected with NFS4ERR_DEADSESSION
    (returned by SEQUENCE). Such a session is considered dead.
    A server MAY re-animate a session
    after a server restart so that the session will accept new
    requests as well as retries. To re-animate a session,
    the server needs to persist additional information
    through server restart:
    <list style='symbols'>
    <t>
     The client ID. This is a prerequisite to let the client
     create more sessions associated with the same client ID
     as the re-animated session.
    </t>
    <t>
     The client ID's sequence ID that is used for creating
     sessions (see Sections <xref target="OP_EXCHANGE_ID" format="counter" /> and
     <xref target="OP_CREATE_SESSION" format="counter" />). This is a
     prerequisite to let the client create more sessions.
    </t>
    <t>
     The principal that created the client ID. This
     allows the server to authenticate the client when
     it sends EXCHANGE_ID.
    </t>
    <t>
     The SSV, if SP4_SSV state protection was
     specified when the client ID was created (see <xref
     target="OP_EXCHANGE_ID" />). This lets the 
     client create new sessions, and associate connections
     with the new and existing sessions.
    </t>
    <t>
     The properties of the client ID as defined in
     <xref target="OP_EXCHANGE_ID" />.
    </t>
     

    </list>
   </t>
   <t>
    A persistent reply cache places certain demands on the server.
    The execution of the sequence of operations (starting with SEQUENCE)
    and placement of its results in the persistent cache MUST be atomic. If
    a client retries a sequence of operations that was previously
    executed on the server, the only acceptable outcomes are either
    the original cached reply or an indication that the client ID
    or session has been lost (indicating a catastrophic loss
    of the reply cache or a session that has been deleted because
    the client failed to use the session for an extended period
    of time).
   </t>
   <t>
    A server could fail and restart in the middle of a
    COMPOUND procedure that contains one or more non-idempotent
    or idempotent-but-modifying operations. This creates
    an even higher challenge for atomic execution and
    placement of results in the reply cache. One way
    to view the problem is as a single transaction consisting of
    each operation in the COMPOUND followed by storing
    the result in persistent storage, then finally a transaction
    commit. If there is a failure before the transaction
    is committed, then the server rolls back the transaction.
    If the server itself fails, then when it restarts, its
    recovery logic could roll back the transaction
    before starting the NFSv4.1 server.
   </t>
   <t>
    While the description of the
    implementation for atomic execution of the request
    and caching of the reply
    is beyond the scope of this document, an example implementation
    for NFSv2 <xref target="RFC1094"/> is described in <xref target="ha_nfs_ibm" />.
   </t>
   </section> <!-- Persistence -->
  </section> <!-- Exactly Once Semantics -->
  <section anchor="RDMA Considerations" title="RDMA Considerations">
  <t>
   A complete discussion of the operation of RPC-based
   protocols over RDMA transports is in <xref target="RPCRDMA" />. A
   discussion of the operation of NFSv4, including NFSv4.1,
   over RDMA is in <xref target="NFSDDP" />.  Where RDMA is considered,
   this specification assumes the use of such a layering;
   it addresses only the upper-layer issues relevant to
   making best use of RPC/RDMA.

  </t>
   <section anchor="RDMA Connection Resources" title="RDMA Connection Resources">
   <t>
    RDMA requires its consumers to register memory and post
    buffers of a specific size and number for receive
    operations.

   </t>
   <t>
    Registration of memory can be a relatively high-overhead operation,
    since it requires pinning of buffers, assignment of attributes
    (e.g., readable/writable), and initialization of hardware
    translation.  Preregistration is desirable to reduce overhead.
    These registrations are specific to hardware interfaces and even to
    RDMA connection endpoints; therefore, negotiation of their limits is
    desirable to manage resources effectively.
   </t>
   <t>
    Following basic registration, these buffers must be posted by
    the RPC layer to handle receives.  These buffers remain in use by
    the RPC/NFSv4.1 implementation; the size and number of them must be
    known to the remote peer in order to avoid RDMA errors that would
    cause a fatal error on the RDMA connection.
   </t>
   <t>
    NFSv4.1 manages slots as resources on a per-session
    basis (see <xref target="Session" />), while RDMA
    connections manage credits on a per-connection basis.
    This means that in order for a peer to send data over
    RDMA to a remote buffer, it has to have both an NFSv4.1
    slot and an RDMA credit.  If multiple RDMA connections
    are associated with a session, then if the total number
    of credits across all RDMA connections associated with
    the session is X, and the number of slots in the session
    is Y, then the maximum number of outstanding requests
    is the lesser of X and Y.

   </t>
   </section> <!-- RDMA Connection Resources -->
   <section anchor="Flow Control" title="Flow Control">
   <t>
    Previous versions of NFS do not provide flow control;
    instead, they rely on the windowing provided by
    transports like TCP to throttle requests.  This does
    not work with RDMA, which provides no operation flow
    control and will terminate a connection in error when
    limits are exceeded. 

    Limits such as maximum number of requests
    outstanding are therefore negotiated when a session
    is created (see the ca_maxrequests field in <xref
    target="OP_CREATE_SESSION" />).  These limits then
    provide the maxima within which each connection associated
    with the session's channel(s) must remain.
    RDMA connections are managed within these limits as
    described in Section 3.3 of <xref target="RPCRDMA" />; if there are multiple
    RDMA connections, then the maximum number of requests
    for a channel will be divided among the RDMA
    connections.  Put a different way, the onus is on the
    replier to ensure that the total number of RDMA credits
    across all connections associated with the replier's
    channel does exceed the channel's maximum number of
    outstanding requests.

   </t>
   <t>
    The limits may also be modified
    dynamically at the replier's choosing by manipulating
    certain parameters present in each NFSv4.1 reply. In
    addition, the CB_RECALL_SLOT callback operation (see
    <xref target="OP_CB_RECALL_SLOT" />) can be sent by
    a server to a client to return RDMA credits to the
    server, thereby lowering the maximum number of requests
    a client can have outstanding to the server.

   </t>
   </section> <!-- Flow Control -->

   <section anchor="Padding" title="Padding">
   <t>
        Header padding is requested by each peer at session initiation
        (see the ca_headerpadsize argument to CREATE_SESSION in
        <xref target="OP_CREATE_SESSION" />), and
        subsequently used by the RPC RDMA layer, as described in <xref target="RPCRDMA" />.
        Zero padding is permitted.
   </t>
   <t>
        Padding leverages the useful property
        that RDMA preserve alignment of data, even when they are
        placed into anonymous (untagged) buffers.  If requested, client
        inline writes will insert appropriate pad bytes within the request
        header to align the data payload on the specified boundary.  The
        client is encouraged to add sufficient padding (up to the
        negotiated size) so that
        the "data" field of the WRITE operation
        is aligned.
        Most servers can make good use of such padding,
        which allows them to chain receive buffers in such a way that any
        data carried by client requests will be placed into appropriate
        buffers at the server, ready for file system processing.  The
        receiver's RPC layer encounters no overhead from skipping over pad
        bytes, and the RDMA layer's high performance makes the insertion
        and transmission of padding on the sender a significant
        optimization.  In this way, the need for servers to perform RDMA
        Read to satisfy all but the largest client writes is obviated.  An
        added benefit is the reduction of message round trips on the network
        -- a potentially good trade, where latency is present.
   </t>
   <t>
        The value to choose for padding is subject to a number of criteria.
        A primary source of variable-length data in the RPC header is the
        authentication information, the form of which is client-determined,
        possibly in response to server specification.  The contents of
        COMPOUNDs, sizes of strings such as those passed to RENAME, etc.
        all go into the determination of a maximal NFSv4.1 request size and
        therefore minimal buffer size.  The client must select its offered
        value carefully, so as to avoid overburdening the server, and vice
        versa.  The benefit of an appropriate padding value is higher
        performance.
   </t>
   <figure>
   <artwork>
                 Sender gather:
     |RPC Request|Pad  bytes|Length| -> |User data...|
     \------+----------------------/      \
             \                             \
              \    Receiver scatter:        \-----------+- ...
         /-----+----------------\            \           \
         |RPC Request|Pad|Length|   ->  |FS buffer|->|FS buffer|->...
   </artwork>
   </figure>
   <t>
        In the above case, the server may recycle unused buffers to the
        next posted receive if unused by the actual received request, or
        may pass the now-complete buffers by reference for normal write
        processing.  For a server that can make use of it, this removes
        any need for data copies of incoming data, without resorting to
        complicated end-to-end buffer advertisement and management.  This
        includes most kernel-based and integrated server designs, among
        many others.  The client may perform similar optimizations, if
        desired.
   </t>
   </section> <!-- Padding -->
   <section anchor="dual" title="Dual RDMA and Non-RDMA Transports">
   <t>
    Some RDMA transports (e.g., <xref target="RDMAP">RFC 5040</xref>)
    permit a "streaming" (non-RDMA) phase,
    where ordinary traffic might flow before "stepping up"
    to RDMA mode, commencing RDMA traffic.  Some RDMA
    transports start connections always in RDMA mode.
    NFSv4.1 allows, but does not assume, a streaming phase
    before RDMA mode.  When a connection
    is associated with a session, the client and server negotiate whether the
    connection is used in RDMA or non-RDMA mode  (see Sections
    <xref target="OP_CREATE_SESSION" format="counter" /> and
    <xref target="OP_BIND_CONN_TO_SESSION" format="counter" />).
   </t>
   </section> <!-- RDMA Transports -->

  </section> <!-- RDMA Considerations -->

  <section anchor="Sessions Security" title="Session Security">
   <section anchor="Session Callback Security" title="Session Callback Security">
   <t>
    Via session/connection association, NFSv4.1 improves security over
    that provided by NFSv4.0 for the backchannel.  The
    connection is client-initiated (see
    <xref target="OP_BIND_CONN_TO_SESSION" />) and subject to the same
    firewall and routing checks as the fore channel.
    At the client's option (see <xref target="OP_EXCHANGE_ID" />),
    connection association is fully authenticated before being
    activated (see <xref target="OP_BIND_CONN_TO_SESSION" />).
    Traffic from the server over the
    backchannel is authenticated exactly as the client specifies
    (see <xref target="Backchannel RPC Security" />).
   </t>
   </section> <!-- Session Callback Security -->
    <section anchor="Backchannel RPC Security" title="Backchannel RPC Security">
    <t>
     When the NFSv4.1 client establishes the backchannel, it
     informs the  server of the security flavors and principals
     to use when sending requests. If the security flavor is
     RPCSEC_GSS, the client expresses the principal in the form
     of an established RPCSEC_GSS context.  The server is free
     to use any of the flavor/principal combinations the client
     offers, but it MUST NOT use unoffered combinations.

     This way, the client need not provide a target
     GSS principal for the backchannel as it did with
     NFSv4.0, nor does the server have to implement an
     RPCSEC_GSS initiator as it did with NFSv4.0 <xref
     target="RFC3530" />.

    </t>
    <t>
     The CREATE_SESSION (<xref target="OP_CREATE_SESSION" />)
     and BACKCHANNEL_CTL (<xref target="OP_BACKCHANNEL_CTL" />)
     operations allow the client to specify flavor/principal combinations.
    </t>
    <t>
     Also note that the SP4_SSV state protection mode 
     (see Sections <xref target="OP_EXCHANGE_ID" format="counter" /> and <xref
     target="protect_state_change" format="counter" />) has the side
     benefit of providing SSV-derived RPCSEC_GSS contexts (<xref target="ssv_mech" />).
    </t>
    </section> <!-- Backchannel RPC Security -->

   <section anchor="protect_state_change" title="Protection from Unauthorized State Changes">
   <t>
     As described to this point in the specification, the state model
     of NFSv4.1 is vulnerable to an attacker that
     sends a SEQUENCE operation with a forged session ID and with a slot ID that
     it expects the legitimate client to use next. When the legitimate client
     uses the slot ID with the same sequence number, the server
     returns the attacker's result from the reply cache, which
     disrupts the legitimate client and thus denies service to it.
     Similarly, an attacker could send a CREATE_SESSION with a forged
     client ID to create a new session associated with the client ID.
     The attacker could send requests using the new session that
     change locking state, such as LOCKU operations to release locks
     the legitimate client has acquired. Setting a security
     policy on the file that requires RPCSEC_GSS credentials when
     manipulating the file's state is one potential work around,
     but has the disadvantage of preventing a legitimate client from
     releasing state when RPCSEC_GSS is required to do so, but
     a GSS context cannot be obtained (possibly because the user
     has logged off the client).
   </t>
   <t>
     NFSv4.1 provides three options to a client for state protection,
     which are specified when a client creates
     a client ID via EXCHANGE_ID (<xref target="OP_EXCHANGE_ID" />).
   </t>
   <t>
     The first (SP4_NONE) is to simply waive state protection.
   </t>
   <t>
     The other two options (SP4_MACH_CRED and SP4_SSV)
     share several traits:
     <list style="symbols">
     <t>
      An RPCSEC_GSS-based credential is used to authenticate
      client ID and session maintenance operations,
      including creating and destroying a session,
      associating a connection with the session, and
      destroying the client ID.
     </t>
     <t>
      Because RPCSEC_GSS is used to authenticate
      client ID and session maintenance, the attacker cannot
      associate a rogue connection with a legitimate session, or
      associate a rogue session with a legitimate client ID in
      order to maliciously alter the client ID's lock state 
      via CLOSE, LOCKU, DELEGRETURN, LAYOUTRETURN, etc.
     </t>
     <t>
      In cases where the server's security policies on a
      portion of its namespace require RPCSEC_GSS authentication,
      a client may have to use an RPCSEC_GSS credential
      to remove per-file state (e.g., LOCKU, CLOSE, etc.).
      The server may require that the principal that removes
      the state match certain criteria (e.g.,
      the principal might have to be the same as the one
      that acquired the state). However, the client might
      not have an RPCSEC_GSS context for such a principal,
      and might not be able to create such a context (perhaps
      because the user has logged off). When the client
      establishes SP4_MACH_CRED or SP4_SSV protection,
      it can specify a list of operations that the server MUST
      allow using the machine credential (if SP4_MACH_CRED
      is used) or the SSV credential (if SP4_SSV is used).
     </t>
     </list>
   </t>
   <t>
     The SP4_MACH_CRED  state protection option uses a machine
     credential where the principal that
     creates the client ID MUST also be the principal
     that performs client ID and session maintenance 
    operations.
     The security of the machine credential state protection approach
     depends entirely on safe guarding the per-machine credential.
     Assuming a proper safeguard using the per-machine credential
     for operations like CREATE_SESSION, BIND_CONN_TO_SESSION,
     DESTROY_SESSION, and DESTROY_CLIENTID will prevent an attacker
     from associating a rogue connection with a session, or
     associating a rogue session with a client ID.
   </t>
   <t>
     There are at least three scenarios for the SP4_MACH_CRED
     option:
     <list style="numbers">
     <t>
      The system administrator configures a unique,
      permanent per-machine credential for one of the
      mandated GSS mechanisms (e.g., if Kerberos
      V5 is used, a "keytab" containing a principal derived from a
      client host name could be used).

     </t>
     <t>
      The client is used by a single user, and so the
      client ID and its sessions are used by just that
      user. If the user's credential expires, then session
      and client ID maintenance cannot occur, but since
      the client has a single user, only that user is
      inconvenienced.

     </t>
     <t>
      The physical client has multiple users, but the
      client implementation has a unique client ID for
      each user. This is effectively the same as the
      second scenario, but a disadvantage is that each
      user needs to be allocated at least one session each,
      so the approach suffers from lack of economy.

     </t>

     </list>
   </t>
   <t>
     The SP4_SSV protection option uses the SSV (<xref
     target="intro_definitions"/>), via RPCSEC_GSS and the SSV GSS
     mechanism (<xref target="ssv_mech" />), to protect state from attack.
     The SP4_SSV protection option is intended for the situation
     comprised of a client that has multiple active users and a system
     administrator who wants to avoid the burden of installing a permanent
     machine credential on each client.  The SSV is
     established and updated on the server via SET_SSV (see <xref
     target="OP_SET_SSV" />). To prevent eavesdropping,
     a client SHOULD send SET_SSV via RPCSEC_GSS with
     the privacy service.  Several aspects of the SSV
     make it intractable for an attacker to guess the SSV,
     and thus associate rogue connections with a session,
     and rogue sessions with a client ID:

    <list style="symbols">
    <t>
      The arguments to and results of SET_SSV include digests of the old and
      new SSV, respectively.
    </t>
    <t>
      Because the initial value of the SSV is zero,
      therefore known, the client that opts for SP4_SSV
      protection and opts to apply SP4_SSV protection to
      BIND_CONN_TO_SESSION and CREATE_SESSION MUST send
      at least one SET_SSV operation before the first
      BIND_CONN_TO_SESSION operation or before the second
      CREATE_SESSION operation on a client ID. If it does
      not, the SSV mechanism will not generate tokens
      (<xref target="ssv_mech" />).

      A client SHOULD send SET_SSV as soon as a session
      is created.

    </t>
    <t>
      A SET_SSV request does not replace the SSV with the argument to
      SET_SSV. Instead, the current SSV on the server is logically
      exclusive ORed (XORed) with the argument to SET_SSV.
      Each time a new principal uses a client ID for the first
      time, the client
      SHOULD send a SET_SSV with that principal's RPCSEC_GSS
      credentials, with RPCSEC_GSS service set to RPC_GSS_SVC_PRIVACY.
    </t>
    </list>
   </t>
   <t>
     Here are the types of attacks that can be attempted by an attacker named
     Eve on a victim named Bob, and how SP4_SSV protection foils
     each attack:
     <list style="symbols">
     <t>
       Suppose Eve is the first user to log into a
       legitimate client.  Eve's use of an NFSv4.1
       file system will cause the legitimate client to
       create a client ID
       with SP4_SSV protection, specifying that the BIND_CONN_TO_SESSION
       operation MUST use the SSV credential. Eve's use of
       the file system also causes an SSV to be created.  The
       SET_SSV operation that creates the SSV will be protected by
       the RPCSEC_GSS context created by the legitimate
       client, which uses Eve's GSS principal and
       credentials. Eve can eavesdrop on the network while
       her RPCSEC_GSS context is created and the SET_SSV
       using her context is sent. Even if the legitimate
       client sends the SET_SSV with RPC_GSS_SVC_PRIVACY,
       because Eve knows her own credentials, she can
       decrypt the SSV.  Eve can compute an RPCSEC_GSS
       credential that BIND_CONN_TO_SESSION will accept,
       and so associate a new connection with the
       legitimate session. Eve can change the slot ID and
       sequence state of a legitimate session, and/or the
       SSV state, in such a way that when Bob accesses
       the server via the same legitimate client, the
       legitimate client will be unable to use the session.

       <vspace blankLines='1' />

       The client's only recourse is to create a new client
       ID for Bob to use, and establish a new SSV for the
       client ID.  The client will be unable to delete
       the old client ID, and will let the lease on the old
       client ID expire.

       <vspace blankLines='1' />

       Once the legitimate client establishes an SSV over
       the new session using Bob's RPCSEC_GSS context,
       Eve can use the new session via the legitimate
       client, but she cannot disrupt Bob.  Moreover,
       because the client SHOULD have modified the SSV
       due to Eve using the new session, Bob cannot get
       revenge on Eve by associating a rogue connection
       with the session. 

       <vspace blankLines='1' />

       The question is how did the legitimate client detect
       that Eve has hijacked the old session?  When the
       client detects that a new principal, Bob, wants to
       use the session, it SHOULD have sent a SET_SSV,
       which leads to the following sub-scenarios:

       <vspace blankLines='1' />

       <list style="symbols">
       <t>
         Let us suppose that from the rogue connection, Eve
         sent a SET_SSV with the same slot ID and sequence ID that
         the legitimate client later uses. The server will
         assume the SET_SSV sent with Bob's credentials is a retry,
         and return to the legitimate
         client the reply it sent Eve. However, unless Eve can
         correctly guess the SSV the legitimate client will use,
         the digest verification checks in the SET_SSV response
         will fail.  That is an indication to the client that the
         session has apparently been hijacked.
         <vspace blankLines='1' />
       </t>
       <t>
         Alternatively, Eve sent a SET_SSV with a different slot ID than
         the legitimate client uses for its SET_SSV. Then the digest
         verification of the SET_SSV sent with Bob's credentials fails
         on the server, and the error returned to the client makes it
         apparent that the session has been hijacked.
         <vspace blankLines='1' />
       </t>
       <t>
         Alternatively, Eve sent an operation other than SET_SSV,
         but with the same slot ID and sequence that the legitimate client
         uses for its SET_SSV. The server returns to the legitimate
         client the response it sent Eve. The client sees that the
         response is not at all what it expects. The client
         assumes either session hijacking or a server bug, and either way
         destroys the old session.
         <vspace blankLines='1' />
       </t>
       </list>
     </t>
     <t>
       Eve associates a rogue connection with the session
       as above, and then destroys the session. Again, Bob
       goes to use the server from the legitimate client,
       which sends a SET_SSV using Bob's credentials. The client receives an error
       that indicates that the session does not exist. When
       the client tries to create a new session, this
       will fail because the SSV it has does not match that which the
       server has, and now the client knows the session
       was hijacked. The legitimate client establishes a
       new client ID.

       <vspace blankLines='1' />

     </t>
     <t>
       If Eve creates a connection before the legitimate
       client establishes an SSV, because the initial
       value of the SSV is zero and therefore known,
       Eve can send a SET_SSV that will pass the digest
       verification check.  However, because the new
       connection has not been associated with the session,
       the SET_SSV is rejected for that reason.

       <vspace blankLines='1' />

     </t>
     </list>
     In summary, an attacker's disruption of state when
     SP4_SSV protection is in use is limited to the
     formative period of a client ID, its first session,
     and the establishment of the SSV. Once a non-malicious
     user uses the client ID, the client quickly detects
     any hijack and rectifies the situation. Once a
     non-malicious user successfully modifies the SSV,
     the attacker cannot use NFSv4.1 operations to disrupt
     the non-malicious user.

   </t>

   <t>
     Note that neither the SP4_MACH_CRED nor
     SP4_SSV protection approaches prevent hijacking
     of a transport connection that has previously been
     associated with a session. If the goal of a counter-threat
     strategy is to prevent connection hijacking, the use of IPsec is RECOMMENDED.
   </t>

   <t>
     If a connection hijack occurs, the hijacker could in
     theory change locking state and negatively impact the
     service to legitimate clients.  However, if the server
     is configured to require the use of RPCSEC_GSS with
     integrity or privacy on the affected file objects, and
     if EXCHGID4_FLAG_BIND_PRINC_STATEID capability (<xref
     target="OP_EXCHANGE_ID"/>) is in force, this will
     thwart unauthorized attempts to change locking state.
   </t>

   </section> <!-- Protection from Unauthorized State Changes -->
  </section> <!-- Sessions Security -->
  <section title="The Secret State Verifier (SSV) GSS Mechanism" anchor="ssv_mech">
  <t>
   The SSV provides the secret key for a GSS mechanism internal to NFSv4.1
   that NFSv4.1 uses for state protection. Contexts for this
   mechanism are not established via the RPCSEC_GSS
   protocol.  Instead, the contexts are automatically
   created when EXCHANGE_ID specifies
   SP4_SSV protection.  The only tokens
   defined are the PerMsgToken (emitted by GSS_GetMIC)
   and the SealedMessage token (emitted by GSS_Wrap).
  </t>
  <t>
   The mechanism OID for the SSV mechanism is
   iso.org.dod.internet.private.enterprise.Michael
   Eisler.nfs.ssv_mech (1.3.6.1.4.1.28882.1.1).  While the
   SSV mechanism does not define any initial context
   tokens, the OID can be used to let servers indicate
   that the SSV mechanism is acceptable whenever the
   client sends a SECINFO or SECINFO_NO_NAME operation
   (see

   <xref target="Security Service Negotiation" />).

  </t>

  <t>
   The SSV mechanism defines four subkeys derived from
   the SSV value. Each time SET_SSV is invoked, the subkeys
   are recalculated by the client and server. The
   calculation of each of the four subkeys depends on each
   of the four respective ssv_subkey4 enumerated values. The calculation
   uses the HMAC
   <xref target="RFC2104" /> algorithm, using the current SSV as the key, the one-way hash
   algorithm as negotiated by EXCHANGE_ID,
   and the input text as represented by the XDR encoded
   enumeration value for that subkey of data type ssv_subkey4.
   If the length of the output of the HMAC algorithm exceeds the length of
   key of the encryption algorithm (which is also negotiated by EXCHANGE_ID),
   then the subkey MUST be truncated from the HMAC output, i.e., if the
   subkey is of N bytes long, then the first N bytes of the HMAC output
   MUST be used for the subkey. The specification of EXCHANGE_ID
   states that the length of the output of the HMAC algorithm MUST NOT
   be less than the length of subkey needed for the encryption algorithm
   (see <xref target="OP_EXCHANGE_ID"/>).
  </t>
<figure>
 <artwork>

/* Input for computing subkeys */
enum ssv_subkey4 {
        SSV4_SUBKEY_MIC_I2T     = 1,
        SSV4_SUBKEY_MIC_T2I     = 2,
        SSV4_SUBKEY_SEAL_I2T    = 3,
        SSV4_SUBKEY_SEAL_T2I    = 4
};

 </artwork>
</figure>
  <t>
   The subkey derived from SSV4_SUBKEY_MIC_I2T
   is used for calculating message integrity codes (MICs)
   that originate from the NFSv4.1 client, whether as part
   of a request over the fore channel or a response
   over the backchannel. The subkey derived from
   SSV4_SUBKEY_MIC_T2I is used for MICs originating from the
   NFSv4.1 server. The subkey derived from SSV4_SUBKEY_SEAL_I2T
   is used for encryption text originating from the NFSv4.1
   client, and the subkey derived from SSV4_SUBKEY_SEAL_T2I
   is used for encryption text originating from the 
   NFSv4.1 server.
  </t>
  <t>
   The PerMsgToken description is based on an XDR definition:
  </t>
<figure>
 <artwork>

/* Input for computing smt_hmac */
struct ssv_mic_plain_tkn4 {
  uint32_t        smpt_ssv_seq;
  opaque          smpt_orig_plain&lt;>;
};

 </artwork>
</figure>
<figure>
 <artwork>

/* SSV GSS PerMsgToken token */
struct ssv_mic_tkn4 {
  uint32_t        smt_ssv_seq;
  opaque          smt_hmac&lt;>;
};

 </artwork>
</figure>
  <t>

   The field smt_hmac is an HMAC calculated by using the
   subkey derived from SSV4_SUBKEY_MIC_I2T or
   SSV4_SUBKEY_MIC_T2I  as the key, the one-way hash algorithm
   as negotiated by EXCHANGE_ID, and the input text
   as represented by data of type ssv_mic_plain_tkn4.
   The field smpt_ssv_seq is the same as smt_ssv_seq.
   The field smpt_orig_plain is the "message" input passed
   to GSS_GetMIC() (see Section 2.3.1 of <xref target="RFC2743"/>).
   The caller of GSS_GetMIC() provides a pointer to a buffer
   containing the plain text. The SSV mechanism's entry point for
   GSS_GetMIC() encodes this into an opaque array, and the encoding
   will include an initial four-byte length, plus any necessary padding.
   Prepended to this will be the XDR encoded value of smpt_ssv_seq,
   thus making up an XDR encoding of a value of data type
   ssv_mic_plain_tkn4, which in turn is the input into the HMAC.
  </t>
  <t>
   The token emitted by GSS_GetMIC() is XDR encoded and
   of XDR data type ssv_mic_tkn4.  The field smt_ssv_seq
   comes from the SSV sequence number, which is equal to
   one after SET_SSV (<xref target="OP_SET_SSV" />)
   is called the first time on a client
   ID.
   Thereafter, the SSV sequence number is incremented on each SET_SSV.
   Thus, smt_ssv_seq represents the version of the SSV at
   the time GSS_GetMIC() was called.  As noted in <xref
   target="OP_EXCHANGE_ID" />, the client and server
   can maintain multiple concurrent versions of the SSV.
   This allows the SSV to be changed without serializing
   all RPC calls that use the SSV mechanism with SET_SSV
   operations.
   Once the HMAC is calculated, it is XDR encoded into
   smt_hmac, which will include an initial four-byte length,
   and any necessary padding. Prepended to this will be
   the XDR encoded value of smt_ssv_seq.

   </t>
  <t>
   The SealedMessage description is based on an XDR definition:
  </t>
<figure>
 <artwork>

/* Input for computing ssct_encr_data and ssct_hmac */
struct ssv_seal_plain_tkn4 {
  opaque          sspt_confounder&lt;>;
  uint32_t        sspt_ssv_seq;
  opaque          sspt_orig_plain&lt;>;
  opaque          sspt_pad&lt;>;
};

 </artwork>
</figure>
<figure>
 <artwork>

/* SSV GSS SealedMessage token */
struct ssv_seal_cipher_tkn4 {
  uint32_t      ssct_ssv_seq;
  opaque        ssct_iv&lt;>;
  opaque        ssct_encr_data&lt;>;
  opaque        ssct_hmac&lt;>;
};

 </artwork>
</figure>
  <t>
   The token emitted by GSS_Wrap() is XDR encoded and
   of XDR data type ssv_seal_cipher_tkn4.

  </t>

  <t>
   The ssct_ssv_seq field has the same meaning as smt_ssv_seq.

  </t>

  <t>
   The ssct_encr_data field is the result of encrypting a
   value of the XDR encoded data type ssv_seal_plain_tkn4.
   The encryption key is the subkey derived from SSV4_SUBKEY_SEAL_I2T
   or SSV4_SUBKEY_SEAL_T2I, and the encryption
   algorithm is that negotiated by EXCHANGE_ID.
  </t>

  <t>
   The ssct_iv field is the initialization vector (IV)
   for the encryption algorithm (if applicable) and is
   sent in clear text. The content and size of the IV MUST
   comply with the specification of the encryption algorithm.
   For example, the id-aes256-CBC algorithm MUST use
   a 16-byte initialization vector (IV), which MUST be
   unpredictable for each instance of a value of data type
   ssv_seal_plain_tkn4 that is encrypted with a particular
   SSV key.

  </t>
  <t>
   The ssct_hmac field is the result of computing an HMAC using the value
   of the XDR encoded data type ssv_seal_plain_tkn4 as the input
   text. The key is the subkey derived from SSV4_SUBKEY_MIC_I2T or
   SSV4_SUBKEY_MIC_T2I, and the one-way hash algorithm is that
   negotiated by EXCHANGE_ID.

  </t>
  <t>
   The sspt_confounder field is a random value.

  </t>
  <t>
   The sspt_ssv_seq field is the same as ssvt_ssv_seq.

  </t>
  <t>
   The field sspt_orig_plain field is the original plaintext
   and is the "input_message" input passed to
   GSS_Wrap() (see Section 2.3.3 of <xref target="RFC2743"/>).
   As with the handling of the plaintext by the SSV mechanism's
   GSS_GetMIC() entry point, the entry point for GSS_Wrap()
   expects a pointer to the plaintext, and will XDR encode
   an opaque array into sspt_orig_plain
   representing the plain text, along with
   the other fields of an instance of data type ssv_seal_plain_tkn4.

  </t>
  <t>
   The sspt_pad field is present to support encryption
   algorithms that require inputs to be in fixed-sized
   blocks.  The content of sspt_pad is zero filled
   except for the length.  Beware that the XDR encoding
   of ssv_seal_plain_tkn4 contains three variable-length
   arrays, and so each array consumes four bytes for an
   array length, and each array that follows the length
   is always padded to a multiple of four bytes per the
   XDR standard.

  </t>
  <t>
   For example, suppose the encryption algorithm uses 16-byte blocks, and
   the sspt_confounder is three bytes long, and
   the sspt_orig_plain field is 15 bytes long.

   The XDR encoding of sspt_confounder uses eight bytes
   (4 + 3 + 1 byte pad),

   the XDR encoding of sspt_ssv_seq uses four bytes,

   the XDR encoding of sspt_orig_plain uses 20 bytes
   (4 + 15 + 1 byte pad),

   and the smallest XDR encoding of the sspt_pad field
   is four bytes.

   This totals 36 bytes. The next multiple of 16 is 48;
   thus, the length field of sspt_pad needs to be set to
   12 bytes, or a total encoding of 16 bytes.

   The total number of XDR encoded bytes is thus 8 +
   4 + 20 + 16 = 48.

  </t>
  <t>
   GSS_Wrap() emits a token that is an XDR
   encoding of a value of data type ssv_seal_cipher_tkn4.

   Note that regardless of whether or not the caller of GSS_Wrap()
   requests confidentiality, the token always has
   confidentiality. This is because the SSV mechanism
   is for RPCSEC_GSS, and RPCSEC_GSS never produces
   GSS_wrap() tokens without confidentiality.

  </t>
  <t>
   There is one SSV per client ID.
   There is a single GSS context for
   a client ID / SSV pair.
   All SSV mechanism RPCSEC_GSS handles of a client ID / SSV pair
   share the same GSS context.
   SSV GSS contexts do not expire except when the SSV
   is destroyed (causes would include the client ID
   being destroyed or a server restart).
   Since one
   purpose of context expiration is to replace keys that
   have been in use for "too long", hence vulnerable to
   compromise by brute force or accident, the client can
   replace the SSV key by
   sending periodic SET_SSV operations, which is done by cycling through
   different users' RPCSEC_GSS credentials. This way, the SSV is
   replaced without destroying the SSV's GSS contexts.
  </t>
  <t>
   SSV RPCSEC_GSS handles can be expired or deleted by the server
   at any time, and the EXCHANGE_ID operation can be used to create
   more SSV RPCSEC_GSS handles. Expiration of SSV RPCSEC_GSS handles
   does not imply that the SSV or its GSS context has expired.
  </t>
  <t>
   The client MUST establish an SSV via SET_SSV before the
   SSV GSS context can be used to emit tokens from GSS_Wrap()
   and GSS_GetMIC(). If SET_SSV has not been successfully
   called, attempts to emit tokens MUST fail.

  </t>
  <t>
   The SSV mechanism does not support replay detection and sequencing
   in its tokens because RPCSEC_GSS does not use those features (See
   Section 5.2.2, "Context Creation Requests", in <xref target="RFC2203"
   />). However, <xref target="rpcsec_ssv_consider"/> discusses special
   considerations for the SSV mechanism when used with RPCSEC_GSS.

  </t>
  </section> <!-- The SSV GSS Mechanism -->

  <section anchor="rpcsec_ssv_consider" title="Security Considerations for RPCSEC_GSS When Using the SSV Mechanism">
  <t>
    When a client ID is created with SP4_SSV state protection (see <xref
    target="OP_EXCHANGE_ID"/>), the client is permitted to associate
    multiple RPCSEC_GSS handles with the single SSV GSS context
    (see <xref target="ssv_mech"/>). Because of the way RPCSEC_GSS
    (both version 1 and version 2, see <xref target="RFC2203"/> and
    <xref target="RFC5403"/>) calculate the verifier of the reply,
    special care must be taken by the implementation of the NFSv4.1
    client to prevent attacks by a man-in-the-middle.  The verifier
    of an RPCSEC_GSS reply is the output of GSS_GetMIC() applied to
    the input value of the seq_num field of the RPCSEC_GSS credential
    (data type rpc_gss_cred_ver_1_t) (see Section 5.3.3.2 of <xref
    target="RFC2203"/>). If multiple RPCSEC_GSS handles share the same
    GSS context, then if one handle is used to send a request with the
    same seq_num value as another handle, an attacker could block the
    reply, and replace it with the verifier used for the other handle.

  </t>

  <t>
   There are multiple ways to prevent the attack on the SSV RPCSEC_GSS
   verifier in the reply. The simplest is believed to be as follows.

   <list style='symbols'>

  <t>
   Each time one or more new SSV RPCSEC_GSS handles are created via
   EXCHANGE_ID, the client SHOULD send a SET_SSV operation to modify
   the SSV. By changing the SSV, the new handles will not result in the
   re-use of an SSV RPCSEC_GSS verifier in a reply.

  </t>
  
  <t>
   When a requester decides to use N SSV RPCSEC_GSS handles, it SHOULD
   assign a unique and non-overlapping range of seq_nums to each SSV
   RPCSEC_GSS handle. The size of each range SHOULD be equal to MAXSEQ
   / N (see Section 5 of <xref target="RFC2203"/> for the definition
   of MAXSEQ). When an SSV RPCSEC_GSS handle reaches its maximum, it
   SHOULD force the replier to destroy the handle by sending a NULL
   RPC request with seq_num set to MAXSEQ + 1 (see Section 5.3.3.3 of
   <xref target="RFC2203"/>).

  </t>

  <t>
   When the requester wants to increase or decrease N, it SHOULD force
   the replier to destroy all N handles by sending a NULL RPC request on
   each handle with seq_num set to MAXSEQ + 1. If the requester is the
   client, it SHOULD send a SET_SSV operation before using new handles.
   If the requester is the server, then the client SHOULD send a SET_SSV
   operation when it detects that the server has forced it to destroy a
   backchannel's SSV RPCSEC_GSS handle. By sending a SET_SSV operation,
   the SSV will change, and so the attacker will be unavailable to
   successfully replay a previous verifier in a reply to the requester.

  </t>

  </list>
  </t>

  <t>
    Note that if the replier carefully creates the SSV RPCSEC_GSS
    handles, the related risk of a man-in-the-middle splicing a forged
    SSV RPCSEC_GSS credential with a verifier for another handle does
    not exist. This is because the verifier in an RPCSEC_GSS request
    is computed from input that includes both the RPCSEC_GSS handle and
    seq_num (see Section 5.3.1 of <xref target="RFC2203"/>). Provided the
    replier takes care to avoid re-using the value of an RPCSEC_GSS
    handle that it creates, such as by including a generation number in the
    handle, the man-in-the-middle will not be able to successfully replay
    a previous verifier in the request to a replier.

  </t>

  </section>

  <section anchor="Session Mechanics - Steady State" title="Session Mechanics - Steady State">

   <section anchor="Obligations of the Server" title="Obligations of the Server">
   <t>
    The server has the primary obligation to monitor the
    state of backchannel resources that the client has
    created for the server (RPCSEC_GSS contexts and backchannel
    connections). If these resources vanish, the
    server takes action as specified in <xref target="Events Requiring Server Action" />.
   </t>
   </section> <!-- Obligations of the Server -->

   <section anchor="Obligations_of_the_Client" title="Obligations of the Client">
   <t>
   The client SHOULD honor the following obligations in order to
   utilize the session:
   <list style="symbols">
   <t>
     Keep a necessary session from going idle on the server. A client
     that requires a session but nonetheless is not
     sending operations risks having the session be destroyed
     by the server. This is because sessions consume
     resources, and resource limitations may force the
     server to cull an inactive session. A server MAY consider
     a session to be inactive if the client has not used
     the session before the session inactivity timer (<xref
     target="session_inactive"/>) has expired.

   </t>
   <t>
     Destroy the session when not needed. If a client has
     multiple sessions, one of which has no
     requests waiting for replies, and has been idle for
     some period of time, it SHOULD destroy the session.
   </t>
   <t>
     Maintain GSS contexts and RPCSEC_GSS handles
     for the backchannel. If the client
     requires the server to use the RPCSEC_GSS security
     flavor for callbacks, then it needs to be sure the
     RPCSEC_GSS handles and/or their GSS
     contexts that are handed to the server via BACKCHANNEL_CTL or
     CREATE_SESSION are unexpired.
   </t>
   <t>
     Preserve a connection for a backchannel. The server
     requires a backchannel in order to gracefully recall
     recallable state or notify the client of certain
     events. Note that if the connection is not being used
     for the fore channel, there is no way for the client to tell
     if the connection is still alive (e.g., the server
     restarted without sending a disconnect). The onus is
     on the server, not the client, to determine if the
     backchannel's connection is alive, and to indicate in
     the response to a SEQUENCE operation when the last
     connection associated with a session's backchannel
     has disconnected.

   </t>
   </list>
   </t>
   </section> <!-- Obligations of the Client -->

   <section anchor="Steps the Client Takes To Establish a Session" title="Steps the Client Takes to Establish a Session">
   <t>
     If the client does not have a client ID, the client
     sends EXCHANGE_ID to establish a client ID.  If it
     opts for SP4_MACH_CRED or SP4_SSV protection, in the
     spo_must_enforce list of operations, it SHOULD at
     minimum specify CREATE_SESSION, DESTROY_SESSION,
     BIND_CONN_TO_SESSION, BACKCHANNEL_CTL, and DESTROY_CLIENTID.
     If it opts for SP4_SSV protection, the client needs to
     ask for SSV-based RPCSEC_GSS handles.

   </t>
   <t>
     The client uses the client ID to send a
     CREATE_SESSION on a connection to the server.
     The results of CREATE_SESSION indicate whether or not the
     server will persist the session reply cache through
     a server that has restarted, and the client notes this
     for future reference.

   </t>
   <t>
     If the client specified SP4_SSV state protection
     when the client ID was created, then it SHOULD send
     SET_SSV in the first COMPOUND after the session is
     created. Each time a new principal goes to use the
     client ID, it SHOULD send a SET_SSV again.

   </t>
   <t>
     If the client wants to use delegations, layouts,
     directory notifications, or any other state that
     requires a backchannel, then it needs to add a connection
     to the backchannel if CREATE_SESSION did not already
     do so.  The client creates a connection, and calls
     BIND_CONN_TO_SESSION to associate the connection
     with the session and the session's backchannel. If
     CREATE_SESSION did not already do so, the client MUST
     tell the server what security is required in order
     for the client to accept callbacks. The client does
     this via BACKCHANNEL_CTL. If the client selected
     SP4_MACH_CRED or SP4_SSV protection when it called
     EXCHANGE_ID, then the client SHOULD specify that the
     backchannel use RPCSEC_GSS contexts for security.

   </t>
   <t>
     If the client wants to use additional
     connections for the backchannel, then it needs to call
     BIND_CONN_TO_SESSION on each connection it wants to
     use with the session. If the client wants to use
     additional connections for the fore channel, then
     it needs to call BIND_CONN_TO_SESSION if it specified
     SP4_SSV or SP4_MACH_CRED state protection when the
     client ID was created.

   </t>

   <t>
     At this point, the session has reached steady state.
   </t>
   </section> <!-- Steps the Client Takes To Establish a Session -->
  </section> <!-- Session Mechanics - Steady State -->

  <section anchor="session_inactive" title="Session Inactivity Timer" >
  <t>
   The server MAY maintain a session inactivity timer for
   each session.  If the session inactivity timer expires,
   then the server MAY destroy the session. To avoid losing
   a session due to inactivity, the client MUST renew
   the session inactivity timer. The length of session
   inactivity timer MUST NOT be less than the lease_time
   attribute (<xref target="attrdef_lease_time"/>).
   As with lease renewal (<xref target="lease_renewal"/>),
   when the server receives a SEQUENCE operation,
   it resets the session inactivity timer, and MUST NOT allow the
   timer to expire while the rest of the operations in the
   COMPOUND procedure's request are still executing. Once the
   last operation has finished, the server MUST set the session
   inactivity timer to expire no sooner than the sum of the
   current time and the value of the lease_time attribute.
  </t>

  </section>
  <section anchor="Session Mechanics - Recovery" title="Session Mechanics - Recovery">


   <section anchor="Events Requiring Client Action" title="Events Requiring Client Action">

   <t>
   The following events require client action to recover.
   </t>
   <section title="RPCSEC_GSS Context Loss by Callback Path">
   <t>
    If all RPCSEC_GSS handles
    granted by the client to the server for callback use have
    expired, the client MUST
    establish a new handle via BACKCHANNEL_CTL. The
    sr_status_flags field of the SEQUENCE results indicates when callback handles
    are nearly expired, or fully expired (see <xref target="OP_SEQUENCE_DESCRIPTION"/>).
   </t>
   </section> <!-- RPCSEC_GSS Context Loss by Callback Path -->
   <section title="Connection Loss">
   <t>
    If the client loses the last connection of the session
    and wants to retain the session, then it needs to
    create a new connection, and if, when the client
    ID was created, BIND_CONN_TO_SESSION was specified
    in the spo_must_enforce list, the client MUST use
    BIND_CONN_TO_SESSION to associate the connection with
    the session.

   </t>
   <t>
    If there was a request outstanding at the time
    of connection loss, then if the client wants to continue
    to use the session, it MUST retry the request, as
    described in
    <xref target="Retry and Replay" />. Note that it
    is not necessary to retry requests over a connection
    with the same source network address or the same
    destination network address as the lost connection. As
    long as the session ID, slot ID, and sequence ID in the
    retry match that of the original request, the server
    will recognize the request as a retry if it executed
    the request prior to disconnect.

   </t>
   <t>
    If the connection that was lost was the last one associated with
    the backchannel, and the client wants to retain the backchannel and/or
    prevent revocation of recallable state, the client needs to
    reconnect, and if it does, it
    MUST associate the connection to the session and backchannel via
    BIND_CONN_TO_SESSION.
    The server SHOULD indicate when it has no callback connection
    via the sr_status_flags result from SEQUENCE.
   </t>
   </section> <!-- Connection Disconnect -->
   <section title="Backchannel GSS Context Loss">
   <t>
    Via the sr_status_flags result of the SEQUENCE operation or
    other means, the client will learn if some or all of
    the RPCSEC_GSS contexts it assigned to the backchannel have
    been lost. If the client wants to retain the backchannel and/or
    not put recallable state subject to revocation,
    the client needs to use BACKCHANNEL_CTL to
    assign new contexts.
   </t>
   </section> <!-- Backchannel GSS Context Loss -->

    <section anchor="loss_of_session" title="Loss of Session">
    <t>
     The replier might lose a record of the session. Causes include:
     <list style="symbols">
      <t>
        Replier failure and restart.
      </t>
      <t>
        A catastrophe that causes the reply cache to be corrupted or
        lost on the media on which it was stored. This applies
        even if the replier indicated in the CREATE_SESSION results
        that it would persist the cache.
      </t>
      <t>
        The server purges the session of a client that has been
        inactive for a very extended period of time.
      </t>
      <t>
        As a result of configuration changes among a set of clustered
        servers, a network address previously connected to one 
        server becomes connected to a different server that has
        no knowledge of the session in question.  Such a configuration
        change will generally only happen when the original server
        ceases to function for a time.
      </t>
     </list>
     Loss of reply cache is equivalent to loss of session.
     The replier indicates loss of session to the requester
     by returning NFS4ERR_BADSESSION on the next operation
     that uses the session ID that refers to the lost
     session.
    </t>
    <t>
     After an event like a server restart, the client may have
     lost its connections. The client assumes for the moment
     that the session has not been lost. It reconnects, and
     if it specified connection association enforcement when
     the session was created, it 
     invokes BIND_CONN_TO_SESSION using the session ID. Otherwise,
     it invokes SEQUENCE. If
     BIND_CONN_TO_SESSION or SEQUENCE returns NFS4ERR_BADSESSION, the
     client knows the session is not available to it when communicating
     with that network address. If the connection survives
     session loss, then the next SEQUENCE operation the client
     sends over the connection will get back NFS4ERR_BADSESSION.
     The client again knows the session was lost.
    </t>
    <t>
     Here is one suggested algorithm for the client when it gets 
     NFS4ERR_BADSESSION.  It is not obligatory in that, if a 
     client does not want to take advantage of such features as 
     trunking, it may omit parts of it.  However, it is a useful
     example that draws attention to various possible recovery 
     issues:
     <list style="numbers">
       <t>
         If the client has other connections to
         other server network addresses
         associated with the same session, attempt
         a COMPOUND with a single operation, SEQUENCE,
         on each of the other connections.
       </t>
       <t>
         If the attempts succeed, the session is still alive,
         and this is a strong indicator that the server's
         network address has moved.
         The client might send an EXCHANGE_ID on the
         connection that returned NFS4ERR_BADSESSION
         to see if there are opportunities for client ID
         trunking (i.e., the same client ID and so_major are
         returned). The client might use DNS to see if
         the moved network address was replaced with another,
         so that the performance and availability benefits of
         session trunking can continue.
       </t>
       <t>
         If the SEQUENCE requests fail with NFS4ERR_BADSESSION,
         then the session no longer exists on any of the
         server network addresses for which the client has connections
         associated with that session ID. It is possible the
         session is still alive and available on other
         network addresses. The client sends an EXCHANGE_ID
         on all the connections to see if the server owner
         is still listening on those network addresses.
         If the same server owner is returned but a new
         client ID is returned, this is a strong
         indicator of a server restart. If both the same
         server owner and same client ID are
         returned, then this is a strong indication
         that the server did delete the session, and the
         client will need to send a CREATE_SESSION if it
         has no other sessions for that client ID.
         If a different server owner is returned,
         the client can use DNS to find
         other network addresses. If it does not, or if
         DNS does not find any other addresses for the server,
         then the client will be unable to provide NFSv4.1
         service, and fatal errors should be returned
         to processes that were using the server. If the
         client is using a "mount" paradigm, unmounting
         the server is advised.
       </t>
       <t>
         If the client knows of no other connections associated
         with the session ID and server network addresses that
         are, or have been, associated with the session ID,
         then the client can use DNS to find
         other network addresses. If it does not, or if
         DNS does not find any other addresses for the server,
         then the client will be unable to provide NFSv4.1
         service, and fatal errors should be returned
         to processes that were using the server. If the
         client is using a "mount" paradigm, unmounting
         the server is advised.
       </t>
     </list>
    </t>
    <t>
      If there is a reconfiguration event that results in the 
      same network address being assigned to servers where the 
      eir_server_scope value is different, it cannot be guaranteed
      that a session ID generated by the first will be recognized
      as invalid by the first.  Therefore, in managing server
      reconfigurations among servers with different server scope
      values, it is necessary to make sure that all clients have
      disconnected from the first server before effecting
      the reconfiguration.  Nonetheless, clients should not
      assume that servers will always adhere to this requirement;
      clients MUST be prepared to deal with unexpected
      effects of server reconfigurations.
      Even where a session ID is inappropriately 
      recognized as valid, it is likely either that the connection 
      will not be recognized as valid or that a sequence value
      for a slot will not be correct.  Therefore, when a client
      receives results indicating such unexpected errors, the use of
      EXCHANGE_ID to determine the current server configuration
      is RECOMMENDED.
    </t>
    <t>
      A variation on the above is that after a server's network 
      address moves, there is no NFSv4.1 server listening, e.g., no 
      listener on port 2049. In this example, one of the following occur: the NFSv4 server returns 
      NFS4ERR_MINOR_VERS_MISMATCH, the NFS server returns a 
      PROG_MISMATCH error, the RPC listener on 2049 returns 
      PROG_UNVAIL, or attempts to reconnect to the network address 
      timeout. These SHOULD be treated as equivalent to SEQUENCE 
      returning NFS4ERR_BADSESSION for these purposes.
    </t>
    <t>
     When the client detects session loss, it needs to call CREATE_SESSION
     to recover.  Any non-idempotent operations that were in progress
     might have been performed on the server at the time of
     session loss. The client has no general way to recover from this.
    </t>
    <t>
     Note that loss of session does not imply loss of byte-range lock, open, delegation,
     or layout state because locks, opens, delegations, and layouts
     are tied to the client ID and depend on the client ID, not the session.
     Nor does loss of byte-range lock, open, delegation,
     or layout state imply loss of session state, because the session depends
     on the client ID; loss of client ID however does imply loss of
     session, byte-range lock, open, delegation, and layout state.
     See <xref target="server_failure" />.
     A session can survive a server restart,
     but lock recovery may still be needed.
    </t>
    <t>
     It is possible that CREATE_SESSION will fail with NFS4ERR_STALE_CLIENTID
     (e.g., the server restarts and does not preserve client ID
     state).
     If so, the client needs to call EXCHANGE_ID, followed by 
     CREATE_SESSION.
    </t>
    </section> <!-- Loss of Session -->
   </section> <!-- Events Requiring Client Action -->

   <section anchor="Events Requiring Server Action" title="Events Requiring Server Action">
   <t>
     The following events require server action to recover.
   </t>
    <section title="Client Crash and Restart">
    <t>
    As described in <xref target="OP_EXCHANGE_ID" />,
    a restarted client sends EXCHANGE_ID in such a way that it
    causes the server to delete any sessions it had.
    </t>
    </section> <!-- Client Crash and Restart -->
    <section title="Client Crash with No Restart" anchor="client_crash_no_restart">
    <t>
    If a client crashes and never comes back, it will never send
    EXCHANGE_ID with its old client owner. Thus, the server has session
    state that will never be used again. After an extended period of time,
    and if the server has resource constraints, it MAY destroy the old
    session as well as locking state.
    </t>
    </section> <!-- Client Crash with No Restart -->
    <section title="Extended Network Partition">
    <t>
     To the server, the extended network partition may be no
     different from a
     client crash with no
     restart (see
     <xref target="client_crash_no_restart" />).
     Unless the server can discern that there is
     a network partition, it is free to treat the
     situation as if the client has crashed permanently.
    </t>
    </section> <!-- "Extended Network Partition" -->
    <section title="Backchannel Connection Loss">
    <t>
     If there were callback requests outstanding at the time
     of a connection loss, then the server
     MUST retry the requests, as described in
     <xref target="Retry and Replay" />. Note that it
     is not necessary to retry requests over a connection
     with the same source network address or the same destination
     network address as the lost connection. As long as
     the session ID, slot ID, and sequence ID in the retry
     match that of the original request, the callback target will
     recognize the request as a retry even if it did see the request
     prior to disconnect.
    </t>
    <t>
     If the connection lost is the last one associated with the backchannel,
     then the server MUST indicate that in the sr_status_flags field of
     every SEQUENCE reply until the backchannel is re-established.
     There are two situations, each of which uses different
     status flags: no connectivity for the session's backchannel
     and no connectivity for any session backchannel of the client.
     See <xref target="OP_SEQUENCE" /> for a description of
     the appropriate flags in sr_status_flags.
    </t>
    </section> <!-- Backchannel Connection Loss -->
    <section title="GSS Context Loss">
    <t>
     The server SHOULD monitor when the number of RPCSEC_GSS
     handles assigned to the backchannel reaches one, and when that
     one handle is near expiry (i.e., between
     one and two periods of lease time), and
     indicate so in the sr_status_flags field of all SEQUENCE replies.
     The server MUST indicate when all of the
     backchannel's assigned RPCSEC_GSS handles
     have expired via the sr_status_flags field of all SEQUENCE replies.
    </t>
    </section> <!-- GSS Context Loss -->
   </section> <!-- Events Requiring Server Action -->
  </section> <!-- Session Mechanics - Recovery -->
  <section title="Parallel NFS and Sessions" anchor="pnfs_and_sessions">
  <t>
   A client and server can potentially be a non-pNFS implementation,
   a metadata server implementation, a data server implementation, or two or
   three types of implementations. The EXCHGID4_FLAG_USE_NON_PNFS,
   EXCHGID4_FLAG_USE_PNFS_MDS, and EXCHGID4_FLAG_USE_PNFS_DS flags
   (not mutually exclusive) are passed in the EXCHANGE_ID arguments
   and results to allow the client to indicate how it wants to use sessions created
   under the client ID, and to allow the server to indicate how it
   will allow the sessions to be used.
   See <xref target="pnfs_session_stuff" /> for pNFS sessions considerations.
  </t>
  </section> <!-- Parallel NFS and Sessions -->
 </section> <!-- Session -->
</section> <!-- Core Infrastructure -->
<!-- 	$Id: 2009-12-20-TO-rfc5661.xml,v 1.2 2009/12/21 05:59:32 shepler.mre Exp $	 -->
<!-- Copyright (C) The IETF Trust (2007-2008) -->
<!-- Copyright (C) The Internet Society (2006) -->
<section title="Protocol Constants and Data Types">
  <t>
    The syntax and semantics to describe the data types of the NFSv4.1
    protocol are defined in the XDR <xref target="RFC4506">RFC 4506</xref> and RPC 
    <xref target="RFC5531">RFC 5531</xref> documents.  The next sections
    build upon the XDR data types to define constants, types, and structures
    specific to this protocol. The full list of XDR data types is in <xref target="RFC5662" />.
  </t>

  <section title="Basic Constants">
<figure>
 <artwork>
const NFS4_FHSIZE               = 128;
const NFS4_VERIFIER_SIZE        = 8;
const NFS4_OPAQUE_LIMIT         = 1024;
const NFS4_SESSIONID_SIZE       = 16;

const NFS4_INT64_MAX            = 0x7fffffffffffffff;
const NFS4_UINT64_MAX           = 0xffffffffffffffff;
const NFS4_INT32_MAX            = 0x7fffffff;
const NFS4_UINT32_MAX           = 0xffffffff;

const NFS4_MAXFILELEN           = 0xffffffffffffffff;
const NFS4_MAXFILEOFF           = 0xfffffffffffffffe;
 </artwork>
</figure>
  <t>
    Except where noted, all these constants are defined in bytes.
    <list style="symbols">
    <t>
       NFS4_FHSIZE is the maximum size of a filehandle.
    </t>
    <t>
       NFS4_VERIFIER_SIZE is the fixed size of a verifier.
    </t>
    <t>
       NFS4_OPAQUE_LIMIT is the maximum size of certain
       opaque information.
    </t>
    <t>
       NFS4_SESSIONID_SIZE is the fixed size of a session identifier.
    </t>
    <t>
       NFS4_INT64_MAX is the maximum value of a signed 64-bit integer.
    </t>
    <t>
       NFS4_UINT64_MAX is the maximum value of an unsigned 64-bit integer.
    </t>
    <t>
       NFS4_INT32_MAX is the maximum value of a signed 32-bit integer.
    </t>
    <t>
       NFS4_UINT32_MAX is the maximum value of an unsigned 32-bit integer.
    </t>
    <t>
       NFS4_MAXFILELEN is the maximum length of a regular file.
    </t>
    <t>
       NFS4_MAXFILEOFF is the maximum offset into a regular file.
    </t>
    </list>
  </t>
  </section>

  <section title="Basic Data Types">
      <t>
	These are the base NFSv4.1 data types.
      </t>
    <texttable anchor='basic_data_types'>

      <ttcol align='left'>Data Type</ttcol>
      <ttcol align='left'>Definition</ttcol>
	<c>int32_t</c>		<c>typedef int int32_t;</c>

	<c>uint32_t</c>		<c>typedef unsigned int uint32_t;</c>

	<c>int64_t</c>		<c>typedef hyper int64_t;</c>

	<c>uint64_t</c>		<c>typedef unsigned hyper uint64_t;</c>

	<c>attrlist4</c>		<c>typedef opaque attrlist4&lt;>;</c>
	<c/>	<c>Used for file/directory attributes.</c>

	<c>bitmap4</c>		<c>typedef uint32_t bitmap4&lt;>;</c>
	<c/>	<c>Used in attribute array encoding.</c>

	<c>changeid4</c>		<c>typedef uint64_t changeid4;</c>
	<c/>	<c>Used in the definition of change_info4.</c>

	<c>clientid4</c>		<c>typedef uint64_t clientid4;</c>
	<c/>	<c>Shorthand reference to client identification.</c>

	<c>count4</c>		<c>typedef uint32_t count4;</c>
	<c/>	<c>Various count parameters (READ, WRITE, COMMIT).</c>

	<c>length4</c>		<c>typedef uint64_t length4;</c>
	<c/>	<c>The length of a byte-range within a file.</c>

	<c>mode4</c>		<c>typedef uint32_t mode4;</c>
	<c/>	<c>Mode attribute data type.</c>

	<c>nfs_cookie4</c>		<c>typedef uint64_t nfs_cookie4;</c>
	<c/>	<c>Opaque cookie value for READDIR.</c>

	<c>nfs_fh4</c>		<c>typedef opaque nfs_fh4&lt;NFS4_FHSIZE>;</c>
	<c/>	<c>Filehandle definition.</c>

	<c>nfs_ftype4</c>		<c>enum nfs_ftype4;</c>
	<c/>	<c>Various defined file types.</c>

	<c>nfsstat4</c>		<c>enum nfsstat4;</c>
	<c/>	<c>Return value for operations.</c>

	<c>offset4</c>		<c>typedef uint64_t offset4;</c>
	<c/>	<c>Various offset designations (READ, WRITE, LOCK, COMMIT).</c>

	<c>qop4</c>		<c>typedef uint32_t qop4;</c>
	<c/>	<c>Quality of protection designation in SECINFO.</c>

	<c>sec_oid4</c>		<c>typedef opaque sec_oid4&lt;>;</c>
	<c/>	<c>Security Object Identifier. The sec_oid4 data type is not really opaque. Instead, it contains an ASN.1 OBJECT IDENTIFIER as used by GSS-API in the mech_type argument to GSS_Init_sec_context. See <xref target="RFC2743" /> for details.</c>

	<c>sequenceid4</c>		<c>typedef uint32_t sequenceid4;</c>
	<c/>	<c>Sequence number used for various session operations (EXCHANGE_ID, CREATE_SESSION, SEQUENCE, CB_SEQUENCE).</c>

	<c>seqid4</c>		<c>typedef uint32_t seqid4;</c>
	<c/>	<c>Sequence identifier used for locking.</c>

	<c>sessionid4</c>		<c>typedef opaque sessionid4[NFS4_SESSIONID_SIZE];</c>
	<c/>	<c>Session identifier.</c>

	<c>slotid4</c>		<c>typedef uint32_t slotid4;</c>
	<c/>	<c>Sequencing artifact for various session operations (SEQUENCE, CB_SEQUENCE).</c>

	<c>utf8string</c>		<c>typedef opaque utf8string&lt;>;</c>
	<c/>	<c>UTF-8 encoding for strings.</c>

	<c>utf8str_cis</c>		<c>typedef utf8string utf8str_cis;</c>
	<c/>	<c>Case-insensitive UTF-8 string.</c>

	<c>utf8str_cs</c>		<c>typedef utf8string utf8str_cs;</c>
	<c/>	<c>Case-sensitive UTF-8 string.</c>

	<c>utf8str_mixed</c>		<c>typedef utf8string utf8str_mixed;</c>
	<c/>	<c>UTF-8 strings with a case-sensitive prefix and a
	case-insensitive suffix.</c>

	<c>component4</c>		<c>typedef utf8str_cs component4;</c>
	<c/>	<c>Represents pathname components.</c>

	<c>linktext4</c>		<c>typedef utf8str_cs linktext4;</c>
	<c/>	<c>Symbolic link contents ("symbolic link" is defined in an <xref target="symlink">Open Group</xref> standard).</c>

	<c>pathname4</c>		<c>typedef component4 pathname4&lt;>;</c>
	<c/>	<c>Represents pathname for fs_locations.</c>

	<c>verifier4</c>		<c>typedef opaque verifier4[NFS4_VERIFIER_SIZE];</c>
	<c/>	<c>Verifier used for various operations (COMMIT, CREATE, EXCHANGE_ID, OPEN, READDIR, WRITE) NFS4_VERIFIER_SIZE is defined as 8.</c>

      <postamble>End of Base Data Types</postamble>
    </texttable>
  </section>

  <!-- start here for the structured data types -->

  <section title="Structured Data Types">

    <section toc="exclude" anchor="nfstime4" title="nfstime4">
<figure>
 <artwork>
struct nfstime4 {
        int64_t         seconds;
        uint32_t        nseconds;
};
 </artwork>
</figure>
      <t>
	The nfstime4 data type gives the number of seconds and
	nanoseconds since midnight or zero hour January 1, 1970
	Coordinated Universal Time (UTC).  Values greater than zero
	for the seconds field denote dates after the zero hour January 1,
	1970.  Values less than zero for the seconds field denote
	dates before the zero hour January 1, 1970.  In both cases, the
	nseconds field is to be added to the seconds field for the
	final time representation.  For example, if the time to be
	represented is one-half second before zero hour January 1, 1970,
	the seconds field would have a value of negative one (-1) and
	the nseconds field would have a value of one-half second
	(500000000).  Values greater than 999,999,999 for nseconds are
	invalid.
      </t>
      <t>
	This data type is used to pass time and date information.  A
	server converts to and from its local representation of time
	when processing time values, preserving as much accuracy as
	possible. If the precision of timestamps stored for a
	file system object is less than defined, loss of precision can
	occur.  An adjunct time maintenance protocol is RECOMMENDED to
	reduce client and server time skew.
      </t>
    </section>

    <section toc="exclude" anchor="time_how4" title="time_how4">
<figure>
 <artwork>
enum time_how4 {
        SET_TO_SERVER_TIME4 = 0,
        SET_TO_CLIENT_TIME4 = 1
};
 </artwork>
</figure>
    </section>

    <section toc="exclude" anchor="settime4" title="settime4">
<figure>
 <artwork>
union settime4 switch (time_how4 set_it) {
 case SET_TO_CLIENT_TIME4:
         nfstime4       time;
 default:
         void;
};
 </artwork>
</figure>
      <t>
	The time_how4 and settime4 data types are used
	for setting timestamps in file object attributes.  If set_it is SET_TO_SERVER_TIME4, then the server
	uses its local representation of time for the time value.
      </t>
    </section>

    <section toc="exclude" anchor="specdata4" title="specdata4">
<figure>
 <artwork>
struct specdata4 {
 uint32_t specdata1; /* major device number */
 uint32_t specdata2; /* minor device number */
};
 </artwork>
</figure>
      <t>
	This data type represents the device numbers for the device file
	types NF4CHR and NF4BLK.
      </t>
    </section>

    <section toc="exclude" anchor="fsid4" title="fsid4">
<figure>
 <artwork>
struct fsid4 {
        uint64_t        major;
        uint64_t        minor;
};
 </artwork>
</figure>
    </section>

    <section toc="exclude" anchor="chg_policy4" title="change_policy4">
<figure>
 <artwork>
struct change_policy4 {
        uint64_t        cp_major;
        uint64_t        cp_minor;
};
 </artwork>
</figure>
      <t>
         The change_policy4 data type is used for the change_policy
         RECOMMENDED attribute.  It provides change sequencing indication
         analogous to the change attribute.  To enable the server to 
         present a value valid across server re-initialization without
         requiring persistent storage, two 64-bit quantities are used,
         allowing one to be a server instance ID and the second to be
         incremented non-persistently, within a given server instance.
      </t>
    </section>

    <section toc="exclude" anchor="fattr4" title="fattr4">
<figure>
 <artwork>
struct fattr4 {
        bitmap4         attrmask;
        attrlist4       attr_vals;
};
 </artwork>
</figure>
      <t>
	The fattr4 data type is used to represent file and directory attributes.
      </t>
      <t>
	The bitmap is a counted array of 32-bit integers used to contain bit
	values.  The position of the integer in the array that contains bit n
	can be computed from the expression (n / 32), and its bit within that
	integer is (n mod 32).
      </t>
      <t>
	<figure>
	  <artwork>
0            1       
+-----------+-----------+-----------+--
|  count    | 31  ..  0 | 63  .. 32 |  
+-----------+-----------+-----------+--
	  </artwork>
	</figure>
      </t>
    </section>

    <section toc="exclude" anchor="change_info4" title="change_info4">
<figure>
 <artwork>
struct change_info4 {
        bool            atomic;
        changeid4       before;
        changeid4       after;
};
 </artwork>
</figure>
      <t>
	This data type is used with the CREATE, LINK, OPEN, REMOVE, and RENAME
	operations to let the client know the value of the change attribute
	for the directory in which the target file system object resides.
      </t>
    </section>

    <section toc="exclude" anchor="netaddr4" title="netaddr4">
<figure>
 <artwork>
struct netaddr4 {
        /* see struct rpcb in RFC 1833 */
        string na_r_netid&lt;>; /* network id */
        string na_r_addr&lt;>;  /* universal address */
};
 </artwork>
</figure>
      <t>
	The netaddr4 data type is used to identify network transport endpoints.
	The r_netid and r_addr fields respectively contain a netid
        and uaddr. The netid and uaddr concepts are defined in
	<xref target="RFC5665"/>. The netid and uaddr formats for
        TCP over IPv4 and TCP over IPv6 are defined in <xref target="RFC5665"/>,
        specifically Tables 2 and 3 and Sections 5.2.3.3 and 5.2.3.4.
      </t>

    </section>

    <section toc="exclude" anchor="state_owner4" title="state_owner4">
<figure>
 <artwork>
struct state_owner4 {
        clientid4       clientid;
        opaque          owner&lt;NFS4_OPAQUE_LIMIT>;
};

typedef state_owner4 open_owner4;
typedef state_owner4 lock_owner4;
 </artwork>
</figure>
    <t>
     The state_owner4 data type is the base type for the 
     open_owner4 (<xref target="open_owner4" />) and
     lock_owner4 (<xref target="lock_owner4" />.
    </t>

     <section toc="exclude" anchor="open_owner4" title="open_owner4">
       <t>
	 This data type is used to identify the owner of OPEN state.
       </t>
     </section>

     <section toc="exclude" anchor="lock_owner4" title="lock_owner4">
       <t>
	 This structure is used to identify the owner of byte-range
         locking state.
       </t>
     </section>
    </section>

    <section toc="exclude" anchor="open_to_lock_owner4" 
	     title="open_to_lock_owner4">
<figure>
 <artwork>
struct open_to_lock_owner4 {
        seqid4          open_seqid;
        stateid4        open_stateid;
        seqid4          lock_seqid;
        lock_owner4     lock_owner;
};
 </artwork>
</figure>
      <t>
	This data type is used for the first LOCK operation done for
	an open_owner4.  It provides both the open_stateid and
	lock_owner, such that the transition is made from a valid
	open_stateid sequence to that of the new lock_stateid
	sequence.  Using this mechanism avoids the confirmation of the
	lock_owner/lock_seqid pair since it is tied to established
	state in the form of the open_stateid/open_seqid.
      </t>
    </section>

    <section toc="exclude" anchor="stateid4" title="stateid4">
<figure>
 <artwork>
struct stateid4 {
        uint32_t        seqid;
        opaque          other[12];
};
 </artwork>
</figure>
      <t>
	This data type is used for the various state sharing
	mechanisms between the client and server.  The client
	never modifies a value of data type stateid.
        The starting value of the
	"seqid" field is undefined.  The server is required to
	increment the "seqid" field by one at each transition
	of the stateid.  This is important since the client will
	inspect the seqid in OPEN stateids to determine the order of
	OPEN processing done by the server.
      </t>
    </section>

    <section toc="exclude" anchor="layouttype4" title="layouttype4">
<figure>
 <artwork>
enum layouttype4 {
        LAYOUT4_NFSV4_1_FILES   = 0x1,
        LAYOUT4_OSD2_OBJECTS    = 0x2,
        LAYOUT4_BLOCK_VOLUME    = 0x3
};
 </artwork>
</figure>

      <t>
	This data type indicates what type of layout is being used.
	The file server advertises the
	layout types it supports through the fs_layout_type file
	system attribute (<xref target="attrdef_fs_layout_type" />).
	A client asks for layouts of a particular type in LAYOUTGET,
	and processes those layouts in its layout-type-specific logic.
      </t>
      <t>
	The layouttype4 data type is 32 bits in length.  The range
	represented by the layout type is split into three parts.  Type
        0x0 is reserved. Types
	within the range 0x00000001-0x7FFFFFFF are globally unique and
	are assigned according to the description in <xref
	target="pnfsiana" />; they are maintained by IANA.  Types
	within the range 0x80000000-0xFFFFFFFF are site specific and
	for private use only.
      </t>
      <t>
	The LAYOUT4_NFSV4_1_FILES enumeration specifies that the NFSv4.1
	file layout type, as defined in <xref target="file_layout_type" />, is to be used.  The LAYOUT4_OSD2_OBJECTS
	enumeration specifies that the object layout, as defined in
	<xref target="RFC5664" />, is to be used.  Similarly,
	the LAYOUT4_BLOCK_VOLUME enumeration specifies that the block/volume
	layout, as defined in <xref target="RFC5663" />, is to be
	used.
      </t>
    </section>

    <section toc="exclude" anchor="deviceid4" title="deviceid4">
<figure>
 <artwork>
const NFS4_DEVICEID4_SIZE = 16;

typedef opaque  deviceid4[NFS4_DEVICEID4_SIZE];
 </artwork>
</figure>
      <t>
	Layout information includes device IDs that
	specify a storage device through a compact handle.
	Addressing and type information is obtained
	with the GETDEVICEINFO operation.  Device IDs
	are not guaranteed to be valid across metadata
	server restarts.  A device ID is unique per client
	ID and layout type.  See <xref target="device_ids"
	/> for more details.

      </t>
    </section>
    <section toc="exclude" anchor="device_addr4"
	     title="device_addr4">
<figure>
 <artwork>
struct device_addr4 {
        layouttype4             da_layout_type;
        opaque                  da_addr_body&lt;>;
};
 </artwork>
</figure>
      <t>
        The device address is used to set up a communication channel
        with the storage device.  Different layout types will require
        different data types to define how they communicate
        with storage devices.  The opaque da_addr_body field is
        interpreted based on the specified da_layout_type field.
      </t>
      <t>
        This document defines the device address for the NFSv4.1 file
        layout (see <xref target="file_data_types" />), which
        identifies a storage device by network IP address and port
        number.  This is sufficient for the clients to communicate
        with the NFSv4.1 storage devices, and may be sufficient for
        other layout types as well.  Device types for object-based storage
        devices and block storage devices (e.g., Small Computer System
         Interface (SCSI) volume labels)
        are defined by their respective layout specifications.
      </t>
    </section>

    <section toc="exclude" anchor="layout_content4" title="layout_content4">
<figure>
 <artwork>
struct layout_content4 {
        layouttype4 loc_type;
        opaque      loc_body&lt;>;
};
 </artwork>
</figure>
      <t>
        The loc_body field is interpreted based on the layout type (loc_type). 
        This document defines the loc_body for the NFSv4.1
	file layout type; see <xref target="file_data_types"
	/> for its definition. 
      </t>
    </section>
    <section toc="exclude" anchor="layout4" title="layout4">
<figure>
 <artwork>
struct layout4 {
        offset4                 lo_offset;
        length4                 lo_length;
        layoutiomode4           lo_iomode;
        layout_content4         lo_content;
};
 </artwork>
</figure>
      <t>
	The layout4 data type defines a layout for a file.  The layout
	type specific data is opaque within lo_content.
        Since layouts are sub-dividable, the offset
	and length together with the file's filehandle, the client ID,
	iomode, and layout type identify the layout.
      </t>
    </section>

    <section toc="exclude" anchor="layoutupdate4"
	     title="layoutupdate4">
<figure>
 <artwork>
struct layoutupdate4 {
        layouttype4             lou_type;
        opaque                  lou_body&lt;>;
};
 </artwork>
</figure>
      <t>
	The layoutupdate4 data type is used by the client to return
	updated layout information to the metadata server via the
	LAYOUTCOMMIT (<xref target="OP_LAYOUTCOMMIT" />) operation.
	This data type provides a channel to pass
	layout type specific information (in field lou_body)
        back to the metadata server.
	For example, for the block/volume layout type, this could include the
	list of reserved blocks that were written.  The contents of
	the opaque lou_body argument are determined by the layout type.
	The NFSv4.1 file-based layout
	does not use this data type; if lou_type is LAYOUT4_NFSV4_1_FILES,
        the lou_body field MUST
	have a zero length.
      </t>
    </section>

    <section toc="exclude" anchor="layouthint4" title="layouthint4">
<figure>
 <artwork>
struct layouthint4 {
        layouttype4             loh_type;
        opaque                  loh_body&lt;>;
};
 </artwork>
</figure>
      <t>
	The layouthint4 data type is used by the client to pass in a
	hint about the type of layout it would like created for a particular
	file.  It is the data type specified by the layout_hint
	attribute described in <xref target="attrdef_layout_hint" />.
	The metadata server may ignore the hint
	or may selectively ignore fields within the hint.  This hint should
	be provided at create time as part of the initial attributes within
	OPEN.  The loh_body field is specific to the type of layout (loh_type).
        The NFSv4.1 file-based layout uses the nfsv4_1_file_layouthint4
	data type as defined in <xref target="file_data_types" />.
      </t>
    </section>


    <section toc="exclude" anchor="layoutiomode4"
	     title="layoutiomode4">
<figure>
 <artwork>
enum layoutiomode4 {
        LAYOUTIOMODE4_READ      = 1,
        LAYOUTIOMODE4_RW        = 2,
        LAYOUTIOMODE4_ANY       = 3
};
 </artwork>
</figure>
      <t>
	The iomode specifies whether the client intends to just read or both
        read and write the data represented by the
	layout.  While the LAYOUTIOMODE4_ANY iomode MUST NOT be used in
        the arguments to the LAYOUTGET operation, it MAY
	be used in the arguments to the LAYOUTRETURN and CB_LAYOUTRECALL
        operations.  The LAYOUTIOMODE4_ANY iomode
	specifies that layouts pertaining to both LAYOUTIOMODE4_READ
        and LAYOUTIOMODE4_RW iomodes are being returned or recalled,
        respectively.  The metadata server's use of the iomode may
        depend on the layout type being used.  The storage devices MAY
        validate I/O accesses against the iomode and reject invalid accesses.
      </t>
    </section>

    <section toc="exclude" anchor="nfs_impl_id4" title="nfs_impl_id4">
<figure>
 <artwork>
struct nfs_impl_id4 {
        utf8str_cis   nii_domain;
        utf8str_cs    nii_name;
        nfstime4      nii_date;
};
 </artwork>
</figure>
      <t>
	This data type is used to identify client and server
	implementation details.  The nii_domain field is the DNS domain
	name with which the implementor is associated.  The nii_name
	field is the product name of the implementation and is
	completely free form.  It is RECOMMENDED that the nii_name be
	used to distinguish machine architecture, machine platforms,
	revisions, versions, and patch levels.  The nii_date field is
	the timestamp of when the software instance was published or
	built.
      </t>
    </section>

    <section toc="exclude" anchor="threshold_item4" title="threshold_item4">
<figure>
 <artwork>
struct threshold_item4 {
        layouttype4     thi_layout_type;
        bitmap4         thi_hintset;
        opaque          thi_hintlist&lt;>;
};
 </artwork>
</figure>
      <t>
	This data type contains a list of hints specific to
	a layout type for helping the client determine when
	it should send I/O directly through the metadata
	server versus the storage devices.  The data type
	consists of the layout type (thi_layout_type),
	a bitmap (thi_hintset) describing the set of
	hints supported by the server (they may differ
	based on the layout type), and a list of hints
	(thi_hintlist) whose content is determined by
	the hintset bitmap.  See the mdsthreshold attribute
	for more details.

      </t>
      <t>
        The thi_hintset field is a bitmap of the following values:
      </t>
      <texttable>
        <ttcol align='left'>name</ttcol>
        <ttcol align='left'>#</ttcol>
        <ttcol align='left'>Data Type</ttcol>
        <ttcol align='left'>Description</ttcol>
  
        <c>threshold4_read_size</c><c>0</c><c>length4</c>
        <c>
           If a file's length is less than the value of threshold4_read_size,
           then it is RECOMMENDED that the client read from the file via the MDS and not
           a storage device.

        </c>
        <c>threshold4_write_size</c><c>1</c><c>length4</c>
        <c>
           If a file's length is less than the value of threshold4_write_size,
           then it is RECOMMENDED that the client write to the file via the MDS and not
           a storage device.
        </c>
        <c>threshold4_read_iosize</c><c>2</c><c>length4</c>
        <c>
          For read I/O sizes below this threshold, it is RECOMMENDED to
  	read data through the MDS.
        </c>
        <c>threshold4_write_iosize</c><c>3</c><c>length4</c>
        <c>
          For write I/O sizes below this threshold, it is RECOMMENDED to
  	write data through the MDS.
        </c>
      </texttable>      
    </section>

    <section toc="exclude" anchor="mdsthreshold4" title="mdsthreshold4">
<figure>
 <artwork>
struct mdsthreshold4 {
        threshold_item4 mth_hints&lt;>;
};
 </artwork>
</figure>
      <t>
        This data type holds an array of elements of data type
        threshold_item4,
	each of which is valid for a particular layout type.  An array
	is necessary because a server can support multiple layout types
	for a single file.
      </t>
    </section>

  </section>
</section>

<!-- End of Data Types -->

<!-- 	$Id: 2009-12-20-TO-rfc5661.xml,v 1.2 2009/12/21 05:59:32 shepler.mre Exp $	 -->
<!-- Copyright (C) The IETF Trust (2007-2008) -->
<!-- Copyright (C) The Internet Society (2006) -->
<section anchor="Filehandles" title="Filehandles">
  <t>
    The filehandle in the NFS protocol is a per-server unique identifier
    for a file system object.  The contents of the filehandle are opaque
    to the client.  Therefore, the server is responsible for translating
    the filehandle to an internal representation of the file system
    object.
  </t>
  <section title="Obtaining the First Filehandle">
    <t>
      The operations of the NFS protocol are defined in terms of one
      or more filehandles.  Therefore, the client needs a filehandle
      to initiate communication with the server.  With the NFSv3
      protocol (<xref target="RFC1813">RFC 1813</xref>), there
      exists an ancillary protocol to obtain this first filehandle.
      The MOUNT protocol, RPC program number 100005, provides the
      mechanism of translating a string-based file system pathname to
      a filehandle, which can then be used by the NFS protocols.
    </t>
    <t>
      The MOUNT protocol has deficiencies in the area of security and
      use via firewalls.  This is one reason that the use of the
      public filehandle was introduced in <xref
      target="RFC2054">RFC 2054</xref> and <xref
      target="RFC2055">RFC 2055</xref>.  With the use of the public
      filehandle in combination with the LOOKUP operation in the NFSv3
      protocol, it has been demonstrated that the
      MOUNT protocol is unnecessary for viable interaction between NFS
      client and server.
    </t>
    <t>
      Therefore, the NFSv4.1 protocol will not use an ancillary
      protocol for translation from string-based pathnames to a filehandle.
      Two special filehandles will be used as starting points for the NFS
      client.
    </t>
    <section title="Root Filehandle">
      <t>
        The first of the special filehandles is the ROOT filehandle.  The ROOT
        filehandle is the "conceptual" root of the file system namespace at
        the NFS server.  The client uses or starts with the ROOT filehandle
        by employing the PUTROOTFH operation.  The PUTROOTFH operation
        instructs the server to set the "current" filehandle to the ROOT of
        the server's file tree.  Once this PUTROOTFH operation is used, the
        client can then traverse the entirety of the server's file tree with
        the LOOKUP operation.  A complete discussion of the server namespace
        is in <xref target="single_server_namespace"/>.
      </t>
    </section>
    <section title="Public Filehandle">
      <t>
        The second special filehandle is the PUBLIC filehandle.  Unlike the
        ROOT filehandle, the PUBLIC filehandle may be bound or represent an
        arbitrary file system object at the server.  The server is responsible
        for this binding.  It may be that the PUBLIC filehandle and the ROOT
        filehandle refer to the same file system object.  However, it is up to
        the administrative software at the server and the policies of the
        server administrator to define the binding of the PUBLIC filehandle
        and server file system object.  The client may not make any
        assumptions about this binding. The client uses the PUBLIC filehandle
        via the PUTPUBFH operation.
      </t>
    </section>
  </section>
  <section title="Filehandle Types">
    <t>
      In the NFSv3 protocol, there was one type of filehandle
      with a single set of semantics.  This type of filehandle is termed
      "persistent" in NFSv4.1.  The semantics of a persistent
      filehandle remain the same as before.  A new type of filehandle
      introduced in NFSv4.1 is the "volatile" filehandle, which
      attempts to accommodate certain server environments.
    </t>
    <t>
      The volatile filehandle type was introduced to address server
      functionality or implementation issues that make correct
      implementation of a persistent filehandle infeasible.  Some server
      environments do not provide a file-system-level invariant that can be
      used to construct a persistent filehandle.  The underlying server
      file system may not provide the invariant or the server's file system
      programming interfaces may not provide access to the needed invariant.
      Volatile filehandles may ease the implementation of server
      functionality such as hierarchical storage management or file system
      reorganization or migration.  However, the volatile filehandle
      increases the implementation burden for the client.
    </t>
    <t>
      Since the client will need to handle persistent and volatile
      filehandles differently, a file attribute is defined that may be used
      by the client to determine the filehandle types being returned by the
      server.
    </t>
    <section title="General Properties of a Filehandle">
      <t>
        The filehandle contains all the information the
        server needs to distinguish an individual file.
        To the client, the filehandle is opaque. The
        client stores filehandles for use in a later
        request and can compare two filehandles from the
        same server for equality by doing a byte-by-byte
        comparison.  However, the client MUST NOT otherwise
        interpret the contents of filehandles.  If two
        filehandles from the same server are equal, they
        MUST refer to the same file.  Servers SHOULD try
        to maintain a one-to-one correspondence between
        filehandles and files, but this is not required.
        Clients MUST use filehandle comparisons only to
        improve performance, not for correct behavior.
        All clients need to be prepared for situations
        in which it cannot be determined whether two
        filehandles denote the same object and in such
        cases, avoid making invalid assumptions that might
        cause incorrect behavior.  Further discussion
        of filehandle and attribute comparison in the
        context of data caching is presented in <xref
        target="data_caching_and_file_identity"/>.

      </t>
      <t>
        As an example, in the case that two different pathnames when
        traversed at the server terminate at the same file system object, the
        server SHOULD return the same filehandle for each path.  This can
        occur if a hard link (see <xref target="hardlink"/>) is used
        to create two file names that refer to the same underlying
        file object and associated data.  For example, if paths /a/b/c
        and /a/d/c refer to the same file, the server SHOULD return
        the same filehandle for both pathnames' traversals.
      </t>
    </section>
    <section title="Persistent Filehandle">
      <t>
        A persistent filehandle is defined as having a fixed value for the
        lifetime of the file system object to which it refers.  Once the
        server creates the filehandle for a file system object, the server
        MUST accept the same filehandle for the object for the lifetime of the
        object.  If the server restarts, the NFS server MUST honor
        the same filehandle value as it did in the server's previous
        instantiation.  Similarly, if the file system is migrated, the new NFS
        server MUST honor the same filehandle as the old NFS server.
      </t>
      <t>
        The persistent filehandle will be become stale or invalid when the
        file system object is removed.  When the server is presented with a
        persistent filehandle that refers to a deleted object, it MUST return
        an error of NFS4ERR_STALE.  A filehandle may become stale when the
        file system containing the object is no longer available.  The file
        system may become unavailable if it exists on removable media and the
        media is no longer available at the server or the file system in whole
        has been destroyed or the file system has simply been removed from the
        server's namespace (i.e., unmounted in a UNIX environment).
      </t>
    </section>
    <section title="Volatile Filehandle">
      <t>
        A volatile filehandle does not share the same longevity
        characteristics of a persistent filehandle.  The server may
        determine that a volatile filehandle is no longer valid at many
        different points in time.  If the server can definitively determine
        that a volatile filehandle refers to an object that has been removed,
        the server should return NFS4ERR_STALE to the client (as is the case
        for persistent filehandles).  In all other cases where the server
        determines that a volatile filehandle can no longer be used, it should
        return an error of NFS4ERR_FHEXPIRED.
      </t>
      <t>
        The REQUIRED attribute "fh_expire_type" is used by the client to
        determine what type of filehandle the server is providing for a
        particular file system.  This attribute is a bitmask with the
        following values:
      </t>
      <t>
        <list style="hanging">
          <t hangText="FH4_PERSISTENT">
            The value of FH4_PERSISTENT is used to indicate a persistent
            filehandle, which is valid until the object is removed from the
            file system.  The server will not return NFS4ERR_FHEXPIRED for this
            filehandle.  FH4_PERSISTENT is defined as a value in which none of the
            bits specified below are set.
          </t>
          <t hangText="FH4_VOLATILE_ANY">
            The filehandle may expire at any time, except as specifically
            excluded (i.e., FH4_NO_EXPIRE_WITH_OPEN).
          </t>
          <t hangText="FH4_NOEXPIRE_WITH_OPEN">
            May only be set when FH4_VOLATILE_ANY is set.  If this bit is set,
            then the meaning of FH4_VOLATILE_ANY is qualified to exclude any
            expiration of the filehandle when it is open.
          </t>
          <t hangText="FH4_VOL_MIGRATION">
	    The filehandle will expire as a result of a file system
	    transition (migration or replication), in those cases in
	    which the continuity of filehandle use is not specified by
	    handle class information
	    within the fs_locations_info attribute.  When this bit is
	    set, clients without access to fs_locations_info
	    information should assume that filehandles will expire on file
	    system transitions.
          </t>
          <t hangText="FH4_VOL_RENAME">
            The filehandle will expire during rename.  This includes a rename by
            the requesting client or a rename by any other client.  If FH4_VOL_ANY
            is set, FH4_VOL_RENAME is redundant.
          </t>
        </list>
      </t>
      <t>
        Servers that provide volatile filehandles that can expire 
        while open require special care as regards handling of RENAMEs
        and REMOVEs.  This situation can arise if FH4_VOL_MIGRATION or 
        FH4_VOL_RENAME is set, if FH4_VOLATILE_ANY is set and 
        FH4_NOEXPIRE_WITH_OPEN is not set, or if a non-read-only file system
        has a transition target in a different handle
         class.  In these cases, the server should deny a RENAME 
        or REMOVE that would affect an OPEN file of any of the
        components leading to the OPEN file.  In addition, the server 
        should deny all RENAME or REMOVE requests during the grace period,
        in order to make sure that reclaims of files where filehandles 
        may have expired do not do a reclaim for the wrong file.
      </t>
      <t>
        Volatile filehandles are especially suitable for implementation
        of the pseudo file systems used to bridge exports.  See 
        <xref target="pseudo_fs_volatility" /> for a discussion of this.
      </t>
    </section>
  </section>
  <section title="One Method of Constructing a Volatile Filehandle">
    <t>
      A volatile filehandle, while opaque to the client, could contain:
    </t>
    <figure>
      <artwork>
[volatile bit = 1 | server boot time | slot | generation number]
      </artwork>
    </figure>
    <t>
      <list style='symbols'>
        <t>
          slot is an index in the server volatile filehandle table
        </t>
        <t>
          generation number is the generation number for the table entry/slot
        </t>
      </list>
      When the client presents a volatile filehandle, the server makes the
      following checks, which assume that the check for the volatile bit has
      passed.  If the server boot time is less than the current server boot
      time, return NFS4ERR_FHEXPIRED.  If slot is out of range, return
      NFS4ERR_BADHANDLE.  If the generation number does not match, return
      NFS4ERR_FHEXPIRED.
    </t>
    <t>
      When the server restarts, the table is gone (it is volatile).
    </t>
    <t>
      If the volatile bit is 0, then it is a persistent filehandle with a
      different structure following it. 

    </t>
  </section>

  <section title="Client Recovery from Filehandle Expiration">
    <t>
      If possible, the client SHOULD recover from the receipt of an
      NFS4ERR_FHEXPIRED error.  The client must take on additional
      responsibility so that it may prepare itself to recover from the
      expiration of a volatile filehandle.  If the server returns persistent
      filehandles, the client does not need these additional steps.
    </t>
    <t>
      For volatile filehandles, most commonly the client will need to store
      the component names leading up to and including the file system object
      in question.  With these names, the client should be able to recover
      by finding a filehandle in the namespace that is still available or
      by starting at the root of the server's file system namespace.
    </t>
    <t>
      If the expired filehandle refers to an object that has been removed
      from the file system, obviously the client will not be able to recover
      from the expired filehandle.
    </t>
    <t>
      It is also possible that the expired filehandle refers to a file that
      has been renamed.  If the file was renamed by another client, again it
      is possible that the original client will not be able to recover.
      However, in the case that the client itself is renaming the file and
      the file is open, it is possible that the client may be able to
      recover.  The client can determine the new pathname based on the
      processing of the rename request.  The client can then regenerate the
      new filehandle based on the new pathname.  The client could also use
      the COMPOUND procedure to construct a series of operations
      like:
      <figure>
        <artwork>
          RENAME A B
          LOOKUP B
          GETFH
        </artwork>
      </figure>

      Note that the COMPOUND procedure does not provide atomicity.  This
      example only reduces the overhead of recovering from an expired
      filehandle.
    </t>
  </section>
</section>
<!-- 	$Id: 2009-12-20-TO-rfc5661.xml,v 1.2 2009/12/21 05:59:32 shepler.mre Exp $	 -->
<!-- Copyright (C) The IETF Trust (2007-2008) -->
<!-- Copyright (C) The Internet Society (2006) -->
<section anchor="file_attributes" title="File Attributes">
  <t>
    To meet the requirements of extensibility and increased
    interoperability with non-UNIX platforms, attributes need to be handled
    in a flexible manner.  The NFSv3 fattr3 structure contains a
    fixed list of attributes that not all clients and servers are able to
    support or care about.  The fattr3 structure cannot be extended as
    new needs arise and it provides no way to indicate non-support.  With
    the NFSv4.1 protocol, the client is able to query what attributes
    the server supports and construct requests with only those supported
    attributes (or a subset thereof).
  </t>
  <t>
    To this end, attributes are divided into three groups: REQUIRED,
    RECOMMENDED, and named.  Both REQUIRED and RECOMMENDED attributes are
    supported in the NFSv4.1 protocol by a specific and well-defined
    encoding and are identified by number.  They are requested by setting
    a bit in the bit vector sent in the GETATTR request; the server
    response includes a bit vector to list what attributes were returned
    in the response.  New REQUIRED or RECOMMENDED attributes may be added
    to the NFSv4 protocol as part of a new minor version
    by publishing a
    Standards Track RFC that allocates a new attribute number value and
    defines the encoding for the attribute.  See
    <xref target="minor_versioning"/> for further
    discussion.
  </t>
  <t>
    Named attributes are accessed by the new OPENATTR operation, which
    accesses a hidden directory of attributes associated with a file
    system object.  OPENATTR takes a filehandle for the object and returns
    the filehandle for the attribute hierarchy.  The filehandle for the
    named attributes is a directory object accessible by LOOKUP or READDIR
    and contains files whose names represent the named attributes and
    whose data bytes are the value of the attribute.  For example:
  </t>
  <texttable>
    <ttcol align='left' />
    <ttcol align='left' />
    <ttcol align='left' />
    <c>LOOKUP</c><c>"foo"</c><c>; look up file</c>
    <c>GETATTR</c><c>attrbits</c><c />
    <c>OPENATTR</c><c /><c>; access foo's named attributes</c>
    <c>LOOKUP</c><c>"x11icon"</c><c>; look up specific attribute</c>
    <c>READ</c><c>0,4096</c><c>; read stream of bytes</c>
  </texttable>
  <t>
    Named attributes are intended for data needed by applications rather
    than by an NFS client implementation.  NFS implementors are strongly
    encouraged to define their new attributes as RECOMMENDED attributes by
    bringing them to the IETF Standards Track process.
  </t>
  <t>
    The set of attributes that are classified as REQUIRED is
    deliberately small since servers need to do whatever it takes to support
    them.  A server should support as many of the RECOMMENDED attributes
    as possible but, by their definition, the server is not required to
    support all of them.  Attributes are deemed REQUIRED if the data is
    both needed by a large number of clients and is not otherwise
    reasonably computable by the client when support is not provided on
    the server.
  </t>
  <t>
    Note that the hidden directory returned by OPENATTR is a convenience
    for protocol processing.  The client should not make any assumptions
    about the server's implementation of named attributes and whether
    or not the underlying file system at the server has a named
    attribute directory.  Therefore, operations such as SETATTR and
    GETATTR on the named attribute directory are undefined.
  </t>
  <section anchor="mandatory_attributes_intro" title="REQUIRED Attributes">
    <t>
      These MUST be supported by every NFSv4.1 client and server in
      order to ensure a minimum level of interoperability.  The server MUST
      store and return these attributes, and the client MUST be able to
      function with an attribute set limited to these attributes.  With just
      the REQUIRED attributes some client functionality may be impaired or
      limited in some ways.  A client may ask for any of these attributes to
      be returned by setting a bit in the GETATTR request, and the server
      MUST return their value.
    </t>
  </section>
  <section anchor="recommended_attributes_intro" title="RECOMMENDED Attributes">
    <t>
      These attributes are understood well enough to warrant support in the
      NFSv4.1 protocol.  However, they may not be supported on all
      clients and servers.  A client may ask for any of these attributes to
      be returned by setting a bit in the GETATTR request but must handle
      the case where the server does not return them.  A client MAY ask for
      the set of attributes the server supports and SHOULD NOT request
      attributes the server does not support.  A server should be tolerant
      of requests for unsupported attributes and simply not return them
      rather than considering the request an error.  It is expected that
      servers will support all attributes they comfortably can and only fail
      to support attributes that are difficult to support in their
      operating environments.  A server should provide attributes whenever
      they don't have to "tell lies" to the client.  For example, a file
      modification time should be either an accurate time or should not be
      supported by the server.  At times this will be difficult for
      clients, but a client is better positioned to decide whether and how to
      fabricate or construct an attribute or whether to do without the
      attribute.
    </t>
  </section>
  <section anchor="named_attributes_intro" title="Named Attributes">
    <t>
      These attributes are not supported by direct encoding in the NFSv4 
      protocol but are accessed by string names rather than
      numbers and correspond to an uninterpreted stream of bytes that are
      stored with the file system object.  The namespace for these
      attributes may be accessed by using the OPENATTR operation.  The
      OPENATTR operation returns a filehandle for a virtual "named attribute
      directory", and further perusal and modification of the namespace may 
      be done using operations that work on more typical directories.  In
      particular, READDIR may be used to get a list of such named attributes,
      and LOOKUP and OPEN may select a particular attribute.  Creation of
      a new named attribute may be the result of an OPEN specifying file
      creation.
    </t>
    <t>
      Once an OPEN is done, named attributes may be examined and changed 
      by normal READ and WRITE operations using the filehandles and stateids
      returned by OPEN.
    </t>
    <t>
      Named attributes and the named attribute directory may have 
      their own (non-named) attributes.  Each of these objects MUST have all 
      of the REQUIRED attributes and may have additional RECOMMENDED 
      attributes.  However, the set of attributes for named attributes 
      and the named attribute directory need not be, and
      typically will not be, as large as that for other objects in that 
      file system.
    </t>
    <t>
      Named attributes and the named attribute directory might be the
      target of delegations (in the case of the named attribute directory,
      these will be directory delegations).  However, since granting
      delegations is at the server's discretion, a server
      need not support delegations on named attributes or the named
      attribute directory.
    </t>
    <t>
      It is RECOMMENDED that servers support arbitrary named attributes.  A
      client should not depend on the ability to store any named attributes
      in the server's file system.  If a server does support named
      attributes, a client that is also able to handle them should be able
      to copy a file's data and metadata with complete transparency from
      one location to another; this would imply that names allowed for
      regular directory entries are valid for named attribute names as well.
    </t>
    <t>
      In NFSv4.1, the structure of named attribute directories is 
      restricted in a number of ways, in order to prevent the development
      of non-interoperable implementations in which some servers support
      a fully general hierarchical directory structure for named attributes
      while others support a limited but adequate structure for named attributes.
      In such an environment, clients or applications might come to
      depend on non-portable extensions.  The restrictions are:
      <list style="symbols">
        <t>
          CREATE is not allowed in a named attribute directory.  Thus, such
          objects as symbolic links and special files are not allowed to
          be named attributes.   Further, directories may not be created
          in a named attribute directory, so no hierarchical structure of
          named attributes for a single object is allowed.
        </t>
        <t>
          If OPENATTR is done on a named attribute directory or on
          a named attribute, the server MUST return NFS4ERR_WRONG_TYPE.
        </t>
        <t>
          Doing a RENAME of a named attribute to a different named 
          attribute directory or to an ordinary (i.e., non-named-attribute)
          directory is not allowed.
        </t>
        <t>
          Creating hard links between named attribute directories or 
          between named attribute directories and ordinary directories 
          is not allowed.
        </t>
      </list>
    </t>
    <t>
      Names of attributes will not be controlled by this document or other
      IETF Standards Track documents.  See
      <xref target="namedattributesiana"/>
      for further discussion.
    </t>
  </section>
  <section title="Classification of Attributes">
    <t>
      Each of the REQUIRED and RECOMMENDED attributes can be classified in
      one of three categories: per server (i.e., the value of the attribute will
      be the same for all file objects that share the same
      server owner; see <xref target="Server Owners"/> for a definition of server
      owner), per file system (i.e., the value of the attribute will
      be the same for some or all file objects that share the
      same <xref target="attrdef_fsid">fsid attribute</xref> and
      server owner), or per file system
      object.  Note that it is possible that some per file system attributes
      may vary within the file system, depending on the value of
      the <xref target="attrdef_homogeneous">"homogeneous"</xref>
      attribute. Note that the attributes time_access_set and
      time_modify_set are not listed in this section because they are
      write-only attributes corresponding to time_access and time_modify,
      and are used in a special instance of SETATTR.
      <list style='symbols'>
	<t>
	  The per-server attribute is:
	  <list style='empty'>
	    <t>
	      lease_time
	    </t>
	  </list>
	</t>
	<t>
	  The per-file system attributes are:
	  <list style='empty'>
	    <t>
	      supported_attrs, suppattr_exclcreat, fh_expire_type, link_support,
	      symlink_support, unique_handles, aclsupport,
	      cansettime, case_insensitive, case_preserving,
	      chown_restricted, files_avail, files_free,
	      files_total, fs_locations, homogeneous, maxfilesize,
	      maxname, maxread, maxwrite, no_trunc, space_avail,
	      space_free, space_total, time_delta,
              change_policy, fs_status,
	      fs_layout_type, fs_locations_info, fs_charset_cap
	    </t>
	  </list>
	</t>    
	<t>
	  The per-file system object attributes are:
	  <list style='empty'>
	    <t>
	      type, change, size, named_attr, fsid, rdattr_error,
	      filehandle, acl, archive, fileid, hidden, maxlink,
	      mimetype, mode, numlinks, owner, owner_group, rawdev,
	      space_used, system, time_access, time_backup,
	      time_create, time_metadata, time_modify,
	      mounted_on_fileid, dir_notif_delay, dirent_notif_delay,
              dacl, sacl,
	      layout_type, layout_hint, layout_blksize, layout_alignment,
              mdsthreshold, retention_get, retention_set, retentevt_get,
              retentevt_set, retention_hold, mode_set_masked
	    </t>
	  </list>
	</t>
      </list>
    </t>
    <t>
      For quota_avail_hard, quota_avail_soft, and quota_used, see their
      definitions below for the appropriate classification.
    </t>

  </section>

  <section anchor="rw_attr" 
	   title="Set-Only and Get-Only Attributes">
    <t>
     Some REQUIRED and RECOMMENDED attributes are set-only; i.e., they
     can be set via SETATTR but not retrieved via GETATTR. Similarly, some
     REQUIRED and RECOMMENDED attributes are get-only; i.e., they
     can be retrieved via GETATTR but not set via SETATTR. If a client attempts
     to set a get-only attribute or get a set-only attributes, the server
     MUST return NFS4ERR_INVAL.
   </t>

  </section>

  <section anchor="mandatory_attributes" 
	   title="REQUIRED Attributes - List and Definition References">
    <t>
     The list of REQUIRED attributes appears in <xref target="req_attr_table"/>.
     The meaning of the columns of the table are:
     <list style='symbols'>
     <t>Name: The name of the attribute.</t>
     <t>Id: The number assigned to the attribute. In
        the event of conflicts between the assigned number and <xref
        target="RFC5662"/>, the latter is
        likely authoritative, but should be resolved with Errata to
        this document and/or
        <xref target="RFC5662"/>. See <xref target="errata"/> for the Errata process.

</t>
     <t>Data Type: The XDR data type of the attribute.</t>
     <t>
        Acc: Access allowed to the attribute. R means
        read-only (GETATTR may retrieve, SETATTR may not
        set). W means write-only (SETATTR may set, GETATTR
        may not retrieve).  R W means read/write (GETATTR
        may retrieve, SETATTR may set).

     </t>
     <t>Defined in: The section of this specification that describes the
        attribute.</t>
     </list>
    </t>

    <texttable anchor="req_attr_table">
      <ttcol align='left' >Name</ttcol>
      <ttcol align='left' >Id</ttcol>
      <ttcol align='left' >Data Type</ttcol>
      <ttcol align='left' >Acc</ttcol>
      <ttcol align='left' >Defined in:</ttcol>

      <c>supported_attrs</c><c>0</c><c>bitmap4</c><c>R</c>
      <c>
	<xref target="attrdef_supp_attr" />
      </c>

      <c>type</c><c>1</c><c>nfs_ftype4</c><c>R</c>
      <c>
	<xref target="attrdef_type"  />
      </c>

      <c>fh_expire_type</c><c>2</c><c>uint32_t</c><c>R</c>
      <c>
	<xref target="attrdef_fh_expire_type"  />
      </c>

      <c>change</c><c>3</c><c>uint64_t</c><c>R</c>
      <c>
	<xref target="attrdef_change"  />
      </c>
      
      <c>size</c><c>4</c><c>uint64_t</c><c>R W</c>
      <c>
	<xref target="attrdef_size" />
      </c>

      <c>link_support</c><c>5</c><c>bool</c><c>R</c>
      <c>
	<xref target="attrdef_link_support" />
      </c>

      <c>symlink_support</c><c>6</c><c>bool</c><c>R</c>
      <c>
	<xref target="attrdef_symlink_support" />
      </c>

      <c>named_attr</c><c>7</c><c>bool</c><c>R</c>
      <c>
	<xref target="attrdef_named_attr" />
      </c>

      <c>fsid</c><c>8</c><c>fsid4</c><c>R</c>
      <c>
	<xref target="attrdef_fsid" />
      </c>

      <c>unique_handles</c><c>9</c><c>bool</c><c>R</c>
      <c>
	<xref target="attrdef_unique_handles" />
      </c>

      <c>lease_time</c><c>10</c><c>nfs_lease4</c><c>R</c>
      <c>
	<xref target="attrdef_lease_time" />
      </c>

      <c>rdattr_error</c><c>11</c><c>enum</c><c>R</c>
      <c>
	<xref target="attrdef_rdattr_error" />
      </c>

      <c>filehandle</c><c>19</c><c>nfs_fh4</c><c>R</c>
      <c>
	<xref target="attrdef_filehandle" />
      </c>

      <c>suppattr_exclcreat</c><c>75</c><c>bitmap4</c><c>R</c>
      <c>
	<xref target="attrdef_suppattr_exclcreat" />
      </c>

    </texttable>
  </section>
  <section anchor="recommended_attributes" 
	   title="RECOMMENDED Attributes - List and Definition References">
    <t>
     The RECOMMENDED attributes are defined in
     <xref target="rec_attr_tbl"/>.  The meanings
     of the column headers are the same as
     <xref target="req_attr_table"/>; see <xref
     target="mandatory_attributes" /> for the meanings.

    </t>
    <texttable anchor="rec_attr_tbl">
      <ttcol align='left' >Name</ttcol>
      <ttcol align='left' >Id</ttcol>
      <ttcol align='left' >Data Type</ttcol>
      <ttcol align='left' >Acc</ttcol>
      <ttcol align='left' >Defined in:</ttcol>

      <c>acl</c><c>12</c><c>nfsace4&lt;></c><c>R W</c>
      <c>
	<xref target="attrdef_acl" />
      </c>

      <c>aclsupport</c><c>13</c><c>uint32_t</c><c>R</c>
      <c>
	<xref target="attrdef_aclsupport" />
      </c>

      <c>archive</c><c>14</c><c>bool</c><c>R W</c>
      <c>
	<xref target="attrdef_archive" />
      </c>

      <c>cansettime</c><c>15</c><c>bool</c><c>R</c>
      <c>
	<xref target="attrdef_cansettime" />
      </c>

      <c>case_insensitive</c><c>16</c><c>bool</c><c>R</c>
      <c>
	<xref target="attrdef_case_insensitive" />
      </c>

      <c>case_preserving</c><c>17</c><c>bool</c><c>R</c>
      <c>
	<xref target="attrdef_case_preserving" />
      </c>

      <c>change_policy</c><c>60</c><c>chg_policy4</c><c>R</c>
      <c>
	<xref target="attrdef_change_policy" />
      </c>

      <c>chown_restricted</c><c>18</c><c>bool</c><c>R</c>
      <c>
	<xref target="attrdef_chown_restricted" />
      </c>

      <c>dacl</c><c>58</c><c>nfsacl41</c><c>R W</c>
      <c>
	<xref target="attrdef_dacl" />
      </c>

      <c>dir_notif_delay</c><c>56</c><c>nfstime4</c><c>R</c>
      <c>
	<xref target="attrdef_dir_notif_delay" />
      </c>

      <c>dirent_notif_delay</c><c>57</c><c>nfstime4</c><c>R</c>
      <c>
	<xref target="attrdef_dirent_notif_delay" />
      </c>

      <c>fileid</c><c>20</c><c>uint64_t</c><c>R</c>
      <c>
	<xref target="attrdef_fileid" />
      </c>

      <c>files_avail</c><c>21</c><c>uint64_t</c><c>R</c>
      <c>
	<xref target="attrdef_files_avail" />
      </c>

      <c>files_free</c><c>22</c><c>uint64_t</c><c>R</c>
      <c>
	<xref target="attrdef_files_free" />
      </c>

      <c>files_total</c><c>23</c><c>uint64_t</c><c>R</c>
      <c>
	<xref target="attrdef_files_total" />
      </c>

      <c>fs_charset_cap</c><c>76</c><c>uint32_t</c><c>R</c>
      <c>
	<xref target="attrdef_fs_charset_cap" />
      </c>

      <c>fs_layout_type</c><c>62</c><c>layouttype4&lt;></c><c>R</c>
      <c>
	<xref target="attrdef_fs_layout_type" />
      </c>

      <c>fs_locations</c><c>24</c><c>fs_locations</c><c>R</c>
      <c>
	<xref target="attrdef_fs_locations" />
      </c>

      <c>fs_locations_info</c><c>67</c><c>*</c><c>R</c>
      <c>
	<xref target="attrdef_fs_locations_info" />
      </c>

      <c>fs_status</c><c>61</c><c>fs4_status</c><c>R</c>
      <c>
	<xref target="attrdef_fs_status" />
      </c>

      <c>hidden</c><c>25</c><c>bool</c><c>R W</c>
      <c>
	<xref target="attrdef_hidden" />
      </c>

      <c>homogeneous</c><c>26</c><c>bool</c><c>R</c>
      <c>
	<xref target="attrdef_homogeneous" />
      </c>

      <c>layout_alignment</c><c>66</c><c>uint32_t</c><c>R</c>
      <c>
	<xref target="attrdef_layout_alignment" />
      </c>

      <c>layout_blksize</c><c>65</c><c>uint32_t</c><c>R</c>
      <c>
	<xref target="attrdef_layout_blksize" />
      </c>

      <c>layout_hint</c><c>63</c><c>layouthint4</c><c>&nbsp;&nbsp;W</c>
      <c>
	<xref target="attrdef_layout_hint" />
      </c>

      <c>layout_type</c><c>64</c><c>layouttype4&lt;></c><c>R</c>
      <c>
	<xref target="attrdef_layout_type" />
      </c>

      <c>maxfilesize</c><c>27</c><c>uint64_t</c><c>R</c>
      <c>
	<xref target="attrdef_maxfilesize" />
      </c>

      <c>maxlink</c><c>28</c><c>uint32_t</c><c>R</c>
      <c>
	<xref target="attrdef_maxlink" />
      </c>

      <c>maxname</c><c>29</c><c>uint32_t</c><c>R</c>
      <c>
	<xref target="attrdef_maxname" />
      </c>

      <c>maxread</c><c>30</c><c>uint64_t</c><c>R</c>
      <c>
	<xref target="attrdef_maxread" />
      </c>

      <c>maxwrite</c><c>31</c><c>uint64_t</c><c>R</c>
      <c>
	<xref target="attrdef_maxwrite" />
      </c>

      <c>mdsthreshold</c><c>68</c><c>mdsthreshold4</c><c>R</c>
      <c>
	<xref target="attrdef_mdsthreshold" />
      </c>

      <c>mimetype</c><c>32</c><c>utf8str_cs</c><c>R W</c>
      <c>
	<xref target="attrdef_mimetype" />
      </c>

      <c>mode</c><c>33</c><c>mode4</c><c>R W</c>
      <c>
	<xref target="attrdef_mode" />
      </c>

      <c>mode_set_masked</c><c>74</c><c>mode_masked4</c><c>&nbsp;&nbsp;W</c>
      <c>
	<xref target="attrdef_mode_set_masked" />
      </c>

      <c>mounted_on_fileid</c><c>55</c><c>uint64_t</c><c>R</c>
      <c>
	<xref target="attrdef_mounted_on_fileid" />
      </c>

      <c>no_trunc</c><c>34</c><c>bool</c><c>R</c>
      <c>
	<xref target="attrdef_no_trunc" />
      </c>

      <c>numlinks</c><c>35</c><c>uint32_t</c><c>R</c>
      <c>
	<xref target="attrdef_numlinks" />
      </c>

      <c>owner</c>
      <c>36</c><c>utf8str_mixed</c><c>R W</c>
      <c>
	<xref target="attrdef_owner" />
      </c>

      <c>owner_group</c>
      <c>37</c><c>utf8str_mixed</c><c>R W</c>
      <c>
	<xref target="attrdef_owner_group" />
      </c>

      <c>quota_avail_hard</c>
      <c>38</c><c>uint64_t</c><c>R</c>
      <c>
	<xref target="attrdef_quota_avail_hard" />
      </c>

      <c>quota_avail_soft</c>
      <c>39</c><c>uint64_t</c><c>R</c>
      <c>
	<xref target="attrdef_quota_avail_soft" />
      </c>

      <c>quota_used</c>
      <c>40</c><c>uint64_t</c><c>R</c>
      <c>
	<xref target="attrdef_quota_used" />
      </c>

      <c>rawdev</c><c>41</c><c>specdata4</c><c>R</c>
      <c>
	<xref target="attrdef_rawdev" />
      </c>

      <c>retentevt_get</c><c>71</c><c>retention_get4</c><c>R</c>
      <c>
	<xref target="attrdef_retentevt_get" />
      </c>

      <c>retentevt_set</c><c>72</c><c>retention_set4</c><c>&nbsp;&nbsp;W</c>
      <c>
	<xref target="attrdef_retentevt_set" />
      </c>

      <c>retention_get</c><c>69</c><c>retention_get4</c><c>R</c>
      <c>
	<xref target="attrdef_retention_get" />
      </c>

      <c>retention_hold</c><c>73</c><c>uint64_t</c><c>R W</c>
      <c>
	<xref target="attrdef_retention_hold" />
      </c>

      <c>retention_set</c><c>70</c><c>retention_set4</c><c>&nbsp;&nbsp;W</c>
      <c>
	<xref target="attrdef_retention_set" />
      </c>

      <c>sacl</c><c>59</c><c>nfsacl41</c><c>R W</c>
      <c>
	<xref target="attrdef_sacl" />
      </c>

      <c>space_avail</c><c>42</c><c>uint64_t</c><c>R</c>
      <c>
	<xref target="attrdef_space_avail" />
      </c>

      <c>space_free</c><c>43</c><c>uint64_t</c><c>R</c>
      <c>
	<xref target="attrdef_space_free" />
      </c>

      <c>space_total</c><c>44</c><c>uint64_t</c><c>R</c>
      <c>
	<xref target="attrdef_space_total" />
      </c>

      <c>space_used</c><c>45</c><c>uint64_t</c><c>R</c>
      <c>
	<xref target="attrdef_space_used" />
      </c>

      <c>system</c><c>46</c><c>bool</c><c>R W</c>
      <c>
	<xref target="attrdef_system" />
      </c>

      <c>time_access</c>
      <c>47</c><c>nfstime4</c><c>R</c>
      <c>
	<xref target="attrdef_time_access" />
      </c>

      <c>time_access_set</c><c>48</c><c>settime4</c><c>&nbsp;&nbsp;W</c>
      <c>
	<xref target="attrdef_time_access_set" />
      </c>

      <c>time_backup</c><c>49</c><c>nfstime4</c><c>R W</c>
      <c>
	<xref target="attrdef_time_backup" />
      </c>

      <c>time_create</c><c>50</c><c>nfstime4</c><c>R W</c>
      <c>
	<xref target="attrdef_time_create" />
      </c>

      <c>time_delta</c><c>51</c><c>nfstime4</c><c>R</c>
      <c>
	<xref target="attrdef_time_delta" />
      </c>

      <c>time_metadata</c><c>52</c><c>nfstime4</c><c>R</c>
      <c>
	<xref target="attrdef_time_metadata" />
      </c>

      <c>time_modify</c><c>53</c><c>nfstime4</c><c>R</c>
      <c>
	<xref target="attrdef_time_modify" />
      </c>

      <c>time_modify_set</c><c>54</c><c>settime4</c><c>&nbsp;&nbsp;W</c>
      <c>
	<xref target="attrdef_time_modify_set" />
      </c>

    </texttable>
    <t>* fs_locations_info4</t>
  </section>

  <section anchor="attribute_definitions" title="Attribute
						 Definitions">

   <section anchor="required_attr" title="Definitions of REQUIRED Attributes">

    <section toc="exclude" anchor="attrdef_supp_attr" 
	     title="Attribute 0: supported_attrs">
	<t>
	The bit vector that would retrieve all REQUIRED and
	RECOMMENDED attributes that are supported for this object.
	The scope of this attribute applies to all objects with a
	matching fsid.
	</t>
    </section>

    <section toc="exclude" anchor="attrdef_type" 
	     title="Attribute 1: type">
	<t>
	  Designates the type of an object in terms of one of a number
          of special constants:
          <list style="symbols">
            <t>
              NF4REG designates a regular file.
            </t>
            <t>
              NF4DIR designates a directory.
            </t>
            <t>
              NF4BLK designates a block device special file.
            </t>
            <t>
              NF4CHR designates a character device special file.
            </t>
            <t>
              NF4LNK designates a symbolic link.
            </t>
            <t>
              NF4SOCK designates a named socket special file.
            </t>
            <t>
              NF4FIFO designates a fifo special file.
            </t>
            <t>
              NF4ATTRDIR designates a named attribute directory.
            </t>
            <t>
              NF4NAMEDATTR designates a named attribute.
            </t>
          </list>
	</t>
	<t>
          Within the explanatory text and operation descriptions, the
          following phrases will be used with the meanings given below:
          <list style="symbols">
            <t>
              The phrase "is a directory" means that the object's
              type attribute is NF4DIR or NF4ATTRDIR.
            </t>
            <t>
              The phrase "is a special file" means that the object's type
              attribute is NF4BLK, NF4CHR, NF4SOCK, or NF4FIFO. 
            </t>
            <t>
              The phrases "is an ordinary file" and
              "is a regular file" mean that the object's
              type attribute is NF4REG or NF4NAMEDATTR.
            </t>
          </list>
	</t>

    </section>

    <section toc="exclude" anchor="attrdef_fh_expire_type" 
	     title="Attribute 2: fh_expire_type">
	<t>
	  Server uses this to specify filehandle expiration behavior
	  to the client.  See <xref target="Filehandles"/> for additional
	  description.
	</t>
    </section>

    <section toc="exclude" anchor="attrdef_change" 
	     title="Attribute 3: change">
	<t>
	  A value created by the server that the client can use to
	  determine if file data, directory contents, or attributes of
	  the object have been modified.  The server may return the
	  object's time_metadata attribute for this attribute's value,
	  but only if the file system object cannot be updated more
	  frequently than the resolution of time_metadata.
	</t>
    </section>

    <section toc="exclude" anchor="attrdef_size" 
	     title="Attribute 4: size">
	<t>
	  The size of the object in bytes.
	</t>
    </section>

    <section toc="exclude" anchor="attrdef_link_support" 
	     title="Attribute 5: link_support">
	<t>
	  TRUE, if the object's file system supports hard links.
	</t>
    </section>

    <section toc="exclude" anchor="attrdef_symlink_support" 
	     title="Attribute 6: symlink_support">
	<t>
	  TRUE, if the object's file system supports symbolic links.
	</t>
    </section>

    <section toc="exclude" anchor="attrdef_named_attr" 
	     title="Attribute 7: named_attr">
	<t>
	  TRUE, if this object has named attributes. In other words,
	  object has a non-empty named attribute directory.
	</t>
    </section>

    <section toc="exclude" anchor="attrdef_fsid" 
	     title="Attribute 8: fsid">
	<t>
	  Unique file system identifier for the file system holding this
	  object.  The fsid attribute has major and minor components, each of
	  which are of data type uint64_t.
	</t>
    </section>

    <section toc="exclude" anchor="attrdef_unique_handles" 
	     title="Attribute 9: unique_handles">
	<t>
	  TRUE, if two distinct filehandles are guaranteed to refer to two
	  different file system objects.
	</t>
    </section>

    <section toc="exclude" anchor="attrdef_lease_time" 
	     title="Attribute 10: lease_time">
	<t>
	  Duration of the lease at server in seconds.
	</t>
    </section>

    <section toc="exclude" anchor="attrdef_rdattr_error" 
	     title="Attribute 11: rdattr_error">
	<t>
	  Error returned from an attempt to retrieve attributes during a READDIR operation.
	</t>
    </section>

    <section toc="exclude" anchor="attrdef_filehandle" 
	     title="Attribute 19: filehandle">
	<t>
	  The filehandle of this object (primarily for READDIR requests).
	</t>
    </section>

    <section toc="exclude" anchor="attrdef_suppattr_exclcreat" 
	     title="Attribute 75: suppattr_exclcreat">
	<t>
	The bit vector that would set all REQUIRED and
	RECOMMENDED attributes that are supported by the EXCLUSIVE4_1
        method of file creation via the OPEN operation.
	The scope of this attribute applies to all objects with a
	matching fsid.
	</t>
    </section>

   </section>

   <section anchor="recommended_attr" title="Definitions of Uncategorized RECOMMENDED Attributes">
    <t>
     The definitions of most of the RECOMMENDED attributes follow. Collections
     that share a common category are defined in other sections.
    </t>

    <section toc="exclude" anchor="attrdef_archive"
	     title="Attribute 14: archive">
      <t>
	TRUE, if this file has been archived since the time of last
	modification (deprecated in favor of time_backup).
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_cansettime"
	     title="Attribute 15: cansettime">
      <t>
	TRUE, if the server is able to change the times for a
	file system object as specified in a SETATTR operation.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_case_insensitive"
	     title="Attribute 16: case_insensitive">
      <t>
	TRUE, if file name comparisons on this file system are case
	insensitive.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_case_preserving"
	     title="Attribute 17: case_preserving">
      <t>
	TRUE, if file name case on this file system is preserved.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_change_policy"
	     title="Attribute 60: change_policy">
      <t>
	A value created by the server that the client can use to
	determine if some server policy related to the current
        file system has been subject to change.  If the value 
        remains the same, then the client can be sure that the
        values of the attributes related to fs location
        and the fss_type field of the fs_status attribute have
        not changed.  On the other hand, a change in this value does
        necessarily imply a change in policy.  It is up to the client
        to interrogate the server to determine if some policy relevant to 
        it has changed.  See <xref target="chg_policy4" /> for 
        details.
      </t>
      <t>
        This attribute MUST change when the value returned by 
        the fs_locations or fs_locations_info attribute changes, when
        a file system goes from read-only to writable or vice versa,
        or when the allowable set of security flavors for the file system
        or any part thereof is changed.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_chown_restricted"
	     title="Attribute 18: chown_restricted">
      <t>
	If TRUE, the server will reject any request to change either
	the owner or the group associated with a file if the caller
	is not a privileged user (for example, "root" in UNIX
	operating environments or, in Windows 2000, the "Take
	Ownership" privilege).
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_fileid"
	     title="Attribute 20: fileid">
      <t>
	A number uniquely identifying the file within the file system.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_files_avail"
	     title="Attribute 21: files_avail">
      <t>
	File slots available to this user on the file system
	containing this object -- this should be the smallest
	relevant limit.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_files_free"
	     title="Attribute 22: files_free">
      <t>
	Free file slots on the file system containing this object --
	this should be the smallest relevant limit.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_files_total"
	     title="Attribute 23: files_total">
      <t>
	Total file slots on the file system containing this object.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_fs_charset_cap" 
	     title="Attribute 76: fs_charset_cap">
      <t>
        Character set capabilities for this file system. See
        <xref target="utf8_caps"/>.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_fs_locations"
            title="Attribute 24: fs_locations">
       <t>
       Locations where this file system may be found.  If the server
       returns NFS4ERR_MOVED as an error, this attribute MUST be
       supported.
       See <xref target="fs_locations"/> for more details.
       </t>
    </section>

    <section toc="exclude" anchor="attrdef_fs_locations_info"
	     title="Attribute 67: fs_locations_info">
      <t>
	Full function file system location.
       See <xref target="fs_locations_info"/> for more details.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_fs_status"
	     title="Attribute 61: fs_status">
      <t>
	Generic file system type information.
       See <xref target="fs_status"/> for more details.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_hidden"
	     title="Attribute 25: hidden">
      <t>
	TRUE, if the file is considered hidden with respect to 
	the Windows API.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_homogeneous"
	     title="Attribute 26: homogeneous">
      <t>
	TRUE, if this object's file system is homogeneous; i.e., all
	objects in the file system (all objects on the server with the
	same fsid) have common values for all per-file-system attributes.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_maxfilesize"
	     title="Attribute 27: maxfilesize">
      <t>
	Maximum supported file size for the file system of this object.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_maxlink"
	     title="Attribute 28: maxlink">
      <t>
	Maximum number of links for this object.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_maxname"
	     title="Attribute 29: maxname">
      <t>
	Maximum file name size supported for this object.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_maxread"
	     title="Attribute 30: maxread">
      <t>
	Maximum amount of data the READ operation will return for this object.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_maxwrite"
	     title="Attribute 31: maxwrite">
      <t>
	Maximum amount of data the WRITE operation will accept for this object.
	This
	attribute SHOULD be supported if the file is writable.  Lack
	of this attribute can lead to the client either wasting
	bandwidth or not receiving the best performance.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_mimetype"
	     title="Attribute 32: mimetype">
      <t>
	MIME body type/subtype of this object.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_mounted_on_fileid"
	     title="Attribute 55: mounted_on_fileid">
      <t>
	Like fileid, but if the target filehandle is the root of a
	file system, this attribute represents the fileid of the
	underlying directory.
      </t>
      <t>
	UNIX-based operating environments connect a file system into
	the namespace by connecting (mounting) the file system onto
	the existing file object (the mount point, usually a
	directory) of an existing file system. When the mount point's
	parent directory is read via an API like readdir(), the return
	results are directory entries, each with a component name and
	a fileid. The fileid of the mount point's directory entry will
	be different from the fileid that the stat() system call
	returns. The stat() system call is returning the fileid of the
	root of the mounted file system, whereas readdir() is
	returning the fileid that stat() would have returned before any
	file systems were mounted on the mount point.
      </t>
      <t>
	Unlike NFSv3, NFSv4.1 allows a client's LOOKUP
	request to cross other file systems. The client detects the
	file system crossing whenever the filehandle argument of
	LOOKUP has an fsid attribute different from that of the
	filehandle returned by LOOKUP. A UNIX-based client will
	consider this a "mount point crossing".  UNIX has a legacy
	scheme for allowing a process to determine its current working
	directory. This relies on readdir() of a mount point's parent
	and stat() of the mount point returning fileids as previously
	described.  The mounted_on_fileid attribute corresponds to the
	fileid that readdir() would have returned as described
	previously.
      </t>
      <t>
	While the NFSv4.1 client could simply fabricate a fileid
	corresponding to what mounted_on_fileid provides (and if the
	server does not support mounted_on_fileid, the client has no
	choice), there is a risk that the client will generate a
	fileid that conflicts with one that is already assigned to
	another object in the file system. Instead, if the server can
	provide the mounted_on_fileid, the potential for client
	operational problems in this area is eliminated.
      </t>
      <t>
	If the server detects that there is no mounted point at the
	target file object, then the value for mounted_on_fileid that
	it returns is the same as that of the fileid attribute.
      </t>
      <t>
	The mounted_on_fileid attribute is RECOMMENDED, so the server
	SHOULD provide it if possible, and for a UNIX-based server,
	this is straightforward. Usually, mounted_on_fileid will be
	requested during a READDIR operation, in which case it is
	trivial (at least for UNIX-based servers) to return
	mounted_on_fileid since it is equal to the fileid of a
	directory entry returned by readdir().  If mounted_on_fileid
	is requested in a GETATTR operation, the server should obey an
	invariant that has it returning a value that is equal to the
	file object's entry in the object's parent directory,
	i.e., what readdir() would have returned.  Some operating
	environments allow a series of two or more file systems to be
	mounted onto a single mount point. In this case, for the
	server to obey the aforementioned invariant, it will need to
	find the base mount point, and not the intermediate mount
	points.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_no_trunc"
	     title="Attribute 34: no_trunc">
      <t>
	If this attribute is TRUE, then if the client uses a file
        name longer than name_max, an error will be
	returned instead of the name being truncated.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_numlinks"
	     title="Attribute 35: numlinks">
      <t>
	Number of hard links to this object.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_owner"
	     title="Attribute 36: owner">
      <t>
	The string name of the owner of this object.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_owner_group"
	     title="Attribute 37: owner_group">
      <t>
	The string name of the group ownership of this object.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_quota_avail_hard"
	     title="Attribute 38: quota_avail_hard">
      <t anchor="quota_avail_hard">
	The value in bytes that represents the amount of additional
	disk space beyond the current allocation that can be allocated
	to this file or directory before further allocations will be
	refused.  It is understood that this space may be consumed by
	allocations to other files or directories.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_quota_avail_soft"
	     title="Attribute 39: quota_avail_soft">
      <t anchor="quota_avail_soft">
	The value in bytes that represents the amount of additional
	disk space that can be allocated to this file or directory
	before the user may reasonably be warned.  It is understood
	that this space may be consumed by allocations to other files
	or directories though there is a rule as to which other files
	or directories.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_quota_used"
	     title="Attribute 40: quota_used">
      <t anchor="quota_used">
	The value in bytes that represents the amount of disk
	space used by this file or directory and possibly a
	number of other similar files or directories, where the
	set of "similar" meets at least the criterion that
	allocating space to any file or directory in the set
	will reduce the "quota_avail_hard" of every other file
	or directory in the set.
	<vspace blankLines='1' />
	Note that there may be a number of distinct but
	overlapping sets of files or directories for which a
	quota_used value is maintained, e.g., "all files with a
	given owner", "all files with a given group owner", etc.
	The server is at liberty to choose any of those sets when
        providing the content of the quota_used attribute, but
	should do so in a repeatable way.  The rule may be
	configured per file system or may be "choose the set with
	the smallest quota".
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_rawdev"
	     title="Attribute 41: rawdev">
      <t>
	Raw device number of file of type NF4BLK or NF4CHR. The device
        number is split into major and minor numbers.
	If the file's type attribute is not NF4BLK or NF4CHR,
	the value returned SHOULD NOT be considered useful.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_space_avail"
	     title="Attribute 42: space_avail">
      <t>
	Disk space in bytes available to this user on the file system
	containing this object -- this should be the smallest
	relevant limit.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_space_free"
	     title="Attribute 43: space_free">
      <t>
	Free disk space in bytes on the file system containing this
	object -- this should be the smallest relevant limit.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_space_total"
	     title="Attribute 44: space_total">
      <t>
	Total disk space in bytes on the file system containing this object.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_space_used"
	     title="Attribute 45: space_used">
      <t>
	Number of file system bytes allocated to this object.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_system"
	     title="Attribute 46: system">
      <t>
	This attribute is TRUE if this file is a "system" file with
	respect to the Windows operating environment.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_time_access"
	     title="Attribute 47: time_access">
      <t>
	The time_access attribute represents the time of last access to
	the object by a READ operation sent to the server. The notion
	of what is an "access" depends on the server's operating environment
	and/or the server's file system semantics.  For example, for
	servers obeying Portable Operating System Interface (POSIX) semantics, time_access would be updated only
	by the READ and READDIR operations and not any of the operations
	that modify the content of the object <xref target="read_atime"/>,
	<xref target="readdir_atime"/>, <xref target="write_atime"/>. Of
	course, setting the corresponding time_access_set attribute is
	another way to modify the time_access attribute.

      </t>
      <t>
	Whenever the file object resides on a writable file system,
	the server should make its best efforts to record time_access into
	stable storage.  However, to mitigate the performance effects
	of doing so, and most especially whenever the server is
	satisfying the read of the object's content from its cache,
	the server MAY cache access time updates and lazily write them
	to stable storage.  It is also acceptable to give
	administrators of the server the option to disable time_access
	updates.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_time_access_set"
	     title="Attribute 48: time_access_set">
      <t>
	Sets the time of last access to the object.  SETATTR use only.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_time_backup"
	     title="Attribute 49: time_backup">
      <t>
	The time of last backup of the object.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_time_create"
	     title="Attribute 50: time_create">
      <t>
	The time of creation of the object. This attribute does not
	have any relation to the traditional UNIX file attribute
	"ctime" or "change time".
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_time_delta"
	     title="Attribute 51: time_delta">
      <t>
	Smallest useful server time granularity.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_time_metadata"
	     title="Attribute 52: time_metadata">
      <t>
	The time of last metadata modification of the object.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_time_modify"
	     title="Attribute 53: time_modify">
      <t>
	The time of last modification to the object.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_time_modify_set"
	     title="Attribute 54: time_modify_set">
      <t>
	Sets the time of last modification to the object.  SETATTR use only.
      </t>
    </section>

   </section>

  </section>

  <section anchor="owner_owner_group" 
	   title="Interpreting owner and owner_group">
    <t>
      The RECOMMENDED attributes "owner" and "owner_group" (and also
      users and groups within the "acl" attribute) are represented in
      terms of a UTF-8 string.  To avoid a representation that is tied
      to a particular underlying implementation at the client or
      server, the use of the UTF-8 string has been chosen.  Note that
      Section 6.1 of <xref target="RFC2624">RFC 2624</xref> provides
      additional rationale.  It is expected that the client and server
      will have their own local representation of owner and
      owner_group that is used for local storage or presentation to
      the end user.  Therefore, it is expected that when these
      attributes are transferred between the client and server,
      the local representation is translated to a syntax of the form
      "user@dns_domain".  This will allow for a client and server that
      do not use the same local representation the ability to
      translate to a common syntax that can be interpreted by both.
    </t>
    <t>
      Similarly, security principals may be represented in different
      ways by different security mechanisms.  Servers normally
      translate these representations into a common format,
      generally that used by local storage, to serve as a means of
      identifying the users corresponding to these security
      principals.  When these local identifiers are translated to
      the form of the owner attribute, associated with files created
      by such principals, they identify, in a common format, the
      users associated with each corresponding set of security
      principals.
    </t>
    <t>
      The translation used to interpret owner and group strings is
      not specified as part of the protocol.  This allows various
      solutions to be employed.  For example, a local translation
      table may be consulted that maps a numeric identifier to the
      user@dns_domain syntax.  A name service may also be used to
      accomplish the translation.  A server may provide a more
      general service, not limited by any particular translation
      (which would only translate a limited set of possible strings)
      by storing the owner and owner_group attributes in local
      storage without any translation or it may augment a
      translation method by storing the entire string for attributes
      for which no translation is available while using the local
      representation for those cases in which a translation is
      available.
    </t>
    <t>
      Servers that do not provide support for all possible values of
      the owner and owner_group attributes SHOULD return an error
      (NFS4ERR_BADOWNER) when a string is presented that has no
      translation, as the value to be set for a SETATTR of the
      owner, owner_group, or acl attributes.  When a server does
      accept an owner or owner_group value as valid on a SETATTR
      (and similarly for the owner and group strings in an acl), it
      is promising to return that same string when a corresponding
      GETATTR is done.  Configuration changes (including
      changes from the mapping of the string to the local representation)
      and ill-constructed
      name translations (those that contain aliasing) may make that
      promise impossible to honor.  Servers should make appropriate
      efforts to avoid a situation in which these attributes have
      their values changed when no real change to ownership has
      occurred.
    </t>
    <t>
      The "dns_domain" portion of the owner string is meant to be a
      DNS domain name, for example, user@example.org.  Servers should
      accept as valid a set of users for at least one domain.  A
      server may treat other domains as having no valid
      translations.  A more general service is provided when a
      server is capable of accepting users for multiple domains, or
      for all domains, subject to security constraints.
    </t>
    <t>
      In the case where there is no translation available to the
      client or server, the attribute value will be constructed
      without the "@".  Therefore, the absence of the @ from the
      owner or owner_group attribute signifies that no translation
      was available at the sender and that the receiver of the
      attribute should not use that string as a basis for
      translation into its own internal format.  Even though the
      attribute value cannot be translated, it may still be useful.
      In the case of a client, the attribute string may be used for
      local display of ownership.
    </t>
    <t>
      To provide a greater degree of compatibility with NFSv3,
      which identified users and groups by 32-bit unsigned user
      identifiers and group identifiers, owner and group strings that
      consist of decimal numeric values with no leading zeros can be
      given a special interpretation by clients and servers that
      choose to provide such support.  The receiver may treat such a
      user or group string as representing the same user as would be
      represented by an NFSv3 uid or gid having the corresponding
      numeric value.  A server is not obligated to accept such a
      string, but may return an NFS4ERR_BADOWNER instead.  To avoid
      this mechanism being used to subvert user and group translation,
      so that a client might pass all of the owners and groups in
      numeric form, a server SHOULD return an NFS4ERR_BADOWNER error
      when there is a valid translation for the user or owner
      designated in this way.  In that case, the client must use the
      appropriate name@domain string and not the special form for compatibility.
    </t>
    <t>
      The owner string "nobody" may be used to designate an
      anonymous user, which will be associated with a file created
      by a security principal that cannot be mapped through normal
      means to the owner attribute. Users and implementations
      of NFSv4.1 SHOULD NOT use "nobody" to designate a real user whose access is not anonymous.
    </t>
  </section>

  <section anchor="character_case_attributes" 
	   title="Character Case Attributes">
    <t>
      With respect to the case_insensitive and case_preserving
      attributes, each UCS-4 character (which UTF-8 encodes) can be
      mapped according to Appendix B.2 of 
      <xref target="RFC3454">RFC 3454</xref>.
      For general character handling and internationalization issues,
      see <xref target="internationalization"/>.
    </t>
  </section>

  <section title="Directory Notification Attributes" anchor="dir_not_attrs">
    <t>
      As described in <xref target="OP_GET_DIR_DELEGATION" />, the
      client can request a minimum delay for notifications of changes
      to attributes, but the server is free to ignore what the client
      requests. The client can determine in advance what notification
      delays the server will accept by sending a GETATTR operation for either or
      both of two directory notification attributes.  When the client
      calls the GET_DIR_DELEGATION operation and asks for attribute
      change notifications, it should request notification delays that
      are no less than the values in the server-provided attributes.
    </t>
    <section toc="exclude" anchor="attrdef_dir_notif_delay"
	     title="Attribute 56: dir_notif_delay">
      <t>
	The dir_notif_delay attribute is the minimum number of seconds
	the server will delay before notifying the client of a change
	to the directory's attributes.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_dirent_notif_delay"
	     title="Attribute 57: dirent_notif_delay">
      <t>
	The dirent_notif_delay attribute is the minimum number of seconds
	the server will delay before notifying the client of a change
	to a file object that has an entry in the directory.
      </t>
    </section>

  </section>

  <section anchor="pnfs_attr_full" title="pNFS Attribute Definitions">

    <section toc="exclude" anchor="attrdef_fs_layout_type"
	     title="Attribute 62: fs_layout_type">
      <t>
	The fs_layout_type attribute (see
	<xref target="layouttype4"/>) applies to a
	file system and indicates what layout types are supported by
	the file system.  When the client encounters a new fsid, the
	client SHOULD obtain the value for the fs_layout_type
	attribute associated with the new file system.  This attribute
	is used by the client to determine if the layout types
	supported by the server match any of the client's supported
	layout types.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_layout_alignment"
	     title="Attribute 66: layout_alignment">
      <t>
	When a client holds layouts on files of a file system, the
        layout_alignment attribute indicates the preferred alignment
        for I/O to files on that file system.  Where possible, the
        client should send READ and WRITE operations with offsets
        that are whole multiples of the layout_alignment attribute.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_layout_blksize"
	     title="Attribute 65: layout_blksize">
      <t>
	When a client holds layouts on files of a file system, the
	layout_blksize attribute indicates the preferred block size
	for I/O to files on that file system.  Where possible, the
	client should send READ operations with a count argument that
	is a whole multiple of layout_blksize, and WRITE operations
	with a data argument of size that is a whole multiple of
	layout_blksize.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_layout_hint"
	     title="Attribute 63: layout_hint">
      <t>
	The layout_hint attribute (see
	<xref target="layouthint4"/>) may be set on
	newly created files to influence the metadata server's choice
	for the file's layout.  If possible, this attribute is one of
	those set in the initial attributes within the OPEN operation.
	The metadata server may choose to ignore this attribute.  The
	layout_hint attribute is a subset of the layout structure
	returned by LAYOUTGET.  For example, instead of specifying
	particular devices, this would be used to suggest the stripe
	width of a file.  The server implementation determines which
	fields within the layout will be used.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_layout_type"
	     title="Attribute 64: layout_type">
      <t>
	This attribute lists the layout type(s) available for a file.
	The value returned by the server is for informational purposes
	only.  The client will use the LAYOUTGET operation to obtain
	the information needed in order to perform I/O, for example,
	the specific device information for the file and its layout.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_mdsthreshold"
	     title="Attribute 68: mdsthreshold">
      <t>
	This attribute is a server-provided hint used to communicate
	to the client when it is more efficient to send READ and
	WRITE operations to the metadata server or the data server.
	The two types of thresholds described are file size thresholds
	and I/O size thresholds.  If a file's size is smaller than the
	file size threshold, data accesses SHOULD be sent to the
	metadata server.  If an I/O request has a length
        that is below the I/O size threshold,
	the I/O SHOULD be sent to the metadata server. 
	Each threshold type is specified separately for read and
	write.
      </t>
      <t>
	The server MAY provide both types of thresholds for a file.
	If both file size and I/O size are provided, the client SHOULD
	reach or exceed both thresholds before sending its read or write
	requests to the data server.  Alternatively, if only one of
	the specified thresholds is reached or exceeded, the I/O requests are
	sent to the metadata server.
      </t>
      <t>
	For each threshold type, a value of zero indicates no READ or WRITE
	should be sent to the metadata server, while a value of all ones
	indicates that all READs or WRITEs should be sent to the metadata
	server.
      </t>
      <t> 
	The attribute is available on a per-filehandle basis.  If the
	current filehandle refers to a non-pNFS file or directory, the
	metadata server should return an attribute that is
	representative of the filehandle's file system.  It is suggested
	that this attribute is queried as part of the OPEN operation.
	Due to dynamic system changes, the client should not assume that
	the attribute will remain constant for any specific time period;
	thus, it should be periodically refreshed.
      </t>
    </section>
  </section> <!-- "PNFS Attributes" -->

  <section anchor="retention" title="Retention Attributes">
    <t>
      Retention is a concept whereby a file object can be placed in an
      immutable, undeletable, unrenamable state for a fixed or
      infinite duration of time. Once in this "retained" state, the
      file cannot be moved out of the state until the duration of
      retention has been reached.
    </t>
    <t>
      When retention is enabled, retention MUST extend to the data of
      the file, and the name of file. The server MAY extend retention
      to any other property of the file, including any subset of
      REQUIRED, RECOMMENDED, and named attributes, with the
      exceptions noted in this section.
    </t>
    <t>
      Servers MAY support or not support retention on
      any file object type.
    </t>
    <t>
      The five retention attributes are explained in the next subsections.
    </t>

    <section toc="exclude" anchor="attrdef_retention_get"
	     title="Attribute 69: retention_get">
      <t>
      If retention is enabled for the associated file,
      this attribute's value represents the retention
      begin time of the file object.   This attribute's
      value is only readable with the GETATTR operation
      and MUST NOT be modified by the SETATTR operation
      (<xref target="rw_attr"/>).  The value of the
      attribute consists of:

<figure>
 <artwork>
const RET4_DURATION_INFINITE    = 0xffffffffffffffff;
struct retention_get4 {
        uint64_t        rg_duration;
        nfstime4        rg_begin_time&lt;1>;
};
 </artwork>
</figure>

      The field rg_duration is the duration in seconds indicating how
      long the file will be retained once retention is enabled. The
      field rg_begin_time is an array of up to one absolute time
      value. If the array is zero length, no beginning retention time
      has been established, and retention is not enabled.  
      If rg_duration is equal to RET4_DURATION_INFINITE, the file, once
      retention is enabled, will be retained for an infinite duration.
     </t>
     <t>
      If (as soon as) rg_duration is zero, then rg_begin_time will be
      of zero length, and again, retention is not (no longer) enabled.

     </t>
    </section>

    <section toc="exclude" anchor="attrdef_retention_set"
	     title="Attribute 70: retention_set">
      <t>
	This attribute is used to set the retention
	duration and optionally enable retention for
	the associated file object.  This attribute is
	only modifiable via the SETATTR operation and 
        MUST NOT be retrieved by the GETATTR operation
        (<xref target="rw_attr"/>). 
	This attribute corresponds to retention_get.
	The value of the attribute consists of:

<figure>
 <artwork>
struct retention_set4 {
        bool            rs_enable;
        uint64_t        rs_duration&lt;1>;
};
 </artwork>
</figure>

        If the client sets rs_enable to TRUE, then it is enabling
        retention on the file object with the begin time of retention
        starting from the server's current time and date. The
        duration of the retention can also be provided if the
        rs_duration array is of length one.  The duration is the time in
        seconds from the begin time of retention, and if set to
        RET4_DURATION_INFINITE, the file is to be retained forever. If
        retention is enabled, with no duration specified in either
        this SETATTR or a previous SETATTR, the duration defaults to
        zero seconds.  The server MAY restrict the enabling of
        retention or the duration of retention on the basis of the
        ACE4_WRITE_RETENTION ACL permission.  The enabling of
        retention MUST NOT prevent the enabling of event-based
        retention or the modification of the retention_hold
        attribute.
      </t>
      <t>
       The following rules apply to both the retention_set and
       retentevt_set attributes.

       <list style='symbols'>
       <t>
	 As long as retention is not enabled, the client
	 is permitted to decrease the duration.

       </t>
       <t>
	 The duration can always be set to an
	 equal or higher value, even if retention is
	 enabled. Note that once retention is enabled,
	 the actual duration (as returned by the
	 retention_get or retentevt_get attributes;
	 see <xref target="attrdef_retention_get"/>
	 or <xref target="attrdef_retentevt_get"/>)
	 is constantly counting down to zero (one unit
	 per second), unless the duration was set to
	 RET4_DURATION_INFINITE.  Thus, it will not be
	 possible for the client to precisely extend the
	 duration on a file that has retention enabled.

       </t>
       <t>
	 While retention is enabled, attempts to disable
	 retention or decrease the retention's duration
	 MUST fail with the error NFS4ERR_INVAL.

       </t>
   
       <t>
         If the principal attempting to change
         retention_set or retentevt_set does not have
         ACE4_WRITE_RETENTION permissions, the attempt
         MUST fail with NFS4ERR_ACCESS.

       </t>

       </list>
      </t>

    </section>

    <section toc="exclude" anchor="attrdef_retentevt_get"
	     title="Attribute 71: retentevt_get">
      <t>
	Gets the event-based retention duration, and if enabled, the
        event-based retention begin time of the file object.  This
        attribute is like retention_get, but refers to event-based
        retention.  The event that triggers event-based retention is
        not defined by the NFSv4.1 specification.
      </t>
    </section>

    <section toc="exclude" anchor="attrdef_retentevt_set"
	     title="Attribute 72: retentevt_set">
      <t>
	Sets the event-based retention duration, and optionally enables
	event-based retention on the file object.  This attribute
	corresponds to retentevt_get and is like retention_set, but
	refers to event-based retention.  When event-based retention
	is set, the file MUST be retained even if non-event-based
	retention has been set, and the duration of non-event-based
	retention has been reached. Conversely, when non-event-based
	retention has been set, the file MUST be retained even if
	event-based retention has been set, and the duration of
	event-based retention has been reached.  The server MAY
	restrict the enabling of event-based retention or the duration
	of event-based retention on the basis of the
	ACE4_WRITE_RETENTION ACL permission.  The enabling of
	event-based retention MUST NOT prevent the enabling of
	non-event-based retention or the modification of the
	retention_hold attribute.
     </t>
    </section>


    <section toc="exclude" anchor="attrdef_retention_hold"
	     title="Attribute 73: retention_hold">
      <t>
	Gets or sets administrative retention holds, one hold per bit
        position.
      </t>
      <t>
	This attribute allows one to 64 administrative holds, one hold
	per bit on the attribute. If retention_hold is not zero, then
	the file MUST NOT be deleted, renamed, or modified, even if
	the duration on enabled event or non-event-based retention has
	been reached.  The server MAY restrict the modification of
	retention_hold on the basis of the ACE4_WRITE_RETENTION_HOLD
	ACL permission.  The enabling of administration retention
	holds does not prevent the enabling of event-based or
	non-event-based retention.
      </t>
      <t>
	If the principal attempting to change retention_hold does
	not have ACE4_WRITE_RETENTION_HOLD permissions,
	the attempt MUST fail with NFS4ERR_ACCESS.
      </t>
    </section>
  </section>
</section>
<!--    $Id: 2009-12-20-TO-rfc5661.xml,v 1.2 2009/12/21 05:59:32 shepler.mre Exp $  -->
<!-- Copyright (C) The IETF Trust (2007-2008) -->
<!-- Copyright (C) The Internet Society (2006) -->
<section title="Access Control Attributes" anchor="acl">
    <t>
        Access Control Lists (ACLs) are file attributes that specify
        fine-grained access control. This section covers the
        &quot;acl&quot;, &quot;dacl&quot;, &quot;sacl&quot;,
        &quot;aclsupport&quot;, &quot;mode&quot;, and
        &quot;mode_set_masked&quot; file attributes and their
        interactions.  Note that file attributes may apply to any file
        system object.
    </t>
    
    <section title="Goals">
      <t>
        ACLs and modes represent two well-established models for
        specifying permissions. This section specifies requirements
        that attempt to meet the following goals:

        <list style="symbols">
          <t>
            If a server supports the mode attribute, it should provide
            reasonable semantics to clients that only set and retrieve
            the mode attribute.
          </t>
          <t>
            If a server supports ACL attributes, it should provide
            reasonable semantics to clients that only set and retrieve
            those attributes.
          </t>
          <t>
            On servers that support the mode attribute, if ACL
            attributes have never been set on an object, via
            inheritance or explicitly, the behavior should be
            traditional UNIX-like behavior.
          </t>
          <t>
            On servers that support the mode attribute, if the ACL
            attributes have been previously set on an object, either
            explicitly or via inheritance:
            <list>
              <t>
                Setting only the mode attribute should effectively
                control the traditional UNIX-like permissions of read,
                write, and execute on owner, owner_group, and other.
              </t>
              <t>
                Setting only the mode attribute should provide
                reasonable security. For example, setting a mode of
                000 should be enough to ensure that future OPEN operations for
                OPEN4_SHARE_ACCESS_READ or OPEN4_SHARE_ACCESS_WRITE by any principal fail, regardless of a
                previously existing or inherited ACL.
              </t>
            </list>
          </t>
          <t>
            NFSv4.1 may introduce different
            semantics relating to the mode and ACL attributes,
            but it does not render invalid any previously
            existing implementations. Additionally, this
            section provides clarifications based on previous
            implementations and discussions around them.
          </t>
          <t>
            On servers that support both the mode and the acl or
            dacl attributes, the server must keep the two consistent
            with each other.  The value of the mode attribute (with
            the exception of the three high-order bits described in
            <xref target="attrdef_mode" />) must be determined entirely
            by the value of the ACL, so that use of the mode is
            never required for anything other than setting the
            three high-order bits.  See <xref target="setattr" />
            for exact requirements.
          </t>
          <t>
            When a mode attribute is set on an object, the ACL
            attributes may need to be modified in order to not conflict
            with the new mode. In such cases, it is desirable that the
            ACL keep as much information as possible. This includes
            information about inheritance, AUDIT and ALARM ACEs, and
            permissions granted and denied that do not conflict with
            the new mode.
          </t>
        </list>
      </t>
    </section>
    
    <section title="File Attributes Discussion">
      <section anchor="attrdef_acl"
	       title="Attribute 12: acl">
        <t>
          The NFSv4.1 ACL attribute contains an array of Access
          Control Entries (ACEs) that are associated with the file
          system object.  Although the client can set and
          get the acl attribute, the server is responsible for using
          the ACL to perform access control. The client can use the
          OPEN or ACCESS operations to check access without modifying
          or reading data or metadata.
        </t>

        <t>
          The NFS ACE structure is defined as follows:
        </t>
<figure>
 <artwork>
typedef uint32_t        acetype4;
 </artwork>
</figure>
<figure>
 <artwork>
typedef uint32_t aceflag4;
 </artwork>
</figure>
<figure>
 <artwork>
typedef uint32_t        acemask4;
 </artwork>
</figure>
<figure>
 <artwork>
struct nfsace4 {
        acetype4        type;
        aceflag4        flag;
        acemask4        access_mask;
        utf8str_mixed   who;
};
 </artwork>
</figure>

        <t>
          To determine if a request succeeds, the server processes
          each nfsace4 entry in order.  Only ACEs that have a "who"
          that matches the requester are considered.  Each ACE is
          processed until all of the bits of the requester's access
          have been ALLOWED.  Once a bit (see below) has been ALLOWED
          by an ACCESS_ALLOWED_ACE, it is no longer considered in the
          processing of later ACEs.  If an ACCESS_DENIED_ACE is
          encountered where the requester's access still has unALLOWED
          bits in common with the "access_mask" of the ACE, the
          request is denied.  When the ACL is fully processed, if
          there are bits in the requester's mask that have not been
          ALLOWED or DENIED, access is denied.
        </t>
        <t>
          Unlike the ALLOW and DENY ACE types, the ALARM and AUDIT ACE
          types do not affect a requester's access, and instead are
          for triggering events as a result of a requester's access
          attempt.  Therefore, AUDIT and ALARM ACEs are processed only
          after processing ALLOW and DENY ACEs.
        </t>
        <t>
          The NFSv4.1 ACL model is quite rich. Some server
          platforms may provide access-control functionality that goes
          beyond the UNIX-style mode attribute, but that is not as
          rich as the NFS ACL model.  So that users can take advantage
          of this more limited functionality, the server may support
          the acl attributes by mapping between its ACL model and the
          NFSv4.1 ACL model.  Servers must ensure that the ACL
          they actually store or enforce is at least as strict as the
          NFSv4 ACL that was set.  It is tempting to accomplish this
          by rejecting any ACL that falls outside the small set that
          can be represented accurately.  However, such an approach
          can render ACLs unusable without special client-side
          knowledge of the server's mapping, which defeats the purpose
          of having a common NFSv4 ACL protocol.  Therefore, servers
          should accept every ACL that they can without compromising
          security.  To help accomplish this, servers may make a
          special exception, in the case of unsupported permission
          bits, to the rule that bits not ALLOWED or DENIED by an ACL
          must be denied.  For example, a UNIX-style server might
          choose to silently allow read attribute permissions even
          though an ACL does not explicitly allow those permissions.
          (An ACL that explicitly denies permission to read attributes
          should still be rejected.)
        </t>
        <t>
          The situation is complicated by the fact that a server may
          have multiple modules that enforce ACLs. For example, the
          enforcement for NFSv4.1 access may be different from,
          but not weaker than, the enforcement for local access, and
          both may be different from the enforcement for access
          through other protocols such as SMB (Server Message Block). So it may be useful for
          a server to accept an ACL even if not all of its modules are
          able to support it.
        </t>
        <t>
          The guiding principle with regard to NFSv4 access is
          that the server must not accept ACLs that appear to
          make access to the file more restrictive than it really is.
        </t>

        <section title="ACE Type">
          <t>
            The constants used for the type field (acetype4) are as
            follows:
          </t>

<figure>
 <artwork>
const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;
const ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;
const ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;
const ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;
 </artwork>
</figure>
          <t>
            Only the ALLOWED and DENIED bits may be used in the
            dacl attribute, and only the AUDIT and ALARM bits may be
            used in the sacl attribute.  All four are permitted in the
            acl attribute.
          </t>
          <texttable>
            <ttcol>Value</ttcol>
            <ttcol>Abbreviation</ttcol>
            <ttcol>Description</ttcol>
            <c>ACE4_ACCESS_ALLOWED_ACE_TYPE</c>
            <c>ALLOW</c>
            <c>
              Explicitly grants the access defined in acemask4 to
              the file or directory.
            </c>
            <c>ACE4_ACCESS_DENIED_ACE_TYPE</c>
            <c>DENY</c>
            <c>
              Explicitly denies the access defined in acemask4 to
              the file or directory.
            </c>
            <c>ACE4_SYSTEM_AUDIT_ACE_TYPE</c>
            <c>AUDIT</c>
            <c>
              Log (in a system-dependent way) any access attempt to
              a file or directory that uses any of the access
              methods specified in acemask4.
            </c>
            <c>ACE4_SYSTEM_ALARM_ACE_TYPE</c>
            <c>ALARM</c>
            <c>
              Generate an alarm (in a system-dependent way) when any
              access attempt is made to a file or directory for the
              access methods specified in acemask4.
            </c>
          </texttable>
            <t>
              The &quot;Abbreviation&quot; column denotes how the
              types will be referred to throughout the rest of this
              section.
            </t>
        </section>
	<section anchor="attrdef_aclsupport"
	     title="Attribute 13: aclsupport">
          <t>
            A server need not support all of the above ACE types.
	    This attribute indicates which ACE types are supported for
	    the current file system.  The bitmask constants used to
	    represent the above definitions within the aclsupport
	    attribute are as follows:
          </t>

<figure>
 <artwork>
const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;
const ACL4_SUPPORT_DENY_ACL     = 0x00000002;
const ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;
const ACL4_SUPPORT_ALARM_ACL    = 0x00000008;
 </artwork>
</figure>
          <t>
            Servers that support either the ALLOW or DENY ACE type
            SHOULD support both ALLOW and DENY ACE types.
          </t>
          <t>
            Clients should not attempt to set an ACE unless the server
            claims support for that ACE type. If the server receives a
            request to set an ACE that it cannot store, it MUST reject
            the request with NFS4ERR_ATTRNOTSUPP. If the server
            receives a request to set an ACE that it can store but
            cannot enforce, the server SHOULD reject the request with
            NFS4ERR_ATTRNOTSUPP.
          </t>
          <t>
            Support for any of the ACL attributes is
            optional (albeit RECOMMENDED).
            However, a server that supports either of the new ACL
            attributes (dacl or sacl) MUST allow use of the new ACL
            attributes to access all of the ACE types that it
            supports.  In other words, if such a server supports ALLOW
            or DENY ACEs, then it MUST support the dacl attribute, and
            if it supports AUDIT or ALARM ACEs, then it MUST support
            the sacl attribute.
          </t>
        </section>
        <section anchor="acemask" title="ACE Access Mask">
          <t>
            The bitmask constants used for the access mask field
            are as follows:
          </t>

<figure>
 <artwork>
const ACE4_READ_DATA            = 0x00000001;
const ACE4_LIST_DIRECTORY       = 0x00000001;
const ACE4_WRITE_DATA           = 0x00000002;
const ACE4_ADD_FILE             = 0x00000002;
const ACE4_APPEND_DATA          = 0x00000004;
const ACE4_ADD_SUBDIRECTORY     = 0x00000004;
const ACE4_READ_NAMED_ATTRS     = 0x00000008;
const ACE4_WRITE_NAMED_ATTRS    = 0x00000010;
const ACE4_EXECUTE              = 0x00000020;
const ACE4_DELETE_CHILD         = 0x00000040;
const ACE4_READ_ATTRIBUTES      = 0x00000080;
const ACE4_WRITE_ATTRIBUTES     = 0x00000100;
const ACE4_WRITE_RETENTION      = 0x00000200;
const ACE4_WRITE_RETENTION_HOLD = 0x00000400;

const ACE4_DELETE               = 0x00010000;
const ACE4_READ_ACL             = 0x00020000;
const ACE4_WRITE_ACL            = 0x00040000;
const ACE4_WRITE_OWNER          = 0x00080000;
const ACE4_SYNCHRONIZE          = 0x00100000;
 </artwork>
</figure>
          <t>

	   Note that some masks have coincident values, for
	   example, ACE4_READ_DATA and ACE4_LIST_DIRECTORY.
	   The mask entries ACE4_LIST_DIRECTORY,
	   ACE4_ADD_FILE, and ACE4_ADD_SUBDIRECTORY are
	   intended to be used with directory objects,
	   while ACE4_READ_DATA, ACE4_WRITE_DATA, and
	   ACE4_APPEND_DATA are intended to be used with
	   non-directory objects.

          </t>
          <section title="Discussion of Mask Attributes">
	    <t>
	      <list style="hanging">
		<t hangText="ACE4_READ_DATA">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="READ" />
			<t hangText="OPEN" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      Permission to read the data of the file.
		      <vspace blankLines='1' />
		      Servers SHOULD allow a user the ability to read the data
		      of the file when only the ACE4_EXECUTE access mask bit is
		      allowed.
		    </t>
		  </list>
		</t>

		<t hangText="ACE4_LIST_DIRECTORY">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="READDIR" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      Permission to list the contents of a directory.
		    </t>
		  </list>
		</t>

		<t hangText="ACE4_WRITE_DATA">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="WRITE" />
			<t hangText="OPEN" />
			<t hangText="SETATTR of size" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      Permission to modify a file's data.
		    </t>
		  </list>
		</t>

		<t hangText="ACE4_ADD_FILE">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="CREATE" />
			<t hangText="LINK" />
			<t hangText="OPEN" />
			<t hangText="RENAME" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      Permission to add a new file in a directory.
		      The CREATE operation is affected when nfs_ftype4
		      is NF4LNK, NF4BLK, NF4CHR, NF4SOCK, or
		      NF4FIFO. (NF4DIR is not listed because it is
		      covered by ACE4_ADD_SUBDIRECTORY.) OPEN is
		      affected when used to create a regular file.
		      LINK and RENAME are always affected.
		    </t>
		  </list>
		</t>

		<t hangText="ACE4_APPEND_DATA">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="WRITE" />
			<t hangText="OPEN" />
			<t hangText="SETATTR of size" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      The ability to modify a file's data, but only
		      starting at EOF.  This allows for the notion of
		      append-only files, by allowing ACE4_APPEND_DATA
		      and denying ACE4_WRITE_DATA to the same user or
		      group.  If a file has an ACL such as the one
		      described above and a WRITE request is made for
		      somewhere other than EOF, the server SHOULD
		      return NFS4ERR_ACCESS.
		    </t>
		  </list>
		</t>

		<t hangText="ACE4_ADD_SUBDIRECTORY">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="CREATE" />
			<t hangText="RENAME" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      Permission to create a subdirectory in a
		      directory.  The CREATE operation is affected
		      when nfs_ftype4 is NF4DIR.  The RENAME operation
		      is always affected.
		    </t>
		  </list>
		</t>

		<t hangText="ACE4_READ_NAMED_ATTRS">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="OPENATTR" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      Permission to read the named attributes of a
		      file or to look up the named attribute
		      directory.  OPENATTR is affected when it is not
		      used to create a named attribute directory.
		      This is when 1) createdir is TRUE, but a named
		      attribute directory already exists, or 2)
		      createdir is FALSE.
		    </t>
		  </list>
		</t>

		<t hangText="ACE4_WRITE_NAMED_ATTRS">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="OPENATTR" />
			<t hangText="" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      Permission to write the named attributes of a
		      file or to create a named attribute directory.
		      OPENATTR is affected when it is used to create a
		      named attribute directory.  This is when
		      createdir is TRUE and no named attribute
		      directory exists.  The ability to check whether
		      or not a named attribute directory exists
		      depends on the ability to look it up; therefore,
		      users also need the ACE4_READ_NAMED_ATTRS
		      permission in order to create a named attribute
		      directory.
		    </t>
		  </list>
		</t>

		<t hangText="ACE4_EXECUTE">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="READ" />
			<t hangText="OPEN" />
			<t hangText="REMOVE" />
			<t hangText="RENAME" />
			<t hangText="LINK" />
			<t hangText="CREATE" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      Permission to execute a file.
		      <vspace blankLines='1' />
		      Servers SHOULD allow a
		      user the ability to read the data of the file
		      when only the ACE4_EXECUTE access mask bit is
		      allowed.  This is because there is no way to
		      execute a file without reading the contents.
		      Though a server may treat ACE4_EXECUTE and
		      ACE4_READ_DATA bits identically when deciding to
		      permit a READ operation, it SHOULD still allow
		      the two bits to be set independently in ACLs,
		      and MUST distinguish between them when replying
		      to ACCESS operations.  In particular, servers
		      SHOULD NOT silently turn on one of the two bits
		      when the other is set, as that would make it
		      impossible for the client to correctly enforce
		      the distinction between read and execute
		      permissions.  
		      <vspace blankLines='1' />
		      As an example, following a SETATTR of the following ACL:
		      <vspace blankLines='1' />
                      nfsuser:ACE4_EXECUTE:ALLOW
		      <vspace blankLines='1' />
		      A subsequent GETATTR of ACL for that file SHOULD return:
		      <vspace blankLines='1' />
                      nfsuser:ACE4_EXECUTE:ALLOW
		      <vspace blankLines='1' />
		      Rather than:
		      <vspace blankLines='1' />
                      nfsuser:ACE4_EXECUTE/ACE4_READ_DATA:ALLOW
		    </t>
		  </list>
		</t>

		<t hangText="ACE4_EXECUTE">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="LOOKUP" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      Permission to traverse/search a directory.
		    </t>
		  </list>
		</t>

		<t hangText="ACE4_DELETE_CHILD">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="REMOVE" />
			<t hangText="RENAME" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      Permission to delete a file or directory within
		      a directory. 

		      See <xref
		      target="delete-delete_child"/>
		      for information on ACE4_DELETE and
		      ACE4_DELETE_CHILD interact.

		    </t>
		  </list>
		</t>

		<t hangText="ACE4_READ_ATTRIBUTES">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="GETATTR of file system object attributes" />
			<t hangText="VERIFY" />
			<t hangText="NVERIFY" />
			<t hangText="READDIR" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      The ability to read basic attributes (non-ACLs)
		      of a file.  On a UNIX system, basic attributes
		      can be thought of as the stat-level attributes.
		      Allowing this access mask bit would mean that the
		      entity can execute "ls -l" and stat.  If a
		      READDIR operation requests attributes, this mask
		      must be allowed for the READDIR to succeed.
		    </t>
		  </list>
		</t>

		<t hangText="ACE4_WRITE_ATTRIBUTES">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="SETATTR of time_access_set, time_backup," />
			<t hangText="time_create, time_modify_set, mimetype, hidden, system" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      Permission to change the times associated with a
		      file or directory to an arbitrary value.  Also
		      permission to change the mimetype, hidden, and
		      system attributes.  A user having
		      ACE4_WRITE_DATA or ACE4_WRITE_ATTRIBUTES will be
		      allowed to set the times associated with a file
		      to the current server time.
		    </t>
		  </list>
		</t>

		<t hangText="ACE4_WRITE_RETENTION">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="SETATTR of retention_set, retentevt_set." />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      Permission to modify the durations of event and
		      non-event-based retention. Also permission to
		      enable event and non-event-based retention. A
		      server MAY behave such that setting
		      ACE4_WRITE_ATTRIBUTES allows
		      ACE4_WRITE_RETENTION.
		    </t>
		  </list>
		</t>

		<t hangText="ACE4_WRITE_RETENTION_HOLD">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="SETATTR of retention_hold." />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      Permission to modify the administration
		      retention holds.  A server MAY map
		      ACE4_WRITE_ATTRIBUTES to
		      ACE_WRITE_RETENTION_HOLD.
		    </t>
		  </list>
		</t>

		<t hangText="ACE4_DELETE">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="REMOVE" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />

		      Permission to delete the
		      file or directory. 

		      See <xref
		      target="delete-delete_child"/>
		      for information on ACE4_DELETE and
		      ACE4_DELETE_CHILD interact.

		    </t>
		  </list>
		</t>

		<t hangText="ACE4_READ_ACL">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="GETATTR of acl, dacl, or sacl" />
			<t hangText="NVERIFY" />
			<t hangText="VERIFY" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      Permission to read the ACL.
		    </t>
		  </list>
		</t>

		<t hangText="ACE4_WRITE_ACL">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="SETATTR of acl and mode" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      Permission to write the acl and mode attributes.
		    </t>
		  </list>
		</t>

		<t hangText="ACE4_WRITE_OWNER">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="SETATTR of owner and owner_group" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      Permission to write the owner and owner_group
		      attributes.  On UNIX systems, this is the
		      ability to execute chown() and chgrp().
		    </t>
		  </list>
		</t>

		<t hangText="ACE4_SYNCHRONIZE">
		  <list style="hanging">
		    <t hangText="Operation(s) affected:">
		      <list style="hanging">
			<t hangText="NONE" />
		      </list>
		    </t>
		    <t hangText="Discussion:">
		      <vspace blankLines='1' />
		      Permission to use the file object as a
		      synchronization primitive for interprocess
		      communication. This permission is not enforced
		      or interpreted by the NFSv4.1 server on behalf of
		      the client.

		      <vspace blankLines='1' />

                      Typically, the ACE4_SYNCHRONIZE permission is
                      only meaningful on local file systems, i.e.,
                      file systems not accessed via NFSv4.1. The reason
                      that the permission bit exists is that some operating
                      environments, such as Windows, use ACE4_SYNCHRONIZE.

		      <vspace blankLines='1' />

                      For example, if a client copies a file that has
                      ACE4_SYNCHRONIZE set from a local file system to
                      an NFSv4.1 server, and then later copies the file
                      from the NFSv4.1 server to a local file system,
                      it is likely that if ACE4_SYNCHRONIZE was set
                      in the original file, the client will want it
                      set in the second copy.  The first copy will not
                      have the permission set unless the NFSv4.1 server
                      has the means to set the ACE4_SYNCHRONIZE bit. The
                      second copy will not have the permission set unless
                      the NFSv4.1 server has the means to retrieve the
                      ACE4_SYNCHRONIZE bit.

		    </t>
		  </list>
		</t>

	      </list>
	    </t>

            <t>
              Server implementations need not provide the granularity
              of control that is implied by this list of masks. For
              example, POSIX-based systems might not distinguish
              ACE4_APPEND_DATA (the ability to append to a file) from
              ACE4_WRITE_DATA (the ability to modify existing
              contents); both masks would be tied to a single "write"
              permission <xref target="chmod"/>. When such a server returns attributes to the
              client, it would show both ACE4_APPEND_DATA and
              ACE4_WRITE_DATA if and only if the write permission is
              enabled.
            </t>

            <t>
              If a server receives a SETATTR request that it cannot
              accurately implement, it should err in the direction of
              more restricted access, except in the previously
              discussed cases of execute and read. For example,
              suppose a server cannot distinguish overwriting data
              from appending new data, as described in the previous
              paragraph.  If a client submits an ALLOW ACE where
              ACE4_APPEND_DATA is set but ACE4_WRITE_DATA is not (or
              vice versa), the server should either turn off
              ACE4_APPEND_DATA or reject the request with
              NFS4ERR_ATTRNOTSUPP.
            </t>
          </section>

          <section anchor="delete-delete_child" title="ACE4_DELETE vs. ACE4_DELETE_CHILD">
            <t>
              Two access mask bits govern the ability to delete a
              directory entry: ACE4_DELETE on the object
              itself (the "target") and ACE4_DELETE_CHILD on
              the containing directory (the "parent").
            </t>

            <t>
              Many systems also take the "sticky bit" (MODE4_SVTX)
              on a directory to allow unlink only to a user that
              owns either the target or the parent; on some
              such systems the decision also depends on
              whether the target is writable.
            </t>

            <t>
              Servers SHOULD allow unlink if either ACE4_DELETE
              is permitted on the target, or ACE4_DELETE_CHILD is
              permitted on the parent.  (Note that this is
              true even if the parent or target explicitly
              denies one of these permissions.)
            </t>

            <t>
              If the ACLs in question neither explicitly ALLOW
              nor DENY either of the above, and if MODE4_SVTX is
              not set on the parent, then the server SHOULD allow
              the removal if and only if ACE4_ADD_FILE is permitted.
              In the case where MODE4_SVTX is set, the server
              may also require the remover to own either the parent
              or the target, or may require the target to be
              writable.
            </t>

            <t>
              This allows servers to support something close to
              traditional UNIX-like semantics, with ACE4_ADD_FILE
              taking the place of the write bit.
            </t>

          </section>
        </section>
        <section anchor="aceflag" title="ACE flag">
          <t>
            The bitmask constants used for the flag field are as
            follows:
<figure>
 <artwork>
const ACE4_FILE_INHERIT_ACE             = 0x00000001;
const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;
const ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;
const ACE4_INHERIT_ONLY_ACE             = 0x00000008;
const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;
const ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;
const ACE4_IDENTIFIER_GROUP             = 0x00000040;
const ACE4_INHERITED_ACE                = 0x00000080;
 </artwork>
</figure>

            A server need not support any of these flags. If the
            server supports flags that are similar to, but not
            exactly the same as, these flags, the implementation
            may define a mapping between the protocol-defined
            flags and the implementation-defined flags.
          </t>

          <t>
            For example, suppose a client tries to set an ACE with
            ACE4_FILE_INHERIT_ACE set but not
            ACE4_DIRECTORY_INHERIT_ACE. If the server does not
            support any form of ACL inheritance, the server should
            reject the request with NFS4ERR_ATTRNOTSUPP. If the
            server supports a single "inherit ACE" flag that
            applies to both files and directories, the server may
            reject the request (i.e., requiring the client to set
            both the file and directory inheritance flags). The
            server may also accept the request and silently turn
            on the ACE4_DIRECTORY_INHERIT_ACE flag.
          </t>
          <section title="Discussion of Flag Bits">


            <t>
              <list style="hanging">
                <t hangText="ACE4_FILE_INHERIT_ACE">
                  <vspace />
                  Any non-directory file in any
                  sub-directory will get this ACE
                  inherited.
                </t>

                <t hangText="ACE4_DIRECTORY_INHERIT_ACE">
                  <vspace />
                  Can be placed on a directory and indicates
                  that this ACE should be added to each new
                  directory created.
                  <vspace />
                  If this flag is set in an ACE in an ACL
                  attribute to be set on a non-directory
                  file system object, the operation
                  attempting to set the ACL SHOULD fail
                  with NFS4ERR_ATTRNOTSUPP.
                </t>



                <t hangText="ACE4_NO_PROPAGATE_INHERIT_ACE">
                  <vspace />
                  Can be placed on a directory.  This flag
                  tells the server that inheritance of this
                  ACE should stop at newly created child
                  directories.
                </t>

                <t hangText="ACE4_INHERIT_ONLY_ACE">
                  <vspace />
                  Can be placed on a directory but does not
                  apply to the directory; ALLOW and DENY ACEs
                  with this bit set do not affect access to
                  the directory, and AUDIT and ALARM ACEs
                  with this bit set do not trigger log or
                  alarm events.  Such ACEs only take effect
                  once they are applied (with this bit
                  cleared) to newly created files and
                  directories as specified by the
                  ACE4_FILE_INHERIT_ACE and ACE4_DIRECTORY_INHERIT_ACE
                  flags.
                  <vspace blankLines="1"/>
                  If this flag is present on an ACE, but
                  neither ACE4_DIRECTORY_INHERIT_ACE nor
                  ACE4_FILE_INHERIT_ACE is present, then
                  an operation attempting to set such an
                  attribute SHOULD fail with
                  NFS4ERR_ATTRNOTSUPP.
                </t>



                <t hangText="ACE4_SUCCESSFUL_ACCESS_ACE_FLAG">
                  <vspace />
                </t>
                <t hangText="ACE4_FAILED_ACCESS_ACE_FLAG">
                  <vspace />
                  The ACE4_SUCCESSFUL_ACCESS_ACE_FLAG
                  (SUCCESS) and ACE4_FAILED_ACCESS_ACE_FLAG
                  (FAILED) flag bits may be set only on
                  ACE4_SYSTEM_AUDIT_ACE_TYPE (AUDIT) and
                  ACE4_SYSTEM_ALARM_ACE_TYPE (ALARM) ACE
                  types. If during the processing of the
                  file's ACL, the server encounters an AUDIT
                  or ALARM ACE that matches the principal
                  attempting the OPEN, the server notes that
                  fact, and the presence, if any, of the
                  SUCCESS and FAILED flags encountered in
                  the AUDIT or ALARM ACE. Once the server
                  completes the ACL processing, it then
                  notes if the operation succeeded or
                  failed. If the operation succeeded, and if
                  the SUCCESS flag was set for a matching
                  AUDIT or ALARM ACE, then the appropriate
                  AUDIT or ALARM event occurs. If the
                  operation failed, and if the FAILED flag
                  was set for the matching AUDIT or ALARM 
                  ACE, then the appropriate AUDIT or ALARM
                  event occurs.  Either or both of the
                  SUCCESS or FAILED can be set, but if
                  neither is set, the AUDIT or ALARM ACE is
                  not useful.
                </t>

                <t hangText="">
                  The previously described processing
                  applies to ACCESS operations even when
                  they return NFS4_OK.  For the purposes of
                  AUDIT and ALARM, we consider an ACCESS
                  operation to be a "failure" if it fails
                  to return a bit that was requested and
                  supported.
                </t>

                <t hangText="ACE4_IDENTIFIER_GROUP">
                  <vspace />
                  Indicates that the "who" refers to a GROUP
                  as defined under UNIX or a GROUP ACCOUNT
                  as defined under Windows. Clients and
                  servers MUST ignore the
                  ACE4_IDENTIFIER_GROUP flag on ACEs with a
                  who value equal to one of the special
                  identifiers outlined in
                  <xref target="acewho" />.
                </t>

                <t hangText="ACE4_INHERITED_ACE">
                  <vspace />
                  Indicates that this ACE is inherited from
                  a parent directory.  A server that supports
                  automatic inheritance will place
                  this flag on any ACEs inherited from the
                  parent directory when creating a new
                  object.  Client applications will use this
                  to perform automatic inheritance.
                  Clients and servers MUST clear this
                  bit in the acl attribute; it may only
                  be used in the dacl and sacl attributes.
                </t>
              </list>
            </t>
          </section>
        </section>
        <section title="ACE Who" anchor="acewho">
          <t>
            The &quot;who&quot; field of an ACE is an identifier that
            specifies the principal or principals to whom the ACE
            applies. It may refer to a user or a group, with the flag
            bit ACE4_IDENTIFIER_GROUP specifying which.
          </t>
          <t>
            There are several special identifiers that need to be
            understood universally, rather than in the context of a
            particular DNS domain. Some of these identifiers cannot be
            understood when an NFS client accesses the server, but
            have meaning when a local process accesses the file. The
            ability to display and modify these permissions is
            permitted over NFS, even if none of the access methods on
            the server understands the identifiers.
          </t>
          <texttable anchor="specialwho">
            <ttcol>Who</ttcol>
            <ttcol>Description</ttcol>
            <c>OWNER</c>
            <c>
              The owner of the file.
            </c>
            <c>GROUP</c>
            <c>
              The group associated with the file.
            </c>
            <c>EVERYONE</c>
            <c>
              The world, including the owner and owning group.
            </c>
            <c>INTERACTIVE</c>
            <c>
              Accessed from an interactive terminal.
            </c>
            <c>NETWORK</c>
            <c>
              Accessed via the network.
            </c>
            <c>DIALUP</c>
            <c>
              Accessed as a dialup user to the server.
            </c>
            <c>BATCH</c>
            <c>
              Accessed from a batch job.
            </c>
            <c>ANONYMOUS</c>
            <c>
              Accessed without any authentication.
            </c>
            <c>AUTHENTICATED</c>
            <c>
              Any authenticated user (opposite of
              ANONYMOUS).
            </c>
            <c>SERVICE</c>
            <c>
              Access from a system service.
            </c>
          </texttable>
          <t>
            To avoid conflict, these special identifiers are
            distinguished by an appended "@" and should appear in the
            form "xxxx@" (with no domain name after the "@"), for
            example, ANONYMOUS@.
          </t>
          <t>
            The ACE4_IDENTIFIER_GROUP flag MUST be ignored on
            entries with these special identifiers.  When encoding
            entries with these special identifiers, the
            ACE4_IDENTIFIER_GROUP flag SHOULD be set to zero.
          </t>

          <section title="Discussion of EVERYONE@">
            <t>
              It is important to note that "EVERYONE@" is not
              equivalent to the UNIX "other" entity. This is
              because, by definition, UNIX "other" does not include
              the owner or owning group of a file. "EVERYONE@" means
              literally everyone, including the owner or owning
              group.
            </t>
          </section>
        </section>
      </section>
      <section anchor="attrdef_dacl"
	       title="Attribute 58: dacl">
	<t>
          The dacl attribute is like the acl attribute,
          but dacl allows 
          just ALLOW and DENY ACEs.  The dacl
          attribute supports automatic inheritance (see
          <xref target="auto_inherit" />).
	</t>
      </section>

      <section anchor="attrdef_sacl"
	       title="Attribute 59: sacl">
	<t>
          The sacl attribute is like the acl attribute,
          but sacl allows
          just AUDIT and ALARM ACEs. The sacl
          attribute supports automatic inheritance (see
          <xref target="auto_inherit" />).
	</t>
      </section>

      <section anchor="attrdef_mode"
	       title="Attribute 33: mode">
        <t>
          The NFSv4.1 mode attribute is based on the UNIX mode
          bits. The following bits are defined:
        </t>

<figure>
 <artwork>
const MODE4_SUID = 0x800;  /* set user id on execution */
const MODE4_SGID = 0x400;  /* set group id on execution */
const MODE4_SVTX = 0x200;  /* save text even after use */
const MODE4_RUSR = 0x100;  /* read permission: owner */
const MODE4_WUSR = 0x080;  /* write permission: owner */
const MODE4_XUSR = 0x040;  /* execute permission: owner */
const MODE4_RGRP = 0x020;  /* read permission: group */
const MODE4_WGRP = 0x010;  /* write permission: group */
const MODE4_XGRP = 0x008;  /* execute permission: group */
const MODE4_ROTH = 0x004;  /* read permission: other */
const MODE4_WOTH = 0x002;  /* write permission: other */
const MODE4_XOTH = 0x001;  /* execute permission: other */
 </artwork>
</figure>

        <t>
          Bits MODE4_RUSR, MODE4_WUSR, and MODE4_XUSR apply to the
          principal identified in the owner attribute. Bits MODE4_RGRP,
          MODE4_WGRP, and MODE4_XGRP apply to principals identified in
          the owner_group attribute but who are not identified in the
          owner attribute. Bits MODE4_ROTH, MODE4_WOTH, and MODE4_XOTH apply
          to any principal that does not match that in the owner
          attribute and does not have a group matching that of the
          owner_group attribute.
        </t>
        <t>
          Bits within a mode other than those specified above
          are not defined by this protocol. A server
          MUST NOT return bits other than those defined above in a
          GETATTR or READDIR operation, and it MUST return NFS4ERR_INVAL
          if bits other than those defined above are set in a SETATTR,
          CREATE, OPEN, VERIFY, or NVERIFY operation.
        </t>
      </section>
      <section anchor="attrdef_mode_set_masked"
	       title="Attribute 74: mode_set_masked">
        <t>
          The mode_set_masked attribute is a write-only attribute
          that allows individual bits in the mode attribute to be
          set or reset, without changing others.  It allows, for
          example, the bits MODE4_SUID, MODE4_SGID, and MODE4_SVTX
          to be modified while leaving unmodified any of the 
          nine low-order mode bits devoted to permissions.
        </t>
        <t>
          In such instances that the nine low-order bits are left
          unmodified, then neither the acl nor the dacl attribute
          should be automatically modified as discussed in 
	  <xref target="setattr" />.
        </t>
        <t>
          The mode_set_masked attribute consists of two words,
          each in the form of a mode4.  The first consists of the
          value to be applied to the current mode value and the
          second is a mask.  Only bits set to one in the mask word
          are changed (set or reset) in the file's mode.  All 
          other bits in the mode remain unchanged.  Bits in the
          first word that correspond to bits that are zero in
          the mask are ignored, except that undefined bits are
          checked for validity and can result in NFS4ERR_INVAL as
          described below.
        </t> 
        <t>
          The mode_set_masked attribute is only valid in a SETATTR
          operation.  If it is used in a CREATE or OPEN operation, the
          server MUST return NFS4ERR_INVAL.
        </t>
        <t>
          Bits not defined as valid in the mode attribute are not
          valid in either word of the mode_set_masked attribute.
          The server MUST return NFS4ERR_INVAL
          if any such bits are set to one in a SETATTR.  
If the mode and
          mode_set_masked attributes are both specified in the
          same SETATTR, the server MUST also return NFS4ERR_INVAL.
        </t>
      </section>

    </section>
    
    <section title="Common Methods">
      <t>
        The requirements in this section will be referred to in future
        sections, especially <xref target="aclreqs" />.
      </t>
      <section title="Interpreting an ACL" anchor="useacl">
        <section title="Server Considerations" anchor="serverinterp">
          <t> 
	    The server uses the algorithm described in
	    <xref target="attrdef_acl"/> to determine whether an ACL
	    allows access to an object.  However, the ACL might not be
	    the sole determiner of access.  For example:
            <list style="symbols">
              <t>
                In the case of a file system exported as read-only,
                the server may deny write access even though
                an object's ACL grants it.
              </t>

              <t>
                Server implementations MAY grant ACE4_WRITE_ACL
                and ACE4_READ_ACL permissions to prevent
                a situation from arising in which there is no valid
                way to ever modify the ACL.
              </t>

              <t>
                All servers will allow a user the ability to read
                the data of the file when only the execute
                permission is granted (i.e., if the ACL denies the
                user the ACE4_READ_DATA access and allows the user
                ACE4_EXECUTE, the server will allow the user to
                read the data of the file).
              </t>

              <t>
                Many servers have the notion of owner-override in
                which the owner of the object is allowed to
                override accesses that are denied by the ACL.
                This may be helpful, for example, to allow users
                continued access to open files on which the
                permissions have changed.
              </t>

              <t>
                Many servers have the notion of a
                &quot;superuser&quot; that has privileges beyond
                an ordinary user.  The superuser may be able
                to read or write data or metadata in ways that would
                not be permitted by the ACL.
              </t>

              <t>
                A retention attribute might also block access otherwise
                allowed by ACLs (see <xref target="retention"/>).
              </t>

            </list>
          </t>
        </section>

        <section title="Client Considerations" anchor="clientinterp">
          <t>
            Clients SHOULD NOT do their own access checks based on
            their interpretation of the ACL, but rather use the OPEN and
            ACCESS operations to do access checks. This allows the
            client to act on the results of having the server
            determine whether or not access should be granted based on
            its interpretation of the ACL.
          </t>

          <t>
            Clients must be aware of situations in which an object's
            ACL will define a certain access even though the server
            will not enforce it. In general, but especially in these
            situations, the client needs to do its part in the
            enforcement of access as defined by the ACL. To do this,
            the client MAY send the appropriate ACCESS operation
            prior to servicing the request of the user or application
            in order to determine whether the user or application
            should be granted the access requested. For examples in
            which the ACL may define accesses that the server doesn't
            enforce, see <xref target="serverinterp"/>.
          </t>
        </section>
      </section>

      <section title="Computing a Mode Attribute from an ACL"
               anchor="computemode">
        <t>
          The following method can be used to calculate the MODE4_R*,
          MODE4_W*, and MODE4_X* bits of a mode attribute, based upon
          an ACL.
        </t>

        <t>
          First, for each of the special identifiers OWNER@, GROUP@, and
          EVERYONE@, evaluate the ACL in order, considering only ALLOW
          and DENY ACEs for the identifier EVERYONE@ and for the
          identifier under consideration.  The result of the evaluation
          will be an NFSv4 ACL mask showing exactly which bits are
          permitted to that identifier.
        </t>

        <t>
          Then translate the calculated mask for OWNER@, GROUP@, and
          EVERYONE@ into mode bits for, respectively, the user, group,
          and other, as follows:

          <list style="numbers">
            <t>
              Set the read bit (MODE4_RUSR, MODE4_RGRP, or
              MODE4_ROTH) if and only if ACE4_READ_DATA is set in
              the corresponding mask.
            </t>

            <t>
              Set the write bit (MODE4_WUSR, MODE4_WGRP, or
              MODE4_WOTH) if and only if ACE4_WRITE_DATA and
              ACE4_APPEND_DATA are both set in the corresponding
              mask.
            </t>

            <t>
              Set the execute bit (MODE4_XUSR, MODE4_XGRP, or
              MODE4_XOTH), if and only if ACE4_EXECUTE is set in the
              corresponding mask.
            </t>
          </list>
        </t>
        <section title="Discussion">
          <t>
            Some server implementations also add bits permitted to
            named users and groups to the group bits (MODE4_RGRP,
            MODE4_WGRP, and MODE4_XGRP).
          </t>
          <t>
            Implementations are discouraged from doing this, because
            it has been found to cause confusion for users who see
            members of a file's group denied access that the mode
            bits appear to allow.  (The presence of DENY ACEs may also
            lead to such behavior, but DENY ACEs are expected to be
            more rarely used.)
          </t>
          <t>
            The same user con