<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd"[   ]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>

<rfc number="8177" 
     category="std" 
     submissionType="IETF"
     consensus="yes"
     ipr="trust200902">

<front>

<title abbrev="YANG Key Chain">YANG Data Model for Key Chains</title> 
   <author initials='A.' surname="Lindem" fullname='Acee Lindem' role="editor">
    <organization>Cisco Systems</organization>
    <address>
      <postal>
        <street>301 Midenhall Way</street>
        <city>Cary</city> <region>NC</region> 
        <country>United States of America</country>
        <code>27513</code> 
       </postal>
       <email>acee@cisco.com</email>
    </address>
    </author>  
   <author initials='Y.' surname="Qu" fullname='Yingzhen Qu'>
    <organization>Huawei</organization>
    <address>
       <email>yingzhen.qu@huawei.com</email>
    </address>
    </author>
    <author initials='D.' surname="Yeung" fullname='Derek Yeung'>
    <organization>Arrcus, Inc</organization>
    <address>
       <email>derek@arrcus.com</email>
    </address>
    </author>
  <author initials='I.' surname="Chen" fullname='Ing-Wher Chen'>
    <organization>Jabil</organization>
    <address>
       <email>Ing-Wher_Chen@jabil.com</email>
    </address>
    </author>
  <author initials='J.' surname="Zhang" fullname='Jeffrey Zhang'>
    <organization>Juniper Networks</organization>
    <address>
      <postal>
        <street>10 Technology Park Drive</street>
        <city>Westford</city> <region>MA</region> 
        <country>United States of America</country>
        <code>01886</code> 
       </postal>
       <email>zzhang@juniper.net</email>
    </address>
    </author>

  <date month="June" year="2017"/>

  <abstract> 
  <t>This document describes the key chain YANG data model.
   Key chains are commonly used for routing protocol
   authentication and other applications requiring symmetric keys.
   A key chain is a list containing one or more elements containing a
   Key ID, key string, send/accept lifetimes, and the associated
   authentication or encryption algorithm. By properly overlapping the send and accept lifetimes
   of multiple key chain elements, key strings and algorithms may be 
   gracefully updated. By representing them in a YANG data model, key 
   distribution can be automated.</t> 
 </abstract>

</front>

<middle>
<section title="Introduction">
  <t>This document describes the key chain YANG <xref target="YANG-1.1"/>
   data model.  Key chains are commonly used for routing protocol
   authentication and other applications requiring symmetric keys.
   A key chain is a list containing one or more elements containing a
   Key ID, key string, send/accept lifetimes, and the associated
   authentication or encryption algorithm.
   By properly overlapping the send and accept lifetimes
   of multiple key chain elements, key strings and algorithms may be 
   gracefully updated. By representing them in a YANG data model, key 
   distribution can be automated.</t> 


   <t>In some applications, the protocols
   do not use the key chain element key directly, but rather a key 
   derivation function is used to derive a  short-lived key from the 
   key chain element key (e.g., the master keys
   used in <xref target="TCP-AO"/>).</t>
<section title="Requirements Notation">


   <t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as 
described in BCP 14 <xref target="KEYWORDS"/> <xref target="KEYWORDS-UPD"/> when, and only when, they
appear in all capitals, as shown here.</t>
</section>


<section title="Tree Diagrams">
 <t>A simplified graphical representation of the complete data
    tree is presented in <xref target="key-chain-tree"/>. The 
    following tree notation is used.</t>
 <t><list style="symbols">
 <t>Brackets "[" and "]" enclose YANG list keys. These YANG list keys
    should not be confused with the key chain keys.</t>
 <t>Curly braces "{" and "}" contain names of optional features that
 make the corresponding node conditional.</t>
 <t>Abbreviations before data node names: "rw" means configuration
 (read-write), "ro" means state data (read-only), "-x" means RPC
operations, and "-n" means notifications.</t>
 <t>Symbols after data node names: "?" means an optional node, "!" denotes a
 container with presence, and "*" denotes a "list" or "leaf-list".</t>
 <t>Parentheses enclose choice and case nodes, and case nodes are
 also marked with a colon (":").</t>
 <t>Ellipsis ("...") stands for contents of subtrees that are not
 shown.</t>
</list></t>
</section>
</section>
<section title="Problem Statement">
<t>This document describes a YANG <xref target="YANG-1.1"/> data model for key chains. Key chains
have been implemented and deployed by a large percentage of network equipment vendors. Providing 
a standard YANG model will facilitate automated key distribution and non-disruptive key rollover.
This will aid in tightening the security of the core routing infrastructure as 
recommended in <xref target="IAB-REPORT"/>. </t>

<t>A key chain is a list containing one or more elements containing a Key ID,
key string, send/accept lifetimes, and the associated authentication or
encryption algorithm. A key chain can be used by any service or application
requiring authentication or encryption using symmetric keys. 

In essence, the 
key chain is a reusable key policy that can be referenced wherever it is required. The
key chain construct has been implemented by most networking vendors and deployed 
in many networks.</t> 
<t>A conceptual representation of a crypto key table is described in 
<xref target="CRYPTO-KEYTABLE"/>. The crypto key table includes keys as well
as their corresponding lifetimes and algorithms. Additionally, the
key table includes key selection criteria and is designed for a deployment
model where the details of the applications or services requiring
authentication or encryption permeate into the key database. The
YANG key chain model described herein doesn't include key selection criteria or 
support this deployment model. At the same time, it does not preclude it. 
<xref target="YANG-CRYPTO-KEYTABLE"/> describes augmentations to the key chain YANG 
model in support of key selection criteria.</t> 
<section title="Applicability">
<t>Other YANG modules may reference ietf-key-chain YANG module key-chain names for authentication and 
encryption applications. A YANG type has been provided to facilitate reference to the key-chain name
without having to specify the complete YANG XML Path Language (XPath) expression.</t>
</section>
<section title="Graceful Key Rollover Using Key Chains">
<t>Key chains may be used to gracefully update the key string and/or algorithm used by an application
for authentication or encryption. To achieve graceful key rollover, the receiver MAY accept all
the keys that have a valid accept lifetime, and the sender MAY send the key with the most recent send
lifetime. 
One scenario for facilitating key rollover is to:
<list style="numbers">
<t>Distribute a key chain with a new key to all the routers or other network devices in the domain of 
that key chain. The new key's accept lifetime should be such that it is accepted during the key rollover period.
The send lifetime should be a time in the future when it can be assured that all the routers in the domain of
that key are upgraded. This will have no immediate impact on the keys used for transmission.</t>
<t>Assure that all the network devices have been updated with the updated key chain and that their system
times are roughly synchronized. The system times of devices within an administrative domain are commonly
synchronized (e.g., using the Network Time Protocol (NTP) <xref target="NTP-PROTO"/>). This also may be automated.</t>

<t>When the send lifetime of the new key becomes valid, the network devices
within the domain of that 
key chain will use the new key for transmissions.</t>
<t>At some point in the future, a new key chain with the old key removed may be distributed to
the network devices within the domain of the key chain. However, this may be deferred until the next 
key rollover. If this is done, the key chain will always include two keys: either the current and future key
(during key rollovers) or the current and previous keys (between key rollovers).</t>
</list></t>
<t>Since the most recent send lifetime is defined as the one with the latest start-time,
specification of "always" will prevent using the graceful key rollover technique described above. Other
key configuration and usage scenarios are possible, but these are beyond the scope of this document.</t>
</section> 
</section> 

<section title="Design of the Key Chain Model">
<t>The ietf-key-chain module contains a list of one or more keys indexed by a Key ID. For some
applications (e.g., OSPFv3 <xref target="OSPFV3-AUTH"/>), 
the Key ID is used to identify the key chain key to be used. In addition to the Key ID, each key chain
key includes a key string and a cryptographic algorithm.
Optionally, the key chain keys include send/accept lifetimes. If the send/accept lifetime is 
unspecified, the key is always considered valid.</t>
<t>Note that different key values for transmission versus acceptance may be supported with 
multiple key chain elements. The key used for transmission will have a valid send-lifetime and invalid accept-lifetime 
(e.g., has an end-time equal to the start-time). The key used for acceptance will have a valid accept-lifetime and 
invalid send-lifetime.</t>
<t>Due to the differences in key chain implementations across various vendors, some of the data elements are 
optional. Finally, the crypto algorithm identities are provided for reuse when configuring
legacy authentication and encryption not using key chains.</t>
<t>A key chain is identified by a unique name within the scope of the network device. 
The "key-chain-ref" typedef SHOULD be used by other YANG modules when they need
to reference a configured key chain.</t>
<section title="Key Chain Operational State">
<t>The key chain operational state is included in the same tree as key chain configuration 
consistent with Network Management Datastore Architecture <xref target="NMDA"/>. 
The timestamp of the last key chain modification is also maintained in the operational state.
Additionally, the operational state includes an indication of whether or not a
key chain key is valid for transmission or acceptance.</t>
</section>
<section title="Key Chain Model Features">
<t>
Features are used to handle differences between vendor implementations. For example, not all vendors 
support configuration of an acceptance tolerance or configuration of key strings in hexadecimal. 
They are also used to support security requirements
(e.g., TCP-AO algorithms <xref target="TCP-AO-ALGORITHMS"/>) not yet implemented by
vendors or implemented by only a single vendor.
</t>
<t>It is common for an entity with sufficient permissions to read and store a device's configuration, 
which would include the contents of this model.  To avoid unnecessarily seeing and storing the keys in 
cleartext, this model provides the aes-key-wrap feature. More details are
described in the Security 
Considerations (<xref target="SECURITY"/>).</t>
</section>
<section anchor="key-chain-tree" title="Key Chain Model Tree">
<figure>
<artwork>
+--rw key-chains
   +--rw key-chain* [name]
   |  +--rw name                       string
   |  +--rw description?               string
   |  +--rw accept-tolerance {accept-tolerance}?
   |  |  +--rw duration?   uint32
   |  +--ro last-modified-timestamp?   yang:date-and-time
   |  +--rw key* [key-id]
   |     +--rw key-id                    uint64
   |     +--rw lifetime
   |     |  +--rw (lifetime)?
   |     |     +--:(send-and-accept-lifetime)
   |     |     |  +--rw send-accept-lifetime
   |     |     |     +--rw (lifetime)?
   |     |     |        +--:(always)
   |     |     |        |  +--rw always?            empty
   |     |     |        +--:(start-end-time)
   |     |     |           +--rw start-date-time?   
   |     |     |           |       yang:date-and-time
   |     |     |           +--rw (end-time)?
   |     |     |              +--:(infinite)
   |     |     |              |  +--rw no-end-time?       empty
   |     |     |              +--:(duration)
   |     |     |              |  +--rw duration?          uint32
   |     |     |              +--:(end-date-time)
   |     |     |                 +--rw end-date-time?     
   |     |     |                         yang:date-and-time
   |     |     +--:(independent-send-accept-lifetime) 
   |     |        |   {independent-send-accept-lifetime}?
   |     |        +--rw send-lifetime
   |     |        |  +--rw (lifetime)?
   |     |        |     +--:(always)
   |     |        |     |  +--rw always?            empty
   |     |        |     +--:(start-end-time)
   |     |        |        +--rw start-date-time?   
   |     |        |        |       yang:date-and-time
   |     |        |        +--rw (end-time)?
   |     |        |           +--:(infinite)
   |     |        |           |  +--rw no-end-time?       empty
   |     |        |           +--:(duration)
   |     |        |           |  +--rw duration?          uint32
   |     |        |           +--:(end-date-time)
   |     |        |              +--rw end-date-time?     
   |     |        |                      yang:date-and-time
   |     |        +--rw accept-lifetime
   |     |           +--rw (lifetime)?
   |     |              +--:(always)
   |     |              |  +--rw always?            empty
   |     |              +--:(start-end-time)
   |     |                 +--rw start-date-time?   
   |     |                 |       yang:date-and-time
   |     |                 +--rw (end-time)?
   |     |                    +--:(infinite)
   |     |                    |  +--rw no-end-time?       empty
   |     |                    +--:(duration)
   |     |                    |  +--rw duration?          uint32
   |     |                    +--:(end-date-time)
   |     |                       +--rw end-date-time?     
   |     |                               yang:date-and-time
   |     +--rw crypto-algorithm identityref
   |     +--rw key-string
   |     |  +--rw (key-string-style)?
   |     |     +--:(keystring)
   |     |     |  +--rw keystring?            string
   |     |     +--:(hexadecimal) {hex-key-string}?
   |     |        +--rw hexadecimal-string?   yang:hex-string
   |     +--ro send-lifetime-active?     boolean
   |     +--ro accept-lifetime-active?   boolean
   +--rw aes-key-wrap {aes-key-wrap}?
      +--rw enable?   boolean

</artwork> 
</figure>
</section> 
</section> 

<section title="Key Chain YANG Model">
<figure>
<artwork><![CDATA[
<CODE BEGINS> file "ietf-key-chain@2017-06-15.yang"
module ietf-key-chain {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-key-chain";
  prefix key-chain;

  import ietf-yang-types {
    prefix yang;
  }
  import ietf-netconf-acm {
    prefix nacm;
  }

  organization
    "IETF RTGWG - Routing Area Working Group";
  contact
    "WG Web:   <https://datatracker.ietf.org/group/rtgwg>
     WG List:  <mailto:rtgwg@ietf.org>
     
     Editor: Acee Lindem
             <mailto:acee@cisco.com>
             Yingzhen Qu
             <mailto:yingzhen.qu@huawei.com>
             Derek Yeung
             <mailto:derek@arrcus.com>
             Ing-Wher Chen
             <mailto:Ing-Wher_Chen@jabail.com>
             Jeffrey Zhang
             <mailto:zzhang@juniper.net>";

  description
    "This YANG module defines the generic configuration
     data for key chains.  It is intended that the module
     will be extended by vendors to define vendor-specific
     key chain configuration parameters.

     Copyright (c) 2017 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 8177; 
     see the RFC itself for full legal notices.";

  reference "RFC 8177";

  revision 2017-06-15 {
    description
      "Initial RFC Revision";
    reference "RFC 8177: YANG Data Model for Key Chains";
  }

  feature hex-key-string {
    description
      "Support hexadecimal key string.";
  }

  feature accept-tolerance {
    description
      "Support the tolerance or acceptance limit.";
  }

  feature independent-send-accept-lifetime {
    description
      "Support for independent send and accept key lifetimes.";
  }

  feature crypto-hmac-sha-1-12 {
    description
      "Support for TCP HMAC-SHA-1 12-byte digest hack.";
  }

  feature cleartext {
    description
      "Support for cleartext algorithm.  Usage is
       NOT RECOMMENDED.";
  }

  feature aes-cmac-prf-128 {
    description
      "Support for AES Cipher-based Message Authentication
       Code Pseudorandom Function.";
  }

  feature aes-key-wrap {
    description
      "Support for Advanced Encryption Standard (AES) Key Wrap.";
  }

  feature replay-protection-only {
    description
      "Provide replay protection without any authentication
       as required by protocols such as Bidirectional
       Forwarding Detection (BFD).";
  }
  identity crypto-algorithm {
    description
      "Base identity of cryptographic algorithm options.";
  }

  identity hmac-sha-1-12 {
    base crypto-algorithm;
    if-feature "crypto-hmac-sha-1-12";
    description
      "The HMAC-SHA1-12 algorithm.";
  }

  identity aes-cmac-prf-128 {
    base crypto-algorithm;
    if-feature "aes-cmac-prf-128";
    description
      "The AES-CMAC-PRF-128 algorithm - required by
       RFC 5926 for TCP-AO key derivation functions.";
  }

  identity md5 {
    base crypto-algorithm;
    description
      "The MD5 algorithm.";
  }

  identity sha-1 {
    base crypto-algorithm;
    description
      "The SHA-1 algorithm.";
  }

  identity hmac-sha-1 {
    base crypto-algorithm;
    description
      "HMAC-SHA-1 authentication algorithm.";
  }

  identity hmac-sha-256 {
    base crypto-algorithm;
    description
      "HMAC-SHA-256 authentication algorithm.";
  }

  identity hmac-sha-384 {
    base crypto-algorithm;
    description
      "HMAC-SHA-384 authentication algorithm.";
  }

  identity hmac-sha-512 {
    base crypto-algorithm;
    description
      "HMAC-SHA-512 authentication algorithm.";
  }

  identity cleartext {
    base crypto-algorithm;
    if-feature "cleartext";
    description
      "cleartext.";
  }

  identity replay-protection-only {
    base crypto-algorithm;
    if-feature "replay-protection-only";
    description
      "Provide replay protection without any authentication as
       required by protocols such as Bidirectional Forwarding
       Detection (BFD).";
  }

  typedef key-chain-ref {
    type leafref {
      path
      "/key-chain:key-chains/key-chain:key-chain/key-chain:name";
    }
    description
      "This type is used by data models that need to reference
       configured key chains.";
  }

  grouping lifetime {
    description
      "Key lifetime specification.";
    choice lifetime {
      default "always";
      description
        "Options for specifying key accept or send lifetimes";
      case always {
        leaf always {
          type empty;
          description
            "Indicates key lifetime is always valid.";
        }
      }
      case start-end-time {
        leaf start-date-time {
          type yang:date-and-time;
          description
            "Start time.";
        }
        choice end-time {
          default "infinite";
          description
            "End-time setting.";
          case infinite {
            leaf no-end-time {
              type empty;
              description
                "Indicates key lifetime end-time is infinite.";
            }
          }
          case duration {
            leaf duration {
              type uint32 {
                range "1..2147483646";
              }
              units "seconds";
              description
                "Key lifetime duration, in seconds";
            }
          }
          case end-date-time {
            leaf end-date-time {
              type yang:date-and-time;
              description
                "End time.";
            }
          }
        }
      }
    }
  }

  container key-chains {
    description
      "All configured key-chains on the device.";
    list key-chain {
      key "name";
      description
        "List of key-chains.";
      leaf name {
        type string;
        description
          "Name of the key-chain.";
      }
      leaf description {
        type string;
        description
          "A description of the key-chain";
      }
      container accept-tolerance {
        if-feature "accept-tolerance";
        description
          "Tolerance for key lifetime acceptance (seconds).";
        leaf duration {
          type uint32;
          units "seconds";
          default "0";
          description
            "Tolerance range, in seconds.";
        }
      }
      leaf last-modified-timestamp {
        type yang:date-and-time;
        config false;
        description
          "Timestamp of the most recent update to the key-chain";
      }
      list key {
        key "key-id";
        description
          "Single key in key chain.";
        leaf key-id {
          type uint64;
          description
            "Numeric value uniquely identifying the key";
        }
        container lifetime {
          description
            "Specify a key's lifetime.";
          choice lifetime {
            description
              "Options for specification of send and accept 
               lifetimes.";
            case send-and-accept-lifetime {
              description
                "Send and accept key have the same lifetime.";
              container send-accept-lifetime {
                description
                  "Single lifetime specification for both
                   send and accept lifetimes.";
                uses lifetime;
              }
            }
            case independent-send-accept-lifetime {
              if-feature "independent-send-accept-lifetime";
              description
                "Independent send and accept key lifetimes.";
              container send-lifetime {
                description
                  "Separate lifetime specification for send 
                   lifetime.";
                uses lifetime;
              }
              container accept-lifetime {
                description
                  "Separate lifetime specification for accept 
                   lifetime.";
                uses lifetime;
              }
            }
          }
        }
        leaf crypto-algorithm {
          type identityref {
            base crypto-algorithm;
          }
          mandatory true;
          description
            "Cryptographic algorithm associated with key.";
        }
        container key-string {
          description
            "The key string.";
          nacm:default-deny-all;
          choice key-string-style {
            description
              "Key string styles";
             case keystring {
               leaf keystring {
                type string;
                description
                  "Key string in ASCII format.";
              }
            }
            case hexadecimal {
              if-feature "hex-key-string";
              leaf hexadecimal-string {
                type yang:hex-string;
                description
                  "Key in hexadecimal string format.  When compared
                   to ASCII, specification in hexadecimal affords
                   greater key entropy with the same number of
                   internal key-string octets.  Additionally, it 
                   discourages usage of well-known words or
                   numbers.";
              }
            }
          }
        }
        leaf send-lifetime-active {
          type boolean;
          config false;
          description
            "Indicates if the send lifetime of the
             key-chain key is currently active.";
           }
        leaf accept-lifetime-active {
          type boolean;
          config false;
          description
            "Indicates if the accept lifetime of the
             key-chain key is currently active.";
        }
      }
    }
    container aes-key-wrap {
      if-feature "aes-key-wrap";
      description
        "AES Key Wrap encryption for key-chain key-strings.  The 
         encrypted key-strings are encoded as hexadecimal key 
         strings using the hex-key-string leaf.";
      leaf enable {
        type boolean;
        default "false";
        description
          "Enable AES Key Wrap encryption.";
      }
    }
  }
}
<CODE ENDS>


]]></artwork>
</figure>
</section> 

<section anchor="SECURITY" title="Security Considerations">
<t>The YANG module defined in this document is designed to be 
accessed via network management protocols such as 
NETCONF <xref target="NETCONF"/> or RESTCONF <xref target="RESTCONF"/>. 
The lowest NETCONF layer is the 
secure transport layer, and the mandatory-to-implement secure 
transport is Secure Shell (SSH) <xref target="NETCONF-SSH"/>. 
The lowest RESTCONF 
layer is HTTPS, and the mandatory-to-implement secure transport is 
TLS <xref target="TLS"/>.</t>

<t>The NETCONF access control model <xref target="NETCONF-ACM"/> provides 
the means to restrict access for particular NETCONF or RESTCONF users to a 
pre-configured subset of all available NETCONF or RESTCONF 
protocol operations and content. The key strings are not accessible by 
default, and NETCONF access control model <xref target="NETCONF-ACM"/> rules
are required to configure or retrieve them.</t> 

<t>When configured, the key strings can be encrypted using the AES Key
Wrap algorithm <xref target="AES-KEY-WRAP"/>. The AES key-encryption key (KEK) 
is not included in the YANG model and must be set or derived independent of
key chain configuration. When AES key encryption is used, the hex-key-string 
feature is also required since the encrypted keys will contain
characters that are not representable in the YANG string built-in 
type <xref target="YANG-1.1"/>. It is RECOMMENDED that key strings be encrypted using 
AES key encryption to prevent key chains from being retrieved 
and stored with the key strings in cleartext. This recommendation is
independent of the access protection that is availed from the NETCONF access
control model (NACM) <xref target="NETCONF-ACM"/>.</t>

<t>The cleartext algorithm is included as a YANG feature. Usage is NOT RECOMMENDED 
except in cases where the application and device have no other alternative
(e.g., a legacy network device that must authenticate packets at intervals of
10 milliseconds or less for many peers using Bidirectional Forwarding Detection
<xref target="BFD"/>). Keys used with the 
cleartext algorithm are considered insecure and SHOULD NOT be reused 
with more secure algorithms.</t>
<t>Similarly, the MD5 and SHA-1 algorithms have been proven to be insecure 
(<xref target="Dobb96a" />, <xref target="Dobb96b"/>, and <xref target="SHA-SEC-CON"/>),
and usage is NOT RECOMMENDED. Usage should be confined to deployments
where it is required for backward compatibility.</t>
<t>Implementations with keys provided via this model should store them 
using best current security practices.</t>
</section>

<section title="IANA Considerations">
<t>This document registers a URI in the "IETF XML Registry"
   <xref target="XML-REGISTRY"/>. It follows the format in <xref target="XML-REGISTRY"/>.

   <figure>
   <artwork>  
   URI: urn:ietf:params:xml:ns:yang:ietf-key-chain
   Registrant Contact: The IESG.
   XML: N/A, the requested URI is an XML namespace.
   </artwork> 
   </figure></t>

   <t>This document registers a YANG module in the "YANG Module Names"
   registry <xref target="YANG-1.0"/>.
   <figure>
   <artwork>  
   name: ietf-key-chain
   namespace: urn:ietf:params:xml:ns:yang:ietf-key-chain
   prefix: key-chain
   reference: RFC 8177
   </artwork> 
   </figure></t>
</section>

</middle>
<?rfc needLines="20"?>
<back>
<references title="Normative References">


<reference  anchor='RESTCONF' target='http://www.rfc-editor.org/info/rfc8040'>
<front>
<title>RESTCONF Protocol</title>
<author initials='A.' surname='Bierman' fullname='A. Bierman'><organization /></author>
<author initials='M.' surname='Bjorklund' fullname='M. Bjorklund'><organization /></author>
<author initials='K.' surname='Watsen' fullname='K. Watsen'><organization /></author>
<date year='2017' month='January' />
</front>
<seriesInfo name='RFC' value='8040'/>
<seriesInfo name='DOI' value='10.17487/RFC8040'/>
</reference>


<reference  anchor='NETCONF-SSH' target='http://www.rfc-editor.org/info/rfc6242'>
<front>
<title>Using the NETCONF Protocol over Secure Shell (SSH)</title>
<author initials='M.' surname='Wasserman' fullname='M. Wasserman'><organization /></author>
<date year='2011' month='June' />
</front>
<seriesInfo name='RFC' value='6242'/>
<seriesInfo name='DOI' value='10.17487/RFC6242'/>
</reference>


<reference  anchor='KEYWORDS' target='http://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>

<reference  anchor='KEYWORDS-UPD' target='http://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>


<reference  anchor='TLS' target='http://www.rfc-editor.org/info/rfc5246'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'><organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<date year='2008' month='August' />
<abstract><t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5246'/>
<seriesInfo name='DOI' value='10.17487/RFC5246'/>
</reference>


<reference  anchor='XML-REGISTRY' target='http://www.rfc-editor.org/info/rfc3688'>
<front>
<title>The IETF XML Registry</title>
<author initials='M.' surname='Mealling' fullname='M. Mealling'><organization /></author>
<date year='2004' month='January' />
<abstract><t>This document describes an IANA maintained registry for IETF standards which use Extensible Markup Language (XML) related items such as Namespaces, Document Type Declarations (DTDs), Schemas, and Resource Description Framework (RDF) Schemas.</t></abstract>
</front>
<seriesInfo name='BCP' value='81'/>
<seriesInfo name='RFC' value='3688'/>
<seriesInfo name='DOI' value='10.17487/RFC3688'/>
</reference>

<reference  anchor='YANG-1.0' target='http://www.rfc-editor.org/info/rfc6020'>
<front>
<title>YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)</title>
<author initials='M.' surname='Bjorklund' fullname='M. Bjorklund' role='editor'><organization /></author>
<date year='2010' month='October' />
<abstract><t>YANG is a data modeling language used to model configuration and state data manipulated by the Network Configuration Protocol (NETCONF), NETCONF remote procedure calls, and NETCONF notifications. [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6020'/>
<seriesInfo name='DOI' value='10.17487/RFC6020'/>
</reference>

<reference  anchor='YANG-1.1' target='http://www.rfc-editor.org/info/rfc7950'>
<front>
<title>The YANG 1.1 Data Modeling Language</title>
<author initials='M.' surname='Bjorklund' fullname='M. Bjorklund' role='editor'><organization /></author>
<date year='2016' month='August' />
<abstract><t>YANG is a data modeling language used to model configuration data, state data, Remote Procedure Calls, and notifications for network management protocols.  This document describes the syntax and semantics of version 1.1 of the YANG language.  YANG version 1.1 is a maintenance release of the YANG language, addressing ambiguities and defects in the original specification.  There are a small number of backward incompatibilities from YANG version 1.  This document also specifies the YANG mappings to the Network Configuration Protocol (NETCONF).</t></abstract>
</front>
<seriesInfo name='RFC' value='7950'/>
<seriesInfo name='DOI' value='10.17487/RFC7950'/>
</reference>

<reference  anchor='NETCONF' target='http://www.rfc-editor.org/info/rfc6241'>
<front>
<title>Network Configuration Protocol (NETCONF)</title>
<author initials='R.' surname='Enns' fullname='R. Enns' role='editor'><organization /></author>
<author initials='M.' surname='Bjorklund' fullname='M. Bjorklund' role='editor'><organization /></author>
<author initials='J.' surname='Schoenwaelder' fullname='J. Schoenwaelder' role='editor'><organization /></author>
<author initials='A.' surname='Bierman' fullname='A. Bierman' role='editor'><organization /></author>
<date year='2011' month='June' />
<abstract><t>The Network Configuration Protocol (NETCONF) defined in this document provides mechanisms to install, manipulate, and delete the configuration of network devices.  It uses an Extensible Markup Language (XML)-based data encoding for the configuration data as well as the protocol messages.  The NETCONF protocol operations are realized as remote procedure calls (RPCs).  This document obsoletes RFC 4741.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6241'/>
<seriesInfo name='DOI' value='10.17487/RFC6241'/>
</reference>

<reference  anchor='NETCONF-ACM' target='http://www.rfc-editor.org/info/rfc6536'>
<front>
<title>Network Configuration Protocol (NETCONF) Access Control Model</title>
<author initials='A.' surname='Bierman' fullname='A. Bierman'><organization /></author>
<author initials='M.' surname='Bjorklund' fullname='M. Bjorklund'><organization /></author>
<date year='2012' month='March' />
<abstract><t>The standardization of network configuration interfaces for use with the Network Configuration Protocol (NETCONF) requires a structured and secure operating environment that promotes human usability and multi-vendor interoperability.  There is a need for standard mechanisms to restrict NETCONF protocol access for particular users to a pre-configured subset of all available NETCONF protocol operations and content.  This document defines such an access control model.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6536'/>
<seriesInfo name='DOI' value='10.17487/RFC6536'/>
</reference>
</references>

<references title="Informative References">

<reference  anchor='CRYPTO-KEYTABLE' target='http://www.rfc-editor.org/info/rfc7210'>
<front>
<title>Database of Long-Lived Symmetric Cryptographic Keys</title>
<author initials='R.' surname='Housley' fullname='R. Housley'><organization /></author>
<author initials='T.' surname='Polk' fullname='T. Polk'><organization /></author>
<author initials='S.' surname='Hartman' fullname='S. Hartman'><organization /></author>
<author initials='D.' surname='Zhang' fullname='D. Zhang'><organization /></author>
<date year='2014' month='April' />
<abstract><t>This document specifies the information contained in a conceptual database of long-lived cryptographic keys used by many different routing protocols for message security.  The database is designed to support both manual and automated key management.  In addition to describing the schema for the database, this document describes the operations that can be performed on the database as well as the requirements for the routing protocols that wish to use the database.  In many typical scenarios, the protocols do not directly use the long-lived key, but rather a key derivation function is used to derive a short-lived key from a long-lived key.</t></abstract>
</front>
<seriesInfo name='RFC' value='7210'/>
<seriesInfo name='DOI' value='10.17487/RFC7210'/>
</reference>


<reference anchor='YANG-CRYPTO-KEYTABLE'>
<front>
<title>YANG Data Model for RFC 7210 Key Table</title>
<author initials='I' surname='Chen' fullname='Helen Chen'>
    <organization />
</author>
<date month='March' day='9' year='2015' />
<abstract><t>This document defines a YANG data model to describe the key table defined in RFC 7210.  The data model defined in this document augments the existing key-chain model with additional key attributes specified in RFC 7210.</t></abstract>
</front>
<seriesInfo name='Work in Progress,' value='draft-chen-rtg-key-table-yang-00' />
</reference>

<reference  anchor='TCP-AO' target='http://www.rfc-editor.org/info/rfc5925'>
<front>
<title>The TCP Authentication Option</title>
<author initials='J.' surname='Touch' fullname='J. Touch'><organization /></author>
<author initials='A.' surname='Mankin' fullname='A. Mankin'><organization /></author>
<author initials='R.' surname='Bonica' fullname='R. Bonica'><organization /></author>
<date year='2010' month='June' />
<abstract><t>This document specifies the TCP Authentication Option (TCP-AO), which obsoletes the TCP MD5 Signature option of RFC 2385 (TCP MD5).  TCP-AO specifies the use of stronger Message Authentication Codes (MACs), protects against replays even for long-lived TCP connections, and provides more details on the association of security with TCP connections than TCP MD5.  TCP-AO is compatible with either a static Master Key Tuple (MKT) configuration or an external, out-of-band MKT management mechanism; in either case, TCP-AO also protects connections when using the same MKT across repeated instances of a connection, using traffic keys derived from the MKT, and coordinates MKT changes between endpoints.  The result is intended to support current infrastructure uses of TCP MD5, such as to protect long-lived connections (as used, e.g., in BGP and LDP), and to support a larger set of MACs with minimal other system and operational changes.  TCP-AO uses a different option identifier than TCP MD5, even though TCP-AO and TCP MD5 are never permitted to be used simultaneously.  TCP-AO supports IPv6, and is fully compatible with the proposed requirements for the replacement of TCP MD5.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5925'/>
<seriesInfo name='DOI' value='10.17487/RFC5925'/>
</reference>

<reference  anchor='TCP-AO-ALGORITHMS' target='http://www.rfc-editor.org/info/rfc5926'>
<front>
<title>Cryptographic Algorithms for the TCP Authentication Option (TCP-AO)</title>
<author initials='G.' surname='Lebovitz' fullname='G. Lebovitz'><organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<date year='2010' month='June' />
<abstract><t>The TCP Authentication Option (TCP-AO) relies on security algorithms to provide authentication between two end-points.  There are many such algorithms available, and two TCP-AO systems cannot interoperate unless they are using the same algorithms.  This document specifies the algorithms and attributes that can be used in TCP-AO's current manual keying mechanism and provides the interface for future message authentication codes (MACs).  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5926'/>
<seriesInfo name='DOI' value='10.17487/RFC5926'/>
</reference>

<reference  anchor='AES-KEY-WRAP' target='http://www.rfc-editor.org/info/rfc5649'>
<front>
<title>Advanced Encryption Standard (AES) Key Wrap with Padding Algorithm</title>
<author initials='R.' surname='Housley' fullname='R. Housley'><organization /></author>
<author initials='M.' surname='Dworkin' fullname='M. Dworkin'><organization /></author>
<date year='2009' month='September' />
<abstract><t>This document specifies a padding convention for use with the AES Key Wrap algorithm specified in RFC 3394.  This convention eliminates the requirement that the length of the key to be wrapped be a multiple of 64 bits, allowing a key of any practical length to be wrapped.  This  memo provides information for the Internet community.</t></abstract>
</front>
<seriesInfo name='RFC' value='5649'/>
<seriesInfo name='DOI' value='10.17487/RFC5649'/>
</reference>

<reference  anchor='IAB-REPORT' target='http://www.rfc-editor.org/info/rfc4948'>
<front>
<title>Report from the IAB workshop on Unwanted Traffic March 9-10, 2006</title>
<author initials='L.' surname='Andersson' fullname='L. Andersson'><organization /></author>
<author initials='E.' surname='Davies' fullname='E. Davies'><organization /></author>
<author initials='L.' surname='Zhang' fullname='L. Zhang'><organization /></author>
<date year='2007' month='August' />
<abstract><t>This document reports the outcome of a workshop held by the Internet Architecture Board (IAB) on Unwanted Internet Traffic.  The workshop was held on March 9-10, 2006 at USC/ISI in Marina del Rey, CA, USA. The primary goal of the workshop was to foster interchange between the operator, standards, and research communities on the topic of unwanted traffic, as manifested in, for example, Distributed Denial of Service (DDoS) attacks, spam, and phishing, to gain understandings on the ultimate sources of these unwanted traffic, and to assess their impact and the effectiveness of existing solutions.  It was also a goal of the workshop to identify engineering and research topics that could be undertaken by the IAB, the IETF, the IRTF, and the network research and development community at large to develop effective countermeasures against the unwanted traffic.  This memo provides information for the Internet community.</t></abstract>
</front>
<seriesInfo name='RFC' value='4948'/>
<seriesInfo name='DOI' value='10.17487/RFC4948'/>
</reference>

<reference  anchor='OSPFV3-AUTH' target='http://www.rfc-editor.org/info/rfc7166'>
<front>
<title>Supporting Authentication Trailer for OSPFv3</title>
<author initials='M.' surname='Bhatia' fullname='M. Bhatia'><organization /></author>
<author initials='V.' surname='Manral' fullname='V. Manral'><organization /></author>
<author initials='A.' surname='Lindem' fullname='A. Lindem'><organization /></author>
<date year='2014' month='March' />
<abstract><t>Currently, OSPF for IPv6 (OSPFv3) uses IPsec as the only mechanism for authenticating protocol packets.  This behavior is different from authentication mechanisms present in other routing protocols (OSPFv2, Intermediate System to Intermediate System (IS-IS), RIP, and Routing Information Protocol Next Generation (RIPng)).  In some environments, it has been found that IPsec is difficult to configure and maintain and thus cannot be used.  This document defines an alternative mechanism to authenticate OSPFv3 protocol packets so that OSPFv3 does not depend only upon IPsec for authentication.</t><t>The OSPFv3 Authentication Trailer was originally defined in RFC 6506. This document obsoletes RFC 6506 by providing a revised definition, including clarifications and refinements of the procedures.</t></abstract>
</front>
<seriesInfo name='RFC' value='7166'/>
<seriesInfo name='DOI' value='10.17487/RFC7166'/>
</reference>

<reference  anchor='NTP-PROTO' target='http://www.rfc-editor.org/info/rfc5905'>
<front>
<title>Network Time Protocol Version 4: Protocol and Algorithms Specification</title>
<author initials='D.' surname='Mills' fullname='D. Mills'><organization /></author>
<author initials='J.' surname='Martin' fullname='J. Martin' role='editor'><organization /></author>
<author initials='J.' surname='Burbank' fullname='J. Burbank'><organization /></author>
<author initials='W.' surname='Kasch' fullname='W. Kasch'><organization /></author>
<date year='2010' month='June' />
<abstract><t>The Network Time Protocol (NTP) is widely used to synchronize computer clocks in the Internet.  This document describes NTP version 4 (NTPv4), which is backwards compatible with NTP version 3 (NTPv3), described in RFC 1305, as well as previous versions of the protocol. NTPv4 includes a modified protocol header to accommodate the Internet Protocol version 6 address family.  NTPv4 includes fundamental improvements in the mitigation and discipline algorithms that extend the potential accuracy to the tens of microseconds with modern workstations and fast LANs.  It includes a dynamic server discovery scheme, so that in many cases, specific server configuration is not required.  It corrects certain errors in the NTPv3 design and implementation and includes an optional extension mechanism.   [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5905'/>
<seriesInfo name='DOI' value='10.17487/RFC5905'/>
</reference>

<reference  anchor='BFD' target='http://www.rfc-editor.org/info/rfc5880'>
<front>
<title>Bidirectional Forwarding Detection (BFD)</title>
<author initials='D.' surname='Katz' fullname='D. Katz'><organization /></author>
<author initials='D.' surname='Ward' fullname='D. Ward'><organization /></author>
<date year='2010' month='June' />
<abstract><t>This document describes a protocol intended to detect faults in the bidirectional path between two forwarding engines, including interfaces, data link(s), and to the extent possible the forwarding engines themselves, with potentially very low latency.  It operates independently of media, data protocols, and routing protocols. [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5880'/>
<seriesInfo name='DOI' value='10.17487/RFC5880'/>
</reference>



<reference anchor="Dobb96a">
<front>
<title>Cryptanalysis of MD5 Compress</title>
<author initials="H." surname="Dobbertin" fullname="">
<organization></organization>
</author>
<date month="May" year="1996" />
</front>
<seriesInfo name="Technical Report" value="Presented at the Rump Session of
					   EuroCrypt '96"/>
</reference>

<reference anchor="Dobb96b">
<front>
<title>The Status of MD5 After a Recent Attack</title>
<author initials="H." surname="Dobbertin" fullname="">
<organization></organization>
</author>
<date month="Summer" year="1996" />
</front>
<seriesInfo name="CryptoBytes," value="Vol. 2, No. 2"/>
</reference>

<reference  anchor='SHA-SEC-CON' target='http://www.rfc-editor.org/info/rfc6194'>
<front>
<title>Security Considerations for the SHA-0 and SHA-1 Message-Digest Algorithms</title>
<author initials='T.' surname='Polk' fullname='T. Polk'><organization /></author>
<author initials='L.' surname='Chen' fullname='L. Chen'><organization /></author>
<author initials='S.' surname='Turner' fullname='S. Turner'><organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'><organization /></author>
<date year='2011' month='March' />
<abstract><t>This document includes security considerations for the SHA-0 and SHA-1 message digest algorithm.  This document is not an Internet  Standards Track specification; it is published for informational  purposes.</t></abstract>
</front>
<seriesInfo name='RFC' value='6194'/>
<seriesInfo name='DOI' value='10.17487/RFC6194'/>
</reference>

<reference anchor="NMDA">
<front>
<title>Network Management Datastore Architecture</title>
<author initials="M." surname="Bjorklund" fullname="Martin Bjorklund">
<organization>Tail-F Systems</organization>
</author>
<author initials="J." surname="Schoenwaelder" fullname="Juergen Schoenwaelder">
<organization>Jacobs University</organization>
</author>
<author initials="P." surname="Shafer" fullname="Phil Shafer">
<organization>Juniper Networks</organization>
</author>
<author initials="K." surname="Watsen" fullname="Kent Watsen">
<organization>Juniper Networks</organization>
</author>
<author initials="R." surname="Wilton" fullname="Rob Wilton">
<organization>Cisco Systems</organization>
</author>
<date month="May" year="2017" />
</front>
<seriesInfo name="Work in Progress," value="draft-ietf-netmod-revised-datastores-02"/>
</reference>
</references>

<?rfc needLines="100"?>
<section title="Examples">
<section title="Simple Key Chain with an Always Valid Single Key">
<figure>
<artwork><![CDATA[
<?xml version="1.0" encoding="utf-8"?>
<data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
  <key-chains xmlns="urn:ietf:params:xml:ns:yang:ietf-key-chain">
    <key-chain>
      <name>keychain-no-end-time</name>
      <description>
        A key chain with a single key that is always valid for 
        transmission and reception.
      </description>
      <key>
        <key-id>100</key-id>
        <lifetime>
          <send-accept-lifetime>
            <always/>
          </send-accept-lifetime>
        </lifetime>
        <crypto-algorithm>hmac-sha-256</crypto-algorithm>
        <key-string>
          <keystring>keystring_in_ascii_100</keystring>
        </key-string>
      </key>
    </key-chain>
  </key-chains>
</data>
]]></artwork>
</figure>
</section> 
<section title="Key Chain with Keys Having Different Lifetimes">
<figure>
<artwork><![CDATA[
<?xml version="1.0" encoding="utf-8"?>
<data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
  <key-chains xmlns="urn:ietf:params:xml:ns:yang:ietf-key-chain">
    <key-chain>
      <name>keychain2</name>
      <description>
        A key chain where each key contains a different send time
        and accept time and a different algorithm illustrating 
        algorithm agility.
      </description>
      <key>
        <key-id>35</key-id>
        <lifetime>
          <send-lifetime>
            <start-date-time>2017-01-01T00:00:00Z</start-date-time>
            <end-date-time>2017-02-01T00:00:00Z</end-date-time>
          </send-lifetime>
          <accept-lifetime>
            <start-date-time>2016-12-31T23:59:55Z</start-date-time>
            <end-date-time>2017-02-01T00:00:05Z</end-date-time>
          </accept-lifetime>
        </lifetime>
        <crypto-algorithm>hmac-sha-256</crypto-algorithm>
        <key-string>
          <keystring>keystring_in_ascii_35</keystring>
        </key-string>
      </key>
      <key>
        <key-id>36</key-id>
        <lifetime>
          <send-lifetime>
            <start-date-time>2017-02-01T00:00:00Z</start-date-time>
            <end-date-time>2017-03-01T00:00:00Z</end-date-time>
          </send-lifetime>
          <accept-lifetime>
            <start-date-time>2017-01-31T23:59:55Z</start-date-time>
            <end-date-time>2017-03-01T00:00:05Z</end-date-time>
          </accept-lifetime>
        </lifetime>
        <crypto-algorithm>hmac-sha-512</crypto-algorithm>
        <key-string>
          <hexadecimal-string>fe:ed:be:af:36</hexadecimal-string>
        </key-string>
      </key>
    </key-chain>
  </key-chains>
</data>
]]></artwork>
</figure>
</section> 
<section title="Key Chain with Independent Send and Accept Lifetimes">
<figure>
<artwork><![CDATA[
<?xml version="1.0" encoding="utf-8"?>
<data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
  <key-chains xmlns="urn:ietf:params:xml:ns:yang:ietf-key-chain">
    <key-chain>
      <name>keychain2</name>
      <description>
        A key chain where each key contains different send times
        and accept times.
      </description>
      <key>
        <key-id>35</key-id>
        <lifetime>
          <send-lifetime>
            <start-date-time>2017-01-01T00:00:00Z</start-date-time>
            <end-date-time>2017-02-01T00:00:00Z</end-date-time>
          </send-lifetime>
          <accept-lifetime>
            <start-date-time>2016-12-31T23:59:55Z</start-date-time>
            <end-date-time>2017-02-01T00:00:05Z</end-date-time>
          </accept-lifetime>
        </lifetime>
        <crypto-algorithm>hmac-sha-256</crypto-algorithm>
        <key-string>
          <keystring>keystring_in_ascii_35</keystring>
        </key-string>
      </key>
      <key>
        <key-id>36</key-id>
        <lifetime>
          <send-lifetime>
            <start-date-time>2017-02-01T00:00:00Z</start-date-time>
            <end-date-time>2017-03-01T00:00:00Z</end-date-time>
          </send-lifetime>
          <accept-lifetime>
            <start-date-time>2017-01-31T23:59:55Z</start-date-time>
            <end-date-time>2017-03-01T00:00:05Z</end-date-time>
          </accept-lifetime>
        </lifetime>
        <crypto-algorithm>hmac-sha-256</crypto-algorithm>
        <key-string>
          <hexadecimal-string>fe:ed:be:af:36</hexadecimal-string>
        </key-string>
      </key>
    </key-chain>
  </key-chains>
</data>
]]></artwork>
</figure>
</section> 
</section>
<section title="Contributors" numbered="no">
<figure>
<artwork>                                                                                                                        
Yi Yang                                                                                                                       
SockRate                                                                                                                      
                                                                                                                                 
Email: yi.yang@sockrate.com                                                                                                   
</artwork>
</figure>
</section>
<section title="Acknowledgments" numbered="no">
  <t>Thanks to Brian Weis for fruitful discussions on security 
     requirements.</t>
  <t>Thanks to Ines Robles for Routing Directorate QA review comments.</t>
  <t>Thanks to Ladislav Lhotka for YANG Doctor comments.</t>
  <t>Thanks to Martin Bjorklund for additional YANG Doctor comments.</t>
  <t>Thanks to Tom Petch for comments during IETF last call.</t>
  <t>Thanks to Matthew Miller for comments made during the Gen-ART review.</t>
  <t>Thanks to Vincent Roca for comments made during the Security Directorate review.</t>
  <t>Thanks to Warren Kumari, Ben Campbell, Adam Roach, and Benoit Claise for comments
     received during the IESG review.</t>
</section>

</back>
</rfc>
