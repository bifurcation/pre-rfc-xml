<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<rfc category="std" number="8563" ipr="trust200902" submissionType="IETF" consensus="yes">


  <front>
    <title abbrev="BFD Multipoint Active Tails">
	Bidirectional Forwarding Detection (BFD) Multipoint Active Tails
    </title>

    <author fullname="Dave Katz" initials="D." surname="Katz">
      <organization>Juniper Networks</organization>
      <address>
		<postal>
		<street> 1194 N. Mathilda Ave.</street>
		<city>Sunnyvale</city>
		<region>California</region>
		<code> 94089-1206</code>
		<country>United States of America</country>
	    </postal>
        <email>dkatz@juniper.net</email>
      </address>
    </author>

    <author fullname="Dave Ward" initials="D." surname="Ward">
      <organization>Cisco Systems</organization>
      <address>
		<postal>
		<street> 170 West Tasman Dr.</street>
		<city>San Jose</city>
		<region>California</region>
		<code>95134</code>
		<country>United States of America</country>
	    </postal>
        <email>wardd@cisco.com</email>
      </address>
    </author>
	
	 <author fullname="Santosh Pallagatti" initials="S." role="editor" surname="Pallagatti">
      <organization>VMware</organization>
      <address>
        <email>santosh.pallagatti@gmail.com</email>
      </address>
    </author>
        
    	 <author fullname="Greg Mirsky" initials="G." role="editor" surname="Mirsky">
      <organization>ZTE Corp.</organization>
      <address>
        <email>gregimirsky@gmail.com</email>
      </address>
    </author>

    <date month="March" year="2019"/>

    <area>BFD Working Group</area>
    <workgroup>Internet Engineering Task Force</workgroup>

    <keyword>BFD</keyword>
    <keyword>Multipoint BFD</keyword>
	<keyword>Multipoint BFD Active Tails</keyword>

    <abstract>
    	<t>
    	This document describes active tail extensions to the 
    	Bidirectional Forwarding Detection (BFD) 
    	protocol for multipoint networks. 
    	</t>
    </abstract>
	
  </front>

  <middle>
    <section title="Introduction" anchor="Intro">

		<t>
		This application of BFD is an extension to Multipoint BFD <xref target="RFC8562"/>,
		which allows tails to notify the head of the lack of multipoint connectivity. As a further option, heads can
   request a notification from the tails by means of a polling mechanism. Notification to the head can be enabled for all tails, or
   for only a subset of the tails. 

		</t>

		<t>
		The goal of this application is for the head to have reasonably rapid knowledge of tails that have lost connectivity from the head.
		</t>

		<t>
		Since scaling is a primary concern (particularly state explosion toward the head), it is required that 
		the head be in control of all timing aspects of the mechanism and that BFD packets from the tails to the head not be synchronized.
		</t>
		
  <t>
Throughout this document, the term "multipoint" is defined as a mechanism by which one or more systems 
receive packets sent by a single sender. This specifically includes such things as IP multicast and point-to-multipoint MPLS.
</t>
<t>
The term "connectivity" in this document is not being used in the context of connectivity verification in a transport network
but as an alternative to "continuity", i.e., the existence of a path between the sender and the receiver.
</t>


		<t>This document effectively modifies and adds to Sections 5.12 and 5.13 of the base BFD multipoint networks specification <xref target="RFC8562"/>. </t>
	</section>
	
	<section title="Terminology and Acronyms">
	<t>BFD: Bidirectional Forwarding Detection</t>
	<t>c-poll: Composite Poll</t>
	<t>m-poll: Multipoint Poll</t>
	</section>
	
	<section title="Keywords">
	             <t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
    "MAY", and "OPTIONAL" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
             </t>
	</section>

<section title="Overview">
 
	<t>
	A head may wish to be alerted of the tails' connectivity (or lack thereof), and there are a number of options to achieve that. 
	First, if all that is needed is a best-effort failure notification, as discussed in <xref target="unreliable-notify-sec"/>,
	the tails can send unsolicited unicast BFD Control packets to the
   head when the path fails, as described in <xref target="control-multipoint-options"/>.
	</t>
	<t>
  If the head wishes to know of the active tails on the
  multipoint path, it may send a multipoint
  BFD Control packet with the Poll (P) bit set, which will induce the tails to return a unicast 
	BFD Control packet with the Final (F) bit set (see a detailed description in <xref target="semi-reliable-section"/>).
	The head can then create BFD session state for each of the tails 
	that have multipoint connectivity. If the head sends such a packet on occasion, it can keep track of which tails answer, 
	thus providing a more deterministic mechanism for detecting which tails fail to respond 
	(implying a loss of multipoint connectivity). In this document, this method is referred to as the Multipoint Poll (m-poll).
	</t>

	<t>
	If the head wishes the definite indication of the tails' connectivity, it may do all of the above, 
	but if it detects that a tail did not answer the previous multipoint poll, it may initiate a Demand mode 
	Poll Sequence as a unicast to that tail (see a detailed description in <xref target="reliable-notification-section"/>).
	This covers the case where either the multipoint poll
	 or the single reply is also lost in transit.  
	If desired, the head may Poll one or more tails proactively to track the tails' connectivity.
	In this document, the method that combines the use of multipoint and unicast polling of 
	tails by the head is referred to as the Composite Poll (c-poll).
	</t> 

	<t>
	If the awareness of the state of some nodes is more important for the head,
	 in the sense that the head needs to detect the lack of multipoint 
	connectivity to a subset of tails at a different rate, the head may transmit unicast BFD Polls to that subset 
	of tails.  In this case, the timing may be independent on a tail-by-tail basis.
	</t>

	<t>
	Individual tails may be configured so that they never send BFD Control packets to the head.
	Such tails will never be known to the head 
	but will still be able to detect multipoint path failures from the head.
	</t>

</section>

<section title="Operational Scenarios">
	<t>
	It is worth analyzing how this protocol reacts to various scenarios. There are three path components 
	present: namely, the multipoint path, the forward unicast path (from the head to a particular tail), and the 
	reverse unicast path (from a tail to the head).  There are also four options as to how the head is 
	notified about failures from the tail. For the different modes described below, the setting of new 
	state variables are given even if these are only introduced later in the document 
	(see <xref target="state-variables-sec"/>).
	</t>
	
	<section anchor="no-head-notify-sec" title="No Head Notification">
		<t>
    In this scenario, only the multipoint path is used and none of the others matter.  
		A failure in the multipoint path will result in the tail noticing the failure within a Detection Time,
		 and the head will remain ignorant of the tail state. This mode emulates the behavior described
		 in <xref target="RFC8562"/>. In this mode, bfd.SessionType is MultipointTail, and the variable 
		 bfd.SilentTail (see <xref target="new-variable-sec"/>) MUST be set to 1.
		 If bfd.SessionType is MultipointHead or MultipointClient, bfd.ReportTailDown MUST be set to zero. The head
		 MAY set bfd.RequiredMinRxInterval to zero and thus suppress tails sending any BFD Control packets.
		 </t>
	</section>
	<section anchor="head-notification-sec" title="Head Notification">
	<t>
	In these scenarios, the tail sends unsolicited or solicited BFD packets in response 
	to the detection of a multipoint path failure. All these scenarios have common settings:
	<list style="symbols">
	<t>if bfd.SessionType is MultipointTail, the variable bfd.SilentTail (see <xref target="new-variable-sec"/>) MUST be set to zero;</t>
	<t>if bfd.SessionType is MultipointHead or MultipointClient, bfd.ReportTailDown MUST be set to 1;</t>
	<t>the head MUST set bfd.RequiredMinRxInterval to nonzero and thus allow tails to send BFD Control packets.</t>
	</list>
	</t>
	
	<section anchor="unreliable-notify-sec" title="Head Notification without Polling">
		<t>
		In this scenario, the tail sends unsolicited BFD packets in response to the detection 
		of a multipoint path failure.  It uses the reverse unicast path, but not the forward unicast path.
		</t>
		
		<t>
		If the multipoint path fails but the reverse unicast path stays up, the tail will detect the failure 
		within a Detection Time, and the head will know about it within one reverse packet time (since the notification is delayed). 
		</t>
		
		<t>If both the multipoint path and the reverse unicast paths fail, the tail will detect the failure, but the head will remain unaware of it.</t>
	</section>

	<section anchor="semi-reliable-section" title="Head Notification and Tail Solicitation with Multipoint Polling">
		<t>
		In this scenario, the head sends occasional multipoint Polls in addition to (or in lieu of) non-Poll multipoint BFD 
		Control packets, expecting the tails to reply with Final.  This also uses the reverse unicast path, but not the forward unicast path.
		</t>
		
		<t>
		If the multipoint path fails but the reverse unicast path stays up, the tail will detect the failure within a Detection 
		Time, and the head will know about it within one reverse packet time (the notification is delayed to avoid synchronization of the tails).
		</t>
		
		<t>
		If both the multipoint path and the reverse unicast paths fail, the tail will detect the failure, but the head will remain unaware of this fact.
		</t>
		
		<t>
		If the reverse unicast path fails but the multipoint path stays up, the head will see the 
		BFD session fail, but the state of the multipoint path will be unknown to the head.  
		The tail will continue to receive multipoint data traffic.
		</t>
		
		<t>
		If either the multipoint Poll or the unicast reply is lost in transit, the head will see the BFD
		 session fail, but the state of the multipoint path will be unknown to the head.  
		 The tail will continue to receive multipoint data traffic.
		 </t>
		
	</section>
	
	<section anchor="reliable-notification-section" title="Head Notification with Composite Polling">
	
		<t> 
		In this scenario, the head sends occasional multipoint Polls in addition to (or in lieu of) non-Poll 
		multipoint BFD Control packets, expecting the tails to reply with Final.  If a tail that had previously 
		replied to a multipoint Poll fails to reply (or if the head simply wishes to verify tail connectivity), the
		head issues a unicast Poll Sequence to the tail.  This scenario makes use of all three paths.
		In this mode for bfd.SessionType of MultipointTail,
		 variable bfd.SilentTail (see <xref target="new-variable-sec"/>) MUST be set to zero.
		</t> 
		
		<t>
		If the multipoint path fails but the two unicast paths stay up,  the tail will detect the failure 
		within a Detection Time, and the head will know about it within one reverse packet time (since the notification is delayed).  
		Note that the reverse packet time may be smaller in this case if the head has previously issued a unicast Poll 
		(since the tail will not delay transmission of the notification in this case).
		</t> 
		
		<t>
		If both the multipoint path and the reverse unicast paths fail (regardless of the state of the forward unicast path), 
		the tail will detect the failure, but the head will remain unaware of this fact. The head will detect a BFD session 
		failure to the tail but cannot make a determination about the state of the tail's multipoint connectivity.
		</t> 
		
		<t>
		If the forward unicast path fails but the reverse unicast path stays up, the head will detect a BFD 
		session failure to the tail if it happens to send a unicast Poll sequence but cannot make a determination 
		about the state of the tail's multipoint connectivity.  If the multipoint path to the tail fails prior to any unicast 
		Poll being sent, the tail will detect the failure within a Detection Time, and the head will know about it within 
		one reverse packet time (since the notification is delayed).
		</t>
		
		<t>
		If the multipoint path stays up but the reverse unicast path fails, the head will see the 
		particular MultipointClient session 
		fail if it happens to send a Poll Sequence, but the state of the multipoint path will be unknown to the head.  
		The tail will continue to receive multipoint data traffic.
		</t> 
		
		<t>
		If the multipoint path and the reverse unicast path both stay up but the forward unicast path fails, 
		neither side will notice this failure as long as a unicast Poll Sequence is never sent by the head.  If the head sends 
		a unicast Poll Sequence, the head will detect the failure in the forward unicast path. The state of the multipoint path 
		will be determined by the multipoint Poll. The tail will continue to receive multipoint data traffic.
		</t> 
	</section>
		</section>
		
</section>

   
<section title="Protocol Details"> 

<t> This section describes the operation of the BFD
     Multipoint active tail in detail.  This section modifies Section
     4 of <xref target="RFC8562"/> as follows:
	<list style="symbols">
	<t><xref target="state-variables-sec"/> introduces new state variables and modifies the usage of a few existing ones;</t>
	<t><xref target="mpBFD-replacement-sec"/> replaces the corresponding sections in the base BFD for multipoint networks specification.</t>
	</list>
	</t>

	<section title="Multipoint Client Session">
		
		<t>
		If the head is keeping track of some or all of the tails, it has a session of type MultipointClient 
		per tail that it cares about. All of the MultipointClient sessions for tails on a particular multipoint 
		path are associated with the MultipointHead session to which the clients are listening.  A BFD 
		Poll Sequence may be sent over a MultipointClient session to a tail if the head wishes to verify connectivity. 
		These sessions receive any BFD Control packets sent by the tails and MUST NOT transmit periodic BFD 
		Control packets other than Poll Sequences (since periodic transmission is always done by the MultipointHead session).
		Note that the settings of all BFD variables in a MultipointClient session for a particular tail override the 
		corresponding settings in the MultipointHead session.
		</t>
	
	</section>

	<section title="Multipoint Client Session Failure">
	
		<t>
		If a MultipointClient session receives a BFD Control packet from the tail with state Down or AdminDown, 
		the head reliably knows that the tail has lost multipoint connectivity. If the Detection Time expires on a 
		MultipointClient session, it is ambiguous as to whether the multipoint connectivity failed or whether there 
		was a unicast path problem in one direction or the other, so the head does not reliably know the tail's state.
		</t>
	
	</section>

	<section anchor="state-variables-sec" title="State Variables">
		
		<t>BFD Multipoint active tail introduces new state variables
		and modifies the usage of a few existing ones defined in
		Section 5.4 of <xref target="RFC8562"/>.</t> 
		
		<section anchor="new-variable-sec" title="New State Variables">
			<t>A few state variables are added in support of multipoint BFD active tail.
				<list style="empty">
							
				<t> bfd.SilentTail
					<list style="empty">
						 <t>If zero, a tail may send packets to the head according to other parts of this specification.  
						    Setting this to 1 allows tails to be provisioned to always be silent, even when
							the head is soliciting traffic from the tails.  This can be
							useful, for example, in deployments of a large number of tails
							when the head wishes to track the state of a subset of them.
							This variable MUST be initialized based on configuration.
							The default value MUST be 1.</t>

							<t>This variable is only pertinent when bfd.SessionType is
								MultipointTail and SHOULD NOT be modified after 
								the MultipointTail session has been created.</t>
					</list>
				</t>
		 
					<t>bfd.ReportTailDown
						<list style="empty">
							<t>Set to 1 if the head wishes tails to notify the head, via
							 periodic BFD Control packets, when they see the BFD session
							 fail.  If zero, the tail will never send periodic BFD Control
							 packets, and the head will not be notified of session failures
							 by the tails.  This variable MUST be initialized based on configuration.
							 The default value MUST be zero.
							 </t>
							 <t>This variable is only pertinent when bfd.SessionType is
							MultipointHead or MultipointClient.
							</t>
						</list>
					</t>
					
					<t>bfd.UnicastRcvd
						<list style="empty">
							<t>Set to 1 if a tail has received a unicast BFD Control packet from
							the head while being in Up state. This variable MUST be set to zero if the session
							transitions from Up state to some other state.
							</t>
							<t>This variable MUST be initialized to zero.</t>
							<t>This variable is only pertinent when bfd.SessionType is
							MultipointTail.
							</t>
						</list>
					</t>
					
				</list>
			</t>
			</section>
			
					<section title="New State Variable Value">
							<t>
					A new state variable value being added to:
					</t>
									<t>bfd.SessionType
						<list style="empty">
							<t>The type of
							this session
							as defined in
							<xref target="RFC7880"/>. A
							new value
							introduced is:
								<list style="empty">
					<t>MultipointClient:  A session on the head that tracks the state of an individual tail, when desirable.</t>
								</list>
							</t>
		
				<t>This variable MUST be initialized to the appropriate type when the session is created, according to the rules in Section 5.4 of <xref target="RFC8562"/>.</t>
						</list>
						</t>

		</section>
		
		<section title="State Variable Initialization and Maintenance">
			<t>
			Some state variables defined in Section 6.8.1 of <xref target="RFC5880"/> need to be 
			initialized or manipulated differently depending on the session type.

			The values of some of these variables relate to those of the same variables of a MultipointHead session
			(see Section 5.4.2 of <xref target="RFC8562"/>).
				<list style="empty">
					<t>bfd.LocalDiscr
						<list style="empty">
							<t>For session type MultipointClient, this variable MUST always
							 match the value of bfd.LocalDiscr in the associated
							 MultipointHead session.
							 </t>
						</list>
					</t>
					
					<t>bfd.DesiredMinTxInterval
						<list style="empty">
							<t>For session type MultipointClient, this variable MUST always
							 match the value of bfd.DesiredMinTxInterval in the associated
							 MultipointHead session.
							 </t>
						</list>
					</t>
					
					<t>bfd.RequiredMinRxInterval
						<list style="empty">
							<t>
It MAY be set to zero at the head BFD system to suppress traffic from the tails.
Setting it to zero in the MultipointHead session suppresses traffic from all tails;
the setting in a MultipointClient session suppresses traffic from a single tail.
</t>
						</list>
					</t>
					
					<t>bfd.DemandMode
						<list style="empty">
							<t>This variable MUST be initialized to 1 for session types MultipointClient.</t>
						</list>
					</t>
					
					<t>bfd.DetectMult
						<list style="empty">
							<t>For session type MultipointClient, this variable MUST always
							 match the value of bfd.DetectMult in the associated
							 MultipointHead session.
							</t>
						</list>
					</t>
				</list>
			</t>
		</section>
	
	</section>
	
	
	<section anchor="control-multipoint-options" title="Controlling Multipoint BFD Options">
	
		<t>The state variables defined above are used to choose which operational options are active.</t>
		
		<t>
 The most basic form of the BFD operation in multipoint networks is explained in <xref target="RFC8562"/>.
 In this scenario, BFD Control packets flow only from the head, and no tracking of tail state at the head is desired.
 That can be accomplished by setting bfd.ReportTailDown to zero in the MultipointHead session (<xref target="no-head-notify-sec"/>).
		</t>
		
		<t>
		If the head wishes to know of active tails, it sends multipoint 
		Polls as needed. Previously known tails that don't respond to the 
		Polls will be detected (as per <xref target="semi-reliable-section"/>).
		</t>
		
		<t>
		If the head wishes to request a notification from the tails when they lose connectivity, 
		it sets bfd.ReportTailDown to 1 in either the MultipointHead session (if such notification is 
		desired from all tails) or the MultipointClient session (if notification is desired from a particular tail).  
		Note that the setting of this variable in a MultipointClient session for a particular tail overrides the setting in the MultipointHead session.
		</t>
		
		<t>
		If the head wishes to verify the state of a tail on an ongoing basis, it 
		sends a Poll Sequence from the MultipointClient session associated with that tail as needed.
		This has the effect of eliminating the initial delay, as described in <xref target="TRANSMIT"/>,
    that the tail would otherwise insert prior to transmission of the packet; thus, the head may have
    notification of the session failure more quickly when comparing with use of m-poll.
		</t> 
		
		<t>
		If a tail wishes to operate silently (sending no BFD Control packets to the head), 
		it sets bfd.SilentTail to 1 in the MultipointTail session.  This allows a tail to be silent independent of the settings on the head.
		</t>

	</section>
	
	<section title="State Machine">
	
		<t>
		Though the state transitions for the state machine, 
		as defined in Section 5.5 of <xref target="RFC8562"/>,
    for a session type MultipointHead are only administratively driven,
		the state machine for a session of type MultipointClient is the same, 
		and the diagram is applicable.
		</t>
		
	</section>
	
	<section title="Session Establishment">
	
		<t>
		If BFD Control packets are received at the head, they are demultiplexed to sessions of type MultipointClient, 
		which represent the set of tails that the head is interested in tracking.  These sessions will typically also be 
		established dynamically based on the receipt of BFD Control packets.  The head has broad latitude in choosing 
		which tails to track, if any, without affecting the basic operation of the protocol.  
		The head directly controls whether or not tails are allowed to send BFD Control 
		packets back to the head by setting bfd.RequiredMinRxInterval to zero in 
		a MultipointHead or a MultipointClient session.
		</t>
		
	</section>	
	
	
	<section title="Discriminators and Packet Demultiplexing">
		
		<t>
		When the tails send BFD Control packets to the head from the MultipointTail session, 
		the contents of Your Discriminator (the discriminator received from the head) will not be sufficient 
		for the head to demultiplex the packet, since the same value will be received from all tails 
		on the multicast tree.  In this case, the head MUST demultiplex packets based on the source 
		address and the value of Your Discriminator, which together uniquely identify the tail and the multipoint path.
		</t>
		
		<t>
		When the head sends unicast BFD Control packets to a tail from a MultipointClient session, the 
		value of Your Discriminator will be valid, and the tail MUST demultiplex the packet based solely on Your Discriminator.
		</t> 	
			
	</section>
	
	<section title="Controlling Tail Packet Transmission">
		<t>As the fan-in from the tails to the head may be very large, it is critical that the flow of BFD Control packets from the tails is controlled.</t>
		
		<t>
		The head always operates in Demand mode.  This means that no tail will send 
		an asynchronous BFD Control packet as long as the session is Up.
		</t>
		
		<t>
		The value of Required Min Rx Interval received by a tail in a unicast BFD Control packet, if any, 
		always takes precedence over the value received in multipoint BFD Control packets.  This allows 
		the packet rate from individual tails to be controlled separately as desired by sending a BFD Control 
		packet from the corresponding MultipointClient session.  This also eliminates the random delay,
		as discussed in <xref target="TRANSMIT"/>,
		prior to transmission from the tail that would otherwise be inserted, 
		reducing the latency of reporting a failure to the head.
		</t>
		
		<t>
		If the head wishes to suppress traffic from the tails when they detect a session failure, it MAY 
		set bfd.RequiredMinRxInterval to zero, which is a reserved value that indicates that the sender 
		wishes to receive no periodic traffic.  This can be set in the MultipointHead session (suppressing 
		traffic from all tails), or it can be set in a MultipointClient session (suppressing traffic from only a single tail).
		</t>
		
		<t>
		Any tail may be provisioned to never send *any* BFD Control packets to 
		the head by setting bfd.SilentTail to 1.  This provides a mechanism by 
		which only a subset of tails reports their session status to the head.
		</t>
		
	</section>
	
	<section title="Soliciting the Tails">
		<t>
		If the head wishes to know of the active tails, the MultipointHead session 
		can send a BFD Control packet as specified in <xref target="TRANSMIT"/>, with the 
		Poll (P) bit set to 1.  This will cause all of the tails to reply with a unicast BFD 
		Control Packet, randomized across one packet interval.
		</t>
		
		<t>
		The decision as to when to send a multipoint Poll is outside the scope of this specification.  
		However, it MUST NOT be sent more often than the regular multipoint BFD Control packet.  
		Since the tail will treat a multipoint Poll like any other multipoint BFD Control packet, Polls may be sent in lieu of non-Poll packets.
		</t>
		
		<t>
		Soliciting the tails also starts the Detection Timer for each of the associated MultipointClient sessions, 
		which will cause those sessions to time out if the associated tails do not respond.
		</t>
		
		<t>
		Note that for this mechanism to work properly, the Detection Time (which is equal to bfd.DesiredMinTxInterval) 
		MUST be greater than the round-trip time of BFD Control packets from the head to the tail (via the multipoint path) 
		and back (via a unicast path).  See <xref target="DETECT"/> for more details.
		</t>
		
	</section>
	
	<section title="Verifying Connectivity to Specific Tails">
		<t>
		If the head wishes to verify connectivity to a specific tail, the corresponding MultipointClient 
		session can send a BFD Poll Sequence to said tail.  This might be done in reaction to the 
		expiration of the Detection Timer (the tail didn't respond to a multipoint Poll), or it might be done on a proactive basis.
		</t>
		
		<t>
		The interval between transmitted packets in the Poll Sequence MUST be calculated as 
		specified in the base BFD specification <xref target="RFC5880"/> (the greater of bfd.DesiredMinTxInterval and bfd.RemoteMinRxInterval).
		</t>
		
		<t>
		The value transmitted in Required Min RX Interval will be used by the tail (rather than the value received in 
		any multipoint packet) when it transmits BFD Control packets to the head to notify it of a session failure, and 
		the transmitted packets will not be delayed. This value can potentially be set much lower than in the multipoint case, 
		in order to speed up a notification to the head, since the value will be used only by the single tail.  
		This value (and the lack of delay) are "sticky", in that once the tail receives it, it will continue to use it indefinitely.  
		Therefore, if the head no longer wishes to single out the tail, it SHOULD reset the timer to the default by sending 
		a Poll Sequence with the same value of Required  Min Rx Interval as is carried in the multipoint packets, or it MAY 
		reset the tail session by sending a Poll Sequence with state AdminDown (after the completion of which the session will come back up).
		</t>
		
		<t>
		Note that a failure of the head to receive a response to a Poll Sequence does not necessarily mean that the tail 
		has lost multipoint connectivity, though a reply to a Poll Sequence does reliably indicate connectivity 
		or lack thereof (by virtue of the tail's state not being Up in the BFD Control packet).
		</t>
		
	</section>
	
		
	<section title="Detection Times" anchor="DETECT">
		
		<t>
		MultipointClient sessions at the head are always in the Demand mode, and as such only care about Detection Time in two cases.  
		First, if a Poll Sequence is being sent on a MultipointClient session, the Detection Time on this session is calculated according 
		to the base BFD specification <xref target="RFC5880"/>, that is, the transmission interval multiplied by bfd.DetectMult. Second, when a multipoint Poll is sent 
		to solicit tail replies, the Detection Time on all associated MultipointClient sessions that aren't currently sending Poll Sequences 
		is set to a value greater than or equal to bfd.RequiredMinRxInterval (one packet time).  This value can be made arbitrarily large 
		in order to ensure that the Detection Time is greater than the round-trip time of a BFD Control packet
		between the head and the tail with no ill effects, 
		other than delaying the detection of unresponsive tails.  Note that a Detection Time expiration on a MultipointClient session at the 
		head, while indicating a BFD session failure, cannot be construed to mean that the tail is not hearing multipoint packets from the head.
		</t>
						
	</section>
	
	<section title="MultipointClient Down/AdminDown Sessions ">
		
		<t>
		If the MultipointHead session is in Down/AdminDown state (which only happens administratively), 
		all associated MultipointClient sessions SHOULD be destroyed as they are superfluous.
		</t>
			
		<t>
		If a MultipointClient session goes down due to the receipt of an unsolicited BFD Control packet from the 
		tail with state Down or AdminDown (not in response to a Poll), and tail connectivity verification is not being done, 
		the session MAY be destroyed.  If verification is desired, the session SHOULD send a Poll Sequence and the session SHOULD be maintained. 
		</t>
			
		<t>
		If the tail replies to a Poll Sequence with state Down or AdminDown, it means 
		that the tail session is definitely down.  In this case, the session MAY be destroyed. 
		</t>
			
		<t>If the Detection Time expires on a MultipointClient session (meaning that the tail did not reply to a Poll Sequence), the session MAY be destroyed.</t>
					
	</section>
	
	<section anchor="mpBFD-replacement-sec" title="Base BFD for Multipoint Networks Specification Text Replacement">
		<t>The following sections are meant to extend the corresponding 
		sections in the base BFD for multipoint networks specification <xref target="RFC8562"/>.</t>
		
		<section title="Reception of BFD Control Packets">
			<t>The following procedure modifies parts of Section 5.13.1 of <xref target="RFC8562"/>.</t>
			
			<t>
			When a BFD Control packet is received, the procedure defined in Section 5.13.1 of <xref target="RFC8562"/> 
			MUST be followed, in the order specified.  If the packet is discarded according to these rules, processing
			of the packet MUST cease at that point. In addition to that, if tail tracking is desired by
			the head, the following procedure MUST be applied.
				<list style="empty">
					<t>If bfd.SessionType is MultipointTail
						<list style="empty">
							<t>If bfd.UnicastRcvd
							is zero or the Multipoint
							(M) bit is clear, set
							bfd.RemoteMinRxInterval to the value of Required Min RX
							Interval.
							</t>
							<t>If the Multipoint (M) bit is clear, set bfd.UnicastRcvd to 1.</t>
						</list>
					</t>
					<t>Else (not MultipointTail)
						<list style="empty">
							<t>Set bfd.RemoteMinRxInterval to the value of Required Min RX Interval.</t>
						</list>
					</t>
					
					<t>If the Poll (P) bit is set, and bfd.SilentTail is zero, send a BFD
					Control packet to the remote system with the Poll (P) bit clear
					and the Final (F) bit set (see <xref target="TRANSMIT"/>).
					</t>
				</list>
			</t>

		</section>
		
		<section title="Demultiplexing BFD Control Packets">
			<t>This section is part of the addition to Section 5.13.2 of <xref target="RFC8562"/>, separated for clarity.
				<list style="empty">
					
					<t>If the Multipoint (M) bit is clear
						<list style="empty">
							<t>If the Your Discriminator field is nonzero:
								<list style="empty">
									<t>Select a session based on the value of Your Discriminator. If no session is found, the packet MUST be discarded.</t>
									<t>If bfd.SessionType is MultipointHead:
										<list style="empty">
											<t>Find a MultipointClient session grouped to this 
											MultipointHead session, based on the source address and the
											value of Your Discriminator.  If a session is found and is not
											MultipointClient, the packet MUST be discarded.  If no session
											is found, a new session of type MultipointClient MAY be
											created, or the packet MAY be discarded.  This choice is outside
											the scope of this specification.
											</t>
											<t>If bfd.SessionType is not MultipointClient, the packet MUST be discarded.</t>
										</list>
									</t>
								</list>
							</t>
						</list>
					</t>
				</list>
			</t>
			
		</section>
		
		<section title="Transmitting BFD Control Packets" anchor="TRANSMIT">
			
			<t>A system MUST NOT periodically transmit BFD Control packets if bfd.SessionType is MultipointClient and a Poll Sequence is not being transmitted.</t>
					
			<t>
			If the bfd.SessionType value is MultipointTail and the periodic transmission 
			of BFD Control packets is just starting (due to Demand 
			mode not being active on the remote system), the first packet to be transmitted MUST be delayed by a 
			random amount of time between zero and (0.9 * bfd.RemoteMinRxInterval).
			</t>
				
			<t>
			If a BFD Control packet is received with the Poll (P) bit set to 1, the receiving system MUST 
			transmit a BFD Control packet with the Poll (P) bit clear and the Final (F) bit, without respect to the 
			transmission timer or any other transmission limitations, the session state, and whether Demand mode is 
                        active on either system.  A system MAY limit the rate at which such 
			packets are transmitted.  If rate limiting is in effect, the advertised value of Desired Min TX Interval MUST 
			be greater than or equal to the interval between transmitted packets imposed by the rate-limiting function. 
			If the Multipoint (M) bit is set in the received packet, the packet transmission MUST be delayed by a random 
			amount of time between zero and (0.9 * bfd.RemoteMinRxInterval). Otherwise, 
			the packet MUST be transmitted as soon as practicable.
			</t>
				
			<t>A system MUST NOT set the Demand (D) bit if bfd.SessionType is MultipointClient 
			unless bfd.DemandMode is 1, bfd.SessionState is Up, and bfd.RemoteSessionState is Up.</t>
			
			<t>Content of the transmitted packet MUST be as explained in Section 5.13.3 of <xref target="RFC8562"/>. </t>
		</section>
	
	</section>
		
</section>


<section title="Assumptions">
	<t>
	If the head notification is to be used, it is assumed that a multipoint BFD packet encapsulation 
	contains enough information so that a tail can address a unicast BFD packet to the head.
	</t>
	
	<t>
	If the head notification is to be used, it is assumed that there is bidirectional unicast 
	communication available (at the same protocol layer within which BFD is being run) between the tail and head.
	</t>
	
	<t>
	For the head to know reliably that a tail has lost multipoint connectivity, the unicast 
	paths in both directions between that tail and the head must remain operational when 
	the multipoint path fails. It is thus desirable that unicast paths not share fate with the multipoint 
	path to the extent possible if the head wants more definite knowledge of the tail state.
	</t>
	
	<t>
	Since the normal BFD three-way handshake is not used in this application, a tail transitioning 
	from state Up to Down and back to Up again may not be reliably detected at the head.
	</t>
		
</section>

<section title="Operational Considerations">
<t>
   Section 7 of <xref target="RFC5880"/> includes the requirements for implementation of a congestion control
   mechanism when BFD is used across multiple hops and a mechanism that uses congestion detection to reduce the amount of
   BFD packets the system generates. These requirements are also applicable to this specification.

    When
   this specification is used in the mode with no head notifications by tails, as discussed in <xref target="no-head-notify-sec"/>,
   the head MUST limit the packet transmission rate to no higher than one BFD packet per second (see Section 5.13.3 of <xref target="RFC8562"/>).
   When the BFD uses one of the notifications by the tails to the head mechanisms described in <xref target="head-notification-sec"/>, Min RX Interval
   can be used by the tail to control the packet transmission rate of the head. The exact mechanism of processing changes in the 
   Min RX Interval value in the received from the tail response to multicast or the unicast Poll BFD packet is outside the scope of this document.
   </t>
<t>
   As noted in Section 7 of <xref target="RFC5880"/>, "any mechanism that increases the transmit or receive
   intervals will increase the Detection Time for the session".
   </t>
</section>

<section title="IANA Considerations">
	<t>This document has no IANA actions.</t>
</section>

<section title="Security Considerations">
<t>The same security considerations as those described in 
<xref target="RFC5880"/> and <xref target="RFC8562"/> apply to this document.</t>
<t>
   Additionally, implementations that create
   MultpointClient sessions dynamically upon receipt of a BFD
   Control packet from a tail MUST implement protective measures to prevent a
   number of MultipointClient sessions from being created and growing out of control.  Below are
   some points to be considered in such implementations.
<list>
<t>
      When the number of MultipointClient sessions exceeds the number of 
      expected tails, the implementation should generate an alarm 
      to users to indicate the anomaly.
</t>
<t>
      The implementation should have a reasonable upper bound on the
      number of MultipointClient sessions that can be created, with the
      upper bound potentially being computed based on the number of
      multicast streams that the system is expecting.
</t>
</list>
</t>
	<t>
	This specification does not raise any additional security issues beyond those of the 
	specifications referred to in the list of normative references.
	</t>
</section>
    
  </middle>

  <back>

    <references title="Normative References">
	  <?rfc include="reference.RFC.5880"?>
          <?rfc include="reference.RFC.7880"?>
	  <?rfc include="reference.RFC.2119"?>
          <?rfc include="reference.RFC.8174"?>

<!--draft-ietf-bfd-multipoint-19; RFC 8562 -->
<reference anchor="RFC8562" target="https://www.rfc-editor.org/info/rfc8562">
<front>
<title>Bidirectional Forwarding Detection (BFD) for Multipoint Networks</title>
<author initials="D" surname="Katz" fullname="Dave Katz">
    <organization/>
</author>
<author initials="D" surname="Ward" fullname="David Ward">
    <organization/>
</author>
<author initials="S" surname="Pallagatti" fullname="S. Pallagatti" role="editor">
    <organization/>
</author>
<author initials="G" surname="Mirsky" fullname="Gregory Mirsky" role="editor">
    <organization/>
</author>
<date month="March" year="2019"/>
</front>
<seriesInfo name="RFC" value="8562"/>
<seriesInfo name="DOI" value="10.17487/RFC8562"/>
</reference>

    </references>


<section title="Acknowledgments" numbered="no">

	<t>The authors would like to thank Nobo Akiya, Vengada Prasad Govindan, Jeff Haas, Wim Henderickx, and Mingui Zhang who have greatly contributed to this document.</t>
	
</section>

<section title="Contributors" numbered="no">

	<t>Rahul Aggarwal of Juniper Networks and George Swallow of Cisco Systems provided the initial idea for this specification and contributed to its development.</t>
	
</section>
    
  </back>
</rfc>

