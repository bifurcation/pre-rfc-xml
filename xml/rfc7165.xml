<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc rfcedstyle="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="info" number="7165" submissionType="IETF" consensus="yes"
     ipr="trust200902">


  <!-- ***** FRONT MATTER ***** -->

  <front>

    <title abbrev="JOSE Use Cases">Use Cases and Requirements for&nbsp;JSON&nbsp;Object&nbsp;Signing&nbsp;and&nbsp;Encryption&nbsp;(JOSE)</title>

    <author fullname="Richard Barnes" initials="R.L." surname="Barnes">
      <organization>Mozilla</organization>

      <address>
        <postal>
          <street>331 E. Evelyn Ave.</street>

          <city>Mountain View</city>

          <region>CA</region>

          <code>94041</code>

          <country>US</country>
        </postal>

        <email>rlb@ipv.sx</email>
      </address>
    </author>

    <date month="March" year="2014"/>

    <area>SEC</area>

    <workgroup>JOSE</workgroup>


    <keyword>JWS, JWE, JWK, JWA, JWT, CMS, S/MIME, JOSE, XMPP, ALTO, OAuth</keyword>

    <abstract>
      <t>Many Internet applications have a need for object-based security
      mechanisms in addition to security mechanisms at the network layer or
      transport layer. For many years, the Cryptographic Message Syntax (CMS) has
      provided a binary secure object format based on ASN.1. Over time,
      binary object encodings such as ASN.1 have become less common than
      text-based encodings, such as the JavaScript Object Notation (JSON). This
      document defines a set of use cases and requirements for a secure object
      format encoded using JSON, drawn from a variety of
      application security mechanisms currently in development.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro-sec" title="Introduction">
      <t>Internet applications rest on the layered architecture of the
      Internet and take advantage of security mechanisms at all layers. Many
      applications rely primarily on channel-based security technologies such as
      IPsec and Transport Layer Security (TLS),
      which create a secure channel at the IP layer or transport layer over
      which application data can flow <xref target="RFC4301"/> <xref
      target="RFC5246"/>. These mechanisms, however, cannot provide end-to-end
      security in some cases. For example, in protocols with application-layer
      intermediaries, channel-based security protocols would protect messages
      from attackers between intermediaries, but not from the intermediaries
      themselves. These cases require object-based security technologies,
      which embed application data within a secure object that can be safely
      handled by untrusted entities.</t>

      <t>The most well-known example of such a protocol today is the use of
      Secure/Multipurpose Internet Mail Extensions (S/MIME) protections within
      the email system <xref target="RFC5751"/> <xref target="RFC5322"/>. An
      email message typically passes through a series of intermediate Mail
      Transfer Agents (MTAs) en route to its destination. While these MTAs
      often apply channel-based security protections to their interactions
      (e.g., STARTTLS <xref target="RFC3207"/>), these protections do not prevent the
      MTAs from interfering with the message. In order to provide end-to-end
      security protections in the presence of untrusted MTAs, mail users can
      use S/MIME to embed message bodies in a secure object format that can
      provide confidentiality, integrity, and data origin authentication.</t>

      <t>S/MIME is based on the Cryptographic Message Syntax (CMS) for secure
      objects <xref target="RFC5652"/>. CMS is defined using Abstract
      Syntax Notation 1 (ASN.1) and typically encoded using the ASN.1
      Distinguished Encoding Rules (DER), which define a binary encoding of
      the protected message and associated parameters <xref
      target="ITU.X690.2002"/>. In recent years, usage of ASN.1 has decreased
      (along with other binary encodings for general objects), while more
      applications have come to rely on text-based formats such as the
      Extensible Markup Language (XML) <xref target="W3C.REC-xml"/> or the JavaScript Object Notation
      (JSON) <xref target="RFC7159"/>.</t>

      <t>Many current applications thus have much more robust support for
      processing objects in these text-based formats than ASN.1 objects;
      indeed, many lack the ability to process ASN.1 objects at all. To
      simplify the addition of object-based security features to these
      applications, the IETF JSON Object Signing and Encryption (JOSE) working
      group has been chartered to develop a secure object format based on
      JSON. While the basic requirements for this object format are
      straightforward -- namely, confidentiality and integrity mechanisms
      encoded in JSON -- discussions in the working group indicated that
      different applications hoping to use the formats defined by JOSE have
      different requirements. This document summarizes the use cases for JOSE
      envisioned by those potential applications and the resulting requirements for
      security mechanisms and object encodings.</t>

      <t>Some systems that use XML have specified the use of XML-based
      security mechanisms for object security, namely XML Digital Signatures
      and XML Encryption <xref target="W3C.xmldsig-core"/> <xref
      target="W3C.xmlenc-core"/>. These mechanisms are used by
      several security token systems (e.g., Security Assertion Markup Language
      (SAML) <xref target="OASIS.saml-core-2.0-os"/>,
      Web Services Federation <xref target="WS-Federation"/>), and the Common Alerting Protocol (CAP)
      emergency alerting format <xref target="CAP"/>. In practice, however,
      XML-based secure object formats introduce similar levels of complexity
      to ASN.1 (e.g., due to the need for XML canonicalization), so developers 
      that lack the tools or motivation to handle
      ASN.1 aren't likely to use XML security either. This situation motivates
      the creation of a JSON-based secure object format that is simple enough
      to implement and deploy that it can be easily adopted by developers with
      minimal effort and tools.</t>
    </section>

    <section anchor="def-sec" title="Definitions">
      <t>This document makes extensive use of standard security terminology
      <xref target="RFC4949"/>. In addition, because the use cases for JOSE
      and CMS are similar, we will sometimes make analogies to some CMS
      concepts <xref target="RFC5652"/>.</t>

      <t>The JOSE working group charter calls for the group to define three
      basic JSON object formats:<list style="numbers">

          <t>Integrity-protected object format</t>

          <t>Confidentiality-protected object format</t>

          <t>A format for expressing keys</t>
        </list>

      In this document, we will refer to these as
      the "signed object format", the "encrypted object format",
      and the "key format", respectively.
      The JOSE working group items intended to describe these formats are 
      JSON Web Signature <xref target="JWS"/>, JSON Web Encryption
<xref target="JWE"/>, and JSON Web Key <xref target="JWK"/>,
      respectively. 

      Algorithms and algorithm identifiers used by JWS, JWE, and JWK are defined in
      JSON Web Algorithms <xref target="JWA"/>.
      </t>

      <t>In general, where there is no need to distinguish between asymmetric and
      symmetric operations, we will use the terms "signing", "signature", etc.,
      to denote both true digital signatures involving asymmetric cryptography
      as well as Message Authentication Codes (MACs) using symmetric keys.</t>

      <t>In the lifespan of a secure object, there are two basic roles, an
      entity that creates the object (e.g., encrypting or signing a payload)
      and an entity that uses the object (decrypting and verifying). We will
      refer to these roles as "sender" and "recipient", respectively. Note
      that while some requirements and use cases may refer to these as single
      entities, each object may have multiple entities in each role. For
      example, a message may be signed by multiple senders or decrypted by
      multiple recipients.</t>
    </section>

    <section anchor="basic-sec" title="Basic Requirements">
      <t>For the encrypted and signed object formats, the necessary
      protections will be created using appropriate cryptographic mechanisms:
      symmetric or asymmetric encryption for confidentiality and MACs or
      digital signatures for integrity protection. In both cases, it is
      necessary for the JOSE format to support both symmetric and asymmetric
      operations.<list style="symbols">
          <t>The JOSE encrypted object format must support object encryption
          in the case where the sender and receiver share a symmetric key.</t>

          <t>The JOSE encrypted object format must support object encryption
          in the case where the sender has only a public key for the
          receiver.</t>

          <t>The JOSE signed object format must support integrity protection using
          MACs, for the case where the sender
          and receiver share only a symmetric key.</t>

          <t>The JOSE signed object format must support integrity protection using
          digital signatures, for the case where the receiver has only a
          public key for the sender.</t>
        </list></t>

      <t>In some applications, the key used to process a JOSE object is indicated
      by application context, instead of directly in the JOSE object.  However,
      in order to avoid confusion, endpoints that lack the necessary context need
      to be able to recognize this and fail cleanly.  Other than keys, JOSE objects 
      do not support pre-negotiation; all cryptographic parameters must be expressed
      directly in the JOSE object.
          <list style="symbols">
          <t>The JOSE signed and encrypted object formats must define the process
          by which an implementation recognizes whether it has the key required
          to process a given object, whether the key is specified by the
          object or by some out-of-band mechanism.</t>

          <t>Each algorithm used for JOSE must define which parameters are 
          required to be present in a JOSE object using that algorithm.</t>
          </list>
      </t>

      <t>In cases where two entities are going to be exchanging several JOSE
      objects, it might be helpful to pre-negotiate some parameters so that 
      they do not have to be signaled in every JOSE object.  However,
      so as not to confuse endpoints that do not support pre-negotiation,
      it is useful to signal when pre-negotiated parameters are in use in those cases.
          <list style="symbols">
          <t>It should be possible to extend the base
	  JOSE signed and encrypted object formats
	  to indicate that pre-negotiated parameters are to be used to 
          process the object.  This extension should also provide a means of indicating  
          which parameters are to be used.</t>
          </list>
      </t>

      <t>The purpose of the key format is to provide the recipient with
      sufficient information to use the encoded key to process cryptographic
      messages. Thus, it is sometimes necessary to include additional parameters along
      with the bare key.</t>

      <t><list style="symbols">
          <t>The JOSE key format must enable inclusion of all algorithm parameters
          necessary to use the encoded key, including an identifier for the
          algorithm with which the key is used as well as any additional
          parameters required by the algorithm (e.g., elliptic curve
          parameters).</t>
        </list></t>
    </section>

    <section anchor="app-req-sec" title="Requirements on Application Protocols">
      <t>
        The JOSE secure object formats describe how cryptographic processing is 
        done on secured content, ensuring that the recipient of an object is able
        to properly decrypt an encrypted object or verify a signature.  In order
        to make use of JOSE, however, applications will need to specify several
        aspects of how JOSE is to be used:
        <list style="symbols">
          <t>What application content is to be protected</t>
          <t>Which cryptographic algorithms are to be used</t>
          <t>How application protocol entities establish keys</t>
          <t>Whether keys are to be explicitly indicated in JOSE objects or 
             associated by application context</t>
          <t>Which serialization(s) of JOSE objects are to be used</t>
        </list>
      </t>
    </section>

    <section anchor="use-cases-sec" title="Use Cases">
      <t>Several IETF working groups developing application-layer protocols
      have expressed a desire to use the JOSE data formats in their
      designs for end-to-end security features. In this section, we summarize
      the use cases proposed by these groups and discuss the requirements that
      they imply for the JOSE object formats.</t>

      <section anchor="sec-token-sec" title="Security Tokens">
        <t>Security tokens are a common use case for object-based security,
        for example, SAML assertions <xref target="OASIS.saml-core-2.0-os"/>.
        Security tokens are used to convey information about a subject entity
        ("claims" or "assertions") from an issuer to a recipient. The security
        features of a token format enable the recipient to verify that the
        claims came from the issuer and, if the object is
        confidentiality protected, that they were not visible to other
        parties.</t>

        <t>Security tokens are used in federation protocols such as SAML 2.0
	<xref target="OASIS.saml-core-2.0-os"/>,
        WS-Federation <xref target="WS-Federation"/>,
	Mozilla Persona <xref target="Persona"/>,
	and OpenID Connect <xref target="OpenID.Core"/>,
	as well as in resource authorization
        protocols such as OAuth 2.0 <xref target="RFC6749"/>,
	including for OAuth bearer tokens <xref target="RFC6750"/>. In some cases,
        security tokens are used for client authentication and for access
        control <xref target="JWT-BEARER"/> <xref
        target="SAML2"/>.</t>

	<t>JSON Web Token <xref target="JWT"/>
	is a security token format
	based on JSON and JOSE. It is used with Mozilla Persona,
	OpenID Connect, and OAuth. Because JWTs are often used in contexts
	with limited space (e.g., HTTP query parameters), it is a core
	requirement for JWTs, and thus JOSE, to have a compact, URL-safe
	representation.</t>

      </section>

      <section anchor="oauth-sec" title="OAuth">

        <t>The OAuth protocol defines a mechanism for distributing and using
        authorization tokens using HTTP <xref target="RFC6749"/>. A client
        that wishes to access a protected resource requests authorization from
        the resource owner. If the resource owner allows this access, he
        directs an authorization server to issue an access token to the
        client. When the client wishes to access the protected resource, he
        presents the token to the relevant resource server, which verifies the
        validity of the token before providing access to the protected
        resource.</t>

        <figure anchor="figOAuth" title="The OAuth Process">
          <artwork><![CDATA[              +---------------+          +---------------+
              |               |          |               |
              |   Resource    |<........>| Authorization |
              |    Server     |          |     Server    |
              |               |          |               |
              +---------------+          +---------------+
                           ^                |
                           |                |
                           |                |
                           |                |
                           |                |
              +------------|--+          +--|------------+
              |            +----------------+            |
              |               |          |   Resource    |
              |     Client    |          |     Owner     |
              |               |          |               |
              +---------------+          +---------------+]]></artwork>

          <postamble/>
        </figure>

        <t>In effect, this process moves the token from the authorization
        server (as a sender of the object) to the resource server (recipient)
        via the client as well as the resource owner (the latter because of
        the HTTP mechanics underlying the protocol). As with email, we have a case
        where an application object is transported via untrusted
        intermediaries.</t>

        <t>This application has two essential security requirements: integrity
        and data origin authentication. Integrity protection is required so
        that the resource owner and the client cannot modify the permission
        encoded in the token.  Although the resource owner is ultimately 
        the entity that grants authorization, it is not trusted to modify the
        authorization token, since this could, for example, grant access to
        resources not owned by the resource owner.</t>
        
        <t>Data origin authentication is required so that
        the resource server can verify that the token was issued by a trusted
        authorization server. </t>

        <t>Confidentiality protection may also be needed
        if the authorization server is concerned about the visibility of
        permissions information to the resource owner or client. For example,
        permissions related to social networking might be considered private
        information. Note, however, that OAuth already requires that the
        underlying HTTP transactions be protected by TLS, so tokens are 
        already confidentiality protected from entities other than
        the resource owner and client.</t>

        <t>The confidentiality and integrity needs are met by the basic
        requirements for signed and encrypted object formats, whether the
        signing and encryption are provided using asymmetric or symmetric
        cryptography. The choice of which mechanism is applied will depend on
        the relationship between the two servers, namely whether they share a
        symmetric key or only public keys.</t>

        <t>Authentication requirements will also depend on deployment
        characteristics. Where there is a relatively strong binding between
        the resource server and the authorization server, it may suffice for
        the authorization server issuing a token to be identified by the key
        used to sign the token. This requires that the protocol carry either the
        public key of the authorization server or an identifier for the public
        or symmetric key.  In OAuth, the <spanx style="verb">client_id</spanx> 
        parameter (external to the token) identifies the key to be used.</t>

        <t>There may also be more advanced cases where the authorization
        server's key is not known in advance to the resource server. This may
        happen, for instance, if an entity instantiated a collection of
        authorization servers (say for load balancing), each of which has an
        independent key pair. In these cases, it may be necessary to also
        include a certificate or certificate chain for the authorization
        server, so that the resource server can verify that the authorization
        server is an entity that it trusts.</t>

        <t>The HTTP transport for OAuth imposes a particular constraint on the
        encoding. In the OAuth protocol, tokens frequently need to be passed
        as query parameters in HTTP URIs <xref target="RFC2616"/> after
        having been base64url encoded <xref target="RFC4648"/>. While there is
        no specified limit on the length of URIs (and thus of query
        parameters), in practice, URIs of more than 2,048 characters are
        rejected by some user agents.  So this use case requires that JOSE objects
        be sufficiently small, even after being signed and possibly encrypted.</t>
      </section>

      <section anchor="oidc-sec" title="OpenID Connect">
  	    <t>The OpenID Connect protocol <xref target="OpenID.Core"/>
  	    is a simple, REST/JSON-based
  	    identity federation protocol layered on OAuth 2.0.
  	    It uses the JWT and JOSE formats both
        to represent security tokens and to provide security for other
        protocol messages (performing signing and optionally encryption).
  	    OpenID Connect negotiates the algorithms to be used and distributes
  	    information about the keys to be used using protocol elements
  	    that are not part of the JWT and JOSE header parameters.</t>

        <t>
        In the OpenID Connect context,  
        it is possible for the recipient of a JWT to accept it without
        integrity protection in the JWT itself.  In such cases, the recipient
        chooses to rely on transport security rather than object security.  For
        example, if the payload is delivered over a TLS-protected channel, the
        recipient may regard the protections provided by TLS as sufficient, so
        JOSE protection would not be required.
        </t>

        <t>
        However, even in this case, it is desirable to associate some 
        metadata with the JWT payload (claim set), such as the content type,
        or other application-specific metadata.  In a signed or encrypted 
        object, these metadata values could be carried in a header with 
        other metadata required for signing or encryption.  It would thus
        simplify the design of OpenID Connect if 
        there could be a JOSE object format that does not apply cryptographic
        protections to its payload, but allows a header to be attached to the
        payload in the same way as a signed or encrypted object.
        </t>
      </section>

      <section anchor="xmpp-sec" title="XMPP">
        <t>The Extensible Messaging and Presence Protocol (XMPP) routes
        messages from one end client to another by way of XMPP servers <xref
        target="RFC6120"/>. There are typically two servers involved in
        delivering any given message: The first client (Alice) sends a message
        for another client (Bob) to her server (A). Server A uses Bob's identity
        and the DNS to locate the server for Bob's domain (B) and then delivers
        the message to that server. Server B then routes the message to
        Bob.</t>

        <figure anchor="fig-xmpp" title="Delivering an XMPP Message">
          <artwork><![CDATA[
         +-------+   +----------+   +----------+   +-----+
         | Alice |-->| Server A |-->| Server B |-->| Bob |
         +-------+   +----------+   +----------+   +-----+]]></artwork>
        </figure>

        <t>The untrusted-intermediary problems are especially acute for XMPP
        because in many current deployments, the holder of an XMPP domain
        outsources the operation of the domain's servers to a different
        entity. In this environment, there is a clear risk of exposing the
        domain holder's private information to the domain operator. XMPP
        already has a defined mechanism for end-to-end security using S/MIME,
        but it has failed to gain widespread deployment <xref
        target="RFC3923"/>, in part because of key management challenges and
        in part because of the difficulty of processing S/MIME objects.</t>

        <t>The XMPP working group is in the process of developing a new
        end&nbhy;to&nbhy;end encryption system with an encoding based on JOSE and a
        clearer key management system <xref target="XMPP-E2E"/>.
        The process of sending an encrypted message in this system involves
        two steps: First, the sender generates a symmetric Session Master Key
        (SMK), encrypts the message content (including a per-message Content
        Master Key), and sends the encrypted message to the desired set of 
        recipients.  Second, each recipient "dials back" to the sender,
        providing his public key.  The sender then responds with the relevant
        SMK, wrapped with the recipient's public key.</t>
        
        <figure anchor="fig-xmpp-sec" title="Delivering a Secure XMPP Message">
          <artwork><![CDATA[
         +-------+   +----------+   +----------+   +-----+
         | Alice |<->| Server A |<->| Server B |<->| Bob |
         +-------+   +----------+   +----------+   +-----+
             |             |              |           |
             |------------Encrypted message---------->|  
             |             |              |           |
             |<---------------Public key--------------|
             |             |              |           |
             |---------------Wrapped SMK------------->|
             |             |              |           |]]></artwork>
        </figure>

        <t>The main thing that this system requires from the JOSE formats is
        confidentiality protection via content encryption, plus an integrity
        check via a MAC derived from the same symmetric key. The separation of
        the key exchange from the transmission of the encrypted content,
        however, requires that the JOSE encrypted object format allow wrapped
        symmetric keys to be carried separately from the encrypted payload. In
        addition, the encrypted object will need to have a tag for the key
        that was used to encrypt the content, so that the recipient (Bob) can
        present the tag to the sender (Alice) when requesting the wrapped
        key.</t>

        <t>Another important feature of XMPP is that it allows for the
        simultaneous delivery of a message to multiple recipients. In the
        diagrams above, Server A could deliver the message not only to Server
        B (for Bob) but also to Servers C, D, E, etc., for other users. In such
        cases, to avoid the multiple "dial back" transactions implied by the
        above mechanism, XMPP systems will likely reuse a given SMK for
        multiple individual messages, refreshing the SMK on a periodic and/or
        event-driven basis (e.g., when the recipient's presence changes).  They might
        also cache public keys for end recipients, so that wrapped keys can be 
        sent along with content on future messages.  This implies that the JOSE 
        encrypted object format must support the provision of multiple versions
        of the same wrapped SMK (much as a CMS EnvelopedData structure can 
        include multiple RecipientInfo structures).</t>

        <t>In the current draft of the XMPP end-to-end security system, each
        party is authenticated by virtue of the other party's trust in the
        XMPP message routing system. The sender is authenticated to the
        receiver because he can receive messages for the identifier "Alice"
        (in particular, the request for wrapped keys) and can originate
        messages for that identifier (the wrapped key). Likewise, the receiver
        is authenticated to the sender because he received the original
        encrypted message and originated the request for a wrapped key. So, the
        authentication here requires not only that XMPP routing be done
        properly, but also that TLS be used on every hop. Moreover, it
        requires that the TLS channels have strong authentication, since a man
        in the middle on any of the three hops can masquerade as Bob and
        obtain the key material for an encrypted message.</t>

        <t>Because this authentication is quite weak (depending on the use of
        TLS on three hops) and unverifiable by the
        endpoints, it is possible that the XMPP working group will integrate
        some sort of credentials for end recipients, in which case there would
        need to be a way to associate these credentials with JOSE objects.</t>

        <t>Finally, it's worth noting that XMPP is based on XML, not JSON. So
        by using JOSE, XMPP will be carrying JSON objects within XML. It is
        thus a desirable property for JOSE objects to be encoded in such a way
        as to be safe for inclusion in XML. Otherwise, an explicit CDATA
        indication must be given to the parser to indicate that it is not to
        be parsed as XML. One way to meet this requirement would be to apply
        base64url encoding, but for XMPP messages of medium-to-large size,
        this could impose a fair degree of overhead.</t>
      </section>

      <section anchor="alto-sec" title="ALTO">
        <t>Application-Layer Traffic Optimization (ALTO) is a system for
        distributing network topology information to end devices, so that
        those devices can modify their behavior to have a lower impact on the
        network <xref target="RFC6708"/>. The ALTO protocol
        distributes topology information in the form of JSON objects carried
        in HTTP <xref target="RFC2616"/> <xref
        target="ALTO"/>. The basic version of ALTO is simply
        a client-server protocol, so simple use of HTTPS suffices for this
        case <xref target="RFC2818"/>. However, there is beginning to be some
        discussion of use cases for ALTO in which these JSON objects will be
        distributed through a collection of intermediate servers before
        reaching the client, while still preserving the ability of the client
        to authenticate the original source of the object. 

        Even the base ALTO
        protocol notes that "ALTO Clients obtaining ALTO information through redistribution must be
        able to validate the received ALTO information" to ensure that it was
        generated by an appropriate ALTO server.</t>

        <t>In this case, the security requirements are straightforward. JOSE
        objects carrying ALTO payloads will need to bear digital signatures
        from the originating servers, which will be bound to certificates
        attesting to the identities of the servers. There is no requirement
        for confidentiality in this case, since ALTO information is generally
        public.</t>

        <t>The more interesting questions are encoding questions. ALTO objects
        are likely to be much larger than payloads in the two cases above,
        with sizes of up to several megabytes. Processing of such large
        objects can be done more quickly if it can be done in a single pass,
        which may be possible if JOSE objects require specific orderings of
        fields within the JSON structure.</t>

        <t>In addition, because ALTO objects are also encoded as JSON, they
        are already safe for inclusion in a JOSE object. Signed JOSE objects
        will likely carry the signed data in a string alongside the signature.
        JSON objects have the property that they can be safely encoded in JSON
        strings. All they require is that unnecessary white space be removed,
        a much simpler transformation than, say, base64url encoding. This
        raises the question of whether it might be possible to optimize the
        JOSE encoding for certain "JSON-safe" cases.</t>

        <t>Finally, it may be desirable for ALTO to have a "detached signature"
        mechanism, that is, a way to encode signature information separate 
        from the protected content.  This would allow the ALTO protocol to 
        include the signature in an HTTPS header, with the signed content as
        the HTTPS entity body.</t>
      </section>

      <section anchor="atoca-sec" title="Emergency Alerting">
        <t>Emergency alerting is an emerging use case for IP networks <xref
        target="ALERT-REQ"/>. Alerting systems allow
        authorities to warn users of impending danger by sending alert
        messages to connected devices. For example, in the event of a hurricane
        or tornado, alerts might be sent to all devices in the path of the
        storm.</t>

        <t>The most critical security requirement for alerting systems is that
        it must not be possible for an attacker to send false alerts to
        devices. Such a capability would potentially allow an attacker to
        create wide-spread panic. In practice, alert systems prevent these
        attacks both by controls on sending messages at points where alerts
        are originated, and by having recipients of alerts verify that
        the alert was sent by an authorized source. The former type of control
        is implemented with local security on hosts from which alerts can be
        originated. The latter type is implemented by digital signatures on alert
        messages (using channel-based or object-based mechanisms).  With an
        object-based mechanism, the signature value is encoded in a secure object.
        With a channel-based mechanism, the alert is "signed" by virtue of being
        sent over an authenticated, integrity-protected channel.</t>

        <t>Alerts typically reach end recipients via a series of
        intermediaries. For example, while a national weather service might
        originate a hurricane alert, it might first be delivered to a national
        gateway and then to network operators, who broadcast it to end
        subscribers.</t>

        <t><figure anchor="fig-atoca-sec"
            title="Delivering an Emergency Alert">
            <artwork><![CDATA[        +------------+    +------------+    +------------+
        | Originator |    | Originator |    | Originator |
        +------------+    +------------+    +------------+
              |                 .                 .       
              +-----------------+..................       
                                |                         
                                V                         
                           +---------+                    
                           | Gateway |                    
                           +---------+                    
                                |                         
                   +------------+------------+            
                   |                         |            
                   V                         V            
              +---------+               +---------+       
              | Network |               | Network |       
              +---------+               +---------+       
                   |                         |            
            +------+-----+            +------+-----+      
            |            |            |            |      
            V            V            V            V      
        +--------+   +--------+   +--------+   +--------+ 
        | Device |   | Device |   | Device |   | Device | 
        +--------+   +--------+   +--------+   +--------+ 

]]></artwork>
          </figure></t>

        <t>In order to verify alert signatures, recipients must be provisioned
        with the proper public keys for trusted alert authorities. This trust
        may be "piece-wise" along the path the alert takes. For example, the
        alert relays operated by networks might have a full set of
        certificates for all alert originators, while end devices may only
        trust their local alert relay. Or, devices might require that a device
        be signed by an authorized originator and by its local network's
        relay.</t>

        <t>This scenario creates a need for multiple signatures on alert
        documents, so that an alert can bear signatures from any or all of the
        entities that processed it along the path. In order to minimize
        complexity, these signatures should be "modular" in the sense that a
        new signature can be added without a need to alter or recompute
        previous signatures.</t>
      </section>

      <section anchor="webcrypto-sec" title="Web Cryptography">
      <t>The W3C Web Cryptography API defines a standard cryptographic API for the
      Web <xref target="WebCrypto"></xref>.  If a browser exposes this API, then 
      JavaScript provided as part of a Web page can ask the browser to perform 
      cryptographic operations, such as digest, MAC, encryption, or digital signing.</t>

      <t>One of the key reasons to have the browser perform cryptographic operations  
      is to avoid allowing JavaScript code to access the keying material used for these
      operations.  For example, this separation would prevent code injected through a
      cross-site scripting (XSS) attack from reading and exfiltrating keys stored 
      within a browser.  While the malicious code could still use the key while running
      in the browser, this vulnerability can only be exercised while the malicious code
      is active in a user's browser.</t>

      <t>However, the Web Cryptography API also provides a key export functionality, 
      which can allow JavaScript to extract a key from the API in wrapped form.  For
      example, JavaScript code might provide a public key for which the corresponding
      private key is held by another device.  The wrapped key provided by the API 
      could then be used to safely transport the key to the new device.  While this
      could potentially allow malicious code to export a key, the need for an explicit
      export operation provides a control point, allowing for user notification or
      consent verification.</t>

      <t>The Web Cryptography API also allows browsers to impose limitations on the 
      usage of the keys it handles.  For example, a symmetric key might be marked as 
      usable only for encryption, and not for MAC.  When a key is exported in wrapped 
      form, these attributes should be carried along with it.</t>

      <t>The Web Cryptography API thus requires formats to express several forms of
      keys.  Obviously, the public key from an asymmetric key pair can be freely 
      imported to and exported from the browser, so there needs to be a format for
      public keys.  There is also a need for a format to express private keys and
      symmetric keys.  For non-public keys, the primary need is for a wrapped form,
      where the confidentiality and integrity of the key is assured cryptographically;
      these protections should also apply to any attributes of the key.  It may also
      be useful to define a direct, unwrapped format for use within a security 
      boundary.</t>
      </section>

    <section title="Constrained Devices">
   
      <t>This section describes use cases for constrained devices as defined 
      in <xref target="CONSTRAINED"/>. Typical issues with this type of 
      device are limited memory, limited power supply, low processing
      power, and severe message size limitations for the communication
      protocols.</t>
   
      <section title="Example: MAC Based on ECDH-Derived Key">

        <t>Suppose a small, low power device maker has decided on using the output of
        the JOSE working group as their encryption and authentication
        framework.  The device maker has a limited budget for both gates and 
        power.  For this reason there are a number of
        short cuts and design decisions that have been made in order to
        minimize these needs.</t>
        
        <t>The design team has determined that the use of MACs is going to be sufficient to provide the necessary
        authentication.  However, although a MAC is going to be used, they do
        not want to use a single long-term shared secret.  Instead, they have
        adopted the following proposal for computing a shared secret that can
        be validated:</t>
        
        <t><list style="symbols">
          <t>An Elliptic-Curve Diffie-Hellman (ECDH) key pair is generated for the
          device at the time of manufacturing.  (Or, as part of the
          configuration process during installation.)</t>
        
          <t>An ECDH public key for the controller is configured at the time of
          configuration.</t>
        
          <t>The configuration system performs the ECDH computation and
          configures the device with the resulting shared secret.  This
          process eliminates the need for the device to be able to perform
          the required ECDH processing.  The security requirements
          on protecting this computed shared secret are the same as the
          requirements on protecting the private ECDH key.</t>
        
          <t>A counter and an increment value are configured onto the device.</t>
        
          <t>When a message is to be sent by the device, the counter is
          incremented and a new MAC key is computed from the ECDH secret and
          the counter value.  A custom Key Derivation Function (KDF)
          based on AES-CBC is used to derive
          the required MAC key.  The MAC key is then used to compute the MAC
          value for the message.</t>
        </list></t>
        
        <t>In a similar manner, the KDF function can be used to compute an 
        Authenticated Encryption with Associated Data (AEAD) algorithm key when 
        the system needs to provide confidentiality for the
        message.  The controller, being a larger device, will perform the
        ECDH step and use a random number generator to generate the
        sender nonce value.</t>

      </section>
      <section title="Object Security for CoAP">
    
        <t>This use case deals with constrained devices of class C0/C1 (see
        <xref target="CONSTRAINED"/>). These devices communicate using RESTful
        requests and responses transferred using the Constrained Application Protocol 
        <xref target="CoAP"/>. To simplify matters, all communication is
        assumed to be unicast; i.e., these security measures don't cover 
        multicast or broadcast.</t>
        
        <t>In this type of setting, it may be too costly to use session-based 
        security (e.g., to run a 4-pass authentication protocol) since
        receiving and in particular sending consumes a lot of power, especially
        for wireless devices. Therefore, to just secure the CoAP 
        payload by replacing a plaintext payload of a request or response
        with a JWE object is an important alternative solution, which
        allows a trade-off between protection (the CoAP headers are not
        protected) and performance.</t>
        
        <t>In a simple setting, consider the payload of a CoAP GET response from
        a sensor type device. The information in a sensor reading may be 
        privacy or business sensitive and needs both integrity protection and
        encryption.</t>
        
        <t>However, some sensor readings are very short, say, a few bytes, and in
        this case, default encryption and integrity protection algorithms 
        (such as 128-bit AES-CBC with HMAC_SHA256) may cause a dramatic
        expansion of the payload, even disregarding JWE headers.</t>
        
        <t>Also, the value of certain sensor readings may decline rapidly, e.g.,
        traffic or environmental measurements, so it must be possible to 
        reduce the security overhead.</t>
        
        <t>This leads to the following requirements that could be covered by
        specific JWE/JWS profiles:</t>
        
        <t><list style="symbols">
          <t>The size of the secure object shall be as small as possible.
          Receiving an object may cost orders of magnitude more in terms of
          power than performing, say, public key cryptography on the object, 
          in particular in a wireless setting.</t>
        
          <t>Integrity protection: 
          The object shall be able to support integrity protection, i.e., have
          a field containing a digital signature, both public key signatures 
          and keyed MACs shall be supported.</t>
        
          <t>Encryption: 
          The object shall be able to support encryption as an optional
          addition to integrity protection. It shall be possible to exclude
          certain fields from encryption, which are needed before verifying 
          integrity or decrypting the object.</t>
        
          <t>Cipher suites:
          It should be possible to support a variety of cipher suites to
          support the constrained devices' use cases. For example:
            <list style="symbols">
              <t>Block ciphers with block sizes of, e.g., 96 bits, in addition to
              the standard 128 bits.</t>
              <t>Modes of operation for block ciphers that do not expand the 
              message size to a block boundary, such as AES-GCM.</t>
              <t>Cipher suites that support combined encryption and MAC 
              calculation (i.e., AEAD modes for block ciphers).</t>
            </list>
          </t>
        </list></t>
    
      </section>
    </section>
    
    </section>

    <section anchor="req-sec" title="Requirements">
      <t>This section summarizes the requirements from the above use cases and
      lists further requirements not directly derived from the above use cases.
      There are also some constraints that are not hard requirements but that
      are still desirable properties for the JOSE system to have.</t>

      <section anchor="functional-sec" title="Functional Requirements">
        <t><list style="hanging">
          <t hangText="F1">Define formats for secure objects that provide the following
          security properties:
            <list style="symbols">
            <t>Digital signature (integrity/authentication under an asymmetric key pair)</t>
            <t>Message authentication (integrity/authentication under a symmetric key)</t>
            <t>Authenticated encryption</t>
            </list>
          </t>
          <t hangText="F2">Define a format for public keys and private keys for 
          asymmetric cryptographic algorithms, with associated attributes, including a
          wrapped form for private keys.</t>
          <t hangText="F3">Define a format for symmetric keys with associated attributes,
          allowing for both wrapped and unwrapped keys.</t>
          <t hangText="F4">Define a JSON serialization for each of the above objects.  An object
          in this encoding must be valid according to the JSON ABNF syntax 
          <xref target="RFC7159"></xref>.</t>
          <t hangText="F5">Define a compact, URL-safe text serialization for the encrypted 
          and signed object formats.</t>
          <t hangText="F6">Allow for attributes associated to wrapped keys to be bound 
          to them cryptographically.</t>
          <t hangText="F7">Allow for wrapped keys to be separated from a secure object 
          that uses a symmetric key.  In such cases, cryptographic components of the 
          secure object other than the wrapped key (e.g., ciphertext, MAC values) must
          be independent of the wrapped form of the key.  For example, if an encrypted
          object is prepared for multiple recipients, then only the wrapped key may vary,
          not the ciphertext.</t>
          <t hangText="F8">Do not impose more overhead than is required to meet the 
          requirements in this document, especially when a large amount of application
          content is being protected.</t>
        </list></t>
      </section>
      
      <section anchor="sec-req-sec" title="Security Requirements">
        <t><list style="hanging">
        <t hangText="S1">Provide mechanisms to avoid repeated use of the same symmetric
        key for encryption or MAC computation.  Instead, long-lived keys should be used
        only for key wrapping, not for direct encryption/MAC.  It should be possible to use any
        of the key management techniques provided in CMS <xref target="RFC5652"></xref>:
          <list style="symbols">
            <t>Key transport (wrapping for a public key)</t>
            <t>Key encipherment (wrapping for a symmetric key)</t>
            <t>Key agreement (wrapping for a Diffie-Hellman (DH) public key)</t>
            <t>Password-based encryption (wrapping under a key derived from a password)</t>
          </list>
        </t>

        <t hangText="S2">Where long-lived symmetric keys are used directly for cryptographic
        operations (i.e., where requirement S1 is not met), provide deployment guidance on
        key management practices, such as the need to limit key lifetimes.</t>

        <t hangText="S3">Use cryptographic algorithms in a manner compatible with
        major validation processes.  For example, if typical validation standards allow
        algorithm A to be used for purpose X but not purpose Y, then JOSE should
        not recommend using algorithm A for purpose Y.</t>
        
        <t hangText="S4">Support operation with or without pre-negotiation.  
        It must be possible to create or process secure objects without
        any configuration beyond key provisioning.  If it is possible for keys
        to be derived from application context, it must be possible for a recipient
        to recognize when it does not have the appropriate key.</t>
        </list></t>
      </section>

      <section anchor="desiderata-sec" title="Desiderata">
        <t><list style="hanging">
          <t hangText="D1">Maximize compatibility with the W3C Web Crypto 
          specifications, e.g., by coordinating with the Web Crypto working group
          to encourage alignment of algorithms and algorithm identifiers. </t>

          <t hangText="D2">Avoid JSON canonicalization to the extent possible.
	  That is, all other things being equal, techniques that rely 
          on fixing a serialization of an object (e.g., by encoding it with base64url) 
          are preferred over those that require converting an object to a 
          canonical form.</t>

          <t hangText="D3">Maximize the extent to which the inputs and outputs of
          JOSE cryptographic operations can be controlled by the applications, as
          opposed to involving processing specific to JOSE.  This allows JOSE the
          flexibility to address the needs of many cryptographic protocols.  
          For example, in some cases, it might allow JOSE objects to be translated to 
          legacy formats such as CMS without the need for re-encryption or re-signing.</t>
        </list></t>
      </section>
    </section>

    <section anchor="sec-cons-sec" title="Security Considerations">
      <t>The primary focus of this document is the requirements for a
      JSON-based secure object format. At the level of general security
      considerations for object-based security technologies, the security
      considerations for this format are the same as for CMS <xref
      target="RFC5652"/>. The primary difference between the JOSE format and
      CMS is that JOSE is based on JSON, which does not have a canonical
      representation. The lack of a canonical form means that it is difficult
      to determine whether two JSON objects represent the same information,
      which could lead to vulnerabilities in some usages of JOSE.</t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <references title="Normative References">

      <?rfc include="reference.RFC.4949.xml"?>
      <?rfc include="reference.RFC.5652.xml"?>
      <?rfc include="reference.RFC.6120.xml"?>
      <?rfc include="reference.RFC.6708.xml"?>
      <?rfc include="reference.RFC.6749.xml"?>
      <?rfc include="reference.RFC.7159.xml"?>

     <reference anchor="W3C.REC-xml" target="http://www.w3.org/TR/2008/REC-xml-20081126/">
        <front>
          <title>Extensible Markup Language (XML) 1.0 (Fifth Edition)</title>
          <author fullname="" initials="T." surname="Bray"><organization/></author>
          <author fullname="" initials="E." surname="Maler"><organization/></author>
          <author fullname="" initials="J." surname="Paoli"><organization/></author>
          <author fullname="" initials="C." surname="Sperberg-McQueen">
          <organization/></author>
          <date month="November" year="2008"/>
        </front>
       <seriesInfo name="W3C" value="Recommendation"/>
      </reference>

      <reference anchor="WebCrypto" target="http://www.w3.org/TR/2013/WD-WebCryptoAPI-20130108/">
        <front>
          <title>Web Cryptography API</title>
          <author fullname="" initials="D." surname="Dahl"><organization/></author>
          <author fullname="" initials="R." surname="Sleevi"><organization/></author>
          <date month="January" year="2013"/>
        </front>
       <seriesInfo name="W3C" value="Working Draft"/>
      </reference>
    </references>

    <references title="Informative References">

      <?rfc include="reference.RFC.4648.xml"?>
      <?rfc include="reference.RFC.5246.xml"?>
      <?rfc include="reference.RFC.5322.xml"?>
      <?rfc include="reference.RFC.5751.xml"?>
      <?rfc include="reference.RFC.6750.xml"?>
      <?rfc include="reference.RFC.2818.xml"?>
      <?rfc include="reference.RFC.3207.xml"?>
      <?rfc include="reference.RFC.3923.xml"?>
      <?rfc include="reference.RFC.4301.xml"?>
      <?rfc include="reference.RFC.2616.xml"?>

<!--draft-ietf-alto-protocol:  in queue in EDIT state -->
<reference anchor='ALTO'>
<front>
<title>ALTO Protocol</title>
<author initials='R' surname='Alimi' fullname='Richard Alimi' role='editor'>
    <organization />
</author>
<author initials='R' surname='Penno' fullname='Reinaldo Penno' role='editor'>
    <organization />
</author>
<author initials='Y' surname='Yang' fullname='Yang Yang' role='editor'>
    <organization />
</author>
<date month='March' year='2014' />
</front>
<seriesInfo name='Work in' value='Progress' />
</reference>

<!--draft-ietf-atoca-requirements-03, Expired-->
<reference anchor='ALERT-REQ'>
<front>
<title>Requirements, Terminology and Framework for Exigent Communications</title>
<author initials='H' surname='Schulzrinne' fullname='Henning Schulzrinne'>
    <organization />
</author>
<author initials='S' surname='Norreys' fullname='Steve Norreys'>
    <organization />
</author>
<author initials='B' surname='Rosen' fullname='Brian Rosen'>
    <organization />
</author>
<author initials='H' surname='Tschofenig' fullname='Hannes Tschofenig'>
    <organization />
</author>
<date month='March' year='2012' />
</front>
<seriesInfo name='Work in' value='Progress' />
</reference>

<!-- draft-ietf-core-coap-18: in queue in EDIT state -->
<reference anchor='CoAP'>
<front>
<title>Constrained Application Protocol (CoAP)</title>
<author initials='Z' surname='Shelby' fullname='Zach Shelby'>
    <organization />
</author>
<author initials='K' surname='Hartke' fullname='Klaus Hartke'>
    <organization />
</author>
<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>
<date month='June' year='2013' />
</front>
<seriesInfo name='Work in' value='Progress' />
</reference>

<!--draft-ietf-jose-json-web-algorithms: I-D Exists -->
<reference anchor='JWA'>
<front>
<title>JSON Web Algorithms (JWA)</title>
<author initials='M' surname='Jones' fullname='Michael Jones'>
    <organization />
</author>
<date month='March' year='2014' />
</front>
<seriesInfo name='Work in' value='Progress' />
</reference>

<!--draft-ietf-jose-json-web-encryption: I-D Exists -->
<reference anchor='JWE'>
<front>
<title>JSON Web Encryption (JWE)</title>
<author initials='M' surname='Jones' fullname='Michael Jones'>
    <organization />
</author>
<author initials='J' surname='Hildebrand' fullname='Joe Hildebrand'>
    <organization />
</author>
<date month='March' year='2014' />
</front>
<seriesInfo name='Work in' value='Progress' />
</reference>

<!--draft-ietf-jose-json-web-key: I-D Exists -->
<reference anchor='JWK'>
<front>
<title>JSON Web Key (JWK)</title>
<author initials='M' surname='Jones' fullname='Michael Jones'>
    <organization />
</author>
<date month='March' year='2014' />
</front>
<seriesInfo name='Work in' value='Progress' />
</reference>

<!--draft-ietf-jose-json-web-signature-21: I-D Exists -->
<reference anchor='JWS'>
<front>
<title>JSON Web Signature (JWS)</title>
<author initials='M' surname='Jones' fullname='Michael Jones'>
    <organization />
</author>
<author initials='J' surname='Bradley' fullname='John Bradley'>
    <organization />
</author>
<author initials='N' surname='Sakimura' fullname='Nat Sakimura'>
    <organization />
</author>
<date month='March' year='2014' />
</front>
<seriesInfo name='Work in' value='Progress' />
</reference>

<!--draft-ietf-lwig-terminology-07, Active-->
<reference anchor='CONSTRAINED'>
<front>
<title>Terminology for Constrained Node Networks</title>
<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>
<author initials='M' surname='Ersue' fullname='Mehmet Ersue'>
    <organization />
</author>
<author initials='A' surname='Keranen' fullname='Ari Keranen'>
    <organization />
</author>
<date month='March' year='2014' />
</front>
<seriesInfo name='Work in' value='Progress' />
</reference>

<!-- draft-ietf-oauth-json-web-token: I-D Exists-->
<reference anchor='JWT'>
<front>
<title>JSON Web Token (JWT)</title>
<author initials='M' surname='Jones' fullname='Michael Jones'>
    <organization />
</author>
<author initials='J' surname='Bradley' fullname='John Bradley'>
    <organization />
</author>
<author initials='N' surname='Sakimura' fullname='Nat Sakimura'>
    <organization />
</author>
<date month='March' year='2014' />
</front>
<seriesInfo name='Work in' value='Progress' />
</reference>

<!--draft-ietf-oauth-jwt-bearer: I-D Exists -->
<reference anchor='JWT-BEARER'>
<front>
<title>JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants</title>
<author initials='M' surname='Jones' fullname='Michael Jones'>
    <organization />
</author>
<author initials='B' surname='Campbell' fullname='Brian Campbell'>
    <organization />
</author>
<author initials='C' surname='Mortimore' fullname='Chuck Mortimore'>
    <organization />
</author>
<date month='March' year='2014' />
</front>
<seriesInfo name='Work in' value='Progress' />
</reference>

<!--draft-ietf-oauth-saml2-bearer: I-D Exists -->
<reference anchor='SAML2'>
<front>
<title>SAML 2.0 Profile for OAuth 2.0 Client Authentication and Authorization Grants</title>
<author initials='B' surname='Campbell' fullname='Brian Campbell'>
    <organization />
</author>
<author initials='C' surname='Mortimore' fullname='Chuck Mortimore'>
    <organization />
</author>
<author initials='M' surname='Jones' fullname='Michael Jones'>
    <organization />
</author>
<date month='March' year='2014' />
</front>
<seriesInfo name='Work in' value='Progress' />
</reference>

    <!-- draft-miller-xmpp-e2e-06: Expired-->
      <reference anchor='XMPP-E2E'>
        <front>
          <title>End-to-End Object Encryption and Signatures for the Extensible Messaging and Presence Protocol (XMPP)</title>
          <author fullname="" initials="M." surname="Miller">
           <organization/></author>
          <date month='June' year='2013' />
      </front>
      <seriesInfo name='Work in' value='Progress' />
      </reference>

   
 <reference anchor="OASIS.saml-core-2.0-os"
                 target="http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf">
        <front>
          <title>Assertions and Protocols for the OASIS Security Assertion Markup Language (SAML) V2.0</title>
          <author fullname="Scott Cantor" initials="S." surname="Cantor">
            <organization></organization>
          </author>
          <author fullname="John Kemp" initials="J."
                  surname="Kemp">
            <organization></organization>
          </author>
           <author fullname="Eve Maler" initials="E." surname="Maler">
            <organization></organization>
          </author>
          <author fullname="Rob Philpott" initials="R." surname="Philpott">
            <organization></organization>
          </author>
         
          <date month="March" year="2005"/>
        </front>
<seriesInfo name="Oasis" value="Standard"/>
      </reference>


      <reference anchor="ITU.X690.2002">
          <front>
              <title>
      Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)
              </title>
              <author>
                  <organization>International Telecommunications Union</organization>
              </author>
              <date month="July" year="2002"/>
          </front>
          <seriesInfo name="ITU-T" value="Recommendation X.690"/>
      </reference>

        <reference anchor="W3C.xmldsig-core"
                 target="http://www.w3.org/TR/2008/REC-xmldsig-core-20080610/">
        <front>
          <title>XML-Signature Syntax and Processing</title>
	  <author fullname="Donald Eastlake" initials="D." surname="Eastlake">
            <organization/>
          </author>
          <author fullname="Joseph Reagle" initials="J." surname="Reagle">
            <organization/>
          </author>
          <author fullname="David Solo" initials="D." surname="Solo">
            <organization/>
          </author>
          <date month="June" year="2008"/>
        </front>
       <seriesInfo name="W3C" value="Recommendation"/>
      </reference>

       <reference anchor="W3C.xmlenc-core"
                 target="http://www.w3.org/TR/2002/REC-xmlenc-core-20021210/">
        <front>
          <title>XML Encryption Syntax and Processing</title>
	  <author fullname="Donald Eastlake" initials="D." surname="Eastlake">
            <organization/>
          </author>
          <author fullname="Joseph Reagle" initials="J." surname="Reagle">
            <organization/>
          </author>
          <date month="December" year="2002"/>
        </front>
       <seriesInfo name="W3C Candidate" value="Recommendation"/>
      </reference>
     

      <reference anchor="CAP" target="http://www.oasis-open.org/committees/download.php/15135/emergency-CAPv1.1-Corrected_DOM.pdf">
        <front>
          <title>Common Alerting Protocol, v1.1</title>
          <author fullname="" initials="A" surname="Botterell"><organization/></author>
          <author initials="E." surname="Jones"><organization/></author>
          <date month="October" year="2005"/>
        </front>
       <seriesInfo name="OASIS Standard" value="CAP-V1.1"/>
      </reference>


      <reference anchor="OpenID.Core"
                 target="http://openid.net/specs/openid-connect-core-1_0.html">
        <front>
          <title>OpenID Connect Core 1.0</title>
          <author fullname="John Bradley" initials="J." surname="Bradley">
            <organization abbrev="Ping Identity">Ping Identity</organization>
          </author>
          <author fullname="Breno de Medeiros" initials="B." surname="de Medeiros">
            <organization abbrev="Google">Google</organization>
          </author>
          <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
            <organization abbrev="Microsoft">Microsoft</organization>
          </author>
          <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
            <organization abbrev="Salesforce">Salesforce</organization>
          </author>
          <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
            <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
          </author>
          <date month="December" year="2013"/>
        </front>
      </reference>

 <reference anchor="Persona" target="https://developer.mozilla.org/en-US/docs/Persona">
	<front>
	  <title>Mozilla Persona</title>
	  <author>
	    <organization abbrev="Mozilla">Mozilla Developer Network</organization>
	  </author>
	  <date month="April" year="2013" />
	</front>
      </reference>

      <reference anchor="WS-Federation"
                 target="http://docs.oasis-open.org/wsfed/federation/v1.2/os/ws-federation-1.2-spec-os.html">
        <front>
          <title>Web Services Federation Language (WS-Federation) Version 1.2</title>
	  <author fullname="Marc Goodner" initials="M." surname="Goodner">
            <organization/>
          </author>
          <author fullname="Chris Kaler" initials="C." surname="Kaler">
            <organization/>
          </author>
          <author fullname="Michael McIntosh" initials="M." surname="McIntosh">
            <organization/>
          </author>
          <author fullname="Anthony Nadalin" initials="A." surname="Nadalin">
            <organization/>
          </author>
          <date month="May" year="2009"/>
          </front>
         <seriesInfo name="Oasis" value="Standard"/>
      </reference>

    </references>

    <section anchor="ack-sec" title="Acknowledgements">
      <t>Thanks to Matt Miller for discussions related to the XMPP end-to-end
      security model and to Mike Jones for considerations related to security
      tokens and XML security.  Thanks to Mark Watson for raising the need for 
      representing symmetric keys and binding attributes to them.  Thanks to
      Ludwig Seitz for contributing the constrained device use case.</t>
    </section>

   
  </back>
</rfc>
