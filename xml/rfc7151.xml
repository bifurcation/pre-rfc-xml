<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd"[

<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC3552 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<?rfc rfcedstyle="yes"?>

<rfc category="std" number="7151" ipr="trust200902" updates="959" submissionType="IETF" consensus="yes">

  <front>
    <title abbrev="FTP HOST Command for Virtual Hosts">File Transfer Protocol HOST Command for Virtual Hosts</title>
    <author fullname="Paul Hethmon" initials="P." surname="Hethmon">
      <organization>Hethmon Brothers</organization>
      <address>
        <postal>
          <street>2305 Chukar Road</street>
          <city>Knoxville</city>
          <region>TN</region>
          <code>37923</code>
          <country>USA</country>
        </postal>
        <email>phethmon@hethmon.com</email>
      </address>
    </author>

    <author fullname="Robert McMurray" initials="R." surname="McMurray">
      <organization>Microsoft Corporation</organization>
      <address>
        <postal>
          <street>One Microsoft Way</street>
          <city>Redmond</city>
          <region>WA</region>
          <code>98052</code>
          <country>USA</country>
        </postal>
        <email>robmcm@microsoft.com</email>
      </address>
    </author>

    <date month="March" year="2014"/>

    <workgroup>Network Working Group</workgroup>
    <keyword>FTP</keyword>
    <keyword>HOST</keyword>

    <abstract>
      <t>The File Transfer Protocol, as defined in RFC 959, does not provide a
way for FTP clients and servers to differentiate between multiple DNS names
that are registered for a single IP address.  This document defines a new FTP
command that provides a mechanism for FTP clients and servers to identify
individual virtual hosts on an FTP server.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction" toc="default">
      <t>It is common on the Internet for many DNS names to resolve to a single
IP address.  This practice has introduced the concept of a "virtual host",
where a host appears to exist as an independent entity but, in reality, shares
its physical resources with one or more similar hosts.</t>

      <t>Such an arrangement presents some problems for FTP servers, because an
FTP server distinguishes incoming FTP connections by IP addresses rather than
DNS names.  Therefore, all DNS names that share a common IP address are handled
by the same FTP server and share the same Network Virtual File System
(NVFS).</t>

      <t>This means that different virtual hosts cannot offer different virtual
file systems to clients, nor can they offer different authentication systems.
Any scheme to overcome this issue needs to indicate not only the destination IP
address but also the virtual hostname that is associated with the desired
virtual FTP server.  Typical user-FTP processes currently use hostnames to
perform hostname-to-IP-address resolution and then ignore hostnames for the
rest of the FTP session; therefore, any mechanism to overcome this issue would
require modifications to the user protocol interpreter (user-PI) and server
protocol interpreter (server-PI).</t>

      <t>It should be noted that this same problem existed for HTTP/1.0 as
defined in <xref target="RFC1945"></xref> and was resolved in HTTP/1.1 as
defined in <xref target="RFC2616"></xref> through the addition of the Host
request header field.  The goal of this document is to bring a similar level of
feature parity to FTP by introducing a new HOST command that allows user-FTP
processes to specify which virtual host to connect to for a server-FTP process
that is handling requests for multiple virtual hosts on a single IP
address.</t>

    </section>

    <section title="Document Conventions" toc="default">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document
are to be interpreted as described in <xref target="RFC2119"></xref>.</t>

      <t>In examples, "C&gt;" and "S&gt;" indicate lines sent by the client and
server, respectively.</t>

      <t>This document also uses notation defined in <xref target="RFC0959"></xref> and <xref target="RFC1123"></xref>.  In particular, the terms "reply",
"user", "NVFS", "NVT", "file", "pathname", "FTP commands", "DTP", "user-FTP
process", "user-PI", "user-DTP", "server-FTP process", "server-PI",
"server-DTP", "mode", "type", "control connection", "data connection", and
"ASCII", are all used here as defined there.</t>

      <t>The required syntax is defined using the Augmented BNF defined in
<xref target="RFC5234"></xref>.  Some general ABNF definitions are required
throughout the document; they will be defined in subsequent sections.</t>

      <t>With the increased use of virtualization technologies, there may be
several possible definitions for the term "virtual host". This document follows
the definition from Section&nbsp;4.1.14 of <xref target="RFC3875"/>,
where several virtual hosts share the same IP address, and hostnames are used
by the server-FTP process to route user-PI sessions to the appropriate virtual
host.</t>

      <section title="Basic Tokens" toc="default">
        <t>This document imports the core definitions given in Appendix&nbsp;B
of <xref target="RFC5234"/>.  There, definitions will be found for basic
ABNF elements like ALPHA, DIGIT, SP, etc.  To that, the following term is
added for use in this document.</t>

        <t>
          <figure>
            <artwork type="ABNF" xml:space="preserve" name="" align="left"
alt="" width="" height=""><![CDATA[   TCHAR = VCHAR / SP / HTAB    ; visible plus white space]]></artwork>
          </figure>
        </t>
        <t>The VCHAR (from <xref target="RFC5234"/>) and TCHAR rules give
basic character types from varying subsets of the ASCII character set for use
in various commands and responses.</t>

        <t>Note that in ABNF, string literals are case insensitive.  That
convention is preserved in this document and implies that FTP commands and
parameters that are added by this specification have values that can be
represented in any case.  That is, "HOST" is the same as "host", "Host",
"HoSt", etc.  Similarly, because domain names are defined to be
case insensitive, "ftp.example.com" is the same as "Ftp.Example.Com",
"fTp.eXample.cOm", etc.</t>

      </section>
      <section title="Server Replies" toc="default">
        <t>Section 4.2 of <xref target="RFC0959"/> defines the format and
meaning of replies by the server-PI to FTP commands from the user-PI.  Those
reply conventions are used here without change.</t>

        <t>
          <figure title="" suppress-title="false" align="left" alt="" width="" height="">
            <artwork type="ABNF" xml:space="preserve" name="" align="left"
alt="" width="" height=""><![CDATA[   error-response = error-code SP *TCHAR CRLF
   error-code     = ("4" / "5") 2DIGIT]]></artwork>
          </figure>
        </t>
        <t>Implementers should note that the ABNF syntax used in this document
and other FTP-related documents (but that was not used in <xref
target="RFC0959"/>) sometimes shows replies using the one-line format.  Unless
otherwise explicitly stated, multi-line responses are also permitted.
Implementers should assume that, unless stated to the contrary, any reply to
any FTP command (including QUIT) can be of the multi-line format described in
<xref target="RFC0959"/>.</t>

        <t>Throughout this document, replies will be identified by the
three-digit code that is their first element.  Thus, the term "500 reply" means
a reply from the server-PI using the three-digit code "500".</t>

      </section>
    </section>
    <section title="The HOST Command" anchor="hostcommand" toc="default">
      <t>A new command, "HOST", is added to the FTP command set in order to
allow a server-FTP process to determine to which of possibly many virtual hosts
the client wishes to connect.  If a HOST command is sent, it MUST be issued
before the user is authenticated, as this will allow the authentication scheme
and set of authorized users to be dependent upon the virtual host that is
chosen.</t>

      <t>Server-FTP processes MUST treat a situation in which the HOST command is
issued more than once before the user has been authenticated as though only the
last HOST command had been sent, and return the appropriate reply for the last
HOST command.  Server-FTP processes MUST treat a situation in which the HOST
command is issued after the user has been authenticated as an erroneous
sequence of commands and return a 503 reply.</t>

      <t>Servers should note that the response to the HOST command is a
sensible time to send their "welcome" message.  This allows the message to be
personalized for any virtual hosts that are supported.  It also allows the
client to determine, via the FEAT response, the languages or
representations supported by the server and select an appropriate one via
the LANG command.  See <xref target="RFC2640"></xref> for more information.</t>

      <t>It should be noted that user-PI implementations that were created
before the introduction of the HOST command will not support this new command.
A similar problem existed with the introduction of the Host header for HTTP in
<xref target="RFC2616"></xref>, and HTTP server implementations had to
determine how best to accommodate HTTP requests from down-level clients that
did not support the Host header.  With this in mind, server-FTP processes will
need to determine how best to accommodate FTP requests from down-level FTP
clients that do not support the HOST command, but those considerations are
outside the scope of this document.</t>

      <section title="Syntax of the HOST Command" toc="default">
        <t>The HOST command is defined as follows.  Note that <xref target="RFC3986"/> remains the normative specification for the syntactic form of IPv4 and IPv6 address literals, in order to ensure identical presentation in 'ftp' URI hostname parts and in the protocol element specified here.</t>
        <t>
          <figure title="" suppress-title="false" align="left" alt="" width="" height="">
            <artwork type="ABNF" xml:space="preserve" name="" align="left"
alt="" width="" height=""><![CDATA[   host-command  = "HOST" SP hostname CRLF
   hostname      = domain / IP-literal

   domain        = sub-domain *("." sub-domain)
   sub-domain    = let-dig [ldh-str]
   let-dig       = ALPHA / DIGIT
   ldh-str       = *( ALPHA / DIGIT / "-" ) let-dig

   IP-literal    = ( "[" IPv6address "]" ) / IPv4address

   IPv6address   = <see [RFC3986] Section 3.2.2>
   IPv4address   = <see [RFC3986] Section 3.2.2>

   host-response = host-ok / error-response
   host-ok       = "220" [ SP *TCHAR ] CRLF]]></artwork>
          </figure>
        </t>
        <t>The "hostname" rule is a restricted form of the "host" rule
specified in <xref target="RFC3986"/>.  Details of the additional restrictions
imposed by this document are given in the
discussion of the syntax that occurs later in this section; they aim at simplifying implementations by only
allowing what currently is specified precisely and in use on the Internet.</t>

        <t>As with all FTP commands, the "HOST" command word is case
independent and can be specified in any character case desired.</t>

        <t>The "hostname" (given as a parameter) specifies the virtual host
to which access is desired.  This SHOULD be the same hostname that was used to
obtain the IP address to which the FTP control connection was made, after any
client conversions have been completed that convert an abbreviated or local
alias to a complete (fully qualified) domain name, but before resolving a DNS
alias (owner of a CNAME resource record) to its canonical name.</t>

        <t>Internationalization of domain names is only supported through the
use of Internationalized Domain Names for Applications (IDNA) "A-labels" for
&lt;sub-domain&gt; as described in <xref target="RFC5890"/>.  For example, the
following HOST command specifies an internationalized domain name:</t>

        <t>
          <figure title="" suppress-title="false" align="left" alt="" width="" height="">
            <artwork xml:space="preserve" name="" type="" align="left" alt=""
width="" height=""><![CDATA[   HOST xn--e1afmkfd.com]]></artwork>
          </figure>
        </t>
        <t>If the user was given an IPv4 or IPv6 literal address, and
consequently was not required to derive the literal address from a hostname,
the client MAY send the HOST command with the IPv4 or IPv6 literal address as
specified to it.  While it may seem counterintuitive to specify a literal
address by using the HOST command after the client has already connected to the
server using a literal address, this should be expected behavior because a
user-FTP process should not be required to differentiate between a fully
qualified domain name and an IPv4 or IPv6 network literal address.  That being
said, if the IPv4 or IPv6 literal address specified by the client does not
match the literal address for the server, the server MUST respond with a 504
reply to indicate that the IPv4 or IPv6 literal address is not valid.</t>

        <t>When the hostname parameter contains a literal address, square
brackets are expected to disambiguate IPv6 address syntax from port numbers
syntax.  Therefore, if the literal address is an IPv6 address, the IPv6 address
is required to be enclosed in square brackets (after eliminating any syntax
that might also -- but is not required to -- be enclosed in brackets, and
from which the server deduced that a literal address had been specified).  For
example, the following examples MAY be sent if the client had been instructed
to connect to "192.0.2.1", "2001:db8::c000:201", or "::192.0.2.1",
respectively, and IPv6 syntax is preferred:</t>

        <t>
          <figure title="" suppress-title="false" align="left" alt="" width="" height="">
            <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height=""><![CDATA[   HOST 192.0.2.1
   HOST [2001:db8::c000:201]
   HOST [::192.0.2.1]]]></artwork>
          </figure>
        </t>
        <t>The client MUST NOT send the port number as part of the HOST
command, even when the client has been instructed to connect to a non-standard
port.  The reason for this requirement is that the user-PI will have
established a connection to the server-PI before the HOST command is sent;
therefore, specifying a different port with the HOST command has no meaning.
For example, the server-PI MUST respond with a 501 reply if the client sends a
HOST command with syntax like either of the following examples:</t>

        <t>
          <figure title="" suppress-title="false" align="left" alt="" width="" height="">
            <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height=""><![CDATA[   HOST 192.0.2.1:2112
   HOST [2001:db8::c000:201]:2112]]></artwork>
          </figure>
        </t>
        <t>The hostname parameter is otherwise to be treated as a fully
qualified domain name or relative name as those terms are defined in
Section&nbsp;3.1 of <xref target="RFC1034"/>.  This implies that the name is to
be treated as a case-independent string, meaning that uppercase ASCII
characters are to be treated as equivalent to their corresponding lowercase
ASCII characters but otherwise preserved as given.  It also implies some
limits on the length of the parameter and of the components that create its
internal structure.  Those limits are not altered in any way here.</t>

        <t>Neither <xref target="RFC1034"/> nor <xref target="RFC1035"/>
imposes any other restrictions upon what kinds of names can be stored in the
DNS.  This specification, however, only allows the use of names that can be
inferred from the ABNF grammar given for the "hostname".  Similarly, this
specification restricts address literals to the IPv4 and IPv6 address families
well established on the Internet.</t>

      </section>

      <section title="HOST Command Semantics" toc="default">
        <t>Upon receiving the HOST command, before authenticating the user-PI,
a server-FTP process SHOULD validate that the hostname given represents a valid
virtual host for that server and, if it is valid, establish the appropriate
environment for that virtual host.  The resultant actions needed to create that
environment are not specified here and may range from doing nothing at all to
performing a simple change of working directory, changing authentication
schemes and/or username and password lists, or making much more elaborate state
changes -- such as creating isolated environments for each FTP session.</t>

        <t>The 220 reply code for the HOST command is the same as the code
that is used in the initial "welcome" message that is sent after the connection
is established.</t>

        <t>If the hostname specified would normally be acceptable, but is
temporarily unavailable, the server-FTP process SHOULD respond to the HOST
command with a 421 reply and close the connection.<list><t>Example:</t><t>The
server-FTP process is shutting down, so the server-FTP process responds to the
HOST command with a 421 reply and closes the connection.  In this scenario, the
421 reply informs the client it can retry at another time.</t></list></t>

        <t>If the hostname specified is unknown at the server, or if the server
is otherwise unwilling to treat the particular connection as a connection to
the hostname specified, the server SHOULD respond with a 504
reply.<list><t>Examples:</t><t>The particular virtual host that was specified
by the HOST command is disabled at the server.  The server responds with a 504
reply and keeps the connection open in order to allow the user-PI an
opportunity to specify another virtual host with a subsequent HOST
command.</t><t>Alternatively, the server-FTP process might choose to route all
connections with unknown hostnames to a different virtual host so that no
connection attempts will result in failed connections.  This design would be
implementation specific and outside the scope of this
specification.</t></list></t>

        <section title="REIN Command Semantics" toc="default">
          <t>As specified in <xref target="RFC0959"/>, the REIN command returns
the state of the connection to what it was immediately after the transport
connection was opened.  This specification makes no changes to that behavior.
The effect of a HOST command MUST be reset if a REIN command is performed, and
a new HOST command MUST be issued afterwards in order to connect to a virtual
host.</t>

        </section>
        <section title="User-PI Usage of HOST" toc="default">
          <t>A user-PI MUST send the HOST command after opening the transport
connection, or after any REIN command, before attempting to authenticate the
user with the USER command.  The following example illustrates what a typical
login sequence might look like when the HOST command is used:</t>

          <t>
            <figure title="" suppress-title="false" align="left" alt="" width="" height="">
              <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height=""><![CDATA[   C> HOST ftp.example.com
   S> 220 Host accepted
   C> USER foo
   S> 331 Password required
   C> PASS bar
   S> 230 User logged in]]></artwork>
            </figure>
          </t>
          <t>If a user-PI sends an additional HOST command before attempting to
authenticate the user, a server-FTP process MUST treat the additional HOST
command as though a previous HOST command was not sent and return the
appropriate reply for the new HOST command.  For example, if a user specifies
the wrong virtual hostname by mistake, sending a subsequent HOST command will
rectify the error.  The following example illustrates what the login sequence
might look like when the HOST command is sent twice before a user has been
authenticated:</t>
          <t>
            <figure title="" suppress-title="false" align="left" alt="" width="" height="">
              <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height=""><![CDATA[   C> HOST foo.example.com
   S> 220 Host accepted
   C> HOST bar.example.com
   S> 220 Host accepted
   C> USER foo
   S> 331 Password required
   C> PASS bar
   S> 230 User logged in]]></artwork>
            </figure>
          </t>
          <t>The HOST command can be used in combination with the ACCT command
to differentiate between a user's various accounts on a specific virtual host.
In this scenario, the user-PI sends a HOST command, which the server-PI uses to
route activity to the correct virtual host; the user-PI sends credentials using
the USER and PASS commands, which the server-PI validates; then, the user-PI
sends an ACCT command to specify any additional account information for the
server-PI implementation.  The following example illustrates a sequential
series of client commands that specify both a HOST and ACCT, with the server
responses omitted for brevity:</t>

          <t>
            <figure title="" suppress-title="false" align="left" alt="" width="" height="">
              <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height=""><![CDATA[   C> HOST ftp.example.com
   C> USER foo
   C> PASS bar
   C> ACCT project1]]></artwork>
            </figure>
          </t>
          <t>This is also true when the HOST command is used with the AUTH and
ADAT commands that are discussed in <xref target="RFC2228"/> and <xref
target="RFC4217"/>.  In this scenario, the user-PI sends a HOST command, which
the server-PI uses to route activity to the correct virtual host; then, the
user-PI uses the AUTH and ADAT commands to negotiate the security mechanism and
relevant authentication token(s) with the server-PI; then, the user-PI sends
user credentials using the USER and PASS commands, which the server-PI
validates, after which the user-PI MAY send an ACCT command to specify any
additional account information for the server-PI implementation.  The following
example illustrates a sequential series of client commands that specify both
HOST and ACCT commands when used in conjunction with the security commands that
are discussed in <xref target="RFC2228"/> and <xref target="RFC4217"/>, with
the server responses omitted for brevity:</t>

          <t>
            <figure title="" suppress-title="false" align="left" alt="" width="" height="">
              <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height=""><![CDATA[   C> HOST ftp.example.com
   C> AUTH <mechanism-name>
   C> ADAT <base64data>
   C> USER foo
   C> PASS bar
   C> ACCT project1]]></artwork>
            </figure>
          </t>
          <t>An exception to the above scenario would be when a user-PI is
providing the hostname in the "server_name" extension of a Transport Layer
Security (TLS) extended client hello as discussed in <xref target="RFC6066"/>.
When the user-PI specifies the hostname in the "server_name" extension of a TLS
extended client hello, the server-PI MUST verify that the hostname in the HOST
command matches the value of the "server_name" extension.  The following
example illustrates a sequential series of client commands that specify the
HOST command when used in conjunction with the TLS extensions that are
discussed in <xref target="RFC6066"/>, with the server responses omitted for
brevity:</t>

          <t>
            <figure title="" suppress-title="false" align="left" alt="" width="" height="">
              <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height=""><![CDATA[   C> AUTH TLS
   C> HOST ftp.example.com
   C> USER foo
   C> PASS bar]]></artwork>
            </figure>
          </t>
          <t>Additional security information about using the HOST command with
the security extensions that are discussed in <xref target="RFC2228"/>,
<xref target="RFC4217"/>, and <xref target="RFC6066"/> is provided
in <xref target="Security"/> of this document.</t>
        </section>

        <section title="State Diagrams" toc="default">
          <t>The state diagrams in this section illustrate typical sequences
for command and reply interchange between the user-PI and server-PI.
These diagrams are modeled on the similar diagrams in
Section&nbsp;6 of <xref target="RFC0959"/>.</t>

          <t>In each diagram, the (B) "begin" state is assumed to occur after
the transport connection has opened or after a REIN command has succeeded.
Other commands (such as FEAT <xref target="RFC2389"/>) that require no
authentication may have intervened.</t>

          <t>Additionally, a three-digit reply indicates a precise server reply
code.  A single digit on a reply path indicates any server reply that begins
with that digit, except where a precise server reply code is defined on another
path.  For example, a single digit "5" will apply to "500", "501", "502", etc.,
when those reply codes are not expressly defined in the diagram.  For each
command, there are three possible outcomes: success (S), failure (F), or error
(E).  In the state diagrams below, we use the symbol "B" for "begin" and the
symbol "W" for "wait for reply".</t>

          <t>For each of these diagrams, without any state transitions being
shown, a REIN command will return the diagram from any wait state to the (B)
"begin" state.</t>

          <t>
            <figure title="Typical Login Sequence with HOST Command" anchor="fig1">
              <preamble>The state diagram in <xref target="fig1"/> shows a
typical sequence of flow of control when HOST is used with USER and PASS to log
in to a particular FTP virtual host.</preamble>

              <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height=""><![CDATA[
           +---+   HOST    +---+ 1,3,5
           | B |---------->| W |-----------------
           +---+           +---+                 |
                            | |                  |
                  2,500,502 | | 4,501,503,504    |
              --------------   -----------       |
             |                            |      V
             V                   1        |    +---+
           +---+   USER    +---+-------------->| E |
           |   |---------->| W | 2        |    +---+
           +---+           +---+-------   |      ^
                            | |        |  |      |
                          3 | | 4,5    |  |      |
              --------------   -----   |  |      |
             |                      |  |  |      |
             |                -------------------
             |              1|      |  |  |
             V               |      |   ------>+---+
           +---+   PASS    +---+ 2  |     |    | S |
           |   |---------->| W |-------------->+---+
           +---+           +---+    |     |
                             |      |     |
                             |4,5   |     |
                             |      |      --->+---+
                             |       --------->| F |
                              ---------------->+---+]]></artwork>
            </figure>
          </t>
          <t>
            <figure title="Login Sequence with HOST and ACCT Commands" anchor="fig2">
              <preamble>After a user has logged in, an additional account may
be required by the server and specified by the client by using the ACCT
command.  With this in mind, the state diagram in <xref target="fig2"/> shows a
typical sequence of flow of control when HOST is used with USER and PASS to log
in to an FTP virtual host and ACCT is used to specify an account.</preamble>

              <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height=""><![CDATA[
           +---+   HOST    +---+ 1,3,5
           | B |---------->| W |-----------------
           +---+           +---+                 |
                            | |                  |
                  2,500,502 | | 4,501,503,504    |
              --------------   -------------     |
             |                              |    |
             V                   1          |    V
           +---+   USER    +---+-------------->+---+
           |   |---------->| W | 2       ----->| E |
           +---+           +---+------  |  --->+---+
                            | |       | | | |
                          3 | | 4,5   | | | |
              --------------   -----  | | | |
             |                      | | | | |
             |                      | | | | |
             |                ----------  | |
             |              1|      | |   | |
             V               |      | |   | |
           +---+   PASS    +---+ 2  |  ------->+---+
           |   |---------->| W |-------------->| S |
           +---+           +---+   ----------->+---+
                            | |   | |     | |
                          3 | |4,5| |     | |
              --------------   --------   |  ----
             |                    | |  |  |      |
             |                    | |  |  |      |
             |                ------------       |
             |            1,3|    | |  |         |
             V               |   2| |  |         V
           +---+   ACCT    +---+--  |   ------>+---+
           |   |---------->| W | 4,5 --------->| F |
           +---+           +---+-------------->+---+]]></artwork>
            </figure>
          </t>
          <t>
            <figure title="Login Sequence with HOST and AUTH/ADAT Commands" anchor="fig3">
              <preamble>The state diagram in <xref target="fig3"/> shows a
typical sequence of flow of control when HOST is used with the AUTH and
ADAT commands that are discussed in <xref target="RFC2228"/>.  (NOTE: <xref
target="Security"/> provides additional information about using the HOST
command with TLS.)</preamble>

              <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height=""><![CDATA[
           +---+   HOST    +---+ 1,3,5
           | B |---------->| W |------------------ 
           +---+           +---+                  |
                            | |                   |
                  2,500,502 | | 4,501,503,504     |
              --------------   -------------      |
             |                              |     |
             V                              |     |
           +---+   AUTH    +---+ 4,5        |     |
           |   |---------->| W |----------->|     |
           +---+           +---+            |     |
                        334 | |             |     |
              --------------  |             |     |
             |            234 |             |     |
             |    ------------              |     |
             V   |               4,5        |     |
           +---+ | ADAT    +---+----------->|     |
           |   |---------->| W | 335        |     |
           +---+ |         +---+-----       |     |
             ^   |           |       |      |     |
             |   |           |       |      |     |
              -----------------------       |     |
                 |           |              |     |
             ----        235 |              |     |
            |  --------------               |     |
            | |                             |     V
            V V                  1          |   +---+
           +---+   USER    +---+--------------->| E |
           |   |---------->| W | 2          |   +---+
           +---+           +---+-------     |     ^
                            | |        |    |     |
                          3 | | 4,5    |    |     |
              --------------   ------  |    |     |
             |                       | |    |     |
             |                --------------------
             |              1|       | |    |
             V               |       |  ------->+---+
           +---+   PASS    +---+ 2   |      |   | S |
           |   |---------->| W |--------------->+---+
           +---+           +---+     |      |  
                             |       |      |
                             |4,5    |      |
                             |       |       -->+---+
                             |        --------->| F |
                              ----------------->+---+]]></artwork>
            </figure>
          </t>
          <t>
            <figure title="Login Sequence with HOST and AUTH/ADAT/ACCT Commands" anchor="fig4">
              <preamble>After a user has logged in with the security commands
that are discussed in <xref target="RFC2228"/>, an additional account may be
required by the server and specified by the client by using the ACCT command.
The state diagram in <xref target="fig4"/> shows a typical sequence of flow of
control when HOST is used with the AUTH and ADAT commands to log in to an FTP
virtual host and ACCT is used to specify an account.</preamble>

              <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height=""><![CDATA[
           +---+   HOST    +---+ 1,3,5
           | B |---------->| W |------------------ 
           +---+           +---+                  |
                            | |                   |
                  2,500,502 | | 4,501,503,504     |
             +--------------   --------------     |
             |                               |    |
             V                               |    |
           +---+   AUTH    +---+ 4,5         |    |
           |   |---------->| W |------------>|    |
           +---+           +---+             |    |
                        334 | |              |    |
              --------------  |              |    |
             |            234 |              |    |
             |    ------------               |    |
             V   |               4,5         |    |
           +---+ | ADAT    +---+------------>|    |
           |   |---------->| W | 335         |    |
           +---+ |         +---+-----        |    |
             ^   |           |       |       |    |
             |   |           |       |       |    |
              -----------------------        |    |
                 |           |               |    |
             ----         235|               |    |
            |  --------------                |    |
            | |                              |    |
            V V                  1           |    V
           +---+   USER    +---+--------------->+---+
           |   |---------->| W | 2        ----->| E |
           +---+           +---+-------  |  --->+---+
                            | |        | | | |
                          3 | | 4,5    | | | |
              --------------   ------  | | | |
             |                       | | | | |
             |                -----------  | |
             |              1|       | |   | |
             V               |       | |   | |
           +---+   PASS    +---+ 2   |  ------->+---+
           |   |---------->| W |--------------->| S |
           +---+           +---+   ------------>+---+
                            | |   |  |     | |
                          3 | |4,5|  |     | |
              --------------   ---------   |  ----
             |                    |  |  |  |      |
             |                -------------       |
             |            1,3|    |  |  |         |
             V               |   2|  |  |         V
           +---+   ACCT    +---+--   |   ------>+---+
           |   |---------->| W | 4,5  --------->| F |
           +---+           +---+--------------->+---+]]></artwork>
            </figure>
          </t>

        </section>
      </section>
      <section title="HOST Command Errors" toc="default">
        <t>The server-PI SHOULD return a 500 or 502 reply if the HOST command
is unrecognized or unimplemented, as specified in <xref target="RFC0959"/>.
For example, a server-PI that predates or otherwise does not conform to
this specification would be expected to return a 500 or 502 reply.</t>

        <t>As discussed in <xref target="hostcommand"/> of this document, if a
HOST command is sent after a user has been authenticated, the server MUST treat
the situation as an invalid sequence of commands and return a 503 reply.</t>

        <t>A 501 reply SHOULD be sent if the hostname given is syntactically
invalid, and a 504 reply SHOULD be sent if a syntactically valid hostname is
not a valid virtual hostname for the server.  In all such cases, the
server-FTP process MUST do one of the following:</t>

        <t>
          <list style="letters">
            <t>Ignore the HOST command and act as if a HOST command had not
been sent.  A user-FTP process MAY then send a subsequent HOST command with a
different hostname.</t>

            <t>Close the connection.</t>
          </list>
        </t>
        <t>A user-PI receiving a 500 or 502 reply to a HOST command SHOULD
assume that the server-PI does not implement virtual servers by using the HOST
command.  The user-PI MAY then proceed to log in as if the HOST command had not
been sent.</t>

        <t>A user-PI receiving an error reply that is different from the errors
that have been described here SHOULD assume that the virtual HOST is
unavailable and terminate communications.</t>

        <t>A server-PI that receives a USER command to begin the authentication
sequence without having received a HOST command SHOULD NOT reject the USER
command.  Clients that conform to earlier FTP specifications do not send HOST
commands.  In this case, the server MAY act as if some default virtual host had
been explicitly selected, or the server MAY enter an environment that is
different from that of any supported virtual hosts, perhaps one in which a
union of all available accounts exists and that presents an NVFS that
appears to contain subdirectories that contain the NVFS for all supported
virtual hosts.</t>

      </section>

      <section title="FEAT Response for HOST Command" toc="default">
        <t>When replying to the FEAT command <xref target="RFC2389"/>, a
server-FTP process that supports the HOST command MUST include a line
containing the single word "HOST".  This word is case insensitive, but it
SHOULD be sent in upper case so as to maximize interoperability with disparate
implementations.  That is, the response SHOULD be:</t>

        <t>
          <figure title="" suppress-title="false" align="left" alt="" width="" height="">
            <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height=""><![CDATA[   C> FEAT
   S> 211- <any descriptive text>
   S>  ...
   S>  HOST
   S>  ...
   S> 211 End]]></artwork>
          </figure>
        </t>
        <t>The ellipses indicate placeholders where other features may be
included but are not required.  The one-space indentation of the feature lines
is mandatory <xref target="RFC2389"/>.</t>

      </section>
    </section>
    <section anchor="Security" title="Security Considerations" toc="default">
      <t>As discussed in <xref target="hostcommand"/> of this document, a
server implementation MUST treat an additional HOST command that was sent
before a user has been authenticated as though a previous HOST command was not
sent.  In this situation, the server implementation MUST reset the
authentication environment, as that would allow for segregation between the
security environments for each virtual host on an FTP server.  The
implementation details for security environments may vary greatly based on the
requirements of each server implementation and operating system, and those
details are outside the scope of the protocol itself.  For example, a virtual
host "foo.example.com" on an FTP server might use a specific username and
password list, while the virtual host "bar.example.com" on the same FTP server
might use a different username and password list.  In such a scenario,
resetting the security environment is necessary for the virtual servers to
appear to behave independently from a client perspective, while the actual
server implementation details are irrelevant at the protocol level.</t>

      <t>Section 15.1.1 of <xref target="RFC4217"/> discusses the use
of X.509 certificates for server authentication.  Taking the information from
that document into account, when securing FTP sessions with the security
mechanisms that are defined in <xref target="RFC4217"/>, client implementations
SHOULD verify that the hostname that they specify in the parameter for the
HOST command matches the identity that is specified in the server's X.509
certificate in order to prevent man-in-the-middle attacks.</t>

      <t>When the HOST command is used in combination with the FTP security
extensions that were introduced in <xref target="RFC2228"></xref>
and <xref target="RFC4217"/>, the HOST command SHOULD precede the security
handshake when the user-PI is not providing the "server_name" in the extended
client hello as defined in <xref target="RFC6066"/>. This allows both user-FTP
and server-FTP processes to map an FTP HOST with the correct server name in the
server's certificate.  If the HOST command is sent after the security
handshake, then mapping an FTP HOST to the correct security certificate will
not take place before the secure session is established.</t>

      <t>For example, if a server-FTP process has multiple virtual hosts
defined and no hostname has been sent from a user-FTP process, the server-FTP
process will be unable to route the connection to the correct virtual host when
the connection is established.  In this situation, the server-FTP process will
be forced to choose a virtual host that will respond.  When the user-PI
attempts to negotiate a secure connection, the virtual host to which the
connection was routed will respond with its server certificate during the
security handshake.  If the virtual host that was chosen by the server-FTP
process does not match the virtual host to which the user-FTP process had
intended to connect, the user-PI will be unable to verify the server's identity
as presented in the server certificate message.</t>

      <t>However, if the user-PI is providing the "server_name" in the extended
client hello as defined in Section&nbsp;3 of <xref target="RFC6066"/>, the
user-PI MAY provide the HOST command after the security handshake because the
server will be able to route the connection to the correct virtual host based
on the contents of the "server_name" extension and the client will be able to
verify the server's identity as presented in the corresponding server
certificate message.  However, the server-PI MUST verify that the name in the
HOST command matches the "server_name" that is provided in the extended client
hello.</t>

      <t>In general, client implementations SHOULD protect user credentials by
using the FTP security extensions that were introduced
in <xref target="RFC2228"/> and <xref target="RFC4217"/>; a detailed discussion
for securing FTP sessions can be found in those documents, and a general
discussion of security issues related to FTP can be found in <xref
target="RFC2577"/>.</t>

    </section>
    <section anchor="IANA" title="IANA Considerations" toc="default">
      <t>IANA has registered the following FTP extension according to
the procedure established by <xref target="RFC5797"></xref>:</t>

      <texttable title="" suppress-title="false" align="center" style="full">
        <ttcol align="left">cmd</ttcol>
        <ttcol align="left">FEAT
Code</ttcol>
        <ttcol align="left">description</ttcol>
        <ttcol align="left">type</ttcol>
        <ttcol align="left">conf</ttcol>
        <ttcol align="left">RFC#s/References
and Notes</ttcol>
        <c>HOST</c>
        <c>HOST</c>
        <c>Hostname</c>
        <c>a</c>
        <c>o</c>
        <c>RFC 7151</c>

      </texttable>
    </section>
  </middle>
  <back>

    <references title="Normative References">

<reference anchor='RFC0959'>
<front>
<title abbrev='File Transfer Protocol'>File Transfer Protocol (FTP)</title>
<author initials='J.' surname='Postel' fullname='J. Postel'>
<organization>Information Sciences Institute (ISI)</organization></author>
<author initials='J.' surname='Reynolds' fullname='J. Reynolds'>
<organization /></author>
<date year='1985' day='1' month='October' /></front>
<seriesInfo name='STD' value='9' />
<seriesInfo name='RFC' value='959' />
</reference>

<reference anchor='RFC1034'>
<front>
<title abbrev='Domain Concepts and Facilities'>Domain Names - Concepts and Facilities</title>
<author initials='P.' surname='Mockapetris' fullname='P. Mockapetris'>
<organization>Information Sciences Institute (ISI)</organization></author>
<date year='1987' day='1' month='November' /></front>
<seriesInfo name='STD' value='13' />
<seriesInfo name='RFC' value='1034' />
</reference>

<reference anchor='RFC1035'>
<front>
<title abbrev='Domain Implementation and Specification'>Domain Names - Implementation and Specification</title>
<author initials='P.' surname='Mockapetris' fullname='P. Mockapetris'>
<organization>USC/ISI</organization></author>
<date year='1987' day='1' month='November' /></front>
<seriesInfo name='STD' value='13' />
<seriesInfo name='RFC' value='1035' />
</reference>

<reference anchor='RFC1123'>
<front>
<title>Requirements for Internet Hosts - Application and Support</title>
<author initials='R.' surname='Braden' fullname='Robert Braden'>
<organization>University of Southern California (USC), Information Sciences Institute</organization></author>
<date year='1989' month='October' /></front>
<seriesInfo name='STD' value='3' />
<seriesInfo name='RFC' value='1123' />
</reference>

<?rfc include="reference.RFC.2119" ?>

<reference anchor='RFC2228'>
<front>
<title>FTP Security Extensions</title>
<author initials='M.' surname='Horowitz' fullname='Marc Horowitz'>
<organization>Cygnus Solutions</organization></author>
<author initials='S.' surname='Lunt' fullname='S. Lunt'/>
<date year='1997' month='October' />
</front>
<seriesInfo name='RFC' value='2228' />
</reference>

<?rfc include="reference.RFC.2389" ?>
<?rfc include="reference.RFC.2640" ?>
<?rfc include="reference.RFC.3986" ?>
<?rfc include="reference.RFC.4217" ?>
<?rfc include="reference.RFC.5234" ?>
<?rfc include="reference.RFC.5890" ?>
<?rfc include="reference.RFC.6066" ?>
    </references>

    <references title="Informative References">
<?rfc include="reference.RFC.1945" ?>
<?rfc include="reference.RFC.2577" ?>
<?rfc include="reference.RFC.2616" ?>
<?rfc include="reference.RFC.3875" ?>
<?rfc include="reference.RFC.5797" ?>
    </references>

    <section title="Unworkable Alternatives" toc="default">
      <t>Due to the level of scope for adding a new command to FTP, a brief
discussion of suggested alternatives to a HOST command and their respective
limitations is warranted.  The suggested alternatives that are discussed in
this appendix have been proposed in the past, but each of these ideas was
deemed insufficient for the reasons listed within each section of this
appendix.</t>

      <section title="Overloading the CWD Command" toc="default">
        <t>One suggested method to emulate a form of virtual hosts would be for
the client to simply send a CWD command after connecting, using the virtual
hostname as the argument to the CWD command.  This would allow the server-FTP
process to implement the file stores of the virtual hosts as subdirectories in
its NVFS.  This suggestion is simple in concept, and most server-FTP
implementations support this without requiring any code changes.  While this
method is simple to describe and implement, it suffers from several
drawbacks:</t>

        <t>
          <list style="letters">
            <t>The CWD command is available only after the user-PI has
authenticated itself to the server-FTP process.  Thus, all virtual hosts would
be required to share a common authentication scheme if they used this
method.</t>

            <t>To make the virtual host truly transparent, either the
server-FTP process needs to be modified to include information that shows the
special nature of this first CWD command (negating most of the advantage of
this scheme), or all users must see the same identical NVFS view upon
connecting (they must connect in the same initial directory), or the NVFS must
implement the full set of virtual host directories at each possible initial
directory for any possible user.</t>

            <t>Unless the server is specially modified, a user connecting this
way to a virtual host would be able to easily move to any other virtual host
supported at the same server-FTP process, exposing the nature of the virtual
host.</t>

          </list>
        </t>
      </section>
      <section title="Overloading the ACCT Command" toc="default">
        <t>Another suggested method would be to simply overload the ACCT
command for FTP virtual hosts, but this proposal is unacceptable for several
reasons with regard to when the ACCT command is sent during the request flow.
Sections&nbsp;5.4 and 6 of <xref target="RFC0959"/> document the request flow
for a login sequence as USER -&gt; PASS -&gt; ACCT.  This flow of commands may
be acceptable when you are considering a single user having multiple accounts
on an FTP server, but it fails to differentiate between virtual hosts when you
consider the following two issues:</t>

        <t>
          <list style="letters">
            <t>The first problem with overloading the ACCT command is
certificate negotiation when using the FTP security extensions that are
documented in <xref target="RFC2228"/> and <xref target="RFC4217"/>.  In order
to safeguard user credentials, negotiation of the security mechanism and
certificate must occur before login credentials are sent by the client.  The
problem with using the ACCT command in this scenario is that there is no way of
ensuring that the certificate matches the correct virtual host before the user
credentials are sent.</t>

            <t>The second problem with overloading the ACCT command is how user
credentials are implemented for FTP virtual hosts.  FTP server implementations
may allow the use of custom user credentials on a per-virtual-host basis.  For
example, in one particular implementation the virtual host negotiation occurs,
and then the user credentials are looked up using the account mechanism that is
specific to that virtual host.  So once again the virtual host negotiation must
take place before the user credentials are sent.</t>

          </list>
        </t>
      </section>
      <section title="Overloading the USER Command" toc="default">
        <t>An additional suggestion would be to overload well-known syntax
through the existing USER command, as illustrated in the following example:</t>
        <t>
          <figure title="" suppress-title="false" align="left" alt="" width="" height="">
            <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height=""><![CDATA[   C> USER foo@example.com
   S> 331 Password required
   C> PASS bar
   S> 230 User logged in]]></artwork>
          </figure>
        </t>
        <t>In this example, the user "foo" might be attempting to log on to the
virtual host "example.com" on an FTP server.  This suggestion may seem
plausible at first, but it introduces several implementation problems.  For
example:</t>

        <t>
          <list style="letters">
            <t>Some network environments already use the "username@hostname"
syntax for network credentials, where the "hostname" portion refers to the
location of the user's credentials within the network hierarchy.  Using the
"foo@example.com" syntax, it becomes difficult to differentiate between the
user "foo" logging into a virtual host that is named "example.com" on an FTP server
versus the user "foo@example.com" logging into an FTP server with no specified
virtual host.</t>

            <t>When using the FTP security extensions that are documented in
<xref target="RFC2228"/> and <xref target="RFC4217"/>, negotiation of the
security mechanism and certificate must occur before login credentials are sent
by the client.  More specifically, the AUTH/ADAT commands must be sent before
the USER command in order to safeguard user credentials.  If you overload the
USER command, there is no way of ensuring that the certificate matches the
correct virtual host before the user credentials are sent by the client.</t>

          </list>
        </t>
      </section>
      <section title="Conclusion" toc="default">
        <t>After examining the above alternatives, and in order to obtain an
adequate emulation of "real" FTP servers, it was concluded that supporting
virtual hosts will require both client and server modifications.  Therefore, a
new FTP command seems the most likely solution to provide the required level of
support.</t>

      </section>
    </section>
    <section anchor="Acknowledgements" title="Acknowledgements" toc="default">
      <t>Robert Elz and Paul Hethmon provided a detailed discussion of the HOST
command in their Internet&nbhy;Draft titled "Extensions to FTP" as part of
their work with the FTPEXT Working Group of the IETF.  Their work formed the
basis for much of this document, and their help has been greatly appreciated.
They would also like to credit Bernhard Rosenkraenzer for having first
suggested and described the HOST command.</t>

      <t>Several people have provided a wealth of constructive feedback about
earlier versions of this document that has helped to shape its development;
many of their suggestions have been incorporated, and their contributions are
gratefully acknowledged.  There are far too many to mention here, but the
authors of this document would like to specifically thank Alexey Melnikov,
Alfred Hoenes, John Klensin, Joe Touch, Paul Ford-Hutchinson, Daniel Stenberg,
Mykyta Yevstifeyev, Alec Rowell, Jaroslav Dunajsky, Wade Hilmo, Anthony Bryan,
and Barry Leiba for their assistance.</t>

    </section>
  </back>
</rfc>
