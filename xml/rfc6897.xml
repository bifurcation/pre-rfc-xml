<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC0793 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0793">
  <!ENTITY RFC1122 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1122">
  <!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119">
  <!ENTITY RFC3542 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3542">
  <!ENTITY RFC4584 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4584">
  <!ENTITY MPTCPARCH SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6182">
  <!ENTITY MPTCPSEC SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6181">
  <!ENTITY MPTCPCC SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6356">
  <!ENTITY SHIMAPI SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6316">
  <!ENTITY HIPAPI SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6317">
  <!ENTITY SCTPAPI SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6458">
  <!ENTITY MIFPRACTICE SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6419">
  <!ENTITY MIFPROBLEM SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6418">
  <!ENTITY EYEBALLS SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6555">
  <!ENTITY RFC5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246">
  <!ENTITY RFC5280 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280">
  <!ENTITY RFC6125 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6125">
  <!ENTITY MPTCP SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6824">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc symrefs="no"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc rfcedstyle="yes"?>

<rfc category="info" number="6897" ipr="trust200902" submissionType="IETF"
consensus="yes">

  <front>
    <title abbrev="MPTCP API">Multipath TCP (MPTCP) Application Interface Considerations</title>

    <author fullname="Michael Scharf" initials="M." surname="Scharf">
      <organization>Alcatel-Lucent Bell Labs</organization>

      <address>
        <postal>
          <street>Lorenzstrasse 10</street>

          <city>70435 Stuttgart</city>

          <country>Germany</country>
        </postal>

        <email>michael.scharf@alcatel-lucent.com</email>
      </address>
    </author>

    <author fullname="Alan Ford" initials="A." surname="Ford">
      <organization>Cisco</organization>

      <address>
        <postal>
          <street>Ruscombe Business Park</street>
          <city>Ruscombe</city>
          <region>Berkshire</region>
          <code>RG10 9NN</code>
          <country>UK</country>
        </postal>

        <email>alanford@cisco.com</email>
      </address>
    </author>

    <date month="March" year="2013"/>

    <area>Transport Area</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <keyword>multipath tcp api jitter qos delay bandwidth sockets</keyword>

    <abstract>
      <t>Multipath TCP (MPTCP) adds the capability of using multiple
      paths to a regular TCP session. Even though it is designed to be
      totally backward compatible to applications, the data transport
      differs compared to regular TCP, and there are several
      additional degrees of freedom that applications may wish to
      exploit. This document summarizes the impact that MPTCP may have
      on applications, such as changes in performance.  Furthermore,
      it discusses compatibility issues of MPTCP in combination with
      non-MPTCP-aware applications. Finally, the document describes a
      basic application interface that is a simple extension of TCP's
      interface for MPTCP-aware applications.</t>
    </abstract>

  </front>

  <middle>

    <section title="Introduction">

      <t>Multipath TCP adds the capability of using multiple paths to
      a regular TCP session <xref target="RFC0793"/>. The motivations
      for this extension include increasing throughput, overall
      resource utilization, and resilience to network failure, and
      these motivations are discussed, along with high-level design
      decisions, as part of the multipath TCP architecture
      <xref target="RFC6182"/>. MPTCP <xref target="RFC6824"/> offers the same
      reliable, in-order, byte-stream transport as TCP and is
      designed to be backward compatible with both applications and
      the network layer. It requires support inside the network stack
      of both endpoints.</t>

      <t>This document first presents the effects that MPTCP may have
      on applications, such as performance changes compared to regular
      TCP. Second, it defines the interoperation of MPTCP and
      applications that are unaware of the multipath transport. MPTCP
      is designed to be usable without any application changes, but
      some compatibility issues have to be taken into account. Third,
      this memo specifies a basic Application Programming Interface
      (API) for MPTCP-aware applications. The API presented here is an
      extension to the regular TCP API to allow an MPTCP-aware
      application the equivalent level of control and access to
      information of an MPTCP connection that would be possible with
      the standard TCP API on a regular TCP connection.</t>

      <t>The de facto standard API for TCP/IP applications is the
      "sockets" interface <xref target="POSIX"/>. This document provides an
      abstract definition of MPTCP-specific extensions to this interface.
      These are operations that can be used by an application to get or set
      additional MPTCP-specific information on a socket, in order to
      provide an equivalent level of information and control over
      MPTCP as exists for an application using regular TCP.  It is up
      to the applications, high-level programming languages, or
      libraries to decide whether to use these optional
      extensions. For instance, an application may want to turn on or
      off the MPTCP mechanism for certain data transfers or limit its
      use to certain interfaces. The abstract specification is in line
      with the Portable Operating System Interface (POSIX)
      standard <xref target="POSIX"/> as much as possible.</t>

      <t>An advanced API for MPTCP is outside the scope of this
      document. Such an advanced API could offer a more fine-grained
      control over multipath transport functions and policies. The
      appendix includes a brief, non-compulsory list of potential
      features of such an advanced API.</t>

      <t>There can be interactions or incompatibilities of MPTCP with
      other APIs or sockets interface extensions, which are discussed
      later in this document. Some network stack implementations,
      especially on mobile devices, have centralized connection managers or other
      higher-level APIs to solve multi-interface issues, as surveyed
      in <xref target="RFC6419"/>. Their interaction with MPTCP is
      outside the scope of this document.</t>

      <t>The target readers of this document are application
      developers whose software may benefit
      significantly from MPTCP. This document also provides the
      necessary information for developers of MPTCP to implement the
      API in a TCP/IP network stack.</t>

    </section>

    <section title="Terminology">
       
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described
      in <xref target="RFC2119"/>.</t>

      <t>This document uses the MPTCP terminology introduced in
      <xref target="RFC6824"/>.</t>

      <t>Concerning the API towards applications, the following terms 
      are distinguished:</t>

      <t><list style="symbols">

        <t>Legacy API: The interface towards TCP that is currently
        used by applications.  This document explains the effect of
        MPTCP for such applications, as well as resulting issues.</t>

        <t>Basic API: A simple extension of TCP's interface for
        applications that are aware of MPTCP. This document abstractly
        describes this interface, which provides access to multipath
        address information and a level of control equivalent to
        regular TCP.</t>

        <t>Advanced API: An API that offers more fine-grained
        control over the behavior of MPTCP. Its specification 
        is outside the scope of this document.</t>

      </list></t>

    </section>

    <section title="Comparison of MPTCP and Regular TCP">
    
      <t>This section discusses the effect of MPTCP on performance as seen
      by an application, in comparison to what may be expected from
      the use of regular TCP.</t>

      <section title="Effect on Performance">

        <t>One of the key goals of adding multipath capability to TCP
        is to improve the performance of a transport connection by
        load distribution over separate subflows across potentially
        disjoint paths. Furthermore, it is an explicit goal of MPTCP
        that it provides a connection that performs at least as well
        as one using single-path TCP. A
        corresponding congestion control algorithm is described in
        <xref target="RFC6356"/>. The following sections summarize the
        performance effect of MPTCP as seen by an application.</t>
        
        <section title="Throughput">

          <t>The most obvious performance improvement that can be
          expected from the use of MPTCP is an increase in throughput,
          since MPTCP will pool more than one path (where available)
          between two endpoints. This will usually provide as great or
          greater bandwidth for an application, even though exceptions
          may exist, e.g., due to differences in the congestion
          control dynamics. For instance, if a new subflow is started,
          the short-term throughput can be smaller than the
          theoretical optimum.  If there are shared bottlenecks
          between the flows, then the congestion control algorithms
          will in most cases ensure that load is evenly spread amongst
          regular and multipath TCP sessions, so that no end user
          receives worse performance than if all were using
          single-path TCP. There are some known corner cases in which
          an upgrade to MPTCP can affect other users <xref
          target="MPTCPISSUES"/>.</t>

          <t>This performance increase additionally means that an
          MPTCP session could achieve throughput that is greater than
          the capacity of a single interface on the device. If any
          applications make assumptions about interfaces due to
          throughput, they must take this into account (although an
          MPTCP implementation must always respect an application's
          request for a particular interface).</t>

          <t>Furthermore, the flexibility of MPTCP to add and remove
          subflows as paths change availability could lead to a
          greater variation, and more frequent change, in connection
          bandwidth. Applications that adapt to available bandwidth
          (such as video and audio streaming) may need to adjust some
          of their assumptions to most effectively take this into
          account.</t>

          <t>The transport of MPTCP signaling information results in
          a small overhead. The use of MPTCP instead of a single TCP
          connection therefore results in a smaller goodput.  Also, if
          multiple subflows share a same bottleneck, this overhead
          slightly reduces the capacity that is available for data
          transport. Yet, this potential reduction of throughput will
          be negligible in many usage scenarios, and the protocol
          contains optimizations in its design so that this overhead
          is minimal.</t>

        </section>

        <section title="Delay">

          <t>The benefits of MPTCP regarding throughput and resilience
          may come at some cost regarding data delivery delay and delay
          jitter.</t>

          <t>If the delays on the constituent subflows of an MPTCP
          connection differ, the jitter perceivable to an application
          may appear higher as the data are spread across the
          subflows. Although MPTCP will ensure in-order delivery to
          the application, the data delivery could be more bursty
          than may be usual with single-path TCP, in particular
          on highly asymmetric paths.</t>
          
          <t>Applications with high real-time requirements might be
          affected by such a scenario. One possible remedy is to disable MPTCP
          for such jitter-sensitive applications, either by using the basic
          API defined in this document, or by other means, such
          as system policies.</t>
          
          <t>However, the actual delay and jitter of data transport over MPTCP
          depend on the scheduling and congestion control algorithms
          used for sending data, as well as the heuristics to establish
          and shut down subflows. A sender can implement strategies
          to minimize the delay jitter seen by applications, but
          this requires an accurate estimation of the path
          characteristics. If the scheduling decisions are suboptimal
          or if assumptions about the path characteristics turn out to be wrong,
          delay jitter may be increased and affect delay-sensitive
          applications. In general, for a delay-sensitive application, it
          would be desirable to select an appropriate congestion control
          algorithm for its traffic needs.</t>

          <t>Alternatively, MPTCP could be used in high-reliability, rather 
          than high-throughput, modes of operation, such as by mirroring 
          traffic on subflows, or by only using additional subflows for hot
          standby. These methods of traffic scheduling would not cause delay
          variation in the same way. These additional modes, and the selection 
          of alternative scheduling algorithms, would need to be indicated
          by an advanced API, the specification of which requires further
          analysis and is outside the scope of this document.</t>
          
          <t>If data transport on one subflow fails,
          the retransmissions inside MPTCP could affect the delivery
          delay to the application. Yet, without MPTCP that data or
          the whole connection might have been lost, and
          other reliability mechanisms (e.g., application-level recovery)
          would likely have an even larger delay impact.</t>
          
          <t>In addition, applications that make round-trip time (RTT)
          estimates at the application level may have some
          issues. Whilst the average delay calculated will be
          accurate, whether this is useful for an application will
          depend on what it requires this information for. If a new
          application wishes to derive such information, it should
          consider how multiple subflows may affect its measurements
          and thus how it may wish to respond. In such a case, an 
          application may wish to express its scheduling preferences,
          as described later in this document.</t>
          
        </section>

        <section title="Resilience">

          <t>Another performance improvement through the use of MPTCP is
          better resilience. 
          The use of multiple subflows simultaneously means that
          if one should fail, all traffic will move to the remaining
          subflow(s), and additionally any lost packets can be
          retransmitted on these subflows.</t>

          <t>As one special case, MPTCP can be used
          with only one active subflow at a given point in time.
          In that case, resilience compared to single-path TCP is
          improved. MPTCP also supports make-before-break
          and break-before-make handovers between
          subflows. In both cases, the MPTCP connection can
          survive an unavailability or change of an IP address
          (e.g., due to shutdown of an interface or handover).
          MPTCP closes or resets the MPTCP connection separately
          from the individual subflows, as described in
          <xref target="RFC6824"/>.</t>

          <t>Subflow failure may be caused by issues within the
          network, which an application would be unaware of, or
          interface failure on the node. An application may, under
          certain circumstances, be in a position to be aware of such
          failure (e.g., by radio signal strength, or simply an interface
          enabled flag), and so must not make assumptions of an MPTCP 
          flow's stability based on this. An MPTCP implementation must never override an
          application's request for a given interface, however, so the
          cases where this issue may be applicable are limited.</t>

        </section>

      </section>

      <section title="Potential Problems">

        <section title="Impact of Middleboxes">

          <t>MPTCP has been designed to pass through the
          majority of middleboxes. Empirical evidence suggests that
          new TCP options can successfully be used on most paths in
          the Internet <xref target="Honda2011"/>. Nevertheless, some
          middleboxes may still refuse to pass MPTCP messages due to
          the presence of TCP options, or they may strip TCP
          options. If this is the case, MPTCP falls back to regular
          TCP. Although this will not create a problem for the
          application (its communication will be set up either way),
          there may be additional (and indeed, user-perceivable) delay
          while the first handshake fails.  Therefore, an alternative
          approach could be to try both MPTCP and regular TCP
          connection attempts at the same time and respond to
          whichever replies first, in a fashion similar to the "Happy
          Eyeballs" mechanism for IPv6 <xref target="RFC6555"/>.  One
          could also apply a shorter timeout on the MPTCP attempt and
          thus reduce the setup delay if fallback to regular TCP is
          needed.</t>

          <t>An MPTCP implementation can learn the rate of MPTCP
          connection attempt successes or failures to particular hosts 
          or networks, and on particular interfaces, and could therefore
          learn heuristics of when and when not to use MPTCP.
          A detailed discussion of the various fallback mechanisms,
          for failures occurring at different points in the connection,
          is presented in <xref target="RFC6824"/>.
          It must be emphasized that all such heuristics could also
          fail, and learning can be difficult in certain environments,
          e.g., if the host is mobile.</t>

          <t>There may also be middleboxes that transparently change
          the length of content. If such middleboxes are present,
          MPTCP's reassembly of the byte stream in the receiver is
          difficult.  Still, MPTCP can detect such middleboxes and
          then fall back to regular TCP. An overview of the impact of
          middleboxes is presented in <xref target="RFC6182"/>, and
          MPTCP's mechanisms to work around these issues are presented and
          discussed in <xref target="RFC6824"/>.</t>

          <t>MPTCP can also have other unexpected implications. For
          instance, intrusion detection systems could be
          triggered. A full analysis of MPTCP's impact on such
          middleboxes is for further study after deployment
          experiments.</t>

        </section>

        <section title="Dealing with Multiple Addresses inside Applications">

          <t>In regular TCP, there is a one-to-one mapping of the 
          sockets interface to a flow through a network. Since MPTCP can
          make use of multiple subflows, applications cannot implicitly 
          rely on this one-to-one mapping any more.</t>
          
          <t>Whilst this doesn't matter for most applications, some
          applications may need to adapt to the presence of multiple addresses,
          because implicit assumptions are outdated. In this section, selected
          examples for resulting issues are discussed. The question of whether
          such implicit assumptions matter is an application-level decision,
          and this document only provides general guidance and a basic
          API to retrieve relevant information.</t>
          
          <t>A few applications require the transport to be along a
          single path; they can disable the use of MPTCP as 
          described later in this document. Examples include 
          monitoring tools that want to measure the available 
          bandwidth on a path, or routing protocols such as BGP
          that require the use of a specific link.</t>

          <t>Certain applications store the IP addresses of TCP
          connections, e.g., by logging mechanisms. Such logging
          mechanisms will continue to work with MPTCP, but two
          important aspects have to be mentioned: First, if the
          application is not aware of MPTCP, it will use the existing
          interface to the network stack. This implies that an
          MPTCP-unaware application will track the IP addresses of the
          first subflow only. IP addresses used by follow-up subflows
          will be ignored. Second, an MPTCP-aware application can use
          the basic API described in this document to monitor the IP
          addresses of all subflows, e.g., for logging mechanisms. If
          an MPTCP connection uses several subflows, this will
          possibly imply that data structures have to be adapted and
          that the amount of data that has to be logged and stored per
          connection will increase.</t>

          <t>An MPTCP implementation may choose to maintain an MPTCP
          connection even if the IP address of the original subflow is
          no longer allocated to a host, depending on the policy
          concerning the first subflow (fate-sharing; see <xref
          target="sec_query_addr"/>).  In this case, the IP address
          exposed to an MPTCP-unaware application can differ from the
          addresses actually being used by MPTCP. It is even possible
          that the IP address gets assigned to another host during the
          lifetime of an MPTCP connection. As further discussed below,
          this could be an issue if the IP addresses are exchanged by
          applications, e.g., inside the application protocol. This
          issue can be addressed by enabling fate-sharing, at the cost
          of resilience, because the MPTCP connection then cannot
          close the initial subflow.</t>

        </section>

        <section title="Security Implications" anchor="sec_security_implications">

         <t>The support for multiple IP addresses within one MPTCP
         connection can result in additional security vulnerabilities,
         such as possibilities for attackers to hijack
         connections. The protocol design of MPTCP minimizes this
         risk.  An attacker on one of the paths can cause harm, but
         this is hardly an additional security risk compared to
         single-path TCP, which is vulnerable to man-in-the-middle
         attacks as well. A detailed threat analysis of MPTCP is
         published in <xref target="RFC6181"/>.</t>

         <t>Impact on Transport Layer Security (TLS) is discussed in <xref target="sec_tls"/>.</t>

        </section>

      </section>

    </section>

    <section title="Operation of MPTCP with Legacy Applications">

      <section title="Overview of the MPTCP Network Stack">

        <t>MPTCP is an extension of TCP, but it is designed to be
        backward compatible for legacy (MPTCP-unaware) applications. 
        TCP interacts with other parts of the network stack via different
        interfaces. The de facto standard API between TCP and
        applications is the sockets interface. The position of MPTCP
        in the protocol stack is illustrated in 
        <xref target="fig_stack"/>.</t>

        <figure title="MPTCP Protocol Stack" anchor="fig_stack" align="center">
          <artwork align="center"><![CDATA[
    +-------------------------------+
    |           Application         |
    +-------------------------------+
           ^                  |
 ~~~~~~~~~~|~Sockets Interface|~~~~~~~~~
           |                  v
    +-------------------------------+
    |             MPTCP             |
    + - - - - - - - + - - - - - - - +
    | Subflow (TCP) | Subflow (TCP) |
    +-------------------------------+
    |       IP      |      IP       |
    +-------------------------------+
          ]]></artwork>
        </figure>

        <t>In general, MPTCP can affect all interfaces that make 
        assumptions about the coupling of a TCP connection to a single 
        IP address and TCP port pair, to one socket endpoint, to one 
        network interface, or to a given path through the network.</t>

        <t>This means that there are two classes of applications:

          <list style="symbols">
            <t>Legacy applications: These applications are unaware of
            MPTCP and use the existing API towards TCP without any 
            changes. This is the default case.</t>
            <t>MPTCP-aware applications: These applications indicate
            support for an enhanced MPTCP interface. This document
            specifies a minimum set of API extensions for such
            applications.</t>
          </list>

        In the following sections, it is discussed to what extent MPTCP
        affects legacy applications using the existing sockets
        API. The existing sockets API implies that applications deal
        with data structures that store, amongst others, the IP
        addresses and TCP port numbers of a TCP connection. A design
        objective of MPTCP is that legacy applications can continue to
        use the established sockets API without any changes. However,
        in MPTCP there is a one-to-many mapping between the socket
        endpoint and the subflows. This has several subtle
        implications for legacy applications using sockets API
        functions.</t>

      </section>

      <section title="Address Issues">

        <section title="Specification of Addresses by Applications"
        anchor="sec_spec_addr">

          <t>During binding, an application can either select a
          specific address or bind to INADDR_ANY. Furthermore, on
          some systems other socket options (e.g., SO_BINDTODEVICE)
          can be used to bind to a specific interface. If an
          application uses a specific address or binds to a specific
          interface, then MPTCP MUST respect this and not interfere in
          the application's choices. The binding to a specific address
          or interface implies that the application is not aware of
          MPTCP and will disable the use of MPTCP on this connection.
          An application that wishes to bind to a specific set of
          addresses with MPTCP must use multipath-aware calls to
          achieve this (as described in
          <xref target="sec_mptcp_bind"/>).</t>
          
          <t>If an application binds to INADDR_ANY, it is assumed that
          the application does not care which addresses are used
          locally. In this case, a local policy MAY allow MPTCP to
          automatically set up multiple subflows on such a
          connection.</t>

          <t>The basic sockets API of MPTCP-aware applications allows
          the expression of further preferences in an MPTCP-compatible way
          (e.g., binding to a subset of interfaces only).</t>

        </section>

        <section title="Querying of Addresses by Applications"
        anchor="sec_query_addr">

          <t>Applications can use the getpeername() or getsockname()
          functions in order to retrieve the IP address of the peer or
          of the local socket. These functions can be used for various
          purposes, including security mechanisms, geo-location, or
          interface checks. The sockets API was designed with an
          assumption that a socket is using just one address, and
          since this address is visible to the application, the
          application may assume that the information provided by the
          functions is the same during the lifetime of a
          connection. However, in MPTCP, unlike in TCP, there is a
          one-to-many mapping of a connection to subflows, and
          subflows can be added and removed while the connection
          continues to exist. Since the subflow addresses can change,
          MPTCP cannot expose addresses by getpeername() or getsockname()
          that are both valid and constant during the connection's lifetime.</t>

          <t>This problem is addressed as follows: If used by a legacy
          application, the MPTCP stack MUST always return the
          addresses and port numbers of the first subflow of an MPTCP
          connection, in all circumstances, even if that particular subflow is no
          longer in use.</t>

          <t>As the addresses may not be valid any more if the first
          subflow is closed, the MPTCP stack MAY close the whole MPTCP
          connection if the first subflow is closed (i.e., fate-sharing
          between the initial subflow and the MPTCP connection
          as a whole). This fate-sharing avoids the reuse of the pair of
          IP addresses and ports while an MPTCP connection is
          still in progress, but at the cost of reducing the utility of
          MPTCP if IP addresses of the first subflow are not available
          any more (e.g., mobility events).
          Whether to close the whole MPTCP connection by
          default SHOULD be controlled by a local policy. Further
          experiments are needed to investigate its implications.</t>

          <t>The functions getpeername() and getsockname() SHOULD also
          always return the addresses of the first subflow if the
          socket is used by an MPTCP-aware application, in order to be
          consistent with MPTCP-unaware applications, and, e.g., also
          with the Stream Control Transmission Protocol (SCTP).
          Instead of getpeername() or getsockname(),
          MPTCP-aware applications can use new API calls, described
          in <xref target="sec_basic_sockets"/>, in order to retrieve
          the full list of address pairs for the subflows in use.</t>

        </section>

      </section>

      <section title="MPTCP Connection Management">
          
        <section title="Reaction to Close Call by Application">
         
          <t>As described in <xref target="RFC6824"/>,
          MPTCP distinguishes between the closing of subflows (by TCP FIN)
          and closing the whole MPTCP connection (by Data FIN).</t>
                 
          <t>When an application closes a socket, e.g., by calling the close() function,
          this indicates that the application has no more data to send, like for
          single-path TCP. MPTCP will then close the MPTCP connection via Data
          FIN messages. This is completely transparent for an application.</t>
          
          <t>In summary, the semantics of the close() interface for applications are not
          changed compared to TCP.</t>

        </section>
        
        <section title="Other Connection Management Functions">
        
          <t>In general, an MPTCP connection is maintained separately from individual subflows.
          MPTCP therefore has internal mechanisms to establish, close, or reset 
          the MPTCP connection <xref target="RFC6824"/>. These mechanisms
          provide
          equivalent functions like single-path TCP and can be mapped accordingly. Therefore,
          these MPTCP internals do not affect the application interface.</t>
          
        </section>

      </section>

      <section title="Socket Option Issues">

        <section title="General Guideline">

          <t>The existing sockets API includes options that modify the
          behavior of sockets and their underlying communications
          protocols. Various socket options exist on the socket, TCP, and
          IP level. The value of an option can usually be set by the
          setsockopt() system function. The getsockopt() function gets
          information.  In general, the existing sockets interface
          functions cannot configure each MPTCP subflow
          individually. In order to be backward compatible, existing
          APIs therefore SHOULD apply to all subflows within one
          connection, as far as possible.</t>

        </section>

        <section title="Disabling of the Nagle Algorithm">

          <t>One commonly used TCP socket option (TCP_NODELAY)
          disables the Nagle algorithm as described in
          <xref target="RFC1122"/>.  This option is also specified in
          the POSIX standard <xref target="POSIX"/>. Applications can
          use this option in combination with MPTCP in exactly the
          same way. It then SHOULD disable the Nagle algorithm for the MPTCP
          connection, i.e., all subflows.</t>

          <t>In addition, the MPTCP protocol instance MAY use a
          different path scheduler algorithm if TCP_NODELAY is
          present. For instance, it could use an algorithm that is
          optimized for latency-sensitive traffic
          (for instance, only transmitting on one path). Specific
          algorithms are outside the scope of this document.</t>

        </section>

        <section title="Buffer Sizing">

          <t>Applications can explicitly configure send and receive
          buffer sizes via the sockets API (SO_SNDBUF,
          SO_RCVBUF). These socket options can also be used in
          combination with MPTCP and then affect the buffer size of
          the MPTCP connection. However, when defining buffer sizes,
          application programmers should take into account that the
          transport over several subflows requires a certain amount of
          buffer for resequencing in the receiver.  MPTCP may also
          require more storage space in the sender, in particular, if
          retransmissions are sent over more than one path. In
          addition, very small send buffers may prevent MPTCP from
          efficiently scheduling data over different
          subflows. Therefore, it does not make sense to use MPTCP in
          combination with small send or receive buffers.</t>

          <t>An MPTCP implementation MAY set a lower bound for send
          and receive buffers and treat a small buffer size request as
          an implicit request not to use MPTCP.</t>

        </section>

        <section title="Other Socket Options">

          <t>TCP features the ability to send "Urgent" data, but
          its use is not recommended in general, and specifically
          not with MPTCP <xref target="RFC6182"/>.</t>

          <t>Some network stacks may provide additional
          implementation-specific socket options or interfaces that
          affect TCP's behavior. In such cases, implementers must
          ensure that these options do not interfere with the MPTCP
          interface.</t>

        </section>

      </section>

      <section title="Default Enabling of MPTCP">

        <t>It is up to a local policy at the end system whether a
        network stack should automatically enable MPTCP for sockets
        even if there is no explicit sign of MPTCP awareness of the
        corresponding application. Such a choice may be under the
        control of the user through system preferences.</t>

        <t>The enabling of MPTCP, either by application or by system
        defaults, does not necessarily mean that MPTCP will always
        be used. Both endpoints must support MPTCP, and there must be
        multiple addresses at at least one endpoint, for MPTCP to be
        used. Even if those requirements are met, however, MPTCP may
        not be immediately used on a connection. It may make sense for
        multiple paths to be brought into operation only after a given
        period of time, or if the connection is saturated.</t>

      </section>

      <section title="Summary of Advice to Application Developers">

        <t><list style="symbols">

          <t>Using the default MPTCP configuration: Like TCP, MPTCP is
          designed to be efficient and robust in the default
          configuration. Application developers should not explicitly
          configure TCP (or MPTCP) features unless this is really
          needed.</t>

          <t>Socket buffer dimensioning: Multipath transport requires
          larger buffers in the receiver for resequencing, as already
          explained. Applications should use reasonable buffer sizes
          (such as the operating system default values) in order to
          fully benefit from MPTCP. A full discussion of buffer sizing
          issues is given in <xref target="RFC6824"/>.</t>

          <t>Facilitating stack-internal heuristics: The path
          management and data scheduling by MPTCP is realized by
          stack-internal algorithms that may implicitly try to
          self-optimize their behavior according to assumed
          application needs. For instance, an MPTCP implementation may
          use heuristics to determine whether an application requires
          delay-sensitive or bulk data transport, using, for instance,
          port numbers, the TCP_NODELAY socket options, or the
          application's read/write patterns as input parameters. An
          application developer can facilitate the operation of such
          heuristics by avoiding atypical interface use cases. For
          instance, for long bulk data transfers, it does not make
          sense to enable the TCP_NODELAY socket option, nor is it
          reasonable to use many small socket send() calls each
          with small amounts of data only.</t>

        </list></t>

      </section>

    </section>

    <section title="Basic API for MPTCP-Aware Applications">

      <section title="Design Considerations">

        <t>While applications can use MPTCP with the unmodified
        sockets API, multipath transport results in many degrees of
        freedom.  MPTCP manages the data transport over different
        subflows automatically. By default, this is transparent to the
        application, but an application could use an additional API to
        interface with the MPTCP layer and to control important
        aspects of the MPTCP implementation's behavior.</t>

        <t>This document describes a basic MPTCP API. The API contains
        a minimum set of functions that provide an equivalent level of 
        control and information as exists for regular TCP. It maintains 
        backward compatibility with legacy applications.</t>

        <t>An advanced MPTCP API is outside the scope of this
        document. The basic API does not allow a sender or a receiver
        to express preferences about the management of paths or the
        scheduling of data, even if this can have a significant
        performance impact and if an MPTCP implementation could
        benefit from additional guidance by applications. A list of
        potential further API extensions is provided in the
        appendix. The specification of such an advanced API is for
        further study and may partly be implementation-specific.</t>

        <t>MPTCP mainly affects the sending of data. But a
        receiver may also have preferences about data transfer
        choices, and it may have performance requirements as well.
        Yet, the configuration of such preferences is outside of the scope
        of the basic API.</t>

      </section>

      <section title="Requirements on the Basic MPTCP API">

        <t>Because of the importance of the sockets interface there
        are several fundamental design objectives for the basic
        interface between MPTCP and applications:</t>

        <t><list style="symbols">
            <t>Consistency with existing sockets APIs must be
            maintained as far as possible. In order to support the
            large base of applications using the original API, a
            legacy application must be able to continue to use
            standard sockets interface functions when run on a system
            supporting MPTCP. Also, MPTCP-aware applications should be
            able to access the socket without any major changes.</t>

            <t>Sockets API extensions must be minimized and independent
            of an implementation.</t>

            <t>The interface should handle both IPv4 and IPv6.</t>

        </list></t>

        <t>The following is a list of the core requirements for the
        basic API:</t>

        <t><list style="format REQ%d:" counter="reqs">

          <t>Turn on/off MPTCP: An application should be able to
          request to turn on or turn off the usage of MPTCP. This
          means that an application should be able to explicitly
          request the use of MPTCP if this is possible. Applications
          should also be able to request not to enable MPTCP and to
          use regular TCP transport instead. This can be implicit in
          many cases, since MPTCP must be disabled by the use of binding
          to a specific address. MPTCP may also be enabled if an
          application uses a dedicated multipath address family (such
          as AF_MULTIPATH <xref target="AFMP"/>).</t>

          <t>An application should be able to restrict MPTCP to
          binding to a given set of addresses.</t>

          <t>An application should be able to obtain information on the
          pairs of addresses used by the MPTCP subflows.</t>

          <t>An application should be able to extract a unique
          identifier for the connection (per endpoint).</t>
          
        </list></t>

        <t>The first requirement is the most important one, since some
        applications could benefit a lot from MPTCP, but there are
        also cases in which it hardly makes sense. The existing
        sockets API provides similar mechanisms to enable or disable
        advanced TCP features. The second requirement corresponds to
        the binding of addresses with the bind() socket call, or,
        e.g., explicit device bindings with a SO_BINDTODEVICE
        option. The third requirement ensures that there is an
        equivalent to getpeername() or getsockname() that is able to
        deal with more than one subflow.  Finally, it should be
        possible for the application to retrieve a unique connection
        identifier (local to the endpoint on which it is running) for
        the MPTCP connection. This replaces the
        (address, port) pair for a connection identifier in single-path
        TCP, which is no longer static in MPTCP.</t>
        
        <t>An application can continue to use getpeername() or
        getsockname() in addition to the basic MPTCP API.
        Both functions return the corresponding addresses of the
        first subflow, as already explained.</t>

      </section>

      <section title="Sockets Interface Extensions by the Basic MPTCP API" anchor="sec_basic_sockets">

        <section title="Overview">

          <t>The abstract, basic MPTCP API consists of a set of new values 
          that are associated with an MPTCP socket. Such values may be used
          for changing properties of an MPTCP connection or retrieving 
          information. These values could be accessed by new symbols on
          existing calls such as setsockopt() and getsockopt() or could 
          be implemented as entirely new function calls. This implementation
          decision is out of scope for this document. The following list
          presents symbolic names for these MPTCP socket settings.</t>

          <t><list style="symbols">

              <t>TCP_MULTIPATH_ENABLE: Enable/disable MPTCP</t>

              <t>TCP_MULTIPATH_ADD: Bind MPTCP to a set of given local
              addresses, or add a set of new local addresses to an
              existing MPTCP connection</t>

              <t>TCP_MULTIPATH_REMOVE: Remove a local address from an MPTCP
              connection</t>

              <t>TCP_MULTIPATH_SUBFLOWS: Get the pairs of addresses currently 
              used by the MPTCP subflows</t>

              <t>TCP_MULTIPATH_CONNID: Get the local connection identifier
              for this MPTCP connection</t>
   
          </list></t>

          <t><xref target="tab_options"/> shows a list of the
          abstract socket operations for the basic configuration of
          MPTCP.  The first column gives the symbolic name of the
          operation. The second and third columns indicate whether the
          operation provides values to be read ("Get") or takes values
          to configure ("Set").  The fourth column lists the type of
          data associated with this operation. The data types are listed
          for information only. In addition to IP
          addresses, an application MAY also indicate TCP port numbers,
          as further detailed below.</t>

          <texttable anchor="tab_options" title="MPTCP Socket Operations">
            <ttcol align='left'>Name</ttcol>
            <ttcol align='center'>Get</ttcol>
            <ttcol align='center'>Set</ttcol>
            <ttcol align='center'>Data type</ttcol>

            <c>TCP_MULTIPATH_ENABLE</c>
            <c>o</c>
            <c>o</c>
            <c>boolean</c>

            <c>TCP_MULTIPATH_ADD</c>
            <c></c>
            <c>o</c>
            <c>list of addresses (and ports)</c>

            <c>TCP_MULTIPATH_REMOVE</c>
            <c></c>
            <c>o</c>
            <c>list of addresses (and ports)</c>

            <c>TCP_MULTIPATH_SUBFLOWS</c>
            <c>o</c>
            <c></c>
            <c>list of pairs of addresses (and ports)</c>

            <c>TCP_MULTIPATH_CONNID</c>
            <c>o</c>
            <c></c>
            <c>integer</c>
          </texttable>

          <t>There are restrictions on when these new socket operations can be
          used:

            <list style="symbols">

              <t>TCP_MULTIPATH_ENABLE: This value should only be set
              before the establishment of a TCP connection. Its value
              should only be read after the establishment of a
              connection.</t>

              <t>TCP_MULTIPATH_ADD: This operation can be applied both
              before connection setup and during a connection. If used
              before, it controls the local addresses that an MPTCP
              connection can use. In the latter case, it allows MPTCP 
              to use an additional local address, if
              there has been a restriction before connection setup.</t>

              <t>TCP_MULTIPATH_REMOVE: This operation can be applied both
              before connection setup and during a connection. In both cases,
              it removes an address from the list of local addresses that
              may be used by subflows.</t>
              
              <t>TCP_MULTIPATH_SUBFLOWS: This value is read-only and
              can only be used after connection setup.</t>
   
              <t>TCP_MULTIPATH_CONNID: This value is read-only and
              should only be used after connection setup.</t>

            </list>

          </t>

        </section>

        <section title="Enabling and Disabling of MPTCP" anchor="sec_mptcp_enable">

          <t>An application can explicitly indicate multipath
          capability by setting TCP_MULTIPATH_ENABLE to the
          value "true". In this case, the MPTCP implementation
          SHOULD try to negotiate MPTCP for that connection. 
          Note that multipath transport will not necessarily be 
          enabled, as it requires support at both end systems, no 
          middleboxes on the path that would prevent any additional 
          signaling, and at least one endpoint with multiple addresses.</t>

          <t>Building on the backward compatibility specified in
          <xref target="sec_spec_addr"/>, if an application enables MPTCP 
          but binds to a specific address or interface, MPTCP MUST be 
          enabled, but MPTCP MUST respect the application's choice and 
          only use addresses that are explicitly provided by the application.
          Note that it would be possible for an application to use the legacy
          bindings and then expand on them by using TCP_MULTIPATH_ADD. Note 
          also that it is possible for more than one local address to be 
          initially available to MPTCP in this case, if an application has 
          bound to a specific interface with multiple addresses.</t>

          <t>An application can disable MPTCP by setting TCP_MULTIPATH_ENABLE
          to a value of "false". In that case, MPTCP MUST NOT be used on that
          connection.</t>

          <t>After connection establishment, an application can get
          the value of TCP_MULTIPATH_ENABLE. A value of "false"
          then means lack of MPTCP support. A value of "true"
          means that MPTCP is supported.</t>

        </section>

        <section title="Binding MPTCP to Specified Addresses" anchor="sec_mptcp_bind">

          <t>Before connection establishment, an application can use the
          TCP_MULTIPATH_ADD function to indicate a set of local IP
          addresses that MPTCP may bind to. The parameter of the
          function is a list of addresses in a corresponding data
          structure. By extension, this operation will also control
          the list of addresses that can be advertised to the peer via
          MPTCP signaling.</t>

          <t>If an application binds to a specific address or
          interface, it is not required to use the TCP_MULTIPATH_ADD
          operation for that address. As explained in
          <xref target="sec_mptcp_enable"/>, MPTCP MUST only use the
          explicitly specified addresses in that case.</t>

          <t>An application MAY also indicate a TCP port number that,
          if specified, MPTCP MUST attempt to bind to. The port number
          MAY be different than the one used by existing subflows. If no
          port number is provided by the application, the port number
          is automatically selected by the MPTCP implementation,
          and it is RECOMMENDED that it is the same across all subflows.</t>
          
          <t>This operation can also be used to modify the address
          list in use during the lifetime of an MPTCP connection. In
          this case, it is used to indicate a set of additional local
          addresses that the MPTCP connection can make use of and
          that can be signaled to the peer.  It should be noted that
          this signal is only a hint, and an MPTCP implementation MAY
          select only a subset of the addresses.</t>

          <t>The TCP_MULTIPATH_REMOVE operation can be used to remove
          a local address, or a set of local addresses, from an MPTCP
          connection. MPTCP MUST
          close any corresponding subflows (i.e., those using the local
          address that is no longer present) and signal the removal
          of the address to the peer. If alternative paths are available
          using the supplied address list but MPTCP is not currently 
          using them, an MPTCP implementation SHOULD establish alternative 
          subflows before undertaking the address removal.</t>

          <t>It should be remembered that these operations SHOULD support
          both IPv4 and IPv6 addresses, potentially in the same call.</t>

        </section>

        <section title="Querying the MPTCP Subflow Addresses">

          <t>An application can get a list of the addresses used by
          the currently established subflows in an MPTCP connection
          by means of the read-only TCP_MULTIPATH_SUBFLOWS operation.</t>
          
          <t>The return value is a list
          of pairs of tuples of IP address and TCP port number.  In
          one pair, the first tuple refers to the local IP address and
          the local TCP port, and the second one to the remote IP
          address and remote TCP port used by the subflow.  The list
          MUST only include established subflows. Both addresses in
          each pair MUST be either IPv4 or IPv6.</t>

        </section>

        <section title="Getting a Unique Connection Identifier">

          <t>An application that wants a unique identifier for the 
          connection, analogous to an (address, port) pair in regular
          TCP, can query the TCP_MULTIPATH_CONNID value to get a local
          connection identifier for the MPTCP connection.</t>

          <t>This SHOULD be an integer number and SHOULD be locally
          unique (e.g., the MPTCP token).</t>

        </section>

      </section>

    </section>

    <section title="Other Compatibility Issues">

      <section title="Usage of TLS over MPTCP" anchor="sec_tls">

        <t>Transport Layer Security (TLS) <xref target="RFC5246"/> may
        be used over MPTCP's basic API.  When TLS compares any
        addresses used by MPTCP against names or addresses present in
        X.509 certificates <xref target="RFC5280"/> <xref
        target="RFC6125"/>, it MUST only compare them with the address
        that MPTCP used to start the initial subflow as presented to
        TLS. The addresses used for subsequent subflows need not to
        be compared against any TLS certificate
        information. Finer-grained control would require an advanced
        API or proactive subflow management via the basic API.</t>

      </section>

      <section title="Usage of the SCTP Sockets API">

        <t>For dealing with multihoming, several sockets API
        extensions have been defined for SCTP
        <xref target="RFC6458"/>. As MPTCP realizes multipath
        transport from and to multihomed end systems, some of these
        interface function calls are actually applicable to MPTCP in a
        similar way.</t>
        
        <t>API developers may wish to integrate SCTP and MPTCP calls to
        provide a consistent interface to the application.
        Yet, it must be emphasized that the transport
        service provided by MPTCP is different than that of SCTP, and this is
        why not all SCTP API functions can be mapped directly to
        MPTCP. Furthermore, a network stack implementing MPTCP does
        not necessarily support SCTP and its specific sockets interface
        extensions. This is why the basic API of MPTCP defines
        additional socket options only, which are a backward-compatible
        extension of TCP's application interface. Integration with the
        SCTP API is outside the scope of the basic API.</t>

      </section>

      <section title="Incompatibilities with Other Multihoming Solutions">

        <t>The use of MPTCP can interact with various related sockets
        API extensions. The use of a multihoming shim layer conflicts
        with multipath transport such as MPTCP or SCTP
        <xref target="RFC6316"/>. Care should be taken that the use 
        of MPTCP not conflict with the overlapping features of other APIs:

          <list style="symbols">

            <t>SHIM API <xref target="RFC6316"/>: This API specifies
            sockets API extensions for the multihoming shim layer.</t>

            <t>HIP API <xref target="RFC6317"/>: The Host Identity
            Protocol (HIP) also results in a new API.</t>

            <t>API for Mobile IPv6 <xref target="RFC4584"/>: For Mobile
            IPv6, a significantly extended sockets API exists as well
            (in addition to API extensions for IPv6
            <xref target="RFC3542"/>).</t>

          </list>

        In order to avoid any conflict, multiaddressed MPTCP SHOULD
        NOT be enabled if a network stack uses SHIM6, HIP, or Mobile
        IPv6.  Furthermore, applications should not try to use both
        the MPTCP API and another multihoming or mobility layer
        API.</t>

        <t>It is possible, however, that some of the MPTCP
        functionality, such as congestion control, could be used in a
        SHIM6 or HIP environment. Such operation is for further
        study.</t>

      </section>

      <section title="Interactions with DNS">

        <t>In multihomed or multiaddressed environments, there are
        various issues that are not specific to MPTCP but have to be
        considered as well. These problems are summarized in
        <xref target="RFC6418"/>.</t>

        <t>Specifically, there can be interactions with DNS. Whilst
        it is expected that an application will iterate over the list
        of addresses returned from a call such as getaddrinfo(), MPTCP
        itself MUST NOT make any assumptions about multiple A or AAAA
        records from the same DNS query referring to the same host, as
        it is possible that multiple addresses refer to multiple
        servers for load-balancing purposes.</t>

      </section>

    </section>

    <section title="Security Considerations">

     <t>This document first defines the behavior of the standard
     TCP/IP API for MPTCP-unaware applications. In general, enabling
     MPTCP has some security implications for applications, which are
     introduced in <xref target="sec_mptcp_bind"/>, and these threats
     are further detailed in <xref target="RFC6181"/>. The protocol
     specification of MPTCP <xref
     target="RFC6824"/> defines several
     mechanisms to protect MPTCP against those attacks.</t>

     <t>The syntax and semantics of the API for MPTCP-unaware
     applications does not change. However, assumptions that
     non-MPTCP-aware applications may make on the data retrieved by
     the backward-compatible API are discussed in <xref
     target="sec_query_addr"/>. System administrators may wish to
     disable MPTCP for certain applications that signal addresses, or
     make security decisions (e.g., opening firewall holes), based on
     responses to such queries.</t>

     <t>In addition, the basic MPTCP API for MPTCP-aware applications
     defines functions that provide an equivalent level of control and
     information as exists for regular TCP. This document does not
     mandate a specific implementation of the basic MPTCP API.  The
     implementation should be designed not to affect memory management
     assumptions in existing code. Implementors should take into
     account that data structures will be more complex than for
     standard TCP, e.g., when multiple subflow addresses have to be
     stored. When dealing with such data structures, care is needed
     not to add security vulnerabilities to applications.</t>

     <t>New functions enable adding and removing local addresses from
     an MPTCP connection (TCP_MULTIPATH_ADD and
     TCP_MULTIPATH_REMOVE). These functions don't add security threats
     if the MPTCP stack verifies that the addresses provided by the
     application are indeed available as source addresses for
     subflows.</t>

     <t>However, applications should use the TCP_MULTIPATH_ADD
     function with care, as new subflows might get established to
     those addresses. Furthermore, it could result in some form of
     information leakage since MPTCP might advertise those addresses
     to the other connection endpoint, which could learn IP addresses
     of interfaces that are not visible otherwise.</t>

     <t>Use of different addresses should not be assumed to lead to
     use of different paths, especially for security purposes.</t>

     <t>MPTCP-aware applications should also take care when querying
     and using information about the addresses used by subflows
     (TCP_MULTIPATH_SUBFLOWS). As MPTCP can dynamically open and close
     subflows, a list of addresses queried once can get outdated
     during the lifetime of an MPTCP connection. Then, the list may
     contain invalid entries, i.e., addresses that are not used any
     more or that might not even be assigned to that host any more.
     Applications that want to
     ensure that MPTCP only uses a certain set of addresses should
     explicitly bind to those addresses.</t>

     <t>One specific example is the use TLS on top of
     MPTCP. Corresponding guidance can be found in <xref
     target="sec_tls"/>.</t>

    </section>

    <section title="Conclusion">

      <t>This document discusses MPTCP's implications and
      its performance impact on applications. In addition, it
      specifies a basic MPTCP API. For legacy applications, it is
      ensured that the existing sockets API continues to work.
      MPTCP-aware applications can use the basic MPTCP API that
      provides some control over the transport layer equivalent to
      regular TCP.</t>

    </section>

    <section title="Acknowledgments">

      <t>The authors sincerely thank the following people for their
      helpful comments and reviews of the document: Philip Eardley,
      Lavkesh Lahngir, John Leslie, Costin Raiciu, Michael Tuexen,
      and Javier Ubillos.</t>

      <t>Michael Scharf is supported by the German-Lab project
      (http://www.german-lab.de/) funded by the German Federal
      Ministry of Education and Research (BMBF). Alan Ford was
      previously supported by Roke Manor Research and by Trilogy
      (http://www.trilogy-project.org/), a research project
      (ICT-216372) partially funded by the European Community under
      its Seventh Framework Program.</t>

    </section>

  </middle>

  <back>

    <references title="Normative References">

      &RFC0793;
      &RFC1122;
      &RFC2119;
      &MPTCPARCH;

<!-- draft-ietf-mptcp-multiaddressed (RFC 6824; published) -->
      &MPTCP;

      &MPTCPSEC;
      &MPTCPCC;

      <reference anchor="POSIX">
        <front>
          <title>IEEE Standard for Information Technology --
          Portable Operating System Interface (POSIX) Base Specifications,
Issue 7</title>
        <author><organization></organization></author>
        <date year="2008"/>
        </front>
       <seriesInfo name="IEEE Std." value="1003.1-2008"/>
      </reference>        

    </references>

    <references title="Informative References">

      &RFC3542;
      &RFC4584;
      &SHIMAPI;
      &HIPAPI;
      &SCTPAPI;
      &MIFPROBLEM;
      &MIFPRACTICE;
      &EYEBALLS;
      &RFC5246;
      &RFC5280;
      &RFC6125;

<!-- draft-sarolahti-mptcp-af-multipath (Expired) -->
    <reference anchor="AFMP">
      <front>
       <title>Multi-address Interface in the Socket API</title>
       <author initials='P' surname='Sarolahti' fullname='Pasi Sarolahti'>
        <organization />
       </author>
      <date month='March' year='2010' />
      </front>
      <seriesInfo name='Work in' value='Progress' />
    </reference>

<!-- draft-khalili-mptcp-performance-issues (I-D Exists) -->
      <reference anchor="MPTCPISSUES">
      <front>
      <title>Performance Issues with MPTCP</title>
      <author initials='R' surname='Khalili' fullname='Ramin Khalili'>
        <organization />
      </author>
      <author initials='N' surname='Gast' fullname='Nicolas Gast'>
        <organization />
      </author>
      <author initials='M' surname='Popovic' fullname='Miroslav Popovic'>
        <organization />
      </author>
      <author initials='J' surname="Le Boudec" fullname='Jean-Yves Le Boudec'>
        <organization />
      </author>
      <date month='February' year='2013' />
      </front>
      <seriesInfo name='Work in' value='Progress' />
     </reference>

     <reference anchor="Honda2011">
      <front>
        <title>Is it Still Possible to Extend TCP?</title>
        <author initials='M.' surname='Honda' fullname='Michio Honda'/>
        <author initials='Y.' surname='Nishida' fullname='Yoshifumi Nishida'/>
        <author initials='C.' surname='Raiciu' fullname='Costin Raiciu'/>
        <author initials='A.' surname='Greenhalgh' fullname='Adam Greenhalgh'/>
        <author initials='M.' surname='Handley' fullname='Mark Handley'/>
        <author initials='H.' surname='Tokuda' fullname='Hideyuki Tokuda'/>
        <date year='2011' month='November'/>
      </front>
      <seriesInfo name="Proc. ACM Internet Measurement Conference" value="(IMC)"/>
     </reference>

    </references>

    <section title="Requirements on a Future Advanced MPTCP API">

      <section title="Design Considerations">

        <t>Multipath transport results in many degrees of freedom.
        The basic MPTCP API only defines a minimum set of the 
        API extensions for the interface between the MPTCP layer and
        applications, which does not offer much control of the MPTCP
        implementation's behavior. A future, advanced API could
        address further features of MPTCP and provide more
        control.</t>

        <t>Applications that use TCP may have different requirements
        on the transport layer.  While developers have become used to
        the characteristics of regular TCP, new opportunities created
        by MPTCP could allow the service provided to be optimized
        further.  An advanced API could enable MPTCP-aware
        applications to specify preferences and control certain
        aspects of the behavior, in addition to the simple control
        provided by the basic interface. An advanced API could also
        address aspects that are completely out of scope of the basic
        API, for example, the question of whether a receiving application
        could influence the sending policy. A better integration
        with TLS could be another relevant objective (cf.        
        <xref target="sec_tls"/>) that requires further work.</t>

        <t>Furthermore, an advanced MPTCP API could be part of a new
        overall interface between the network stack and applications
        that addresses other issues as well, such as the split between
        identifiers and locators. An API that does not use IP
        addresses (but instead uses, e.g., the connectbyname() function) would
        be useful for numerous purposes, independent of MPTCP.</t>
        
        <t>It has also been suggested that a separate address family
        called AF_MULTIPATH <xref target="AFMP"/> be used.
        This separate address family could be used to exchange multiple
        addresses between an application and the standard sockets
        API, but it would be a more fundamental change compared to the
        basic API described in this document.</t>

        <t>This appendix documents a list of potential usage scenarios
        and requirements for the advanced API. The specification and
        implementation of a corresponding API are outside the scope
        of this document.</t>

      </section>

      <section title="MPTCP Usage Scenarios and Application Requirements">

        <t>There are different MPTCP usage scenarios. An application
        that wishes to transmit bulk data will want MPTCP to provide a
        high-throughput service immediately, through creating and
        maximizing utilization of all available subflows.  This is the
        default MPTCP use case.</t>

        <t>But at the other extreme, there are applications that are
        highly interactive but require only a small amount of
        throughput, and these are optimally served by low latency and
        jitter stability.  In such a situation, it would be preferable
        for the traffic to use only the lowest-latency subflow
        (assuming it has sufficient capacity), maybe with one or two
        additional subflows for resilience and recovery purposes.  The
        key challenge for such a strategy is that the delay on a path
        may fluctuate significantly and that just always selecting the
        path with the smallest delay might result in instability.</t>

        <t>The choice between bulk data transport and
        latency-sensitive transport affects the scheduler in terms of
        whether traffic should be, by default, sent on one subflow or
        across several subflows. Even if the total bandwidth required is
        less than that available on an individual path, it is
        desirable to spread this load to reduce stress on potential
        bottlenecks, and this is why this method should be the default
        for bulk data transport. However, that may not be optimal for
        applications that require latency/jitter stability.</t>

        <t>In the case of the latter option, a further question
        arises: Should additional subflows be used whenever the
        primary subflow is overloaded, or only when the primary path
        fails (hot standby)? In other words, is latency stability or
        bandwidth more important to the application? This results in
        two different options: Firstly, there is the single path that
        can overflow into an additional subflow; and secondly, there is
        the single path with hot standby, whereby an application may want
        an alternative backup subflow in order to improve resilience.
        In case data delivery on the first subflow fails, the
        data transport could immediately be continued on the second
        subflow, which is idle otherwise.</t>

        <t>Yet another complication is introduced with the potential
        that MPTCP introduces for changes in available bandwidth as
        the number of available subflows changes. Such jitter in 
        bandwidth may prove confusing for some applications, such as
        video or audio streaming, that dynamically adapt codecs based
        on available bandwidth. Such applications may prefer MPTCP
        to attempt to provide a consistent bandwidth as far as is
        possible and avoid maximizing the use of all subflows.</t>

        <t>A further, mostly orthogonal question is whether data
        should be duplicated over the different subflows, in
        particular if there is spare capacity. This could improve both
        the timeliness and reliability of data delivery.</t>

        <t>In summary, there are at least three possible performance
        objectives for multipath transport:</t>

        <t><list style="numbers">

            <t>High bandwidth</t>

            <t>Low latency and jitter stability</t>

            <t>High reliability</t>
  
        </list></t>

        <t>These are not necessarily disjoint, since there are also 
        broadband interactive applications that require both high-speed
        bulk data traffic and a low latency and jitter.</t>

        <t>In an advanced API, applications could provide high-level
        guidance to the MPTCP implementation concerning these
        performance requirements, for instance, which requirement is
        considered to be the most important. The MPTCP stack would then use
        internal mechanisms to fulfill this abstract indication of a
        desired service, as far as possible. This would affect
        the assignment of data (including retransmissions) to existing
        subflows (e.g., 'use all in parallel', 'use as overflow', 'hot
        standby', 'duplicate traffic') as well as the decisions regarding
        when to set up additional subflows to which addresses. In both
        cases, different policies can exist, which can be expected to
        be implementation-specific.</t>

        <t>Therefore, an advanced API could provide a mechanism for how
        applications can specify their high-level requirements in an
        implementation-independent way. One possibility would be to
        select one "application profile" out of a number of choices
        that characterize typical applications. Yet, as applications
        today do not have to inform TCP about their communication
        requirements, it requires further studies as to whether such an
        approach would be realistic.</t>
        
        <t>Of course, independent of an advanced API, such
        functionality could also partly be achieved by MPTCP-internal
        heuristics that infer some application preferences, e.g., from
        existing socket options, such as TCP_NODELAY. Whether this
        would be reliable, and indeed appropriate, is for further
        study.</t>

      </section>

      <section title="Potential Requirements on an Advanced MPTCP API">

        <t>The following is a list of potential requirements for an
        advanced MPTCP API beyond the features of the basic API. It is
        included here for information only:</t>

        <t><list style="format REQ%d:" counter="reqs">

          <t>An application should be able to establish MPTCP
          connections without using IP addresses as locators.</t>

          <t>An application should be able to obtain usage information
          and statistics about all subflows (e.g., ratio of traffic
          sent via this subflow).</t>

          <t>An application should be able to request a change in the
          number of subflows in use, thus triggering removal or
          addition of subflows. An even finer control granularity
          would be a request for the establishment of a specific subflow to
          a provided destination or a request for the termination of
          a specified, existing subflow.</t>

          <t>An application should be able to inform the MPTCP
          implementation about its high-level performance
          requirements, e.g., in the form of a profile.</t>

          <t>An application should be able to indicate communication
          characteristics, e.g., the expected amount of data to be
          sent, the expected duration of the connection, or the
          expected rate at which data is provided. Applications may in
          some cases be able to forecast such properties. If so, such
          information could be an additional input parameter for
          heuristics inside the MPTCP implementation, which could be
          useful, for example, to decide when to set up additional
          subflows.</t>

          <t>An application should be able to control the automatic
          establishment/termination of subflows. This would imply a
          selection among different heuristics of the path manager,
          e.g., 'try as soon as possible', 'wait until there is a
          bunch of data', etc.</t>

          <t>An application should be able to set preferred subflows
          or subflow usage policies. This would result in a selection
          among different configurations of the multipath
          scheduler. For instance, an application might want to use
          certain subflows as backup only.</t>

          <t>An application should be able to control the level of
          redundancy by telling whether segments should be sent on
          more than one path in parallel.</t>

          <t>An application should be able to control the use of
          fate-sharing of the MPTCP connection and the initial subflow,
          e.g., to overwrite system policies.</t>

          <t>An application should be able to register for callbacks
          to be informed of changes to subflows on an MPTCP connection.
          This "push" interface would allow the application to make 
          timely logging and configuration changes, if required, and
          would avoid frequent polling of information.</t>

        </list></t>

        <t>An advanced API fulfilling these requirements would allow
        application developers to more specifically configure MPTCP.
        It could avoid suboptimal decisions of internal, implicit
        heuristics. However, it is unclear whether all of these
        requirements would have a significant benefit to applications,
        since they are going above and beyond what the existing API to
        regular TCP provides.</t>

        <t>A subset of these functions might also be implemented
        system-wide or by other configuration mechanisms. These
        implementation details are left for further study.</t>

      </section>

      <section title="Integration with the SCTP Sockets API">

        <t>The advanced API may also integrate or use the SCTP sockets API.
        The following functions that are defined for SCTP
        have functionality similar to the basic MPTCP API:</t>

        <t><list style="symbols">

           <t>sctp_bindx()</t>

           <t>sctp_connectx()</t>

           <t>sctp_getladdrs()</t>

           <t>sctp_getpaddrs()</t>
           
           <t>sctp_freeladdrs()</t>
           
           <t>sctp_freepaddrs()</t>

        </list></t>

        <t>The syntax and semantics of these functions are described in
        <xref target="RFC6458"/>.</t>

        <t>A potential objective for the advanced API is to provide a
        consistent MPTCP and SCTP interface to the application. This is 
        left for further study.</t>

      </section>


    </section>

  </back>

</rfc>
