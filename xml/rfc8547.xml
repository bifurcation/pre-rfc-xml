<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd' []>


<rfc number="8547" submissionType="IETF" ipr="trust200902" category="exp" consensus="yes">

<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc private=""?>
<?rfc topblock="yes"?>
<?rfc comments="no"?>
<front>
<title abbrev="TCP Encryption Negotiation Option">TCP-ENO: Encryption Negotiation Option</title>

<author initials="A." surname="Bittau" fullname="Andrea Bittau">
<organization>Google</organization>
<address>
<postal>
<street>345 Spear Street</street>
<city>San Francisco, CA</city>
<code>94105</code>
<country>United States of America</country>
<region></region>
</postal>
<phone></phone>
<email>bittau@google.com</email>
<uri></uri>
</address>
</author>
<author initials="D." surname="Giffin" fullname="Daniel B. Giffin">
<organization>Stanford University</organization>
<address>
<postal>
<street>353 Serra Mall, Room 288</street>
<city>Stanford, CA</city>
<code>94305</code>
<country>United States of America</country>
<region></region>
</postal>
<phone></phone>
<email>daniel@beech-grove.net
</email>
<uri></uri>
</address>
</author>
<author initials="M." surname="Handley" fullname="Mark Handley">
<organization>University College London</organization>
<address>
<postal>
<street>Gower St.</street>
<city>London</city>
<code>WC1E 6BT</code>
<country>United Kingdom</country>
<region></region>
</postal>
<phone></phone>
<email>M.Handley@cs.ucl.ac.uk</email>
<uri></uri>
</address>
</author>
<author initials="D." surname="Mazieres" fullname="David Mazieres">
<organization>Stanford University</organization>
<address>
<postal>
<street>353 Serra Mall, Room 290</street>
<city>Stanford, CA</city>
<code>94305</code>
<country>United States of America</country>
<region></region>
</postal>
<phone></phone>
<email>dm@uun.org</email>
<uri></uri>
</address>
</author>
<author initials="E." surname="Smith" fullname="Eric W. Smith">
<organization>Kestrel Institute</organization>
<address>
<postal>
<street>3260 Hillview Avenue</street>
<city>Palo Alto, CA</city>
<code>94304</code>
<country>United States of America</country>
<region></region>
</postal>
<phone></phone>
<email>eric.smith@kestrel.edu</email>
<uri></uri>
</address>
</author>
<date year="2019" month="May" />

<area>Internet</area>
<workgroup></workgroup>
<keyword>tcp, encryption</keyword>



<abstract>
<t>Despite growing adoption of TLS, a significant fraction of TCP traffic
on the Internet remains unencrypted.  The persistence of unencrypted
traffic can be attributed to at least two factors.  First, some legacy
protocols lack a signaling mechanism (such as a STARTTLS command) by
which to convey support for encryption, thus making incremental deployment
impossible.  Second, legacy applications themselves cannot always be
upgraded and therefore require a way to implement encryption transparently
entirely within the transport layer.  The TCP Encryption Negotiation
Option (TCP-ENO) addresses both of these problems through a new TCP
option kind providing out-of-band, fully backward-compatible
negotiation of encryption.
</t>
</abstract>


</front>

<middle>


<section anchor="introduction" title="Introduction">
<t>Many applications and protocols running on top of TCP today do not
encrypt traffic.  This failure to encrypt lowers the bar for certain
attacks, harming both user privacy and system security.  Counteracting
the problem demands a minimally intrusive, backward-compatible
mechanism for incrementally deploying encryption.  The TCP Encryption
Negotiation Option (TCP-ENO) specified in this document provides such
a mechanism.
</t>
<t>Introducing TCP options, extending operating system interfaces to
support TCP-level encryption, and extending applications to take
advantage of TCP-level encryption all require effort.  To the greatest
extent possible, the effort invested in realizing TCP-level encryption
today needs to remain applicable in the future should the need arise
to change encryption strategies.  To this end, it is useful to
consider two questions separately:
</t>
<t>
<list style="numbers">
<t>How to negotiate the use of encryption at the TCP layer</t>
<t>How to perform encryption at the TCP layer</t>
</list>
</t>
<t>This document addresses question 1 with a new TCP option, ENO.
TCP&nbhy;ENO provides a framework in which two endpoints can agree on a TCP
encryption protocol (TEP) out of multiple possible TEPs.  For future
compatibility, TEPs can vary widely in terms of wire format, use of
TCP option space, and integration with the TCP header and
segmentation.  However, ENO abstracts these differences to ensure the
introduction of new TEPs can be transparent to applications taking
advantage of TCP-level encryption.
</t>
<t>Question 2 is addressed by one or more companion TEP specification
documents.  While current TEPs enable TCP-level traffic encryption
today, TCP-ENO ensures that the effort invested to deploy today's TEPs
will additionally benefit future ones.
</t>

<section anchor="design-goals" title="Design Goals">
<t>TCP-ENO was designed to achieve the following goals:
</t>
<t>
<list style="numbers">
<t>Enable endpoints to negotiate the use of a separately specified TCP
encryption protocol (TEP) suitable for either opportunistic
security <xref target="RFC7435"/> of arbitrary TCP communications or stronger
security of applications willing to perform endpoint
authentication.</t>
<t>Transparently fall back to unencrypted TCP when not supported by
both endpoints.</t>
<t>Provide out-of-band signaling through which applications can better
take advantage of TCP-level encryption (for instance, by improving
authentication mechanisms in the presence of TCP-level encryption).</t>
<t>Define a standard negotiation transcript that TEPs can use to
defend against tampering with TCP-ENO.</t>
<t>Make parsimonious use of TCP option space.</t>
<t>Define roles for the two ends of a TCP connection, so as to name
each end of a connection for encryption or authentication purposes
even following a symmetric simultaneous open.</t>
</list>
</t>
</section>
</section>

<section anchor="requirements-language" title="Requirements Language">
        <t>
    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
    "MAY", and "OPTIONAL" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
</section>

<section anchor="terminology" title="Terminology">
<t>Throughout this document, we use the following terms, several of which
have more detailed normative descriptions in <xref target="RFC0793"/>:
</t>
<t>
<list style="hanging">
<t hangText="SYN segment">
<vspace />
A TCP segment in which the SYN flag is set</t>
<t hangText="ACK segment">
<vspace />
A TCP segment in which the ACK flag is set (which includes most
segments other than an initial SYN segment)</t>
<t hangText="Non-SYN segment">
<vspace />
A TCP segment in which the SYN flag is clear</t>
<t hangText="SYN-only segment">
<vspace />
A TCP segment in which the SYN flag is set but the ACK flag is
clear</t>
<t hangText="SYN-ACK segment">
<vspace />
A TCP segment in which the SYN and ACK flags are both set</t>
<t hangText="Active opener">
<vspace />
A host that initiates a connection by sending a SYN-only segment.
With the BSD socket API, an active opener calls <spanx style="verb">connect</spanx>.  In
client-server configurations, active openers are typically clients.</t>
<t hangText="Passive opener">
<vspace />
A host that does not send a SYN-only segment but responds to one
with a SYN-ACK segment.  With the BSD socket API, passive openers
call <spanx style="verb">listen</spanx> and <spanx style="verb">accept</spanx>, rather than <spanx style="verb">connect</spanx>.  In
client-server configurations, passive openers are typically
servers.</t>
<t hangText="Simultaneous open">
<vspace />
The act of symmetrically establishing a TCP connection between two
active openers (both of which call <spanx style="verb">connect</spanx> with BSD sockets).
Each host of a simultaneous open sends both a SYN-only and a
SYN-ACK segment.  Simultaneous open is less common than asymmetric
open with one active and one passive opener, but it can be used for
NAT traversal by peer-to-peer applications <xref target="RFC5382"/>.</t>
<t hangText="TEP">
<vspace />
A TCP encryption protocol intended for use with TCP-ENO and
specified in a separate document</t>
<t hangText="TEP identifier">
<vspace />
A unique 7-bit value in the range 0x20-0x7f that IANA has assigned
to a TEP</t>
<t hangText="Negotiated TEP">
<vspace />
The single TEP governing a TCP connection, determined by use of the
TCP ENO option specified in this document</t>
</list>
</t>
</section>

<section anchor="tcpeno-specification" title="TCP-ENO Specification">
<t>TCP-ENO extends TCP connection establishment to enable encryption
opportunistically.  It uses a new TCP option kind <xref target="RFC0793"/> to
negotiate one among multiple possible TCP encryption protocols (TEPs).
The negotiation involves hosts exchanging sets of supported TEPs,
where each TEP is represented by a suboption within a larger TCP ENO
option in the offering host's SYN segment.
</t>
<t>If TCP-ENO succeeds, it yields the following information:
</t>
<t>
<list style="symbols">
<t>a negotiated TEP represented by a unique 7-bit TEP identifier,</t>
<t>a few extra bytes of suboption data from each host, if needed by the
TEP,</t>
<t>a negotiation transcript with which to mitigate attacks on the
negotiation itself,</t>
<t>role assignments designating one endpoint &quot;host A&quot; and the other
endpoint &quot;host B&quot;, and</t>
<t>a bit available to higher-layer protocols at each endpoint for
out-of-band negotiation of updated behavior in the presence of TCP
encryption.</t>
</list>
</t>
<t>If TCP-ENO fails, encryption is disabled and the connection falls back
to traditional unencrypted TCP.
</t>
<t>The remainder of this section provides the normative description of
the TCP ENO option and handshake protocol.
</t>

<section anchor="eno-option" title="ENO Option">
<t>TCP-ENO employs an option in the TCP header <xref target="RFC0793"/>.
<xref target="fig:option"/> illustrates the high-level format of this option.
</t>

<figure anchor="fig:option" align="center" title="The TCP-ENO Option
"><artwork align="center">
byte    0     1     2             N+1   (N+2 bytes total)
     +-----+-----+-----+--....--+-----+
     |Kind=|Len= |                    |
     |  69 | N+2 | contents (N bytes) |
     +-----+-----+-----+--....--+-----+
</artwork></figure>
<t>The contents of an ENO option can take one of two forms.  A SYN-form ENO option,
illustrated in <xref target="fig:eno"/>, appears only in SYN segments.  A
non-SYN-form ENO option, illustrated in <xref target="fig:minimal"/>, appears only in non-SYN segments.
The SYN-form ENO option acts as a container for zero or more suboptions,
labeled <spanx style="verb">Opt_0</spanx>, <spanx style="verb">Opt_1</spanx>,
... in <xref target="fig:eno"/>.  The non-SYN-form ENO option, by its
presence, acts as a one-bit acknowledgment, with the actual contents
ignored by ENO.  Particular TEPs MAY assign additional meaning to the
contents of non-SYN-form ENO options.  When a negotiated TEP does not
assign such meaning, the contents of a non-SYN-form ENO option MUST be zero
bytes (i.e., N = 0) in sent segments and MUST be ignored in received segments.
</t>

<figure anchor="fig:eno" align="center" title="SYN-Form ENO Option"><artwork align="center">
byte    0     1     2     3                     ... N+1
     +-----+-----+-----+-----+--...--+-----+----...----+
     |Kind=|Len= |Opt_0|Opt_1|       |Opt_i|   Opt_i   |
     |  69 | N+2 |     |     |       |     |   data    |
     +-----+-----+-----+-----+--...--+-----+----...----+
</artwork></figure>

<figure anchor="fig:minimal" align="center" title="Non-SYN-Form ENO option, Where N MAY Be 0
"><artwork align="center">
byte   0     1     2     N+1
    +-----+-----+-----...----+
    |Kind=|Len= |  ignored   |
    |  69 | N+2 | by TCP-ENO |
    +-----+-----+-----...----+
</artwork></figure>
<t>Every suboption starts with a byte of the form illustrated in
<xref target="fig:subopt"/>.  The high bit <spanx style="verb">v</spanx>, when set, introduces suboptions with
variable-length data.  When v = 0, the byte itself constitutes the
entirety of the suboption.  The remaining 7-bit value, called <spanx style="verb">glt</spanx>,
takes on various meanings as defined below:
</t>
<t>
<list style="symbols">
<t>Global configuration data (discussed in <xref target="the-global-suboption"/>)</t>
<t>Suboption data length for the next suboption (discussed in
<xref target="specifying-suboption-data-length"/>)</t>
<t>An offer to use a particular TEP defined in a separate TEP
specification document</t>
</list>
</t>

<figure anchor="fig:subopt" align="center" title="Format of Initial Suboption Byte"><artwork align="center">
bit   7   6   5   4   3   2   1   0
    +---+---+---+---+---+---+---+---+
    | v |            glt            |
    +---+---+---+---+---+---+---+---+

    v   - non-zero for use with variable-length suboption data
    glt - Global suboption, Length, or TEP identifier
</artwork></figure>
<t><xref target="tab:subopt"/> summarizes the meaning of initial suboption bytes.
Values of glt below 0x20 are used for global suboptions and length
information (the <spanx style="verb">gl</spanx> in <spanx style="verb">glt</spanx>), while those greater than or equal to
0x20 are TEP identifiers (the <spanx style="verb">t</spanx>).  When v = 0, since the initial
suboption byte constitutes the entirety of the suboption, all
information is expressed by the 7-bit glt value, which can be either
a global suboption or a TEP identifier.  When v = 1, it indicates a
suboption with variable-length suboption data.  Only TEP identifiers
have suboption data, not global suboptions.  Therefore, bytes with v = 1
and glt &lt; 0x20 are not global suboptions but rather length bytes
governing the length of the next suboption (which MUST be a TEP
identifier).  In the absence of a length byte, a TEP identifier
suboption with v = 1 has suboption data extending to the end of the
TCP option.
</t>
<texttable anchor="tab:subopt" title="Initial Suboption Byte Values
">
<ttcol align="left">glt</ttcol>
<ttcol align="left">v</ttcol>
<ttcol align="left">Meaning</ttcol>

<c>0x00-0x1f</c><c>0</c><c>Global suboption (<xref target="the-global-suboption"/>)</c>
<c>0x00-0x1f</c><c>1</c><c>Length byte (<xref target="specifying-suboption-data-length"/>)</c>
<c>0x20-0x7f</c><c>0</c><c>TEP identifier without suboption data</c>
<c>0x20-0x7f</c><c>1</c><c>TEP identifier followed by suboption data</c>
</texttable>
<t>A SYN segment MUST contain at most one TCP ENO option.  If a SYN
segment contains more than one ENO option, the receiver MUST behave as
though the segment contained no ENO options and disable encryption.  A
TEP MAY specify the use of multiple ENO options in a non-SYN segment.
For non-SYN segments, ENO itself only distinguishes between the
presence or absence of ENO options; multiple ENO options are
interpreted the same as one.
</t>
</section>

<section anchor="the-global-suboption" title="The Global Suboption">
<t>Suboptions 0x00-0x1f are used for global configuration that applies
regardless of the negotiated TEP.  A TCP SYN segment MUST include at
most one ENO suboption in this range.  A receiver MUST ignore all but
the first suboption in this range in any given TCP segment so as to
anticipate updates to ENO that assign new meaning to bits in
subsequent global suboptions.  The value of a global suboption byte is
interpreted as a bit mask, illustrated in <xref target="fig:config"/>.
</t>

<figure anchor="fig:config" align="center" title="Format of the Global Suboption Byte
"><artwork align="center">
bit   7   6   5   4   3   2   1   0
    +---+---+---+---+---+---+---+---+
    | 0 | 0 | 0 |z1 |z2 |z3 | a | b |
    +---+---+---+---+---+---+---+---+

    b  - Passive role bit
    a  - Application-aware bit
    z* - Zero bits (reserved for future use)
</artwork></figure>
<t>The fields of the bit mask are interpreted as follows:
</t>
<t>
<list style="hanging">
<t hangText="b">
<vspace />
The passive role bit MUST be 1 for all passive openers.  For active
openers, it MUST default to 0, but implementations MUST provide an API
through which an application can explicitly set b = 1 before
initiating an active open. (Manual configuration of <spanx style="verb">b</spanx> is only
necessary to enable encryption with a simultaneous open and requires
prior coordination to ensure exactly one endpoint sets b = 1 before
connecting.) See <xref target = "passive-role-bit"/> for further discussion.</t>
<t hangText="a">
<vspace />
Legacy applications can benefit from ENO-specific updates that
improve endpoint authentication or avoid double encryption.  The
application-aware bit <spanx style="verb">a</spanx> is an out-of-band signal through which
higher-layer protocols can enable ENO-specific updates that would
otherwise not be backwards compatible.  Implementations MUST set this
bit to zero by default, and MUST provide an API through which
applications can change the value of the bit as well as examine the
value of the bit sent by the remote host.  Implementations MUST
furthermore support a mandatory application-aware mode in which
TCP-ENO is automatically disabled if the remote host does not set a =
1. See <xref target="applicationaware-bit"/> for further discussion.</t>
<t hangText="z1, z2, z3">
<vspace />
The <spanx style="verb">z</spanx> bits are reserved for future updates to TCP-ENO.  They MUST
be set to zero in sent segments and MUST be ignored in received
segments.</t>
</list>
</t>
<t>A SYN segment without an explicit global suboption has an implicit
global suboption of 0x00.  Because passive openers MUST always set b
= 1, they cannot rely on this implicit 0x00 byte and MUST include an
explicit global suboption in their SYN-ACK segments.
</t>
</section>

<section anchor="tcpeno-roles" title="TCP-ENO Roles">
<t>TCP-ENO uses abstract roles called &quot;A&quot; and &quot;B&quot; to distinguish the two
ends of a TCP connection.  These roles are determined by the <spanx style="verb">b</spanx> bit
in the global suboption.  The host that sent an implicit or explicit
suboption with b = 0 plays the A role.  The host that sent b = 1
plays the B role.  Because a passive opener MUST set b = 1 and an
active opener by default has b = 0, the normal case is for the
active opener to play role A and the passive opener role B.
</t>
<t>Applications performing a simultaneous open, if they desire TCP-level
encryption, need to arrange for exactly one endpoint to set b = 1
(despite being an active opener) while the other endpoint keeps the
default b = 0.  Otherwise, if both sides use the default b = 0 or
if both sides set b = 1, then TCP-ENO will fail and fall back to
unencrypted TCP.  Likewise, if an active opener explicitly configures
b = 1 and connects to a passive opener (which MUST always have b =
1), then TCP-ENO will fail and fall back to unencrypted TCP.
</t>
<t>TEP specifications SHOULD refer to TCP-ENO's A and B roles to specify
asymmetric behavior by the two hosts.  For the remainder of this
document, we will use the terms &quot;host A&quot; and &quot;host B&quot; to designate the
hosts with roles A and B, respectively, in a connection.
</t>
</section>

<section anchor="specifying-suboption-data-length" title="Specifying Suboption Data Length">
<t>A TEP MAY optionally make use of one or more bytes of suboption data.
The presence of such data is indicated by setting v = 1 in the
initial suboption byte (see <xref target="fig:subopt"/>).  A suboption introduced by
a TEP identifier with v = 1 (i.e., a suboption whose first octet has
value 0xa0 or higher) extends to the end of the TCP option.  Hence, if
only one suboption requires data, the most compact way to encode it is
to place it last in the ENO option, after all other suboptions. In <xref
target="fig:eno"/>, for example, the last suboption, Opt_i, has suboption
data and thus requires v = 1. However, the suboption data length is
inferred from the total length of the TCP option.
</t>
<t>When a suboption with data is not last in an ENO option, the sender
MUST explicitly specify the suboption data length for the receiver to
know where the next suboption starts.  The sender does so by
introducing the suboption with a length byte, depicted in
<xref target="fig:marker"/>.  The length byte encodes a 5-bit value nnnnn.  Adding
one to nnnnn yields the length of the suboption data (not including
the length byte or the TEP identifier).  Hence, a length byte can
designate anywhere from 1 to 32 bytes of suboption data (inclusive).
</t>

<figure anchor="fig:marker" align="center" title="Format of a Length Byte
"><artwork align="center">
bit   7   6   5   4   3   2   1   0
    +---+---+---+-------------------+
    | 1   0   0         nnnnn       |
    +---+---+---+-------------------+

    nnnnn - 5-bit value encoding (length - 1)
</artwork></figure>
<t>A suboption preceded by a length byte MUST be a TEP identifier
(glt &gt;= 0x20) and MUST have v = 1.  <xref target="fig:suboption-with-length-byte"/>
shows an example of such a suboption.
</t>

<figure anchor="fig:suboption-with-length-byte" align="center" title="Suboption with Length Byte
"><artwork align="center">
byte    0      1       2      nnnnn+2  (nnnnn+3 bytes total)
     +------+------+-------...-------+
     |length| TEP  | suboption data  |
     | byte |ident.| (nnnnn+1 bytes) |
     +------+------+-------...-------+

     length byte    - specifies nnnnn
     TEP identifier - MUST have v = 1 and glt &gt;= 0x20
     suboption data - length specified by nnnnn+1
</artwork></figure>
<t>A host MUST ignore an ENO option in a SYN segment and MUST disable
encryption if either of the following apply:
</t>
<t>
<list style="numbers">
<t>A length byte indicates that suboption data would extend beyond the
end of the TCP ENO option.</t>
<t>A length byte is followed by an octet in the range 0x00-0x9f
(meaning the following byte has v = 0 or glt &lt; 0x20).</t>
</list>
</t>
<t>Because the last suboption in an ENO option is special-cased to have
its length inferred from the 8-bit TCP option length, it MAY contain
more than 32 bytes of suboption data.  Other suboptions are limited to
32 bytes by the length byte format. However, the TCP header itself can only
accommodate a maximum of 40 bytes of options.  Therefore,
regardless of the length byte format, a segment would not be able to
contain more than one suboption over 32 bytes in size.  That said,
TEPs MAY define the use of multiple suboptions with the same TEP
identifier in the same SYN segment, providing another way to convey
over 32 bytes of suboption data even with length bytes.
</t>
</section>

<section anchor="the-negotiated-tep" title="The Negotiated TEP">
<t>A TEP identifier glt (with glt &gt;= 0x20) is valid for a
connection when all of the following hold:
</t>
<t>
<list style="numbers">
<t>Each side has sent a suboption for glt in its SYN-form ENO option.</t>
<t>Any suboption data in these glt suboptions is valid according to
the TEP specification and satisfies any runtime constraints.</t>
<t>If an ENO option contains multiple suboptions with glt, then such
repetition is well-defined by the TEP specification.</t>
</list>
</t>
<t>A passive opener (which is always host B) sees the remote host's SYN
segment before constructing its own SYN-ACK segment.  Therefore, a passive
opener SHOULD include only one TEP identifier in SYN-ACK segments and
SHOULD ensure this TEP identifier is valid.  However, simultaneous
open or implementation considerations can prevent host B from offering
only one TEP.
</t>
<t>To accommodate scenarios in which host B sends multiple TEP
identifiers in the SYN-ACK segment, the negotiated TEP is defined as
the last valid TEP identifier in host B's SYN-form ENO option.  This
definition means host B specifies TEP suboptions in order of
increasing priority, while host A does not influence TEP priority.
</t>
</section>

<section anchor="tcpeno-handshake" title="TCP-ENO Handshake">
<t>A host employing TCP-ENO for a connection MUST include an ENO option
in every TCP segment sent until either encryption is disabled or the
host receives a non-SYN segment.  

In particular, this means an active
opener MUST include a non-SYN-form ENO option in the third segment of
a three-way handshake.
</t>
<t>A host MUST disable encryption, refrain from sending any further ENO
options, and fall back to unencrypted TCP if any of the following
occurs:
</t>
<t>
<list style="numbers">
<t>Any segment it receives up to and including the first received ACK
segment does not contain an ENO option (or contains an ill-formed
SYN-form ENO option).</t>
<t>The SYN segment it receives does not contain a valid TEP
identifier.</t>
<t>It receives a SYN segment with an incompatible global suboption.
(Specifically, "incompatible" means the two hosts set the same <spanx style="verb">b</spanx>
value, or the connection is in mandatory application-aware mode and
the remote host set a = 0.)</t>
</list>
</t>
<t>Hosts MUST NOT alter SYN-form ENO options in retransmitted segments,
or between the SYN and SYN-ACK segments of a simultaneous open, with
two exceptions for an active opener.  First, an active opener MAY
unilaterally disable ENO (and thus remove the ENO option) between
retransmissions of a SYN-only segment. (Such removal could enable
recovery from middleboxes dropping segments with ENO options.)
Second, an active opener performing simultaneous open MAY include no
TCP-ENO option in its SYN-ACK if the received SYN caused it to disable
encryption according to the above rules (for instance, because role
negotiation failed).
</t>
<t>Once a host has both sent and received an ACK segment containing an
ENO option, encryption MUST be enabled.  Once encryption is enabled,
hosts MUST follow the specification of the negotiated TEP and MUST NOT
present raw TCP payload data to the application.  In particular, data
segments MUST NOT contain plaintext application data, but rather
ciphertext, key negotiation parameters, or other messages as
determined by the negotiated TEP.
</t>
<t>A host MAY send a SYN-form ENO option containing zero TEP identifier
suboptions, which we term a "vacuous" ENO option.  If either host's
SYN segment contains a vacuous ENO option, it follows that there are
no valid TEP identifiers for the connection, and therefore the connection
MUST fall back to unencrypted TCP.  Hosts MAY send vacuous ENO options
to indicate that ENO is supported but unavailable by configuration, or
to probe network paths for robustness to ENO options.  However, a
passive opener MUST NOT send a vacuous ENO option in a SYN-ACK segment
unless there was an ENO option in the SYN segment it received.
Moreover, a passive opener's SYN-form ENO option MUST still include a
global suboption with b = 1 as discussed in <xref target="tcpeno-roles"/>.
</t>
</section>

<section anchor="data-in-syn-segments" title="Data in SYN Segments">
<t>TEPs MAY specify the use of data in SYN segments so as to reduce the
number of round trips required for connection setup.  The meaning of
data in a SYN segment with an ENO option (a SYN+ENO segment) is
determined by the last TEP identifier in the ENO option, which we term
the segment's "SYN TEP".  A SYN+ENO segment MAY of course include
multiple TEP suboptions, but only the SYN TEP (i.e., the last one)
specifies how to interpret the SYN segment's data payload.
</t>
<t>A host sending a SYN+ENO segment MUST NOT include data in the segment
unless the SYN TEP's specification defines the use of such data.
Furthermore, to avoid conflicting interpretations of SYN data, a
SYN+ENO segment MUST NOT include a non-empty TCP Fast Open (TFO) option
<xref target="RFC7413"/>.
</t>
<t>Because a host can send SYN data before knowing which if any TEP the
connection will negotiate, hosts implementing ENO are REQUIRED to
discard data from SYN+ENO segments when the SYN TEP does not become
the negotiated TEP.  Hosts are furthermore REQUIRED to discard SYN
data in cases where another Internet standard specifies a conflicting
interpretation of SYN data (as would occur when receiving a non-empty
TFO option).  This requirement applies to hosts that implement ENO
even when ENO has been disabled by configuration.  However, note that
discarding SYN data is already common practice <xref target="RFC4987"/> and the new
requirement applies only to segments containing ENO options.
</t>
<t>More specifically, a host that implements ENO MUST discard the data in
a received SYN+ENO segment if any of the following applies:
</t>
<t>
<list style="symbols">
<t>ENO fails and TEP-indicated encryption is disabled for the
connection.</t>
<t>The received segment's SYN TEP is not the negotiated TEP.</t>
<t>The negotiated TEP does not define the use of SYN data.</t>
<t>The SYN segment contains a non-empty TFO option or any other TCP
option implying a conflicting definition of SYN data.</t>
</list>
</t>
<t>A host discarding SYN data in compliance with the above requirement
MUST NOT acknowledge the sequence number of the discarded data, but
rather MUST acknowledge the other host's initial sequence number as if
the received SYN segment contained no data.  Furthermore, after
discarding SYN data, such a host MUST NOT assume the SYN data will be
identically retransmitted, and MUST process data only from non-SYN
segments.
</t>
<t>If a host sends a SYN+ENO segment with data and receives
acknowledgment for the data, but the SYN TEP in its transmitted SYN
segment is not the negotiated TEP (either because a different TEP was
negotiated or because ENO failed to negotiate encryption), then the
host MUST abort the TCP connection.  Proceeding in any other fashion
risks misinterpreted SYN data.
</t>
<t>If a host sends a SYN-only SYN+ENO segment bearing data and
subsequently receives a SYN-ACK segment without an ENO option, that
host MUST abort the connection even if the SYN-ACK segment does not
acknowledge the SYN data.  The issue is that unacknowledged data could
nonetheless have been cached by the receiver; later retransmissions
intended to supersede this unacknowledged data could fail to do so if
the receiver gives precedence to the cached original data.
Implementations MAY provide an API call for a non-default mode in
which unacknowledged SYN data does not cause a connection abort, but
applications MUST use this mode only when a higher-layer integrity
check would anyway terminate a garbled connection.
</t>
<t>To avoid unexpected connection aborts, ENO implementations MUST
disable the use of data in SYN-only segments by default.  Such data
MAY be enabled by an API command.  In particular, implementations MAY
provide a per-connection mandatory encryption mode that automatically
aborts a connection if ENO fails, and they MAY enable SYN data in this
mode.
</t>
<t>To satisfy the requirement of the previous paragraph, all TEPs SHOULD
support a normal mode of operation that avoids data in SYN-only
segments.  An exception is TEPs intended to be disabled by default.
</t>
</section>

<section anchor="negotiation-transcript" title="Negotiation Transcript">
<t>To defend against attacks on encryption negotiation itself, a TEP MUST,
with high probability, fail to establish a working connection between
two ENO-compliant hosts when SYN-form ENO options have been altered in
transit. (Of course, in the absence of endpoint authentication, two
compliant hosts can each still be connected to a man-in-the-middle
attacker.)  To detect SYN-form ENO option tampering, TEPs MUST
reference a transcript of TCP-ENO's negotiation.
</t>
<t>TCP-ENO defines its negotiation transcript as a packed data structure
consisting of two TCP-ENO options exactly as they appeared in the TCP
header (including the TCP option kind and TCP option length byte as
illustrated in <xref target="fig:option"/>).  The transcript is constructed from the
following, in order:
</t>
<t>
<list style="numbers">
<t>The TCP-ENO option in host A's SYN segment, including the kind and
length bytes</t>
<t>The TCP-ENO option in host B's SYN segment, including the kind and
length bytes</t>
</list>
</t>
<t>Note that because the ENO options in the transcript contain length
bytes as specified by TCP, the transcript unambiguously delimits A's
and B's ENO options.
</t>
</section>
</section>

<section anchor="requirements-for-teps" title="Requirements for TEPs">
<t>TCP-ENO affords TEP specifications a large amount of design
flexibility.  However, to abstract TEP differences away from
applications requires fitting them all into a coherent framework.  As
such, any TEP claiming an ENO TEP identifier MUST satisfy the
following normative list of properties:
</t>
<t>
<list style="symbols">
<t>TEPs MUST protect TCP data streams with authenticated encryption.
(Note that "authenticated encryption" refers only to the form of
encryption, such as an Authenticated Encryption with Associated Data (AEAD) algorithm meeting the requirements of
<xref target="RFC5116"/>; it does not imply endpoint authentication.)</t>
<t>TEPs MUST define a session ID whose value identifies the TCP
connection and, with overwhelming probability, is unique over all
time if either host correctly obeys the TEP.  <xref target="session-ids"/>
describes the requirements of the session ID in more detail.</t>
<t>TEPs MUST NOT make data confidentiality dependent on encryption
algorithms with a security strength <xref target="NIST-SP-800-57"/> of less than
120 bits.  The number 120 was chosen to accommodate ciphers with
128-bit keys that lose a few bits of security either to
particularities of the key schedule or to highly theoretical and
unrealistic attacks.</t>
<t>TEPs MUST NOT allow the negotiation of null cipher suites, even for
debugging purposes.  (Implementations MAY support debugging modes
that allow applications to extract their own session keys.)</t>
<t>TEPs MUST guarantee the confidentiality of TCP streams without
assuming the security of any long-lived secrets.  Implementations
SHOULD provide forward secrecy soon after the close of a TCP
connection and SHOULD therefore bound the delay between closing a
connection and erasing any relevant cryptographic secrets.
(Exceptions to forward secrecy are permissible only at the
implementation level and only in response to hardware or
architectural constraints -- e.g., storage that cannot be securely
erased.)</t>
<t>TEPs MUST protect and authenticate the end-of-file marker conveyed
by TCP's FIN flag.  In particular, a receiver MUST, with overwhelming
probability, detect a FIN flag that was set or cleared in transit and
does not match the sender's intent.  A TEP MAY discard a segment
with such a corrupted FIN bit or MAY abort the connection in
response to such a segment.  However, any such abort MUST raise an
error condition distinct from an authentic end-of-file condition.</t>
<t>TEPs MUST prevent corrupted packets from causing urgent data to be
delivered when none has been sent.  There are several ways to do so.
For instance, a TEP MAY cryptographically protect the URG flag and
urgent pointer alongside ordinary payload data.  Alternatively, a
TEP MAY disable urgent data functionality by clearing the URG flag
on all received segments and returning errors in response to
sender-side urgent-data API calls.  Implementations SHOULD avoid
negotiating TEPs that disable urgent data by default.  The exception
is when applications and protocols are known never to send urgent
data.</t>
</list>
</t>

<section anchor="session-ids" title="Session IDs">
<t>Each TEP MUST define a session ID that is computable by both endpoints
and uniquely identifies each encrypted TCP connection.
Implementations MUST expose the session ID to applications via an API
extension.  The API extension MUST return an error when no session ID
is available because ENO has failed to negotiate encryption or because
no connection is yet established.  Applications that are aware of
TCP-ENO SHOULD, when practical, authenticate the TCP endpoints by
incorporating the values of the session ID and TCP-ENO role (A or B)
into higher-layer authentication mechanisms.
</t>
<t>In order to avoid replay attacks and prevent authenticated session IDs
from being used out of context, session IDs MUST be unique over all
time with high probability.  This uniqueness property MUST hold even
if one end of a connection maliciously manipulates the protocol in an
effort to create duplicate session IDs.  In other words, it MUST be
infeasible for a host, even by violating the TEP specification, to
establish two TCP connections with the same session ID to remote hosts
properly implementing the TEP.
</t>
<t>To prevent session IDs from being confused across TEPs, all session
IDs begin with the negotiated TEP identifier -- that is, the last valid
TEP identifier in host B's SYN segment.  Furthermore, this initial byte
has bit <spanx style="verb">v</spanx> set to the same value that accompanied the negotiated TEP
identifier in B's SYN segment.  However, only this single byte is
included, not any suboption data.  <xref target="fig:sessid"/> shows the resulting
format.  This format is designed for TEPs to compute unique
identifiers; it is not intended for application authors to pick apart
session IDs.  Applications SHOULD treat session IDs as monolithic
opaque values and SHOULD NOT discard the first byte to shorten
identifiers. (An exception is for non-security-relevant purposes,
such as gathering statistics about negotiated TEPs.)
</t>

<figure anchor="fig:sessid" align="center" title="Format of a Session ID
"><artwork align="center">
byte    0     1     2        N-1    N
     +-----+------------...------------+
     | sub-| collision-resistant hash  |
     | opt | of connection information |
     +-----+------------...------------+
</artwork></figure>
<t>Though TEP specifications retain considerable flexibility in their
definitions of the session ID, all session IDs MUST meet the following
normative list of requirements:
</t>
<t>
<list style="symbols">
<t>The session ID MUST be at least 33 bytes (including the one-byte
suboption), though TEPs MAY choose longer session IDs.</t>
<t>The session ID MUST depend, in a collision-resistant way, on all of
the following (meaning it is computationally infeasible to produce
collisions of the session ID derivation function unless all of the
following quantities are identical):
<list style="symbols">
<t>Fresh data contributed by both sides of the connection</t>
<t>Any public keys, public Diffie-Hellman parameters, or other
public asymmetric cryptographic parameters that are employed by
the TEP and have corresponding private data that is known by
only one side of the connection</t>
<t>The negotiation transcript specified in
<xref target="negotiation-transcript"/></t>
</list></t>
<t>Unless and until applications disclose information about the session
ID, all but the first byte MUST be computationally indistinguishable
from random bytes to a network eavesdropper.</t>
<t>Applications MAY choose to make session IDs public.  Therefore, TEPs
MUST NOT place any confidential data in the session ID (such as data
permitting the derivation of session keys).</t>
</list>
</t>
</section>
</section>

<section anchor="examples" title="Examples">
<t>This subsection illustrates the TCP-ENO handshake with a few
non-normative examples.
</t>

<figure anchor="fig:handshake" align="center" title="Three-Way Handshake with Successful TCP-ENO Negotiation
"><artwork align="center">
(1) A -&gt; B:  SYN      ENO&lt;X,Y&gt;
(2) B -&gt; A:  SYN-ACK  ENO&lt;b=1,Y&gt;
(3) A -&gt; B:  ACK      ENO&lt;&gt;
[rest of connection encrypted according to TEP Y]
</artwork></figure>
<t><xref target="fig:handshake"/> shows a three-way handshake with a successful TCP-ENO
negotiation.  Host A includes two ENO suboptions with TEP identifiers
X and Y.  Host A does not include an explicit global suboption, which
means it has an implicit global suboption 0x00 conveying passive role
bit b = 0.  The two sides agree to follow the TEP identified by
suboption Y.
</t>

<figure anchor="fig:bad-handshake" align="center" title="Three-Way Handshake with Failed TCP-ENO Negotiation
"><artwork align="center">
(1) A -&gt; B:  SYN      ENO&lt;X,Y&gt;
(2) B -&gt; A:  SYN-ACK
(3) A -&gt; B:  ACK
[rest of connection unencrypted legacy TCP]
</artwork></figure>

<t><xref target="fig:bad-handshake"/> shows a failed TCP-ENO negotiation.  The active
opener (A) indicates support for TEPs corresponding to suboptions X
and Y.  Unfortunately, at this point, one of several things occurs:
</t>
<t>
<list style="numbers">
<t>The passive opener (B) does not support TCP-ENO.</t>
<t>B supports TCP-ENO but supports neither of the TEPs X and Y, and so it
does not reply with an ENO option.</t>
<t>B supports TCP-ENO but has the connection configured in mandatory
application-aware mode and thus disables ENO because A's SYN
segment contains an implicit global suboption with a = 0.</t>
<t>The network stripped the ENO option out of A's SYN segment, so B
did not receive it.</t>
</list>
</t>
<t>Whichever of the above applies, the connection transparently falls
back to unencrypted TCP.
</t>

<figure anchor="fig:filter" align="center" title="Failed TCP-ENO Negotiation Because of Option Stripping
"><artwork align="center">
(1) A -&gt; B:  SYN      ENO&lt;X,Y&gt;
(2) B -&gt; A:  SYN-ACK  ENO&lt;b=1,X&gt; [ENO stripped by middlebox]
(3) A -&gt; B:  ACK
[rest of connection unencrypted legacy TCP]
</artwork></figure>
<t><xref target="fig:filter"/> Shows another handshake with a failed encryption
negotiation.  In this case, the passive opener (B) receives an ENO
option from A and replies.  However, the reverse network path from B
to A strips ENO options.  Therefore, A does not receive an ENO option from
B, it disables ENO, and it does not include a non-SYN-form ENO option in
segment 3 when ACKing B's SYN.  Had A not disabled encryption,
<xref target="tcpeno-handshake"/> would have required it to include a non-SYN-form ENO
option in segment 3.  The omission of this option informs B that
encryption negotiation has failed, after which the two hosts proceed
with unencrypted TCP.
</t>

<figure anchor="fig:simultaneous" align="center" title="Simultaneous Open with Successful TCP-ENO Negotiation
"><artwork align="center">
(1) A -&gt; B:  SYN      ENO&lt;Y,X&gt;
(2) B -&gt; A:  SYN      ENO&lt;b=1,X,Y,Z&gt;
(3) A -&gt; B:  SYN-ACK  ENO&lt;Y,X&gt;
(4) B -&gt; A:  SYN-ACK  ENO&lt;b=1,X,Y,Z&gt;
[rest of connection encrypted according to TEP Y]
</artwork></figure>
<t><xref target="fig:simultaneous"/> shows a successful TCP-ENO negotiation with
simultaneous open.  Here, the first four segments contain a SYN-form
ENO option, as each side sends both a SYN-only and a SYN-ACK segment.
The ENO option in each host's SYN-ACK is identical to the ENO option
in its SYN-only segment, as otherwise, connection establishment could
not recover from the loss of a SYN segment.  The last valid TEP in
host B's ENO option is Y, so Y is the negotiated TEP.
</t>
</section>

<section anchor="future-developments" title="Future Developments">
<t>TCP-ENO is designed to capitalize on future developments that could
alter trade-offs and change the best approach to TCP-level encryption
(beyond introducing new cipher suites).  By way of example, we discuss
a few such possible developments.
</t>
<t>Various proposals exist to increase the maximum space for options in
the TCP header.  These proposals are highly experimental -- particularly
those that apply to SYN segments.  Therefore, future TEPs are unlikely to
benefit from extended SYN option space.  In the unlikely event that
SYN option space is one day extended, however, future TEPs could
benefit by embedding key agreement messages directly in SYN segments.
Under such usage, the 32-byte limit on length bytes could prove
insufficient.  This document intentionally aborts TCP-ENO if a length
byte is followed by an octet in the range 0x00-0x9f.  If necessary, a
future update to this document can define a format for larger
suboptions by assigning meaning to such currently undefined byte
sequences.
</t>
<t>New revisions to socket interfaces <xref target="RFC3493"/> could involve library
calls that simultaneously have access to hostname information and an
underlying TCP connection.  Such an API enables the possibility of
authenticating servers transparently to the application, particularly
in conjunction with technologies such as DNS-Based Authentication of Named
Entities (DANE) <xref target="RFC6394"/>.  An update
to TCP-ENO can adopt one of the <spanx style="verb">z</spanx> bits in the global suboption to
negotiate the use of an endpoint authentication protocol before any
application use of the TCP connection.  Over time, the consequences of
failed or missing endpoint authentication can gradually be increased
from issuing log messages to aborting the connection if some as yet
unspecified DNS record indicates authentication is mandatory.  Through
shared library updates, such endpoint authentication can potentially
be added transparently to legacy applications without recompilation.
</t>
<t>TLS can currently only be added to legacy applications whose protocols
accommodate a STARTTLS command or equivalent.  TCP-ENO, because it
provides out-of-band signaling, opens the possibility of future TLS
revisions being generically applicable to any TCP application.
</t>
</section>

<section anchor="design-rationale" title="Design Rationale">
<t>This section describes some of the design rationale behind TCP-ENO.
</t>

<section anchor="handshake-robustness" title="Handshake Robustness">
<t>Incremental deployment of TCP-ENO depends critically on failure cases
devolving to unencrypted TCP rather than causing the entire TCP
connection to fail.
</t>
<t>Because a network path might drop ENO options in one direction only, a
host needs to know not just that the peer supports encryption, but
that the peer has received an ENO option.  To this end, ENO disables
encryption unless it receives an ACK segment bearing an ENO option.
To stay robust in the face of dropped segments, hosts continue to
include non-SYN-form ENO options in segments until the point that they have
received a non-SYN segment from the other side.
</t>
<t>One particularly pernicious middlebox behavior found in the wild is
load balancers that echo unknown TCP options found in SYN segments
back to an active opener.  The passive role bit <spanx style="verb">b</spanx> in global
suboptions ensures encryption will always be disabled under such
circumstances, as sending back a verbatim copy of an active opener's
SYN-form ENO option always causes role negotiation to fail.
</t>
</section>

<section anchor="suboption-data" title="Suboption Data">
<t>TEPs can employ suboption data for session caching, cipher suite
negotiation, or other purposes.  However, TCP currently limits total
option space consumed by all options to only 40 bytes, making it
impractical to have many suboptions with data.  For this reason, ENO
optimizes the case of a single suboption with data by inferring the
length of the last suboption from the TCP option length.  Doing so
saves one byte.
</t>
</section>

<section anchor="passive-role-bit" title="Passive Role Bit">
<t>TCP-ENO, TEPs, and applications all have asymmetries that require an
unambiguous way to identify one of the two connection endpoints.  As
an example, <xref target="negotiation-transcript"/> specifies that host A's ENO
option comes before host B's in the negotiation transcript.  As
another example, an application might need to authenticate one end of
a TCP connection with a digital signature.  To ensure the signed
message cannot be interpreted out of context to authenticate the
other end, the signed message would need to include both the session
ID and the local role, A or B.
</t>
<t>A normal TCP three-way handshake involves one active and one passive
opener.  This asymmetry is captured by the default configuration of
the <spanx style="verb">b</spanx> bit in the global suboption.  With simultaneous open, both
hosts are active openers, so TCP-ENO requires that one host explicitly
configure b = 1.  An alternate design might automatically break the
symmetry to avoid this need for explicit configuration.  However, all
such designs we considered either lacked robustness or consumed
precious bytes of SYN option space even in the absence of simultaneous
open. (One complicating factor is that TCP does not know it is
participating in a simultaneous open until after it has sent a SYN
segment.  Moreover, with packet loss, one host might never learn it
has participated in a simultaneous open.)
</t>
</section>

<section anchor="applicationaware-bit" title="Application-Aware Bit">
<t>Applications developed before TCP-ENO can potentially evolve to take
advantage of TCP-level encryption.  For instance, an application
designed to run only on trusted networks might leverage TCP-ENO to run
on untrusted networks, but, importantly, needs to authenticate
endpoints and session IDs to do so.  In addition to user-visible
changes such as requesting credentials, this kind of authentication
functionality requires application-layer protocol changes.  Some
protocols can accommodate the requisite changes -- for instance, by
introducing a new verb analogous to STARTTLS, while others cannot do
so in a backwards-compatible manner.
</t>
<t>The application-aware bit <spanx style="verb">a</spanx> in the global suboption provides a
means of incrementally deploying enhancements specific to TCP-ENO to
application-layer protocols that would otherwise lack the necessary
extensibility.  Software implementing the enhancement always sets a =
1 in its own global suboption, but only activates the new behavior
when the other end of the connection also sets a = 1.
</t>

<t>A related issue is that an application might leverage TCP-ENO as a
replacement for legacy application-layer encryption.  In this
scenario, if both endpoints support TCP-ENO, then application-layer
encryption can be disabled in favor of simply authenticating the
TCP-ENO session ID.  On the other hand, if one endpoint is not aware
of the new mode of operation specific to TCP-ENO, there is little benefit
to performing redundant encryption at the TCP layer; data is already
encrypted once at the application layer, and authentication only has meaning
with respect to this application-layer encryption. The mandatory
application-aware mode lets applications avoid double encryption in
this case: the mode sets a = 1 in the local host's global suboption
but also disables TCP-ENO entirely in the event that the other side
has not also set a = 1.
</t>
<t>Note that the application-aware bit is not needed by applications that
already support adequate higher-layer encryption such as those provided by
TLS <xref target="RFC8446"/> or SSH <xref target="RFC4253"/>.  To avoid double
encryption in
such cases, it suffices to disable TCP-ENO by configuration on any
ports with known secure protocols.
</t>
</section>

<section anchor="use-of-eno-option-kind-by-teps" title="Use of ENO Option Kind by TEPs">
<t>This document does not specify the use of ENO options beyond the first
few segments of a connection.  Moreover, it does not specify the
content of ENO options in non-SYN segments, only their presence.  As a
result, any use of option kind 69 after the SYN exchange does not
conflict with this document.  In addition, because ENO guarantees at
most one negotiated TEP per connection, TEPs will not conflict with
one another or ENO if they use option kind 69 for out-of-band
signaling in non-SYN segments.
</t>
</section>

<section anchor="unpredictability-of-session-ids" title="Unpredictability of Session IDs">
<t><xref target="session-ids"/> specifies that all but the first (TEP identifier) byte
of a session ID MUST be computationally indistinguishable from random
bytes to a network eavesdropper.  This property is easy to ensure
under standard assumptions about cryptographic hash functions.  Such
unpredictability helps security in a broad range of cases.  For
example, it makes it possible for applications to use a session ID
from one connection to authenticate a session ID from another, thereby
tying the two connections together.  It furthermore helps ensure that
TEPs do not trivially subvert the 33-byte minimum-length requirement
for session IDs by padding shorter session IDs with zeros.
</t>
</section>
</section>

<section anchor="experiments" title="Experiments">
<t>This document has experimental status because TCP-ENO's viability
depends on middlebox behavior that can only be determined a
posteriori.  Specifically, we need to determine to what extent
middleboxes will permit the use of TCP-ENO.  Once TCP-ENO is deployed,
we will be in a better position to gather data on two types of
failure:
</t>
<t>
<list style="numbers">
<t>Middleboxes downgrading TCP-ENO connections to unencrypted TCP.
This can happen if middleboxes strip unknown TCP options or if they
terminate TCP connections and relay data back and forth.</t>
<t>Middleboxes causing TCP-ENO connections to fail completely.  This
can happen if middleboxes perform deep packet inspection and start
dropping segments that unexpectedly contain ciphertext, or if
middleboxes strip ENO options from non-SYN segments after allowing
them in SYN segments.</t>
</list>
</t>
<t>Type-1 failures are tolerable since TCP-ENO is designed for
incremental deployment anyway.  Type-2 failures are more problematic,
and, if prevalent, will require the development of techniques to avoid
and recover from such failures.  The experiment will succeed so long
as we can avoid type-2 failures and find sufficient use cases that
avoid type-1 failures (possibly along with a gradual path for further
reducing type-1 failures).
</t>
<t>In addition to the question of basic viability, deploying TCP-ENO will
allow us to identify and address other potential corner cases or
relaxations.  For example, does the slight decrease in effective TCP
segment payload pose a problem to any applications, which would require
restrictions on how TEPs interpret socket buffer sizes?  Conversely,
can we relax the prohibition on default TEPs that disable urgent data?
</t>
<t>A final important metric, related to the pace of deployment and
incidence of type-1 failures, will be the extent to which applications
adopt enhancements specific to TCP-ENO for endpoint authentication.
</t>
</section>

<section anchor="security-considerations" title="Security Considerations">
<t>An obvious use case for TCP-ENO is opportunistic encryption, e.g.,
encrypting some connections, but only where supported and without any
kind of endpoint authentication.  Opportunistic encryption provides a
property known as "opportunistic security" <xref target="RFC7435"/>, which protects
against undetectable large-scale eavesdropping.  However, it does not
protect against detectable large-scale eavesdropping (for instance, if
ISPs terminate TCP connections and proxy them or simply downgrade
connections to unencrypted).  Moreover, opportunistic encryption
emphatically does not protect against targeted attacks that employ
trivial spoofing to redirect a specific high-value connection to a
man-in-the-middle attacker.  Hence, the mere presence of TEP-indicated
encryption does not suffice for an application to represent a
connection as secure to the user.
</t>
<t>Achieving stronger security with TCP-ENO requires verifying session
IDs.  Any application relying on ENO for communication security MUST
incorporate session IDs into its endpoint authentication.  By way of
example, an authentication mechanism based on keyed digests (such as
Digest Access Authentication <xref target="RFC7616"/>) can be extended to include
the role and session ID in the input of the keyed digest.
Authentication mechanisms with a notion of channel binding (such as
Salted Challenge Response Authentication Mechanism (SCRAM) <xref target="RFC5802"/>) can be updated to derive a channel binding from the
session ID.  Higher-layer protocols MAY use the application-aware <spanx style="verb">a</spanx>
bit to negotiate the inclusion of session IDs in authentication even
when there is no in-band way to carry out such a negotiation.  Because
there is only one <spanx style="verb">a</spanx> bit, however, a protocol extension that
specifies use of the <spanx style="verb">a</spanx> bit will likely require a built-in versioning
or negotiation mechanism to accommodate crypto agility and future
updates.
</t>
<t>Because TCP-ENO enables multiple different TEPs to coexist, security
could potentially be only as strong as the weakest available TEP.  In
particular, if TEPs use a weak hash function to incorporate the
TCP-ENO transcript into session IDs, then an attacker can undetectably
tamper with ENO options to force negotiation of a deprecated and
vulnerable TEP.  To avoid such problems, security reviewers of new
TEPs SHOULD pay particular attention to the collision resistance of
hash functions used for session IDs (including the state of
cryptanalysis and research into possible attacks).  Even if other
parts of a TEP rely on more esoteric cryptography that turns out to be
vulnerable, it ought nonetheless to be intractable for an attacker to
induce identical session IDs at both ends after tampering with ENO
contents in SYN segments.
</t>
<t>Implementations MUST NOT send ENO options unless they have access to
an adequate source of randomness <xref target="RFC4086"/>.  Without secret
unpredictable data at both ends of a connection, it is impossible for
TEPs to achieve confidentiality and forward secrecy.  Because systems
typically have very little entropy on bootup, implementations might
need to disable TCP-ENO until after system initialization.
</t>
<t>With a regular three-way handshake (meaning no simultaneous open), the
non-SYN-form ENO option in an active opener's first ACK segment MAY
contain N &gt; 0 bytes of TEP-specific data, as shown in <xref target="fig:minimal"/>.
Such data is not part of the TCP-ENO negotiation transcript and therefore
MUST be separately authenticated by the TEP.
</t>
</section>

<section anchor="iana-considerations" title="IANA Considerations">

<t>This document defines a new TCP option kind for TCP-ENO, assigned a
value of 69 from the TCP option space.  This value is defined as:
</t>
<texttable anchor="tab:kind_numbers" title="TCP Option Kind Numbers">
<ttcol align="left">Kind</ttcol>
<ttcol align="left">Length</ttcol>
<ttcol align="left">Meaning</ttcol>
<ttcol align="left">Reference</ttcol>

<c>69</c><c>N</c><c>Encryption Negotiation (TCP-ENO)</c><c>RFC 8547</c>
</texttable>
<t>Early implementations of TCP-ENO and a predecessor TCP encryption
protocol made unauthorized use of TCP option kind 69.
These earlier uses of option 69 are not compatible with TCP-ENO and
could disable encryption or suffer complete connection failure when
interoperating with TCP-ENO-compliant hosts.  Hence, legacy use of
option 69 MUST be disabled on hosts that cannot be upgraded to
TCP-ENO.

More recent implementations used experimental option 253 per
<xref target="RFC6994"/> with 16-bit ExID 0x454E.  Current and new implementations
of TCP-ENO MUST use option 69, while any legacy implementations MUST
migrate to option 69.  Note in particular that <xref target="eno-option"/> requires
at most one SYN-form ENO option per segment, which means hosts MUST
NOT include both option 69 and option 253 with ExID 0x454E in the
same TCP segment.
</t>


<t>This document defines a 7-bit glt field in the range of 0x20-0x7f.
IANA has created and will maintain a new registry titled &quot;TCP
Encryption Protocol Identifiers&quot; under the &quot;Transmission Control
Protocol (TCP) Parameters&quot; registry.  <xref target="tab:csreg"/> shows
the initial contents of this registry.
This document allocates one TEP identifier (0x20) for experimental
use.  In case the TEP identifier space proves too small, identifiers
in the range 0x70-0x7f are reserved to enable a future update to this
document to define extended identifier values.  Future assignments are
to be made upon satisfying either of two policies defined
in <xref target="RFC8126"/>:  &quot;IETF Review&quot; or (for non-IETF stream
specifications)
&quot;Expert Review with RFC Required&quot;. IANA will furthermore provide
early allocation <xref target="RFC7120"/> to facilitate testing before RFCs
are finalized.                                        
</t>
<texttable anchor="tab:csreg" title="TCP Encryption Protocol Identifiers
">
<ttcol align="left">Value</ttcol>
<ttcol align="left">Meaning</ttcol>
<ttcol align="left">Reference</ttcol>

<c>0x20</c><c>Experimental Use</c><c>RFC 8547</c>
<c>0x70-0x7f</c><c>Reserved for extended values</c><c>RFC 8547</c>
</texttable>
</section>

</middle>
<back>
<references title="Normative References">
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0793.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4086.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7120.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"?>


   <reference anchor="NIST-SP-800-57"
                 target="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r4.pdf">
        <front>
          <title>Recommendation for Key Management - Part 1: General</title>
          <author>
            <organization>National Institute of Standards and
	    Technology</organization>
          </author>
          <date month="January" year="2016" />
        </front>
        <seriesInfo name="NIST Special Publication," value="800-57, Revision 4"/>
        <seriesInfo name="DOI" value="10.6028/NIST.SP.800-57pt1r4" />
   </reference>


</references>
<references title="Informative References">
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3493.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4253.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4987.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5116.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5382.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5802.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6394.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6994.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7413.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7435.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7616.xml"?>
</references>


<section anchor="acknowledgments" title="Acknowledgments" numbered="no">
<t>We are grateful for contributions, help, discussions, and feedback
from the IETF and its TCPINC Working Group, including Marcelo Bagnulo,
David Black, Bob Briscoe, Benoit Claise, Spencer Dawkins, Jake
Holland, Jana Iyengar, Tero Kivinen, Mirja Kuhlewind, Watson Ladd,
Kathleen Moriarty, Yoav Nir, Christoph Paasch, Eric Rescorla, Adam
Roach, Kyle Rose, Michael Scharf, Joe Touch, and Eric Vyncke.  This
work was partially funded by DARPA CRASH and the Stanford Secure
Internet of Things Project.
</t>
</section>

<section anchor="contributors" title="Contributors" numbered="no">
<t>Dan Boneh was a coauthor of the draft that became this document.
</t>
</section>


</back>
</rfc>
