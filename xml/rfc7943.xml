<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?> <!-- used by XSLT processors -->
<!-- OPTIONS, known as processing instructions (PIs) go here. -->

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc strict="no" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no"?>

<rfc number="7943"
     category="info" 
     submissionType="independent"
     consensus="yes"
     ipr="trust200902">
<front>
<title abbrev="Stable and Opaque IIDs with DHCPv6">A Method for Generating
Semantically Opaque Interface Identifiers (IIDs) with Dynamic Host Configuration Protocol for IPv6 (DHCPv6)</title>

    <author fullname="Fernando Gont" initials="F." surname="Gont">
      <organization abbrev="SI6 Networks / UTN-FRH">SI6 Networks / UTN-FRH</organization>

      <address>
        <postal>
          <street>Evaristo Carriego 2644</street>

          <code>1706</code>

          <city>Haedo</city>

          <region>Provincia de Buenos Aires</region>

          <country>Argentina</country>
        </postal>

        <phone>+54 11 4650 8472</phone>

        <email>fgont@si6networks.com</email>

        <uri>http://www.si6networks.com</uri>
      </address>
    </author>

<author fullname="Will (Shucheng) Liu" initials="W." surname="Liu">
      <organization>Huawei Technologies</organization>
      <address>
        <postal>
          <street>Bantian, Longgang District</street>
          <city>Shenzhen</city>
          <code>518129</code>
          <country>China</country>
        </postal>
        <email>liushucheng@huawei.com</email>
      </address>
</author>


<date month="July" year="2016"/>

<area>Internet</area>
<workgroup>Dynamic Host Configuration (dhc)</workgroup>

<keyword>security</keyword><keyword>privacy</keyword>
<keyword>resiliency</keyword><keyword>attack</keyword>
<keyword>scanning</keyword><keyword>tracking</keyword>
    <abstract>
    <t>
   This document describes a method for selecting IPv6 Interface
   Identifiers that can be employed by Dynamic Host Configuration Protocol
   for IPv6 (DHCPv6) servers when leasing non-temporary IPv6 addresses
   to DHCPv6 clients. This method is a DHCPv6 server-side algorithm
   that does not require any updates to the existing DHCPv6
   specifications. The aforementioned method results in stable addresses
   within each subnet, even in the presence of multiple DHCPv6 servers
   or DHCPv6 server reinstallments.  It is a DHCPv6 variant of
   the method specified in RFC 7217 for IPv6 Stateless Address
   Autoconfiguration.
    </t>
    </abstract>
    
<note title="IESG Note">
<t>A predecessor to this document was
earlier a working group document in the dhc WG. The WG decided to stop further
work in this area because such work was not considered useful.</t>

<t>The proposal described in this document has an unaddressed failure case that
makes it unsuitable for use as the mechanism to provide the claimed failover
features for DHCPv6 servers. Specifically, when a DHCPv6 client DECLINEs a
provided address there is no recovery mechanism described that will result in
the DHCPv6 client obtaining a working IPv6 address.
</t>
</note>
  </front>

  <middle>
  
  
<section title="Introduction" anchor="intro">

  


<t>The benefits of stable IPv6 addresses are discussed in <xref target="RFC7721"/>. Providing address stability across server reinstallations or when a database of previous DHCPv6 address leases is unavailable is of use not only when a DHCPv6 server must be reinstalled or the address-lease database becomes corrupted, but is also of use when implementation constraints (e.g., a DHCPv6 server implementation on an embedded device) make it impossible for a DHCPv6 server implementation to maintain a database of previous DHCPv6 address leases. Additionally, <xref target="RFC7031"/> describes scenarios where multiple DHCPv6 servers are required to run in such a way as to provide increased availability in case of server failures.
</t>


   <t> This document describes a method for selecting IPv6 Interface
 Identifiers that can be employed by DHCPv6 servers when leasing non-temporary IPv6 addresses
 to DHCPv6 clients (i.e., to be employed with IA_NA options). This method is a
 DHCPv6 server-side algorithm
   that does not require any updates to the existing DHCPv6
   specifications. The aforementioned method has the following
   properties:

<list style="symbols">
<t>The resulting IPv6 addresses remain stable within each subnet for
      the same network interface of the same client, even when different
      DHCPv6 servers (implementing this specification) are employed.</t>

<t>Predicting the IPv6 addresses that will be generated by the method specified in this document,
      even with knowledge of the IPv6 addresses generated for other nodes within the same network, becomes very difficult.</t>
</list>

   </t>

<t>
   The method specified in this document achieves the aforementioned
   properties by means of a calculated technique as opposed to, e.g., state sharing among DHCPv6 servers. This approach has already been 
   suggested in <xref target="RFC7031"/>.  We note that the method described in this
   document is essentially a DHCPv6 version of the "Method for
   Generating Semantically Opaque Interface Identifiers with IPv6
   Stateless Address Autoconfiguration (SLAAC)" specified in <xref target="RFC7217"/>.
</t>

</section>




<section title="Applicability and Design Goals" anchor="applicability">
<t>This document simply describes one possible approach for selecting IPv6 Interface Identifiers to be employed by DHCPv6 servers when leasing non-temporary IPv6 addresses to DHCPv6 clients, with the following properties:

<list style="symbols">
<t>The resulting IPv6 addresses remain stable within each subnet for the same network interface of the same client.</t>
<t>The resulting IPv6 addresses cannot be predicted by an attacker without knowledge of a secret key.</t>


<t>The resulting IPv6 addresses remain stable across DHCPv6 server reinstallations, or even if a database of previous DHCPv6 address leases is not available.</t>

<t>The resulting IPv6 addresses remain stable when different DHCPv6 servers (implementing this specification) are employed on the same network.</t>
</list>
</t>

<t>We note that the algorithm specified in this document employs a
(lightweight) calculated technique (as opposed to, e.g., state sharing among DHCPv6 servers) to achieve address stability in scenarios where multiple DHCPv6 servers are required to run in such a way as to provide increased availability, without the need of an additional protocol to synchronize the lease databases of DHCPv6 servers.
</t>

<t>Finally, we note that the algorithm in this document is only meant to mitigate IPv6 address-based location tracking, device-specific vulnerability exploitation, and host scanning (please see <xref target="RFC7721"/>). There are a number of ways in which DHCPv6 affects user privacy, which the algorithm specified in this document does not mitigate (and does not intend to). Please see <xref target="RFC7844"/> for a comprehensive discussion of how DHCPv6 may affect user privacy.</t>
</section>

<section title="Method Specification" anchor="specification">


<t>Implementations should provide the means for a system administrator to enable or disable the use of this algorithm for generating IPv6 addresses. </t> 


<t>A DHCPv6 server implementing this specification must select the IPv6 addresses to be leased with the following algorithm:

<list style="numbers">
<t>
Compute a random (but stable) identifier with the expression:
<vspace blankLines="1" />
RID = F(Prefix | Client_DUID | IAID | Counter | secret_key)
<vspace blankLines="1" />
Where:
<list style="hanging">
<t hangText="RID:">
<vspace blankLines="0" />Random (but stable) Identifier</t>
<t hangText="F():">
<vspace blankLines="0" />A Pseudorandom Function (PRF) that must not be computable from the outside (without knowledge of the secret key). F() must also be difficult to reverse, such that it resists attempts to obtain the secret key, even when given samples of the output of F() and knowledge
or control of the other input parameters. F() should produce an output of at
least 64 bits. F() could be implemented as a cryptographic hash of the
concatenation of each of the function parameters. The default algorithm to be
employed for F() should be SHA-256 <xref target="FIPS-SHS"/>. An
implementation may provide the means for selecting other algorithms. Note:
Message Digest 5 (MD5) <xref target="RFC1321"/> is considered unacceptable for F() <xref target="RFC6151"/>.</t>

<t hangText="Prefix:">
<vspace blankLines="0" />The prefix employed for the local subnet, as a 128-bit unsigned integer in network byte order (with the unused bits set to 0). If multiple servers operate on the same network to provide
       increased availability, all such DHCPv6 servers must be
       configured with the same Prefix. It is the administrator's
       responsibility that the aforementioned requirement is met.
</t>


<t hangText="|:">
<vspace blankLines="0" />An operator representing "concatenation".</t>


<t hangText="Client_DUID:">
<vspace blankLines="0" />The DHCPv6 Unique Identifier (DUID) value contained in the Client Identifier option received in the DHCPv6 client message. The DUID can be treated as an array of 8-bit unsigned integers.</t>

<t hangText="IAID:">
<vspace blankLines="0" />The Identity Association Identifier (IAID) value contained in the IA_NA option received in the client message. It must be interpreted as a 32-bit unsigned integer in network byte order. </t>

<t hangText="secret_key:">
<vspace blankLines="0" />A secret key configured by the DHCPv6 server administrator, which must not be known by the attacker. It must be encoded as an array of 8-bit unsigned integers. An implementation of this specification must provide an interface for viewing and changing the secret key. All DHCPv6 servers leasing addresses from the same address range must employ the same secret key.
</t>
<t hangText="Counter:">
<vspace blankLines="0" />A 32-bit unsigned integer in network byte order that is employed to resolve address conflicts. It must be initialized to 0.</t>
</list>
</t>



<t>A candidate IPv6 address (IPV6_ADDR) to be leased is obtained by concatenating as many bits as necessary from the RID value computed in the previous step (starting from the least significant bit) to the Prefix employed in the equation above, as follows:

          <figure align="center">
            <artwork><![CDATA[
     IPV6_ADDR = IPV6_ADDR_LOW +  
                 RID % (IPV6_ADDR_HI - IPV6_ADDR_LOW + 1)
]]></artwork>
          </figure>


where:

<list style="hanging">

<t hangText="IPV6_ADDR:">

<vspace blankLines="0" />The candidate IPv6 address to be leased.
</t>

<t hangText="IPV6_ADDR_HI:">

<vspace blankLines="0" />An IPv6 address specifying the upper boundary of the
IPv6 address pool from which the DHCPv6 server leases IPv6 addresses. If an
address range is not explicitly selected, IPV6_ADDR_HI must be set to the IPv6
address from the Prefix (see the expression above) that has all of the bits of the Interface Identifier set to 1.
</t>

<t hangText="IPV6_ADDR_LOW:">

<vspace blankLines="0" />An IPv6 address specifying the lower boundary of the
IPv6 address pool from which the DHCPv6 server leases IPv6 addresses. If an
address range is not explicitly selected, IPV6_ADDR_LOW must be set to the
IPv6 address from the Prefix (see the expression above) that has all of the bits of the Interface Identifier set to 0. 
</t>
</list>
</t>

<t>
The Interface Identifier of the selected IPv6 address must be compared against the reserved IPv6 Interface Identifiers <xref target="RFC5453"/> <xref target="IANA-RESERVED-IID"/>. In the event that an unacceptable identifier has been generated, the Counter variable should be incremented by 1, and a new IPv6 address should be computed with the updated Counter value.
</t>
<t>If the resulting address is not available (e.g., there is a conflicting binding), the DHCPv6 server should increment the Counter variable, and a new Interface Identifier and IPv6 address should be computed with the updated Counter value.</t>
</list>
</t>

<t>This document requires that SHA-256 be the default function to be used for
F(), such that (all other configuration parameters being the same) different 
implementations of this specification result in the same IPv6 addresses. 
</t>



<t>Including the Prefix in the PRF computation causes the Interface Identifier
to be different for each address from a different prefix leased to the same
client. This mitigates the correlation of activities of multihomed nodes
(since each of the corresponding addresses will employ a different Interface
Identifier), host tracking (since the network prefix, and therefore the resulting Interface Identifier, will change as the node moves from one network to another), and any other attacks that benefit from predictable Interface Identifiers <xref target="RFC7721"/>.
</t>

<t>As required by <xref target="RFC3315"/>, an IAID is associated with each of the client's network interfaces and is consistent across restarts of the DHCPv6 client.</t> 

<t>The Counter parameter provides the means to intentionally cause this algorithm to produce different IPv6 addresses (all other parameters being the same). This can be of use to resolve address conflicts (e.g., the resulting address having a conflicting binding).
</t>

   <t>Note that the result of F() in the algorithm above is no more secure than the secret key.  If an attacker is aware of the PRF that is being used by the DHCPv6 server (which we should expect), and the attacker can obtain enough material (i.e., addresses generated by the DHCPv6 server), the attacker may simply search the entire secret-key space to find matches. To protect against this, the secret key should be of at least 128 bits. Key lengths of at least 128 bits should be adequate. 
</t>

<t>
Providing a mechanism to display and change the secret_key is crucial for having different DHCPv6 servers produce the same IPv6 addresses and for  causing a replacement system to generate the same IPv6 addresses as the system being replaced. We note that since the privacy of the scheme specified in this document relies on the secrecy of the secret_key parameter, implementations should constrain access to the secret_key parameter to the extent practicable (e.g., require superuser privileges to access it). Furthermore, in order to prevent leakages of the secret_key parameter, it should not be used for any other purposes than being a parameter to the scheme specified in this document.</t>

<t>We note that all of the bits in the resulting Interface Identifiers are treated as "opaque" bits <xref target="RFC7136"/>. For example, the universal/local bit of Modified EUI-64 format identifiers is treated as any other bit of such identifier. 
</t>

</section>

    <section title="Security Considerations" anchor="sec-cons">
<t>The method specified in this document results in IPv6 Interface Identifiers (and hence IPv6 addresses) that do not follow any specific pattern. Thus, attacks that rely on predictable Interface Identifiers (such as <xref target="RFC7707"/>) are mitigated.</t>

<t>The method specified in this document neither mitigates nor exacerbates the security considerations for DHCPv6 discussed in <xref target="RFC3315"/> and does not mitigate a range of other privacy implications associated with DHCPv6. Please read <xref target="RFC7844"/> for a comprehensive assessment of the privacy implications of DHCPv6.</t>

<t>Finally, we note that an attacker that is able to attach to each of the links to which the victim attaches would still be able to correlate the activities of the victim across networks.</t>
    </section>

  </middle>




  <back>
  <references title='Normative References'>

	<?rfc include="reference.RFC.3315" ?>
	<?rfc include="reference.RFC.5453" ?>
	<?rfc include="reference.RFC.7136" ?>
  </references>

  <references title='Informative References'>
	<?rfc include="reference.RFC.1321" ?>
	<?rfc include="reference.RFC.6151" ?>
	<?rfc include="reference.RFC.7217" ?>
	<?rfc include="reference.RFC.7031" ?>
	<?rfc include="reference.RFC.7707" ?>
	<?rfc include="reference.RFC.7721" ?>
	<?rfc include="reference.RFC.7844" ?>

	<reference anchor="IANA-RESERVED-IID" 
		   target="http://www.iana.org/assignments/ipv6-interface-ids">
		<front>
		<title>Reserved IPv6 Interface Identifiers</title>
		<author initials="" 
			surname="" 
			fullname="">
				<organization>IANA</organization>
			</author>
			<date year=""/>
		</front>
	</reference>

<!--[rfced] We note that the following [FIPS-SHS] reference has been updated
from March 2012. We updated the publication month and year to the most
recent version of the document. Please let us know if these changes should
be reverted.

Original

   [FIPS-SHS]
              FIPS, , "Secure Hash Standard (SHS)",  Federal Information
              Processing Standards Publication 180-4, March 2012,
              <http://csrc.nist.gov/publications/fips/fips180-4/
              fips-180-4.pdf>.
Updated

   [FIPS-SHS]
              Federal Information Processing Standards (FIPS), "Secure
              Hash Standard (SHS)", FIPS 180-4, August 2015,
              <http://csrc.nist.gov/publications/fips/fips180-4/
              fips-180-4.pdf>.
-->

<!-- The updated reference is perfect. Thanks! -->

	<reference anchor="FIPS-SHS" 
		   target="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">
		<front>
			<title>Secure Hash Standard (SHS)</title>
			<author initials="" surname="" fullname="">
				<organization>Federal Information Processing
				Standards (FIPS)</organization>
			</author>
			<date month="August" year="2015"/>
		</front>
		<seriesInfo name="FIPS" 
			    value="180-4"/>
	</reference>

</references>

<section title="Acknowledgements" numbered="no">

<t>This document is based on <xref target="RFC7217"/>, authored by Fernando
Gont.</t>

<t>The authors would like to thank Marc Blanchet, Stephane Bortzmeyer, Tatuya
Jinmei, Andre Kostur, Tomek Mrugalski, Hosnieh Rafiee, Jim Schaad,
Jean-Francois Tremblay, Tina Tsou, and Bernie Volz for providing valuable 
comments on earlier versions of this documents.</t>

<t>The authors would like to thank Ted Lemon, who kindly answered some
DHCPv6-related questions, and Nevil Brownlee for his guidance
while pursuing this document.</t>


<t>Fernando Gont would like to thank Nelida Garcia and Guillermo Gont for their love and support, and Diego Armando Maradona for his magic and inspiration.</t>
</section>
  </back>
</rfc>

