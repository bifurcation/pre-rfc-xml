<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc number="8218"
     ipr="trust200902"
     category="exp"
     submissionType="IETF"
     consensus="yes">
  

<front>
<title abbrev="Multipath OLSRv2">Multipath Extension for the Optimized Link State Routing Protocol Version 2 (OLSRv2)</title>

<author fullname="Jiazi Yi" initials="J" surname="Yi">
<organization>Ecole Polytechnique</organization>
<address>
<postal>
<street/>
<city>91128 Palaiseau Cedex</city>
<region/>
<country>France</country>
</postal>
<phone>+33 (0) 1 77 57 80 85</phone>
<email>jiazi@jiaziyi.com</email>
<uri>http://www.jiaziyi.com/</uri>
</address>
</author>

<author fullname="Benoit Parrein" initials="B.P." surname="Parrein">
<organization>University of Nantes</organization>
<address>
<postal>
<street>IRCCyN Lab - IVC team</street>
<street>Polytech Nantes, rue Christian Pauc, BP50609</street>
<code>44306 Nantes cedex 3</code>
<country>France</country>
</postal>
<phone>+33 (0) 2 40 68 30 50</phone>
<email>Benoit.Parrein@polytech.univ-nantes.fr</email>
<uri>http://www.irccyn.ec-nantes.fr/~parrein</uri>
</address>
</author>

<date month="August" year="2017"/>

<workgroup>Network Working Group</workgroup>
<keyword>MANET</keyword>

<abstract>
<t>
This document specifies a multipath extension for the Optimized Link State Routing Protocol version 2 (OLSRv2) to discover multiple disjoint paths for Mobile Ad Hoc Networks (MANETs). Considering the characteristics of MANETs, especially the dynamic network topology, using multiple paths can increase aggregated throughput and improve the reliability by avoiding single route failures. The interoperability with OLSRv2 is retained.
</t>
</abstract>

</front>

<middle>

<section title="Introduction" anchor="introduction">
	<t>
        The Optimized Link State Routing Protocol version 2 (OLSRv2) <xref
	target="RFC7181"/> is a proactive link state protocol designed for use
	in Mobile Ad Hoc Networks (MANETs). It generates routing messages
	periodically to create and maintain a Routing Set, which contains
	routing information to all the possible destinations in the routing
	domain. For each destination, there exists a unique Routing Tuple, which indicates the next hop to reach the destination. 
    </t>

    <t>
 	This document specifies an extension of the OLSRv2 protocol <xref target="RFC7181"/> to provide multiple disjoint paths when appropriate for a source-destination pair.  Because of the characteristics of MANETs <xref target="RFC2501"/>, especially the dynamic topology, having multiple paths is helpful for increasing network throughput, improving forwarding reliability, and load-balancing. 
    </t>
    
    <t>
    Multipath OLSRv2 (MP-OLSRv2), specified in this document, uses the Multipath Dijkstra Algorithm by default to explore multiple disjoint paths from a source router to a destination router based on the topology information obtained through OLSRv2 and to forward the datagrams in a load-balancing manner using source routing. MP-OLSRv2 is designed to be interoperable with OLSRv2. 
    </t>

	
	<section title="Motivation and Experiments to Be Conducted">
	<t>
		This document is an experimental extension of OLSRv2 that can increase the data forwarding reliability in dynamic and high-load MANET scenarios by transmitting datagrams over multiple disjoint paths using source routing. This mechanism is used because:
	
	<list style="symbols">
	<t>Disjoint paths can avoid single route failures.</t>
	
	<t>Transmitting datagrams through parallel paths can increase aggregated throughput.</t>
	
	<t>Some scenarios may require that some routers must (or must not) be used.</t>
	
	<t>Having control of the paths at the source benefits the load-balancing and traffic engineering.</t>
	
	<t>An application of this extension is in combination with Forward
	Error Correction (FEC) coding applied across packets (erasure coding)
	<xref target="WPMC11"/>. Because the packet drops are normally bursty
	in a path (for example, due to route failure), erasure coding is less
	effective in single path routing protocols. By providing multiple
	disjoint paths, the application of erasure coding with multipath
	protocol is more resilient to routing failures.
	</t>
	
	</list>
	
	</t>	
	
	<t>In existing deployments, while running code and simulations have
	proven the interest of multipath extension for OLSRv2 in certain
	networks <xref target="GIIS14"/><xref target="WCNC08"/><xref
	target="ADHOC11"/>, more experiments and experiences are still needed to
	understand the effects of the protocol specified in this Experimental
	RFC. The multipath extension for OLSRv2 is expected to be revised
	and documented as a Standards Track RFC once sufficient operational
	experience is obtained. Other than general experiences, including the
	protocol specification and interoperability with base OLSRv2
	implementations, experiences in the following aspects are highly
	appreciated:
	
	
	<list style="symbols">

	<t>
		Optimal values for the number of multiple paths
		(NUMBER_OF_PATHS, see <xref target="parameters_and_constants"/>)
		to be used. This depends on the network topology and router
		density.
	</t>
	

	<t>
		Optimal values used in the metric functions. Metric functions
		are applied to increase the metric of used links and nodes so
		as to obtain disjoint paths. What kind of disjointness is
		desired (node disjoint or link disjoint) may depend on the
		Layer 2 protocol used and can be achieved by applying
		different sets of metric functions.
	</t>
	
	<t>
		Use of different metric types. This multipath extension can be
		used with metric types that meet the requirement of OLSRv2,
		such as <xref target="RFC7779"/>. The metric type used also has an
		impact on the choice of metric functions as indicated in
		the previous bullet point.
	</t>

	<t>
		The impact of partial topology information to multipath calculation. OLSRv2 maintains a partial topology information base to reduce protocol overhead. Experience has shown that multiple paths can be obtained even with such partial information; however, depending on the Multipoint Relay (MPR) selection algorithm used, the disjointness of the multiple paths might be impacted depending on the Multipoint Relay (MPR) selection algorithm used. 
	</t>

	<t>
		Use of IPv6 loose source routing. In the current specification, only strict source routing is used for IPv6 based on <xref target="RFC6554"/>. In <xref target="IPv6-SRH"/>, the use of the loose source routing is also  proposed in IPv6. In scenarios where the length of the source routing header is critical, the loose source routing can be considered. 
	</t>
	
	
	<t>
		Optimal choice of "key" routers for loose source routing. In some cases, loose source routing is used to reduce overhead or for interoperability with OLSRv2 routers. Other than the basic rules defined in the following parts of this document, optimal choices of routers to put in the loose source routing header can be further studied. 
	</t>
	

	<t>
		 Different path-selection schedulers. Depending on the
		 application type and transport layer type, either a per-flow
		 scheduler or per-datagram scheduler is applied. By default,
		 the traffic load should be equally distributed in multiple
		 paths. In some scenarios, weighted scheduling can be
		 considered: for example, the paths with lower metrics (i.e.,
		 higher quality) can transfer more datagrams or flows compared
		 to paths with higher metrics.
	</t>
	
	<t>
		The impacts of the delay variation due to multipath routing. <xref target="RFC2991"/> brings out some concerns of multipath routing, especially variable latencies when per-datagram scheduling is applied. Although current experiment results show that multipath routing can reduce the jitter in dynamic scenarios, some transport protocols or applications may be sensitive to the datagram reordering. 
	</t>
	
	<t>
		The disjoint multipath protocol has an interesting application
		with erasure coding, especially for services like video/audio
		streaming <xref target="WPMC11"/>. The combination of erasure
		coding mechanisms and this extension is thus encouraged.
	</t>
	

	
	<t>
		Different algorithms to obtain multiple paths, other than the default Multipath Dijkstra Algorithm introduced in <xref target="multipath-dijkstra"/> of this specification. 
	</t>
	

	<t>
		The use of multitopology information. By using <xref target="RFC7722"/>, multiple topologies using different metric types can be obtained. Although there is no work defining how this extension can make use of the multitopology information base yet, experimentation with the use of multiple metrics for building multiple paths is encouraged.
	</t>
	
	</list>
	</t>
	
	<t>

		Comments are solicited and should be addressed to the MANET working group's mailing list at manet@ietf.org and/or the authors. 
	</t>
	
	</section>
</section>

    <section title="Terminology" anchor="terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in BCP 14
      <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
      appear in all capitals, as shown here.</t>

      <t>This document uses the terminology and notation defined in <xref
      target="RFC5444"/>, <xref target="RFC6130"/>, and <xref target="RFC7181"/>. Additionally, it defines the following terminology:
      
        <list style="hanging">
 			<t hangText="OLSRv2 Routing Process:">
 				A routing process based on <xref target="RFC7181"/>, without multipath extension specified in this document. 
 			</t>
 			
 			<t hangText="MP-OLSRv2 Routing Process:">
 				A Multipath Routing Process based on this specification as an extension to <xref target="RFC7181"/>.
 			</t>
 			
 			<t hangText="SR-OLSRv2 Routing Process:">
 				An OLSRv2 Routing Process that supports Source Routing (SR) or an MP-OLSRv2 Routing Process.
 			</t>
 			
		 </list>

      </t>
    </section>    <section title="Applicability Statement" anchor="applicability_statement">
		<t>
			As an extension of OLSRv2, this specification is applicable to MANETs for which OLSRv2 is applicable (see <xref target="RFC7181"/>). It can operate on single or multiple interfaces to discover multiple disjoint paths from a source router to a destination router. MP-OLSRv2 is designed for networks with dynamic topology to avoid single route failure. It can also provide higher aggregated throughput and load-balancing.
		</t>
		
		<t>
			In a router supporting MP-OLSRv2, MP-OLSRv2 does not necessarily replace OLSRv2 completely. The extension can be applied for certain applications that are suitable for multipath routing (mainly video or audio streams) based on information such as a Diffserv codepoint <xref target="RFC2474"/>. 
		</t>
		
		<t>
			Compared to OLSRv2, this extension does not introduce
			any new message type. A new Message TLV Type is
			introduced to identify the routers that support
			forwarding based on the source routing header. It is interoperable with OLSRv2 implementations that do not have this extension: as the MP-OLSRv2 uses source routing, in IPv4 networks the interoperability is achieved using loose source routing headers; in IPv6 networks, it is achieved by eliminating routers that do not support IPv6 strict source routing. 
		</t>
		
		<t>
			MP-OLSRv2 supports two different but interoperable
			multipath calculation approaches: proactive and
			reactive. In the proactive calculation, the paths to
			all the destinations are calculated before they are needed. In the reactive calculation, only the paths to desired destination(s) are calculated on demand. The proactive approach requires more computational resources than the reactive one. The reactive approach requires the IP forwarding plane to trigger the multipath calculation. 
		</t>
	
		<t>
			MP-OLSRv2 forwards datagrams using the source routing header. As there are multiple paths to each destination, MP-OLSRv2 requires the IP forwarding plane to be able to choose which source route to be put in the source routing header based on the path scheduler defined by MP-OLSRv2. For IPv4 networks, implementation of loose source routing is required following <xref target="RFC0791"/>. For IPv6 networks, implementation of strict source routing is required following the source routing header generation and processing defined in <xref target="RFC6554"/>. 
		</t>

    </section>
<section title="Protocol Overview and Functioning" anchor="overview_and_functioning">
	<t>
		This specification uses OLSRv2 <xref target="RFC7181"/> to:
		<list style="symbols">
			<t>
				Identify all the reachable routers in the network. 
			</t>
			<t>
				Identify a sufficient subset of links in the networks so that routes can be calculated to all reachable destinations. 
			</t>
			<t>
				Provide a Routing Set containing the shortest routes from this router to all destinations. 
			</t>
		</list>
		
	</t>
      	
    <t>
    	In addition, the MP-OLSRv2 Routing Process identifies the routers that support source routing by adding a new Message TLV in HELLO and Topology Control (TC) messages. Based on the above information acquired, every MP-OLSRv2 Routing Process is aware of a reduced topology map of the network and the routers supporting source routing. 
    </t>
    
	<t>
		 A Multipath Routing Set containing the multipath information is maintained. It may be either proactively calculated or reactively calculated:
		
		<list style="symbols"> 
			
			<t>
			In the proactive approach, multiple paths to all possible destinations are calculated and updated based on control message exchange. The routes are thus available before they are actually needed. 
			</t>
			
			<t>In the reactive approach, a multipath algorithm is
			invoked on demand, i.e., only when there is a datagram
			to be sent from the source to the destination and
			there is no available Routing Tuple in the Multipath
			Routing Set.&nbsp; This requires the IP forwarding
			information base to trigger the multipath calculation
			specified in <xref target="mp-dijkstra"/> when no
			Multipath Routing Tuple is available. The reactive
			operation is local to the router and no additional
			exchange of routing control messages is required. When the paths are being calculated, the datagrams SHOULD be buffered unless the router does not have enough memory. 
			</t>
		</list>
	</t>
	
	<t>
			Routers in the same network may choose either proactive or reactive multipath calculation independently according to their computation resources. The Multipath Dijkstra Algorithm (defined in <xref target="mp-dijkstra"/>) is introduced as the default algorithm to generate multiple disjoint paths from a source to a destination, and such information is kept in the Multipath Routing Set. 
	</t>

	
	<t>
		The datagram is forwarded based on source routing. When there is a datagram to be sent to a destination, the source router acquires a path from the Multipath Routing Set.&nbsp; The path information is stored in the datagram header using the source routing header. 
	</t>
		
	
</section>
    
<section anchor="parameters_and_constants" title="Parameters and Constants">
	<t>In addition to the parameters and constants defined in <xref target="RFC7181"/>, this specification uses the parameters and constants described in this section.</t>


	<section title="Router Parameters" anchor="router_parameters">
		<t>
		<list style="hanging">
      		<t hangText="NUMBER_OF_PATHS:">
      			The number of paths desired by the router. 
      		</t>
      		
			<t hangText="MAX_SRC_HOPS:">
				The maximum number of hops allowed to be put
				in the source routing header. A value set to 0
				means there is no limitation on the maximum
				number of hops. In an IPv6 network, it MUST be
				set to 0 because <xref target="RFC6554"/>
				supports only strict source routing. All the
				intermediate routers MUST be included in the
				source routing header, which is a various number of hops. In an IPv4 network, it MUST be strictly less than 11 and greater than 0 due to the length limit of the IPv4 header.   
      		</t>
      		
      		<t hangText="CUTOFF_RATIO:">
      			The ratio that defines the maximum metric of a path
			compared to the shortest path kept in the OLSRv2
			Routing Set.&nbsp; For example, the metric to a destination
			is R_metric based on the Routing Set.&nbsp; Then, the
			maximum metric allowed for a path is CUTOFF_RATIO *
			R_metric. CUTOFF_RATIO MUST be greater than or equal
			to 1. Setting the number low makes it less likely that 
			additional paths will be found -- for example, 
			setting it to 1 will mean only equal length paths are considered.
      		</t>

			<t hangText="SR_TC_INTERVAL:">
				The maximum time between the transmission of two successive TC messages by an MP-OLSRv2 Routing Process.  
			</t>
      		
      		<t hangText="SR_HOLD_TIME:">
      			 The minimum value in the TLV with Type = VALIDITY_TIME included in TC messages generated based on SR_TC_INTERVAL. 
      		</t>

      	</list>
		</t>
		</section>
		
</section>
<section anchor="packets_and_messages" title="Packets and Messages">
	<t>
		This extension employs the routing control messages HELLO and TC as defined in OLSRv2 <xref target="RFC7181"/> to obtain network topology information. For the datagram to support source routing, a source routing header is added to each datagram routed by this extension. Depending on the IP version used, the source routing header is defined in this section.  
	</t>
	
	<section title = "HELLO and TC messages">
	
	<t>
		HELLO and TC messages used by the MP-OLSRv2 Routing Process use the same format as defined in <xref target="RFC7181"/>. In addition, a new Message TLV Type is defined to identify the originator of the HELLO or TC message that supports source-route forwarding. The new Message TLV Type is introduced for enabling MP-OLSRv2 as an extension of OLSRv2: only the routers supporting source-route forwarding can be used in the source routing header of a datagram because adding a router that does not understand the source routing header will cause routing failure.  
	</t>
	
	<section title = "SOURCE_ROUTE TLV">
	
	<t>
		The SOURCE_ROUTE TLV is a Message TLV signaling that the message is generated by a router that supports source-route forwarding. It can be an MP-OLSRv2 Routing Process or an OLSRv2 Routing Process that supports source-route forwarding. 
	</t>
	
	<t>
		Every HELLO or TC message generated by a MP-OLSRv2 Routing Process MUST have exactly one SOURCE_ROUTE TLV without value. 
	</t>

	<t>
		Every HELLO or TC message generated by an OLSRv2 Routing Process MUST have exactly one SOURCE_ROUTE TLV, if the OLSRv2 Routing Process supports source-route forwarding, and be willing to join the source route generated by other MP-OLSRv2 Routing Processes. The existence of SOURCE_ROUTE TLV MUST be consistent for a specific OLSRv2 Routing Process, i.e., either it adds SOURCE_ROUTE TLV to all its HELLO/TC messages or it does not add SOURCE_ROUTE TLV to any HELLO/TC messages. 
	</t>

	
	</section> 
	
	</section>
		
	<section title = "Datagram">
	
	<section title = "Source Routing Header in IPv4">
		<t>
			In IPv4 <xref target="RFC0791"/> networks, the MP-OLSRv2 Routing Process employs the loose source routing header, as defined in <xref target="RFC0791"/>. It exists as an option header with option class 0 and option number 3. 
		</t>
		
		<t>
			The source route information is kept in the "route data" field of the loose source routing header. 
		</t>
	</section>
	
	<section title = "Source Routing Header in IPv6">
		<t>
			In IPv6 <xref target="RFC8200"/> networks, the MP-OLSRv2 Routing Process employs the source routing header, as defined in Section 3 of <xref target="RFC6554"/>, with IPv6 Routing Type 3. 
		</t>
		
		<t>
			The source route information is kept in the "Addresses" field of the routing header.
		</t>

	</section>
	</section>
	
</section><section anchor="information_bases" title="Information Bases">
    <t>
      Each MP-OLSRv2 Routing Process maintains the information bases as defined in <xref target="RFC7181"/>. Additionally, a Multipath Information Base is used for this specification. It includes the protocol sets as defined below. 
	</t>
	
	<section title="SR-OLSRv2 Router Set">
		<t>The SR-OLSRv2 Router Set records the routers that support source-route forwarding. This includes routers that run the MP-OLSRv2 Routing Process or the OLSRv2 Routing Process with source-route forwarding support. The set consists of SR-OLSRv2 Routing Tuple:
		</t>
		
                <figure>
                        <artwork>
(SR_addr, SR_time)
                        </artwork>
                </figure>
		
		<t>where:
			<list style="empty">
				<t>SR_addr is the originator address of the router that supports source-route forwarding.
				</t>
				
				<t>SR_time is the time until which the SR-OLSRv2 Routing Tuple is considered valid. 
				</t>
			</list>
		</t>
	</section>
	
	<section title="Multipath Routing Set" anchor="mp-routing_set">
		<t>The Multipath Routing Set records the full path information
		of different paths to the destination. It consists of
		Multipath Routing Tuple:
		</t>
		
                <figure>
                        <artwork>
(MR_dest_addr, MR_path_set)
                        </artwork>
                </figure>
		
		<t>where:
			<list style="empty">
				<t>MR_dest_addr is the network address of the
					destination; it is either the network
					address of an interface of a
					destination router or the network
					address of an attached network.
				</t>

				<t>MP_path_set contains the multiple paths to the
					destination and it consists of a set
					of Path Tuples.
				</t>
			</list>
		</t>
		
		<t>
		Each Path Tuple is defined as:
		</t>
		
                <figure>
                        <artwork>
(PT_metric, PT_address[1], PT_address[2], ..., PT_address[n])
                        </artwork>
                </figure>
		
		<t>where:
			<list style="empty">
				<t>PT_metric is the metric of the
				path to the destination, measured in
				LINK_METRIC_TYPE defined in <xref
				target="RFC7181"/>.
				</t>

				<t>PT_address[1, ..., n-1] are the
				addresses of intermediate routers to be
				visited, numbered from 1 to n-1, where n is
				the number of routers in the path, i.e., the
				hop count.
				</t>
			</list>
		</t>
	</section>
	
</section>


<section anchor="protocol_details" title="Protocol Details">
	<t>This protocol is based on OLSRv2 and is extended to discover
	multiple disjoint paths from a source router to a destination
	router. It retains the formats of the basic routing control packets
	and the processing of OLSRv2 to obtain the topology information of the network. The main differences from the OLSRv2 Routing Process are the datagram processing at the source router and datagram forwarding.</t>
	
	<section title = "HELLO and TC Message Generation">
		<t>HELLO messages are generated according to Section 15.1 of
		<xref target="RFC7181"/>, plus a single message TLV with Type
		:= SOURCE_ROUTE included.</t>
		
		<t>TC messages are generated according to Section 16.1 of <xref target="RFC7181"/>, plus a single message TLV with Type := SOURCE_ROUTE included.</t>
		
		<t>
			For the routers that do not generate TC messages
			according to <xref target="RFC7181"/>, at least one TC
			message MUST be generated by an MP-OLSRv2 Routing
			Process during the SR_TC_INTERVAL  (<xref
			target="parameters_and_constants"/>), which MUST be
			greater than or equal to TC_INTERVAL. Those TC
			messages MUST NOT carry any advertised neighbor
			addresses. This serves for those routers to advertise
			the SOURCE_ROUTE TLV so that the other routers can be
			aware of the routers that are source-route enabled so as to be used as destinations of multipath routing. The validity time associated with the VALIDITY_TIME TLV in such TC messages equals SR_HOLD_TIME, which MUST be greater than the SR_TC_INTERVAL. If the TC message carries an optional INTERVAL_TIME TLV, it MUST have a value encoding the SR_TC_INTERVAL. 
		</t>

	</section>
	
	<section title="HELLO and TC Message Processing">
		<t>HELLO and TC messages are processed according to Sections 15.3 and 16.3 of <xref target="RFC7181"/>.
		</t>
						

		<t>
		In addition to the reasons specified in <xref target="RFC7181"/> for discarding a HELLO message or a TC message on reception, a HELLO or TC message received MUST be discarded if it has more than one Message TLV with Type = SOURCE_ROUTE. 
		</t>
		
		<t>
			For every HELLO or TC message received, if there is a Message TLV with Type := SOURCE_ROUTE, create or update (if the Tuple exists already) the SR-OLSR Routing Tuple with:
			<list style="symbols">
				<t>SR_addr := originator address of the HELLO or TC message</t>
				
				<t>SR_time := current_time + validity
					time of the TC or HELLO message
					defined in <xref target="RFC7181"/>.
				</t>
			</list>
		</t>
		

		
	</section>
	
	<section title="MPR Selection">
		<t>Each MP-OLSRv2 Routing Process selects routing MPRs
			and flooding MPRs following Section 18 of <xref
			target="RFC7181"/>. In a mixed network with
			OLSRv2-only routers, the following considerations
			apply when calculating MPRs:
			<list style="symbols">
				<t>MP-OLSRv2 routers SHOULD be preferred as routing MPRs to increase the possibility of finding disjoint paths using MP-OLSRv2 routers.</t>
				
				<t>The number of routing MPRs that run the MP-OLSRv2 Routing Process MUST be equal to or greater than NUMBER_OF_PATHS if there are enough MP-OLSRv2 symmetric neighbors. Otherwise, all the MP-OLSRv2 routers are selected as routing MPRs, except the routers with willingness WILL_NEVER. 
				</t>
			</list>
			
		</t>
	</section>
	
	<section title="Datagram Processing at the MP-OLSRv2 Originator" anchor="orig-processing">
		<t>
			If datagrams without a source routing header need to be forwarded using multiple paths (for example, based on the information of a Diffserv codepoint <xref target="RFC2474"/>), the MP-OLSRv2 Routing Process will try to find the Multipath Routing Tuple where:
			<list style="symbols">
				<t>
					MR_dest_addr = destination of the datagram
				</t>

			</list>
		</t>
		
		<t>	If no matching Multipath Routing Tuple is found and the Multipath Routing Set is maintained proactively, it indicates that there is no multipath route available to the desired destination. The datagram is forwarded following the OLSRv2 Routing Process.
		</t>
		
		<t>
		If no matching Multipath Routing Tuple is found and the Multipath Routing Set is maintained reactively, the multipath algorithm defined in <xref target="mp-dijkstra"/> is invoked to calculate the Multipath Routing Tuple to the destination. If the calculation does not return any Multipath Routing Tuple, the following steps are aborted and the datagram is forwarded following the OLSRv2 Routing Process.  
		</t>
		
		<t>
			If a matching Multipath Routing Tuple is obtained, the Path Tuples of the Multipath Routing Tuple are applied to the datagrams using either per-flow or per-datagram scheduling, depending on the transport layer protocol and the application used. By default, per-flow scheduling is used, especially for the transport protocols that are sensitive to reordering, such as TCP. The path-selection decision is made on the first datagram and all subsequent datagrams of the same flow use the same path. 

If the path breaks before the flow is closed, another path with the most similar metric is used. Per-datagram scheduling is recommended if the traffic is insensitive to reordering such as unreliable transmission of media traffic or when erasure coding is applied. In such a case, each datagram selects its paths independently.  
		</t>
		
		<t>
			By default, the traffic load should be equally distributed in multiple paths. Other path-scheduling mechanisms (e.g., assigning more traffic over better paths) are also possible and will not impact the interoperability of different implementations.
		</t>
		
		<t>
			The addresses in PT_address[1, ..., n-1] of the chosen
			Path Tuple are thus added to the datagram header as
			the source routing header. For IPv6 networks, strict
			source routing is used; thus, all the intermediate
			routers in the path are stored in the source routing
			header following the format defined in Section 3 of
			<xref target="RFC6554"/> with the Routing Type set to 3. 
		</t>
			
		<t>For IPv4 networks, loose source routing is used with the following rules: 
			
			<list style="symbols">
				<t>
					Only the addresses that exist in the SR-OLSR Router Set can be added to the source routing header. 
				</t>
				
				<t>
					If the length of the path (n) is
					greater than MAX_SRC_HOPS (<xref
					target="parameters_and_constants"/>)
					or if adding the whole path
					information exceeds the MTU, only the
					"key" routers in the path are kept. By
					default, the key routers are uniformly
					chosen in the path. If further
					information, such as the capacity of the routers (e.g., battery life) or the routers' willingness in forwarding data, is available, the routers with higher capacity and willingness are preferred. 
				</t>

				<t>
					The routers that are considered not appropriate for forwarding indicated by external policies should be avoided. 
				</t>
			</list>
		</t> 
		
		<t>
			It is not recommended to fragment the IP packet if the packet with the
source routing header would exceed the minimum MTU along the path. Depending on the size of the routing domain, the MTU should be at least 1280 + 40 (for the outer IP header) + 16 * diameter of the network in number of hops (for the source routing header). If the links in the network have different MTU sizes, by using technologies like Path MTU Discovery, the routers are able to be aware of the MTU along the path. The size of the datagram plus the size of IP headers (including the source routing header) should not exceed the minimum MTU along the path; otherwise, the source routing should not be used. 
		</t>
		
		<t>
			If the destination of the datagrams is out of the MP-OLSRv2 routing domain, the datagram must be source routed to the gateway between the MP-OLSRv2 routing domain and the rest of the Internet. The gateway MUST remove the source routing header before forwarding the datagram to the rest of the Internet. 
		</t>
		
	</section>
	
	<section title="Multipath Calculation" anchor="mp-dijkstra">
	
	<section title="Requirements of Multipath Calculation" anchor="mp-requirements">
		
		<t>
			The Multipath Routing Set maintains the information of multiple paths to the destination. The Path Tuples of the Multipath Routing Set (<xref target="mp-routing_set"/>) are generated based on a multipath algorithm.
		</t>
		
		<t> For each path to a destination, the algorithm must provide:
			<list style="symbols">
				<t> The metric of the path to the destination,  
				</t>
				
				<t>The list of intermediate routers on the path. 
				</t>
			</list>
		</t>
		
		<t>For IPv6 networks, as  strict source routing is used, only the routers that exist in the SR-OLSRv2 Router Set are considered in the path calculation, i.e., only the source-routing-supported routers can exist in the path. 
		</t>
		
		<t> After the calculation of multiple paths, the metric of paths (denoted c_i for path i) to the destination is compared to the R_metric of the OLSRv2 Routing Tuple (<xref target="RFC7181"/>) to the same destination. If the metric c_i is greater than R_metric * CUTOFF_RATIO (<xref target="parameters_and_constants"/>), the corresponding path i SHOULD NOT be used. If less than two paths are found with metrics less than R_metric * CUTOFF_RATIO, the router SHOULD fall back to OLSRv2 Routing Process without using multipath routing. This can happen if there are too many OLSRv2-only routers in the network, and requiring multipath routing may result in inferior paths. 
		</t>
			

				<t>
		By invoking the multipath algorithm, up to NUMBER_OF_PATHS paths are obtained and added to the Multipath Routing Set by creating a Multipath Routing Tuple with:
			<list style="symbols">
				<t>
					MR_dest_addr := destination of the datagram.
				</t>

				<t>
					An MP_path_set with calculated Path Tuples. Each Path Tuple corresponds to a path obtained in the Multipath Dijkstra Algorithm, with PT_metric := metric of the calculated path and PT_address[1, ..., n-1] := list of intermediate routers. 
				</t>
			</list>
		</t>
		
		</section>
		
		<section title="Multipath Dijkstra Algorithm" anchor="multipath-dijkstra">
		
		<t>This section introduces the Multipath Dijkstra Algorithm as a default algorithm. It tries to obtain disjoint paths when appropriate, but it does not guarantee strict disjoint paths.  The use of other algorithms is not prohibited, as long as the requirements described in <xref target="mp-requirements"/> are met. Using different multipath algorithms will not impact the interoperability. 
		</t>
		
		<t>The general principle of the Multipath Dijkstra Algorithm
		<xref target="ADHOC11"/> is to use the Dijkstra Algorithm for
		multiple iterations and to look for the
		shortest path P[i] to the destination d at iteration i. After each iteration, the metric of used links is increased. Compared to the original Dijkstra's algorithm, the main modification consists in adding two incremental functions, named metric functions fp and fe, in order to prevent the next steps resulting in similar paths:
			
			<list style="symbols">
				<t>fp(c) is used to increase metrics of arcs belonging to the previous path P[i-1] (with i>1), where c is the value of the previous metric. This encourages future paths to use different arcs but not different vertices. 
				</t>
				
				<t>fe(c) is used to increase metrics of the arcs that lead to intermediate vertices of the previous path P[i-1] (with i>1), where c is the value of the previous metric. The "lead to" means that only one vertex of the arc belongs to the previous path P[i-1] while the other vertex does not. The "intermediate" means that the source and destination vertices are not considered.  			
				</t>
			</list>			
		</t>
		
		<t>
Consider the simple example in <xref target="cost-function-example-1"/>: a path P[i] S--A--D is obtained at step i. For the next step, the metric of link S--A and A--D are to be increased using fp(c) because they belong to the path P[i]. A--B is to be increased using fe(c) because A is an intermediate vertex of path P[i], and B is not part of P[i]. B--D is unchanged. 
		
		</t>
<figure align="center" anchor="cost-function-example-1" > 
                <artwork align="center"><![CDATA[
                B
             /    \
            /      \ 
           /        \    
S---------A-----------D
               
   ]]>
                </artwork>
</figure>

		
		<t>It is possible to choose a different fp and fe to get link-disjoint paths or node-disjoint paths as desired. A recommendation for configuration of fp and fe is given in <xref target="config-param"/>. 
		</t>

		
		<t>To get NUMBER_OF_PATHS different paths, for each path P[i] (i = 1, ..., NUMBER_OF_PATHS):
				<list  style="numbers">
					<t>Run Dijkstra's algorithm to get the shortest path P[i] for the destination d. </t>
					<t>Apply metric function fp to the metric of links (in both directions) in P[i]. </t>
					<t>Apply metric function fe to the metric of links (in both directions) that lead to routers used in P[i]. 
					</t>

				</list>
		</t>
		
		<t>A simple example of the Multipath Dijkstra Algorithm is illustrated in <xref target="mp-dijkstra-example"/>.  
		</t>
		
		</section>
		
	</section>
	
	<section title="Multipath Routing Set Updates">
	
	<t>   The Multipath Routing Set MUST be updated when the Local
	Information Base, the Neighborhood Information Base, or the Topology
	Information Base indicate a change (including a change of any potentially used outgoing neighbor metric values) of the known symmetric links and/or attached networks in the MANET, hence, changing the Topology Graph as described in Section 17.7 of <xref target="RFC7181"/>. How the Multipath Routing Set is updated depends on whether the set is maintained reactively or proactively:
	
	<list style="symbols">
		<t> In reactive mode, all the Tuples in the Multipath Routing Set are removed. The new arriving datagrams will be processed as specified in <xref target="orig-processing"/>.
		</t>
		
		<t> In proactive mode, the routes to all the destinations are updated according to <xref target="mp-dijkstra"/>. 
		</t>
	</list>
	
	</t>
	
	
	
	</section>
	
	<section title="Datagram Forwarding">
		<t>
			In IPv4 networks, datagrams are forwarded using loose source routing as specified in Section 3.1 of <xref target="RFC0791"/>. 
		</t>
		
		<t>
			In IPv6 networks, datagrams are forwarded using strict source routing as specified in Section 4.2 of <xref target="RFC6554"/>, except the applied routers are MP-OLSRv2 routers rather than RPL routers. The last hop of the source route MUST remove the source routing header.  
		</t>
	


	</section>
</section>
<section title="Configuration Parameters" anchor="config-param">
	<t>
		This section gives default values and guidelines for setting parameters defined in <xref target="parameters_and_constants"/>. Network administrators may wish to change certain or all the parameters for different network scenarios. As an experimental protocol, the users of this protocol are also encouraged to explore different parameter settings in various network environments and provide feedback. 
	</t>
	
	<t>
		<list style="symbols">
			<t> NUMBER_OF_PATHS := 3. This parameter defines the number of parallel paths used in datagram forwarding. Setting it to 1 makes the specification identical to OLSRv2. Setting it to too large of a value may lead to unnecessary computational overhead and inferior paths.</t>
			<t> MAX_SRC_HOPS := 10, for IPv4 networks. For IPv6
			networks, it MUST be set to 0, i.e., no constraint on
			the maximum number of hops.</t>
			<t> CUTOFF_RATIO := 1.5. It MUST be greater than or equal to 1. </t>

			<t> SR_TC_INTERVAL := 10 x TC_INTERVAL. It MUST be greater than or equal to TC_INTERVAL. It SHOULD be significantly greater than TC_INTERVAL to reduce unnecessary TC message generations. 
			</t>
			
			<t> SR_HOLD_TIME := 3 x SR_TC_INTERVAL. It MUST be greater than SR_TC_INTERVAL and SHOULD allow for a small number of lost messages.  
			</t>
		</list>
	</t>
	
	<t>
		If the Multipath Dijkstra Algorithm is applied: 
		
		<list style="symbols">
			<t> fp(c) := 4*c, where c is the original metric of the link. </t>
			<t> fe(c) := 2*c, where c is the original metric of the link.</t>
		</list>
	</t>
	<t>
		The setting of metric functions fp and fc defines the preference of obtained multiple disjoint paths. If id is the identity function, i.e., fp(c)=c, three cases are possible:
				 	<list style="symbols">
						<t>if id=fe&lt;fp, only increase the metric of related links;</t>
						<t>if id&lt;fe=fp, apply equal increase to the metric of related nodes and links;</t>
						<t>if id&lt;fe&lt;fp, apply greater increase to the metric of related links.</t>
					</list>
	</t>
	<t>
		Increasing the metric of related links or nodes means avoiding the use of such links or nodes in the next path to be calculated. 
	</t>

</section> 

    <section anchor="Security" title="Security Considerations">
		<t>
			As an extension of <xref target="RFC7181"/>, the security considerations and security architecture illustrated in <xref target="RFC7181"/> are applicable to this MP-OLSRv2 specification.  The implementations without security mechanisms are vulnerable to threats discussed in <xref target="RFC8116"/>.
		</t>
		
		<t>	
		 In a mixed network with OLSRv2-only routers, a compromised router can add SOURCE_ROUTE TLVs in its TC and HELLO messages, which will make other MP-OLSRv2 Routing Processes believe that it supports source routing. This will increase the possibility of being chosen as MPRs and put into the source routing header. The former will make it possible to manipulate the flooding of TC messages and the latter will make the datagram pass through the compromised router. 
		</t>
			
		<t>As with <xref target="RFC7181"/>, a conformant implementation of MP-OLSRv2 MUST, at minimum, implement the security mechanisms specified in <xref target="RFC7183"/> to provide integrity and replay protection of routing control messages.  
		</t>
		
		<t>
			The MP-OLSRv2 Routing Process MUST drop datagrams entering or exiting an OLSRv2/MP-OLSRv2 routing domain that contain a source routing header. Compared to OLSRv2, the use of the source routing header in this specification introduces vulnerabilities related to source routing attacks, which include bypassing filtering devices, bandwidth exhaustion of certain routers, etc.  Those attacks are discussed in Section 5 of <xref target="RFC6554"/> and <xref target="RFC5095"/>. The influence is limited to the OLSRv2/MP-OLSRv2 routing domain because the source routing header is used only in the current routing domain. 
		</t>
		
		<t>
			If the multiple paths are calculated reactively, the datagrams SHOULD be buffered while the paths are being calculated. Because the path calculation is local and no control message is exchanged, the buffering time should be trivial. However, depending on the CPU power and memory of the router, a maximum buffer size SHOULD be set to avoid occupying too much memory of the router. When the buffer is full, the oldest datagrams are dropped. A possible attack that a malicious application could launch would be one in which it initiates a large amount of datagrams to all the other routers in the network, thus triggering path calculation to all the other routers and during which the datagrams are buffered. This might flush other legitimate datagrams. But the impact of the attack is transient: once the path calculation is finished, the datagrams are forwarded and the buffer goes back to empty. 
		</t>
    </section>
<section anchor="IANA" title="IANA Considerations">
	
	<t>
		This section adds one new Message TLV, allocated as a new Type Extension to an existing Message TLV.
	</t>
 
    <section title="Message TLV Types">
    	<t>
    		This specification updates the IANA registry "Type 7 Message TLV
		Type Extensions" by adding the new Type Extension SOURCE_ROUTE, as illustrated in  <xref target="message-tlv-types"/>. 
    	</t>
    	
		<texttable anchor="message-tlv-types"
		 title="SOURCE_ROUTE type for Type 7 Message TLV Type Extensions [RFC5444]">
		   <ttcol align="center">Type Extension</ttcol>
		  <ttcol align="center">Name</ttcol>
		  <ttcol align="center">Description</ttcol>
		  <ttcol align="left">Reference</ttcol>
		  
		  <c>2</c><c>SOURCE_ROUTE</c><c>Indicates that the originator of the message supports source-route forwarding. No value. </c><c>This specification</c>
		</texttable>
    </section>

	</section>
      </middle>

<back>
<references title="Normative References">

<?rfc include="reference.RFC.2119"?>

<?rfc include="reference.RFC.8174"?>

<?rfc include="reference.RFC.7181"?>

<?rfc include="reference.RFC.6130"?>

<?rfc include="reference.RFC.0791"?>

<?rfc include="reference.RFC.6554"?>

<?rfc include="reference.RFC.5444"?>

<?rfc include="reference.RFC.7183"?>

</references>

<references title="Informative References">

<?rfc include="reference.RFC.8200"?>

<?rfc include="reference.RFC.2501"?>

<?rfc include="reference.RFC.2474"?>

<?rfc include="reference.RFC.2991" ?>

<?rfc include="reference.RFC.5095" ?>

<?rfc include="reference.RFC.7722" ?>

<?rfc include="reference.RFC.7779" ?>


<!--draft-ietf-manet-olsrv2-sec-threats-04: Pub'd as RFC 8116-->

<?rfc include="reference.RFC.8116" ?>
	
	<reference anchor="ADHOC11">
		<front>
		<title>Multipath optimized link state routing for mobile ad hoc networks</title>
		<author initials="J" surname="Yi">
		<organization>Nantes University</organization>
		</author>
		<author initials="A" surname="Adnane">
		<organization>Nantes University</organization>
		</author>
		<author initials="S" surname="David">
			<organization>Nantes University</organization>
		</author>
		<author initials="B" surname="Parrein">
			<organization>Nantes University</organization>
		</author>
		<date month="January" year="2011"/>
		</front>
		<seriesInfo name="Elsevier Ad Hoc Networks," value ="Volume 9,
								    Number 1,
								    pp
								    28-47"/>
		<seriesInfo name="DOI" value="10.1016/j.adhoc.2010.04.007"/>
	</reference>

<reference anchor="GIIS14">
<front>
<title>Experimental performance comparison of single-path and multipath
routing in VANETs</title>
<author initials="R" surname="Macedo">
</author>
<author initials="R" surname="Melo">
</author>
<author initials="A" surname="Santos">
</author>
<author initials="M" surname="Nogueria">
</author>
<date month="September" year="2014"/>
</front>
<seriesInfo name="In" value="the Global Information Infrastructure and
  Networking Symposium (GIIS), Volume 1, Number 6, pp 15-19"/>
<seriesInfo name="DOI" value="10.1109/GIIS.2014.6934283"/>
</reference>

<reference anchor="WCNC08">
<front>
<title>Simulation and Performance Analysis of MP-OLSR for Mobile Ad hoc
Networks</title>
<author initials="J" surname="Yi">
<organization>Nantes University</organization>
</author>
<author initials="E" surname="Cizeron">
<organization>Nantes University</organization>
</author>
<author initials="S" surname="Hamma">
<organization>Nantes University</organization>
</author>
<author initials="B" surname="Parrein">
<organization>Nantes University</organization>
</author>
<date year="2008"/>
</front>
<seriesInfo name="In" value="Proceedings of the IEEE Wireless Communications
			      and Networking Conference (WCNC)"/>
<seriesInfo name="DOI" value="10.1109/WCNC.2008.395"/>
</reference>
	

	<reference anchor="WPMC11">
		<front>
		<title>Multipath Routing Protocol for MANET: Application to H.264/SVC Video Content Delivery</title>
				<author initials="J" surname="Yi">
		<organization>Nantes University</organization>
		</author>
		<author initials="B" surname="Parrein">
			<organization>Nantes University</organization>
		</author>
		<author initials="D" surname="Radu">
			<organization>Nantes University</organization>
		</author>
		<date year="2011"/>
		</front>
		<seriesInfo name="Proceedings of" value="the 14th
					     International Symposium on
					     Wireless Personal Multimedia
					     Communications"/>
 	</reference>
 	
<!--draft-ietf-6man-segment-routing-header-07: I-D Exists-->
<reference anchor='IPv6-SRH'>
<front>
<title>IPv6 Segment Routing Header (SRH)</title>

<author initials='S' surname='Previdi' fullname='Stefano Previdi' role="editor">
    <organization />
</author>

<author initials='C' surname='Filsfils' fullname='Clarence Filsfils'>
    <organization />
</author>

<author initials='K' surname='Raza' fullname='Kamran Raza'>
    <organization />
</author>

<author initials='J' surname='Leddy' fullname='John Leddy'>
    <organization />
</author>

<author initials='B' surname='Field' fullname='Brian Field'>
    <organization />
</author>

<author initials='D' surname='Voyer' fullname='Daniel Voyer'>
    <organization />
</author>

<author initials='S' surname='Bernier' fullname='Daniel Bernier'>
    <organization />
</author>

<author initials='S' surname='Matsushima' fullname='Satoru Matsushima'>
    <organization />
</author>

<author initials='I' surname='Leung' fullname='Ida Leung'>
    <organization />
</author>

<author initials='J' surname='Linkova' fullname='Jen Linkova'>
    <organization />
</author>

<author initials='E' surname='Aries' fullname='Ebben Aries'>
    <organization />
</author>

<author initials='T' surname='Kosugi' fullname='Tomoya Kosugi'>
    <organization />
</author>

<author initials='E' surname='Vyncke' fullname='Eric Vyncke'>
    <organization />
</author>

<author initials='D' surname='Lebrun' fullname='David Lebrun'>
    <organization />
</author>

<author initials='D' surname='Steinberg' fullname='Dirk Steinberg'>
    <organization />
</author>

<author initials='R' surname='Raszuk' fullname='Robert Raszuk'>
    <organization />
</author>

<date month='July' year='2017' />

<abstract><t>Segment Routing (SR) allows a node to steer a packet through a controlled set of instructions, called segments, by prepending an SR header to the packet.  A segment can represent any instruction, topological or service-based.  SR allows to enforce a flow through any path (topological, or application/service based) while maintaining per-flow state only at the ingress node to the SR domain.  Segment Routing can be applied to the IPv6 data plane with the addition of a new type of Routing Extension Header.  This draft describes the Segment Routing Extension Header Type and how it is used by SR capable nodes.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-6man-segment-routing-header-07' />

</reference>
 	
  </references>
  
  <section title="Examples of Multipath Dijkstra Algorithm" anchor="mp-dijkstra-example">

	<t>
		This appendix gives two examples of the Multipath Dijkstra Algorithm. 
	</t>
	

	
	<t>A network topology is depicted in <xref target="on-demand_topology"/>.  </t>


        <figure align="center" anchor="on-demand_topology" > 
                <artwork align="center"><![CDATA[
   .-----A-----(2)
  (1)   / \     \
 /     /   \     \
S     (2)   (1)   D
 \   /       \   /
(1) /         \ / (2)
   B----(3)----C
   ]]>
                </artwork>
   </figure>


	   <t>The capital letters are the names of routers. An arbitrary metric with value between 1 and 3 is used. The initial metrics of all the links are indicated in the parentheses. The incremental functions fp(c)=4c and fe(c)=2c are used in this example. Two paths from router S to router D are demanded.</t>
	   <t>On the first run of the Dijkstra Algorithm, the shortest path S->A->D with metric 3 is obtained.</t>
	   <t>The incremental function fp is applied to increase the metric of
	   the link S-A and A-D, and fe is applied to increase the metric of the link A-B and A-C. <xref target="punishment"/> shows the link metrics after the increment.</t>

        <figure align="center" anchor="punishment" > 
                <artwork align="center"><![CDATA[
   .-----A-----(8)
  (4)   / \     \
 /     /   \     \
S     (4)   (2)   D
 \   /       \   /
(1) /         \ / (2)
   B----(3)----C
   ]]>
                </artwork>
   </figure>

	   <t>On the second run of the Dijkstra Algorithm, the second path S->B->C->D with metric 6 is obtained.</t>
	   
	   
	<t>
		As mentioned in <xref target="mp-dijkstra"/>, the Multipath Dijkstra Algorithm does not guarantee strict disjoint paths in order to avoid choosing inferior paths. For example, given the topology in <xref target="disjoint-paths"/>, two paths from node S to D are desired. On the top of the figure, there is a high cost path between S and D.      	
	</t>
	
	<t>
		If an algorithm tries to obtain strict disjoint paths, the two paths obtained will be S--B--D and S--(high cost path)--D, which are extremely unbalanced. It is undesirable because it will cause huge delay variance between the paths. By using the Multipath Dijkstra Algorithm, which is based on the punishing scheme, S--B--D and S--B--C--D will be obtained. 
	</t>
	
                <figure align="center" anchor="disjoint-paths" > 
                <artwork align="center"><![CDATA[
  --high cost path-
 /                 \
/                   \
S----B--------------D
      \           /
       \---C-----/


   ]]>
                </artwork>
   </figure>

</section> 

<section title="Acknowledgments" numbered="no">
        <t>The authors would like to thank Sylvain David, Asmaa Adnane, Eddy
        Cizeron, Salima Hamma, Pascal Lesage, and Xavier Lecourtier for their
        efforts in developing, implementing, and testing the
        specification. The authors also appreciate valuable discussions with
        Thomas Clausen, Ulrich Herberg, Justin Dean, Geoff Ladwig, Henning
        Rogge, Marcus Barkowsky, and especially Christopher Dearlove for his
        multiple rounds of reviews during the working group last calls.
        </t>
</section>

</back>
</rfc>

