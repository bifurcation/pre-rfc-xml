<?xml version='1.0' encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>


<rfc category="std"
     ipr="trust200902"
     number="8572" submissionType="IETF" consensus="yes">
    <front>
        <title abbrev="Secure Zero Touch Provisioning (SZTP)">Secure Zero Touch Provisioning (SZTP)</title>

<!--Note: changed order of authors per the RFC Editor note.-->

        <author initials="K.W." surname="Watsen" fullname="Kent Watsen">
            <organization>Watsen Networks</organization>
            <address>
                <email>kent+ietf@watsen.net</email>
            </address>
        </author>

        <author initials="I.F." surname="Farrer" fullname="Ian Farrer">
            <organization>Deutsche Telekom AG</organization>
            <address>
                <email>ian.farrer@telekom.de</email>
            </address>
        </author>

        <author initials="M.A." surname="Abrahamsson" fullname="Mikael Abrahamsson">
            <organization>T-Systems</organization>
            <address>
                <email>mikael.abrahamsson@t-systems.se</email>
            </address>
        </author>

        <date month="April" year="2019"/>
        <area>Operations</area>
        <workgroup>NETCONF Working Group</workgroup>
        <keyword>zerotouch</keyword>
        <keyword>bootstrap</keyword>
        <keyword>sztp</keyword>
        <keyword>ztp</keyword>


<!--[rfced] ADs and authors, the Security Considerations (Section 9) does not
contain the boilerplate text for YANG module security considerations (see
https://trac.ietf.org/trac/ops/wiki/yang-security-guidelines). We see some
language from the boilerplate in Section 9.16 but not all.  Please review to
confirm if this is correct or if any updates are needed.
-->


        <abstract>
            <t>This document presents a technique to securely provision a networking
            device when it is booting in a factory-default state.  Variations
            in the solution enable it to be used on both public and private
            networks.  The provisioning steps are able to update the boot image,
            commit an initial configuration, and execute arbitrary scripts to
            address auxiliary needs.  The updated device is subsequently able
            to establish secure connections with other systems.  For instance,
            a device may establish NETCONF (RFC 6241) and/or RESTCONF (RFC 8040)
            connections with deployment-specific network management systems.</t>
        </abstract>
     
    </front>

    <middle>
      <section title="Introduction">

        <t>A fundamental business requirement for any network operator is
        to reduce costs where possible.  For network operators, deploying
        devices to many locations can be a significant cost, as sending
        trained specialists to each site for installations is both cost
        prohibitive and does not scale.</t>

        <t>This document defines Secure Zero Touch Provisioning (SZTP),
        a bootstrapping strategy enabling devices to securely obtain
        bootstrapping data with no installer action beyond physical
        placement and connecting network and power cables.  As such,
        SZTP enables non-technical personnel to bring up devices in
        remote locations without the need for any operator input.</t>

        <t>The SZTP solution includes updating the boot image,
        committing an initial configuration, and executing arbitrary scripts to
        address auxiliary needs.  The updated device is subsequently able to
        establish secure connections with other systems. 

        For instance, a
        device may establish NETCONF  <xref target="RFC6241"/> and/or RESTCONF
        <xref target="RFC8040"/> connections with deployment-specific network
        management systems.</t>

        <t>This document primarily regards physical devices, where the setting
        of the device's initial state (described in <xref target="initial-state"/>)
        occurs during the device's manufacturing process.  The SZTP solution
        may be extended to support virtual machines or other such logical
        constructs, but details for how this can be accomplished is left
        for future work.</t>


        <section title="Use Cases" anchor="use-cases">
          <t>
            <list style="symbols">
              <t>Device connecting to a remotely administered network
                <list style="empty">
                  <t>This use case involves scenarios, such as a remote branch office
                  or convenience store, whereby a device connects as an access gateway
                  to an ISP's network.  Assuming it is not possible to customize the
                  ISP's network to provide any bootstrapping support, and with no other
                  nearby device to leverage, the device has no recourse but to reach
                  out to an Internet-based bootstrap server to bootstrap from.</t>
                </list>
              </t>
              <t>Device connecting to a locally administered network
                <list style="empty">
                  <t>This use case covers all other scenarios and differs only in that
                  the device may additionally leverage nearby devices, which may direct
                  it to use a local service to bootstrap from.  If no such information
                  is available, or the device is unable to use the information provided,
                  it can then reach out to the network just as it would for the remotely
                  administered network use case.</t>
                </list>
              </t>
            </list>
          </t>
          <t>Conceptual workflows for how SZTP might be deployed are
          provided in <xref target="workflow-overview"/>.</t>
        </section>


        <section title="Terminology" anchor="terminology">

          <t>This document uses the following terms (sorted alphabetically):
            <list style="hanging" hangIndent="4">

              <t hangText="Artifact:">The term "artifact" is used throughout
	      this document to represent
              any of the three artifacts defined in <xref target="artifacts"/> (conveyed
              information, ownership voucher, and owner certificate).  These artifacts
              collectively provide all the bootstrapping data a device may use.</t>


              <t hangText="Bootstrapping Data:">The term "bootstrapping data" is used
              throughout this document to refer to the collection of data that a device
              may obtain during the bootstrapping process.  Specifically, it refers
              to the three artifacts defined in <xref target="artifacts"/>
	      (conveyed information, owner certificate, and
              ownership voucher).</t>

              <t hangText="Bootstrap Server:">The term "bootstrap server" is used within
              this document to mean any RESTCONF server implementing the YANG module
              defined in <xref target="yang-module"/>.</t>

              <t hangText="Conveyed Information:">The term "conveyed information" is used
              herein to refer to either redirect information or onboarding information.
              Conveyed information is one of the three bootstrapping artifacts described in
              <xref target="artifacts"/>.</t>

              <t hangText="Device:">The term "device" is used throughout this document
              to refer to a network element that needs to be bootstrapped.  See
              <xref target="device-details"/> for more information about devices.</t>

              <t hangText="Manufacturer:">The term "manufacturer" is used herein to
              refer to the manufacturer of a device or a delegate of the manufacturer.</t>

              <t hangText="Network Management System (NMS):">The acronym "NMS" is used
              throughout this document to refer to the deployment-specific management
              system that the bootstrapping process is responsible for introducing devices to.
              From a device's perspective, when the bootstrapping process has completed,
              the NMS is a NETCONF or RESTCONF client.</t>

              <t hangText="Onboarding Information:">The term "onboarding information" is used
              herein to refer to one of the two types of "conveyed information"
              defined in this document, the other being "redirect information".  Onboarding
              information is formally defined by the "onboarding-information"
	      container within the "conveyed-information" yang-data
              structure in <xref target="info-yang-module"/>.</t>

              <t hangText="Onboarding Server:">The term "onboarding server" is used
              herein to refer to a bootstrap server that only returns onboarding
              information.</t>

              <t hangText="Owner:">The term "owner" is used throughout this document
              to refer to the person or organization that purchased or otherwise owns
              a device.</t>

              <t hangText="Owner Certificate:">The term "owner certificate" is used in
              this document to represent an X.509 certificate that binds an owner identity
              to a public key, which a device can use to validate a signature over the
              conveyed information artifact.  The owner certificate may be communicated
              along with its chain of intermediate certificates leading up to a known
              trust anchor.  The owner certificate is one of the three bootstrapping
              artifacts described in <xref target="artifacts"/>.</t>

              <t hangText="Ownership Voucher:">The term "ownership voucher" is used in
              this document to represent the voucher artifact defined in <xref
              target="RFC8366"/>.  The ownership voucher is used to
              assign a device to an owner.  The ownership voucher is one of
              the three bootstrapping artifacts described in <xref target="artifacts"/>.</t>

              <t hangText="Redirect Information:">The term "redirect information" is used
              herein to refer to one of the two types of "conveyed information"
              defined in this document, the other being "onboarding information".  Redirect
              information is formally defined by the "redirect-information"
	      container within the "conveyed-information" yang-data
              structure in <xref target="info-yang-module"/>.</t>

              <t hangText="Redirect Server:">The term "redirect server" is used to refer
              to a bootstrap server that only returns redirect information.  A redirect
              server is particularly useful when hosted by a manufacturer, as a
              well-known (e.g., Internet-based) resource to redirect devices to
              deployment-specific bootstrap servers.</t>

              <t hangText="Signed Data:">The term "signed data" is used throughout to mean
              conveyed information that has been signed, specifically by a private key
              possessed by a device's owner.</t>

              <t hangText="Unsigned Data:">The term "unsigned data" is used throughout to mean
              conveyed information that has not been signed.</t>
            </list>
          </t>
        </section>

        <section title="Requirements Language" anchor="requirements-language">
          <t>    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
    "MAY", and "OPTIONAL" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.</t>
        </section>

        <section title="Tree Diagrams">
          <t>Tree diagrams used in this document follow the notation
          defined in <xref target="RFC8340"/>.</t>
        </section>
      </section> 


      <section title="Types of Conveyed Information" anchor="types-of-information">

        <t>This document defines two types of conveyed information that devices can access during
        the bootstrapping process.  These conveyed information types are described in
        this section. Examples are provided in <xref target="zt-info-data-model-examples"/>.</t>

        <section title="Redirect Information" anchor="redirect-information">
          <t>Redirect information redirects a device to
          another bootstrap server.  Redirect information encodes a list of bootstrap
          servers, each specifying the bootstrap server's hostname (or IP address),
          an optional port, and an optional trust anchor certificate that the device
          can use to authenticate the bootstrap server with.</t>

          <t>Redirect information is YANG-modeled data formally defined by the
          "redirect-information" container in the YANG module presented in
          <xref target="info-yang-module"/>.  This container has the tree
          diagram shown below.</t>
          <t><figure>
            <artwork name="redirect-information-tree.txt" align="center"><![CDATA[
+--:(redirect-information)
   +-- redirect-information
      +-- bootstrap-server* [address]
         +-- address         inet:host
         +-- port?           inet:port-number
         +-- trust-anchor?   cms
]]></artwork>
          </figure></t>

          <t>Redirect information may be trusted or untrusted.  The redirect information
          is trusted whenever it is obtained via a secure connection to a trusted bootstrap
          server or whenever it is signed by the device's owner.  In all other
          cases, the redirect information is untrusted.</t>

          <t>Trusted redirect information is useful for enabling a device to establish
          a secure connection to a specified bootstrap server, which is possible when the redirect
          information includes the bootstrap server's trust anchor certificate.</t>

          <t>Untrusted redirect information is useful for directing a device to a bootstrap
          server where signed data has been staged for it to obtain.  Note that, when the
          redirect information is untrusted, devices discard any potentially included trust
          anchor certificates.</t>

          <t>How devices process redirect information is described in
          <xref target="process-redirect-information"/>.</t>
        </section>

        <section title="Onboarding Information" anchor="onboarding-information">

          <t>Onboarding information provides data necessary for a device
          to bootstrap itself and establish secure connections with other
          systems.  As defined in this document, onboarding information can
          specify details about the boot image a device must be running, 
          an initial configuration the device must commit, and 
          scripts that the device must successfully execute.</t>

          <t>Onboarding information is YANG-modeled data formally defined by the
          "onboarding-information" container in the YANG module presented in
          <xref target="info-yang-module"/>.  This container has the tree diagram
          shown below.</t>

         <t><figure>
            <artwork name="onboarding-information-tree.txt" align="center"><![CDATA[
+--:(onboarding-information)
   +-- onboarding-information
      +-- boot-image
      |  +-- os-name?              string
      |  +-- os-version?           string
      |  +-- download-uri*         inet:uri
      |  +-- image-verification* [hash-algorithm]
      |     +-- hash-algorithm    identityref
      |     +-- hash-value        yang:hex-string
      +-- configuration-handling?      enumeration
      +-- pre-configuration-script?    script
      +-- configuration?               binary
      +-- post-configuration-script?   script
]]></artwork>
          </figure></t>

          <t>Onboarding information must be trusted for it to be of any use to a device.
          There is no option for a device to process untrusted onboarding information.</t>

          <t>Onboarding information is trusted whenever it is obtained via a secure connection
          to a trusted bootstrap server or whenever it is signed by the device's
          owner.  In all other cases, the onboarding information is untrusted.</t>

          <t>How devices process onboarding information is described in
          <xref target="process-onboarding-information"/>.</t>
        </section>

      </section>

      <section title="Artifacts" anchor="artifacts">

        <t>This document defines three artifacts that can be made available
        to devices while they are bootstrapping.  Each source of bootstrapping
        data specifies how it provides the artifacts defined in this section
        (see <xref target="sources"/>).</t>

        <section title="Conveyed Information" anchor="conveyed-information">
          <t>The conveyed information artifact encodes the essential bootstrapping
          data for the device.  This artifact is used to encode the redirect
          information and onboarding information types discussed in <xref
          target="types-of-information"/>.</t>

          <t>The conveyed information artifact is a Cryptographic Message Syntax (CMS) structure, as described
          in <xref target="RFC5652"/>, encoded using ASN.1 distinguished encoding
          rules (DER), as specified in ITU-T X.690 <xref target="ITU.X690.2015"/>.
          The CMS structure MUST contain content conforming to the
          YANG module specified in <xref target="info-yang-module"/>.</t>

          <t>The conveyed information CMS structure may encode signed or
          unsigned bootstrapping data.  When the bootstrapping data is signed,
          it may also be encrypted, but from a terminology perspective, it
          is still "signed data"; see <xref target="terminology"/>.</t>

          <t>When the conveyed information artifact is unsigned and unencrypted, as it might
          be when communicated over trusted channels, the CMS structure's 
          topmost content type MUST be one of the OIDs described in 
          <xref target="cms_cts"/> (i.e., id-ct-sztpConveyedInfoXML or
          id-ct-sztpConveyedInfoJSON) or the OID id-data (1.2.840.113549.1.7.1).
          When the OID id-data is used, the encoding (JSON, XML, etc.) SHOULD
          be communicated externally. In either case, the associated
          content is an octet string containing "conveyed-information"
          data in the expected encoding.</t>

          <t>When the conveyed information artifact is unsigned and 
          encrypted, as it might be when communicated over trusted
          channels but, for some reason, the operator wants to ensure
          that only the device is able to see the contents, the CMS 
          structure's topmost content type MUST be the OID id-envelopedData
          (1.2.840.113549.1.7.3). Furthermore, the encryptedContentInfo's
          content type MUST be one of the OIDs described in 
          <xref target="cms_cts"/> (i.e., id-ct-sztpConveyedInfoXML
          or id-ct-sztpConveyedInfoJSON) or the OID id-data
          (1.2.840.113549.1.7.1).  When the OID id-data is used,
          the encoding (JSON, XML, etc.) SHOULD be communicated
          externally. In either case, the associated content is
          an octet string containing "conveyed-information" data
          in the expected encoding.</t>

          <t>When the conveyed information artifact is signed and unencrypted, as it might
          be when communicated over untrusted channels, the CMS structure's
          topmost content type MUST be the OID id-signedData (1.2.840.113549.1.7.2).
          Furthermore, the inner eContentType MUST be one of the OIDs described in
          <xref target="cms_cts"/> (i.e., id-ct-sztpConveyedInfoXML or 
          id-ct-sztpConveyedInfoJSON) or the OID id-data (1.2.840.113549.1.7.1).
          When the OID id-data is used, the encoding (JSON, XML, etc.) SHOULD
          be communicated externally.  In either case, the associated content
          or eContent is an octet string containing "conveyed-information"
          data in the expected encoding.</t>

          <t>When the conveyed information artifact is signed and encrypted,
          as it might be when communicated over untrusted channels and 
          privacy is important, the CMS structure's topmost content type
          MUST be the OID id-envelopedData (1.2.840.113549.1.7.3). Furthermore, 
          the encryptedContentInfo's content type MUST be the OID id-signedData
          (1.2.840.113549.1.7.2), whose eContentType MUST be one of the OIDs
          described in <xref target="cms_cts"/> (i.e., id-ct-sztpConveyedInfoXML
          or id-ct-sztpConveyedInfoJSON), or the OID id-data
          (1.2.840.113549.1.7.1).  When the OID id-data is used, the encoding
          (JSON, XML, etc.) SHOULD be communicated externally.  In either case,
          the associated content or eContent is an octet string containing
          "conveyed-information" data in the expected encoding.</t>

        </section>

        <section title="Owner Certificate" anchor="owner-certificate">
          <t>The owner certificate artifact is an X.509 certificate
          <xref target="RFC5280"/> that is used to identify an "owner" (e.g.,
          an organization).  The owner certificate can be signed by any
          certificate authority (CA). 


          The owner certificate MUST have no Key Usage specified, or the Key
          Usage MUST, at a minimum, set the "digitalSignature" bit.  The values for the 
          owner certificate's
          "subject" and/or "subjectAltName" are not constrained by this
          document.</t>

          <t>The owner certificate is used by a device to verify the signature over
          the conveyed information artifact (<xref target="conveyed-information"/>)
          that the device should have also received, as described in
          <xref target="artifact-groupings"/>.  In particular, the device
          verifies the signature using the public key in the owner certificate
          over the content contained within the conveyed information artifact.</t>

          <t>The owner certificate artifact is formally a CMS structure, as
          specified by <xref target="RFC5652"/>, encoded using ASN.1
          DER, as specified in ITU-T X.690
          <xref target="ITU.X690.2015"/>.</t>

          <t>The owner certificate CMS structure MUST contain the owner
          certificate itself, as well as all intermediate certificates leading
          to the "pinned-domain-cert" certificate specified in the ownership
          voucher.  The owner certificate artifact MAY optionally include the
          "pinned-domain-cert" as well.</t>

          <t>In order to support devices deployed on private networks, the
          owner certificate CMS structure MAY also contain suitably fresh, as
          determined by local policy, revocation objects (e.g., Certificate
          Revocation Lists (CRLs) <xref target="RFC5280"/> and OCSP Responses <xref target="RFC6960"/>).  Having these
          revocation objects stapled to the owner certificate may obviate the
          need for the device to have to download them dynamically using the
          CRL distribution point or an Online Certificate Status Protocol
          (OCSP) responder specified in the associated certificates.</t>

<!-- [rfced]  FYI: We updated these sentences as follows to avoid the use of
two possessives in a row. Please let us know any objections.

Original:
   When unencrypted, the owner certificate artifact's CMS structure's
   top-most content type MUST be the OID id-signedData
   (1.2.840.113549.1.7.2). 
...
   When encrypted, the owner certificate artifact's CMS structure's top-
   most content type MUST be the OID id-envelopedData
   (1.2.840.113549.1.7.3), and the encryptedContentInfo's content type
   MUST be the OID id-signedData (1.2.840.113549.1.7.2), ...
...
   When encrypted, the ownership voucher artifact's CMS structure's
   topmost content type MUST be the OID id-envelopedData
   (1.2.840.113549.1.7.3), ...

Updated:
   When unencrypted, the topmost content type of the owner certificate
   artifact's CMS structure MUST be the OID id-signedData
   (1.2.840.113549.1.7.2). 
...
   When encrypted, the topmost content type of the owner certificate
   artifact's CMS structure MUST be the OID id-envelopedData
   (1.2.840.113549.1.7.3), and the encryptedContentInfo's content type
   MUST be the OID id-signedData (1.2.840.113549.1.7.2), ...
...
   When encrypted, the topmost content type of the ownership voucher
   artifact's CMS structure MUST be the OID id-envelopedData
   (1.2.840.113549.1.7.3), ...
-->
          <t>When unencrypted, the topmost content type of the owner certificate artifact's CMS structure
           MUST be the OID id-signedData (1.2.840.113549.1.7.2).
          The inner SignedData structure is the degenerate form, whereby there
          are no signers, that is commonly used to disseminate certificates and
          revocation objects.</t>

          <t>When encrypted, the topmost content type of the owner certificate artifact's CMS structure
           MUST be the OID id-envelopedData 
          (1.2.840.113549.1.7.3), and the encryptedContentInfo's content type
          MUST be the OID id-signedData (1.2.840.113549.1.7.2), whereby the
          inner SignedData structure is the degenerate form that has no signers
          commonly used to disseminate certificates and revocation objects.</t>

        </section>

        <section title="Ownership Voucher" anchor="ownership-voucher">
          <t>The ownership voucher artifact is used to securely identify a device's
          owner, as it is known to the manufacturer. The ownership voucher is signed
          by the device's manufacturer.</t>

          <t>The ownership voucher is used to verify the owner certificate
          (<xref target="owner-certificate"/>) that the device should have also
          received, as described in <xref target="artifact-groupings"/>.  In
          particular, the device verifies that the owner certificate has a chain
          of trust leading to the trusted certificate included in the ownership
          voucher ("pinned-domain-cert").  Note that this relationship holds
          even when the owner certificate is a self-signed certificate and
          hence also the pinned-domain-cert.</t>

          <t>When unencrypted, the ownership voucher artifact is as defined
          in <xref target="RFC8366"/>.  As described, it is
          a CMS structure whose topmost content type MUST be the OID 
          id-signedData (1.2.840.113549.1.7.2), whose eContentType MUST
          be OID id-ct-animaJSONVoucher (1.2.840.113549.1.9.16.1), or the
          OID id-data (1.2.840.113549.1.7.1).  When the OID id-data is used,
          the encoding (JSON, XML, etc.) SHOULD be communicated externally.
          In either case, the associated content is an octet string
          containing ietf-voucher data in the expected encoding.</t>

          <t>When encrypted, the topmost content type of the ownership voucher artifact's CMS structure
           MUST be the OID id-envelopedData 
          (1.2.840.113549.1.7.3), and the encryptedContentInfo's content type
          MUST be the OID id-signedData (1.2.840.113549.1.7.2), whose eContentType
          MUST be OID id-ct-animaJSONVoucher (1.2.840.113549.1.9.16.1), or the OID
          id-data (1.2.840.113549.1.7.1).  When the OID id-data is used, the
          encoding (JSON, XML, etc.) SHOULD be communicated externally.  In
          either case, the associated content is an octet string containing
          ietf-voucher data in the expected encoding.</t>
        </section>

        <section title="Artifact Encryption" anchor="artifact-encryption">
          <t>Each of the three artifacts MAY be individually encrypted.  Encryption
          may be important in some environments where the content is considered
          sensitive.</t>

          <t>Each of the three artifacts are encrypted in the same way, by the
          unencrypted form being encapsulated inside a CMS EnvelopedData type.</t>


   <t>As a consequence, both the conveyed information and ownership voucher
   artifacts are signed and then encrypted; they are never encrypted and then
   signed.</t>

          <t>This sequencing has the following advantages: shrouding the signer's
          certificate and ensuring that the owner knows the content being
          signed.  This sequencing further enables the owner to inspect an
          unencrypted voucher obtained from a manufacturer and then encrypt
          the voucher later themselves, perhaps while also stapling in 
          current revocation objects, when ready to place the artifact
          in an unsafe location.</t>

          <t>When encrypted, the CMS MUST be encrypted using a secure device
          identity certificate for the device.  This certificate MAY be the
          same as the TLS-level client certificate the device uses when
          connecting to bootstrap servers.  The owner must possess the
          device's identity certificate at the time of encrypting the data.
          How the owner comes to posses the device's identity certificate
          for this purpose is outside the scope of this document.</t>
        </section>

        <section title="Artifact Groupings" anchor="artifact-groupings">
          <t>The previous sections discussed the bootstrapping artifacts,
          but only certain groupings of these artifacts make sense to return in the
          various bootstrapping situations described in this document.  These groupings
          are:
            <list style="hanging" hangIndent="6">
                <t hangText="   Unsigned Data:">This artifact grouping is useful for cases
                  when transport-level security can be used to convey trust (e.g., HTTPS)
                  or when the conveyed information can be processed in a provisional manner (i.e.,
                  unsigned redirect information).</t>
                <t hangText="   Signed Data, without revocations:">This artifact grouping
                  is useful when signed data is needed (i.e., because the data is obtained
                  from an untrusted source and it cannot be processed provisionally)
                  and revocations either are not needed or can be obtained
                  dynamically.</t>



                <t hangText="   Signed Data, with revocations:">This artifact
		grouping is useful when signed data is needed (i.e., because
		the data is obtained
                from an untrusted source and it cannot be processed
                provisionally) and when revocations are needed but the
                revocations cannot be obtained dynamically.
                </t>
            </list>
          </t>
          <t>The presence of each artifact and any distinguishing characteristics are identified
             for each artifact grouping in the table below ("yes" and "no"
	     indicate whether or not the
              artifact is present in the artifact grouping):
            <figure>
              <artwork align="center"><![CDATA[
+---------------------+---------------+--------------+--------------+
| Artifact            | Conveyed      | Ownership    | Owner        |
| Grouping            | Information   | Voucher      | Certificate  |
+=====================+===============+==============+==============+
| Unsigned Data       | Yes, no sig   | No           | No           |
+---------------------+---------------+--------------+--------------+
| Signed Data,        | Yes, with sig | Yes, without | Yes, without |
| without revocations |               | revocations  | revocations  |
+---------------------+---------------+--------------+--------------+
| Signed Data,        | Yes, with sig | Yes, with    | Yes, with    |
| with revocations    |               | revocations  | revocations  |
+---------------------+---------------+--------------+--------------+
]]></artwork>
            </figure>
          </t>
        </section>
      </section>

      <section title="Sources of Bootstrapping Data" anchor="sources">

        <t>This section defines some sources for bootstrapping data that a device
        can access.  The list of sources defined here is not meant to be exhaustive.
        It is left to future documents to define additional sources for obtaining
        bootstrapping data.</t>

        <t>For each source of bootstrapping data defined in this section, details
        are given for how the three artifacts listed in <xref target="artifacts"/>
        are provided.</t>

        <section title="Removable Storage" anchor="removable-storage">
          <t>A directly attached removable storage device (e.g., a USB flash drive)
          MAY be used as a source of SZTP bootstrapping data.</t>

          <t>Use of a removable storage device is compelling, as it does not require
          any external infrastructure to work.  It is notable that the raw boot
          image file can also be located on the removable storage device, enabling
          a removable storage device to be a fully self-standing bootstrapping
          solution.</t>

          <t>To use a removable storage device as a source of bootstrapping data,
          a device need only detect if the removable storage device is plugged in
          and mount its filesystem.</t>

          <t>A removable storage device is an untrusted source of bootstrapping data.
          This means that the information stored on the removable storage
	  device either
          MUST be signed or MUST be information that can be processed
          provisionally (e.g., unsigned redirect information).</t>

          <t>From an artifact perspective, since a removable storage device presents
          itself as a filesystem, the bootstrapping artifacts need to be presented
          as files.  The three artifacts defined in <xref target="artifacts"/> are
          mapped to files below.</t>

          <t>Artifact to File Mapping:
            <list style="hanging" hangIndent="6">
              <t hangText="   Conveyed Information:">Mapped to a file containing
              the binary artifact described in <xref target="conveyed-information"/>
              (e.g., conveyed-information.cms).</t>
              <t hangText="   Owner Certificate:">Mapped to a file containing the
              binary artifact described in <xref target="owner-certificate"/>
              (e.g., owner-certificate.cms).</t>
              <t hangText="   Ownership Voucher:">Mapped to a file containing the
              binary artifact described in <xref target="ownership-voucher"/>
              (e.g., ownership-voucher.cms or ownership-voucher.vcj).</t>
            </list>
          </t>
          <t>The format of the removable storage device's filesystem and the naming of the
          files are outside the scope of this document.  However, in order to facilitate
          interoperability, it is RECOMMENDED that devices support open and/or standards-based
          filesystems.  It is also RECOMMENDED that devices assume a file naming convention
          that enables more than one instance of bootstrapping data (i.e., for different
          devices) to exist on a removable storage device.  The file naming convention 
          SHOULD additionally be unique to the manufacturer, in order to enable bootstrapping
          data from multiple manufacturers to exist on a removable storage device.</t>
        </section>

        <section title="DNS Server" anchor="dns-server">
          <t>A DNS server MAY be used as a source of SZTP bootstrapping data.</t>

          <t>Using a DNS server may be a compelling option for deployments having
          existing DNS infrastructure, as it enables a touchless bootstrapping option
          that does not entail utilizing an Internet-based resource hosted by a
          third party.</t>

          <t>DNS is an untrusted source of bootstrapping data.  Even if DNSSEC
          <xref target="RFC6698"/> is used to authenticate the various DNS resource
          records (e.g., A, AAAA, CERT, TXT, and TLSA), the device cannot be
          sure that the domain returned to it, e.g., from a DHCP server, belongs
          to its rightful owner.  This means that the information stored in the
          DNS records either MUST be signed (per this document, not DNSSEC) or
          MUST be information that can be processed provisionally (e.g., unsigned
          redirect information).</t>

          <section title="DNS Queries" toc="exclude">

            <t>Devices claiming to support DNS as a source of bootstrapping
            data MUST first query for device-specific DNS records and then, only
            if doing so does not result in a successful bootstrap, MUST
            query for device-independent DNS records.</t>

            <t>For each of the device-specific and device-independent queries,
            devices MUST first query using multicast DNS <xref target="RFC6762"/>
            and then, only if doing so does not result in a successful bootstrap,
            MUST query again using unicast DNS <xref target="RFC1035"/>
            <xref target="RFC7766"/>. This assumes the address of a DNS server
            is known, such as it may be using techniques similar to those
            described in Section 11 of <xref target="RFC6763"/>.
            </t>

            <t>When querying for device-specific DNS records, devices 
            MUST query for TXT records <xref target="RFC1035"/> under
            "&lt;serial-number&gt;._sztp", where &lt;serial-number&gt;
            is the device's serial number (the same value as in the
            device's secure device identity certificate), and "_sztp"
            is the globally scoped DNS attribute registered per this document
            (see <xref target="_sztp_attr"/>).</t>

            <t>Example device-specific DNS record queries:
              <?rfc subcompact="yes"?>
              <list style="empty">
                <t>TXT in &lt;serial-number&gt;._sztp.local.  (multicast)</t>
                <t>TXT in &lt;serial-number&gt;._sztp.&lt;domain&gt;.  (unicast)</t>
              </list>
              <?rfc subcompact="no"?>
            </t>


            <t>When querying for device-independent DNS records, devices MUST
            query for SRV records <xref target="RFC2782"/> under "_sztp._tcp",
            where "_sztp" is the service name registered per this document
            (see <xref target="dns_srv"/>), and "_tcp" is the globally scoped DNS
            attribute registered per <xref target="RFC8552"/>.</t>

            <t>Note that a device-independent response is only able to
            encode unsigned data anyway, since signed data necessitates the use of a
            device-specific ownership voucher.  Use of SRV records maximumly
            leverages existing DNS standards.  A response containing multiple
            SRV records is comparable to an unsigned redirect information's
            list of bootstrap servers.</t>

            <t>Example device-independent DNS record queries:
              <?rfc subcompact="yes"?>
              <list style="empty">
                <t>SRV in _sztp._tcp.local.  (multicast)</t>
                <t>SRV in _sztp._tcp.&lt;domain&gt;.  (unicast)</t>
              </list>
              <?rfc subcompact="no"?>
            </t>
          </section>

          <section title="DNS Response for Device-Specific Queries" toc="exclude">

            <t>For device-specific queries, the three bootstrapping artifacts defined
            in <xref target="artifacts"/> are encoded into the TXT records using 
            key/value pairs, similar to the technique described in Section 6.3
            of <xref target="RFC6763"/>.</t>
  
            <t>Artifact to TXT Record Mapping:
              <list style="hanging" hangIndent="6">
                <t hangText="   Conveyed Information:">Mapped to a TXT record
                having the key "ci" and the value being the binary
                artifact described in <xref target="conveyed-information"/>.</t>
                <t hangText="   Owner Certificate:">Mapped to a TXT record
                having the key "oc" and the value being the binary
                artifact described in <xref target="owner-certificate"/>.</t>
                <t hangText="   Ownership Voucher:">Mapped to a TXT record
                having the key "ov" and the value being the binary
                artifact described in <xref target="ownership-voucher"/>.</t>
              </list>
            </t>
  
            <t>Devices MUST ignore any other keys that may be returned.</t>
  
            <t>Note that, despite the name, TXT records can and SHOULD (per
            Section 6.5 of <xref target="RFC6763"/>) encode binary data.</t>
  
            <t>Following is an example of a device-specific response, as 
            it might be presented by a user agent, containing signed data.
            This example assumes that the device's serial number is 
            "&lt;serial-number&gt;", the domain is "example.com", and
            "&lt;binary data&gt;" represents the binary artifact:
              <figure>
                <artwork align="center"><![CDATA[
<serial-number>._sztp.example.com. 3600 IN TXT "ci=<binary data>"
<serial-number>._sztp.example.com. 3600 IN TXT "oc=<binary data>"
<serial-number>._sztp.example.com. 3600 IN TXT "ov=<binary data>"
]]></artwork>
              </figure>
            </t>

            <t>Note that, in the case that "ci" encodes unsigned data,
            the "oc" and "ov" keys would not be present in the response.</t>
          </section>
  
          <section title="DNS Response for Device-Independent Queries" toc="exclude">
            <t>For device-independent queries, the three bootstrapping
            artifacts defined in <xref target="artifacts"/> are encoded
            into the SVR records as follows.</t>
  
            <t>Artifact to SRV Record Mapping:
              <list style="hanging" hangIndent="6">
                <t hangText="   Conveyed Information:">This artifact is not supported
                directly.  Instead, the essence of unsigned redirect information is
                mapped to SVR records per <xref target="RFC2782"/>.</t>


                <t hangText="   Owner Certificate:">Not supported.  Device-independent
                responses never encode signed data; hence, there is no need for
                an owner certificate artifact.</t>
                <t hangText="   Ownership Voucher:">Not supported.  Device-independent
                responses never encode signed data; hence, there is no need for
                an ownership voucher artifact.</t>
              </list>
            </t>
  
            <t>Following is an example of a device-independent response, as
            it might be presented by a user agent, containing (effectively)
            unsigned redirect information to four bootstrap servers.  This
            example assumes that the domain is "example.com" and that there
            are four bootstrap servers "sztp[1-4]":
              <figure>
                <artwork align="center">
_sztp._tcp.example.com. 1800 IN SRV 0 0 443 sztp1.example.com.
_sztp._tcp.example.com. 1800 IN SRV 1 0 443 sztp2.example.com.
_sztp._tcp.example.com. 1800 IN SRV 2 0 443 sztp3.example.com.
_sztp._tcp.example.com. 1800 IN SRV 2 0 443 sztp4.example.com.
</artwork>
              </figure>
            </t>

            <t>Note that, in this example, "sztp3" and "sztp4" have equal
            priority and hence effectively represent a clustered pair
            of bootstrap servers.  While "sztp1" and "sztp2" only have
            a single SRV record each, it may be that the record points
            to a load balancer fronting a cluster of bootstrap servers.</t>

            <t>While this document does not use DNS-SD <xref target="RFC6763"/>,
            per Section 12.2 of that RFC, Multicast DNS (mDNS) responses SHOULD also include
            all address records (type "A" and "AAAA") named in the SRV rdata.</t>
          </section>

          <section title="Size of Signed Data" toc="exclude">

            <t>The signed data artifacts are large by DNS conventions.  In the
            smallest-footprint scenario, they are each a few kilobytes in size.
            However, onboarding information can easily be several kilobytes in
            size and has the potential to be many kilobytes in size.</t>
  
            <t>All resource records, including TXT records, have an upper size
            limit of 65535 bytes, since "RDLENGTH" is a 16-bit field
            (Section 3.2.1 of <xref target="RFC1035"/>).  If it is ever 
            desired to encode onboarding information that exceeds this
            limit, the DNS records returned should instead encode redirect
            information, to direct the device to a bootstrap server from
            which the onboarding information can be obtained.</t>
  
            <t>Given the expected size of the TXT records, it is unlikely
            that signed data will fit into a UDP-based DNS packet, even
            with the Extension Mechanisms for DNS (EDNS(0)) extensions <xref target="RFC6891"/> enabled.
            Depending on content, signed data may also not fit into a
            multicast DNS packet, which bounds the size to 9000 bytes,
            per Section 17 of <xref target="RFC6762"/>.  Thus, it is
            expected that DNS Transport over TCP <xref target="RFC7766"/>
            will be required in order to return signed data.</t>
          </section>

        </section> 

        <section title="DHCP Server" anchor="dhcp-server">
          <t>A DHCP server MAY be used as a source of SZTP bootstrapping data.</t>

          <t>Using a DHCP server may be a compelling option for deployments having
          existing DHCP infrastructure, as it enables a touchless bootstrapping option
          that does not entail utilizing an Internet-based resource hosted by a
          third party.</t>

          <t>A DHCP server is an untrusted source of bootstrapping data.  Thus, the
          information stored on the DHCP server either MUST be signed or MUST be
          information that can be processed provisionally (e.g., unsigned redirect
          information).</t>

          <t>However, unlike other sources of bootstrapping data described
          in this document, the DHCP protocol (especially DHCP for IPv4) is very
          limited in the amount of data that can be conveyed, to the extent that
          signed data cannot be communicated.  This means that only unsigned
          redirect information can be conveyed via DHCP.</t>

          <t>Since the redirect information is unsigned, it SHOULD NOT include the
          optional trust anchor certificate, as it takes up space in the DHCP
          message, and the device would have to discard it anyway.  For this
          reason, the DHCP options defined in <xref target="dhcp-options"/> do
          not enable the trust anchor certificate to be encoded.</t>

          <t>From an artifact perspective, the three artifacts defined in
          <xref target="artifacts"/> are mapped to the DHCP fields specified in
          <xref target="dhcp-options"/> as follows.</t>

          <t>Artifact to DHCP Option Fields Mapping:
            <list style="hanging" hangIndent="6">
              <t hangText="   Conveyed Information:">This artifact is not supported
              directly.  Instead, the essence of unsigned redirect information is
              mapped to the DHCP options described in <xref target="dhcp-options"/>.</t>
              <t hangText="   Owner Certificate:">Not supported.  There is not enough
              space in the DHCP packet to hold an owner certificate artifact.</t>
              <t hangText="   Ownership Voucher:">Not supported.  There is not enough
              space in the DHCP packet to hold an ownership voucher artifact.</t>
            </list>
          </t>
        </section>

        <section title="Bootstrap Server" anchor="bootstrap-server">
          <t>A bootstrap server MAY be used as a source of SZTP bootstrapping data.
          A bootstrap server is defined as a RESTCONF <xref target="RFC8040"/>
          server implementing the YANG module provided in <xref target="api"/>.</t>

          <t>Using a bootstrap server as a source of bootstrapping data is a compelling
          option as it MAY use transport-level security, obviating the need for signed
          data, which may be easier to deploy in some situations.</t>

          <t>Unlike any other source of bootstrapping data described in this document,
          a bootstrap server is not only a source of data, but it can also receive data
          from devices using the YANG-defined "report-progress" RPC defined in the YANG
          module provided in <xref target="yang-module"/>.  The "report-progress" RPC enables
          visibility into the bootstrapping process (e.g., warnings and errors) and
          provides potentially useful information upon completion (e.g., the device's
          Secure Shell (SSH) host keys and/or TLS trust anchor certificates).</t>

          <t>A bootstrap server may be a trusted or an untrusted source of bootstrapping
          data, depending on if the device learned about the bootstrap server's trust
          anchor from a trusted source.  When a bootstrap server is trusted, the
          conveyed information returned from it MAY be signed.  When the bootstrap server is
          untrusted, the conveyed information either MUST be signed or MUST be
	  information
          that can be processed provisionally (e.g., unsigned redirect information).</t>

          <t>From an artifact perspective, since a bootstrap server presents data
          conforming to a YANG data model, the bootstrapping artifacts need to be
          mapped to YANG nodes.  The three artifacts defined in <xref target="artifacts"/>
          are mapped to "output" nodes of the "get-bootstrapping-data" RPC defined
          in <xref target="yang-module"/>.</t>

          <t>Artifact to Bootstrap Server Mapping:
            <list style="hanging" hangIndent="6">
              <t hangText="   Conveyed Information:">Mapped to the "conveyed-information"
              leaf in the output of the "get-bootstrapping-data" RPC.</t>
              <t hangText="   Owner Certificate:">Mapped to the "owner-certificate"
              leaf in the output of the "get-bootstrapping-data" RPC.</t>
              <t hangText="   Ownership Voucher:">Mapped to the "ownership-voucher"
              leaf in the output of the "get-bootstrapping-data" RPC.</t>
            </list>
          </t>

          <t>SZTP bootstrap servers have only two endpoints: one for the
          "get&nbhy;bootstrapping&nbhy;data" RPC and one for the "report-progress" RPC.
          These RPCs use the authenticated RESTCONF username to isolate the
          execution of the RPC from other devices.</t>

        </section> 

      </section>




      <section title="Device Details" anchor="device-details">

          <t>Devices supporting the bootstrapping strategy described in this
          document MUST have the pre-configured state and bootstrapping logic
          described in the following sections.</t>

          <section title="Initial State" anchor="initial-state">
            <figure>
                <artwork align="center"><![CDATA[
+-------------------------------------------------------------+
|                          <device>                           |
|                                                             |
| +---------------------------------------------------------+ |
| |                   <read/write storage>                  | |
| |                                                         | |
| | 1.  flag to enable SZTP bootstrapping set to "true"     | |
| +---------------------------------------------------------+ |
|                                                             |
| +---------------------------------------------------------+ |
| |                   <read-only storage>                   | |
| |                                                         | |
| | 2.  TLS client cert & related intermediate certificates | |
| | 3.  list of trusted well-known bootstrap servers        | |
| | 4.  list of trust anchor certs for bootstrap servers    | |
| | 5.  list of trust anchor certs for ownership vouchers   | |
| +---------------------------------------------------------+ |
|                                                             |
|   +-----------------------------------------------------+   |
|   |                 <secure storage>                    |   |
|   |                                                     |   |
|   |  6.  private key for TLS client certificate         |   |
|   |  7.  private key for decrypting SZTP artifacts      |   |
|   +-----------------------------------------------------+   |
|                                                             |
+-------------------------------------------------------------+
]]></artwork>
            </figure>
            <t>Each numbered item below corresponds to a numbered item in the diagram above.
            <list style="numbers">

              <t>Devices MUST have a configurable variable that is used to enable/disable
              SZTP bootstrapping.  This variable MUST be enabled by default in
              order for SZTP bootstrapping to run when the device first powers on.
              Because it is a goal that the configuration installed by the bootstrapping
              process disables SZTP bootstrapping, and because the
              configuration may be merged into the existing configuration, using a
              configuration node that relies on presence is NOT RECOMMENDED, as it
              cannot be removed by the merging process.</t>

              <t>Devices that support loading bootstrapping data from bootstrap servers
              (see <xref target="bootstrap-server"/>) SHOULD possess a TLS-level client
              certificate and any intermediate certificates leading to the certificate's
              well-known trust anchor.  The well-known trust anchor certificate may
              be an intermediate certificate or a self-signed root certificate.  To
              support devices not having a client certificate, devices MAY, alternatively
              or in addition to, identify and authenticate themselves to the bootstrap
              server using an HTTP authentication scheme, as allowed by Section 2.5 of
              <xref target="RFC8040"/>; however, this document does not define a
              mechanism for operator input enabling, for example, the entering of
              a password.</t>

              <t>Devices that support loading bootstrapping data from well-known
              bootstrap servers MUST possess a list of the well-known bootstrap servers.
              Consistent with redirect information (<xref target="redirect-information"/>),
              each bootstrap server can be identified by its hostname or IP address and
              an optional port.</t>

              <t>Devices that support loading bootstrapping data from well-known
              bootstrap servers MUST also possess a list of trust anchor certificates
              that can be used to authenticate the well-known bootstrap servers.  For
              each trust anchor certificate, if it is not itself a self-signed root
              certificate, the device SHOULD also possess the chain of intermediate
              certificates leading up to and including the self-signed root certificate.</t>

              <t>Devices that support loading signed data (see <xref target="terminology"/>)
              MUST possess the trust anchor certificates for validating ownership vouchers.
              For each trust anchor certificate, if it is not itself a self-signed
              root certificate, the device SHOULD also possess the chain of intermediate
              certificates leading up to and including the self-signed root certificate.</t>

              <t>Devices that support using a TLS-level client certificate to identify
              and authenticate themselves to a bootstrap server MUST possess the
              private key that corresponds to the public key encoded in the TLS-level
              client certificate.  This private key SHOULD be securely stored, ideally
              in a cryptographic processor, such as a trusted platform module (TPM)
              chip.</t>

              <t>Devices that support decrypting SZTP artifacts MUST posses the
              private key that corresponds to the public key encoded in the secure
              device identity certificate used when encrypting the artifacts.  This
              private key SHOULD be securely stored, ideally in a cryptographic 
              processor, such as a trusted platform module (TPM) chip.  This private
              key MAY be the same as the one associated to the TLS-level client
              certificate used when connecting to bootstrap servers.</t>
            </list>
          </t>
          <t>A YANG module representing this data is provided in
          <xref target="device-model"/>.</t>

        </section>

        <section title="Boot Sequence" anchor="boot-sequence">
          <t>A device claiming to support the bootstrapping strategy defined in this
          document MUST support the boot sequence described in this section.</t>
          <t>
            <figure>
              <artwork align="center"><![CDATA[
    Power On
        |
        v                           No
1.  SZTP bootstrapping configured ------> Boot normally
        |
        | Yes
        v
2.  For each supported source of bootstrapping data,
    try to load bootstrapping data from the source
        |
        |
        v                               Yes
3.  Able to bootstrap from any source? -----> Run with new config
        |
        | No
        v
4.  Loop back to Step 1


Note: At any time, the device MAY be configured via an alternate
      provisioning mechanism (e.g., command-line interface (CLI)).
]]></artwork>
            </figure>
          </t>

          <t>Each numbered item below corresponds to a numbered item in the diagram above.
            <list style="numbers">
              <t>When the device powers on, it first checks to see if SZTP bootstrapping
              is configured, as is expected to be the case for the device's pre-configured
              initial state.   If SZTP bootstrapping is not configured, then the device
              boots normally.</t>

              <t>The device iterates over its list of sources for
              bootstrapping data (<xref target="sources"/>).  Details for
              how to process a source of bootstrapping data are provided
              in <xref target="processing-a-source"/>.</t>

              <t>If the device is able to bootstrap itself from any of
              the sources of bootstrapping data, it runs with the new
              bootstrapped configuration.</t>

              <t>Otherwise, the device MUST loop back through the list of
              bootstrapping sources again.</t>
            </list>
          </t>
          <t>This document does not limit the simultaneous use of alternate
             provisioning mechanisms.  Such mechanisms may include, for instance,
             a CLI, a web-based user interface, or
             even another bootstrapping protocol.  Regardless of how it is
             configured, the configuration SHOULD unset the flag enabling
             SZTP bootstrapping as discussed in <xref target="initial-state"/>.</t>
        </section>  

        <section title="Processing a Source of Bootstrapping Data" anchor="processing-a-source">
          <t>This section describes a recursive algorithm that devices can use to,
          ultimately, obtain onboarding information.  The algorithm is recursive
          because sources of bootstrapping data may return redirect information,
          which causes the algorithm to run again, for the newly discovered sources
          of bootstrapping data.  An expression that captures all possible
          successful sequences of bootstrapping data is: zero or more redirect
	  information
          responses, followed by one onboarding information response.</t>

          <t>An important aspect of the algorithm is knowing when data needs to be
          signed or not.  The following figure provides a summary of options:
          <figure>
            <artwork align="center"><![CDATA[
                             Untrusted Source  Trusted Source
Kind of Bootstrapping Data     Can Provide?     Can Provide?

Unsigned Redirect Info     :       Yes+             Yes
Signed Redirect Info       :       Yes              Yes*
Unsigned Onboarding Info   :        No              Yes
Signed Onboarding Info     :       Yes              Yes*

The '+' above denotes that the source redirected to MUST
return signed data or more unsigned redirect information.

The '*' above denotes that, while possible, it is generally
unnecessary for a trusted source to return signed data.
]]></artwork>
          </figure></t>

          <t>The recursive algorithm uses a conceptual globally scoped variable
          called "trust-state".  The trust-state variable is initialized to FALSE.
          The ultimate goal of this algorithm is for the device to process
          onboarding information (<xref target="onboarding-information"/>)
          while the trust-state variable is TRUE.</t>

          <t>If the source of bootstrapping data (<xref target="sources"/>) is a
          bootstrap server (<xref target="bootstrap-server"/>), and the device is
          able to authenticate the bootstrap server using X.509 certificate path
          validation (<xref target="RFC6125"/>, Section 6) to one of the device's
          pre-configured trust anchors, or to a trust anchor that it learned
          from a previous step, then the device MUST set trust-state to TRUE.</t>

          <t>When establishing a connection to a bootstrap server, whether
          trusted or untrusted, the device MUST identify and authenticate
          itself to the bootstrap server using a TLS-level client certificate
          and/or an HTTP authentication scheme, per Section 2.5 of
          <xref target="RFC8040"/>.  If both authentication mechanisms
          are used, they MUST both identify the same serial number.</t>

          <t>When sending a client certificate, the device MUST also send all of
          the intermediate certificates leading up to, and optionally including,
          the client certificate's well-known trust anchor certificate.</t>

          <t>For any source of bootstrapping data (e.g., <xref target="sources"/>),
          if any artifact obtained is encrypted, the device MUST first decrypt it
          using the private key associated with the device certificate used to
          encrypt the artifact.</t>

          <t>If the conveyed information artifact is signed, and the device
          is able to validate the signed data using the algorithm described in
          <xref target="validating-signed-data"/>, then the device MUST set
          trust-state to TRUE; otherwise, if the device is unable to validate
          the signed data, the device MUST set trust-state to FALSE.  Note that
          this is worded to cover the special case when signed data is returned
          even from a trusted source of bootstrapping data.</t>

          <t>If the conveyed information artifact contains redirect information,
          the device MUST, within limits of how many recursive loops the device
          allows, process the redirect information as described in
          <xref target="process-redirect-information"/>.  Implementations MUST
          limit the maximum number of recursive redirects allowed; the maximum
          number of recursive redirects allowed SHOULD be no more than ten.
          This is the recursion step; it will cause the device to reenter this
          algorithm, but this time the data source will definitely be a bootstrap
          server, as redirect information is only able to redirect devices to
          bootstrap servers.</t>


          <t>If the conveyed information artifact contains onboarding information, and
          trust-state is FALSE, the device MUST exit the recursive algorithm (as
          this is not allowed; see the figure above), returning to the bootstrapping
          sequence described in <xref target="boot-sequence"/>.  Otherwise, the device
          MUST attempt to process the onboarding information as described in
          <xref target="process-onboarding-information"/>.  Whether the processing
          of the onboarding information succeeds or fails, the device MUST exit the
          recursive algorithm, returning to the bootstrapping sequence described
          in <xref target="boot-sequence"/>; the only difference is how it
          responds to the "Able to bootstrap from any source?" conditional described
          in the figure in that section.</t>
        </section>

        <section title="Validating Signed Data" anchor="validating-signed-data">
          <t>Whenever a device is presented signed data, it MUST validate the
          signed data as described in this section.  This includes the case
          where the signed data is provided by a trusted source.</t>
          <t>Whenever there is signed data, the device MUST also be provided
          an ownership voucher and an owner certificate.  How all the needed
          artifacts are provided for each source of bootstrapping data is
          described in <xref target="sources"/>.</t>

          <t>In order to validate signed data, the device MUST first 
          authenticate the ownership voucher by validating its signature to one
          of its pre-configured trust anchors (see <xref target="initial-state"/>),
          which may entail using additional intermediate certificates attached
          to the ownership voucher.  If the device has an accurate clock,
          it MUST verify that the ownership voucher was created in the past
          (i.e., "created-on" &lt; now), and if the "expires-on" leaf is present,
          the device MUST verify that the ownership voucher has not yet expired
          (i.e., now &lt; "expires-on").  The device MUST verify that the ownership
          voucher's "assertion" value is acceptable (e.g., some devices may only
          accept the assertion value "verified").  The device MUST verify that
          the ownership voucher specifies the device's serial number in the
          "serial-number" leaf.  If the "idevid-issuer" leaf is present, the
          device MUST verify that the value is set correctly.  If the authentication
          of the ownership voucher is successful, the device extracts the 
          "pinned-domain-cert" node, an X.509 certificate, that is
          needed to verify the owner certificate in the next step.</t>

          <t>The device MUST next authenticate the owner certificate by performing
          X.509 certificate path verification to the trusted certificate extracted
          from the ownership voucher's "pinned-domain-cert" node.  This verification
          may entail using additional intermediate certificates attached to the
          owner certificate artifact.  If the ownership voucher's
          "domain-cert-revocation-checks" node's value is set to "true", the device
          MUST verify the revocation status of the certificate chain used to sign
          the owner certificate, and if a suitably fresh revocation status is unattainable or
          if it is determined that a certificate has been revoked, the device
          MUST NOT validate the owner certificate.</t>

          <t>Finally, the device MUST verify that the conveyed information
          artifact was signed by the validated owner certificate.</t>
          <t>If any of these steps fail, the device MUST invalidate the
          signed data and not perform any subsequent steps.</t>
        </section>

        <section title="Processing Redirect Information" anchor="process-redirect-information">
          <t>In order to process redirect information (<xref target="redirect-information"/>),
          the device MUST follow the steps presented in this section.</t>

          <t>Processing redirect information is straightforward; the device sequentially
          steps through the list of provided bootstrap servers until it can find one it
          can bootstrap from.</t>

          <t>If a hostname is provided, and the hostname's DNS resolution is to more
          than one IP address, the device MUST attempt to connect to all of the DNS
          resolved addresses at least once, before moving on to the next bootstrap
          server.  If the device is able to obtain bootstrapping data from any of the
          DNS resolved addresses, it MUST immediately process that data, without
          attempting to connect to any of the other DNS resolved addresses.</t>

          <t>If the redirect information is trusted (e.g., trust-state is TRUE), and the
          bootstrap server entry contains a trust anchor certificate, then the device MUST
          authenticate the specified bootstrap server's TLS server certificate
          using X.509 certificate path validation (<xref target="RFC6125"/>, Section 6)
          to the specified trust anchor.  If the bootstrap server entry does not contain
          a trust anchor certificate device, the device MUST establish a provisional
          connection to the bootstrap server (i.e., by blindly accepting its server
          certificate) and set trust-state to FALSE.</t>

          <t>If the redirect information is untrusted (e.g., trust-state is FALSE), the
          device MUST discard any trust anchors provided by the redirect information and
          establish a provisional connection to the bootstrap server (i.e., by blindly
          accepting its TLS server certificate).</t>
        </section>

        <section title="Processing Onboarding Information" anchor="process-onboarding-information">
          <t>In order to process onboarding information (<xref target="onboarding-information"/>),
          the device MUST follow the steps presented in this section.</t>

          <t>When processing onboarding information, the device MUST first process the
          boot image information (if any), then execute the pre-configuration script
          (if any), then commit the initial configuration (if any), and then execute
          the post-configuration script (if any), in that order.</t>

          <t>When the onboarding information is obtained from a trusted bootstrap server,
          the device MUST send the "bootstrap-initiated" progress report and send 
          a terminating "boot-image-installed-rebooting", "bootstrap-complete", or error-specific
          progress report.  


   If the "reporting-level" node of the bootstrap server's
   "get-bootstrapping-data" RPC-reply is the value "verbose", the device MUST
          additionally send all appropriate non-terminating progress reports (e.g.,
          initiated, warning, complete, etc.). 
          Regardless of the reporting level requested
          by the bootstrap server, the device MAY send progress reports beyond 
          those required by the reporting level.
</t>

          <t>When the onboarding information is obtained from an untrusted bootstrap
          server, the device MUST NOT send any progress reports to the bootstrap server,
          even though the onboarding information was, necessarily, signed and authenticated.
          Please be aware that bootstrap servers are recommended to promote untrusted
          connections to trusted connections, in the last paragraph of Section 9.6, so
          as to, in part, be able to collect progress reports from devices.</t>
 
          <t>If the device encounters an error at any step, it MUST stop processing the
          onboarding information and return to the bootstrapping sequence described in
          <xref target="boot-sequence"/>. In the context of a recursive algorithm, the
          device MUST return to the enclosing loop, not back to the very beginning.
          Some state MAY be retained from the bootstrapping process (e.g., updated
          boot image, logs, remnants from a script, etc.).  However, the retained
          state MUST NOT be active in any way (e.g., no new configuration or running
          of software) and MUST NOT hinder the ability for the device to continue
          the bootstrapping sequence (i.e., process onboarding information from
          another bootstrap server).</t>

          <t>At this point, the specific ordered sequence of actions the device MUST
          perform is described.</t>

          <t>If the onboarding information is obtained from a trusted bootstrap server,
          the device MUST send a "bootstrap-initiated" progress report.  It is an error
          if the device does not receive back the "204 No Content" HTTP status line.
          If an error occurs, the device MUST try to send a "bootstrap-error" progress
          report before exiting.</t>

          <t>The device MUST parse the provided onboarding information document, to 
          extract values used in subsequent steps.  Whether using a stream-based parser
          or not, if there is an error when parsing the onboarding information, and the
          device is connected to a trusted bootstrap server, the device MUST try to send
          a "parsing-error" progress report before exiting.</t>

          <t>If boot image criteria are specified, the device MUST first determine if the
          boot image it is running satisfies the specified boot image criteria.  If the 
          device is already running the specified boot image, then it skips the remainder
          of this step.  If the device is not running the specified boot image, then it
          MUST download, verify, and install, in that order, the specified boot
          image, and then reboot.  If connected to a trusted bootstrap server, the
          device MAY try to send a "boot-image-mismatch" progress report.  To download
          the boot image, the device MUST only use the URIs supplied by the onboarding
          information.  To verify the boot image, the device MUST use either one of the
          verification fingerprints supplied by the onboarding information or a
          cryptographic signature embedded into the boot image itself using a mechanism
          not described by this document.  Before rebooting, if connected to a trusted
          bootstrap server, the device MUST try to send a "boot-image-installed-rebooting"
          progress report.  Upon rebooting, the bootstrapping process runs again, which
          will eventually come to this step again, but then the device will be running
          the specified boot image and thus will move to processing the next step.  If
          an error occurs at any step while the device is connected to a trusted
          bootstrap server (i.e., before the reboot), the device MUST try to send
          a "boot-image-error" progress report before exiting.</t>

          <t>If a pre-configuration script has been specified, the device MUST execute the
          script, capture any output emitted from the script, and check if the script had
          any warnings or errors.  If an error occurs while the device is connected to a
          trusted bootstrap server, the device MUST try to send a "pre-script-error"
          progress report before exiting.</t>
 
          <t>If an initial configuration has been specified, the device MUST atomically
          commit the provided initial configuration, using the approach specified by the 
          "configuration-handling" leaf.  If an error occurs while the device is connected
          to a trusted bootstrap server, the device MUST try to send a "config-error"
          progress report before exiting.</t>

          <t>If a post-configuration script has been specified, the device MUST execute the
          script, capture any output emitted from the script, and check if the script had
          any warnings or errors. If an error occurs while the device is connected to a
          trusted bootstrap server, the device MUST try to send a "post-script-error"
          progress report before exiting.</t>

          <t>If the onboarding information was obtained from a trusted bootstrap server,
          and the result of the bootstrapping process did not disable the "flag to enable
          SZTP bootstrapping" described in <xref target="initial-state"/>, the device
          SHOULD send an "bootstrap-warning" progress report.</t>

          <t>If the onboarding information was obtained from a trusted bootstrap server,
          the device MUST send a "bootstrap-complete" progress report.  It is an error
          if the device does not receive back the "204 No Content" HTTP status line.
          If an error occurs, the device MUST try to send a "bootstrap-error" progress
          report before exiting.</t>

          <t>At this point, the device has completely processed the bootstrapping
          data.</t>

          <t>The device is now running its initial configuration.  Notably,
          if NETCONF Call Home or RESTCONF Call Home <xref target="RFC8071"/> is
          configured, the device initiates trying to establish the call home
          connections at this time.</t>

          <t>Implementation Notes:
           <list>
            <t>Implementations may vary in how to ensure no unwanted state is retained
            when an error occurs.</t>

            <t>If the implementation chooses to undo previous steps, the
	    following guidelines apply:
              <list style="symbols">
                <t>When an error occurs, the device must rollback the current step and
                any previous steps.</t>

                <t>Most steps are atomic.  For example, the processing of a configuration
                is atomic (as specified above), and the processing of scripts is atomic (as specified in the "ietf-sztp-conveyed-info" YANG module).</t>
                <t>In case the error occurs after the initial configuration was committed,
                the device must restore the configuration to the configuration that
                existed prior to the configuration being committed.</t>
                <t>In case the error occurs after a script had executed successfully,
                it may be helpful for the implementation to define scripts as being
                able to take a conceptual input parameter indicating that the script
                should remove its previously set state.</t>
              </list>
            </t>
           </list>
          </t>

        </section>
      </section> 

      <section title="The Conveyed Information Data Model" anchor="zt-info-data-model">
        <t>This section defines a YANG 1.1 <xref target="RFC7950"/> module that is used to
        define the data model for the conveyed information artifact described in
        <xref target="conveyed-information"/>.  This data model uses the "yang-data"
        extension statement defined in <xref target="RFC8040"/>.
        Examples illustrating this data model are provided in
        <xref target="zt-info-data-model-examples"/>.</t>

        <section title="Data Model Overview">
          <t>The following tree diagram provides an overview of the data model for the
          conveyed information artifact.</t>
          <figure>
            <artwork name="ietf-sztp-conveyed-info-tree.txt" align="center"><![CDATA[
module: ietf-sztp-conveyed-info

  yang-data conveyed-information:
    +-- (information-type)
       +--:(redirect-information)
       |  +-- redirect-information
       |     +-- bootstrap-server* [address]
       |        +-- address         inet:host
       |        +-- port?           inet:port-number
       |        +-- trust-anchor?   cms
       +--:(onboarding-information)
          +-- onboarding-information
             +-- boot-image
             |  +-- os-name?              string
             |  +-- os-version?           string
             |  +-- download-uri*         inet:uri
             |  +-- image-verification* [hash-algorithm]
             |     +-- hash-algorithm    identityref
             |     +-- hash-value        yang:hex-string
             +-- configuration-handling?      enumeration
             +-- pre-configuration-script?    script
             +-- configuration?               binary
             +-- post-configuration-script?   script
]]></artwork>
          </figure>
        </section>

        <section title="Example Usage" anchor="zt-info-data-model-examples">


          <t>The following example illustrates how redirect information
          (<xref target="redirect-information"/>) can be encoded using JSON
	  <xref target="RFC8259"/>.</t>
          <figure>
            <artwork name="ex-file-redirect-information.json"><![CDATA[
{
  "ietf-sztp-conveyed-info:redirect-information" : {
    "bootstrap-server" : [
      {
        "address" : "sztp1.example.com",
        "port" : 8443,
        "trust-anchor" : "base64encodedvalue=="
      },
      {
        "address" : "sztp2.example.com",
        "port" : 8443,
        "trust-anchor" : "base64encodedvalue=="
      },
      {
        "address" : "sztp3.example.com",
        "port" : 8443,
        "trust-anchor" : "base64encodedvalue=="
      }
    ]
  }
}
]]></artwork>
          </figure>

          <t>The following example illustrates how onboarding information
          (<xref target="onboarding-information"/>) can be encoded using JSON
	  <xref target="RFC8259"/>.</t>



          <figure>
            <artwork name="ex-file-onboarding-information.json"><![CDATA[
[Note: '\' line wrapping for formatting only]

{
  "ietf-sztp-conveyed-info:onboarding-information" : {
    "boot-image" : {
      "os-name" : "VendorOS",
      "os-version" : "17.2R1.6",
      "download-uri" : [ "https://example.com/path/to/image/file" ],
      "image-verification" : [
        {
          "hash-algorithm" : "ietf-sztp-conveyed-info:sha-256",
          "hash-value" : "ba:ec:cf:a5:67:82:b4:10:77:c6:67:a6:22:ab:\
7d:50:04:a7:8b:8f:0e:db:02:8b:f4:75:55:fb:c1:13:b2:33"
        }
      ]
    },
    "configuration-handling" : "merge",
    "pre-configuration-script" : "base64encodedvalue==",
    "configuration" : "base64encodedvalue==",
    "post-configuration-script" : "base64encodedvalue=="
  }
}
]]></artwork>
          </figure>
        </section>

        <section title="YANG Module" anchor="info-yang-module">
          <t>The conveyed information data model is defined
          by the YANG module presented in this section.</t>

          <t>This module uses data types defined in <xref target="RFC5280"/>,
          <xref target="RFC5652"/>, <xref target="RFC6234"/>, and
          <xref target="RFC6991"/>; an extension statement from
          <xref target="RFC8040"/>; and an
          encoding defined in <xref target="ITU.X690.2015"/>.</t>


          <figure>
            <artwork name="ietf-sztp-conveyed-info@2019-01-15.yang"><![CDATA[
<CODE BEGINS> file "ietf-sztp-conveyed-info@2019-03-31.yang"
module ietf-sztp-conveyed-info {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-sztp-conveyed-info";
  prefix sztp-info;

  import ietf-yang-types {
    prefix yang;
    reference
      "RFC 6991: Common YANG Data Types";
  }
  import ietf-inet-types {
    prefix inet;
    reference
      "RFC 6991: Common YANG Data Types";
  }
  import ietf-restconf {
    prefix rc;
    reference
      "RFC 8040: RESTCONF Protocol";
  }

  organization
    "IETF NETCONF (Network Configuration) Working Group";
  contact
    "WG Web:   <https://datatracker.ietf.org/wg/netconf/>
     WG List:  <mailto:netconf@ietf.org>
     Author:   Kent Watsen <mailto:kent+ietf@watsen.net>";
  description
    "This module defines the data model for the conveyed
     information artifact defined in RFC 8572 ('Secure Zero Touch
     Provisioning (SZTP)').

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL',
     'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED',
     'NOT RECOMMENDED', 'MAY', and 'OPTIONAL' in this document
     are to be interpreted as described in BCP 14 (RFC 2119)
     (RFC 8174) when, and only when, they appear in all
     capitals, as shown here.

     Copyright (c) 2019 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 8572; see the
     RFC itself for full legal notices.";

  revision 2019-03-31 {
    description
      "Initial version";
    reference
      "RFC 8572: Secure Zero Touch Provisioning (SZTP)";
  }

  // identities

  identity hash-algorithm {
    description
      "A base identity for hash algorithm verification.";
  }

  identity sha-256 {
    base hash-algorithm;
    description
      "The SHA-256 algorithm.";
    reference
      "RFC 6234: US Secure Hash Algorithms";
  }

  // typedefs

  typedef cms {
    type binary;
    description
      "A ContentInfo structure, as specified in RFC 5652,
       encoded using ASN.1 distinguished encoding rules (DER),
       as specified in ITU-T X.690.";
    reference
      "RFC 5652:
         Cryptographic Message Syntax (CMS)
       ITU-T X.690:
         Information technology - ASN.1 encoding rules:
         Specification of Basic Encoding Rules (BER),
         Canonical Encoding Rules (CER) and Distinguished
         Encoding Rules (DER)";
  }

  // yang-data
  rc:yang-data conveyed-information {
    choice information-type {
      mandatory true;
      description
        "This choice statement ensures the response contains
         redirect-information or onboarding-information.";
      container redirect-information {
        description
          "Redirect information is described in Section 2.1 of
           RFC 8572.  Its purpose is to redirect a device to
           another bootstrap server.";
        reference
          "RFC 8572: Secure Zero Touch Provisioning (SZTP)";
        list bootstrap-server {
          key "address";
          min-elements 1;
          description
            "A bootstrap server entry.";
          leaf address {
            type inet:host;
            mandatory true;
            description
              "The IP address or hostname of the bootstrap server the
               device should redirect to.";
          }
          leaf port {
            type inet:port-number;
            default "443";
            description
              "The port number the bootstrap server listens on.  If no
               port is specified, the IANA-assigned port for 'https'
               (443) is used.";
          }
          leaf trust-anchor {
            type cms;
            description
              "A CMS structure that MUST contain the chain of
               X.509 certificates needed to authenticate the TLS
               certificate presented by this bootstrap server.

               The CMS MUST only contain a single chain of
               certificates.  The bootstrap server MUST only
               authenticate to last intermediate CA certificate
               listed in the chain.

               In all cases, the chain MUST include a self-signed
               root certificate.  In the case where the root
               certificate is itself the issuer of the bootstrap
               server's TLS certificate, only one certificate
               is present.

               If needed by the device, this CMS structure MAY
               also contain suitably fresh revocation objects
               with which the device can verify the revocation
               status of the certificates.

               This CMS encodes the degenerate form of the SignedData
               structure that is commonly used to disseminate X.509
               certificates and revocation objects (RFC 5280).";
            reference
              "RFC 5280:
                 Internet X.509 Public Key Infrastructure Certificate
                 and Certificate Revocation List (CRL) Profile";
          }
        }
      }
      container onboarding-information {
        description
          "Onboarding information is described in Section 2.2 of
           RFC 8572.  Its purpose is to provide the device everything
           it needs to bootstrap itself.";
        reference
          "RFC 8572: Secure Zero Touch Provisioning (SZTP)";
        container boot-image {
          description
            "Specifies criteria for the boot image the device MUST
             be running, as well as information enabling the device
             to install the required boot image.";
          leaf os-name {
            type string;
            description
              "The name of the operating system software the device
               MUST be running in order to not require a software
               image upgrade (e.g., VendorOS).";
          }
          leaf os-version {
            type string;
            description
              "The version of the operating system software the
               device MUST be running in order to not require a
               software image upgrade (e.g., 17.3R2.1).";
          }
          leaf-list download-uri {
            type inet:uri;
            ordered-by user;
            description
              "An ordered list of URIs to where the same boot image
               file may be obtained.  How the URI schemes (http, ftp,
               etc.) a device supports are known is vendor specific.
               If a secure scheme (e.g., https) is provided, a device
               MAY establish an untrusted connection to the remote
               server, by blindly accepting the server's end-entity
               certificate, to obtain the boot image.";
          }
          list image-verification {
            must '../download-uri' {
              description
                "Download URIs must be provided if an image is to
                 be verified.";
            }
            key "hash-algorithm";
            description
              "A list of hash values that a device can use to verify
               boot image files with.";
            leaf hash-algorithm {
              type identityref {
                base hash-algorithm;
              }
              description
                "Identifies the hash algorithm used.";
            }
            leaf hash-value {
              type yang:hex-string;
              mandatory true;
              description
                "The hex-encoded value of the specified hash
                 algorithm over the contents of the boot image
                 file.";
            }
          }
        }
        leaf configuration-handling {
          type enumeration {
            enum merge {
              description
                "Merge configuration into the running datastore.";
            }
            enum replace {
              description
                "Replace the existing running datastore with the
                 passed configuration.";
            }
          }
          must '../configuration';
          description
            "This enumeration indicates how the server should process
             the provided configuration.";
        }
        leaf pre-configuration-script {
          type script;
          description
            "A script that, when present, is executed before the
             configuration has been processed.";
        }
        leaf configuration {
          type binary;
          must '../configuration-handling';
          description
            "Any configuration known to the device.  The use of
             the 'binary' type enables content (e.g., XML) to be
             embedded into a JSON document.  The exact encoding
             of the content, as with the scripts, is vendor
             specific.";
        }
        leaf post-configuration-script {
          type script;
          description
            "A script that, when present, is executed after the
             configuration has been processed.";
        }
      }
    }
  }

  typedef script {
    type binary;
    description
      "A device-specific script that enables the execution of
       commands to perform actions not possible thru configuration
       alone.

       No attempt is made to standardize the contents, running
       context, or programming language of the script, other than
       that it can indicate if any warnings or errors occurred and
       can emit output.  The contents of the script are considered
       specific to the vendor, product line, and/or model of the
       device.

       If the script execution indicates that a warning occurred,
       then the device MUST assume that the script had a soft error
       that the script believes will not affect manageability.

       If the script execution indicates that an error occurred,
       the device MUST assume the script had a hard error that the
       script believes will affect manageability.  In this case,
       the script is required to gracefully exit, removing any
       state that might hinder the device's ability to continue
       the bootstrapping sequence (e.g., process onboarding
       information obtained from another bootstrap server).";
  }
}
<CODE ENDS>
]]></artwork>
          </figure>
        </section>

      </section>

      <section title="The SZTP Bootstrap Server API" anchor="api">

        <t>This section defines the API for bootstrap servers.  The API is
        defined as that produced by a RESTCONF <xref target="RFC8040"/>
        server that supports the YANG 1.1 <xref target="RFC7950"/> module
        defined in this section.</t>

        <section title="API Overview">
          <t>The following tree diagram provides an overview for the bootstrap server
          RESTCONF API.</t>
          <figure>
            <artwork name="ietf-sztp-bootstrap-server-tree.txt" align="center"><![CDATA[
module: ietf-sztp-bootstrap-server

  rpcs:
    +---x get-bootstrapping-data
    |  +---w input
    |  |  +---w signed-data-preferred?   empty
    |  |  +---w hw-model?                string
    |  |  +---w os-name?                 string
    |  |  +---w os-version?              string
    |  |  +---w nonce?                   binary
    |  +--ro output
    |     +--ro reporting-level?    enumeration {onboarding-server}?
    |     +--ro conveyed-information    cms
    |     +--ro owner-certificate?      cms
    |     +--ro ownership-voucher?      cms
    +---x report-progress {onboarding-server}?
       +---w input
          +---w progress-type         enumeration
          +---w message?              string
          +---w ssh-host-keys
          |  +---w ssh-host-key* []
          |     +---w algorithm    string
          |     +---w key-data     binary
          +---w trust-anchor-certs
             +---w trust-anchor-cert*   cms
]]></artwork>
          </figure>
        </section>

        <section title="Example Usage" anchor="api-examples">

          <t>This section presents three examples illustrating the bootstrap server's
          API.  Two examples are provided for the "get-bootstrapping-data" RPC (one
          to an untrusted bootstrap server and the other to a trusted bootstrap server),
          and one example is provided for the "report-progress" RPC.</t>

          <t>The following example illustrates a device using the API to fetch its
          bootstrapping data from an untrusted bootstrap server.  In this example, the
          device sends the "signed-data-preferred" input parameter and receives signed
          data in the response.</t>
          <figure>
            <preamble>REQUEST</preamble>
            <artwork name="ex-api-get-bootstrap-data-rpc-untrusted.xml"><![CDATA[
[Note: '\' line wrapping for formatting only]

POST /restconf/operations/ietf-sztp-bootstrap-server:get-bootstrappi\
ng-data HTTP/1.1
HOST: example.com
Content-Type: application/yang.data+xml

<input
  xmlns="urn:ietf:params:xml:ns:yang:ietf-sztp-bootstrap-server">
  <signed-data-preferred/>
</input>
]]></artwork>
          </figure>
          <figure>
            <preamble>RESPONSE</preamble>
            <artwork name="ex-api-get-bootstrap-data-rpc-reply-untrusted.xml"><![CDATA[
HTTP/1.1 200 OK
Date: Sat, 31 Oct 2015 17:02:40 GMT
Server: example-server
Content-Type: application/yang.data+xml

<output
  xmlns="urn:ietf:params:xml:ns:yang:ietf-sztp-bootstrap-server">
  <conveyed-information>base64encodedvalue==</conveyed-information>
  <owner-certificate>base64encodedvalue==</owner-certificate>
  <ownership-voucher>base64encodedvalue==</ownership-voucher>
</output>
]]></artwork>
          </figure>

<!--[rfrced] We updated 'additon' to be 'additional' in the folllowing
sentence.  If that is not correct, please let us know.

Original:
   In this example,
   the device sends addition input parameters to the bootstrap server,
   which it may use when formulating its response to the device.

Updated:
   In this example,
   the device sends additional input parameters to the bootstrap server,
   which it may use when formulating its response to the device.
-->
          <t>The following example illustrates a device using the API to fetch its
          bootstrapping data from a trusted bootstrap server.  In this example, the
          device sends additional input parameters to the bootstrap server, which it
          may use when formulating its response to the device.</t>
          <figure>
            <preamble>REQUEST</preamble>
            <artwork name="ex-api-get-bootstrap-data-rpc-trusted.xml"><![CDATA[
[Note: '\' line wrapping for formatting only]

POST /restconf/operations/ietf-sztp-bootstrap-server:get-bootstrappi\
ng-data HTTP/1.1
HOST: example.com
Content-Type: application/yang.data+xml

<input
  xmlns="urn:ietf:params:xml:ns:yang:ietf-sztp-bootstrap-server">
  <hw-model>model-x</hw-model>
  <os-name>vendor-os</os-name>
  <os-version>17.3R2.1</os-version>
  <nonce>extralongbase64encodedvalue=</nonce>
</input>
]]></artwork>
          </figure>
          <figure>
            <preamble>RESPONSE</preamble>
            <artwork name="ex-api-get-bootstrap-data-rpc-reply-trusted.xml"><![CDATA[
HTTP/1.1 200 OK
Date: Sat, 31 Oct 2015 17:02:40 GMT
Server: example-server
Content-Type: application/yang.data+xml

<output
  xmlns="urn:ietf:params:xml:ns:yang:ietf-sztp-bootstrap-server">
  <reporting-level>verbose</reporting-level>
  <conveyed-information>base64encodedvalue==</conveyed-information>
</output>
]]></artwork>
          </figure>
          <t>The following example illustrates a device using the API to post
          a progress report to a bootstrap server.  Illustrated below is
          the "bootstrap-complete" message, but the device may send other
          progress reports to the server while bootstrapping.  In this
          example, the device is sending both its SSH host keys and a TLS
          server certificate, which the bootstrap server may, for example,
          pass to an NMS, as discussed in <xref target="device-powers-on"/>.</t>

          <figure>
            <preamble>REQUEST</preamble>
            <artwork name=""><![CDATA[
[Note: '\' line wrapping for formatting only]

POST /restconf/operations/ietf-sztp-bootstrap-server:report-progress\
 HTTP/1.1
HOST: example.com
Content-Type: application/yang.data+xml

<input
  xmlns="urn:ietf:params:xml:ns:yang:ietf-sztp-bootstrap-server">
  <progress-type>bootstrap-complete</progress-type>
  <message>example message</message>
  <ssh-host-keys>
    <ssh-host-key>
      <algorithm>ssh-rsa</algorithm>
      <key-data>base64encodedvalue==</key-data>
    </ssh-host-key>
    <ssh-host-key>
      <algorithm>rsa-sha2-256</algorithm>
      <key-data>base64encodedvalue==</key-data>
    </ssh-host-key>
  </ssh-host-keys>
  <trust-anchor-certs>
    <trust-anchor-cert>base64encodedvalue==</trust-anchor-cert>
  </trust-anchor-certs>
</input>
]]></artwork>
          </figure>
          <figure>
            <preamble>RESPONSE</preamble>
            <artwork><![CDATA[
HTTP/1.1 204 No Content
Date: Sat, 31 Oct 2015 17:02:40 GMT
Server: example-server
]]></artwork>
          </figure>
        </section> 

        <section title="YANG Module" anchor="yang-module">
          <t>The bootstrap server's device-facing API is normatively defined
          by the YANG module defined in this section.</t>

<!--[rfced] Since IEEE 802.1AR is referenced in both YANG modules, we added
the citation [Std-802.1AR] to the following sentences. Please let us
know of any objections.

Also, RFC 6960 is mentioned in the first setence below but is not referenced
in the YANG module. Should a reference be added to the YANG module or should
RFC 6960 be removed?

Original:
   This module uses data types defined in [RFC4253], [RFC5652],
   [RFC5280], [RFC6960], and [RFC8366], uses an encoding defined in
   [ITU.X690.2015], and makes a reference to [RFC4250] and [RFC6187].
...
   This module uses data types defined in [RFC6991],
   [I-D.ietf-netconf-crypto-types], and
   [I-D.ietf-netconf-trust-anchors].

Current:
   This module uses data types defined in [RFC4253], [RFC5652],
   [RFC5280], [RFC6960], and [RFC8366]; uses an encoding defined in
   [ITU.X690.2015]; and makes a reference to [RFC4250], [RFC6187], 
   and [Std-802.1AR].
...
   This module references [Std-802.1AR] and uses data types
   defined in [RFC6991], [YANG-CRYPTOGRAPHY], and
   [YANG-TRUST-ANCHORS].
-->


          <t>This module uses data types defined in <xref target="RFC4253"/>,
          <xref target="RFC5652"/>, <xref target="RFC5280"/>,
          and <xref target="RFC8366"/>; uses
          an encoding defined in <xref target="ITU.X690.2015"/>; and 
          makes a reference to <xref target="RFC4250"/>, 
          <xref target="RFC6187"/>, and <xref target="Std-802.1AR"/>.</t>
          <figure>
            <artwork name="ietf-sztp-bootstrap-server@2019-01-15.yang"><![CDATA[
<CODE BEGINS> file "ietf-sztp-bootstrap-server@2019-03-31.yang"
module ietf-sztp-bootstrap-server {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-sztp-bootstrap-server";
  prefix sztp-svr;

  organization
    "IETF NETCONF (Network Configuration) Working Group";
  contact
    "WG Web:   <https://datatracker.ietf.org/wg/netconf/>
     WG List:  <mailto:netconf@ietf.org>
     Author:   Kent Watsen <mailto:kent+ietf@watsen.net>";
  description
    "This module defines an interface for bootstrap servers, as
     defined by RFC 8572 ('Secure Zero Touch Provisioning (SZTP)').

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL',
     'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED',
     'NOT RECOMMENDED', 'MAY', and 'OPTIONAL' in this document
     are to be interpreted as described in BCP 14 (RFC 2119)
     (RFC 8174) when, and only when, they appear in all
     capitals, as shown here.

     Copyright (c) 2019 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 8572; see the
     RFC itself for full legal notices.";

  revision 2019-03-31 {
    description
      "Initial version";
    reference
      "RFC 8572: Secure Zero Touch Provisioning (SZTP)";
  }

  // features

  feature redirect-server {
    description
      "The server supports being a 'redirect server'.";
  }

  feature onboarding-server {
    description
      "The server supports being an 'onboarding server'.";
  }

  // typedefs

  typedef cms {
    type binary;
    description
      "A CMS structure, as specified in RFC 5652, encoded using
       ASN.1 distinguished encoding rules (DER), as specified in
       ITU-T X.690.";
    reference
      "RFC 5652:
         Cryptographic Message Syntax (CMS)
       ITU-T X.690:
         Information technology - ASN.1 encoding rules:
         Specification of Basic Encoding Rules (BER),
         Canonical Encoding Rules (CER) and Distinguished
         Encoding Rules (DER)";
  }

  // RPCs

  rpc get-bootstrapping-data {
    description
      "This RPC enables a device, as identified by the RESTCONF
       username, to obtain bootstrapping data that has been made
       available for it.";
    input {
      leaf signed-data-preferred {
        type empty;
        description
          "This optional input parameter enables a device to
           communicate to the bootstrap server that it prefers
           to receive signed data.  Devices SHOULD always send
           this parameter when the bootstrap server is untrusted.
           Upon receiving this input parameter, the bootstrap
           server MUST return either signed data or unsigned
           redirect information; the bootstrap server MUST NOT
           return unsigned onboarding information.";
      }
      leaf hw-model {
        type string;
        description
          "This optional input parameter enables a device to
           communicate to the bootstrap server its vendor-specific
           hardware model number.  This parameter may be needed,
           for instance, when a device's IDevID certificate does
           not include the 'hardwareModelName' value in its
           subjectAltName field, as is allowed by 802.1AR.";
        reference
          "IEEE 802.1AR: IEEE Standard for Local and
             metropolitan area networks - Secure
             Device Identity";
      }
      leaf os-name {
        type string;
        description
          "This optional input parameter enables a device to
           communicate to the bootstrap server the name of its
           operating system.  This parameter may be useful if
           the device, as identified by its serial number, can
           run more than one type of operating system (e.g.,
           on a white-box system.";
      }
      leaf os-version {
        type string;
        description
          "This optional input parameter enables a device to
           communicate to the bootstrap server the version of its
           operating system.  This parameter may be used by a
           bootstrap server to return an operating-system-specific
           response to the device, thus negating the need for a
           potentially expensive boot image update.";
      }
      leaf nonce {
        type binary {
          length "16..32";
        }
        description
          "This optional input parameter enables a device to
           communicate to the bootstrap server a nonce value.
           This may be especially useful for devices lacking
           an accurate clock, as then the bootstrap server
           can dynamically obtain from the manufacturer a
           voucher with the nonce value in it, as described
           in RFC 8366.";
        reference
          "RFC 8366:
             A Voucher Artifact for Bootstrapping Protocols";
      }
    }
    output {
      leaf reporting-level {
        if-feature "onboarding-server";
        type enumeration {
          enum minimal {
            description
              "Send just the progress reports required by RFC 8572.";
            reference
              "RFC 8572: Secure Zero Touch Provisioning (SZTP)";
          }
          enum verbose {
            description
              "Send additional progress reports that might help
               troubleshooting an SZTP bootstrapping issue.";
          }
        }
        default "minimal";
        description
          "Specifies the reporting level for progress reports the
           bootstrap server would like to receive when processing
           onboarding information.  Progress reports are not sent
           when processing redirect information or when the
           bootstrap server is untrusted (e.g., device sent the
           '<signed-data-preferred>' input parameter).";
      }
      leaf conveyed-information {
        type cms;
        mandatory true;
        description
          "An SZTP conveyed information artifact, as described in
           Section 3.1 of RFC 8572.";
        reference
          "RFC 8572: Secure Zero Touch Provisioning (SZTP)";
      }
      leaf owner-certificate {
        type cms;
        must '../ownership-voucher' {
          description
            "An ownership voucher must be present whenever an owner
             certificate is presented.";
        }
        description
          "An owner certificate artifact, as described in Section
           3.2 of RFC 8572.  This leaf is optional because it is
           only needed when the conveyed information artifact is
           signed.";
        reference
          "RFC 8572: Secure Zero Touch Provisioning (SZTP)";
      }
      leaf ownership-voucher {
        type cms;
        must '../owner-certificate' {
          description
            "An owner certificate must be present whenever an
             ownership voucher is presented.";
        }
        description
          "An ownership voucher artifact, as described by Section
           3.3 of RFC 8572.  This leaf is optional because it is
           only needed when the conveyed information artifact is
           signed.";
        reference
          "RFC 8572: Secure Zero Touch Provisioning (SZTP)";
      }
    }
  }

  rpc report-progress {
    if-feature "onboarding-server";
    description
      "This RPC enables a device, as identified by the RESTCONF
       username, to report its bootstrapping progress to the
       bootstrap server.  This RPC is expected to be used when
       the device obtains onboarding-information from a trusted
       bootstrap server.";
    input {
      leaf progress-type {
        type enumeration {
          enum bootstrap-initiated {
            description
              "Indicates that the device just used the
               'get-bootstrapping-data' RPC.  The 'message' node
               below MAY contain any additional information that
               the manufacturer thinks might be useful.";
          }
          enum parsing-initiated {
            description
              "Indicates that the device is about to start parsing
               the onboarding information.  This progress type is
               only for when parsing is implemented as a distinct
               step.";
          }
          enum parsing-warning {
            description
              "Indicates that the device had a non-fatal error when
               parsing the response from the bootstrap server.  The
               'message' node below SHOULD indicate the specific
               warning that occurred.";
          }
          enum parsing-error {
            description
              "Indicates that the device encountered a fatal error
               when parsing the response from the bootstrap server.
               For instance, this could be due to malformed encoding,
               the device expecting signed data when only unsigned
               data is provided, the ownership voucher not listing
               the device's serial number, or because the signature
               didn't match.  The 'message' node below SHOULD
               indicate the specific error.  This progress type
               also indicates that the device has abandoned trying
               to bootstrap off this bootstrap server.";
          }
          enum parsing-complete {
            description
              "Indicates that the device successfully completed
               parsing the onboarding information.  This progress
               type is only for when parsing is implemented as a
               distinct step.";
          }
          enum boot-image-initiated {
            description
              "Indicates that the device is about to start
               processing the boot image information.";
          }
          enum boot-image-warning {
            description
              "Indicates that the device encountered a non-fatal
               error condition when trying to install a boot image.
               A possible reason might include a need to reformat a
               partition causing loss of data.  The 'message' node
               below SHOULD indicate any warning messages that were
               generated.";
          }
          enum boot-image-error {
            description
              "Indicates that the device encountered an error when
               trying to install a boot image, which could be for
               reasons such as a file server being unreachable,
               file not found, signature mismatch, etc.  The
               'message' node SHOULD indicate the specific error
               that occurred.  This progress type also indicates
               that the device has abandoned trying to bootstrap
               off this bootstrap server.";
          }
          enum boot-image-mismatch {
            description
              "Indicates that the device has determined that
               it is not running the correct boot image.  This
               message SHOULD precipitate trying to download
               a boot image.";
          }
          enum boot-image-installed-rebooting {
            description
              "Indicates that the device successfully installed
               a new boot image and is about to reboot.  After
               sending this progress type, the device is not
               expected to access the bootstrap server again
               for this bootstrapping attempt.";
          }
          enum boot-image-complete {
            description
              "Indicates that the device believes that it is
               running the correct boot image.";
          }
          enum pre-script-initiated {
            description
              "Indicates that the device is about to execute the
               'pre-configuration-script'.";
          }
          enum pre-script-warning {
            description
              "Indicates that the device obtained a warning from the
               'pre-configuration-script' when it was executed.  The
               'message' node below SHOULD capture any output the
               script produces.";
          }
          enum pre-script-error {
            description
              "Indicates that the device obtained an error from the
               'pre-configuration-script' when it was executed.  The
               'message' node below SHOULD capture any output the
               script produces.  This progress type also indicates
               that the device has abandoned trying to bootstrap
               off this bootstrap server.";
          }
          enum pre-script-complete {
            description
              "Indicates that the device successfully executed the
               'pre-configuration-script'.";
          }
          enum config-initiated {
            description
              "Indicates that the device is about to commit the
               initial configuration.";
          }
          enum config-warning {
            description
              "Indicates that the device obtained warning messages
               when it committed the initial configuration.  The
               'message' node below SHOULD indicate any warning
               messages that were generated.";
          }
          enum config-error {
            description
              "Indicates that the device obtained error messages
               when it committed the initial configuration.  The
               'message' node below SHOULD indicate the error
               messages that were generated.  This progress type
               also indicates that the device has abandoned trying
               to bootstrap off this bootstrap server.";
          }
          enum config-complete {
            description
              "Indicates that the device successfully committed
               the initial configuration.";
          }
          enum post-script-initiated {
            description
              "Indicates that the device is about to execute the
               'post-configuration-script'.";
          }
          enum post-script-warning {
            description
              "Indicates that the device obtained a warning from the
               'post-configuration-script' when it was executed.  The
               'message' node below SHOULD capture any output the
               script produces.";
          }
          enum post-script-error {
            description
              "Indicates that the device obtained an error from the
               'post-configuration-script' when it was executed.  The
               'message' node below SHOULD capture any output the
               script produces.  This progress type also indicates
               that the device has abandoned trying to bootstrap
               off this bootstrap server.";
          }
          enum post-script-complete {
            description
              "Indicates that the device successfully executed the
               'post-configuration-script'.";
          }
          enum bootstrap-warning {
            description
              "Indicates that a warning condition occurred for which
               no other 'progress-type' enumeration is deemed
               suitable.  The 'message' node below SHOULD describe
               the warning.";
          }
          enum bootstrap-error {
            description
              "Indicates that an error condition occurred for which
               no other 'progress-type' enumeration is deemed
               suitable.  The 'message' node below SHOULD describe
               the error.  This progress type also indicates that
               the device has abandoned trying to bootstrap off
               this bootstrap server.";
          }
          enum bootstrap-complete {
            description
              "Indicates that the device successfully processed
               all 'onboarding-information' provided and that it
               is ready to be managed.  The 'message' node below
               MAY contain any additional information that the
               manufacturer thinks might be useful.  After sending
               this progress type, the device is not expected to
               access the bootstrap server again.";
          }
          enum informational {
            description
              "Indicates any additional information not captured
               by any of the other progress types.  For instance,
               a message indicating that the device is about to
               reboot after having installed a boot image could
               be provided.  The 'message' node below SHOULD
               contain information that the manufacturer thinks
               might be useful.";
          }
        }
        mandatory true;
        description
          "The type of progress report provided.";
      }
      leaf message {
        type string;
        description
          "An optional arbitrary value.";
      }
      container ssh-host-keys {
        when "../progress-type = 'bootstrap-complete'" {
          description
            "SSH host keys are only sent when the progress type
             is 'bootstrap-complete'.";
        }
        description
          "A list of SSH host keys an NMS may use to authenticate
           subsequent SSH-based connections to this device (e.g.,
           netconf-ssh, netconf-ch-ssh).";
        list ssh-host-key {
          description
            "An SSH host key an NMS may use to authenticate
             subsequent SSH-based connections to this device
             (e.g., netconf-ssh and netconf-ch-ssh).";
          reference
            "RFC 4253: The Secure Shell (SSH) Transport Layer
                       Protocol";
          leaf algorithm {
            type string;
            mandatory true;
            description
              "The public key algorithm name for this SSH key.

               Valid values are listed in the 'Public Key Algorithm
               Names' subregistry of the 'Secure Shell (SSH) Protocol
               Parameters' registry maintained by IANA.";
            reference
              "RFC 4250: The Secure Shell (SSH) Protocol Assigned
                         Numbers
               IANA URL: <https://www.iana.org/assignments/ssh-para\\
                         meters>
                         ('\\' added for formatting reasons)";
          }
          leaf key-data {
            type binary;
            mandatory true;
            description
              "The binary public key data for this SSH key, as
               specified by RFC 4253, Section 6.6; that is:

                 string    certificate or public key format
                           identifier
                 byte[n]   key/certificate data.";
            reference
              "RFC 4253: The Secure Shell (SSH) Transport Layer
                         Protocol";
          }
        }
      }
      container trust-anchor-certs {
        when "../progress-type = 'bootstrap-complete'" {
          description
            "Trust anchors are only sent when the progress type
             is 'bootstrap-complete'.";
        }
        description
          "A list of trust anchor certificates an NMS may use to
           authenticate subsequent certificate-based connections
           to this device (e.g., restconf-tls, netconf-tls, or
           even netconf-ssh with X.509 support from RFC 6187).
           In practice, trust anchors for IDevID certificates do
           not need to be conveyed using this mechanism.";
        reference
          "RFC 6187: X.509v3 Certificates for Secure Shell
                     Authentication";
        leaf-list trust-anchor-cert {
          type cms;
          description
            "A CMS structure whose topmost content type MUST be the
             signed-data content type, as described by Section 5 of
             RFC 5652.

             The CMS MUST contain the chain of X.509 certificates
             needed to authenticate the certificate presented by
             the device.

             The CMS MUST contain only a single chain of
             certificates.  The last certificate in the chain
             MUST be the issuer for the device's end-entity
             certificate.

             In all cases, the chain MUST include a self-signed
             root certificate.  In the case where the root
             certificate is itself the issuer of the device's
             end-entity certificate, only one certificate is
             present.

             This CMS encodes the degenerate form of the SignedData
             structure that is commonly used to disseminate X.509
             certificates and revocation objects (RFC 5280).";
          reference
            "RFC 5280: Internet X.509 Public Key Infrastructure
                       Certificate and Certificate Revocation List
                       (CRL) Profile
             RFC 5652: Cryptographic Message Syntax (CMS)";
        }
      }
    }
  }
}
<CODE ENDS>
]]></artwork>
          </figure>
        </section> 
      </section> 

      <section title="DHCP Options" anchor="dhcp-options">

        <t>This section defines two DHCP options: one for DHCPv4 and one for
        DHCPv6.  These two options are semantically the same, though syntactically
        different.</t>

        <section title="DHCPv4 SZTP Redirect Option">

          <t>The DHCPv4 SZTP Redirect Option is used to provision the client
          with one or more URIs for bootstrap servers that can be
          contacted to attempt further configuration.</t>

          <figure>
            <artwork align="center"><![CDATA[

 0                             1
 0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|   option-code (143)   |     option-length     |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
.                                               .
.    bootstrap-server-list (variable length)    .
.                                               .
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

* option-code: OPTION_V4_SZTP_REDIRECT (143)
* option-length: The option length in octets.
* bootstrap-server-list: A list of servers for the
   client to attempt contacting, in order to obtain
   further bootstrapping data, in the format shown
   in Section 8.3.

          DHCPv4 SZTP Redirect Option
]]></artwork>
          </figure>

          <t>DHCPv4 Client Behavior</t>
          <t>Clients MAY request the OPTION_V4_SZTP_REDIRECT option by including its
          option code in the Parameter Request List (55) in DHCP request messages.</t>

          <t>On receipt of a DHCPv4 Reply message that contains the
          OPTION_V4_SZTP_REDIRECT option, the client processes the response according
          to <xref target="process-redirect-information"/>, with the understanding
          that the "address" and "port" values are encoded in the URIs.</t>

          <t>
   Any invalid URI entries received in the uri-data field are ignored by
   the client.  If the received OPTION_V4_SZTP_REDIRECT option does
 not contain at least one valid URI entry in the uri-data field, then
  the client MUST discard the option.
</t>

          <t>  As the list of URIs may exceed the maximum allowed length of a
	  single
  DHCPv4 option (255 octets), the client MUST implement the
  decoding agent behavior described in 
            <xref target="RFC3396"/>, to correctly process
  a URI list split across a number of received OPTION_V4_SZTP_REDIRECT
  option instances.
          </t>

          <t>DHCPv4 Server Behavior</t>
          <t>The DHCPv4 server MAY include a single instance of the
            OPTION_V4_SZTP_REDIRECT option in DHCP messages it sends. Servers MUST
            NOT send more than one instance of the OPTION_V4_SZTP_REDIRECT option.
          </t>

          <t>The server's DHCP message MUST contain only a single instance of the
          OPTION_V4_SZTP_REDIRECT's 'bootstrap-server-list'
          field. However, the list of URIs in this field may exceed the maximum
          allowed length of a single DHCPv4 option (per <xref target="RFC3396"/>).
          </t>

          <t>If the length of 'bootstrap-server-list' is small enough to fit into
          a single instance of OPTION_V4_SZTP_REDIRECT,  the server MUST NOT
          send more than one instance of this option.</t>

          <t>If the length of the 'bootstrap-server-list' field is too large to
          fit into a single option, then OPTION_V4_SZTP_REDIRECT MUST be
          split into multiple instances of the option according to the process
          described in <xref target="RFC3396"/>.</t>

        </section>

        <section title="DHCPv6 SZTP Redirect Option">

          <t>The DHCPv6 SZTP Redirect Option is used to provision the client with
          one or more URIs for bootstrap servers that can be contacted to
          attempt further configuration.</t>
          <figure>
            <artwork align="center"><![CDATA[

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       option-code (136)       |          option-length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.           bootstrap-server-list (variable length)             .
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

* option-code: OPTION_V6_SZTP_REDIRECT (136)
* option-length: The option length in octets.
* bootstrap-server-list: A list of servers for the client to
  attempt contacting, in order to obtain further bootstrapping
  data, in the format shown in Section 8.3.

                 DHCPv6 SZTP Redirect Option

]]></artwork>
          </figure>

          <t>DHCPv6 Client Behavior</t>

          <t>Clients MAY request OPTION_V6_SZTP_REDIRECT using the process defined
          in <xref target="RFC8415"/>, Sections 18.2.1, 18.2.2, 18.2.4, 18.2.5,
          18.2.6, and 21.7. As a convenience to the reader, we mention here that
          the client includes requested option codes in the Option Request option.</t>

          <t>On receipt of a DHCPv6 Reply message that contains the
          OPTION_V6_SZTP_REDIRECT option, the client processes the response according
          to <xref target="process-redirect-information"/>, with the understanding
          that the "address" and "port" values are encoded in the URIs.</t>

          <t>
   Any invalid URI entries received in the uri-data field are ignored by
   the client.  If the received OPTION_V6_SZTP_REDIRECT option does not
   contain at least one valid URI entry in the uri-data field, then the client
   MUST discard the option.
          </t>

          <t>DHCPv6 Server Behavior</t>
          <t>Section 18.3 of <xref target="RFC8415"/> governs server
          operation in regard to option assignment. As a convenience to the
          reader, we mention here that the server will send a particular option
          code only if configured with specific values for that option code and
          if the client requested it.</t>

          <t>The OPTION_V6_SZTP_REDIRECT option is a singleton.  Servers MUST NOT
           send more than one instance of this option.</t>
        </section> 

        <section title="Common Field Encoding" anchor="common-field-encoding">
          <t>Both of the DHCPv4 and DHCPv6 options defined in this section encode
            a list of bootstrap server URIs.  The "URI" structure is a DHCP
            option that can contain multiple URIs (see <xref target="RFC7227"/>, 
            Section 5.7). Each URI entry in the bootstrap-server-list is 
            structured as follows:
          </t>

          <figure>
            <artwork align="center"><![CDATA[
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...-+-+-+-+-+-+-+
|       uri-length              |          URI                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...-+-+-+-+-+-+-+

* uri-length: 2 octets long; specifies the length of the URI data.
* URI: URI of the SZTP bootstrap server.
]]></artwork>
          </figure>

          <t>The URI of the SZTP bootstrap server MUST use
          the "https" URI scheme defined in Section 2.7.2 of 
          <xref target="RFC7230"/>, and it MUST be in form 
          "https://&lt;ip-address-or-hostname&gt;[:&lt;port&gt;]".</t>

        </section> 

      </section> 


      <section title="Security Considerations" anchor="sec-con">
        <section title="Clock Sensitivity" anchor="clock-sens">
          <t>The solution in this document relies on TLS certificates,
          owner certificates, and ownership vouchers, all of which
          require an accurate clock in order to be processed
          correctly (e.g., to test validity dates and revocation
          status).  Implementations SHOULD ensure devices have an
          accurate clock when shipped from manufacturing facilities
          and take steps to prevent clock tampering.</t>

          <t>If it is not possible to ensure clock accuracy, it is
          RECOMMENDED that implementations disable the aspects of the
          solution having clock sensitivity. In particular, such
          implementations should assume that TLS certificates,
          ownership vouchers, and owner certificates never expire
          and are not revocable.  From an ownership voucher
          perspective, manufacturers SHOULD issue a single
          ownership voucher for the lifetime of such devices.</t>

          <t>Implementations SHOULD NOT rely on NTP for time, as
          NTP is not a secure protocol at this time.  Note that there
          is an IETF document that focuses on securing NTP 
          <xref target="NTS-NTP"/>.</t>
        </section>
        <section title="Use of IDevID Certificates">
          <t>IDevID certificates, as defined in <xref target="Std-802.1AR"/>,
          are RECOMMENDED, both for the TLS-level client certificate used
          by devices when connecting to a bootstrap server, as well as for
          the device identity certificate used by owners when encrypting
          the SZTP bootstrapping data artifacts.</t>
        </section>
        <section title="Immutable Storage for Trust Anchors">
          <t>Devices MUST ensure that all their trust anchor certificates,
          including those for connecting to bootstrap servers and verifying
          ownership vouchers, are protected from external modification.</t>
          <t>It may be necessary to update these certificates over time 
          (e.g., the manufacturer wants to delegate trust to a new CA).
          It is therefore expected that devices MAY update these trust
          anchors when needed through a verifiable process, such as a
          software upgrade using signed software images.</t>
        </section>
        <section title="Secure Storage for Long-Lived Private Keys">
          <t>Manufacturer-generated device identifiers may have very long
          lifetimes.  For instance, <xref target="Std-802.1AR"/>
          recommends using the "notAfter" value 99991231235959Z in IDevID
          certificates.  Given the long-lived nature of these private keys,
          it is paramount that they are stored so as to resist discovery,
          such as in a secure cryptographic processor (e.g., a trusted
          platform module (TPM) chip).</t>
        </section>
        <section title="Blindly Authenticating a Bootstrap Server">
          <t>This document allows a device to blindly authenticate a
          bootstrap server's TLS certificate.  It does so to allow
          for cases where the redirect information may be obtained
          in an unsecured manner, which is desirable to support
          in some cases.</t>
          <t>To compensate for this, this document requires that
          devices, when connected to an untrusted bootstrap server,
          assert that data downloaded from the server is signed.</t>
        </section>
        <section title="Disclosing Information to Untrusted Servers">
          <t>This document allows devices to establish connections to
          untrusted bootstrap servers.  However, since the bootstrap
          server is untrusted, it may be under the control of an
          adversary; therefore, devices SHOULD be cautious about
          the data they send to the bootstrap server in such cases.</t>

          <t>Devices send different data to bootstrap servers at each
          of the protocol layers: TCP, TLS, HTTP, and RESTCONF.</t>

          <t>At the TCP protocol layer, devices may relay their IP address,
          subject to network translations.  Disclosure of this information
          is not considered a security risk.</t>

          <t>At the TLS protocol layer, devices may use a client certificate
          to identify and authenticate themselves to untrusted bootstrap
          servers.  At a minimum, the client certificate must disclose
          the device's serial number and may disclose additional information
          such as the device's manufacturer, hardware model, public key, etc.
          Knowledge of this information may provide an adversary with details
          needed to launch an attack.  It is RECOMMENDED that secrecy of the
          network constituency not be relied on for security.</t>

          <t>At the HTTP protocol layer, devices may use an HTTP authentication
          scheme to identify and authenticate themselves to untrusted bootstrap
          servers.  At a minimum, the authentication scheme must disclose the
          device's serial number and, concerningly, may, depending on the
          authentication mechanism used, reveal a secret that is only supposed
          to be known to the device (e.g., a password).  Devices SHOULD NOT use
          an HTTP authentication scheme (e.g., HTTP Basic) with an untrusted
          bootstrap server that reveals a secret that is only supposed to be
          known to the device.</t>

          <t>At the RESTCONF protocol layer, devices use the "get-bootstrapping-data"
          RPC, but not the "report-progress" RPC, when connected to an untrusted
          bootstrap server.  The "get-bootstrapping-data" RPC allows additional
          input parameters to be passed to the bootstrap server (e.g., "os-name",
          "os-version", and "hw-model").  It is RECOMMENDED that devices only pass
          the "signed-data-preferred" input parameter to an untrusted bootstrap
          server.  While it is okay for a bootstrap server to immediately
          return signed onboarding information, it is RECOMMENDED that
          bootstrap servers instead promote the untrusted connection to a
          trusted connection, as described in <xref target="untrust2trust"/>,
          thus enabling the device to use the "report-progress" RPC while
          processing the onboarding information.</t>
       </section>
        <section title="Sequencing Sources of Bootstrapping Data">
          <t>For devices supporting more than one source for bootstrapping
          data, no particular sequencing order has to be observed for
          security reasons, as the solution for each source is considered
          equally secure.  However, from a privacy perspective, it is
          RECOMMENDED that devices access local sources before accessing
          remote sources.</t>
        </section>
        <section title="Safety of Private Keys Used for Trust">
          <t>The solution presented in this document enables bootstrapping
          data to be trusted in two ways: through either transport-level
          security or the signing of artifacts.</t>

          <t>When transport-level security (i.e., a trusted bootstrap server)
          is used, the private key for the end-entity certificate must be
          online in order to establish the TLS connection.</t>

          <t>When artifacts are signed, the signing key is required to be
          online only when the bootstrap server is returning a dynamically
          generated signed-data response.  For instance, a bootstrap server,
          upon receiving the "signed-data-preferred" input parameter to the
          "get&nbhy;bootstrapping&nbhy;data" RPC, may dynamically generate a response
          that is signed.</t>

          <t>Bootstrap server administrators are RECOMMENDED to follow best
          practices to protect the private key used for any online operation.
          For instance, use of a hardware security module (HSM) is RECOMMENDED.
          If an HSM is not used, frequent private key refreshes are RECOMMENDED,
          assuming all bootstrapping devices have an accurate clock (see
          <xref target="clock-sens"/>).</t>

          <t>For best security, it is RECOMMENDED that owners only provide
          bootstrapping data that has been signed (using a protected private
          key) and encrypted (using the device's public key from its secure
          device identity certificate).</t>
        </section>
        <section title="Increased Reliance on Manufacturers">
          <t>The SZTP bootstrapping protocol presented in this document shifts
          some control of initial configuration away from the rightful owner of the
          device and towards the manufacturer and its delegates.</t>

          <t>The manufacturer maintains the list of well-known bootstrap servers
          its devices will trust.  By design, if no bootstrapping data is found via
          other methods first, the device will try to reach out to the well-known
          bootstrap servers.  There is no mechanism to prevent this from occurring
          other than by using an external firewall to block such connections.
          Concerns related to trusted bootstrap servers are discussed in 
          <xref target="seccon-trusted-bootstrap-servers"/>.</t>

          <t>Similarly, the manufacturer maintains the list of voucher-signing
          authorities its devices will trust.  The voucher-signing authorities
          issue the vouchers that enable a device to trust an owner's domain
          certificate.  It is vital that manufacturers ensure the integrity
          of these voucher-signing authorities, so as to avoid incorrect
          assignments.</t>

          <t>Operators should be aware that this system assumes that they trust
          all the pre-configured bootstrap servers and voucher-signing authorities
          designated by the manufacturers.  While operators may use points in
          the network to block access to the well-known bootstrap servers,
          operators cannot prevent voucher-signing authorities from generating
          vouchers for their devices.</t>
        </section>
        <section title="Concerns with Trusted Bootstrap Servers"
                 anchor="seccon-trusted-bootstrap-servers">
          <t>Trusted bootstrap servers, whether well-known or discovered,
          have the potential to cause problems, such as the following.
            <list style="symbols">
              <t>A trusted bootstrap server that has been compromised may be
              modified to return unsigned data of any sort.  For instance, a
              bootstrap server that is only supposed to return redirect 
              information might be modified to return onboarding information.
              Similarly, a bootstrap server that is only supposed to return
              signed data may be modified to return unsigned data.  In both
              cases, the device will accept the response, unaware that it
              wasn't supposed to be any different.  It is RECOMMENDED that
              maintainers of trusted bootstrap servers ensure that their
              systems are not easily compromised and, in case of compromise,
              have mechanisms in place to detect and remediate the compromise
              as expediently as possible.</t>

              <t>A trusted bootstrap server hosting data that is either unsigned or signed
              but not encrypted may disclose information to unwanted parties
              (e.g., an administrator of the bootstrap server).  This is a privacy
              issue only, but it could reveal information that might be used in a
              subsequent attack.  Disclosure of redirect information has limited
              exposure (it is just a list of bootstrap servers), whereas disclosure
              of onboarding information could be highly revealing (e.g., network
              topology, firewall policies, etc.).  It is RECOMMENDED that operators
              encrypt the bootstrapping data when its contents are considered 
              sensitive, even to the point of hiding it from the administrators
              of the bootstrap server, which may be maintained by a third party.</t>
            </list>
          </t>
        </section>
        <section title="Validity Period for Conveyed Information">
          <t>The conveyed information artifact does not specify a validity period.  For
          instance, neither redirect information nor onboarding information
          enable "not-before" or "not-after" values to be specified, and
          neither artifact alone can be revoked.</t>

          <t>For unsigned data provided by an untrusted source of bootstrapping
          data, it is not meaningful to discuss its validity period when the
          information itself has no authenticity and may have come from anywhere.</t>

          <t>For unsigned data provided by a trusted source of bootstrapping
          data (i.e., a bootstrap server), the availability of the data
          is the only measure of it being current.  Since the untrusted data
          comes from a trusted source, its current availability is meaningful,
          and since bootstrap servers use TLS, the contents of the exchange
          cannot be modified or replayed.</t>

          <t>For signed data, whether provided by an untrusted or trusted
          source of bootstrapping data, the validity is constrained by
          the validity of both the ownership voucher and owner
          certificate used to authenticate it.</t>
          
          <t>The ownership voucher's validity is primarily constrained by 
          the ownership voucher's "created-on" and "expires-on" nodes.  
          While <xref target="RFC8366"/> recommends short-lived vouchers
          (see Section 6.1), the "expires-on" node may be set to any point
          in the future or omitted altogether to indicate that the voucher
          never expires.  The ownership voucher's validity is secondarily
          constrained by the manufacturer's PKI used to sign the voucher;
          whilst an ownership voucher cannot be revoked directly, the PKI
          used to sign it may be.</t>

          <t>The owner certificate's validity is primarily constrained by
          the X.509's validity field, the "notBefore" and "notAfter" values,
          as specified by the certificate authority that signed it.  The
          owner certificate's validity is secondarily constrained by the
          validity of the PKI used to sign the voucher.  Owner certificates
          may be revoked directly.</t>

          <t>For owners that wish to have maximum flexibility in their
          ability to specify and constrain the validity of signed data,
          it is RECOMMENDED that a unique owner certificate be created
          for each signed artifact.  Not only does this enable a
          validity period to be specified, for each artifact, but it
          also enables the validity of each artifact to be revoked.</t>
        </section>
        <section title="Cascading Trust via Redirects">
          <t>Redirect information (<xref target="redirect-information"/>),
          by design, instructs a bootstrapping device to initiate an HTTPS
          connection to the specified bootstrap servers.</t>
          <t>When the redirect information is trusted, the redirect
          information can encode a trust anchor certificate used by
          the device to authenticate the TLS end-entity certificate
          presented by each bootstrap server.</t>

          <t>As a result, any compromise in an interaction providing 
          redirect information may result in compromise of all
          subsequent interactions.</t>
        </section>
        <section title="Possible Reuse of Private Keys">
          <t>This document describes two uses for secure device identity
          certificates.</t>

          <t>The primary use is for when the device authenticates
          itself to a bootstrap server, using its private key for
          TLS-level client-certificate-based authentication.</t>

          <t>A secondary use is for when the device needs to decrypt
          provided bootstrapping artifacts, using its private key
          to decrypt the data or, more precisely, per Section 6 of
          <xref target="RFC5652"/>, decrypt a symmetric key used to
          decrypt the data.</t>

          <t><xref target="artifact-encryption"/> of this document
          allows for the possibility that the same secure device
          identity certificate is utilized for both uses, as 
          <xref target="Std-802.1AR"/> states that a DevID
          certificate MAY have the "keyEncipherment" KeyUsage bit,
          in addition to the "digitalSignature" KeyUsage bit, set.</t>

          <t>While it is understood that it is generally frowned
          upon to reuse private keys, this document views such
          reuse acceptable as there are not any known ways to cause
          a signature made in one context to be (mis)interpreted
          as valid in the other context.</t>
        </section>
        <section title="Non-issue with Encrypting Signed Artifacts">
          <t>This document specifies the encryption of signed objects,
          as opposed to the signing of encrypted objects, as might
          be expected given well-publicized oracle attacks (e.g., the
          padding oracle attack).</t>
          <t>This document does not view such attacks as feasible in
          the context of the solution because the decrypted text never
          leaves the device.</t>
        </section>
        <section title="The &quot;ietf-sztp-conveyed-info&quot; YANG Module">
          <t>The "ietf-sztp-conveyed-info" module defined in this document
          defines a data structure that is always wrapped by a CMS structure.
          When accessed by a secure mechanism (e.g., protected by TLS), then the
          CMS structure may be unsigned.  However, when accessed by an insecure
          mechanism (e.g., a removable storage device), the CMS structure
          must be signed, in order for the device to trust it.</t>

          <t>Implementations should be aware that signed bootstrapping data
          only protects the data from modification and that the content is still
          visible to others.  This doesn't affect security so much as privacy.
          That the contents may be read by unintended parties when accessed by
          insecure mechanisms is considered next.</t>

          <t>The "ietf-sztp-conveyed-info" module defines a top-level "choice"
          statement that declares the content is either redirect-information
          or onboarding-information.  Each of these two cases are now considered.</t>

          <t>When the content of the CMS structure is redirect-information,
          an observer can learn about the bootstrap servers the device is being
          directed to, their IP addresses or hostnames, ports, and trust anchor
          certificates.  Knowledge of this information could provide an observer
          some insight into a network's inner structure.</t>

          <t>When the content of the CMS structure is onboarding-information,
          an observer could learn considerable information about how the device
          is to be provisioned.  This information includes the operating system
          version, initial configuration, and script contents.  This information
          should be considered sensitive, and precautions should be taken to 
          protect it (e.g., encrypt the artifact using the device's public key).</t>
        </section>
        <section title="The &quot;ietf-sztp-bootstrap-server&quot; YANG Module">
          <t>The "ietf-sztp-bootstrap-server" module defined in this document
          specifies an API for a RESTCONF <xref target="RFC8040"/>.  The lowest
          RESTCONF layer is HTTPS, and the mandatory-to-implement secure transport
          is TLS <xref target="RFC8446"/>.</t>

          <t>The NETCONF Access Control Model (NACM) <xref target="RFC8341"/>
          provides the means to restrict access for particular users
          to a pre-configured subset of all available protocol operations
          and content.</t>

          <t>This module presents no data nodes (only RPCs).  There is no need
          to discuss the sensitivity of data nodes.</t>
          <t>This module defines two RPC operations that may be considered
          sensitive in some network environments.  These are the operations
          and their sensitivity/vulnerability:
            <list style="hanging" hangIndent="4">
              <t hangText="get-bootstrapping-data:">This RPC is used by devices
              to obtain their bootstrapping data.  By design, each device, as
              identified by its authentication credentials (e.g., client 
              certificate), can only obtain its own data.  NACM is not needed
              to further constrain access to this RPC.</t>

              <t hangText="report-progress:">This RPC is used by devices
              to report their bootstrapping progress.  By design, each device,
              as identified by its authentication credentials (e.g., client 
              certificate), can only report data for itself.  NACM is not
              needed to further constrain access to this RPC.</t>
            </list>
          </t>
        </section>
      </section>

      <section title="IANA Considerations" anchor="iana-considerations">


        <section title="The IETF XML Registry">
          <t>IANA has registered two URIs in the "ns" subregistry of
          the "IETF XML Registry" <xref target="RFC3688"/> maintained at 
          &lt;https://www.iana.org/assignments/xml-registry&gt;.
          The following registrations have been made per the format in <xref target="RFC3688"/>:
        </t>
          <t>
            <figure>
                <artwork align="left"><![CDATA[
   URI: urn:ietf:params:xml:ns:yang:ietf-sztp-conveyed-info
   Registrant Contact: The NETCONF WG of the IETF.
   XML: N/A, the requested URI is an XML namespace.

   URI: urn:ietf:params:xml:ns:yang:ietf-sztp-bootstrap-server
   Registrant Contact: The NETCONF WG of the IETF.
   XML: N/A, the requested URI is an XML namespace.
]]></artwork>
            </figure>
          </t>
        </section>
        <section title="The YANG Module Names Registry">
          <t>IANA has registered two YANG modules in the
          "YANG Module Names" registry <xref target="RFC6020"/> maintained at
          &lt;https://www.iana.org/assignments/yang-parameters&gt;.
          The following registrations have been made per the format in <xref target="RFC6020"/>:
          </t>
          <t>
            <figure>
                <artwork align="left"><![CDATA[
   name:      ietf-sztp-conveyed-info
   namespace: urn:ietf:params:xml:ns:yang:ietf-sztp-conveyed-info
   prefix:    sztp-info
   reference: RFC 8572

   name:      ietf-sztp-bootstrap-server
   namespace: urn:ietf:params:xml:ns:yang:ietf-sztp-bootstrap-server
   prefix:    sztp-svr
   reference: RFC 8572
]]></artwork>
          </figure>
        </t>
        </section>



        <section title="The SMI Security for S/MIME CMS Content Type Registry" anchor="cms_cts">
          <t>IANA has registered
	  two subordinate object identifiers in the "SMI Security for
          S/MIME CMS Content Type (1.2.840.113549.1.9.16.1)" registry maintained at
          &lt;https://www.iana.org/assignments/smi-numbers&gt;.
          The following registrations have been made per the format in Section
	  3.4 of <xref target="RFC7107"/>:
          </t>
          <t>
            <figure>
                <artwork align="left"><![CDATA[
   Decimal   Description                  References
   -------   --------------------------   ----------
   42        id-ct-sztpConveyedInfoXML    RFC 8572
   43        id-ct-sztpConveyedInfoJSON   RFC 8572
]]></artwork> 
          </figure>
        </t>

        <t>id-ct-sztpConveyedInfoXML indicates that the "conveyed-information"
        is encoded using XML.  id-ct-sztpConveyedInfoJSON indicates that the
        "conveyed-information" is encoded using JSON.</t>
        </section>

        <section title="The BOOTP Vendor Extensions and DHCP Options Registry">
          <t>IANA has registered one DHCP code point in the "BOOTP Vendor
	  Extensions and DHCP Options" registry maintained at
          &lt;https://www.iana.org/assignments/bootp-dhcp-parameters&gt;:
        </t>
          <t>
            <figure>
              <artwork align="left">
   Tag:         143
   Name:        OPTION_V4_SZTP_REDIRECT
   Data Length: N
   Meaning:     This option provides a list of URIs
                for SZTP bootstrap servers
   Reference:   RFC 8572
</artwork>
            </figure>
          </t>

        </section>
        <section title="The Dynamic Host Configuration Protocol for IPv6 (DHCPv6) Registry">
          <t>IANA has registered one DHCP code point in the "Option Codes" subregistry
          of the "Dynamic Host Configuration Protocol for IPv6 (DHCPv6)" registry 
          maintained at &lt;https://www.iana.org/assignments/dhcpv6-parameters&gt;:
          </t>
          <t>
            <figure>
              <artwork align="left">
   Value:            136
   Description:      OPTION_V6_SZTP_REDIRECT
   Client ORO:       Yes
   Singleton Option: Yes
   Reference:        RFC 8572
</artwork>
            </figure>
          </t>
        </section>

        <section title="The Service Name and Transport Protocol Port Number Registry" anchor="dns_srv">
          <t>IANA has registered one service name in the "Service Name and
          Transport Protocol Port Number Registry" <xref target="RFC6335"/> maintained at
          &lt;https://www.iana.org/assignments/service-names-port-numbers&gt;.
          The following registration has been made per the format in Section
	  8.1.1 of <xref target="RFC6335"/>:
          </t>
          <t>
            <figure>
                <artwork align="left"><![CDATA[
  Service Name:            sztp
  Transport Protocol(s):   TCP
  Assignee:                IESG <iesg@ietf.org>
  Contact:                 IETF Chair <chair@ietf.org>
  Description:             This service name is used to construct the
                           SRV service label "_sztp" for discovering
                           SZTP bootstrap servers.
  Reference:               RFC 8572  
  Port Number:             N/A
  Service Code:            N/A
  Known Unauthorized Uses: N/A
  Assignment Notes:        This protocol uses HTTPS as a substrate.
]]></artwork>
            </figure>
          </t>
        </section>
        <section title="The Underscored and Globally Scoped DNS Node Names Registry" anchor="_sztp_attr">


          <t>IANA has registered one service name in the "Underscored and
	  Globally Scoped DNS Node Names"
          subregistry <xref target="RFC8552"/> of the "Domain Name System
	  (DNS) Parameters" registry maintained at
	  &lt;https://www.iana.org/assignments/dns-parameters&gt;.
          The following registration has been made per the format in Section
	  3 of <xref target="RFC8552"/>:
          </t>
          <t>
            <figure>
                <artwork align="left"><![CDATA[
   RR Type:            TXT
   _NODE NAME:         _sztp
   Reference:          RFC 8572
]]></artwork>
            </figure>
          </t>
        </section>
      </section>

    </middle>

    <back>
      <references title="Normative References">
        <?rfc include="reference.RFC.1035.xml"?>
        <?rfc include="reference.RFC.2119.xml"?>
        <?rfc include="reference.RFC.2782.xml"?>
        <?rfc include="reference.RFC.5652.xml"?>
        <?rfc include="reference.RFC.8415.xml"?>
        <?rfc include="reference.RFC.3396.xml"?>
        <?rfc include="reference.RFC.4253.xml"?>
        <?rfc include="reference.RFC.5280.xml"?>
        <?rfc include="reference.RFC.6020.xml"?>
        <?rfc include="reference.RFC.6125.xml"?>
        <?rfc include="reference.RFC.6762.xml"?>
        <?rfc include="reference.RFC.6991.xml"?>
        <?rfc include="reference.RFC.7227.xml"?>
        <?rfc include="reference.RFC.7230.xml"?>
        <?rfc include="reference.RFC.7950.xml"?>
        <?rfc include="reference.RFC.8040.xml"?>
        <?rfc include="reference.RFC.8174.xml"?>
        <?rfc include="reference.RFC.8366.xml"?>
 
<!--draft-ietf-dnsop-attrleaf-16; PUB, part of C354-->

        <?rfc include="reference.RFC.8552.xml"?>


        <reference anchor="ITU.X690.2015" target="https://www.itu.int/rec/T-REC-X.690/">
          <front>
            <title>Information Technology - ASN.1 encoding rules: Specification of Basic
            Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished
            Encoding Rules (DER)</title>
            <author>
              <organization>International Telecommunication Union</organization>
            </author>
            <date month="August" year="2015" />
          </front>
          <seriesInfo name="ITU-T Recommendation X.690," value="ISO/IEC 8825-1" />
	</reference>

        <reference anchor="Std-802.1AR">
          <front>
            <title>IEEE Standard for Local and metropolitan area networks - Secure Device Identity</title>
            <author>
               <organization>IEEE</organization>
            </author>
            <date/>
          </front>
          <seriesInfo name="IEEE" value="802.1AR" />
        </reference>
      </references>

      <references title="Informative References">
        <?rfc include="reference.RFC.3688.xml"?>
        <?rfc include="reference.RFC.4250.xml"?>
        <?rfc include="reference.RFC.6187.xml"?>
        <?rfc include="reference.RFC.6234.xml"?>
        <?rfc include="reference.RFC.6241.xml"?>
        <?rfc include="reference.RFC.6335.xml"?>
        <?rfc include="reference.RFC.6763.xml"?>
        <?rfc include="reference.RFC.6891.xml"?>
        <?rfc include="reference.RFC.6960.xml"?>
        <?rfc include="reference.RFC.6698.xml"?>
        <?rfc include="reference.RFC.7107.xml"?>
        <?rfc include="reference.RFC.7766.xml"?>
        <?rfc include="reference.RFC.8071.xml"?>
        <?rfc include="reference.RFC.8340.xml"?>
        <?rfc include="reference.RFC.8341.xml"?>
        <?rfc include="reference.RFC.8446.xml"?>
        <?rfc include="reference.RFC.8259.xml"?>

<!--draft-ietf-netconf-crypto-types-02; Active - I-D exists-->
<reference anchor='YANG-CRYPTO-TYPES'>
<front>
<title>Common YANG Data Types for Cryptography</title>
<author initials='K' surname='Watsen' fullname='Kent Watsen'>
    <organization />
</author>
<author initials='H' surname='Wang' fullname='HAIGUANG Wang'>
    <organization />
</author>
<date month='March' year='2019' />

</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-netconf-crypto-types-05' />
</reference>

<!--draft-ietf-netconf-trust-anchors-02; Active - I-D exists-->
<reference anchor='YANG-TRUST-ANCHORS'>
<front>
<title>YANG Data Model for Global Trust Anchors</title>
<author initials='K' surname='Watsen' fullname='Kent Watsen'>
    <organization />
</author>
<date month='March' year='2019' />
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-netconf-trust-anchors-03' />
</reference>

<!--draft-ietf-ntp-using-nts-for-ntp-17; Active - I-D exists-->
<reference anchor='NTS-NTP'>
<front>
<title>Network Time Security for the Network Time Protocol</title>
<author initials='D' surname='Franke' fullname='Daniel Franke'>
    <organization />
</author>
<author initials='D' surname='Sibold' fullname='Dieter Sibold'>
    <organization />
</author>
<author initials='K' surname='Teichel' fullname='Kristof Teichel'>
    <organization />
</author>
<author initials='M' surname='Dansarie' fullname='Marcus Dansarie'>
    <organization />
</author>
<author initials='R' surname='Sundblad' fullname='Ragnar Sundblad'>
    <organization />
</author>
<date month='February' year='2019' />
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-ntp-using-nts-for-ntp-17' />
</reference>

      </references>


      <section title="Example Device Data Model" anchor="device-model">

        <t>This section defines a non-normative data model that 
        enables the configuration of SZTP bootstrapping and the
        discovery of what parameters are used by a device's bootstrapping logic.</t>

        <section title="Data Model Overview">
          <t>The following tree diagram provides an overview for the SZTP
          device data model.</t>
          <figure>
            <artwork name="example-device-data-model-tree.txt" align="center"><![CDATA[
module: example-device-data-model
  +--rw sztp
     +--rw enabled?                          boolean
     +--ro idevid-certificate?               ct:end-entity-cert-cms
     |       {bootstrap-servers}?
     +--ro bootstrap-servers {bootstrap-servers}?
     |  +--ro bootstrap-server* [address]
     |     +--ro address    inet:host
     |     +--ro port?      inet:port-number
     +--ro bootstrap-server-trust-anchors {bootstrap-servers}?
     |  +--ro reference*   ta:pinned-certificates-ref
     +--ro voucher-trust-anchors {signed-data}?
        +--ro reference*   ta:pinned-certificates-ref
]]></artwork>
          </figure>
          <t>In the above diagram, notice that there is only one configurable node:
          "enabled".  The expectation is that this node would be set to "true" in
          the device's factory default configuration and that it would be either set
          to "false" or deleted when the SZTP bootstrapping is longer needed.</t>
        </section>

        <section title="Example Usage" anchor="device-example">
          <t>Following is an instance example for this data model.</t>
          <figure>
            <artwork name="ex-api-device-model.xml"><![CDATA[
<sztp xmlns="https://example.com/sztp-device-data-model">
  <enabled>true</enabled>
  <idevid-certificate>base64encodedvalue==</idevid-certificate>
  <bootstrap-servers>
    <bootstrap-server>
      <address>sztp1.example.com</address>
      <port>8443</port>
    </bootstrap-server> 
    <bootstrap-server>
      <address>sztp2.example.com</address>
      <port>8443</port>
    </bootstrap-server> 
    <bootstrap-server>
      <address>sztp3.example.com</address>
      <port>8443</port>
    </bootstrap-server> 
  </bootstrap-servers>
  <bootstrap-server-trust-anchors>
    <reference>manufacturers-root-ca-certs</reference>
  </bootstrap-server-trust-anchors>
  <voucher-trust-anchors>
    <reference>manufacturers-root-ca-certs</reference>
  </voucher-trust-anchors>
</sztp>
]]></artwork>
          </figure>
        </section> 

        <section title="YANG Module" anchor="device-yang-module">
          <t>The device model is defined by the YANG module
          defined in this section.</t>


          <t>This module references <xref target="Std-802.1AR"/> and uses data types defined in <xref target="RFC6991"/>,
          <xref target="YANG-CRYPTO-TYPES"/>, and
          <xref target="YANG-TRUST-ANCHORS"/>.</t>
          <figure>
            <artwork name="example-device-data-model@2019-01-15.yang"><![CDATA[
module example-device-data-model {
  yang-version 1.1;
  namespace "https://example.com/sztp-device-data-model";
  prefix sztp-ddm;

  import ietf-inet-types {
    prefix inet;
    reference "RFC 6991: Common YANG Data Types";
  }

  import ietf-crypto-types {
    prefix ct;
    revision-date 2019-03-09;
    description
     "ietf-crypto-types is defined in
      draft-ietf-netconf-crypto-types";
    reference
     "draft-ietf-netconf-crypto-types-05:
        Common YANG Data Types for Cryptography";
  }

  import ietf-trust-anchors {
    prefix ta;
    revision-date 2019-03-09;
    description
     "ietf-trust-anchors is defined in 
      draft-ietf-netconf-trust-anchors.";
    reference
     "draft-ietf-netconf-trust-anchors-03:
        YANG Data Model for Global Trust Anchors";
  }

  organization
    "Example Corporation";

  contact
    "Author: Bootstrap Admin <mailto:admin@example.com>";

  description
    "This module defines a data model to enable SZTP 
     bootstrapping and discover what parameters are used.
     This module assumes the use of an IDevID certificate,
     as opposed to any other client certificate, or the
     use of an HTTP-based client authentication scheme.";

  revision 2019-03-31 {
    description
      "Initial version";
    reference
      "RFC 8572: Secure Zero Touch Provisioning (SZTP)";
  }

  // features

  feature bootstrap-servers {
    description
      "The device supports bootstrapping off bootstrap servers.";
  }

  feature signed-data {
    description
      "The device supports bootstrapping off signed data.";
  }

  // protocol accessible nodes

  container sztp {
    description
      "Top-level container for the SZTP data model.";
    leaf enabled {
      type boolean;
      default false;
      description
        "The 'enabled' leaf controls if SZTP bootstrapping is
         enabled or disabled.  The default is 'false' so that, when
         not enabled, which is most of the time, no configuration
         is needed.";
    }
    leaf idevid-certificate {
      if-feature bootstrap-servers;
      type ct:end-entity-cert-cms;
      config false;
      description
        "This CMS structure contains the IEEE 802.1AR
         IDevID certificate itself and all intermediate
         certificates leading up to, and optionally including,
         the manufacturer's well-known trust anchor certificate
         for IDevID certificates.  The well-known trust anchor
         does not have to be a self-signed certificate.";
      reference
        "IEEE 802.1AR:
           IEEE Standard for Local and metropolitan area
           networks - Secure Device Identity";
    }
    container bootstrap-servers {
      if-feature bootstrap-servers;
      config false;
      description
        "List of bootstrap servers this device will attempt
         to reach out to when bootstrapping.";
      list bootstrap-server {
        key "address";
        description
          "A bootstrap server entry.";
        leaf address {
          type inet:host;
          mandatory true;
          description
            "The IP address or hostname of the bootstrap server the
             device should redirect to.";
        }
        leaf port {
          type inet:port-number;
          default "443";
          description
            "The port number the bootstrap server listens on.  If no
             port is specified, the IANA-assigned port for 'https'
             (443) is used.";
        }
      }
    }
    container bootstrap-server-trust-anchors {
      if-feature bootstrap-servers;
      config false;
      description "Container for a list of trust anchor references.";
      leaf-list reference {
        type ta:pinned-certificates-ref;
        description
          "A reference to a list of pinned certificate authority (CA)
           certificates that the device uses to validate bootstrap
           servers with.";
      }
    }
    container voucher-trust-anchors {
      if-feature signed-data;
      config false;
      description "Container for a list of trust anchor references.";
      leaf-list reference {
        type ta:pinned-certificates-ref;
        description
          "A reference to a list of pinned certificate authority (CA)
           certificates that the device uses to validate ownership
           vouchers with.";
      }
    }
  }
}
]]></artwork>
          </figure>
        </section> 
      </section> 


      <section title="Promoting a Connection from Untrusted to Trusted" anchor="untrust2trust">
        <t>The following diagram illustrates a sequence of
        bootstrapping activities that promote an untrusted
        connection to a bootstrap server to a trusted connection
        to the same bootstrap server.  This enables a device
        to limit the amount of information it might disclose
        to an adversary hosting an untrusted bootstrap server.</t>
        <t><figure>
          <artwork><![CDATA[
                                                      +-----------+
                                                      |Deployment-|
                                                      | Specific  |
+------+                                              | Bootstrap |
|Device|                                              |  Server   |
+------+                                              +-----------+
   |                                                        |
   | 1.  "HTTPS" Request ("signed-data-preferred", nonce)   |
   |------------------------------------------------------->|
   | 2.  "HTTPS" Response (signed redirect information)     |
   |<-------------------------------------------------------|
   |                                                        |
   |                                                        |
   | 3.  HTTPS Request (os-name=xyz, os-version=123, etc.)  |
   |------------------------------------------------------->|
   | 4.  HTTPS Response (unsigned onboarding information    |
   |<-------------------------------------------------------|
   |                                                        |
]]></artwork>
        </figure></t>
        <t>The interactions in the above diagram are described below.</t>
        <t><list style="numbers">
          <t>The device initiates an untrusted connection to a bootstrap
          server, as is indicated by putting "HTTPS" in double quotes
          above.  It is still an HTTPS connection, but the device is
          unable to authenticate the bootstrap server's TLS certificate.
          Because the device is unable to trust the bootstrap server, it
          sends the "signed-data-preferred" input parameter, and optionally
          also the "nonce" input parameter, in the "get-bootstrapping-data"
          RPC.  The "signed-data-preferred" parameter informs the
          bootstrap server that the device does not trust it and may
          be holding back some additional input parameters from the
          server (e.g., other input parameters, progress reports, etc.).
          The "nonce" input parameter enables the bootstrap server to
          dynamically obtain an ownership voucher from a Manufacturer Authorized Signing Authority (MASA), which
          may be important for devices that do not have a reliable clock.</t>

          <t>The bootstrap server, seeing the "signed-data-preferred"
          input parameter, knows that it can send either unsigned
          redirect information or signed data of any type.  But, in
          this case, the bootstrap server has the ability to sign
          data and chooses to respond with signed redirect information,
          not signed onboarding information as might be expected,
          securely redirecting the device back to it again.  Not
          displayed but, if the "nonce" input parameter was passed,
          the bootstrap server could dynamically 
          connect to a MASA and download a voucher having the nonce value
          in it.  Details regarding a protocol enabling this integration
          is outside the scope of this document.</t>

          <t>Upon validating the signed redirect information, the
          device establishes a secure connection to the bootstrap
          server.  Unbeknownst to the device, it is the same bootstrap
          server it was connected to previously, but because the device
          is able to authenticate the bootstrap server this time, it sends its
          normal "get-bootstrapping-data" request (i.e., with additional
          input parameters) as well as its progress reports (not depicted).</t>
          <t>This time, because the "signed-data-preferred" parameter was
          not passed, having access to all of the device's input parameters,
          the bootstrap server returns, in this example, unsigned onboarding
          information to the device.  Note also that, because the bootstrap
          server is now trusted, the device will send progress reports to
          the server.</t>
        </list></t>
      </section>
      <section title="Workflow Overview" anchor="workflow-overview">

        <t>The solution presented in this document is conceptualized
        to be composed of the non-normative workflows described in this section.
        Implementation details are expected to vary.  Each diagram is followed
        by a detailed description of the steps presented in the diagram, with
        further explanation on how implementations may vary.</t>

        <section title="Enrollment and Ordering Devices" anchor="onboarding-and-ordering">
          <t>The following diagram illustrates key interactions that may occur from when a
          prospective owner enrolls in a manufacturer's SZTP program to when the
          manufacturer ships devices for an order placed by the prospective owner.</t>
          <t>
            <figure>
              <artwork align="center"><![CDATA[
                               +-----------+
+------------+                 |Prospective|                    +---+
|Manufacturer|                 |   Owner   |                    |NMS|
+------------+                 +-----------+                    +---+
      |                              |                            |
      |                              |                            |
      |  1. initiate enrollment      |                            |
      #<-----------------------------|                            |
      #                              |                            |
      #                              |                            |
      #     IDevID trust anchor      |                            |
      #----------------------------->#  set IDevID trust anchor   |
      #                              #--------------------------->|
      #                              |                            |
      #     bootstrap server         |                            |
      #     account credentials      |                            |
      #----------------------------->#  set credentials           |
      |                              #--------------------------->|
      |                              |                            |
      |                              |                            |
      |  2. set owner certificate trust anchor                    |
      |<----------------------------------------------------------|
      |                              |                            |
      |                              |                            |
      |  3. place device order       |                            |
      |<-----------------------------#  model devices             |
      |                              #--------------------------->|
      |                              |                            |
      |  4. ship devices and send    |                            |
      |     device identifiers and   |                            |
      |     ownership vouchers       |                            |
      |----------------------------->#  set device identifiers    |
      |                              #  and ownership vouchers    |
      |                              #--------------------------->|
      |                              |                            |
]]></artwork>
            </figure>
          </t>
          <t>Each numbered item below corresponds to a numbered item
          in the diagram above.
            <list style="numbers">
              <t>A prospective owner of a manufacturer's devices initiates an
              enrollment process with the manufacturer.  This process includes
              the following:
              <list style="symbols">
                <t>Regardless of how the prospective owner intends to bootstrap their devices,
                they will always obtain from the manufacturer the trust anchor
                certificate for the IDevID certificates.  This certificate 
                is installed on the prospective owner's NMS so that the NMS can
                authenticate the IDevID certificates when they are presented to
                subsequent steps.</t>

                <t>If the manufacturer hosts an Internet-based bootstrap server (e.g., a
                redirect server) such as described in <xref target="bootstrap-server"/>,
                then credentials necessary to configure the bootstrap server would be
                provided to the prospective owner.  If the bootstrap server is
                configurable through an API (outside the scope of this document), then
                the credentials might be installed on the prospective owner's NMS so
                that the NMS can subsequently configure the manufacturer-hosted
                bootstrap server directly.</t>
              </list></t>
              <t>If the manufacturer's devices are able to validate signed data
              (<xref target="validating-signed-data"/>), and assuming that the
              prospective owner's NMS is able to prepare and sign the bootstrapping
              data itself, the prospective owner's NMS might set a trust anchor
              certificate onto the manufacturer's bootstrap server, using the
              credentials provided in the previous step.  This certificate is the
              trust anchor certificate that the prospective owner would like the
              manufacturer to place into the ownership vouchers it generates, thereby
              enabling devices to trust the owner's owner certificate.  How this trust
              anchor certificate is used to enable devices to validate signed bootstrapping
              data is described in <xref target="validating-signed-data"/>.</t>

              <t>Some time later, the prospective owner places an order
              with the manufacturer, perhaps with a special
              flag checked for SZTP handling.  At this time, or
              perhaps before placing the order, the owner may model
              the devices in their NMS, creating virtual objects for the
              devices with no real-world device associations.  For instance,
              the model can be used to simulate the device's location in the
              network and the configuration it should have when fully
              operational.</t>

              <t>When the manufacturer fulfills the order, shipping
              the devices to their intended locations, they may notify the owner
              of the devices' serial numbers and shipping destinations, which
              the owner may use to stage the network for when the devices power
              on.  Additionally,  the manufacturer may send one or more ownership
              vouchers, cryptographically assigning ownership of those devices to
              the owner.  The owner may set this information on their NMS, perhaps
              binding specific modeled devices to the serial numbers and ownership
              vouchers.</t>
            </list>
          </t>
        </section>


        <section title="Owner Stages the Network for Bootstrap">
          <t>The following diagram illustrates how an owner might stage the
          network for bootstrapping devices.</t>
          <t>
            <figure>
              <artwork align="center"><![CDATA[
            +-----------+ +-------------+
            |Deployment-| |Manufacturer-| +------+ +------+
            | Specific  | |   Hosted    | | Local| | Local| +---------+
      +---+ | Bootstrap | |  Bootstrap  | |  DNS | | DHCP | |Removable|
      |NMS| |  Server   | |   Server    | |Server| |Server| | Storage |
      +---+ +-----------+ +-------------+ +------+ +------+ +---------+
        |        |             |            |        |         |
1.      |        |             |            |        |         |
activate|        |             |            |        |         |
modeled |        |             |            |        |         |
device  |        |             |            |        |         |
------->|        |             |            |        |         |
        | 2. (optional)        |            |        |         |
        |    configure         |            |        |         |
        |    bootstrap         |            |        |         |
        |    server            |            |        |         |
        |------->|             |            |        |         |
        |        |             |            |        |         |
        | 3. (optional) configure           |        |         |
        |    bootstrap server  |            |        |         |
        |--------------------->|            |        |         |
        |        |             |            |        |         |
        |        |             |            |        |         |
        | 4. (optional) configure DNS server|        |         |
        |---------------------------------->|        |         |
        |        |             |            |        |         |
        |        |             |            |        |         |
        | 5. (optional) configure DHCP server        |         |
        |------------------------------------------->|         |
        |        |             |            |        |         |
        |        |             |            |        |         |
        | 6. (optional) store bootstrapping artifacts on media |
        |----------------------------------------------------->|
        |        |             |            |        |         |
        |        |             |            |        |         |
]]></artwork>
            </figure>
          </t>

          <t>Each numbered item below corresponds to a numbered item
          in the diagram above.
            <list style="numbers">
              <t>Having previously modeled the devices, including setting their
              fully operational configurations and associating device serial
              numbers and (optionally) ownership vouchers, the owner might "activate" one or
              more modeled devices.  That is, the owner tells the NMS to perform
              the steps necessary to prepare for when the real-world devices
              power up and initiate the bootstrapping process.  Note that,
              in some deployments, this step might be combined with the last step
              from the previous workflow.  Here, it is depicted that an NMS performs
              the steps, but they may be performed manually or through some other
              mechanism.</t>

              <t>If it is desired to use a deployment-specific bootstrap server,
              it must be configured to provide the bootstrapping data for
              the specific devices.   Configuring the bootstrap server may occur
              via a programmatic API not defined by this document.  Illustrated
              here as an external component, the bootstrap server may be
              implemented as an internal component of the NMS itself.</t>

              <t>If it is desired to use a manufacturer-hosted bootstrap
              server, it must be configured to provide the bootstrapping data
              for the specific devices.  The configuration must be either redirect or
              onboarding information.  That is, the manufacturer-hosted bootstrap
              server will either redirect the device to another bootstrap server or provide
              the device with the onboarding information itself.  The types of
              bootstrapping data the manufacturer-hosted bootstrap server
              supports may vary by implementation; some implementations may 
              support only redirect information or only onboarding information, while
	      others
	      may support
              both redirect and onboarding information.  Configuring the
              bootstrap server may occur via a programmatic API not defined by this
              document.</t>

              <t>If it is desired to use a DNS server to supply bootstrapping
              data, a DNS server needs to be configured.  If multicast
              DNS is desired, then the DNS server must reside on the local network;
              otherwise, the DNS server may reside on a remote network.  Please see
              <xref target="dns-server"/> for more information about how to
              configure DNS servers.  Configuring the DNS server may occur via
              a programmatic API not defined by this document.</t>

              <t>If it is desired to use a DHCP server to supply bootstrapping
              data, a DHCP server needs to be configured.  The DHCP server may
              be accessed directly or via a DHCP relay.  Please see
              <xref target="dhcp-server"/> for more information about how to
              configure DHCP servers.  Configuring the DHCP server may occur
              via a programmatic API not defined by this document.</t>

              <t>If it is desired to use a removable storage device (e.g., a USB flash
              drive) to supply bootstrapping data, the data would need
              to be placed onto it.  Please see <xref target="removable-storage"/>
              for more information about how to configure a removable storage device.</t>
            </list>
          </t>
        </section>

        <section title="Device Powers On" anchor="device-powers-on">
          <t>The following diagram illustrates the sequence of activities
          that occur when a device powers on.
            <figure>
              <artwork align="center"><![CDATA[
                                                  +-----------+
                                   +-----------+  |Deployment-|
                                   | Source of |  | Specific  |
+------+                           | Bootstrap |  | Bootstrap |  +---+
|Device|                           |   Data    |  |  Server   |  |NMS|
+------+                           +-----------+  +-----------+  +---+
   |                                     |              |          |
   |                                     |              |          |
   | 1. if SZTP bootstrap service        |              |          |
   |    is not enabled, then exit.       |              |          |
   |                                     |              |          |
   | 2. for each source supported, check |              |          |
   |    for bootstrapping data.          |              |          |
   |------------------------------------>|              |          |
   |                                     |              |          |
   | 3. if onboarding information is     |              |          |
   |    found, initialize self and, only |              |          |
   |    if source is a trusted bootstrap |              |          |
   |    server, send progress reports.   |              |          |
   |------------------------------------>#              |          |
   |                                     # webhook      |          |
   |                                     #------------------------>|
   |                                                    |          |
   | 4. else, if redirect information is found, for     |          |
   |    each bootstrap server specified, check for data.|          |
   |-+------------------------------------------------->|          |
   | |                                                  |          |
   | | if more redirect information is found, recurse   |          |
   | | (not depicted); else, if onboarding information  |          |
   | | is found, initialize self and post progress      |          |
   | | reports.                                         |          |
   | +------------------------------------------------->#          |
   |                                                    # webhook  |
   |                                                    #--------->|
   |
   | 5. retry sources and/or wait for manual provisioning.
   |
]]></artwork>
            </figure>
          </t>
          <t>The interactions in the above diagram are described below.
            <list style="numbers">
              <t>Upon power being applied, the device checks to see if SZTP
              bootstrapping is configured, such as must be the case when running its
              "factory default" configuration.  If SZTP bootstrapping is
              not configured, then the bootstrapping logic exits and none of the
              following interactions occur.</t>

              <t>For each source of bootstrapping data the device supports, preferably
              in order of closeness to the device (e.g., removable storage before
              Internet-based servers), the device checks to see if there is any
              bootstrapping data for it there.</t>

              <t>If onboarding information is found, the device initializes
              itself accordingly (e.g., installing a boot image and committing an
              initial configuration).  If the source is a bootstrap server, and the
              bootstrap server can be trusted (i.e., TLS-level authentication), the
              device also sends progress reports to the bootstrap server.
                <list style="symbols">
                  <t>The contents of the initial configuration should configure
                  an administrator account on the device (e.g., username, SSH public
                  key, etc.), should configure the device to either listen for
                  NETCONF or RESTCONF connections or initiate call home connections
                  <xref target="RFC8071"/>, and should disable the SZTP
                  bootstrapping service (e.g., the "enabled" leaf in data model
                  presented in <xref target="device-model"/>).</t>


                  <t>If the bootstrap server supports forwarding device progress reports
                  to external systems (e.g., via a webhook), a "bootstrap-complete"
                  progress report (<xref target="yang-module"/>) informs the external
                  system to know when it can, for instance, initiate a connection to
                  the device.  To support this scenario further, the "bootstrap-complete"
                  progress report may also relay the device's SSH host keys and/or TLS
                  certificates, which the external system can use to authenticate
                  subsequent connections to the device.</t>
                </list>
              If the device successfully completes the bootstrapping process,
              it exits the bootstrapping logic without considering any additional
              sources of bootstrapping data.
              </t>

              <t>Otherwise, if redirect information is found, the device iterates
              through the list of specified bootstrap servers, checking to see if
              the bootstrap server has bootstrapping data for the device.  If the bootstrap server
              returns more redirect information, then the device processes it recursively.
              Otherwise, if the bootstrap server returns onboarding information,
              the device processes it following the description provided in (3) above.</t>

              <t>After having tried all supported sources of bootstrapping data, the
              device may retry again all the sources and/or provide manageability
              interfaces for manual configuration (e.g., CLI, HTTP, NETCONF, etc.).
              If manual configuration is allowed, and such configuration is provided,
              the configuration should also disable the SZTP bootstrapping service,
              as the need for bootstrapping would no longer be present.</t>
            </list>
          </t>
        </section>
      </section>

      <section title="Acknowledgements" numbered="no">

<!--[rfced] Since the Acknowledgements section notes that the authors are
ordered by last name, we assume that the the list should be in
alphabetical order, so we made a few updates.  If that is not correct,
please let us know.
-->
        <t>The authors would like to thank the following for
        lively discussions on list and in the halls (ordered
        by last name):
        Michael Behringer,
        Martin Bjorklund,
        Dean Bogdanovic,
        Joe Clarke,
        Dave Crocker,
        Toerless Eckert,
        Stephen Farrell,
        Stephen Hanna,
        Wes Hardaker,
        David Harrington,
        Benjamin Kaduk,
        Radek Krejci,
        Suresh Krishnan,
        Mirja Kuehlewind,
        David Mandelberg,
        Alexey Melnikov,
        Russ Mundy,
        Reinaldo Penno,
        Randy Presuhn,
        Max Pritikin,
        Michael Richardson,
        Adam Roach,
        Juergen Schoenwaelder, and
        Phil Shafer.</t>

        <t>Special thanks goes to Steve Hanna, Russ Mundy, and
        Wes Hardaker for brainstorming the original solution
        during the IETF 87 meeting in Berlin.</t>
      </section>

    </back>
</rfc>
