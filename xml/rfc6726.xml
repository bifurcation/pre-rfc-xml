<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='http://xml.resource.org/authoring/rfc2629.xslt'?>
<!DOCTYPE rfc SYSTEM "http://xml.resource.org/authoring/rfc2629.dtd" [
<!ENTITY rfc1112 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1112.xml">
<!ENTITY rfc2045 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml">
<!ENTITY rfc2104 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml">
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc2357 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2357.xml">
<!ENTITY rfc3261 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml">
<!ENTITY rfc3275 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3275.xml">
<!ENTITY rfc3447 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml">
<!ENTITY rfc3470 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3470.xml">
<!ENTITY rfc3688 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3688.xml">
<!ENTITY rfc3830 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3830.xml">
<!ENTITY rfc3926 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3926.xml">
<!ENTITY rfc3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY rfc4082 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4082.xml">
<!ENTITY rfc4566 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4566.xml">
<!ENTITY rfc5052 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5052.xml">
<!ENTITY rfc5226 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY rfc5445 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5445.xml">
<!ENTITY rfc5651 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5651.xml">
<!ENTITY rfc5751 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5751.xml">
<!ENTITY rfc5775 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5775.xml">
<!ENTITY rfc5776 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5776.xml">
<!ENTITY rfc5905 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5905.xml">
<!ENTITY rfc6584 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6584.xml">
]>
<?rfc toc='yes'?>
<?rfc compact='yes'?>
<?rfc symrefs='yes'?>
<?rfc subcompact='no'?>
<?rfc rfcedstyle="yes"?>

<rfc category="std" number="6726"
     ipr="pre5378Trust200902" obsoletes="3926"
     submissionType="IETF" consensus="yes">

  <front>
    <title abbrev="FLUTE">FLUTE - File Delivery over Unidirectional
    Transport</title>

    <author fullname="Toni Paila" initials="T." surname="Paila">
      <organization>Nokia</organization>

      <address>
        <postal>
          <street>Itamerenkatu 11-13</street>

          <city>Helsinki</city>

          <code>00180</code>

          <country>Finland</country>
        </postal>

        <email>toni.paila@gmail.com</email>
      </address>
    </author>

    <author fullname="Rod Walsh" initials="R." surname="Walsh">
      <organization abbrev="Nokia/TUT">Nokia/Tampere University of Technology</organization>

      <address>
        <postal>

          <street>P.O. Box 553 (Korkeakoulunkatu 1)</street>

          <city>Tampere</city>

          <code>FI-33101</code>

          <country>Finland</country>
        </postal>

        <email>roderick.walsh@tut.fi</email>
      </address>
    </author>

    <author fullname="Michael Luby" initials="M." surname="Luby">
      <organization>Qualcomm Technologies, Inc.</organization>

      <address>

        <postal>

          <street>2030 Addison Street, Suite 420</street>

          <city>Berkeley</city>

          <region>CA</region>

          <code>94704</code>

          <country>USA</country>
        </postal>

        <email>luby@qti.qualcomm.com</email>
      </address>
    </author>

    <author fullname="Vincent Roca" initials="V." surname="Roca">
      <organization>INRIA</organization>

      <address>
        <postal>
          <street>655, av. de l'Europe</street>

          <street>Inovallee; Montbonnot</street>

          <city>ST ISMIER cedex</city>

          <code>38334</code>

          <country>France</country>
        </postal>

        <email>vincent.roca@inria.fr</email>
      </address>
    </author>

    <author fullname="Rami Lehtonen" initials="R." surname="Lehtonen">
      <organization>TeliaSonera</organization>

      <address>
        <postal>
          <street>Hatanpaankatu 1</street>

          <city>Tampere</city>

          <code>FIN-33100</code>

          <country>Finland</country>
        </postal>

        <email>rami.lehtonen@teliasonera.com</email>
      </address>
    </author>

    <date month="November" year="2012" />

    <area>Transport</area>

    <workgroup>Reliable Multicast Transport (RMT)</workgroup>

    <keyword>File</keyword>

    <keyword>Delivery</keyword>

    <keyword>Multicast</keyword>

    <keyword>Unidirectional</keyword>

    <abstract>
      <t>This document defines File Delivery over Unidirectional Transport
      (FLUTE), a protocol for the unidirectional
      delivery of files over the Internet, which is particularly suited to
      multicast networks. The specification builds on Asynchronous Layered
      Coding, the base protocol designed for massively scalable multicast
      distribution. This document obsoletes RFC 3926.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction">

      <t>This document defines FLUTE version 2, a protocol for unidirectional
      delivery of files over the Internet. This specification is not 
      backwards compatible with the previous experimental version defined in
      <xref target="RFC3926"></xref> (see <xref target="change-log"/> for
      details).
      The specification builds on Asynchronous Layered Coding (ALC), version 1
      <xref target="RFC5775"></xref>, the base protocol designed for
      massively scalable multicast distribution. ALC defines transport of
      arbitrary binary objects. For file delivery applications, mere transport
      of objects is not enough, however. The end systems need to know what
      the objects actually represent. This document specifies a technique
      called FLUTE -- a mechanism for signaling and mapping the properties of
      files to concepts of ALC in a way that allows receivers to assign those
      parameters for received objects. Consequently, throughout this document
      the term 'file' relates to an 'object' as discussed in ALC. Although
      this specification frequently makes use of multicast addressing as an
      example, the techniques are similarly applicable for use with unicast
      addressing.</t>

      <t>This document defines a specific transport application of ALC, adding
      the following specifications: <list style="hanging">
          <t hangText="-">Definition of a file delivery session built on top
          of ALC, including transport details and timing constraints.</t>

          <t hangText="-">In-band signaling of the transport parameters of the
          ALC session.</t>

          <t hangText="-">In-band signaling of the properties of delivered
          files.</t>

          <t hangText="-">Details associated with the multiplexing of multiple
          files within a session.</t>
        </list></t>

      <t>This specification is structured as follows. <xref target="file-delivery"/> begins by
      defining the concept of the file delivery session. Following that, it
      introduces the File Delivery Table, which forms the core part of this
      specification. Further, it discusses multiplexing issues of transmission
      objects within a file delivery session. <xref target="channels-cc-timing"/> describes the use of
      congestion control and channels with FLUTE. <xref target="deliv-fec-oti"/> defines how the
      Forward Error Correction (FEC) Object Transmission Information is to be
      delivered within a file delivery session. <xref target="desc-file-delivery-session"/> defines the required
      parameters for describing file delivery sessions in a general case.
      <xref target="sec-cons"/> outlines security considerations regarding file delivery with
      FLUTE. Last, there are two informative appendices. <xref target="rcvr-op"/>
      describes an envisioned receiver operation for the receiver of the file
      delivery session. Readers who want to see a simple example of FLUTE in
      operation should refer to <xref target="rcvr-op"/> right away.
<xref target="example-fdt-instance"/> gives 
      an example of a File Delivery Table.</t>

      <t>This specification contains part of the definitions necessary to
      fully specify a Reliable Multicast Transport (RMT) protocol in
      accordance with <xref target="RFC2357"/>.</t>

      <t>This document obsoletes <xref target="RFC3926"/>, which contained a
      previous version of this specification and was published in the
      "Experimental" category. This Proposed Standard specification is thus
      based on <xref target="RFC3926"/> and has been updated
      according to accumulated experience and growing protocol maturity since
      the publication of <xref target="RFC3926"/>. Said experience applies
      both to this
      specification itself and to congestion control strategies related to the
      use of this specification.</t>

      <t>The differences between <xref target="RFC3926"/> and this document
      are listed in <xref target="change-log"></xref>.</t>

      <t>This document updates ALC <xref target="RFC5775"/> and Layered
      Coding Transport (LCT) <xref target="RFC5651"/>
      in the sense that it defines two new header extensions,
      EXT_FDT and EXT_CENC.</t>

      <section anchor="applicability-statement"
               title="Applicability Statement">
        <section anchor="target-app-space"
                 title="The Target Application Space">
          <t>FLUTE is applicable to the delivery of large and small files to
          many hosts, using delivery sessions of several seconds or more. For
          instance, FLUTE could be used for the delivery of large software
          updates to many hosts simultaneously. It could also be used for
          continuous, but segmented, data such as time-lined text for
          subtitling -- potentially leveraging its layering inheritance from
          ALC and LCT to scale the richness of the session to the congestion
          status of the network. It is also suitable for the basic transport
          of metadata, for example, Session Description Protocol (SDP)
          <xref target="RFC4566"></xref> files that enable user applications
          to access multimedia sessions.</t>
        </section>

        <section anchor="target-scale" title="The Target Scale">
          <t>Massive scalability is a primary design goal for FLUTE. IP
          multicast is inherently massively scalable, but the best-effort
          service that it provides does not provide session management
          functionality, congestion control, or reliability. FLUTE provides all
          of this by using ALC and IP multicast without sacrificing any of the
          inherent scalability of IP multicast.</t>
        </section>

        <section anchor="int-environ" title="Intended Environments">
          <t>All of the environmental requirements and considerations that
          apply to the RMT building blocks used by FLUTE shall also apply to
          FLUTE. These are the ALC protocol instantiation <xref
          target="RFC5775"></xref>, the LCT building block
          <xref target="RFC5651"/>, and the FEC building
          block <xref target="RFC5052"></xref>.</t>

          <t>FLUTE can be used with both multicast and unicast delivery, but
          its primary application is for unidirectional multicast file
          delivery. FLUTE requires connectivity between a sender and receivers
          but does not require connectivity from receivers to a sender.
          Because of its low expectations, FLUTE
          works with most types of networks, including LANs, WANs,
          Intranets, the Internet, asymmetric networks, wireless networks, and
          satellite networks.</t>

          <t>FLUTE is compatible with both IPv4 and IPv6, as no part of the
          packet is IP version specific. FLUTE works with both multicast
          models: Any-Source Multicast (ASM) <xref target="RFC1112"></xref>
          and Source-Specific Multicast (SSM) <xref
          target="PAPER.SSM"></xref>.</t>

          <t>FLUTE is applicable for both shared networks, such as the
          Internet, with a suitable congestion control building block;
          and provisioned/controlled networks, such as wireless broadcast
          radio systems, with a traffic-shaping building block.</t>
        </section>

        <section anchor="weaknesses" title="Weaknesses">
          <t>FLUTE congestion control protocols depend on the ability of a
          receiver to change multicast subscriptions between multicast 
          groups supporting different rates and/or layered codings.  If
          the network does not support this, then the FLUTE congestion 
          control protocols may not be amenable to such a network.</t>

          <t>FLUTE can also be used for point-to-point (unicast)
          communications. At a minimum, implementations of ALC MUST support
          the Wave and Equation Based Rate Control (WEBRC) <xref
          target="RFC3738"></xref> multiple-rate congestion control scheme
          <xref target="RFC5775"></xref>. However, since WEBRC has been
          designed for massively scalable multicast flows, it is not clear how
          appropriate it is to the particular case of unicast flows. Using a
          separate point-to-point congestion control scheme is another
          alternative. How to do that is outside the scope of the present
          document.</t>

          <t>FLUTE provides reliability using the FEC building block. This
          will reduce the error rate as seen by applications. However, FLUTE
          does not provide a method for senders to verify the reception
          success of receivers, and the specification of such a method is
          outside the scope of this document.</t>
        </section>
      </section>
    </section>

    <section anchor="conventions" title="Conventions Used in This Document">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref target="RFC2119"/>.</t>

      <t>The terms "object" and "transmission object" are consistent with the
      definitions in ALC <xref target="RFC5775"></xref> and LCT <xref
      target="RFC5651"/>. The terms "file" and "source object" are
      pseudonyms for "object".</t>
    </section>

    <section anchor="file-delivery" title="File Delivery">
      <t>Asynchronous Layered Coding <xref target="RFC5775"></xref> is
      a protocol designed for delivery of arbitrary binary objects. It is
      especially suitable for massively scalable, unidirectional multicast
      distribution. ALC provides the basic transport for FLUTE, and thus FLUTE
      inherits the requirements of ALC.</t>

      <t>This specification is designed for the delivery of files. The core of
      this specification is to define how the properties of the files are
      carried in-band together with the delivered files.</t>

      <t>As an example, let us consider a 5200-byte file referred to by
      "http://www.example.com/docs/file.txt". Using the example, the following
      properties describe the properties that need to be conveyed by the file
      delivery protocol.</t>

      <t><list style="hanging">
          <t hangText="*">Identifier of the file, expressed as a URI <xref target="RFC3986"/>.
          The identifier MAY provide a location for the file.
          In the above example: "http://www.example.com/docs/file.txt".</t>

          <t hangText="*">File name (usually, this can be concluded from the
          URI). In the above example: "file.txt".</t>

          <t hangText="*">File type, expressed as Internet Media Types (often
          referred to as "Media Types"). In the above example: "text/plain".</t>

          <t hangText="*">File size, expressed in octets. In the above
          example: "5200". If the file is content encoded, then this is the
          file size before content encoding.</t>

          <t hangText="*">Content encoding of the file, within transport. In
          the above example, the file could be encoded using ZLIB <xref
          target="RFC1950"></xref>. In this case, the size of the transmission
          object carrying the file would probably differ from the file size.
          The transmission object size is delivered to receivers as part of
          the FLUTE protocol.</t>

          <t hangText="*">Security properties of the file, such as digital
          signatures, message digests, etc. For example, one could use S/MIME
          <xref target="RFC5751"></xref> as the content encoding type for
          files with this authentication wrapper, and one could use
          XML Digital Signatures (XML-DSIG) <xref target="RFC3275"></xref>
          to digitally sign the file. 
          XML-DSIG can also be used to provide tamper prevention,
          e.g., in the Content-Location field. Content encoding is applied to
          file data before FEC protection.</t>
        </list></t>

      <t>For each unique file, FLUTE encodes the attributes listed above
         and other attributes as children of an XML file element.  A 
         table of XML file elements is transmitted as a special file 
         called a 'File Delivery Table' (FDT), which is further described
         in the next subsection and in <xref target="fdt"/>.</t>

      <section anchor="file-delivery-session" title="File Delivery Session">
        <t>ALC is a protocol instantiation of the Layered Coding Transport
        (LCT) building block <xref target="RFC5651"/>. Thus, ALC inherits
        the session concept of LCT. In this document, we will use the concept
        of the ALC/LCT session to collectively denote the interchangeable
        terms "ALC session" and "LCT session".</t>

        <t>An ALC/LCT session consists of a set of logically grouped ALC/LCT
        channels associated with a single sender sending ALC/LCT packets for
        one or more objects. An ALC/LCT channel is defined by the combination
        of a sender and an address associated with the channel by the
        sender. A receiver joins a channel to start receiving the data packets
        sent to the channel by the sender, and a receiver leaves a channel to
        stop receiving data packets from the channel.</t>

        <t>One of the fields carried in the ALC/LCT header is the Transport
        Session Identifier (TSI), an integer carried in a field of size 16,
        32, or 48 bits (note that the TSI may be carried by other means,
        in which case it is absent from the LCT header <xref target="RFC5651"/>).
        The (source IP address, TSI) pair uniquely
        identifies a session.  Note that the TSI is scoped by the IP address,
        so the same TSI may be used by several source IP addresses at once.
        Thus, the receiver uses the (source IP address, TSI) pair from each
        packet to uniquely identify the session sending each packet.  When a
        session carries multiple objects, the Transmission Object Identifier
        (TOI) field within the ALC/LCT header names the object used to generate
        each packet. Note that each object is associated with a unique TOI
        within the scope of a session.</t>

        <t>A FLUTE session consistent with this specification MUST use FLUTE
        version 2 as specified in this document.  Thus, all sessions consistent
        with this specification MUST set the FLUTE version to 2. The FLUTE 
        version is carried within the EXT_FDT Header Extension (defined in
        <xref target="ext-fdt"/>) in the ALC/LCT layer.  A FLUTE session
        consistent with 
        this specification MUST use ALC version 1 as specified in <xref target="RFC5775"/>, and 
        LCT version 1 as specified in <xref target="RFC5651"/>.</t>

        <t>If multiple FLUTE sessions are sent to a channel, then receivers MUST
        determine the FLUTE protocol version, based on version fields and the
        (source IP address, TSI) pair carried in the ALC/LCT header of the packet.
        Note that when a receiver first begins receiving packets, it might not
        know the FLUTE protocol version, as not every LCT packet carries the
        EXT_FDT header (containing the FLUTE protocol version). A new receiver
        MAY keep an open binding in the LCT protocol layer between the TSI and
        the FLUTE protocol version, until the EXT_FDT header arrives.
        Alternatively, a new receiver MAY discover a binding between TSI and
        FLUTE protocol version via a session discovery protocol that is out of
        scope of this document.</t>

        <t>If the sender's IP address is not accessible to
        receivers, then packets that can be received by receivers contain an
        intermediate IP address.  In this case, the TSI is scoped by this
        intermediate IP address of the sender for the duration of the session. As
        an example, the sender may be behind a Network Address Translation
        (NAT) device that temporarily assigns an IP address for the sender.
        In this case, the TSI is scoped by the intermediate IP address
        assigned by the NAT.  As another example, the sender may send its
        original packets using IPv6, but some portions of the network may not
        be IPv6 capable.  Thus, there may be an IPv6-to-IPv4 translator that
        changes the IP address of the packets to a different IPv4 address. In
        this case, receivers in the IPv4 portion of the network will receive
        packets containing the IPv4 address, and thus the TSI for them is
        scoped by the IPv4 address. How the IP address of the sender to be
        used to scope the session by receivers is delivered to receivers,
        whether it is the sender's IP address or an intermediate IP address, is
        outside the scope of this document.</t>

        <t>When FLUTE is used for file delivery over ALC, the ALC/LCT session
        is called a file delivery session, and the ALC/LCT concept of
        'object' denotes either a 'file' or a 'File Delivery Table Instance'
        (<xref target="fdt"/>).</t>

        <t>Additionally, the following rules apply:
        <list style="hanging">
            <t hangText="*">The TOI field MUST be included in ALC packets
            sent within a FLUTE session, with the exception that ALC packets
            sent in a FLUTE session with the Close Session (A) flag set to 1
            (signaling the end of the session) and that contain no payload
            (carrying no information for any file or FDT) SHALL NOT carry the
            TOI. See Section 5.1 of <xref target="RFC5651"/>
            for the LCT definition of the Close Session flag, and see
            Section 4.2 of <xref target="RFC5775"></xref> for an
            example of the use of a TOI within an ALC packet.</t>

            <t hangText="*">The TOI value '0' is reserved for the delivery of
            File Delivery Table Instances. Each non-expired File Delivery Table
            Instance is uniquely identified by an FDT Instance ID
            within the EXT_FDT header defined in <xref target="ext-fdt"/>.</t>

            <t hangText="*">Each file in a file delivery session MUST be
            associated with a TOI (&gt;0) in the scope of that session.</t>

            <t hangText="*">Information carried in the headers and the payload
            of a packet is scoped by the source IP address and the TSI.
            Information particular to the object carried in the headers and
            the payload of a packet is further scoped by the TOI for file
            objects, and is further scoped by both the TOI and the FDT
            Instance ID for FDT Instance objects.</t>
        </list></t>
      </section>

      <section anchor="fdt" title="File Delivery Table">
        <t>The File Delivery Table (FDT) provides a means to describe various
        attributes associated with files that are to be delivered within the
        file delivery session. The following lists are examples of such
        attributes and are not intended to be mutually exclusive or
        exhaustive.</t>

        <t>Attributes related to the delivery of a file: <list style="hanging">
            <t hangText="-">TOI value that represents the file</t>

            <t hangText="-">FEC Object Transmission Information (including the
            FEC Encoding ID and, if relevant, the FEC Instance ID)</t>

            <t hangText="-">Size of the transmission object carrying the
            file</t>

            <t hangText="-">Aggregate rate of sending packets to all
            channels</t>
          </list></t>

        <t>Attributes related to the file itself: <list style="hanging">
            <t hangText="-">Name, Identification, and Location of file
            (specified by the URI)</t>

            <t hangText="-">Media type of file</t>

            <t hangText="-">Size of file</t>

            <t hangText="-">Encoding of file</t>

            <t hangText="-">Message digest of file</t>
          </list></t>

        <t>Some of these attributes MUST be included in the file description
        entry for a file; others are optional, as defined
        in <xref target="fdt-syntax"/>.</t>

        <t>Logically, the FDT is a set of file description entries for files
        to be delivered in the session. Each file description entry MUST
        include the TOI for the file that it describes and the URI identifying
        the file. The TOI carried in each file description entry is how 
        FLUTE names the ALC/LCT data packets used for delivery of the file.
        Each file description entry may also contain one or more descriptors 
        that map the above-mentioned attributes to the file.</t>

        <t>Each file delivery session MUST have an FDT that is local to the
        given session. The FDT MUST provide a file description entry mapped to
        a TOI for each file appearing within the session. An object that is
        delivered within the ALC session, but not described in the FDT, other
        than the FDT itself, is not considered a 'file' belonging to the file
        delivery session. This object received with an unmapped TOI
        (non-zero TOI that is not resolved by the FDT) SHOULD in general be
        ignored by a FLUTE receiver. The details of how to do that are out of
        scope of this specification.</t>

        <t>Note that a client that joins an active file delivery session MAY receive
        data packets for a TOI &gt; 0 before receiving any FDT Instance
        (see <xref target="fdt-dynamics"/> for recommendations on how to limit
        the probability that this situation will occur). Even if the TOI is
        not mapped to any file
        description entry, this is hopefully a transient situation.
        When this happens, system performance might be improved by caching such
        packets within a reasonable time window and storage size. Such optimizations
        are use-case and implementation specific, and further details are beyond
        the scope of this document.
        </t>

        <t>Within the file delivery session, the FDT is delivered as FDT
        Instances. An FDT Instance contains one or more file description
        entries of the FDT. Any FDT Instance can be equal to, be a subset of,
        be a superset of, overlap with, or complement any other FDT Instance.
        A certain FDT Instance may be repeated multiple times during a session,
        even after subsequent FDT Instances (with higher FDT Instance ID
        numbers) have been transmitted. Each FDT Instance contains at least a
        single file description entry and at most the exhaustive set of file
        description entries of the files being delivered in the file delivery
        session.</t>

        <t>A receiver of the file delivery session keeps an FDT database for
        received file description entries. The receiver maintains the
        database, for example, upon reception of FDT Instances. Thus, at any
        given time the contents of the FDT database represent the receiver's
        current view of the FDT of the file delivery session. Since each
        receiver behaves independently of other receivers, it SHOULD NOT be
        assumed that the contents of the FDT database are the same for all the
        receivers of a given file delivery session.</t>

        <t>Since the FDT database is an abstract concept, the structure and the
        maintenance of the FDT database are left to individual implementations
        and are thus out of scope of this specification.</t>
      </section>

      <section anchor="fdt-dynamics"
               title="Dynamics of FDT Instances within a File Delivery Session">
        <t>The following rules define the dynamics of the FDT Instances within
        a file delivery session: <list style="hanging">
            <t hangText="*">For every file delivered within a file delivery
            session, there MUST be a file description entry included in at
            least one FDT Instance sent within the session. A file description
            entry contains at a minimum the mapping between the TOI and the
            URI.</t>

            <t hangText="*">An FDT Instance MAY appear in any part of the file
            delivery session, and packets for an FDT Instance MAY be
            interleaved with packets for other files or other FDT Instances
            within a session.</t>

            <t hangText="*">The TOI value of '0' MUST be reserved for delivery
            of FDT Instances. The use of other TOI values (i.e., an integer &gt; 0)
            for FDT Instances is outside the scope of this specification.</t>

            <t hangText="*">The FDT Instance is identified by the use of a new
            fixed-length LCT Header Extension, EXT_FDT (defined later in this
            section).  Each non-expired FDT Instance is uniquely identified
            within the file delivery session by its FDT Instance ID, carried 
            by the EXT_FDT Header Extension. Any ALC/LCT packet carrying an FDT
            Instance MUST include EXT_FDT.</t>

            <t hangText="*">It is RECOMMENDED that an FDT Instance that
            contains the file description entry for a file be sent at least
            once before sending the described file within a file delivery
            session.  This recommendation is intended to minimize the amount
            of file data that may be received by receivers in advance of the
            FDT Instance containing the entry for a file (such data must
            either be speculatively buffered or discarded). Note that this
            possibility cannot be completely eliminated, since the first
            transmission of FDT data might be lost.</t>

            <t hangText="*">Within a file delivery session, any TOI &gt; 0 MAY
            be described more than once. For example, a previous FDT Instance 0
            describes a TOI of value '3'. Now, subsequent FDT Instances can
            either keep TOI '3' unmodified in the table, not include it, or
            augment the description. However, subsequent FDT Instances MUST
            NOT change the parameters already described for a specific
            TOI.</t>

            <t hangText="*">An FDT Instance is valid until its expiration
            time. The expiration time is expressed within the FDT Instance
            payload as a UTF-8 decimal representation of a 32-bit unsigned
            integer. The value of this integer represents the 32 most
            significant bits of a 64-bit Network Time Protocol (NTP) <xref
            target="RFC5905"></xref> time value. These 32&nbsp;bits provide an
            unsigned integer representing the time in seconds relative to
            0 hours 1 January 1900 in the case of the prime epoch (era&nbsp;0)
            <xref target="RFC5905"></xref>. The handling of time wraparound
            (to happen in 2036) requires that the associated epoch be
            considered. In any case, both a sender and a receiver easily
            determine to which (136-year) epoch
            the FDT Instance expiration time value pertains by choosing the
            epoch for which the expiration time is closest in time to the
            current time.</t>

            <t>
            Here is an example.
            Let us imagine that a new FLUTE session is started on February
            7th, 2036, 0h, i.e., at NTP time 4,294,944,000, a few hours
            before the end of epoch 0.
            In order to define an FDT Instance valid for the next 48 hours,
            The FLUTE sender sets an expiry time of 149,504.
            This FDT Instance will expire exactly on February 9th, 2036, 0h.
            A client that receives this FDT Instance on the 7th, 0h, just
            after it has been sent, immediately understands that this value
            corresponds to epoch 1.
            A client that joins the session on February 8th, 0h, i.e., at
            NTP time 63,104, epoch 1, immediately understands that the
            149,504 NTP timestamp corresponds to epoch 1.
            </t>

            <t hangText="*">The space of FDT Instance IDs is limited by the
            associated field size (i.e., 20 bits) in the EXT_FDT Header
            Extension (<xref target="ext-fdt"/>). Therefore,
            senders should take care to always have a large enough supply of
            available FDT Instance IDs when specifying FDT expiration times.</t>

            <t hangText="*">The receiver MUST NOT use a received FDT
            Instance to interpret packets received beyond the expiration time
            of the FDT Instance.</t>

            <t hangText="*">A sender MUST use an expiration time in the future
            upon creation of an FDT Instance relative to its Sender Current
            Time (SCT).</t>

            <t hangText="*">Any FEC Encoding ID MAY be used for the sending of
            FDT Instances. The default is to use the Compact No-Code FEC 
            Encoding ID 0 <xref target="RFC5445"></xref> 
            for the sending of FDT Instances.  (Note that since FEC Encoding
            ID 0 is the default for FLUTE, this
            implies that Source Block Number and Encoding Symbol ID lengths
            both default to 16&nbsp;bits each.)</t>

            <t hangText="*">If the receiver does not support the FEC Scheme
            indicated by the FEC Encoding ID, the receiver MUST NOT decode
            the associated FDT.</t>

            <t hangText="*">It is RECOMMENDED that the mechanisms used for 
            file attribute delivery SHOULD achieve a delivery probability 
            that is higher than the file recovery probability and the file
            attributes SHOULD be delivered at this higher priority before 
            the delivery of the associated files begins.</t>

          </list></t>

        <t>Generally, a receiver needs to receive an FDT Instance describing a
        file before it is able to recover the file itself. In this sense, FDT
        Instances are of higher priority than files. Additionally, a FLUTE
        sender SHOULD assume that receivers will not receive all packets
        pertaining
        to FDT Instances.  The way FDT Instances are transmitted has a large
        impact on satisfying the recommendation above. When there is a single
        file transmitted in the session, one way to satisfy the recommendation
        above is to repeatedly transmit on a regular enough basis FDT Instances
        describing the file while the file is being transmitted. If an FDT
        Instance is longer than one packet payload in length, it is RECOMMENDED
        that an FEC code that provides protection against loss be used for
        delivering this FDT Instance. When there are multiple files in a
        session concurrently being transmitted to receivers, the way the FDT
        Instances are structured and transmitted also has a large impact.  As
        an example, a way to satisfy the recommendation above is to transmit an
        FDT Instance that describes all files currently being transmitted, and
        to transmit this FDT Instance reliably, using the same techniques as
        explained for the case when there is a single file transmitted in a
        session. If instead the concurrently transmitted files are described in
        separate FDT Instances, another way to satisfy this recommendation is
        to transmit all the relevant FDT Instances reliably, using the same
        techniques as explained for the case when there is a single file
        transmitted in a session.</t>

        <t>In any case, how often the description of a file is sent in an FDT
        Instance, how often an FDT Instance is sent, and how much FEC
        protection is provided for an FDT Instance (if longer than one packet
        payload) are dependent on the particular application and are outside
        the scope of this document.</t>

        <t>Sometimes the various attributes associated with files that are to
        be delivered within the file delivery session are sent out-of-band.
        The details of how this is done are out of the scope of this document.
        However, it is still RECOMMENDED that any out-of-band transmission be
        managed in such a way that a receiver will be able to recover the
        attributes associated with a file at least as reliably
        as the receiver is able to receive enough packets containing encoding
        symbols to recover the file. For example, the probability of a
        randomly chosen receiver being able to recover a given file can often
        be estimated based on a statistical model of reception conditions, the
        amount of data transmitted, and the properties of any Forward Error
        Correction in use. The recommendation above suggests that mechanisms
        used for file attribute delivery should achieve a higher delivery
        probability than the file recovery probability.
        The sender MAY also continue sending the various file attributes
        in-band, in addition to the out-of-band transmission.</t>

      </section>

      <section anchor="fdt-structure"
               title="Structure of FDT Instance Packets">
        <t>FDT Instances are carried in ALC packets with TOI = 0 and with an
        additional REQUIRED LCT Header extension called the FDT Instance
        Header. The FDT Instance Header (EXT_FDT) contains the FDT Instance ID
        that uniquely identifies FDT Instances within a file delivery session.
        Placement of the FDT Instance Header is the same as that of any
        other LCT Header Extension. There MAY be other LCT Header Extensions
        in use.</t>

        <t>The FDT Instance is encoded for transmission, like any other object,
        using an FEC Scheme (which MAY be the Compact No-Code FEC Scheme). The
        LCT Header Extensions are followed by the FEC Payload ID, and finally
        the Encoding Symbols for the FDT Instance, which contains one or more
        file description entries. An FDT Instance MAY span several ALC
        packets --
        the number of ALC packets is a function of the file attributes
        associated with the FDT Instance. The FDT Instance Header is carried in
        each ALC packet carrying the FDT Instance. The FDT Instance Header is
        identical for all ALC/LCT packets for a particular FDT Instance.</t>

        <t>The overall format of ALC/LCT packets carrying an FDT Instance is
        depicted in <xref target="overall-flute-packet"/> below.
        All integer fields are carried in
        "big-endian" or "network order" format (i.e., most significant
        byte (octet) first). As defined in <xref target="RFC5775"></xref>,
        all ALC/LCT packets are sent using UDP.</t>

        <figure anchor="overall-flute-packet" title="Overall FDT Packet">
          <artwork><![CDATA[
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         UDP header                            |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Default LCT header (with TOI = 0)              |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          LCT Header Extensions (EXT_FDT, EXT_FTI, etc.)       |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       FEC Payload ID                          |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
               FLUTE Payload: Encoding Symbol(s)                
~             (for FDT Instance in an FDT packet)               ~
                                 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]></artwork>
        </figure>

        <section anchor="ext-fdt" title="Format of FDT Instance Header">
          <t>The FDT Instance Header (EXT_FDT) is a new fixed-length,
          ALC Protocol-Instantiation-specific LCT Header
          Extension <xref target="RFC5651"/>. The
          Header Extension Type (HET) for the extension is 192. Its format is
          defined below:</t>

          <figure anchor="fig-ext-fdt" title="EXT_FDT Format">
            <artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   HET = 192   |   V   |          FDT Instance ID              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]></artwork>
          </figure>

          <t>Version of FLUTE (V), 4 bits:</t>

          <t>This document specifies FLUTE version 2. Hence, in any ALC packet
          that carries an FDT Instance and that belongs to the file delivery
          session as specified in this specification MUST set this field
          to&nbsp;'2'.</t>

          <t>FDT Instance ID, 20 bits:</t>

          <t>For each file delivery session, the numbering of FDT Instances
          starts from '0' and is incremented by one for each subsequent FDT
          Instance. After reaching the maximum value (2^20-1), the numbering
          starts from the smallest FDT Instance ID value assigned to an expired
          FDT Instance. When wraparound from a greater FDT Instance ID value
          to a smaller FDT Instance ID value occurs, the smaller FDT Instance
          ID value is considered logically higher than the greater FDT
          Instance ID value.
          Then, the subsequent FDT Instances are assigned the next available
          smallest FDT Instance ID value, in order to always keep the FDT
          Instance ID values logically increasing.</t>

          <t>Senders MUST NOT reuse an FDT Instance ID
          value that is already in use for a non-expired FDT Instance. Sender
          behavior when all the FDT Instance IDs are used by non-expired FEC
          Instances is outside the scope of this specification and left to
          individual implementations of FLUTE. Receipt of an FDT Instance that
          reuses an FDT Instance ID value that is currently used by a
          non-expired FDT Instance MUST be considered an error case.
          Receiver behavior in this case (e.g., leave the session or ignore
          the new FDT Instance) is outside the scope of this specification
          and left to individual implementations of FLUTE. Receivers MUST be
          ready to handle FDT Instance ID wraparound and situations where
          missing FDT Instance IDs result in increments larger than one.</t>

        </section>

        <section anchor="fdt-syntax" title="Syntax of FDT Instance">
          <t>The FDT Instance contains file description entries that provide
          the mapping functionality described in <xref target="fdt"/> above.</t>

          <t>The FDT Instance is an Extensible Markup Language (XML) structure
          that has a single root
          element "FDT-Instance". The "FDT-Instance" element MUST contain the
          "Expires" attribute, which provides the expiration time of the FDT
          Instance. In addition, the "FDT-Instance" element MAY contain the
          "Complete" attribute, a boolean that can be either set to '1' or 'true'
          for TRUE, or '0' or 'false' for FALSE. When TRUE, the "Complete"
          attribute signals that this
          "FDT Instance" includes the set of "File" entries that exhausts both
          the set of files delivered so far and the set of files to be
          delivered in the session. This implies that no new data will be
          provided in future FDT Instances within this session (i.e., that
          either FDT Instances with higher ID numbers will not be used or, if
          they are used, will only provide file parameters identical to those
          already given in this and previous FDT Instances). The "Complete"
          attribute is therefore used to provide a complete list of files in
          an entire FLUTE session (a "complete FDT").
          Note that when all the FDT Instances received so far have no "Complete"
          attribute, the receiver MUST consider that the session is not
          complete and that new data MAY be provided in future FDT Instances.
          This is equivalent to receiving FDT Instances having the "Complete"
          attribute set to FALSE.
          </t>

          <t>The "FDT-Instance" element MAY contain attributes that give
          common parameters for all files of an FDT Instance. These attributes
          MAY also be provided for individual files in the "File" element.
          Where the same attribute appears in both the "FDT-Instance" and the
          "File" elements, the value of the attribute provided in the "File"
          element takes precedence.</t>

          <t>For each file to be declared in the given FDT Instance, there is a
          single file description entry in the FDT Instance. Each entry is
          represented by element "File", which is a child element of the FDT
          Instance structure.</t>

          <t>The attributes of the "File" element in the XML structure represent
          the attributes given to the file that is delivered in the file
          delivery session. The value of the XML attribute name corresponds to
          the MIME field name, and the XML attribute value corresponds to the value
          of the MIME field body <xref target="RFC2045"/>.
          Each "File" element MUST contain at least
          two attributes: "TOI" and "Content-Location". "TOI" MUST be assigned
          a valid TOI value as described in <xref target="fdt-dynamics"/>.
          "Content-Location" <xref target="RFC2616"/> MUST be assigned a
          syntactically valid URI, as defined in <xref target="RFC3986"/>,
          which identifies the file to be delivered. For example, it can be a
          URI with the "http" or "file" URI scheme.
          Only one "Content-Location" attribute is allowed for each file.
          The "Content-Location" field MUST be considered a string
          that identifies a file (i.e., two different strings are two different
          identifiers).
          Any use of the "Content-Location" field for anything else other
          than to identify the object is out of scope of this specification.
          The semantics for any two "File" elements declaring the same
          "Content-Location" but differing "TOI" is that the element appearing
          in the FDT Instance with the greater FDT Instance ID is considered
          to declare a newer instance (e.g., version) of the same "File".</t>

          <t>In addition to mandatory attributes, the "FDT-Instance" element
          and the "File" element MAY contain other attributes, of which the
          following are specifically pointed out: 

          <list style="hanging">
              <t hangText="*">The attribute "Content-Type" SHOULD be included
              and, when present, MUST be used for the purpose defined in <xref
              target="RFC2616"></xref>.</t>

              <t hangText="*">Where the length is described, the attribute
              "Content-Length" MUST be used for the purpose defined in
              <xref target="RFC2616"></xref>. The transfer length is
              defined to be the length of the object transported in octets. It
              is often important to convey the transfer length to receivers,
              because the source block structure needs to be known for the FEC
              decoder to be applied to recover source blocks of the file, and
              the transfer length is often needed to properly determine the
              source block structure of the file. There generally will be a
              difference between the length of the original file and the
              transfer length if content encoding is applied to the file
              before transport, and thus the "Content-Encoding" attribute is
              used. If the file is not content encoded before transport (and
              thus the "Content-Encoding" attribute is not used), then the
              transfer length is the length of the original file, and in this
              case the "Content-Length" is also the transfer length. However,
              if the file is content encoded before transport (and thus the
              "Content-Encoding" attribute is used), e.g., if compression is
              applied before transport to reduce the number of octets that need
              to be transferred, then the transfer length is generally
              different than the length of the original file, and in this case
              the attribute "Transfer-Length" MAY be used to carry the
              transfer length.</t>

              <t hangText="*">Whenever content encoding is applied, the
              attribute "Content-Encoding" MUST be included. Whenever the
              attribute "Content-Encoding" is included, it MUST be used as
              described in <xref target="RFC2616"></xref>.</t>

              <t hangText="*">Where the MD5 message digest is described, the
              attribute "Content&nbhy;MD5" MUST be used for the purpose defined
              in <xref target="RFC2616"/>.
              Note that the goal is to provide a decoded object integrity
              service in cases where transmission and/or FLUTE/ALC processing
              errors may occur (the probability of collision is in that case
              negligible). It MUST NOT be regarded as a security mechanism
              (see <xref target="sec-cons"/> for information regarding
              security measures).</t>

              <t hangText="*">The FEC Object Transmission Information
              attributes are described in <xref target="deliv-fec-oti"/>.</t>

            </list></t>

          <t>The following specifies the XML Schema <xref
          target="XML-Schema-Part-1"></xref> <xref
          target="XML-Schema-Part-2"></xref> for the FDT Instance:</t>

          <figure anchor="fig-fdt-instance" title="XML Schema for the FDT Instance">
            <artwork><![CDATA[
BEGIN
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns="urn:ietf:params:xml:ns:fdt"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           targetNamespace="urn:ietf:params:xml:ns:fdt"
           elementFormDefault="qualified">
  <xs:element name="FDT-Instance" type="FDT-InstanceType"/>
  <xs:complexType name="FDT-InstanceType">
    <xs:sequence>
      <xs:element name="File" type="FileType" maxOccurs="unbounded"/>
      <xs:any namespace="##other" processContents="skip"
              minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="Expires"
                  type="xs:string"
                  use="required"/>
    <xs:attribute name="Complete"
                  type="xs:boolean"
                  use="optional"/>
    <xs:attribute name="Content-Type"
                  type="xs:string"
                  use="optional"/>
    <xs:attribute name="Content-Encoding"
                  type="xs:string"
                  use="optional"/>
    <xs:attribute name="FEC-OTI-FEC-Encoding-ID"
                  type="xs:unsignedByte"
                  use="optional"/>
    <xs:attribute name="FEC-OTI-FEC-Instance-ID"
                  type="xs:unsignedLong"
                  use="optional"/>
    <xs:attribute name="FEC-OTI-Maximum-Source-Block-Length"
                  type="xs:unsignedLong"
                  use="optional"/>
    <xs:attribute name="FEC-OTI-Encoding-Symbol-Length"
                  type="xs:unsignedLong"
                  use="optional"/>
    <xs:attribute name="FEC-OTI-Max-Number-of-Encoding-Symbols"
                  type="xs:unsignedLong"
                  use="optional"/>
    <xs:attribute name="FEC-OTI-Scheme-Specific-Info"
                  type="xs:base64Binary"
                  use="optional"/>
    <xs:anyAttribute processContents="skip"/>
  </xs:complexType>
  <xs:complexType name="FileType">
    <xs:sequence>
      <xs:any namespace="##other" processContents="skip"
              minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="Content-Location"
                  type="xs:anyURI"
                  use="required"/>
    <xs:attribute name="TOI"
                  type="xs:positiveInteger"
                  use="required"/>
    <xs:attribute name="Content-Length"
                  type="xs:unsignedLong"
                  use="optional"/>
    <xs:attribute name="Transfer-Length"
                  type="xs:unsignedLong"
                  use="optional"/>
    <xs:attribute name="Content-Type"
                  type="xs:string"
                  use="optional"/>
    <xs:attribute name="Content-Encoding"
                  type="xs:string"
                  use="optional"/>
    <xs:attribute name="Content-MD5"
                  type="xs:base64Binary"
                  use="optional"/>
    <xs:attribute name="FEC-OTI-FEC-Encoding-ID"
                  type="xs:unsignedByte"
                  use="optional"/>
    <xs:attribute name="FEC-OTI-FEC-Instance-ID"
                  type="xs:unsignedLong"
                  use="optional"/>
    <xs:attribute name="FEC-OTI-Maximum-Source-Block-Length"
                  type="xs:unsignedLong"
                  use="optional"/>
    <xs:attribute name="FEC-OTI-Encoding-Symbol-Length"
                  type="xs:unsignedLong"
                  use="optional"/>
    <xs:attribute name="FEC-OTI-Max-Number-of-Encoding-Symbols"
                  type="xs:unsignedLong"
                  use="optional"/>
    <xs:attribute name="FEC-OTI-Scheme-Specific-Info"
                  type="xs:base64Binary"
                  use="optional"/>
    <xs:anyAttribute processContents="skip"/>
  </xs:complexType>
</xs:schema>
END
          ]]></artwork>
          </figure>

          <t>Any valid FDT Instance MUST use the above XML Schema. This way, FDT
          provides extensibility to support private elements and private attributes
          within the file description entries. Those could be, for example,
          the attributes related to the delivery of the file (timing, packet
          transmission rate, etc.). Unsupported private elements and attributes
          SHOULD be silently ignored by a FLUTE receiver.</t>

          <t>In case the basic FDT XML Schema is extended in terms of new
          descriptors (attributes or elements), for descriptors applying to a
          single file, those MUST be placed within the element "File". For
          descriptors applying to all files described by the current FDT
          Instance, those MUST be placed within the element "FDT-Instance". It
          is RECOMMENDED that the new attributes applied in the FDT be in the
          format of message header fields and be either defined in the HTTP/1.1
          specification <xref target="RFC2616"></xref> or another well-known
          specification, or in an IANA registry <xref target="IANAheaderfields"/>.
          However, this specification doesn't prohibit the use of other 
          formats to allow private attributes to be used when interoperability
          is not a concern.
          </t>

        </section>

        <section anchor="fdt-encoding"
                 title="Content Encoding of FDT Instance">
          <t>The FDT Instance itself MAY be content encoded (e.g.,
          compressed). This specification defines the FDT Instance Content Encoding
          Header (EXT_CENC). EXT_CENC is a new fixed-length LCT Header
          Extension <xref target="RFC5651"/>. The Header Extension Type
          (HET) for the extension is 193. If the FDT Instance is content
          encoded, EXT_CENC MUST be used to signal the content encoding
          type. In that case, the EXT_CENC Header Extension MUST be used in all
          ALC packets carrying the same FDT Instance ID. Consequently, when the
          EXT_CENC header is used, it MUST be used together with a proper FDT
          Instance Header (EXT_FDT). Within a file delivery session, FDT
          Instances that are not content encoded and FDT Instances that are
          content encoded MAY both appear. If content encoding is not used for
          a given FDT Instance, EXT_CENC MUST NOT be used in any packet
          carrying the FDT Instance. The format of EXT_CENC is defined
          below:</t>

          <figure anchor="fig-ext-cenc" title="EXT_CENC Format">
            <artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   HET = 193   |     CENC      |          Reserved             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]></artwork>
          </figure>

          <t>Content Encoding Algorithm (CENC), 8 bits:</t>

          <t>This field signals the content encoding algorithm used in the FDT
          Instance payload. This subsection reserves the Content Encoding
          Algorithm values 0, 1, 2, and 3 for null, ZLIB <xref
          target="RFC1950"></xref>, DEFLATE <xref
          target="RFC1951"></xref>, and GZIP <xref
          target="RFC1952"></xref>, respectively.</t>

          <t>Reserved, 16 bits:</t>

          <t>This field MUST be set to all '0's. This field MUST be ignored
          on reception.</t>
        </section>
      </section>

      <section anchor="mix-session"
               title="Multiplexing of Files within a File Delivery Session">
        <t>The delivered files are carried as transmission objects (identified
        with TOIs) in the file delivery session. All these objects, including
        the FDT Instances, MAY be multiplexed in any order and in parallel
        with each other within a session; i.e., packets for one file may be
        interleaved with packets for other files or other FDT Instances within
        a session.</t>

        <t>Multiple FDT Instances MAY be delivered in a single session using
        TOI = 0. In this case, it is RECOMMENDED that the sending of a
        previous FDT Instance SHOULD end before the sending of the next FDT
        Instance starts. However, due to unexpected network conditions,
        packets for the FDT Instances might be interleaved. A receiver can
        determine which FDT Instance a packet contains information about, since
        the FDT Instances are uniquely identified by their FDT Instance ID
        carried in the EXT_FDT headers.</t>
      </section>
    </section>

    <section anchor="channels-cc-timing"
             title="Channels, Congestion Control, and Timing">
      <t>ALC/LCT has a concept of channels and congestion control. There are
      four scenarios in which FLUTE is envisioned to be applied. 
        <list style="format (%c)">
          <t>Use of a single channel and a single-rate congestion
          control protocol.</t>

          <t>Use of multiple channels and a multiple-rate
          congestion control protocol. In this case, the FDT Instances MAY be
          delivered on more than one channel.</t>

          <t>Use of a single channel without congestion control
          supplied by ALC, but only when in a controlled network environment
          where flow/congestion control is being provided by other means.</t>

          <t>Use of multiple channels without congestion control
          supplied by ALC, but only when in a controlled network environment
          where flow/congestion control is being provided by other means. In
          this case, the FDT Instances MAY be delivered on more than one
          channel.</t>
        </list></t>

      <t>When using just one channel for a file delivery session, as in (a)
      and (c), the notion of 'prior' and 'after' are intuitively defined for
      the delivery of objects with respect to their delivery times.</t>

      <t>However, if multiple channels are used, as in (b) and (d), it is not
      straightforward to state that an object was delivered 'prior' to the
      other. An object may begin to be delivered on one or more of those
      channels before the delivery of a second object begins. However, the use
      of multiple channels/layers may mean that the delivery of the second
      object is completed before the first. This is not a problem when objects are
      delivered sequentially using a single channel. Thus, if the application
      of FLUTE has a mandatory or critical requirement that the first
      transmission object must complete 'prior' to the second one, it is
      RECOMMENDED that only a single channel be used for the file delivery
      session.</t>

      <t>Furthermore, if multiple channels are used, then a receiver joined to
      the session at a low reception rate will only be joined to the lower
      layers of the session. Thus, since the reception of FDT Instances is of
      higher priority than the reception of files (because the reception of
      files depends on the reception of an FDT Instance describing it), the
      following are RECOMMENDED:
          <list style="numbers">
          <t>The layers to which packets for FDT Instances are
          sent SHOULD NOT be biased towards those layers to which lower-rate
          receivers are not joined. For example, it is okay to put all the
          packets for an FDT Instance into the lowest layer (if this layer
          carries enough packets to deliver the FDT to higher-rate receivers
          in a reasonable amount of time), but it is not okay to put all the
          packets for an FDT Instance into the higher layers that only
          higher-rate receivers will receive.</t>

          <t>If FDT Instances are generally longer than one
          Encoding Symbol in length and some packets for FDT Instances are
          sent to layers that lower-rate receivers do not receive, an FEC
          encoding other than Compact No-Code FEC Encoding ID 0 <xref
          target="RFC5445"></xref> SHOULD be used to deliver FDT
          Instances. This is because in this case, even when there is no
          packet loss in the network, a lower-rate receiver will not receive
          all packets sent for an FDT Instance.</t>
        </list></t>
    </section>

    <section anchor="deliv-fec-oti"
             title="Delivering FEC Object Transmission Information">
      <t>FLUTE inherits the use of the FEC building block <xref
      target="RFC5052"></xref> from ALC. When using FLUTE for file delivery
      over ALC, the FEC Object Transmission Information MUST be delivered
      in-band within the file delivery session. There are two methods to
      achieve this: the use of the ALC-specific LCT Header Extension EXT_FTI <xref
      target="RFC5775"></xref> and the use of the FDT. The latter method is
      specified in this section. The use of EXT_FTI requires repetition of the
      FEC Object Transmission Information to ensure reception (though not
      necessarily in every packet) and thus may entail higher overhead than
      the use of the FDT, but may also provide more timely delivery of the FEC
      Object Transmission Information.</t>

      <t>The receiver of a file delivery session MUST support delivery of FEC
      Object Transmission Information using EXT_FTI for the FDT Instances
      carried using TOI value 0. For the TOI values other than 0, the receiver
      MUST support both methods: the use of EXT_FTI and the use of the FDT.</t>

      <t>The FEC Object Transmission Information that needs to be delivered to
      receivers MUST be exactly the same whether it is delivered using EXT_FTI
      or using the FDT (or both). The FEC Object Transmission Information that
      MUST be delivered to receivers is defined by the FEC Scheme. This
      section describes the delivery using the FDT.</t>

      <t>The FEC Object Transmission Information regarding a given TOI may be
      available from several sources. In this case, it is RECOMMENDED that the
      receiver of the file delivery session prioritize the sources in the
      following way (in order of decreasing priority).
          <list style="numbers">
          <t>FEC Object Transmission Information that is
          available in EXT_FTI.</t>

          <t>FEC Object Transmission Information that is
          available in the FDT.</t>
        </list></t>

      <t>The FDT delivers FEC Object Transmission Information for each file
      using an appropriate attribute within the "FDT-Instance" or the "File"
      element of the FDT structure. <list style="hanging">
          <t hangText="*">"Transfer-Length" carries the "Transfer-Length"
          Object Transmission Information element defined in <xref
          target="RFC5052"></xref>.</t>

          <t hangText="*">"FEC-OTI-FEC-Encoding-ID" carries the "FEC Encoding
          ID" Object Transmission Information element defined in <xref
          target="RFC5052"></xref>, as carried in the Codepoint field of the
          ALC/LCT header.</t>

          <t hangText="*">"FEC-OTI-FEC-Instance-ID" carries the "FEC Instance
          ID" Object Transmission Information element defined in <xref
          target="RFC5052"></xref> for Under-Specified FEC Schemes.</t>

          <t hangText="*">"FEC-OTI-Maximum-Source-Block-Length" carries the
          "Maximum-Source-Block-Length" Object Transmission Information
          element defined in <xref target="RFC5052"></xref>, if required by
          the FEC Scheme.</t>

          <t hangText="*">"FEC-OTI-Encoding-Symbol-Length" carries the
          "Encoding-Symbol-Length" Object Transmission Information element
          defined in <xref target="RFC5052"></xref>, if required by the FEC
          Scheme.</t>

          <t hangText="*">"FEC-OTI-Max-Number-of-Encoding-Symbols" carries the
          "Max-Number-of-Encoding-Symbols" Object Transmission Information
          element defined in <xref target="RFC5052"></xref>, if required by
          the FEC Scheme.</t>

          <t hangText="*">"FEC-OTI-Scheme-Specific-Info" carries the
          "encoded Scheme-specific FEC Object Transmission Information" as
          defined in <xref target="RFC5052"></xref>, if required by the FEC
          Scheme.</t>
        </list></t>

      <t>In FLUTE, the FEC Encoding ID (8 bits) for a given TOI MUST be
      carried in the Codepoint field of the ALC/LCT header. When the FEC
      Object Transmission Information for this TOI is delivered through the
      FDT, then the associated "FEC-OTI-FEC-Encoding-ID" attribute and the
      Codepoint field of all packets for this TOI MUST be the same.</t>
    </section>

    <section anchor="desc-file-delivery-session"
             title="Describing File Delivery Sessions">
      <t>To start receiving a file delivery session, the receiver needs to
      know transport parameters associated with the session. Interpreting
      these parameters and starting the reception therefore represent the
      entry point from which thereafter the receiver operation falls into the
      scope of this specification. According to <xref
      target="RFC5775"></xref>, the transport parameters of an ALC/LCT
      session that the receiver needs to know are: <list style="hanging">
          <t hangText="*">The source IP address;</t>

          <t hangText="*">The number of channels in the session;</t>

          <t hangText="*">The destination IP address and port number for each
          channel in the session;</t>

          <t hangText="*">The Transport Session Identifier (TSI) of the
          session;</t>

          <t hangText="*">An indication that the session is a FLUTE session.
          The need to demultiplex objects upon reception is implicit in any
          use of FLUTE, and this fulfills the ALC requirement of an indication
          of whether or not a session carries packets for more than one object
          (all FLUTE sessions carry packets for more than one object).</t>
        </list></t>

      <t>Optionally, the following parameters MAY be associated with the
      session (note that the list is not exhaustive): <list style="hanging">
          <t hangText="*">The start time and end time of the session;</t>

          <t hangText="*">FEC Encoding ID and FEC Instance ID when the default
          FEC Encoding ID 0 is not used for the delivery of the FDT;</t>

          <t hangText="*">Content encoding format if optional content encoding
          of the FDT Instance is used, e.g., compression;</t>

          <t hangText="*">Some information that tells receiver, in the first
          place, that the session contains files that are of interest;</t>

          <t hangText="*">Definition and configuration of a congestion control
          mechanism for the session;</t>

          <t hangText="*">Security parameters relevant for the session;</t>

          <t hangText="*">FLUTE version number.</t>
        </list></t>

      <t>It is envisioned that these parameters would be described according
      to some session description syntax (such as SDP <xref
      target="RFC4566"></xref> or XML based) and held in a file that would be
      acquired by the receiver before the FLUTE session begins by means of
      some transport protocol (such as the Session Announcement Protocol
      (SAP) <xref target="RFC2974"></xref>, email,
      HTTP <xref target="RFC2616"></xref>,
      SIP <xref target="RFC3261"></xref>, manual preconfiguration, etc.).
      However, the way in which the receiver discovers the above-mentioned
      parameters is out of scope of this document, as it is for LCT and ALC.
      In particular, this specification does not mandate or exclude any
      mechanism.</t>
    </section>

    <section anchor="sec-cons" title="Security Considerations">
      <section anchor="sec-problem-statement" title="Problem Statement">
        <t>A content delivery system is potentially subject to attacks.
        Attacks may target: <list style="hanging">
            <t hangText="*">the network (to compromise the routing
            infrastructure, e.g., by creating congestion),</t>

            <t hangText="*">the Content Delivery Protocol (CDP) (e.g., to
            compromise the normal behavior of FLUTE), or</t>

            <t hangText="*">the content itself (e.g., to corrupt the files
            being transmitted).</t>
          </list> These attacks can be launched either: <list style="hanging">
            <t hangText="*">against the data flow itself (e.g., by sending
            forged packets),</t>

            <t hangText="*">against the session control parameters (e.g., by
            corrupting the session description, the FDT Instances, or the
            ALC/LCT control parameters) that are sent either in-band or
            out-of-band, or</t>

            <t hangText="*">against some associated building blocks (e.g., the
            congestion control component).</t>
          </list> In the following sections, we provide more details on these
        possible attacks and sketch some possible countermeasures. We provide
        recommendations in <xref target="min-sec-recommendations"></xref>.</t>
      </section>

      <section anchor="sec-attacks-data-flow"
               title="Attacks against the Data Flow">
        <t>Let us consider attacks against the data flow first. At the least,
        the following types of attacks exist: <list style="hanging">
            <t hangText="*">attacks that are meant to give access to a
            confidential file (e.g., in the case of non-free content) and</t>

            <t hangText="*">attacks that try to corrupt the file being
            transmitted (e.g., to inject malicious code within a file, or to
            prevent a receiver from using a file, which is a kind of
            denial of service (DoS)).</t>
          </list></t>

        <section anchor="sec-access-confidential-files"
                 title="Access to Confidential Files">
          <t>Access control to the file being transmitted is typically
          provided by means of encryption. This encryption can be done over
          the whole file, i.e., before applying FEC protection (e.g., by the
          content provider, before submitting the file to FLUTE), or can be
          done on a packet-by-packet basis (e.g., when IPsec/ESP <xref target="RFC4303"></xref> is used;
          see <xref target="min-sec-recommendations"></xref>). If
          confidentiality is a concern, it is RECOMMENDED that one of these
          solutions be used.</t>
        </section>

        <section anchor="sec-file-corruption" title="File Corruption">
          <t>Protection against corruptions (e.g., if an attacker sends forged
          packets) is achieved by means of a content integrity
          verification/sender authentication scheme. This service can be
          provided at the file level, i.e., before applying content encoding
          and FEC encoding. In that case, a receiver has no
          way to identify which symbol(s) is(are) corrupted if the file is
          detected as corrupted. This service can also be provided at the
          packet level, i.e., after applying content encoding and FEC
          encoding, on a packet-by-packet basis. In this case,
          after removing all corrupted packets, the file may be in some cases
          recovered from the remaining correct packets.</t>

          <t>Integrity protection applied at the file level has the advantage
          of lower overhead, since only relatively few bits are added to
          provide the integrity protection compared to the file size. However,
          it has the disadvantage that it cannot distinguish between correct
          packets and corrupt packets, and therefore correct packets, which may
          form the majority of packets received, may be unusable. Integrity
          protection applied at the packet level has the advantage that it can
          distinguish between correct and corrupt packets, at the cost of
          additional per-packet overhead.</t>

          <t>Several techniques can provide this source authentication/content
          integrity service: <list style="hanging">
              <t hangText="*">At the file level, the file MAY be digitally
              signed (e.g., by using RSA Probabilistic Signature
              Scheme Public-Key Cryptography Standards version 1.5
              (RSASSA-PKCS1-v1_5) <xref target="RFC3447"></xref>). This
              signature enables a receiver to
              check the file's integrity once the file has been fully
              decoded. Even if digital signatures are computationally
              expensive, this calculation occurs only once per file, which is
              usually acceptable.</t>

              <t hangText="*">At the packet level, each packet can be
              digitally signed <xref target="RFC6584"></xref>. A major
              limitation is the high computational and transmission overheads
              that this solution requires. To avoid this problem, the
              signature may span a set of symbols (instead of a single one) in
              order to amortize the signature calculation, but if a single
              symbol is missing, the integrity of the whole set cannot be
              checked.</t>

              <t hangText="*">At the packet level, a Group-Keyed Message
              Authentication Code (MAC) <xref target="RFC2104"></xref>
              <xref target="RFC6584"></xref> scheme can be used; an example
              is using HMAC-SHA-256 with a secret key shared by all
              the group members, senders, and receivers. This technique creates
              a cryptographically secured digest of a packet that is sent
              along with the packet. The Group-Keyed MAC scheme does not create
              prohibitive processing load or transmission overhead, but it
              has a major limitation: it only provides a group
              authentication/integrity service, since all group members share
              the same secret group key, which means that each member can send
              a forged packet. It is therefore restricted to situations where
              group members are fully trusted (or in association with another
              technique as a pre-check).</t>

              <t hangText="*">At the packet level, Timed Efficient Stream
              Loss-Tolerant Authentication (TESLA) <xref
              target="RFC4082"></xref> <xref target="RFC5776"></xref> is an
              attractive solution that is robust to losses, provides a true
              authentication/integrity service, and does not create any
              prohibitive processing load or transmission overhead. However,
              checking a packet requires a small delay (a second or more)
              after its reception.</t>

              <t hangText="*">At the packet level, IPsec/ESP <xref
              target="RFC4303"></xref> can be used to check the integrity and
              authenticate the sender of all the packets being exchanged in a
              session (see <xref
              target="min-sec-recommendations"></xref>).</t>
            </list> Techniques relying on public key cryptography (digital
          signatures and TESLA during the bootstrap process, when used)
          require that public keys be securely associated to the entities.
          This can be achieved by a Public Key Infrastructure (PKI), or by a
          Pretty Good Privacy (PGP) Web of Trust, or by pre-distributing the
          public keys of each group member.</t>

          <t>Techniques relying on symmetric key cryptography (Group-Keyed MAC)
          require that a secret key be shared by all group members. This can
          be achieved by means of a group key management protocol, or simply
          by pre-distributing the secret key (but this manual solution has
          many limitations).</t>

          <t>It is up to the developer and deployer, who know the security
          requirements and features of the target application area, to define
          which solution is the most appropriate. Nonetheless, in case there
          is any concern of the threat of file corruption, it is RECOMMENDED
          that at least one of these techniques be used.</t>
        </section>
      </section>

      <section anchor="sec-attacks-sessions"
               title="Attacks against the Session Control Parameters and
               Associated Building Blocks">
        <t>Let us now consider attacks against the session control parameters
        and the associated building blocks. The attacker has at least the
        following opportunities to launch an attack: <list style="hanging">
            <t hangText="*">the attack can target the session description,</t>

            <t hangText="*">the attack can target the FDT Instances,</t>

            <t hangText="*">the attack can target the ALC/LCT parameters,
            carried within the LCT header, or</t>

            <t hangText="*">the attack can target the FLUTE associated
            building blocks (e.g., the multiple-rate congestion
            control protocol).</t>
          </list> The consequences of these attacks are potentially serious,
        since they might compromise the behavior of the content delivery system
        itself.</t>

        <section anchor="sec-attacks-sdp"
                 title="Attacks against the Session Description">
          <t>A FLUTE receiver may potentially obtain an incorrect session
          description for the session. The consequence of this is that
          legitimate receivers with the wrong session description are unable
          to correctly receive the session content, or that receivers
          inadvertently try to receive at a much higher rate than they are
          capable of, thereby possibly disrupting other traffic in the
          network.</t>

          <t>To avoid these problems, it is RECOMMENDED that measures be taken
          to prevent receivers from accepting incorrect session descriptions.
          One such measure is source authentication to ensure that receivers
          only accept legitimate session descriptions from authorized senders.
          How these measures are achieved is outside the scope of this
          document, since this session description is usually carried
          out-of-band.</t>
        </section>

        <section anchor="sec-attacks-fdt"
                 title="Attacks against the FDT Instances">
          <t>Corrupting the FDT Instances is one way to create a
          DoS attack. For example, the attacker changes the
          MD5 sum associated to a file. This possibly leads a receiver to
          reject the files received, no matter whether the files have been
          correctly received or not.</t>

          <t>Corrupting the FDT Instances is also a way to make the reception
          process more costly than it should be. This can be achieved by
          changing the FEC Object Transmission Information when the FEC Object
          Transmission Information is included in the FDT Instance. For
          example, an attacker may corrupt the FDT Instance in such a way that
          Reed-Solomon over GF(2^^16) would be used instead of GF(2^^8)
          with FEC Encoding ID 2. This may significantly increase the
          processing load while compromising FEC decoding.</t>

          <t>More generally, because FDT Instance data is structured using the XML
          language by means of an XML media type, many of the security considerations
          described in <xref target="RFC3023"/> and <xref target="RFC3470"/>
          also apply to such data.</t>

          <t>It is therefore RECOMMENDED that measures be taken to guarantee
          the integrity and to check the sender's identity of the FDT
          Instances. To that purpose, one of the countermeasures mentioned
          above (<xref target="sec-file-corruption"></xref>) SHOULD be used.
          These measures will either be applied on a packet level or globally
          over the whole FDT Instance object. Additionally, XML digital
          signatures <xref target="RFC3275"></xref> are a way to protect the
          FDT Instance by digitally signing it. When there is no packet-level
          integrity verification scheme, it is RECOMMENDED to rely on
          XML digital signatures of the FDT Instances.</t>
        </section>

        <section anchor="sec-attacks-alc"
                 title="Attacks against the ALC/LCT Parameters">
          <t>By corrupting the ALC/LCT header (or header extensions), one can
          execute attacks on the underlying ALC/LCT implementation. For
          example, sending forged ALC packets with the Close Session flag (A)
          set to one can lead the receiver to prematurely close the session.
          Similarly, sending forged ALC packets with the Close Object flag (B)
          set to one can lead the receiver to prematurely give up the
          reception of an object.</t>

          <t>It is therefore RECOMMENDED that measures be taken to guarantee
          the integrity and to check the sender's identity of the ALC packets
          received. To that purpose, one of the countermeasures mentioned
          above (<xref target="sec-file-corruption"></xref>) SHOULD be
          used.</t>
        </section>

        <section anchor="sec-attacks-bb"
                 title="Attacks against the Associated Building Blocks">
          <t>Let us first focus on the congestion control building block,
          which may be used in the ALC session. A receiver with an incorrect or
          corrupted implementation of the multiple-rate congestion control
          building block may affect the health of the network in the path
          between the sender and the receiver. That may also affect the
          reception rates of other receivers who joined the session.</t>

          <t>When the congestion control building block is applied with FLUTE,
          it is RECOMMENDED that receivers be required to identify
          themselves as legitimate before they receive the session description
          needed to join the session. How receivers identify themselves as
          legitimate is outside the scope of this document. If authenticating
          a receiver does not prevent this receiver from launching an attack,
          this authentication will enable the network operator to identify him
          and to take countermeasures.</t>

          <t>When the congestion control building block is applied with FLUTE,
          it is also RECOMMENDED that a packet-level authentication scheme be
          used, as explained in <xref target="sec-file-corruption"></xref>.
          Some of them, like TESLA, only provide a delayed authentication
          service, whereas congestion control requires a rapid reaction. It is
          therefore RECOMMENDED <xref target="RFC5775"></xref> that a
          receiver using TESLA quickly reduce its subscription level when the
          receiver believes that congestion did occur, even if the packet
          has not yet been authenticated. Therefore, TESLA will not prevent DoS
          attacks where an attacker makes the receiver believe that
          congestion occurred. This is an issue for the receiver, but this
          will not compromise the network. Other authentication methods that
          do not feature this delayed authentication could be preferred, or a
          Group-Keyed MAC scheme could be used in parallel with TESLA to
          prevent attacks launched from outside of the group.</t>
        </section>
      </section>

      <section anchor="other-sec-considerations"
               title="Other Security Considerations">
        <t>The security considerations that apply to, and are described in,
        ALC <xref target="RFC5775"></xref>, LCT <xref target="RFC5651"/>,
        and FEC <xref target="RFC5052"></xref> also apply to FLUTE, as FLUTE
        builds on those specifications. In addition, any security
        considerations that apply to any congestion control building block
        used in conjunction with FLUTE also apply to FLUTE.</t>

        <t>Even if FLUTE defines a purely unidirectional delivery service, without
        any feedback information that would be sent to the sender, security
        considerations MAY require bidirectional communications.
        For instance, if an automated key management scheme is used, a
        bidirectional point-to-point channel is often needed to establish
        a shared secret between each receiver and the sender. Each shared secret
        can then be used to distribute additional keys to the associated receiver
        (e.g., traffic encryption keys).</t>

        <t>As an example, <xref target="MBMSsecurity"></xref> details a
        complete security framework for the Third Generation Partnership
        Project (3GPP) Multimedia Broadcast/Multicast
        Service (MBMS) that relies on FLUTE/ALC for Download Sessions.
        It relies on bidirectional point-to-point communications for User
        Equipment authentication and for key distribution, using the
        Multimedia Internet KEYing (MIKEY) protocol <xref target="RFC3830"/>.
        Because this security framework is specific to this use case, it cannot
        be reused as such for generic security recommendations in this
        specification. Instead, the following section introduces minimum
        security recommendations.</t>

      </section>

      <section anchor="min-sec-recommendations"
               title="Minimum Security Recommendations">
        <t>We now introduce a mandatory-to-implement, but not necessarily to
        use, security configuration, in the sense of <xref
        target="RFC3365"></xref>. Since FLUTE relies on ALC/LCT, it inherits
        the "baseline secure ALC operation" of <xref
        target="RFC5775"></xref>. More precisely, security is achieved
        by means of IPsec/ESP in transport mode. <xref
        target="RFC4303"></xref> explains that ESP can be used to potentially
        provide confidentiality, data origin authentication, content
        integrity, anti-replay, and (limited) traffic flow confidentiality.
        <xref target="RFC5775"></xref> specifies that the data origin
        authentication, content integrity, and anti-replay services SHALL be
        supported, and that the confidentiality service is RECOMMENDED. If a
        short-lived session MAY rely on manual keying, it is also RECOMMENDED
        that an automated key management scheme be used, especially in the
        case of long-lived sessions.</t>

        <t>Therefore, the RECOMMENDED solution for FLUTE provides per-packet
        security, with data origin authentication, integrity verification, and
        anti-replay. This is sufficient to prevent most of the in-band attacks
        listed above. If confidentiality is required, a per-packet encryption
        SHOULD also be used.</t>
      </section>
    </section>

    <section anchor="iana-cons" title="IANA Considerations">

      <t>This specification contains five separate items upon which IANA has
taken action:
          <list style="numbers">
          <t>Registration of the FDT Instance XML Namespace.</t>

          <t>Registration of the FDT Instance XML Schema.</t>

          <t>Registration of the application/fdt+xml Media Type.</t>

          <t>Registration of the Content Encoding Algorithms.</t>

          <t>Registration of two LCT Header Extension Types
             (EXT_FDT and EXT_CENC).</t>
        </list></t>

      <section anchor="reg-fdt-ns"
               title="Registration of the FDT Instance XML Namespace">

        <t>IANA has registered the following new XML Namespace in the IETF XML "ns" registry <xref target="RFC3688"/> at
http://www.iana.org/assignments/xml-registry/ns.html.</t>

        <t>URI: urn:ietf:params:xml:ns:fdt</t>

        <t>Registrant Contact: Toni Paila (toni.paila@gmail.com)</t>

        <t>XML: N/A</t>
      </section>

      <section anchor="reg-fdt-schema"
               title="Registration of the FDT Instance XML Schema">

        <t>IANA has registered the following in the IETF
        XML "schema" registry <xref target="RFC3688"/> at
http://www.iana.org/assignments/xml-registry/schema.html. </t>

        <t>URI: urn:ietf:params:xml:schema:fdt</t>

        <t>Registrant Contact: Toni Paila (toni.paila@gmail.com)</t>

        <t>XML: The XML Schema specified in <xref target="fdt-syntax"></xref></t>
      </section>

      <section anchor="reg-fdt-mime"
               title="Registration of the application/fdt+xml Media Type">

        <t>IANA has registered the following in the "Application Media Types"
registry at
http://www.iana.org/assignments/media-types/application/.</t>

        <t>Type name: application</t>

        <t>Subtype name: fdt+xml</t>

        <t>Required parameters: none</t>

        <t>Optional parameters: charset="utf-8"
        <!--Indeed, the fdt+xml type consists of UTF-8 ASCII characters
        <xref target="RFC3629"/> and must be well-formed XML.-->
        </t>

        <t>Encoding considerations: binary
        (the FLUTE file delivery protocol does not impose any restriction
        on the objects it carries and in particular on the FDT Instance itself)</t>

        <!--
        <t>Additional content and transfer encodings may be used with fdt+xml
        files, with the appropriate encoding for any specific file being
        entirely dependent upon the deployed application.</t>-->

        <t>Restrictions on usage: none
        <!--Only for usage with FDT Instances which are
        valid according to the XML schema of section 3.4.2.-->
        </t>

        <t>Security considerations: fdt+xml data is passive and does not
        generally represent a unique or new security threat. However, there is
        some risk in sharing any kind of data, in that unintentional
        information may be exposed, and that risk applies to fdt+xml data as
        well.</t>

        <t>Interoperability considerations: None</t>

        <t>Published specification: [RFC6726], especially noting
        <xref target="fdt-syntax"/>. The specified FDT Instance functions
        as an actual media format of use to the general Internet community,
        and thus media type
        registration under the Standards Tree is appropriate to maximize
        interoperability.</t>

        <t>Applications that use this media type:
        file and object delivery applications and protocols (e.g., FLUTE).
        </t>

        <t>Additional information:</t>

        <figure>
          <artwork><![CDATA[
    Magic number(s): none
    File extension(s): ".fdt" (e.g., if there is a need to store an
                       FDT Instance as a file)
    Macintosh File Type Code(s): none
            ]]></artwork>
        </figure>

        <t>Person and email address to contact for further information:
        Toni&nbsp;Paila (toni.paila@gmail.com)</t>

        <t>Intended usage: Common</t>

        <t>Author/Change controller: IETF</t>
      </section>

      <section anchor="reg-ext-cenc"
               title="Creation of the FLUTE Content Encoding Algorithms Registry">

        <t>IANA has created a new registry, "FLUTE Content Encoding Algorithms",
        with a reference to [RFC6726]; see <xref target="fdt-encoding"/>.
        The registry
        entries consist of a numeric value from 0 to 255, inclusive,
        and may be registered using the Specification Required policy
        <xref target="RFC5226"/>.</t>

        <t>The initial contents of the registry are as follows, with
        unspecified values available for new registrations:</t>

<texttable>
  <ttcol align="center">Value</ttcol>
  <ttcol align="center">Algorithm Name</ttcol>
  <ttcol align="center">Reference</ttcol>

        <c>
0
        </c>
        <c>
null
        </c>
        <c>
[RFC6726]
        </c>

        <c>
1
        </c>
        <c>
ZLIB
        </c>
        <c>
<xref target="RFC1950"/>
        </c>

        <c>
2
        </c>
        <c>
DEFLATE
        </c>
        <c>
<xref target="RFC1951"/>
        </c>

        <c>
3
        </c>
        <c>
GZIP
        </c>
        <c>
<xref target="RFC1952"/>
        </c>
</texttable>

      </section>

      <section anchor="reg-lct-hdr" title="Registration of LCT Header Extension Types">
        <t>IANA has registered two new entries in the "Layered Coding Transport
        (LCT) Header Extension Types" registry <xref target="RFC5651"/>,
        as follows:</t>

<texttable>
  <ttcol align="center">Number</ttcol>
  <ttcol align="center">Name</ttcol>
  <ttcol align="center">Reference</ttcol>

        <c>
192
        </c>
        <c>
EXT_FDT
        </c>
        <c>
[RFC6726] <xref target="ext-fdt"></xref>
        </c>

        <c>
193
        </c>
        <c>
EXT_CENC
        </c>
        <c>
[RFC6726] <xref target="fdt-encoding"></xref>
        </c>
</texttable>

      </section>
    </section>

    <section anchor="acknow" title="Acknowledgments">
      <t>The following persons have contributed to this specification: Brian
      Adamson, Mark Handley, Esa Jalonen, Roger Kermode, Juha-Pekka Luoma,
      Topi Pohjolainen, Lorenzo Vicisano, Mark Watson, David Harrington,
      Ben Campbell, Stephen Farrell, Robert Sparks, Ronald Bonica,
      Francis Dupont, Peter Saint-Andre, Don Gillies, and Barry Leiba.
      The authors would like to thank all the contributors for their valuable
      work in reviewing and providing feedback regarding this specification.
      </t>
    </section>

    <section anchor="contributors" title="Contributors">

<figure><artwork>
Jani Peltotalo
Tampere University of Technology
P.O. Box 553 (Korkeakoulunkatu 1)
Tampere FIN-33101
Finland
EMail: jani.peltotalo@tut.fi

Sami Peltotalo
Tampere University of Technology
P.O. Box 553 (Korkeakoulunkatu 1)
Tampere FIN-33101
Finland
EMail: sami.peltotalo@tut.fi

Magnus Westerlund
Ericsson Research
Ericsson AB
SE-164 80 Stockholm
Sweden
EMail: magnus.westerlund@ericsson.com

Thorsten Lohmar
Ericsson Research (EDD)
Ericsson Allee 1
52134 Herzogenrath
Germany
EMail: thorsten.lohmar@ericsson.com
</artwork></figure>
    </section>

    <section anchor="change-log" title="Change Log">
      <section title="RFC 3926 to This Document">

        <t>Incremented the FLUTE protocol version from 1 to 2, due to concerns
        about backwards compatibility. For instance, the LCT header changed
        between RFC 3451 and <xref target="RFC5651"/>.
        In RFC 3451, the T and R fields of the LCT header indicate the
        presence of Sender Current Time and Expected Residual Time,
        respectively.
        In <xref target="RFC5651"/>, these fields MUST be set to zero
        and MUST be ignored by receivers
        (instead, the EXT_TIME Header Extensions can convey this information
        if needed).
        Thus, <xref target="RFC5651"/> is not backwards compatible with
        RFC 3451, even though both use LCT version 1.
        FLUTE version 1 as specified in <xref target="RFC3926"/> MUST use
        RFC 3451.
        FLUTE version 2 as specified in this document MUST
        use <xref target="RFC5651"/>.
        Therefore, an implementation that relies on <xref target="RFC3926"/>
        and RFC 3451 will not be backwards compatible with FLUTE as specified
        in this document.</t>
        
        <t>Updated dependencies to other RFCs to revised versions; e.g.,
        changed ALC reference from RFC 3450 to <xref target="RFC5775"/>,
        changed LCT reference from RFC 3451 to <xref target="RFC5651"/>,
        etc.</t>
        
        <t>Added clarification for the use of FLUTE for unicast communications
        in <xref target="weaknesses"></xref>.</t>

        <t>Clarified how to reliably deliver the FDT in <xref
        target="fdt-dynamics"></xref> and the possibility of using
        out-of-band delivery of FDT information.</t>

        <t>Clarified how to address FDT Instance expiration time wraparound
        with the notion of the NTPv4 "epoch" in <xref
        target="fdt-dynamics"></xref>.</t>

        <t>Clarified what should be considered erroneous situations in
        <xref target="ext-fdt"></xref> (definition of FDT Instance ID). In
        particular, a receiver MUST be ready to handle FDT Instance ID
        wraparounds and missing FDT Instances.</t>

        <t>Updated <xref target="min-sec-recommendations"/> to define
        IPsec/ESP as a mandatory-to-implement security solution.</t>

        <t>Removed the 'Statement of Intent' from <xref target="intro"></xref>.
        The statement of intent was meant to clarify
        the "Experimental" status of <xref target="RFC3926"/>.
        It does not apply to this document.</t>

        <t>Added clarification of "XML-DSIG" near the end
        of <xref target="file-delivery"></xref>.</t>

        <t>In <xref target="fdt"></xref>, replaced "complete FDT"
        with text that is more descriptive.</t>

        <t>Clarified <xref target="overall-flute-packet"></xref> with
        regard to "Encoding Symbol(s) for FDT Instance".</t>

        <t>Clarified the text regarding FDT Instance ID wraparound at the
        end of <xref target="ext-fdt"></xref>.</t>

        <t>Clarified "complete FDT" in <xref target="fdt-syntax"></xref>.</t>

        <t>Added semantics for the case where two TOIs refer to the same
        Content-Location. It is now in line with the way that 3GPP and
        Digital Video Broadcasting (DVB) standards interpret this case.</t>

        <t>In <xref target="fdt-syntax"></xref>, the XML Schema of the FDT
        Instance was modified per advice from various sources.
        For example, extension by element was
        missing but is now supported. Also, the namespace definition was
        changed to URN format.</t>

        <t>Clarified FDT-schema extensibility at the end of <xref
        target="fdt-syntax"></xref>.</t>

        <t>The CENC value allocation has been added at the end of <xref
        target="fdt-encoding"></xref>.</t>

        <t><xref target="deliv-fec-oti"></xref> has been modified so that
        EXT_FTI and the FEC issues were replaced by a reference to the ALC
        specification <xref target="RFC5775"/>.</t>

        <t>Added a clarifying paragraph on the use of the Codepoint field
        at the end of <xref target="deliv-fec-oti"></xref>.</t>

        <t>Reworked <xref target="iana-cons"></xref> -- IANA Considerations;
        it now contains six IANA registration requests: 
        <list style="hanging">
            <t hangText="*">Registration of the FDT Instance XML Namespace.</t>

            <t hangText="*">Registration of the FDT Instance XML Schema.</t>

            <t hangText="*">Registration of the application/fdt+xml Media
            Type.</t>

            <t hangText="*">Registration of the Content Encoding Algorithms.
            </t>

            <t hangText="*">Registration of two LCT Header Extension Types and
            corresponding values in the LCT Header Extension Types Registry
            (192 for EXT_FDT and 193 for EXT_CENC).</t>

        </list></t>

        <t>Added <xref target="contributors"></xref> -- Contributors.</t>

        <t>Revised lists of both Normative and Informative references.</t>

        <t>Added a clarification that the receiver should ignore reserved
        bits of Header Extension type 193 upon reception.</t>

        <t>Elaborated on what kinds of networks cannot support FLUTE
        congestion control (<xref target="weaknesses"/>).</t>

        <t>In <xref target="fdt"></xref>, changed "several" 
        (meaning 3-n vs. "couple" = 2) to "multiple" (meaning 2-n).</t>

        <t>Moved the requirement in <xref target="fdt-dynamics"></xref> (to
        send FDT more reliably than files) to a bulleted RECOMMENDED
        requirement, making check-off easier for testers.</t>

        <t>In <xref target="fdt-dynamics"></xref>, sharpened the definition
        that future FDT file instances can "augment" (meaning enhance) rather 
        than "complement" (sometimes meaning negate, which is not allowed)
        the file parameters.</t>

        <t>Elaborated in Sections <xref target="fdt-dynamics" format="counter"></xref> and
        <xref target="channels-cc-timing" format="counter"></xref> that FEC Encoding ID = 0 
        is Compact No-Code FEC, so that the reader doesn't have to search 
        other RFCs to understand these protocol constants used by FLUTE.</t>

        <t>Required in <xref target="fdt-dynamics"></xref> that FLUTE receivers
        SHALL NOT attempt to decode FDTs if they do not understand the FEC 
        Encoding ID.</t>

        <t>Removed the restriction of <xref target="fdt-dynamics"></xref>, in
        bullet #4, that TOI = 0 for the FDT, to be consistent
        with <xref target="rcvr-op"/> step 6 and elsewhere.
        An FDT is signaled by an FDT Instance ID, NOT only by
        TOI&nbsp;= 0.</t>

        <t>Standardized on the term "expiration time", and avoided using the
        redundant and possibly confusing term "expiry time".</t>

        <t>To interwork with experimental FLUTE, stipulated
        in <xref target="file-delivery-session"></xref> that only 1
        instantiation of all 3 protocols -- FLUTE, ALC, and LCT -- can be
        associated with a session (source IP Address, TSI), and mentioned
        in <xref target="desc-file-delivery-session"></xref> that one may
        (optionally) derive the FLUTE version from the file delivery session
        description.</t>

        <t>Used a software writing tool to lower the reading grade level and
        simplify <xref target="file-delivery-session"></xref>.</t>

      </section>
    </section>
  </middle>

  <back>
<?rfc rfcedstyle="no"?>
    <references title="Normative References">
    <!-- ================================ -->

      &rfc2119;

      &rfc5775; <!-- ALC --> 

      &rfc5651; <!-- LCT -->

      &rfc5052; <!-- FEC BB -->

      &rfc5445; <!-- Basic FEC BB -->

<!-- NTPv4 -->
<reference anchor='RFC5905'>
<front>
<title>Network Time Protocol Version 4: Protocol and Algorithms Specification</title>
<author initials='D.' surname='Mills' fullname='D. Mills'>
<organization /></author>
<author initials='J.' surname='Martin' fullname='J. Martin' role="editor">
<organization /></author>
<author initials='J.' surname='Burbank' fullname='J. Burbank'>
<organization /></author>
<author initials='W.' surname='Kasch' fullname='W. Kasch'>
<organization /></author>
<date year='2010' month='June' />
</front>
<seriesInfo name='RFC' value='5905' />
</reference>

      <!-- obsoleted by RFC 5905
      <reference anchor="RFC.NTP">
        <front>
          <title>Network Time Protocol (Version 3), Specification,
          Implementation and Analysis</title>

          <author initials="D." surname="Mills">
            <organization></organization>
          </author>

          <date month="March" year="1992" />
        </front>

        <seriesInfo name="RFC" value="1305" />
      </reference>
      -->

      <reference anchor="RFC2616">
        <front>
          <title>Hypertext Transfer Protocol -- HTTP/1.1</title>

          <author initials="R." surname="Fielding">
            <organization></organization>
          </author>

          <author initials="J." surname="Gettys">
            <organization></organization>
          </author>

          <author initials="J." surname="Mogul">
            <organization></organization>
          </author>

          <author initials="H." surname="Frystyk">
            <organization></organization>
          </author>

          <author initials="L." surname="Masinter">
            <organization></organization>
          </author>

          <author initials="P." surname="Leach">
            <organization></organization>
          </author>

          <author initials="T." surname="Berners-Lee">
            <organization></organization>
          </author>

          <date month="June" year="1999" />
        </front>

        <seriesInfo name="RFC" value="2616" />
      </reference>

      <reference anchor="XML-Schema-Part-1" target="http://www.w3.org/TR/xmlschema-1/">
        <front>
          <title>XML Schema Part 1: Structures Second Edition</title>
          <author initials="H." surname="Thompson">
            <organization></organization>
          </author>
          <author initials="D." surname="Beech">
            <organization></organization>
          </author>
          <author initials="M." surname="Maloney">
            <organization></organization>
          </author>
          <author initials="N." surname="Mendelsohn">
            <organization></organization>
          </author>
          <date month="October" year="2004" />
        </front>
        <seriesInfo name="W3C" value="Recommendation" />
      </reference>

      <reference anchor="XML-Schema-Part-2" target="http://www.w3.org/TR/xmlschema-2/">
        <front>
          <title>XML Schema Part 2: Datatypes Second Edition</title>
          <author initials="P." surname="Biron">
            <organization></organization>
          </author>
          <author initials="A." surname="Malhotra">
            <organization></organization>
          </author>
          <date month="October" year="2004" />
        </front>
        <seriesInfo name="W3C" value="Recommendation" />
      </reference>

      <reference anchor="RFC3023">
        <front>
          <title>XML Media Types</title>

          <author fullname="M Murata" initials="M" surname="Murata">
            <organization></organization>
          </author>

          <author fullname="S St.Laurent" initials="S" surname="St. Laurent">
            <organization></organization>
          </author>

          <author fullname="D Kohn" initials="D" surname="Kohn">
            <organization></organization>
          </author>

          <date month="January" year="2001" />
        </front>

        <seriesInfo name="RFC" value="3023" />
      </reference>

      <reference anchor="RFC5226">
        <front>
          <title>Guidelines for Writing an IANA Considerations Section in
          RFCs</title>

          <author fullname="T Narten" initials="T" surname="Narten">
            <organization></organization>
          </author>

          <author fullname="H Alvestrand" initials="H" surname="Alvestrand">
            <organization></organization>
          </author>

          <date month="May" year="2008" />
        </front>

        <seriesInfo name="RFC" value="5226" />
      </reference>

      <reference anchor="RFC3738">
        <front>
          <title>Wave and Equation Based Rate Control (WEBRC) Building
          Block</title>

          <author fullname="M. Luby" initials="M." surname="Luby">
            <organization></organization>
          </author>

          <author fullname="V. Goyal" initials="V." surname="Goyal">
            <organization></organization>
          </author>
          <date month="April" year="2004"/>
        </front>
        <seriesInfo name="RFC" value="3738" />
<annotation>
Note: The RFC 3738 reference is to a target document of a lower maturity
level.  Some caution should be used, since it may be less stable
than the present document.
</annotation>

      </reference>

      <reference anchor="RFC4303">
        <front>
          <title>IP Encapsulating Security Payload (ESP)</title>
          <author fullname="S Kent" initials="S" surname="Kent">
            <organization></organization>
          </author>
          <date month="December" year="2005" />
        </front>
        <seriesInfo name="RFC" value="4303" />
      </reference>

    </references>

    <references title="Informative References">
    <!-- ================================== -->
      &rfc3926;

<reference anchor='RFC2357'>
<front>
<title abbrev='Evaluating Reliable Multicast'>IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols</title>
<author initials='A.' surname='Mankin' fullname='Allison Mankin'>
</author>
<author initials='A.' surname='Romanow' fullname='Allyn Romanow'>
</author>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
</author>
<author initials='V.' surname='Paxson' fullname='Vern Paxson'>
</author>
<date year='1998' month='June' />
</front>
<seriesInfo name='RFC' value='2357' />
</reference>

      &rfc3986;
      &rfc3470;
      &rfc2045;

      <reference anchor="RFC1950">
        <front>
          <title>ZLIB Compressed Data Format Specification version 3.3</title>

          <author initials="P." surname="Deutsch">
            <organization></organization>
          </author>

          <author initials="J-L." surname="Gailly">
            <organization></organization>
          </author>

          <date month="May" year="1996" />
        </front>

        <seriesInfo name="RFC" value="1950" />
      </reference>

      <reference anchor="RFC1951">
        <front>
          <title>DEFLATE Compressed Data Format Specification version
          1.3</title>

          <author initials="P." surname="Deutsch">
            <organization></organization>
          </author>

          <date month="May" year="1996" />
        </front>

        <seriesInfo name="RFC" value="1951" />
      </reference>

      <reference anchor="RFC1952">
        <front>
          <title>GZIP file format specification version 4.3</title>

          <author initials="P." surname="Deutsch">
            <organization></organization>
          </author>

          <date month="May" year="1996" />
        </front>

        <seriesInfo name="RFC" value="1952" />
      </reference>

      <reference anchor="IANAheaderfields" target="http://www.iana.org/protocols">
        <front>
          <title>Message Header Fields</title>
            <author><organization>IANA</organization></author>
        </front>
      </reference>

      <reference anchor="RFC2974">
        <front>
          <title>Session Announcement Protocol</title>

          <author initials="M." surname="Handley">
            <organization></organization>
          </author>

          <author initials="C." surname="Perkins">
            <organization></organization>
          </author>

          <author initials="E." surname="Whelan">
            <organization></organization>
          </author>

          <date month="October" year="2000" />
        </front>

        <seriesInfo name="RFC" value="2974" />
      </reference>

&rfc4566;

&rfc1112;

      <reference anchor="PAPER.SSM">
        <front>
          <title>A Channel Model for Multicast</title>
          <author initials="H.W." surname="Holbrook">
            <organization></organization>
          </author>
          <date month="August" year="2001" />
        </front>
       <seriesInfo name="Ph.D. Dissertation," value="Stanford University,
Department of Computer Science, Stanford, California"/>
      </reference>

      <!-- replaced by RFC 5905, which also obsoletes RFC1305
      <reference anchor="NTPv4">
        <front>
          <title>Network Time Protocol Version 4 Protocol And Algorithms
          Specification</title>

          <author fullname="William Kasch" initials="W" surname="Kasch">
            <organization></organization>
          </author>

          <author fullname="David Mills" initials="D" surname="Mills">
            <organization></organization>
          </author>

          <author fullname="Jack Burbank" initials="J" surname="Burbank">
            <organization></organization>
          </author>

          <date day="9" month="October" year="2009" />
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-ietf-ntp-ntpv4-proto-13 (work in progress)" />
      </reference>
      -->

      <reference anchor="RFC3365">
        <front>
          <title>Strong Security Requirements for Internet Engineering Task
          Force Standard Protocols</title>

          <author fullname="J. Schiller" initials="J." surname="Schiller">
            <organization></organization>
          </author>

          <date month="August" year="2002" />
        </front>

        <seriesInfo name="BCP" value="61" />

        <seriesInfo name="RFC" value="3365" />
      </reference>

      &rfc5751;

<reference anchor='RFC3275'>
<front>
<title>(Extensible Markup Language) XML-Signature Syntax and Processing</title>
<author initials='D.' surname='Eastlake 3rd' fullname='D. Eastlake'>
<organization /></author>
<author initials='J.' surname='Reagle' fullname='J. Reagle'>
<organization /></author>
<author initials='D.' surname='Solo' fullname='D. Solo'>
<organization /></author>
<date year='2002' month='March' />
</front>
<seriesInfo name='RFC' value='3275' />
</reference>

      &rfc3261;

      &rfc3688;

      &rfc3447;

      &rfc2104;

      &rfc4082;

      &rfc5776;

      &rfc6584;

      &rfc3830;

      <reference anchor="MBMSsecurity" target="http://www.3gpp.org/ftp/Specs/archive/33_series/33.246/">
        <front>
          <title>3rd Generation Partnership Project; Technical Specification Group Services and System Aspects; 3G Security; Security of Multimedia Broadcast/Multicast Service (MBMS) (Release 10)</title>
          <author fullname="3GPP" initials="" surname="">
            <organization>3GPP</organization>
          </author>
          <date month="December" year="2010" />
        </front>
      </reference>

    </references>
<?rfc rfcedstyle="yes"?>

    <section anchor="rcvr-op" title="Receiver Operation (Informative)">
      <t>This section gives an example of how the receiver of the file delivery
      session may operate. Instead of a detailed state-by-state specification,
      the following should be interpreted as a rough sequence of an envisioned
      file delivery receiver. <list style="format %d.">
          <t>The receiver obtains the description of the file delivery session
          identified by the (source IP address, Transport Session Identifier)
          pair. The receiver also obtains the destination IP addresses
          and respective ports associated with the file delivery session.</t>

          <t>The receiver joins the channels in order to receive packets
          associated with the file delivery session. The receiver may schedule
          this join operation utilizing the timing information contained in a
          possible description of the file delivery session.</t>

          <t>The receiver receives ALC/LCT packets associated with the file
          delivery session. The receiver checks that the packets match the
          declared Transport Session Identifier. If not, the packets are
          silently discarded.</t>

          <t>While receiving, the receiver demultiplexes packets based on
          their TOI and stores the relevant packet information in an
          appropriate area for recovery of the corresponding file. Multiple
          files can be reconstructed concurrently.</t>

          <t>The receiver recovers an object. An object can be recovered when
          an appropriate set of packets containing Encoding Symbols for the
          transmission object has been received. An appropriate set of
          packets is dependent on the properties of the FEC Encoding ID and
          FEC Instance ID, and on other information contained in the FEC
          Object Transmission Information.</t>

          <t>Objects with TOI = 0 are reserved for FDT Instances.  
          All FDT Instances are signaled by including an EXT_FDT 
          Header Extension in the LCT header. The  EXT_FDT header 
          contains an FDT Instance ID (i.e., an FDT version number).  
          If the object has an FDT Instance ID 'N', the receiver 
          parses the payload of the instance 'N' of the FDT and updates 
          its FDT database accordingly.</t>

          <t>If the object recovered is not an FDT Instance but a file, the
          receiver looks up its FDT database to get the properties described
          in the database, and assigns the file the given properties. The
          receiver also checks that the received content length matches with 
          the description in the database. Optionally, if an MD5 checksum has 
          been used, the receiver checks that the calculated MD5 matches the
          description in the FDT database.</t>

          <t>The actions the receiver takes with imperfectly received files
          (missing data, mismatching content integrity digest, etc.) are
          outside the scope of this specification. When a file is recovered
          before the associated file description entry is available, a
          possible behavior is to wait until an FDT Instance is received that
          includes the missing properties.</t>

          <t>If the file delivery session end time has not been reached, go
          back to step 3. Otherwise, end.</t>
        </list></t>
    </section>

    <section anchor="example-fdt-instance" title="Example of FDT Instance (Informative)">
      <figure>
        <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<FDT-Instance xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="urn:ietf:params:xml:ns:fdt
                      ietf-flute-fdt.xsd"
  Expires="2890842807">
  <File
    Content-Location="http://www.example.com/menu/tracklist.html"
    TOI="1"
    Content-Type="text/html"/>
  <File
    Content-Location="http://www.example.com/tracks/track1.mp3"
    TOI="2"
    Content-Length="6100"
    Content-Type="audio/mp3"
    Content-Encoding="gzip"
    Content-MD5="+VP5IrWploFkZWc11iLDdA=="
    Some-Private-Extension-Tag="abc123"/>
</FDT-Instance>
]]></artwork>
      </figure>
    </section>
  </back>
</rfc>
