<?xml version="1.0" encoding="us-ascii"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- Originally generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.9 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC4086 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4086.xml">
<!ENTITY RFC4648 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY RFC5234 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml">
<!ENTITY RFC6347 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6347.xml">
<!ENTITY RFC7049 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7049.xml">
<!ENTITY RFC7230 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml">
<!ENTITY RFC7231 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7231.xml">
<!ENTITY RFC7252 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7252.xml">
<!ENTITY RFC7641 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7641.xml">
<!ENTITY RFC7959 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7959.xml">
<!ENTITY RFC8075 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8075.xml">
<!ENTITY RFC8132 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8132.xml">
<!ENTITY RFC8152 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8152.xml">
<!ENTITY RFC8174 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml">
<!ENTITY RFC8288 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8288.xml">
<!ENTITY RFC8323 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8323.xml">
<!ENTITY RFC8446 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml">
<!ENTITY RFC3552 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC3986 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY RFC5116 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5116.xml">
<!ENTITY RFC5869 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5869.xml">
<!ENTITY RFC6690 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6690.xml">
<!ENTITY RFC7228 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7228.xml">
<!ENTITY RFC7515 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7515.xml">
<!ENTITY RFC7967 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7967.xml">
<!ENTITY RFC8610 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8610.xml">
<!ENTITY I-D.ietf-ace-oauth-authz SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-ace-oauth-authz.xml">
<!ENTITY I-D.bormann-6lo-coap-802-15-ie SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.bormann-6lo-coap-802-15-ie.xml">
<!ENTITY I-D.hartke-core-e2e-security-reqs SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.hartke-core-e2e-security-reqs.xml">
<!ENTITY I-D.mattsson-core-coap-actuators SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.mattsson-core-coap-actuators.xml">
<!ENTITY I-D.ietf-ace-oscore-profile SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-ace-oscore-profile.xml">
<!ENTITY I-D.ietf-core-oscore-groupcomm SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-core-oscore-groupcomm.xml">
<!ENTITY I-D.ietf-core-echo-request-tag SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-core-echo-request-tag.xml">
<!ENTITY I-D.mcgrew-iv-gen SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.mcgrew-iv-gen.xml">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc tocdepth="2"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc ipr="trust200902" number="8613" submissionType="IETF" category="std" consensus="yes" updates="7252">

  <front>
    <title abbrev="OSCORE">Object Security for Constrained RESTful Environments (OSCORE)</title>

    <author initials="G." surname="Selander" fullname="Goeran Selander">
      <organization>Ericsson AB</organization>
      <address>
        <email>goran.selander@ericsson.com</email>
      </address>
    </author>
    <author initials="J." surname="Mattsson" fullname="John Mattsson">
      <organization>Ericsson AB</organization>
      <address>
        <email>john.mattsson@ericsson.com</email>
      </address>
    </author>
    <author initials="F." surname="Palombini" fullname="Francesca Palombini">
      <organization>Ericsson AB</organization>
      <address>
        <email>francesca.palombini@ericsson.com</email>
      </address>
    </author>
    <author initials="L." surname="Seitz" fullname="Ludwig Seitz">
      <organization>RISE</organization>
      <address>
        <email>ludwig.seitz@ri.se</email>
      </address>
    </author>

    <date year="2019" month="July" />

    
    <workgroup>CoRE Working Group</workgroup>
    

    <abstract>


<t>This document defines Object Security for Constrained RESTful
Environments (OSCORE), a method for application-layer protection of
the Constrained Application Protocol (CoAP), using CBOR Object Signing
and Encryption (COSE). OSCORE provides end-to-end protection between
endpoints communicating using CoAP or CoAP-mappable HTTP. OSCORE is
designed for constrained nodes and networks supporting a range of
proxy operations, including translation between different transport
protocols.</t>

<t>Although an optional functionality of CoAP, OSCORE alters
CoAP options processing and IANA registration. Therefore, this
document updates RFC 7252.</t>



    </abstract>


  </front>

  <middle>


<section anchor="intro" title="Introduction">

<t>The Constrained Application Protocol (CoAP) <xref
target="RFC7252"/> is a web transfer protocol designed for
constrained nodes and networks <xref target="RFC7228"/>; CoAP may be
mapped from HTTP <xref target="RFC8075"/>. CoAP specifies the use of
proxies for scalability and efficiency and references DTLS <xref
target="RFC6347"/> for security. CoAP-to-CoAP, HTTP-to-CoAP, and
CoAP-to-HTTP proxies require DTLS or TLS <xref target="RFC8446"/> to
be terminated at the proxy. Therefore, the proxy not only has access to
the data required for performing the intended proxy functionality, but is also able to eavesdrop on, or manipulate any part of, the message
payload and metadata in transit between the endpoints. The proxy can
also inject, delete, or reorder packets since they are no longer
protected by (D)TLS.</t>


<t>This document defines the Object Security for Constrained RESTful
Environments (OSCORE) security protocol, protecting CoAP and
CoAP-mappable HTTP requests and responses end-to-end across
intermediary nodes such as CoAP forward proxies and cross-protocol
translators including HTTP-to-CoAP proxies <xref
target="RFC8075"/>. In addition to the core CoAP features defined in
<xref target="RFC7252"/>, OSCORE supports the Observe <xref
target="RFC7641"/>, Block-wise <xref target="RFC7959"/>, and
No-Response <xref target="RFC7967"/> options, as well as the PATCH and
FETCH methods <xref target="RFC8132"/>. An analysis of end-to-end
security for CoAP messages through some types of intermediary nodes is
performed in <xref target="CoAP-E2E-Sec"/>. OSCORE essentially
protects the RESTful interactions: the request method, the requested
resource, the message payload, etc. (see <xref
target="protected-fields"/>), where "RESTful" refers to the Representational 
State Transfer (REST) Architecture <xref target="REST"/>. 
OSCORE protects neither the CoAP
messaging layer nor the CoAP Token, which may change between the
endpoints; therefore, those are processed as defined in <xref
target="RFC7252"/>. Additionally, since the message formats for CoAP
over unreliable transport <xref target="RFC7252"/> and for CoAP over
reliable transport <xref target="RFC8323"/> differ only in terms of
CoAP messaging layer, OSCORE can be applied to both unreliable and
reliable transports (see <xref target="fig-stack"/>).</t>

<t>OSCORE works in very constrained nodes and networks, thanks to its small message size and the restricted code and memory requirements in addition to what is required by CoAP. Examples of the use of OSCORE are given in <xref target="examples"/>. OSCORE may be used over any underlying layer, such as UDP or TCP, and with non-IP transports (e.g., <xref target="CoAP-802.15.4"/>). OSCORE may also be used in different ways with HTTP. OSCORE messages may be transported in HTTP, and OSCORE may also be used to protect CoAP-mappable HTTP messages, as described below.</t>

<figure title="Abstract Layering of CoAP with OSCORE" anchor="fig-stack"><artwork align="center"><![CDATA[
+-----------------------------------+
|            Application            |
+-----------------------------------+
+-----------------------------------+  \
|  Requests / Responses / Signaling |  |
|-----------------------------------|  |
|               OSCORE              |  | CoAP
|-----------------------------------|  |
| Messaging Layer / Message Framing |  |
+-----------------------------------+  /
+-----------------------------------+
|          UDP / TCP / ...          |
+-----------------------------------+  
]]></artwork></figure>

<t>OSCORE is designed to protect as much information as possible while
still allowing CoAP proxy operations (<xref
target="coap-coap-proxy"/>). It works with existing CoAP-to-CoAP
forward proxies <xref target="RFC7252"/>, but an OSCORE-aware proxy
will be more efficient. HTTP-to-CoAP proxies <xref target="RFC8075"/>
and CoAP-to-HTTP proxies can also be used with OSCORE, as specified in
<xref target="http-op"/>. OSCORE may be used together with TLS or DTLS
over one or more hops in the end-to-end path, e.g., transported with
HTTPS in one hop and with plain CoAP in another hop. The use of OSCORE
does not affect the URI scheme; therefore, OSCORE can be used with any
URI scheme defined for CoAP or HTTP. The application decides the
conditions for which OSCORE is required.</t>

<t>OSCORE uses pre-shared keys that may have been established
out-of-band or with a key establishment protocol (see <xref
target="context-derivation"/>). The technical solution builds on CBOR
Object Signing and Encryption (COSE) <xref target="RFC8152"/>,
providing end-to-end encryption, integrity, replay protection, and
binding of response to request. A compressed version of COSE is used,
as specified in <xref target="compression"/>. The use of OSCORE is
signaled in CoAP with a new option (<xref target="option"/>), and in
HTTP with a new header field (<xref target="header-field"/>) and
content type (<xref target="oscore-media-type"/>). The solution
transforms a CoAP/HTTP message into an "OSCORE message" before
sending, and vice versa after receiving. The OSCORE message is a
CoAP/HTTP message related to the original message in the following
way: the original CoAP/HTTP message is translated to CoAP (if not
already in CoAP) and protected in a COSE object. The encrypted message
fields of this COSE object are transported in the CoAP payload/HTTP
body of the OSCORE message, and the OSCORE option/header field is
included in the message. A sketch of an exchange of OSCORE messages,
in the case of the original message being CoAP, is provided in <xref
target="fig-sketch"/>. The use of OSCORE with HTTP is detailed in
<xref target="http-op"/>.</t>

<figure title="Sketch of CoAP with OSCORE" anchor="fig-sketch"><artwork align="center"><![CDATA[
Client                                          Server
   |      OSCORE request - POST example.com:      |
   |        Header, Token,                        |
   |        Options: OSCORE, ...,                 |
   |        Payload: COSE ciphertext              |
   +--------------------------------------------->|
   |                                              |
   |<---------------------------------------------+
   |      OSCORE response - 2.04 (Changed):       |
   |        Header, Token,                        |
   |        Options: OSCORE, ...,                 |
   |        Payload: COSE ciphertext              |
   |                                              |
]]></artwork></figure>

<t>An implementation supporting this specification MAY implement only the client part, MAY implement only the server part, or MAY implement only one of the proxy parts.</t>

<section anchor="terminology" title="Terminology">

<t>
    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
    "MAY", and "OPTIONAL" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>


<t>Readers are expected to be familiar with the terms and concepts described in CoAP <xref target="RFC7252"/>, COSE <xref target="RFC8152"/>, Concise Binary Object Representation (CBOR) <xref target="RFC7049"/>, Concise Data Definition Language (CDDL) <xref target="RFC8610"/> as summarized in <xref target="cddl-sum"/>, and constrained environments <xref target="RFC7228"/>. Additional optional features include Observe <xref target="RFC7641"/>, Block-wise  <xref target="RFC7959"/>, No-Response <xref target="RFC7967"/> and CoAP over reliable transport <xref target="RFC8323"/>.</t>

<t>The term "hop" is used to denote a particular leg in the end-to-end path. The concept "hop-by-hop" (as in "hop-by-hop encryption" or "hop-by-hop fragmentation") opposed to "end-to-end", is used in this document to indicate that the messages are processed accordingly in the intermediaries, rather than just forwarded to the next node.</t>

<t>The term "stop processing" is used throughout the document to denote that the message is not passed up to the CoAP request/response layer (see <xref target="fig-stack"/>).</t>


<t>The terms Common Context, Sender Context, Recipient Context, Master Secret, Master Salt, Sender ID, Sender Key, Recipient ID, Recipient Key, ID Context, and Common IV are defined in <xref target="context-definition"/>.</t>

</section>
</section>
<section anchor="option" title="The OSCORE Option">


<t>The OSCORE option defined in this section (see <xref target="fig-option"/>, which extends &quot;Table 4: Options&quot; of <xref target="RFC7252"/>) indicates that the CoAP message is an OSCORE message and that it contains a compressed COSE object (see Sections <xref target="cose-object" format="counter"/> and <xref target="compression" format="counter"/>). The OSCORE option is critical, safe to forward, part of the cache key, and not repeatable.</t>

<figure title="The OSCORE Option" anchor="fig-option"><artwork align="center"><![CDATA[
+------+---+---+---+---+----------------+--------+--------+---------+
| No.  | C | U | N | R | Name           | Format | Length | Default |
+------+---+---+---+---+----------------+--------+--------+---------+
|   9  | x |   |   |   | OSCORE         |  (*)   | 0-255  | (none)  |
+------+---+---+---+---+----------------+--------+--------+---------+

    C = Critical,   U = Unsafe,   N = NoCacheKey,   R = Repeatable   
    (*) See below.
]]></artwork></figure>


<t>The OSCORE option includes the OSCORE flag bits (<xref
target="compression"/>), the Sender Sequence Number, the Sender ID,
and the ID Context when these fields are present (<xref
target="context"/>). The detailed format and length is specified in
<xref target="compression"/>. If the OSCORE flag bits are all zero
(0x00), the option value SHALL be empty (Option Length = 0). An
endpoint receiving a CoAP message without payload that also contains
an OSCORE option SHALL treat it as malformed and reject it.</t>

<t>A successful response to a request with the OSCORE option SHALL
contain the OSCORE option. Whether error responses contain the OSCORE
option depends on the error type (see <xref
target="processing"/>).</t>

<t>For CoAP proxy operations, see <xref
target="coap-coap-proxy"/>.</t>

</section>
<section anchor="context" title="The Security Context">

<t>OSCORE requires that client and server establish a shared security context used to process the COSE objects. OSCORE uses COSE with an Authenticated Encryption with Associated Data (AEAD, <xref target="RFC5116"/>) algorithm for protecting message data between a client and a server. In this section, we define the security context and how it is derived in client and server based on a shared secret and a key derivation function.</t>

<section anchor="context-definition" title="Security Context Definition">

<t>The security context is the set of information elements necessary to carry out the cryptographic operations in OSCORE. For each endpoint, the security context is composed of a "Common Context", a "Sender Context", and a "Recipient Context".</t>

<t>The endpoints protect messages to send using the Sender Context and verify messages received using the Recipient Context; both contexts being derived from the Common Context and other data. Clients and servers need to be able to retrieve the correct security context to use.</t>

<t>An endpoint uses its Sender ID (SID) to derive its Sender Context; the other endpoint uses the same ID, now called Recipient ID (RID), to derive its Recipient Context. In communication between two endpoints, the Sender Context of one endpoint matches the Recipient Context of the other endpoint, and vice versa. Thus, the two security contexts identified by the same IDs in the two endpoints are not the same, but they are partly mirrored. Retrieval and use of the security context are shown in <xref target="fig-context"/>.</t>


<figure title="Retrieval and Use of the Security Context" anchor="fig-context"><artwork align="center"><![CDATA[
          .---------------------.   .---------------------.
          |    Common Context   | = |    Common Context   |
          +---------------------+   +---------------------+        
          |    Sender Context   | = |  Recipient Context  |
          +---------------------+   +---------------------+ 
          |  Recipient Context  | = |    Sender Context   |
          '---------------------'   '---------------------'
                   Client                   Server
                      |                       |
Retrieve context for  | OSCORE request:       |
 target resource      |   Token = Token1,     |
Protect request with  |   kid = SID, ...      |
  Sender Context      +---------------------->| Retrieve context with
                      |                       |  RID = kid
                      |                       | Verify request with
                      |                       |  Recipient Context
                      | OSCORE response:      | Protect response with
                      |   Token = Token1, ... |  Sender Context
Retrieve context with |<----------------------+
 Token = Token1       |                       |
Verify request with   |                       |
 Recipient Context    |                       |
]]></artwork></figure>

<t>The Common Context contains the following parameters:</t>

<t><list style="symbols">
  <t>AEAD Algorithm. The COSE AEAD algorithm to use for encryption.</t>

  <t>HKDF Algorithm. An HMAC-based key derivation function (HKDF, <xref target="RFC5869"/>) used to derive the Sender Key, Recipient Key, and Common IV.</t>
  <t>Master Secret. Variable length, random byte string (see <xref target="master-secret"/>) used to derive AEAD keys and Common IV.</t>
  <t>Master Salt. Optional variable-length byte string containing the salt used to derive AEAD keys and Common IV.</t>
  <t>ID Context. Optional variable-length byte string providing additional information to identify the Common Context and to derive AEAD keys and Common IV. The use of ID Context is described in <xref target="context-hint"/>.</t>
  <t>Common IV. Byte string derived from the Master Secret, Master Salt, and ID Context. Used to generate the AEAD nonce (see <xref target="nonce"/>). Same length as the nonce of the AEAD Algorithm.</t>
</list></t>

<t>The Sender Context contains the following parameters:</t>


<t><list style="symbols">
  <t>Sender ID. Byte string used to identify the Sender Context, to derive AEAD keys and Common IV, and to contribute to the uniqueness of AEAD nonces. Maximum length is determined by the AEAD Algorithm.</t>
  <t>Sender Key. Byte string containing the symmetric AEAD key to protect messages to send. Derived from Common Context and Sender ID. Length is determined by the AEAD Algorithm.</t>
  <t>Sender Sequence Number. Non-negative integer used by the sender to enumerate requests and certain responses, e.g., Observe notifications. Used as "Partial IV" <xref target="RFC8152"/> to generate unique AEAD nonces. Maximum value is determined by the AEAD Algorithm. Initialization is described in <xref target="initial-replay"/>.</t>
</list></t>

<t>The Recipient Context contains the following parameters:</t>


<t><list style="symbols">
  <t>Recipient ID. Byte string used to identify the Recipient Context, to derive AEAD keys and Common IV, and to contribute to the uniqueness of AEAD nonces. Maximum length is determined by the AEAD Algorithm.</t>
  <t>Recipient Key. Byte string containing the symmetric AEAD key to verify messages received. Derived from Common Context and Recipient ID. Length is determined by the AEAD Algorithm.</t>
  <t>Replay Window (Server only). The replay window used to verify requests received. Replay protection is described in <xref target="replay-protection"/> and <xref target="initial-replay"/>.</t>
</list></t>

<t>All parameters except Sender Sequence Number and Replay Window are immutable once the security context is established. An endpoint may free up memory by not storing the Common IV, Sender Key, and Recipient Key, deriving them when needed. Alternatively, an endpoint may free up memory by not storing the Master Secret and Master Salt after the other parameters have been derived.</t>

<t>Endpoints MAY operate as both client and server and use the same security context for those roles. Independent of being client or server, the endpoint protects messages to send using its Sender Context, and verifies messages received using its Recipient Context. The endpoints MUST NOT change the Sender/Recipient ID when changing roles. In other words, changing the roles does not change the set of AEAD keys to be used.</t>

</section>
<section anchor="context-derivation" title="Establishment of Security Context Parameters">

<t>Each endpoint derives the parameters in the security context from a small set of input parameters. The following input parameters SHALL be preestablished:</t>

<t><list style="symbols">
  <t>Master Secret</t>
  <t>Sender ID</t>
  <t>Recipient ID</t>
</list></t>

<t>The following input parameters MAY be preestablished. In case any of these parameters is not preestablished, the default value indicated below is used:</t>

<t><list style="symbols">
  <t>AEAD Algorithm  <list style="symbols">
      <t>Default is AES-CCM-16-64-128 (COSE algorithm encoding: 10)</t>
    </list></t>
  <t>Master Salt  <list style="symbols">
      <t>Default is the empty byte string</t>
    </list></t>
  <t>HKDF Algorithm  <list style="symbols">
      <t>Default is HKDF SHA-256</t>
    </list></t>
  <t>Replay Window  <list style="symbols">
  <t>The default mechanism is an anti-replay sliding window (see Section 4.1.2.6 of <xref target="RFC6347"/> with a window size of 32 </t>

    </list></t>
</list></t>

<t>All input parameters need to be known and agreed on by both endpoints, but the Replay Window may be different in the two endpoints. The way the input parameters are preestablished is application specific. Considerations of security context establishment are given in <xref target="sec-context-establish"/> and examples of deploying OSCORE in <xref target="deployment-examples"/>.</t>

<section anchor="derivation-of-sender-key-recipient-key-and-common-iv" title="Derivation of Sender Key, Recipient Key, and Common IV">

<t>The HKDF MUST be one of the HMAC-based HKDF <xref target="RFC5869"/> algorithms defined for COSE <xref target="RFC8152"/>. HKDF SHA-256 is mandatory to implement. The security context parameters Sender Key, Recipient Key, and Common IV SHALL be derived from the input parameters using the HKDF, which consists of the composition of the HKDF-Extract and HKDF-Expand steps <xref target="RFC5869"/>:</t>

<figure><artwork><![CDATA[
   output parameter = HKDF(salt, IKM, info, L) 
]]></artwork></figure>

<t>where:</t>



<t><list style="symbols">
  <t>salt is the Master Salt as defined above</t>
  <t>IKM is the Master Secret as defined above</t>
  <t>info is the serialization of a CBOR array consisting of (the notation follows <xref target="RFC8610"/> as summarized in <xref target="cddl-sum"/>):</t>
</list></t>

<figure><artwork type="CDDL"><![CDATA[
   info = [
     id : bstr,
     id_context : bstr / nil,
     alg_aead : int / tstr,
     type : tstr,
     L : uint,
   ]
]]></artwork></figure>
<t>where:</t>

<t><list style="symbols">
  <t>id is the Sender ID or Recipient ID when deriving Sender Key and Recipient Key, respectively, and the empty byte string when deriving the Common IV.</t>
  <t>id_context is the ID Context, or nil if ID Context is not provided.</t>
  <t>alg_aead is the AEAD Algorithm, encoded as defined in <xref target="RFC8152"/>.</t>
  <t>type is "Key" or "IV". The label is an ASCII string and does not include a trailing NUL byte.</t>
  <t>L is the size of the key/nonce for the AEAD Algorithm used, in bytes.</t>
</list></t>

<t>For example, if the algorithm AES-CCM-16-64-128 (see Section 10.2 in <xref target="RFC8152"/>) is used, the integer value for alg_aead is 10, the value for L is 16 for keys and 13 for the Common IV. Assuming use of the default algorithms HKDF SHA-256 and AES-CCM-16-64-128, the extract phase of HKDF produces a pseudorandom key (PRK) as follows:</t>

<figure><artwork><![CDATA[
   PRK = HMAC-SHA-256(Master Salt, Master Secret)
]]></artwork></figure>

<t>and as L is smaller than the hash function output size, the expand phase of HKDF consists of a single HMAC invocation; therefore, the Sender Key, Recipient Key, and Common IV are the first 16 or 13 bytes of</t>

<figure><artwork><![CDATA[
   output parameter = HMAC-SHA-256(PRK, info || 0x01)
]]></artwork></figure>




<t>where different values of info are used for each derived parameter and where || denotes byte string concatenation.</t>

<t>Note that <xref target="RFC5869"/> specifies that if the salt is not provided, it is set to a string of zeros. For implementation purposes, not providing the salt is the same as setting the salt to the empty byte string. OSCORE sets the salt default value to empty byte string, which is converted to a string of zeroes (see Section 2.2 of <xref target="RFC5869"/>).</t>

</section>
<section anchor="initial-replay" title="Initial Sequence Numbers and Replay Window">

<t>The Sender Sequence Number is initialized to 0.</t>

<t>The supported types of replay protection and replay window size is application specific and depends on how OSCORE is transported (see <xref target="replay-protection"/>). The default mechanism is the anti-replay window of received messages used by IPsec AH/ESP and DTLS (see Section 4.1.2.6 of <xref target="RFC6347"/>) with a window size of 32.</t>

</section>
</section>
<section anchor="req-params" title="Requirements on the Security Context Parameters">

<t>To ensure unique Sender Keys, the quartet (Master Secret, Master Salt, ID Context, Sender ID) MUST be unique, i.e., the pair (ID Context, Sender ID) SHALL be unique in the set of all security contexts using the same Master Secret and Master Salt. This means that Sender ID SHALL be unique in the set of all security contexts using the same Master Secret, Master Salt, and ID Context; such a requirement guarantees unique (key, nonce) pairs for the AEAD.</t>

<t>Different methods can be used to assign Sender IDs: a protocol that allows the parties to negotiate locally unique identifiers, a trusted third party (e.g., <xref target="ACE-OAuth"/>), or the identifiers can be assigned out-of-band. The Sender IDs can be very short (note that the empty string is a legitimate value). The maximum length of Sender ID in bytes equals the length of the AEAD nonce minus 6, see <xref target="nonce"/>. For AES-CCM-16-64-128 the maximum length of Sender ID is 7 bytes.</t>

<t>To simplify retrieval of the right Recipient Context, the Recipient ID SHOULD be unique in the sets of all Recipient Contexts used by an endpoint. If an endpoint has the same Recipient ID with different Recipient Contexts, i.e., the Recipient Contexts are derived from different Common Contexts, then the endpoint may need to try multiple times before verifying the right security context associated to the Recipient ID.</t>

<t>The ID Context is used to distinguish between security contexts. The methods used for assigning Sender ID can also be used for assigning the ID Context. Additionally, the ID Context can be used to introduce randomness into new Sender and Recipient Contexts (see <xref target="master-secret-multiple"/>). ID Context can be arbitrarily long.</t>

</section>
</section>
<section anchor="protected-fields" title="Protected Message Fields">

<t>OSCORE transforms a CoAP message (which may have been generated from an HTTP message) into an OSCORE message, and vice versa. OSCORE protects as much of the original message as possible while still allowing certain proxy operations (see Sections <xref target="coap-coap-proxy" format="counter"/> and <xref target="http-op" format="counter"/>). This section defines how OSCORE protects the message fields and transfers them end-to-end between client and server (in any direction).</t>

<t>The remainder of this section and later sections focus on the behavior in terms of CoAP messages. If HTTP is used for a particular hop in the end-to-end path, then this section applies to the conceptual CoAP message that is mappable to/from the original HTTP message as discussed in <xref target="http-op"/>.  That is, an HTTP message is conceptually transformed to a CoAP message and then to an OSCORE message, and similarly in the reverse direction.  An actual implementation might translate directly from HTTP to OSCORE without the intervening CoAP representation.</t>

<t>Protection of signaling messages (Section 5 of <xref target="RFC8323"/>) is specified in <xref target="coap-signaling"/>. The other parts of this section target request/response messages.</t>

<t>Message fields of the CoAP message may be protected end-to-end between CoAP client and CoAP server in different ways:</t>

<t><list style="symbols">
  <t>Class E: encrypted and integrity protected,</t>
  <t>Class I: integrity protected only, or</t>
  <t>Class U: unprotected.</t>
</list></t>

<t>The sending endpoint SHALL transfer Class E message fields in the ciphertext of the COSE object in the OSCORE message. The sending endpoint SHALL include Class I message fields in the AAD of the AEAD algorithm, allowing the receiving endpoint to detect if the value has changed in transfer. Class U message fields SHALL NOT be protected in transfer. Class I and Class U message field values are transferred in the header or options part of the OSCORE message, which is visible to proxies.</t>

<t>Message fields not visible to proxies, i.e., transported in the ciphertext of the COSE object, are called "Inner" (Class E). Message fields transferred in the header or options part of the OSCORE message, which is visible to proxies, are called "Outer" (Class I or Class U). There are currently no Class I options defined.</t>

<t>An OSCORE message may contain both an Inner and an Outer instance of a certain CoAP message field. Inner message fields are intended for the receiving endpoint, whereas Outer message fields are used to enable proxy operations.</t>

<section anchor="coap-options" title="CoAP Options">

<t>A summary of how options are protected is shown in <xref target="fig-option-protection"/>. Note that some options may have both Inner and Outer message fields, which are protected accordingly. Certain options require special processing as is described in <xref target="special-options"/>.</t>

<t>Options that are unknown or for which OSCORE processing is not defined SHALL be processed as Class E (and no special processing). Specifications of new CoAP options SHOULD define how they are processed with OSCORE. A new COAP option SHOULD be of Class E unless it requires proxy processing. If a new CoAP option is of class U, the potential issues with
the option being unprotected SHOULD be documented (see <xref target="unprot-fields"/>).</t>

<section anchor="inner-options" title="Inner Options">

<t>Inner option message fields (Class E) are used to communicate directly with
the other endpoint.</t>

<t>The sending endpoint SHALL write the Inner option message fields present in the original CoAP message into the plaintext of the COSE object (<xref target="plaintext"/>) and then remove the Inner option message fields from the OSCORE message.</t>

<t>The processing of Inner option message fields by the receiving endpoint is specified in Sections <xref target="ver-req" format="counter"/> and <xref target="ver-res" format="counter"/>.</t>

<figure title="Protection of CoAP Options" anchor="fig-option-protection"><artwork align="center"><![CDATA[
  +------+-----------------+---+---+
  | No.  | Name            | E | U |
  +------+-----------------+---+---+
  |   1  | If-Match        | x |   |
  |   3  | Uri-Host        |   | x |
  |   4  | ETag            | x |   |
  |   5  | If-None-Match   | x |   |
  |   6  | Observe         | x | x |
  |   7  | Uri-Port        |   | x |
  |   8  | Location-Path   | x |   |
  |   9  | OSCORE          |   | x |
  |  11  | Uri-Path        | x |   |
  |  12  | Content-Format  | x |   |
  |  14  | Max-Age         | x | x |
  |  15  | Uri-Query       | x |   |
  |  17  | Accept          | x |   |
  |  20  | Location-Query  | x |   |
  |  23  | Block2          | x | x |
  |  27  | Block1          | x | x |
  |  28  | Size2           | x | x |
  |  35  | Proxy-Uri       |   | x |
  |  39  | Proxy-Scheme    |   | x |
  |  60  | Size1           | x | x |
  | 258  | No-Response     | x | x |
  +------+-----------------+---+---+

E = Encrypt and Integrity Protect (Inner)
U = Unprotected (Outer)
]]></artwork></figure>

</section>
<section anchor="outer-options" title="Outer Options">

<t>Outer option message fields (Class U or I) are used to support proxy operations, see <xref target="supp-proxy-op"/>.</t>

<t>The sending endpoint SHALL include the Outer option message field present in the original message in the options part of the OSCORE message. All Outer option message fields, including the OSCORE option, SHALL be encoded as described in Section 3.1 of <xref target="RFC7252"/>, where the delta is the difference from the previously included instance of Outer option message field.</t>

<t>The processing of Outer options by the receiving endpoint is specified in Sections <xref target="ver-req" format="counter"/> and <xref target="ver-res" format="counter"/>.</t>

<t>A procedure for integrity-protection-only of Class I option message fields is specified in <xref target="AAD"/>. Specifications that introduce repeatable Class I options MUST specify that proxies MUST NOT change the order of the instances of such an option in the CoAP message.</t>

<t>Note: There are currently no Class I option message fields defined.</t>

</section>
<section anchor="special-options" title="Special Options">

<t>Some options require special processing as specified in this section.</t>

<section anchor="max-age" title="Max-Age">

<t>An Inner Max-Age message field is used to indicate the maximum time a response may be cached by the client (as defined in <xref target="RFC7252"/>), end-to-end from the server to the client, taking into account that the option is not accessible to proxies. The Inner Max-Age SHALL be processed by OSCORE as a normal Inner option, specified in <xref target="inner-options"/>.</t>


<t>An Outer Max-Age message field is used to avoid unnecessary caching of error responses  caused by OSCORE processing at OSCORE-unaware intermediary nodes. A server MAY set a Class U Max-Age message field with value zero to such error responses, described in Sections <xref target="replay-protection" format="counter"/>, <xref target="ver-req" format="counter"/>, and <xref target="ver-res" format="counter"/>, since these error responses are cacheable, but subsequent OSCORE requests would never create a hit in the intermediary node caching it. Setting the Outer Max-Age to zero relieves the intermediary from uselessly caching responses. Successful OSCORE responses do not need to include an Outer Max-Age option. Except when the Observe option (see <xref target="observe"/>) is used, responses appear to the OSCORE-unaware intermediary as 2.04 (Changed) responses, which are non-cacheable (see <xref target="coap-header"/>). For Observe responses, which are cacheable, an Outer Max-Age option with value 0 may be used to avoid unnecessary proxy caching.</t>


<t>The Outer Max-Age message field is processed according to <xref target="outer-options"/>.</t>

</section>
<section anchor="uri-host" title="Uri-Host and Uri-Port">

<t>When the Uri-Host and Uri-Port are set to their default values (see Section 5.10.1 <xref target="RFC7252"/>), they are omitted from the message (Section 5.4.4 of <xref target="RFC7252"/>), which is favorable both for overhead and privacy.</t>

<t>In order to support forward proxy operations, Proxy-Scheme, Uri-Host, and Uri-Port need to be Class U. 
For the use of Proxy-Uri, see <xref target="proxy-uri"/>.</t>

<t>Manipulation of unprotected message fields (including Uri-Host, Uri-Port, destination IP/port or request scheme) MUST NOT lead to an OSCORE message becoming verified by an unintended server. Different servers SHALL have different security contexts.</t>

</section>
<section anchor="proxy-uri" title="Proxy-Uri">

<t>When Proxy-Uri is present, the client SHALL first decompose the Proxy-Uri value of the original CoAP message into the Proxy-Scheme, Uri-Host, Uri-Port, Uri-Path, and Uri-Query options according to Section 6.4 of <xref target="RFC7252"/>.</t>

<t>Uri-Path and Uri-Query are Class E options and SHALL be protected and processed as Inner options (<xref target="inner-options"/>).</t>

<t>The Proxy-Uri option of the OSCORE message SHALL be set to the composition of Proxy-Scheme, Uri-Host, and Uri-Port options as specified in Section 6.5 of <xref target="RFC7252"/> and processed as an Outer option of Class U (<xref target="outer-options"/>).</t>

<t>Note that replacing the Proxy-Uri value with the Proxy-Scheme and Uri-* options works by design for all CoAP URIs (see Section 6 of <xref target="RFC7252"/>). OSCORE-aware HTTP servers should not use the userinfo component of the HTTP URI (as defined in Section 3.2.1 of <xref target="RFC3986"/>), so that this type of replacement is possible in the presence of CoAP-to-HTTP proxies (see <xref target="coap2http"/>). In future specifications of cross-protocol proxying behavior using different URI structures, it is expected that the authors will create Uri-* options that allow decomposing the Proxy-Uri, and specifying the OSCORE processing.</t>

<t>An example of how Proxy-Uri is processed is given here. Assume that the original CoAP message contains:</t>

<t><list style="symbols">
  <t>Proxy-Uri = "coap://example.com/resource?q=1"</t>
</list></t>

<t>During OSCORE processing, Proxy-Uri is split into:</t>


<t><list style="symbols">
  <t>Proxy-Scheme = "coap"</t>
  <t>Uri-Host = "example.com"</t>
  <t>Uri-Port = "5683" (default)</t>
  <t>Uri-Path = "resource"</t>
  <t>Uri-Query = "q=1"</t>
</list></t>

<t>Uri-Path and Uri-Query follow the processing defined in <xref target="inner-options"/>; thus, they are encrypted and transported in the COSE object:</t>

<t><list style="symbols">
  <t>Uri-Path = "resource"</t>
  <t>Uri-Query = "q=1"</t>
</list></t>

<t>The remaining options are composed into the Proxy-Uri included in the options part of the OSCORE message, which has value:</t>

<t><list style="symbols">
  <t>Proxy-Uri = "coap://example.com"</t>
</list></t>

<t>See Sections 6.1 and 12.6 of <xref target="RFC7252"/> for more details.</t>

</section>
<section anchor="block-options" title="The Block Options">

<t>Block-wise <xref target="RFC7959"/> is an optional feature. An implementation MAY support CoAP <xref target="RFC7252"/> and the OSCORE option without supporting block-wise transfers. The Block options (Block1, Block2, Size1, Size2), when Inner message fields, provide secure message segmentation such that each segment can be verified. The Block options, when Outer message fields, enable hop-by-hop fragmentation of the OSCORE message. Inner and Outer block processing may have different performance properties depending on the underlying transport. The end-to-end integrity of the message can be verified both in case of Inner and Outer Block-wise transfers, provided all blocks are received.</t>

<section anchor="inner-block-options" title="Inner Block Options">

<t>The sending CoAP endpoint MAY fragment a CoAP message as defined in <xref target="RFC7959"/> before the message is processed by OSCORE. In this case, the Block options SHALL be processed by OSCORE as normal Inner options (<xref target="inner-options"/>). The receiving CoAP endpoint SHALL process the OSCORE message before processing Block-wise as defined in <xref target="RFC7959"/>.</t>

</section>
<section anchor="outer-block-options" title="Outer Block Options">

 
<t>Proxies MAY fragment an OSCORE message using <xref
target="RFC7959"/> by introducing Block option message fields that are
Outer (<xref target="outer-options"/>). Note that the Outer Block
options are neither encrypted nor integrity protected. As a
consequence, a proxy can maliciously inject block fragments
indefinitely, since the receiving endpoint needs to receive the last
block (see <xref target="RFC7959"/>) to be able to compose the OSCORE
message and verify its integrity. Therefore, applications supporting
OSCORE and <xref target="RFC7959"/> MUST specify a security policy
defining a maximum unfragmented message size (MAX_UNFRAGMENTED_SIZE)
considering the maximum size of message that can be handled by the
endpoints. Messages exceeding this size SHOULD be fragmented by the
sending endpoint using Inner Block options (<xref
target="inner-block-options"/>).</t>

<t>An endpoint receiving an OSCORE message with an Outer Block option SHALL first process this option according to <xref target="RFC7959"/>, until all blocks of the OSCORE message have been received or the cumulated message size of the blocks exceeds MAX_UNFRAGMENTED_SIZE.  In the former case, the processing of the OSCORE message continues as defined in this document. In the latter case, the message SHALL be discarded.</t>

<t>Because of encryption of Uri-Path and Uri-Query, messages to the same server may, from the point of view of a proxy, look like they also target the same resource. A proxy SHOULD mitigate a potential mix-up of blocks from concurrent requests to the same server, for example, using the Request-Tag processing specified in Section 3.3.2 of <xref target="CoAP-ECHO-REQ-TAG"/>.</t>

</section>
</section>
<section anchor="observe" title="Observe">

<t>Observe <xref target="RFC7641"/> is an optional feature. An implementation MAY support CoAP <xref target="RFC7252"/> and the OSCORE option without supporting <xref target="RFC7641"/>, in which case the Observe-related processing can be omitted.</t>

<t>The support for Observe <xref target="RFC7641"/> with OSCORE targets the requirements on forwarding of Section 2.2.1 of <xref target="CoAP-E2E-Sec"/>, i.e., that observations go through intermediary nodes, as illustrated in Figure 8 of <xref target="RFC7641"/>.</t>

<t>Inner Observe SHALL be used to protect the value of the Observe option between the endpoints. Outer Observe SHALL be used to support forwarding by intermediary nodes.</t>

<t>The server SHALL include a new Partial IV (see <xref target="cose-object"/>) in responses (with or without the Observe option) to Observe registrations, except for the first response where Partial IV MAY be omitted.</t>

<t>For cancellations, Section 3.6 of <xref target="RFC7641"/> specifies that all options MUST be identical to those in the registration request except for the Observe option and the set of ETag options. For OSCORE messages, this matching is to be done to the options in the decrypted message.</t>

<t><xref target="RFC7252"/> does not specify how the server should act upon receiving the same Token in different requests. When using OSCORE, the server SHOULD NOT remove an active observation just because it receives a request with the same Token.</t>

<t>Since POST with the Observe option is not defined, for messages with the Observe option, the Outer Code MUST be set to 0.05 (FETCH) for requests and to 2.05 (Content) for responses (see <xref target="coap-header"/>).</t>

<section anchor="observe-registration" title="Registrations and Cancellations">

<t>The Inner and Outer Observe options in the request MUST contain the Observe value of the original CoAP request; 0 (registration) or 1 (cancellation).</t>

<t>Every time a client issues a new request with the Observe option, a new Partial IV MUST be used (see <xref target="cose-object"/>), and so the payload and OSCORE option are changed. The server uses the Partial IV of the new request as the 'request_piv' of all associated notifications (see <xref target="AAD"/>).</t>


<t>Intermediaries are not assumed to have access to the OSCORE security context used by the endpoints; thus, they cannot make requests or transform responses with the OSCORE option that pass verification (at the receiving endpoint) as having come from the other endpoint. This has the following consequences and limitations for Observe operations.</t>

<t><list style="symbols">
  <t>An intermediary node removing the Outer Observe 0 option does not change the registration request to a request without the Observe option (see Section 2 of <xref target="RFC7641"/>). Instead other means for cancellation may be used as described in Section 3.6 of <xref target="RFC7641"/>.</t>
  <t>An intermediary node is not able to transform a normal response into an OSCORE-protected Observe notification (see Figure 7 of <xref target="RFC7641"/>) that verifies as coming from the server.</t>
  <t>An intermediary node is not able to initiate an OSCORE protected
  Observe registration (Observe option with value 0) that verifies as coming
  from the client. An OSCORE-aware intermediary SHALL NOT initiate
  registrations of observations (see <xref
  target="coap-coap-proxy"/>). If an OSCORE-unaware proxy resends an
  old registration message from a client, the replay
  protection mechanism in the server will be triggered. To prevent this from resulting
  in the OSCORE-unaware proxy canceling the registration, a server
  MAY respond to a replayed registration request with a replay of a
  cached notification. Alternatively, the server MAY send a new
  notification.</t>

  <t>An intermediary node is not able to initiate an OSCORE-protected Observe cancellation (Observe option with value 1) that verifies as coming from the client. An application MAY decide to allow intermediaries to cancel Observe registrations, e.g., to send the Observe option with value 1 (see Section 3.6 of <xref target="RFC7641"/>); however, that can also be done with other methods, e.g., by sending a RST message. This is out of scope for this specification.</t>
</list></t>

</section>
<section anchor="notifications" title="Notifications">

<t>If the server accepts an Observe registration, a Partial IV MUST be included in all notifications (both successful and error), except for the first one where the Partial IV MAY be omitted. To protect against replay, the client SHALL maintain a Notification Number for each Observation it registers. The Notification Number is a non-negative integer containing the largest Partial IV of the received notifications for the associated Observe registration. Further details of replay protection of notifications are specified in <xref target="replay-notifications"/>.</t>


<t>For notifications, the Inner Observe option value MUST be empty (see Section 3.2 of <xref target="RFC7252"/>). The Outer Observe option in a notification is needed for intermediary nodes to allow multiple responses to one request, and it MAY be set to the value of the Observe option in the original CoAP message. The client performs ordering of notifications and replay protection by comparing their Partial IVs and SHALL ignore the Outer Observe option value.</t>

<t>If the client receives a response to an Observe request without an Inner Observe option, then it verifies the response as a non-Observe response, as specified in <xref target="ver-res"/>. If the client receives a response to a non-Observe request with an Inner Observe option, then it stops processing the message, as specified in <xref target="ver-res"/>.</t>

<t>A client MUST consider the notification with the highest Partial IV as the freshest, regardless of the order of arrival. In order to support existing Observe implementations, the OSCORE client implementation MAY set the Observe option value to the three least significant bytes of the Partial IV. Implementations need to make sure that the notification without Partial IV is considered the oldest.</t>

</section>
</section>
<section anchor="no-resp" title="No-Response">

<t>No-Response <xref target="RFC7967"/> is an optional feature used by the client to communicate its disinterest in certain classes of responses to a particular request. An implementation MAY support <xref target="RFC7252"/> and the OSCORE option without supporting <xref target="RFC7967"/>.</t>

<t>If used, No-Response MUST be Inner. The Inner No-Response SHALL be processed by OSCORE as specified in <xref target="inner-options"/>. The Outer option SHOULD NOT be present. The server SHALL ignore the Outer No-Response option. The client MAY set the Outer No-Response value to 26 (suppress all known codes) if the Inner value is set to 26. The client MUST be prepared to receive and discard 5.04 (Gateway Timeout) error messages from intermediaries potentially resulting from destination time out due to no response.</t>

</section>
<section anchor="oscore" title="OSCORE">

<t>The OSCORE option is only defined to be present in OSCORE messages as an indication that OSCORE processing has been performed. The content in the OSCORE option is neither encrypted nor integrity protected as a whole, but some part of the content of this option is protected (see <xref target="AAD"/>). Nested use of OSCORE is not supported: If OSCORE processing detects an OSCORE option in the original CoAP message, then processing SHALL be stopped.</t>


</section>
</section>
</section>
<section anchor="coap-header" title="CoAP Header Fields and Payload">

  <t>A summary of how the CoAP header fields and payload are protected is shown in <xref target="fig-fields-protection"/>, including fields specific to CoAP over UDP and CoAP over TCP (marked accordingly in the table).</t>

  <figure title="Protection of CoAP Header Fields and Payload" anchor="fig-fields-protection"><artwork align="center"><![CDATA[
      +------------------+---+---+
      | Field            | E | U |
      +------------------+---+---+
      | Version (UDP)    |   | x |
      | Type (UDP)       |   | x |
      | Length (TCP)     |   | x |
      | Token Length     |   | x |
      | Code             | x |   |
      | Message ID (UDP) |   | x |
      | Token            |   | x |
      | Payload          | x |   |
      +------------------+---+---+

E = Encrypt and Integrity Protect (Inner)
U = Unprotected (Outer)
]]></artwork></figure>

<t>Most CoAP header fields (i.e., the message fields in the fixed 4-byte header) are required to be read and/or changed by CoAP proxies; thus, they cannot, in general, be protected end-to-end from one endpoint to the other. As mentioned in <xref target="intro"/>, OSCORE protects the CoAP request/response layer only and not the CoAP messaging layer (Section 2 of <xref target="RFC7252"/>), so fields such as Type and Message ID are not protected with OSCORE.</t>

<t>The CoAP header field Code is protected by OSCORE. Code SHALL be encrypted and integrity protected (Class E) to prevent an intermediary from eavesdropping on or manipulating it (e.g., changing from GET to DELETE).</t>

<t>The sending endpoint SHALL write the Code of the original CoAP message into the plaintext of the COSE object (see <xref target="plaintext"/>). After that, the sending endpoint writes an Outer Code to the OSCORE message. With one exception (see <xref target="observe"/>), the Outer Code SHALL be set to 0.02 (POST) for requests and to 2.04 (Changed) for responses. The receiving endpoint SHALL discard the Outer Code in the OSCORE message and write the Code of the COSE object plaintext (<xref target="plaintext"/>) into the decrypted CoAP message.</t>

<t>The other currently defined CoAP header fields are Unprotected (Class U). The sending endpoint SHALL write all other header fields of the original message into the header of the OSCORE message. The receiving endpoint SHALL write the header fields from the received OSCORE message into the header of the decrypted CoAP message.</t>

<t>The CoAP Payload, if present in the original CoAP message, SHALL be encrypted and integrity protected; thus, it is an Inner message field. The sending endpoint writes the payload of the original CoAP message into the plaintext (<xref target="plaintext"/>) input to the COSE object. The receiving endpoint verifies and decrypts the COSE object, and it recreates the payload of the original CoAP message.</t>

</section>
<section anchor="coap-signaling" title="Signaling Messages">


<t>Signaling messages (CoAP Code 7.00-7.31) were introduced to exchange information related to an underlying transport connection in the specific case of CoAP over reliable transports <xref target="RFC8323"/>.</t>

<t>OSCORE MAY be used to protect signaling if the endpoints for OSCORE coincide with the endpoints for the signaling message. If OSCORE is used to protect signaling then:</t>

<t><list style="symbols">
  <t>To comply with <xref target="RFC8323"/>, an initial empty Capabilities and Settings Message  (CSM) SHALL be sent. The subsequent signaling message SHALL be protected.</t>
  <t>Signaling messages SHALL be protected as CoAP request messages, except in the case in which the signaling message is a response to a previous signaling message; then it SHALL be protected as a CoAP response message. 
For example, 7.02 (Ping) is protected as a CoAP request and 7.03 (Pong) as a CoAP response.</t>
  <t>The Outer Code for signaling messages SHALL be set to 0.02 (POST), unless it is a response to a previous signaling message, in which case it SHALL be set to 2.04 (Changed).</t>
  <t>All signaling options, except the OSCORE option, SHALL be Inner (Class E).</t>
</list></t>

<t>NOTE: Option numbers for signaling messages are specific to the CoAP Code (see Section 5.2 of <xref target="RFC8323"/>).</t>

<t>If OSCORE is not used to protect signaling, Signaling messages SHALL be unaltered by OSCORE.</t>

</section>
</section>
<section anchor="cose-object" title="The COSE Object">
  

  
<t>This section defines how to use COSE <xref target="RFC8152"/> to wrap and protect data in the original message. OSCORE uses the untagged COSE_Encrypt0 structure (see Section 5.2 of <xref target="RFC8152"/>) with an AEAD algorithm. The AEAD key lengths, AEAD nonce length, and maximum Sender Sequence Number are algorithm dependent.</t>

<t>The AEAD algorithm AES-CCM-16-64-128 defined in Section 10.2 of <xref target="RFC8152"/> is mandatory to implement. For AES-CCM-16-64-128, the length of Sender Key and Recipient Key is 128 bits; the length of AEAD nonce and Common IV is 13 bytes. The maximum Sender Sequence Number is specified in <xref target="sec-considerations"/>.</t>

<t>As specified in <xref target="RFC5116"/>, plaintext denotes the data that is to be encrypted and integrity protected, and Additional Authenticated Data (AAD) denotes the data that is to be integrity protected only.</t>

<t>The COSE object SHALL be a COSE_Encrypt0 object with fields defined as follows:</t>



<t><list style="symbols">
  <t>The 'protected' field is empty.</t>
  <t>The 'unprotected' field includes:  <list style="symbols">
      <t>The 'Partial IV' parameter. The value is set to the Sender Sequence Number. All leading bytes of value zero SHALL be removed when encoding the Partial IV, except in the case of Partial IV value 0, which is encoded to the byte string 0x00. This parameter SHALL be present in requests and will not typically be present in responses (for two exceptions, see Observe notifications (<xref target="notifications"/>) and Replay Window synchronization (<xref target="reboot-replay"/>)).</t>
      <t>The 'kid' parameter. The value is set to the Sender ID. This parameter SHALL be present in requests and will not typically be present in responses. An example where the Sender ID is included in a response is the extension of OSCORE to group communication <xref target="Group-OSCORE"/>.</t>
      <t>Optionally, a 'kid context' parameter (see <xref target="context-hint"/>). This parameter MAY be present in requests and, if so, MUST contain an ID Context (see <xref target="context-definition"/>). This parameter SHOULD NOT be present in responses: an example of how 'kid context' can be used in responses is given in <xref target="master-secret-multiple"/>. If 'kid context' is present in the request, then the server SHALL use a security context with that ID Context when verifying the request.</t>
    </list></t>
  <t>The 'ciphertext' field is computed from the secret key (Sender Key or Recipient Key), AEAD nonce (see <xref target="nonce"/>), plaintext (see <xref target="plaintext"/>), and the AAD (see <xref target="AAD"/>) following Section 5.2 of <xref target="RFC8152"/>.</t>
</list></t>

<t>The encryption process is described in Section 5.3 of <xref target="RFC8152"/>.</t>

<section anchor="context-hint" title="ID Context and 'kid context'">

<t>For certain use cases, e.g., deployments where the same Sender ID is used with multiple contexts, it is possible (and sometimes necessary, see <xref target="req-params"/>) for the client to use an ID Context to distinguish the security contexts (see <xref target="context-definition"/>). For example:</t>

<t><list style="symbols">
  <t>If the client has a unique identifier in some namespace, then that identifier can be used as ID Context.</t>
  <t>The ID Context may be used to add randomness into new Sender and Recipient Contexts, see <xref target="master-secret-multiple"/>.</t>
  <t>In the case of group communication <xref target="Group-OSCORE"/>, a group identifier is used as ID Context to enable different security contexts for a server belonging to multiple groups.</t>
</list></t>

<t>The Sender ID and ID Context are used to establish the necessary input parameters and in the derivation of the security context (see <xref target="context-derivation"/>).</t>
<t>While the 'kid' parameter is used to transport the Sender ID, the new COSE header parameter 'kid context' is used to transport the ID Context in requests, see <xref target="tab-1"/>.</t>

<figure title="Common Header Parameter 'kid context' for the COSE Object" anchor="tab-1"><artwork align="center"><![CDATA[
+----------+--------+------------+----------------+-----------------+
|   Name   |  Label | Value Type | Value Registry |   Description   |
+----------+--------+------------+----------------+-----------------+
|   kid    |    10  | bstr       |                | Identifies the  |
| context  |        |            |                | context for the |
|          |        |            |                | key identifier  |
+----------+--------+------------+----------------+-----------------+
]]></artwork></figure>

<t>If ID Context is non-empty and the client sends a request without
'kid context' resulting in an error indicating that the server could
not find the security context, then the client could include the ID
Context in the 'kid context' when making another request. Note that
since the error is unprotected, it may have been spoofed and the real
response blocked by an on-path attacker.</t>

</section>
<section anchor="nonce" title="AEAD Nonce">

  <t>The high-level design of the AEAD nonce follows Section 4.4 of <xref target="IV-GEN"/>. The detailed construction of the AEAD nonce is presented here (see <xref target="fig-nonce"/>):</t>

  
<t><list style="numbers">
  <t>left-pad the Partial IV (PIV) with zeroes to exactly 5 bytes,</t>
  <t>left-pad the Sender ID of the endpoint that generated the Partial IV (ID_PIV) with zeroes to exactly nonce length minus 6 bytes,</t>
  <t>concatenate the size of the ID_PIV (a single byte S) with the padded ID_PIV and the padded PIV,</t>
  <t>and then XOR with the Common IV.</t>
</list></t>

<t>Note that in this specification, only AEAD algorithms that use nonces equal or greater than 7 bytes are supported. The nonce construction with S, ID_PIV, and PIV together with endpoint-unique IDs and encryption keys makes it easy to verify that the nonces used with a specific key will be unique, see <xref target="kn-uniqueness"/>.</t>


<t>If the Partial IV is not present in a response, the nonce from the request is used. For responses that are not notifications (i.e., when there is a single response to a request), the request and the response should typically use the same nonce to reduce message overhead. Both alternatives provide all the required security properties, see <xref target="replay-protection"/> and <xref target="kn-uniqueness"/>. Another non-Observe scenario where a Partial IV is included in a response is when the server is unable to perform replay protection, see <xref target="reboot-replay"/>. For processing instructions see <xref target="processing"/>.</t>

<figure title="AEAD Nonce Formation" anchor="fig-nonce"><artwork align="center"><![CDATA[
     <- nonce length minus 6 B -> <-- 5 bytes -->
+---+-------------------+--------+---------+-----+
| S |      padding      | ID_PIV | padding | PIV |----+ 
+---+-------------------+--------+---------+-----+    | 
                                                      |
 <---------------- nonce length ---------------->     |               
+------------------------------------------------+    | 
|                   Common IV                    |->(XOR)
+------------------------------------------------+    | 
                                                      | 
 <---------------- nonce length ---------------->     |               
+------------------------------------------------+    | 
|                     Nonce                      |<---+ 
+------------------------------------------------+     
]]></artwork></figure>

</section>
<section anchor="plaintext" title="Plaintext">


  
<t>The plaintext is formatted as a CoAP message with a subset of the header (see <xref target="fig-plaintext"/>) consisting of:</t>

<t><list style="symbols">
  <t>the Code of the original CoAP message as defined in Section 3 of <xref target="RFC7252"/>; and</t>
  <t>all Inner option message fields (see <xref target="inner-options"/>) present in the original CoAP message (see <xref target="coap-options"/>). The options are encoded as described in Section 3.1 of <xref target="RFC7252"/>, where the delta is the difference from the previously included instance of Class E option; and</t>
  <t>the Payload of original CoAP message, if present, and in that case prefixed by the one-byte Payload Marker (0xff).</t>
</list></t>

<t>NOTE: The plaintext contains all CoAP data that needs to be encrypted end-to-end between the endpoints.</t>

<figure title="Plaintext" anchor="fig-plaintext"><artwork align="center"><![CDATA[
 0                   1                   2                   3   
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Code      |    Class E options (if any) ...                
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1 1 1 1 1 1 1 1|    Payload (if any) ...                        
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 (only if there 
   is payload)
]]></artwork></figure>

</section>
<section anchor="AAD" title="Additional Authenticated Data">


<t>The external_aad SHALL be a CBOR array wrapped in a bstr object as defined below, following the notation of <xref target="RFC8610"/> as summarized in <xref target="cddl-sum"/>:</t>

<figure><artwork type="CDDL"><![CDATA[
external_aad = bstr .cbor aad_array

aad_array = [
  oscore_version : uint,
  algorithms : [ alg_aead : int / tstr ],
  request_kid : bstr,
  request_piv : bstr,
  options : bstr,
]
]]></artwork></figure>

<t>where:</t>

<t><list style="symbols">
  <t>oscore_version: contains the OSCORE version number. Implementations of this specification MUST set this field to 1. Other values are reserved for future versions.</t>
  <t>algorithms: contains (for extensibility) an array of algorithms, according to this specification only containing alg_aead.</t>
  <t>alg_aead: contains the AEAD Algorithm from the security context used for the exchange (see <xref target="context-definition"/>).</t>
  <t>request_kid: contains the value of the 'kid' in the COSE object of the request (see <xref target="cose-object"/>).</t>
  <t>request_piv: contains the value of the 'Partial IV' in the COSE object of the request (see <xref target="cose-object"/>).</t>
  <t>options: contains the Class I options (see <xref target="outer-options"/>) present in the original CoAP message encoded as described in Section 3.1 of <xref target="RFC7252"/>, where the delta is the difference from the previously included instance of class I option.</t>
</list></t>


<t>The oscore_version and algorithms parameters are established out-of-band; thus, they are not transported in OSCORE, but the external_aad allows to verify that they are the same in both endpoints.</t>

<t>NOTE: The format of the external_aad is, for simplicity, the same for requests and responses, although some parameters, e.g., request_kid, need not be integrity protected in all requests.</t>


<t>The AAD is composed from the external_aad as described in Section 5.3 of <xref target="RFC8152"/> (the notation follows <xref target="RFC8610"/> as summarized in <xref target="cddl-sum"/>):</t>

<figure><artwork><![CDATA[
   AAD = Enc_structure = [ "Encrypt0", h'', external_aad ]
]]></artwork></figure>

<t>The following is an example of AAD constructed using AEAD Algorithm = AES-CCM-16-64-128 (10), request_kid = 0x00, request_piv = 0x25 and no Class I options:</t>

<t><list style="symbols">
  <t>oscore_version: 0x01 (1 byte)</t>
  <t>algorithms: 0x810a (2 bytes)</t>
  <t>request_kid: 0x00 (1 byte)</t>
  <t>request_piv: 0x25 (1 byte)</t>
  <t>options: 0x (0 bytes)</t>
  <t>aad_array: 0x8501810a4100412540 (9 bytes)</t>
  <t>external_aad: 0x498501810a4100412540 (10 bytes)</t>
  <t>AAD: 0x8368456e63727970743040498501810a4100412540 (21 bytes)</t>
</list></t>

<t>Note that the AAD consists of a fixed string of 11 bytes concatenated with the external_aad.</t>

</section>
</section>
<section anchor="compression" title="OSCORE Header Compression">

<t>The Concise Binary Object Representation (CBOR) <xref
target="RFC7049"/> combines very small message sizes with
extensibility. The CBOR Object Signing and Encryption (COSE) <xref
target="RFC8152"/> uses CBOR to create compact encoding of signed and
encrypted data. However, COSE is constructed to support a large number
of different stateless use cases and is not fully optimized for use as
a stateful security protocol, leading to a larger than necessary
message expansion. In this section, we define a stateless header
compression mechanism, simply removing redundant information from the
COSE objects, which significantly reduces the per-packet overhead. The
result of applying this mechanism to a COSE object is called the
"compressed COSE object".</t>

<t>The COSE_Encrypt0 object used in OSCORE is transported in the OSCORE option and in the Payload. The Payload contains the ciphertext of the COSE object. The headers of the COSE object are compactly encoded as described in the next section.</t>

<section anchor="obj-sec-value" title="Encoding of the OSCORE Option Value">

<t>The value of the OSCORE option SHALL contain the OSCORE flag bits, the 'Partial IV' parameter, the 'kid context' parameter (length and value), and the 'kid' parameter as follows:</t>

<figure title="The OSCORE Option Value" anchor="fig-option-value"><artwork align="center"><![CDATA[
 0 1 2 3 4 5 6 7 <------------- n bytes -------------->
+-+-+-+-+-+-+-+-+--------------------------------------
|0 0 0|h|k|  n  |       Partial IV (if any) ...    
+-+-+-+-+-+-+-+-+--------------------------------------

 <- 1 byte -> <----- s bytes ------>                    
+------------+----------------------+------------------+
| s (if any) | kid context (if any) | kid (if any) ... |
+------------+----------------------+------------------+
]]></artwork></figure>

<t><list style="symbols">
  <t>The first byte, containing the OSCORE flag bits, encodes the following set of bits and the length of the 'Partial IV' parameter:  <list style="symbols">
      <t>The three least significant bits encode the Partial IV length
      n. If n = 0, then the Partial IV is not present in the
      compressed COSE object. The values n = 6 and n = 7 are
      reserved.</t>
      <t>The fourth least significant bit is the 'kid' flag, k. It is set to 1 if 'kid' is present in the compressed COSE object.</t>
      <t>The fifth least significant bit is the 'kid context' flag, h.  It is set to 1 if the compressed COSE object contains a 'kid context' (see <xref target="context-hint"/>).</t>
      <t>The sixth-to-eighth least significant bits are reserved for
      future use. These bits SHALL be set to zero when not in
      use. According to this specification, if any of these bits are
      set to 1, the message is considered to be malformed and
      decompression fails as specified in item 2 of <xref
      target="ver-req"/>.</t>
    </list></t>
</list></t>

<t>The flag bits are registered in the "OSCORE Flag Bits" registry specified in <xref target="oscore-flag-bits"/>.</t>

<t><list style="symbols">
  <t>The following n bytes encode the value of the Partial IV, if the Partial IV is present (n &gt; 0).</t>

  
  
  <t>The following 1 byte encodes the length s of the 'kid context' (<xref target="context-hint"/>), if the 'kid context' flag is set (h = 1).</t>
  <t>The following s bytes encode the 'kid context', if the 'kid context' flag is set (h = 1).</t>
  <t>The remaining bytes encode the value of the 'kid', if the 'kid' is present (k = 1).</t>
</list></t>

<t>Note that the 'kid' MUST be the last field of the OSCORE option value, even in the case in which reserved bits are used and additional fields are added to it.</t>

<t>The length of the OSCORE option thus depends on the presence and
length of Partial IV, 'kid context', 'kid', as specified in this
section, and on the presence and length of additional parameters, as
defined in the future documents registering those parameters.</t>




</section>
<section anchor="oscore-payl" title="Encoding of the OSCORE Payload">

<t>The payload of the OSCORE message SHALL encode the ciphertext of the COSE object.</t>

</section>
<section anchor="examples-of-compressed-cose-objects" title="Examples of Compressed COSE Objects">

<t>This section covers a list of OSCORE Header Compression examples for requests and responses. The examples assume the COSE_Encrypt0 object is set (which means the CoAP message and cryptographic material is known). Note that the full CoAP unprotected message, as well as the full security context, is not reported in the examples, but only the input necessary to the compression mechanism, i.e., the COSE_Encrypt0 object. The output is the compressed COSE object as defined in <xref target="compression"/>, divided into two parts, since the object is transported in two CoAP fields: the OSCORE option and payload.</t>

<t><list style="format %d." counter="bar">
  <t>Request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = 0x25, and Partial IV = 0x05</t>
</list></t>

<figure><artwork><![CDATA[
    Before compression (24 bytes):

      [
        h'',
        { 4:h'25', 6:h'05' },
        h'aea0155667924dff8a24e4cb35b9',
      ]
]]></artwork></figure>

<figure><artwork><![CDATA[
    After compression (17 bytes):

      Flag byte: 0b00001001 = 0x09 (1 byte)

      Option Value: 0x090525 (3 bytes)

      Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes)
]]></artwork></figure>

<t><list style="format %d." counter="bar">
  <t>Request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = empty string, and Partial IV = 0x00</t>
</list></t>

<figure><artwork><![CDATA[
    Before compression (23 bytes):

      [
        h'',
        { 4:h'', 6:h'00' },
        h'aea0155667924dff8a24e4cb35b9',
      ]
]]></artwork></figure>

<figure><artwork><![CDATA[
    After compression (16 bytes):

      Flag byte: 0b00001001 = 0x09 (1 byte)

      Option Value: 0x0900 (2 bytes)

      Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes)
]]></artwork></figure>

<t><list style="format %d." counter="bar">
  <t>Request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = empty string, Partial IV = 0x05, and kid context = 0x44616c656b</t>
</list></t>



<figure><artwork><![CDATA[
    Before compression (30 bytes):

      [
        h'',
        { 4:h'', 6:h'05', 10:h'44616c656b' },
        h'aea0155667924dff8a24e4cb35b9',
      ]
]]></artwork></figure>

<figure><artwork><![CDATA[
    After compression (22  bytes):

      Flag byte: 0b00011001 = 0x19 (1 byte)

      Option Value: 0x19050544616c656b (8 bytes)

      Payload: 0xae a0155667924dff8a24e4cb35b9 (14 bytes)
]]></artwork></figure>

<t><list style="format %d." counter="bar">
  <t>Response with ciphertext = 0xaea0155667924dff8a24e4cb35b9 and no Partial IV</t>
</list></t>

<figure><artwork><![CDATA[
    Before compression (18 bytes):

      [
        h'',
        {},
        h'aea0155667924dff8a24e4cb35b9',
      ]
]]></artwork></figure>

<figure><artwork><![CDATA[
    After compression (14 bytes):

      Flag byte: 0b00000000 = 0x00 (1 byte)

      Option Value: 0x (0 bytes)

      Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes)
]]></artwork></figure>

<t><list style="format %d." counter="bar">
  <t>Response with ciphertext = 0xaea0155667924dff8a24e4cb35b9 and Partial IV = 0x07</t>
</list></t>

<figure><artwork><![CDATA[
    Before compression (21 bytes):

      [
        h'',
        { 6:h'07' },
        h'aea0155667924dff8a24e4cb35b9',
      ]
]]></artwork></figure>

<figure><artwork><![CDATA[
    After compression (16 bytes):

      Flag byte: 0b00000001 = 0x01 (1 byte)

      Option Value: 0x0107 (2 bytes)

      Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes)
]]></artwork></figure>

</section>
</section>
<section anchor="sequence-numbers" title="Message Binding, Sequence Numbers, Freshness, and Replay Protection">

<section anchor="message-binding" title="Message Binding">

<t>In order to prevent response delay and mismatch attacks <xref target="CoAP-Actuators"/> from on-path attackers and compromised intermediaries, OSCORE binds responses to the requests by including the 'kid' and Partial IV of the request in the AAD of the response. Therefore, the server needs to store the 'kid' and Partial IV of the request until all responses have been sent.</t>

</section>
<section anchor="nonce-uniqueness" title="Sequence Numbers">

<t>An AEAD nonce MUST NOT be used more than once per AEAD key. The uniqueness of (key, nonce) pairs is shown in <xref target="kn-uniqueness"/>, and in particular depends on a correct usage of Partial IVs (which encode the Sender Sequence Numbers, see <xref target="cose-object"/>). If messages are processed concurrently, the operation of reading and increasing the Sender Sequence Number MUST be atomic.</t>

<section anchor="max-seq" title="Maximum Sequence Number">

<t>The maximum Sender Sequence Number is algorithm dependent (see
<xref target="sec-considerations"/>) and SHALL be less than 2^40. If
the Sender Sequence Number exceeds the maximum, the endpoint MUST NOT
process any more messages with the given Sender Context. If necessary,
the endpoint SHOULD acquire a new security context before this
happens. The latter is out of scope of this document.</t>

</section>
</section>
<section anchor="freshness" title="Freshness">

<t>For requests, OSCORE provides only the guarantee that the request
is not older than the security context. For applications having
stronger demands on request freshness (e.g., control of actuators),
OSCORE needs to be augmented with mechanisms providing freshness (for
example, as specified in <xref target="CoAP-ECHO-REQ-TAG"/>).</t>

<t>Assuming an honest server (see <xref
target="overview-sec-properties"/>), the message binding guarantees
that a response is not older than its request. For responses that are
not notifications (i.e., when there is a single response to a
request), this gives absolute freshness. For notifications, the
absolute freshness gets weaker with time, and it is RECOMMENDED that
the client regularly re-register the observation. Note that the
message binding does not guarantee that a misbehaving server created the
response before receiving the request, i.e., it does not verify server
aliveness.</t>

<t>For requests and notifications, OSCORE also provides relative freshness in the sense that the received Partial IV allows a recipient to determine the relative order of requests or responses.</t>

</section>
<section anchor="replay-protection" title="Replay Protection">


  
<t>In order to protect from replay of requests, the server's Recipient
Context includes a Replay Window.


A server SHALL verify that the
Sender Sequence Number received in the 'Partial IV' parameter of the
COSE object (see <xref target="obj-sec-value"/>) has
not been received before.
If this verification fails, the server SHALL stop
processing the message, and it MAY optionally respond with a 4.01
(Unauthorized) error message. Also, the server MAY set an Outer
Max-Age option with value zero to inform any intermediary that the
response is not to be cached. The diagnostic payload MAY contain the
string "Replay detected". The size and type of the Replay Window
depends on the use case and the protocol with which the OSCORE message
is transported. In case of reliable and ordered transport from
endpoint to endpoint, e.g., TCP, the server MAY just store the last
received Partial IV and require that newly received Partial IVs equal
the last received Partial IV + 1. However, in the case of mixed
reliable and unreliable transports and where messages may be lost,
such a replay mechanism may be too restrictive and the default replay
window may be more suitable (see <xref target="initial-replay"/>).</t>




<t>Responses (with or without Partial IV) are protected against replay as they are bound to the request and the fact that only a single response is accepted. In this case the Partial IV is not used for replay protection of responses.</t>

<t>The operation of validating the Partial IV and updating the replay protection MUST be atomic.</t>

<section anchor="replay-notifications" title="Replay Protection of Notifications">

<t>The following applies additionally when the Observe option is supported.</t>


<t>The Notification Number (see <xref target="notifications"/>)
is initialized to the Partial IV of the
first successfully verified notification in response to the
registration request. A client MUST only accept at most one Observe
notification without Partial IV, and treat it as the oldest
notification received. A client receiving a notification containing a
Partial IV SHALL compare the Partial IV with the Notification Number
associated to that Observe registration. The client MUST stop
processing notifications with a Partial IV that has been previously
received. Applications MAY decide that a client only processes
notifications that have a greater Partial IV than the Notification
Number.</t>

<t>If the verification of the response succeeds, and the received
Partial IV was greater than the Notification Number, then the client
SHALL overwrite the corresponding Notification Number with the
received Partial IV.</t>

</section>
</section>
<section anchor="context-state" title="Losing Part of the Context State">



<t>To prevent reuse of an AEAD nonce with the same AEAD key or the
acceptance of replayed messages, an endpoint needs to handle the situation
of losing rapidly changing parts of the context, such as the Sender
Sequence Number and Replay Window. These are typically stored in RAM
and therefore lost in the case of, e.g., an unplanned reboot. There are
different alternatives to recover, for example:</t>

<t><list style="numbers">
  <t>The endpoints can reuse an existing Security Context after
  updating the mutable parts of the security context (Sender Sequence
  Number and Replay Window). This requires that the mutable parts of
  the security context are available throughout the lifetime of the
  device or that the device can establish a fresh security context after
  loss of mutable security context data. Examples are given based on
  careful use of nonvolatile memory, see <xref target="seq-numb"/>
  and the use of the Echo option, see <xref
  target="reboot-replay"/>. If an endpoint makes use of a partial
  security context stored in nonvolatile memory, it MUST NOT reuse a
  previous Sender Sequence Number and MUST NOT accept previously
  received messages.</t>

  
  <t>The endpoints can reuse an existing shared Master Secret and
  derive new Sender and Recipient Contexts, see <xref
  target="master-secret-multiple"/> for an example. This typically
  requires a good source of randomness.</t>
  <t>The endpoints can use a trusted third-party-assisted key establishment
  protocol such as <xref target="OSCORE-PROFILE"/>. This requires the
  execution of a three-party protocol and may require a good source of randomness.</t>
  <t>The endpoints can run a key exchange protocol providing forward secrecy resulting in a fresh Master Secret, from which an entirely new Security Context is derived. This requires a good source of randomness, and additionally, the transmission and processing of the protocol may have a non-negligible cost, e.g., in terms of power consumption.</t>
</list></t>

<t>The endpoints need to be configured with information about which method is used. The choice of method may depend on capabilities of the devices deployed and the solution architecture. Using a key exchange protocol is necessary for deployments that require forward secrecy.</t>

</section>
</section>
<section anchor="processing" title="Processing">

<t>This section describes the OSCORE message processing. Additional processing for Observe or Block-wise are described in subsections.</t>

<t>Note that, analogously to <xref target="RFC7252"/> where the Token
and source/destination pair are used to match a response with a
request, both endpoints MUST keep the association (Token, {Security
Context, Partial IV of the request}), in order to be able to find the
Security Context and compute the AAD to protect or verify the
response. The association MAY be forgotten after it has been used to
successfully protect or verify the response, with the exception of
Observe processing, where the association MUST be kept as long as the
Observation is active.</t>

<t>The processing of the Sender Sequence Number follows the procedure
described in Section 3 of <xref target="IV-GEN"/>.</t>

<section anchor="prot-req" title="Protecting the Request">

<t>Given a CoAP request, the client SHALL perform the following steps to create an OSCORE request:</t>

<t><list style="numbers">
  <t>Retrieve the Sender Context associated with the target resource.</t>
  <t>Compose the AAD and the plaintext, as described in Sections <xref target="plaintext" format="counter"/> and <xref target="AAD" format="counter"/>.</t>
  <t>Encode the Partial IV (Sender Sequence Number in network byte order) and increment the Sender Sequence Number by one. Compute the AEAD nonce from the Sender ID, Common IV, and Partial IV as described in <xref target="nonce"/>.</t>
  <t>Encrypt the COSE object using the Sender Key.&nbsp;Compress the COSE object as specified in <xref target="compression"/>.</t>
  <t>Format the OSCORE message according to <xref target="protected-fields"/>. The OSCORE option is added (see <xref target="outer-options"/>).</t>
</list></t>

</section>
<section anchor="ver-req" title="Verifying the Request">

<t>A server receiving a request containing the OSCORE option SHALL perform the following steps:</t>

<t><list style="numbers">
  <t>Discard Code and all Class E options (marked in <xref target="fig-option-protection"/> with 'x' in column E) present in the received message. For example, an If-Match Outer option is discarded, but an Uri-Host Outer option is not discarded.</t>


  <t>Decompress the COSE object (<xref target="compression"/>) and retrieve the Recipient Context associated with the Recipient ID in the 'kid' parameter, additionally using the 'kid context', if present. Note that the Recipient Context MAY be retrieved by deriving a new security context, e.g. as described in <xref target="master-secret-multiple"/>. If either the decompression or the COSE message fails to decode, or the server fails to retrieve a Recipient Context with Recipient ID corresponding to the 'kid' parameter received, then the server SHALL stop processing the request.  <list style="symbols">
      <t>If either the decompression or the COSE message fails to decode, the server MAY respond with a 4.02 (Bad Option) error message. The server MAY set an Outer Max-Age option with value zero. The diagnostic payload MAY contain the string "Failed to decode COSE".</t>
      <t>If the server fails to retrieve a Recipient Context with Recipient ID corresponding to the 'kid' parameter received, the server MAY respond with a 4.01 (Unauthorized) error message. The server MAY set an Outer Max-Age option with value zero. The diagnostic payload MAY contain the string "Security context not found".</t>
    </list></t>

  <t>Verify that the Partial IV has not been received before using the Replay Window, as described in <xref target="replay-protection"/>.</t>
  <t>Compose the AAD, as described in <xref target="AAD"/>.</t>
  <t>Compute the AEAD nonce from the Recipient ID, Common IV, and the Partial IV, received in the COSE object.</t>
  <t>Decrypt the COSE object using the Recipient Key, as per Section 5.3 of <xref target="RFC8152"/>. (The decrypt operation includes the verification of the integrity.)  <list style="symbols">
      <t>If decryption fails, the server MUST stop processing the request and MAY respond with a 4.00 (Bad Request) error message. The server MAY set an Outer Max-Age option with value zero. The diagnostic payload MAY contain the string "Decryption failed".</t>
      <t>If decryption succeeds, update the Replay Window, as described in <xref target="sequence-numbers"/>.</t>
  </list></t>

  <t>Add decrypted Code, options, and payload to the decrypted request. The OSCORE option is removed.</t>
  <t>The decrypted CoAP request is processed according to <xref target="RFC7252"/>.</t>
</list></t>

<section anchor="supporting-block-wise" title="Supporting Block-wise">

<t>If Block-wise is supported, insert the following step before any other:</t>

<t>A.  If Block-wise is present in the request, then process the Outer Block options according to <xref target="RFC7959"/>, until all blocks of the request have been received (see <xref target="block-options"/>).</t>

</section>
</section>
<section anchor="prot-res" title="Protecting the Response">

<t>If a CoAP response is generated in response to an OSCORE request, the server SHALL perform the following steps to create an OSCORE response. Note that CoAP error responses derived from CoAP processing (step 8 in <xref target="ver-req"/>) are protected, as well as successful CoAP responses, while the OSCORE errors (steps 2, 3, and 6 in <xref target="ver-req"/>) do not follow the processing below but are sent as simple CoAP responses, without OSCORE processing.</t>

<t><list style="numbers">
  <t>Retrieve the Sender Context in the Security Context associated with the Token.</t>
  <t>Compose the AAD and the plaintext, as described in Sections <xref target="plaintext" format="counter"/> and <xref target="AAD" format="counter"/>.</t>
  <t>Compute the AEAD nonce as described in <xref target="nonce"/>:  <list style="symbols">
      <t>Either use the AEAD nonce from the request, or</t>
      <t>Encode the Partial IV (Sender Sequence Number in network byte order) and increment the Sender Sequence Number by one. Compute the AEAD nonce from the Sender ID, Common IV, and Partial IV.</t>
    </list></t>
  <t>Encrypt the COSE object using the Sender Key.&nbsp;Compress the COSE object as specified in <xref target="compression"/>. If the AEAD nonce was constructed from a new Partial IV, this Partial IV MUST be included in the message. If the AEAD nonce from the request was used, the Partial IV MUST NOT be included in the message.</t>
  <t>Format the OSCORE message according to <xref target="protected-fields"/>. The OSCORE option is added (see <xref target="outer-options"/>).</t>
</list></t>

<section anchor="observe-prot-res" title="Supporting Observe">

<t>If Observe is supported, insert the following step between steps 2 and 3 of <xref target="prot-res"/>:</t>

<t>A. If the response is an Observe notification:</t>

<t><list style="symbols">
  <t>If the response is the first notification:
  <list style="symbols">
      <t>compute the AEAD nonce as described in <xref target="nonce"/>:
      <list style="symbols">
          <t>Either use the AEAD nonce from the request, or</t>
          <t>Encode the Partial IV (Sender Sequence Number in network byte order) and increment the Sender Sequence Number by one. Compute the AEAD nonce from the Sender ID, Common IV, and Partial IV.</t>
        </list>
Then, go to 4.</t>
    </list></t>
  <t>If the response is not the first notification:
  <list style="symbols">
      <t>encode the Partial IV (Sender Sequence Number in network byte order) and increment the Sender Sequence Number by one. Compute the AEAD nonce from the Sender ID, Common IV, and Partial IV, then go to 4.</t>
    </list></t>
</list></t>

</section>
</section>
<section anchor="ver-res" title="Verifying the Response">

<t>A client receiving a response containing the OSCORE option SHALL perform the following steps:</t>

<t><list style="numbers">
  <t>Discard Code and all Class E options (marked in <xref target="fig-option-protection"/> with 'x' in column E) present in the received message. For example, ETag Outer option is discarded, as well as Max-Age Outer option.</t>
  <t>Retrieve the Recipient Context in the Security Context associated with the Token. Decompress the COSE object (<xref target="compression"/>). If either the decompression or the COSE message fails to decode, then go to 8.</t>
  <t>Compose the AAD, as described in <xref target="AAD"/>.</t>
  <t>Compute the AEAD nonce  <list style="symbols">
      <t>If the Partial IV is not present in the response, the AEAD nonce from the request is used.</t>
      <t>If the Partial IV is present in the response, compute the AEAD nonce from the Recipient ID, Common IV, and the Partial IV, received in the COSE object.</t>
    </list></t>
  <t>Decrypt the COSE object using the Recipient Key, as per Section 5.3 of <xref target="RFC8152"/>. (The decrypt operation includes the verification of the integrity.) If decryption fails, then go to 8.</t>
  <t>Add decrypted Code, options and payload to the decrypted request. The OSCORE option is removed.</t>
  <t>The decrypted CoAP response is processed according to <xref target="RFC7252"/>.</t>
  <t>In case any of the previous erroneous conditions apply: the client SHALL stop processing the response.</t>
</list></t>

<section anchor="supporting-block-wise-1" title="Supporting Block-wise">

<t>If Block-wise is supported, insert the following step before any other:</t>



<t>A.  If Block-wise is present in the response, then process the Outer Block options according to <xref target="RFC7959"/>, until all blocks of the response have been received (see <xref target="block-options"/>).</t>

</section>
<section anchor="observe-ver-res" title="Supporting Observe">

<t>If Observe is supported:</t>

<t>Insert the following step between step 5 and step 6:</t>

<t>A. If the request was an Observe registration, then:</t>

<t><list style="symbols">
  <t>If the Partial IV is not present in the response, and the Inner Observe option is present, and the AEAD nonce from the request was already used once, then go to 8.</t>
  <t>If the Partial IV is present in the response and the Inner Observe option is present, then follow the processing described in <xref target="notifications"/> and <xref target="replay-notifications"/>, then:  <list style="symbols">
      <t>initialize the Notification Number (if first successfully verified notification), or</t>
      <t>overwrite the Notification Number (if the received Partial IV was greater than the Notification Number).</t>
    </list></t>
</list></t>

<t>Replace step 8 of <xref target="ver-res"/> with:</t>

<t>B. In case any of the previous erroneous conditions apply: the client SHALL stop processing the response. An error condition occurring while processing a response to an observation request does not cancel the observation. A client MUST NOT react to failure by re-registering the observation immediately.</t>

</section>
</section>
</section>
<section anchor="web-linking" title="Web Linking">

<t>The use of OSCORE MAY be indicated by a target "osc" attribute in a web link <xref target="RFC8288"/> to a resource, e.g., using a link-format document <xref target="RFC6690"/> if the resource is accessible over CoAP.</t>

<t>The "osc" attribute is a hint indicating that the destination of that link is only accessible using OSCORE, and unprotected access to it is not supported. Note that this is simply a hint, it does not include any security context material or any other information required to run OSCORE.</t>

<t>A value MUST NOT be given for the "osc" attribute; any present value MUST be ignored by parsers. The "osc" attribute MUST NOT appear more than once in a given link-value; occurrences after the first MUST be ignored by parsers.</t>

<t>The example in <xref target="fig-web-link"/> shows a use of the "osc" attribute: the client does resource discovery on a server and gets back a list of resources, one of which includes the "osc" attribute indicating that the resource is protected with OSCORE. The link-format notation (see Section 5 of <xref target="RFC6690"/>) is used.</t>

<figure title="The Web Link" anchor="fig-web-link"><artwork align="center"><![CDATA[
REQ: GET /.well-known/core

RES: 2.05 Content
   </sensors/temp>;osc,
   </sensors/light>;if="sensor"
]]></artwork></figure>

</section>
<section anchor="coap-coap-proxy" title="CoAP-to-CoAP Forwarding Proxy">

<t>CoAP is designed for proxy operations (see Section 5.7 of <xref target="RFC7252"/>).</t>

<t>OSCORE is designed to work with OSCORE-unaware CoAP proxies. Security requirements for forwarding are listed in Section 2.2.1 of <xref target="CoAP-E2E-Sec"/>. Proxy processing of the (Outer) Proxy-Uri option works as defined in <xref target="RFC7252"/>. Proxy processing of the (Outer) Block options works as defined in <xref target="RFC7959"/>.</t>

<t>However, not all CoAP proxy operations are useful:</t>

<t><list style="symbols">
  <t>Since a CoAP response is only applicable to the original CoAP request, caching is in general not useful. In support of existing proxies, OSCORE uses the Outer Max-Age option, see <xref target="max-age"/>.</t>
  <t>Proxy processing of the (Outer) Observe option as defined in <xref target="RFC7641"/> is specified in <xref target="observe"/>.</t>
</list></t>

<t>Optionally, a CoAP proxy MAY detect OSCORE and act accordingly. An OSCORE-aware CoAP proxy:</t>

<t><list style="symbols">
  <t>SHALL bypass caching for the request if the OSCORE option is present.</t>
  <t>SHOULD avoid caching responses to requests with an OSCORE option.</t>
</list></t>

<t>In the case of Observe (see <xref target="observe"/>), the OSCORE-aware CoAP proxy:</t>

<t><list style="symbols">
  <t>SHALL NOT initiate an Observe registration.</t>
  <t>MAY verify the order of notifications using Partial IV rather than the Observe option.</t>
</list></t>

</section>
<section anchor="http-op" title="HTTP Operations">

<t>The CoAP request/response model may be mapped to HTTP and vice versa as described in Section 10 of <xref target="RFC7252"/>. The HTTP-CoAP mapping is further detailed in <xref target="RFC8075"/>. This section defines the components needed to map and transport OSCORE messages over HTTP hops. By mapping between HTTP and CoAP and by using cross-protocol proxies, OSCORE may be used end-to-end between, e.g., an HTTP client and a CoAP server. Examples are provided in Sections <xref target="example-http-client-and-coap-server" format="counter"/> and <xref target="example-coap-client-and-http-server" format="counter"/>.</t>

<section anchor="header-field" title="The HTTP OSCORE Header Field">

<t>The HTTP OSCORE header field (see <xref target="iana-http"/>) is used for carrying the content of the CoAP OSCORE option when transporting OSCORE messages over HTTP hops.</t>

<t>The HTTP OSCORE header field is only used in POST requests and responses
  with HTTP Status Code 200 (OK). When used, the HTTP header field Content-Type is set to 'application/oscore' (see <xref target="oscore-media-type"/>) indicating that the HTTP body of this message contains the OSCORE payload (see <xref target="oscore-payl"/>). No additional semantics are provided by other message fields.</t>

<t>Using the Augmented Backus-Naur Form (ABNF) notation of <xref target="RFC5234"/>, including the following core ABNF syntax rules defined by that specification: ALPHA (letters) and DIGIT (decimal digits), the HTTP OSCORE header field value is as follows.</t>

<figure><artwork type="abnf"><![CDATA[
base64url-char = ALPHA / DIGIT / "-" / "_"

OSCORE = 2*base64url-char
]]></artwork></figure>

<t>The HTTP OSCORE header field is not appropriate to list in the Connection header field (see Section 6.1 of <xref target="RFC7230"/>) since it is not hop-by-hop. OSCORE messages are generally not useful when served from cache (i.e., they will generally be marked Cache-Control: no-cache) and so interaction with Vary is not relevant (Section 7.1.4 of <xref target="RFC7231"/>). Since the HTTP OSCORE header field is critical for message processing, moving it from headers to trailers renders the message unusable in case trailers are ignored (see Section 4.1 of <xref target="RFC7230"/>).</t>

<t>In general, intermediaries are not allowed to insert, delete, or modify the OSCORE header. In general, changes to the HTTP OSCORE header field will violate the integrity of the OSCORE message resulting in an error. For the same reason the HTTP OSCORE header field is generally not preserved across redirects.</t>

<t>Since redirects are not defined in the mappings between HTTP and CoAP (<xref target="RFC8075"/> <xref target="RFC7252"/>), a number of conditions need to be fulfilled for redirects to work. For CoAP-client-to-HTTP-server redirects, such conditions include:</t>

<t><list style="symbols">
  <t>the CoAP-to-HTTP proxy follows the redirect, instead of the CoAP client as in the HTTP case.</t>
  <t>the CoAP-to-HTTP proxy copies the HTTP OSCORE header field and body to the new request.</t>
  <t>the target of the redirect has the necessary OSCORE security context required to decrypt and verify the message.</t>
</list></t>

<t>Since OSCORE requires the HTTP body to be preserved across redirects, the HTTP server is RECOMMENDED to reply with 307 (Temporary Redirect) or 308 (Permanent Redirect) instead of 301 (Moved Permanently) or 302 (Found).</t>

<t>For the case of HTTP-client-to-CoAP-server redirects, although redirect is not defined for CoAP servers <xref target="RFC7252"/>, an HTTP client receiving a redirect should generate a new OSCORE request for the server it was redirected to.</t>

</section>
<section anchor="coap2http" title="CoAP-to-HTTP Mapping">

<t>Section 10.1 of <xref target="RFC7252"/> describes the fundamentals of the CoAP-to-HTTP cross-protocol mapping process. The additional rules for OSCORE messages are as follows:</t>

<t><list style="symbols">
  <t>The HTTP OSCORE header field value is set to:  <list style="symbols">
      <t>AA if the CoAP OSCORE option is empty; otherwise,</t>
      <t>the value of the CoAP OSCORE option (<xref target="obj-sec-value"/>) in base64url (Section 5 of <xref target="RFC4648"/>) encoding without padding. Implementation notes for this encoding are given in Appendix C of <xref target="RFC7515"/>.</t>
    </list></t>
  <t>The HTTP Content-Type is set to 'application/oscore' (see <xref target="oscore-media-type"/>), independent of CoAP Content-Format.</t>
</list></t>

</section>
<section anchor="http2coap" title="HTTP-to-CoAP Mapping">

<t>Section 10.2 of <xref target="RFC7252"/> and <xref target="RFC8075"/> specify the behavior of an HTTP-to-CoAP proxy. 
The additional rules for HTTP messages with the OSCORE header field are as follows.</t>

<t><list style="symbols">
  <t>The CoAP OSCORE option is set as follows:  <list style="symbols">
      <t>empty if the value of the HTTP OSCORE header field is a single zero byte (0x00) represented by AA; otherwise,</t>
      <t>the value of the HTTP OSCORE header field decoded from base64url (Section 5 of <xref target="RFC4648"/>) without padding. Implementation notes for this encoding are given in Appendix C of <xref target="RFC7515"/>.</t>
    </list></t>
  <t>The CoAP Content-Format option is omitted, the content format for OSCORE (<xref target="content-format"/>) MUST NOT be used.</t>
</list></t>

</section>
<section anchor="http-endpoints" title="HTTP Endpoints">

<t>Restricted to subsets of HTTP and CoAP supporting a bijective mapping, OSCORE can be originated or terminated in HTTP endpoints.</t>

<t>The sending HTTP endpoint uses <xref target="RFC8075"/> to translate the HTTP message into a CoAP message. The CoAP message is then processed with OSCORE as defined in this document. The OSCORE message is then mapped to HTTP as described in <xref target="coap2http"/> and sent in compliance with the rules in <xref target="header-field"/>.</t>

<t>The receiving HTTP endpoint maps the HTTP message to a CoAP message using <xref target="RFC8075"/> and <xref target="http2coap"/>. The resulting OSCORE message is processed as defined in this document. If successful, the plaintext CoAP message is translated to HTTP for normal processing in the endpoint.</t>

</section>
<section anchor="example-http-client-and-coap-server" title="Example: HTTP Client and CoAP Server">

<t>This section gives an example of what a request and a response
between an HTTP client and a CoAP server could look like. The example
is not a test vector but intended as an illustration of how the
message fields are translated in the different steps.</t>

<t>Mapping and notation here is based on "Simple Form" (Section 5.4.1
of <xref target="RFC8075"/>).</t>

<figure><artwork><![CDATA[
[HTTP request -- Before client object security processing]

  GET http://proxy.url/hc/?target_uri=coap://server.url/orders 
   HTTP/1.1
]]></artwork></figure>

<figure><artwork><![CDATA[
[HTTP request -- HTTP Client to Proxy]

  POST http://proxy.url/hc/?target_uri=coap://server.url/ HTTP/1.1
  Content-Type: application/oscore
  OSCORE: CSU
  Body: 09 07 01 13 61 f7 0f d2 97 b1 [binary]
]]></artwork></figure>

<figure><artwork><![CDATA[
[CoAP request -- Proxy to CoAP Server]

  POST coap://server.url/
  OSCORE: 09 25
  Payload: 09 07 01 13 61 f7 0f d2 97 b1 [binary]
]]></artwork></figure>

<figure><artwork><![CDATA[
[CoAP request -- After server object security processing]

  GET coap://server.url/orders 
]]></artwork></figure>

<figure><artwork><![CDATA[
[CoAP response -- Before server object security processing]

  2.05 Content
  Content-Format: 0
  Payload: Exterminate! Exterminate!
]]></artwork></figure>

<figure><artwork><![CDATA[
[CoAP response -- CoAP Server to Proxy]

  2.04 Changed
  OSCORE: [empty]
  Payload: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary]
]]></artwork></figure>

<figure><artwork><![CDATA[
[HTTP response -- Proxy to HTTP Client]

  HTTP/1.1 200 OK
  Content-Type: application/oscore
  OSCORE: AA 
  Body: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary]
]]></artwork></figure>

<figure><artwork><![CDATA[
[HTTP response -- After client object security processing]

  HTTP/1.1 200 OK
  Content-Type: text/plain
  Body: Exterminate! Exterminate!
]]></artwork></figure>



<t>Note that the HTTP Status Code 200 (OK) in the next-to-last message is the mapping of CoAP Code 2.04 (Changed), whereas the HTTP Status Code 200 (OK) in the last message is the mapping of the CoAP Code 2.05 (Content), which was encrypted within the compressed COSE object carried in the Body of the HTTP response.</t>

</section>
<section anchor="example-coap-client-and-http-server" title="Example: CoAP Client and HTTP Server">

<t>This section gives an example of what a request and a response between a CoAP client and an HTTP server could look like.  The example is not a test vector but intended as an illustration of how the message fields are translated in the different steps.</t>

<figure><artwork><![CDATA[
[CoAP request -- Before client object security processing]

  GET coap://proxy.url/
  Proxy-Uri=http://server.url/orders
]]></artwork></figure>

<figure><artwork><![CDATA[
[CoAP request -- CoAP Client to Proxy]

  POST coap://proxy.url/
  Proxy-Uri=http://server.url/
  OSCORE: 09 25
  Payload: 09 07 01 13 61 f7 0f d2 97 b1 [binary]
]]></artwork></figure>

<figure><artwork><![CDATA[
[HTTP request -- Proxy to HTTP Server]

  POST http://server.url/ HTTP/1.1
  Content-Type: application/oscore
  OSCORE: CSU
  Body: 09 07 01 13 61 f7 0f d2 97 b1 [binary]
]]></artwork></figure>

<figure><artwork><![CDATA[
[HTTP request -- After server object security processing]

  GET http://server.url/orders HTTP/1.1
]]></artwork></figure>

<figure><artwork><![CDATA[
[HTTP response -- Before server object security processing]

  HTTP/1.1 200 OK
  Content-Type: text/plain
  Body: Exterminate! Exterminate!
]]></artwork></figure>

<figure><artwork><![CDATA[
[HTTP response -- HTTP Server to Proxy]

  HTTP/1.1 200 OK
  Content-Type: application/oscore
  OSCORE: AA
  Body: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary]
]]></artwork></figure>

<figure><artwork><![CDATA[
[CoAP response -- Proxy to CoAP Client]

  2.04 Changed
  OSCORE: [empty]
  Payload: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary]
]]></artwork></figure>

<figure><artwork><![CDATA[
[CoAP response -- After client object security processing]

  2.05 Content
  Content-Format: 0
  Payload: Exterminate! Exterminate!
]]></artwork></figure>

<t>Note that the HTTP Code 2.04 (Changed) in the next-to-last message is the mapping of HTTP Status Code 200 (OK), whereas the CoAP Code 2.05 (Content) in the last message is the value that was encrypted within the compressed COSE object carried in the Body of the HTTP response.</t>

</section>
</section>
<section anchor="sec-considerations" title="Security Considerations">

<t>An overview of the security properties is given in <xref target="overview-sec-properties"/>.</t>

<section anchor="end-to-end-protection" title="End-to-end Protection">

<t>In scenarios with intermediary nodes such as proxies or gateways, transport layer security such as (D)TLS only protects data hop-by-hop. As a consequence, the intermediary nodes can read and modify any information. The trust model where all intermediary nodes are considered trustworthy is problematic, not only from a privacy perspective, but also from a security perspective, as the intermediaries are free to delete resources on sensors and falsify commands to actuators (such as "unlock door", "start fire alarm", "raise bridge"). Even in the rare cases where all the owners of the intermediary nodes are fully trusted, attacks and data breaches make such an architecture brittle.</t>

<t>(D)TLS protects hop-by-hop the entire message. OSCORE protects end-to-end all information that is not required for proxy operations (see <xref target="protected-fields"/>). (D)TLS and OSCORE can be combined, thereby enabling end-to-end security of the message payload, in combination with hop-by-hop protection of the entire message, during transport between endpoint and intermediary node. In particular, when OSCORE is used with HTTP, the additional TLS protection of HTTP hops is RECOMMENDED, e.g., between an HTTP endpoint and a proxy translating between HTTP and CoAP.</t>

<t>Applications need to consider that certain message fields and messages types are not protected end-to-end and may be spoofed or manipulated. The consequences of unprotected message fields are analyzed in <xref target="unprot-fields"/>.</t>

</section>
<section anchor="sec-context-establish" title="Security Context Establishment">

<t>The use of COSE_Encrypt0 and AEAD to protect messages as specified in this document requires an established security context. The method to establish the security context described in <xref target="context-derivation"/> is based on a common Master Secret and unique Sender IDs. The necessary input parameters may be preestablished or obtained using a key establishment protocol augmented with establishment of Sender/Recipient ID, such as a key exchange protocol or the OSCORE profile of the Authentication and
Authorization for Constrained Environments (ACE) framework <xref target="OSCORE-PROFILE"/>.  Such a procedure must ensure that the requirements of the security context parameters for the intended use are complied with (see <xref target="req-params"/>) even in error situations. While recipient IDs are allowed to coincide between different security contexts (see <xref target="req-params"/>), this may cause a server to process multiple verifications before finding the right security context or rejecting a message. Considerations for deploying OSCORE with a fixed Master Secret are given in <xref target="deployment-examples"/>.</t>

</section>
<section anchor="master-secret" title="Master Secret">

<t>OSCORE uses HKDF <xref target="RFC5869"/> and the established input
parameters to derive the security context. The required properties of
the security context parameters are discussed in <xref
target="req-params"/>; in this section, we focus on the Master
Secret. In this specification, HKDF denotes the composition of the
expand and extract functions as defined in <xref target="RFC5869"/>
and the Master Secret is used as Input Keying Material (IKM).</t>


<t>Informally, HKDF takes as source an IKM containing some good amount of randomness but not necessarily distributed uniformly (or for which an attacker has some partial knowledge) and derive from it one or more cryptographically strong secret keys <xref target="RFC5869"/>.</t>

<t>Therefore, the main requirement for the OSCORE Master Secret, in addition to being secret, is that it have a good amount of randomness. The selected key establishment schemes must ensure that the necessary properties for the Master Secret are fulfilled. For pre-shared key deployments and key transport solutions such as <xref target="OSCORE-PROFILE"/>, the Master Secret can be generated offline using a good random number generator. Randomness requirements for security are described in <xref target="RFC4086"/>.</t>

</section>
<section anchor="replay-protection2" title="Replay Protection">

<t>Replay attacks need to be considered in different parts of the
implementation. Most AEAD algorithms require a unique nonce for each
message, for which the Sender Sequence Numbers in the COSE message
field 'Partial IV' is used. If the recipient accepts any sequence
number larger than the one previously received, then the problem of
sequence number synchronization is avoided. With reliable transport,
it may be defined that only messages with sequence numbers that are
equal to the previous sequence number + 1 are accepted. An adversary may
try to induce a device reboot for the purpose of replaying a message
(see <xref target="context-state"/>).</t>

<t>Note that sharing a security context between servers may open up for replay attacks, for example, if the Replay Windows are not synchronized.</t>

</section>
<section anchor="client-aliveness" title="Client Aliveness">

<t>A verified OSCORE request enables the server to verify the identity
of the entity who generated the message. However, it does not verify
that the client is currently involved in the communication, since the
message may be a delayed delivery of a previously generated request,
which now reaches the server. To verify the aliveness of the client
the server may use the Echo option in the response to a request from
the client (see <xref target="CoAP-ECHO-REQ-TAG"/>).</t>

</section>
<section anchor="cryptographic-considerations" title="Cryptographic Considerations">

<t>The maximum Sender Sequence Number is dependent on the AEAD
algorithm. The maximum Sender Sequence Number is 2^40 - 1, or any
algorithm-specific lower limit, after which a new security context
must be generated. The mechanism to build the AEAD nonce (<xref
target="nonce"/>) assumes that the nonce is at least 56 bits, and the
Partial IV is at most 40 bits. The mandatory-to-implement AEAD
algorithm AES-CCM-16-64-128 is selected for compatibility with
CCM*. AEAD algorithms that require unpredictable nonces are not
supported.</t>

<t>In order to prevent cryptanalysis when the same plaintext is
repeatedly encrypted by many different users with distinct AEAD keys,
the AEAD nonce is formed by mixing the sequence number with a secret
per-context initialization vector (Common IV) derived along with the
keys (see Section 3.1 of <xref target="RFC8152"/>), and by using a
Master Salt in the key derivation (see <xref target="MF00"/> for an
overview). The Master Secret, Sender Key, Recipient Key, and Common IV
must be secret, the rest of the parameters may be public. The Master
Secret must have a good amount of randomness (see <xref
target="master-secret"/>).</t>

<t>The ID Context, Sender ID, and Partial IV are always at least implicitly integrity protected, as manipulation leads to the wrong nonce or key being used and therefore results in decryption failure.</t>

</section>
<section anchor="message-segmentation" title="Message Segmentation">

<t>The Inner Block options enable the sender to split large messages
into OSCORE-protected blocks such that the receiving endpoint can
verify blocks before having received the complete message. The Outer
Block options allow for arbitrary proxy fragmentation operations that
cannot be verified by the endpoints but that can, by policy, be
restricted in size since the Inner Block options allow for secure
fragmentation of very large messages. A maximum message size (above
which the sending endpoint fragments the message and the receiving
endpoint discards the message, if complying to the policy) may be
obtained as part of normal resource discovery.</t>

</section>
<section anchor="priv-cons" title="Privacy Considerations">

<t>Privacy threats executed through intermediary nodes are
considerably reduced by means of OSCORE. End-to-end integrity
protection and encryption of the message payload and all options that
are not used for proxy operations provide mitigation against attacks
on sensor and actuator communication, which may have a direct impact
on the personal sphere.</t>

<t>The unprotected options (<xref target="fig-option-protection"/>)
may reveal privacy-sensitive information, see <xref
target="unprot-fields"/>. CoAP headers sent in plaintext allow, for
example, matching of CON and ACK (CoAP Message Identifier), matching
of request and responses (Token) and traffic analysis. OSCORE does not
provide protection for HTTP header fields that are not both
CoAP-mappable and Class E. The HTTP message fields that are visible
to on-path entities are only used for the purpose of transporting the
OSCORE message, whereas the application-layer message is encoded in
CoAP and encrypted.</t>

<t>COSE message fields, i.e., the OSCORE option, may reveal
information about the communicating endpoints. For example, 'kid' and
'kid context', which are intended to help the server find the right
context, may reveal information about the client. Tracking 'kid' and
'kid context' to one server may be used for correlating requests from
one client.</t>

<t>Unprotected error messages reveal information about the security
state in the communication between the endpoints. Unprotected
signaling messages reveal information about the reliable transport
used on a leg of the path. Using the mechanisms described in <xref
target="context-state"/> may reveal when a device goes through a
reboot. This can be mitigated by the device storing the precise state
of Sender Sequence Number and Replay Window on a clean shutdown.</t>

<t>The length of message fields can reveal information about the
message. Applications may use a padding scheme to protect against
traffic analysis.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<section anchor="cose-header-parameters-registry" title="COSE Header Parameters Registry">

<t>The 'kid context' parameter has been added to the "COSE Header Parameters" registry:</t>

<t><list style="symbols">
  <t>Name: kid context</t>
  <t>Label: 10</t>
  <t>Value Type: bstr</t>
  <t>Value Registry:</t>
  <t>Description: Identifies the context for the key identifier</t>
  <t>Reference: <xref target="context-hint"/> of this document</t>
</list></t>

</section>
<section anchor="coap-option-numbers-registry" title="CoAP Option Numbers Registry">

<t>The OSCORE option has been added to the "CoAP Option Numbers" registry:</t>

<figure><artwork align="center"><![CDATA[
+--------+-----------------+-------------------+
| Number | Name            | Reference         |
+--------+-----------------+-------------------+
|     9  | OSCORE          | [RFC8613]         |
+--------+-----------------+-------------------+
]]></artwork></figure>


<t>Furthermore, the following existing entries in the "CoAP Option Numbers"
registry have been updated with a reference to the document specifying OSCORE processing of that option:</t>

<figure><artwork align="center"><![CDATA[
+--------+-----------------+-------------------------------+
| Number | Name            |          Reference            |
+--------+-----------------+-------------------------------+
|   1    | If-Match        | [RFC7252] [RFC8613]           |
|   3    | Uri-Host        | [RFC7252] [RFC8613]           | 
|   4    | ETag            | [RFC7252] [RFC8613]           |
|   5    | If-None-Match   | [RFC7252] [RFC8613]           |
|   6    | Observe         | [RFC7641] [RFC8613]           |
|   7    | Uri-Port        | [RFC7252] [RFC8613]           |
|   8    | Location-Path   | [RFC7252] [RFC8613]           |
|  11    | Uri-Path        | [RFC7252] [RFC8613]           |
|  12    | Content-Format  | [RFC7252] [RFC8613]           |
|  14    | Max-Age         | [RFC7252] [RFC8613]           |
|  15    | Uri-Query       | [RFC7252] [RFC8613]           |
|  17    | Accept          | [RFC7252] [RFC8613]           |
|  20    | Location-Query  | [RFC7252] [RFC8613]           |
|  23    | Block2          | [RFC7959] [RFC8323] [RFC8613] |
|  27    | Block1          | [RFC7959] [RFC8323] [RFC8613] |
|  28    | Size2           | [RFC7959] [RFC8613]           |
|  35    | Proxy-Uri       | [RFC7252] [RFC8613]           |
|  39    | Proxy-Scheme    | [RFC7252] [RFC8613]           |
|  60    | Size1           | [RFC7252] [RFC8613]           |
| 258    | No-Response     | [RFC7967] [RFC8613]           |
+--------+-----------------+-------------------------------+
]]></artwork></figure>

<t>Future additions to the "CoAP Option Numbers" registry need to provide a reference to the document where the OSCORE processing of that CoAP Option is defined.</t>

</section>
<section anchor="coap-signaling-option-numbers-registry" title="CoAP Signaling Option Numbers Registry">

<t>The OSCORE option has been added to the "CoAP Signaling Option Numbers" registry:</t>

<figure><artwork align="center"><![CDATA[
+------------+--------+---------------------+-------------------+
| Applies to | Number | Name                | Reference         |
+------------+--------+---------------------+-------------------+
| 7.xx (all) |     9  | OSCORE              | [RFC8613]         |
+------------+--------+---------------------+-------------------+
]]></artwork></figure>


</section>
<section anchor="iana-http" title="Header Field Registrations">

<t>The HTTP OSCORE header field has been added to the "Message Headers" registry:</t>

<figure><artwork align="center"><![CDATA[
+-------------------+----------+----------+---------------------+
| Header Field Name | Protocol | Status   | Reference           |
+-------------------+----------+----------+---------------------+
| OSCORE            | http     | standard | [RFC8613],          |
|                   |          |          | Section 11.1        |
+-------------------+----------+----------+---------------------+
]]></artwork></figure>

</section>
<section anchor="oscore-media-type" title="Media Type Registration">

<t>This section registers the 'application/oscore' media type in the "Media
Types" registry. This media type is used to indicate that the content is an OSCORE message. The OSCORE body cannot be understood without the OSCORE header field value and the security context.</t>

<figure><artwork><![CDATA[
  Type name: application

  Subtype name: oscore

  Required parameters: N/A

  Optional parameters: N/A

  Encoding considerations: binary

  Security considerations: See the Security Considerations section
     of [RFC8613].

  Interoperability considerations: N/A

  Published specification: [RFC8613]

  Applications that use this media type: IoT applications sending
     security content over HTTP(S) transports.

  Fragment identifier considerations: N/A

  Additional information:

  *  Deprecated alias names for this type: N/A
  *  Magic number(s): N/A
  *  File extension(s): N/A
  *  Macintosh file type code(s): N/A

  Person & email address to contact for further information:
     IESG <iesg@ietf.org>

  Intended usage: COMMON

  Restrictions on usage: N/A

  Author: Goeran Selander <goran.selander@ericsson.com>

  Change Controller: IESG

  Provisional registration?  No
]]></artwork></figure>

</section>
<section anchor="content-format" title="CoAP Content-Formats Registry">


<t>This section registers the media type 'application/oscore' media
type in the "CoAP Content-Formats" registry. This Content-Format for
the OSCORE payload is defined for potential future use cases and SHALL
NOT be used in the OSCORE message. The OSCORE payload cannot be
understood without the OSCORE option value and the security
context.</t>

<figure><artwork align="center"><![CDATA[
+----------------------+----------+----------+-------------------+
| Media Type           | Encoding |   ID     |     Reference     |
+----------------------+----------+----------+-------------------+
| application/oscore   |          |  10001   | [RFC8613]         |
+----------------------+----------+----------+-------------------+
]]></artwork></figure>

</section>
<section anchor="oscore-flag-bits" title="OSCORE Flag Bits Registry">

<t>This document defines a subregistry for the OSCORE flag bits within
the "CoRE Parameters" registry. The name of the subregistry is "OSCORE
Flag Bits". The registry has been created with the Expert Review
policy <xref target="RFC8126"/>. Guidelines for the experts are provided in <xref
target="exp-instr"/>.</t>

<t>The columns of the registry are as follows:</t>

<t><list style="symbols">
  <t>Bit Position: This indicates the position of the bit in the set of OSCORE flag bits, starting at 0 for the most significant bit. The bit position must be an integer or a range of integers, in the range 0 to 63.</t>
  <t>Name: The name is present to make it easier to refer to and discuss the registration entry. The value is not used in the protocol. Names are to be unique in the table.</t>
  <t>Description: This contains a brief description of the use of the bit.</t>
  <t>Reference: This contains a pointer to the specification defining the entry.</t>
</list></t>

<t>The initial contents of the registry are in the table below. The reference
column for all rows is this document. The entries with
Bit Position of 0 and 1 are marked as 'Reserved'. The entry with Bit Position
of 1 will be specified in a future document and will be used to expand the space for the OSCORE flag bits in <xref target="obj-sec-value"/>, so that entries 8-63 of the registry are defined.</t>

<figure><artwork align="center"><![CDATA[
+--------------+-------------+-----------------------------+-----------+
| Bit Position | Name        | Description                 | Reference |
+--------------+-------------+-----------------------------+-----------+
|       0      | Reserved    |                             |           |
+--------------+-------------+-----------------------------+-----------+
|       1      | Reserved    |                             |           |
+--------------+-------------+-----------------------------+-----------+
|       2      | Unassigned  |                             |           |
+--------------+-------------+-----------------------------+-----------+
|       3      | Kid Context | Set to 1 if kid context     | [RFC8613] |
|              | Flag        | is present in the           |           |
|              |             | compressed COSE object      |           |
+--------------+-------------+-----------------------------+-----------+
|       4      | Kid Flag    | Set to 1 if kid is present  | [RFC8613] |
|              |             | in the compressed COSE      |           |
|              |             | object                      |           |
+--------------+-------------+-----------------------------+-----------+
|     5-7      | Partial IV  | Encodes the Partial IV      | [RFC8613] |
|              | Length      | length; can have value      |           |
|              |             | 0 to 5                      |           |
+--------------+-------------+-----------------------------+-----------+
|    8-63      | Unassigned  |                             |           |
+--------------+-------------+-----------------------------+-----------+
]]></artwork></figure>

</section>
<section anchor="exp-instr" title="Expert Review Instructions">

<t>The expert reviewers for the registry defined in this document are expected to ensure that the usage solves a valid use case that could not be solved better in a different way, that it is not going to duplicate one that is already registered, and that the registered point is likely to be used in deployments. They are furthermore expected to check the clarity of purpose and use of the requested code points. Experts should take into account the expected usage of entries when approving point assignment, and the length of the encoded value should be weighed against the number of code points left that encode to that size and the size of device it will be used on. Experts should block registration for entries 8-63 until these points are defined (i.e., until the mechanism for the OSCORE flag bits expansion via bit 1 is specified).</t>

</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC2119;
&RFC4086;
&RFC4648;
&RFC5234;
&RFC6347;
&RFC7049;
&RFC7230;
&RFC7231;
&RFC7252;
&RFC7641;
&RFC7959;
&RFC8075;
&RFC8132;
&RFC8152;
&RFC8174;
&RFC8288;
&RFC8323;
&RFC8446;
&RFC8610;

    </references>

    <references title='Informative References'>

&RFC3552;
&RFC3986;
&RFC5116;
&RFC5869;
&RFC6690;
&RFC7228;
&RFC7515;
&RFC7967;
<?rfc include="reference.RFC.8126"?>

<!--&I-D.ietf-ace-oauth-authz; Publication requested.  See https://datatracker.ietf.org/doc/search/?name=ietf-ace-oauth-authz&activedrafts=on&rfcs=on-->
<reference anchor='ACE-OAuth'>
<front>
<title>Authentication and Authorization for Constrained Environments (ACE) using the OAuth 2.0 Framework (ACE-OAuth)</title>

<author initials='L' surname='Seitz' fullname='Ludwig Seitz'>
    <organization />
</author>

<author initials='G' surname='Selander' fullname='Goeran Selander'>
    <organization />
</author>

<author initials='E' surname='Wahlstroem' fullname='Erik Wahlstroem'>
    <organization />
</author>

<author initials='S' surname='Erdtman' fullname='Samuel Erdtman'>
    <organization />
</author>

<author initials='H' surname='Tschofenig' fullname='Hannes Tschofenig'>
    <organization />
</author>

<date month='March' year='2019' />

<abstract><t>This specification defines a framework for authentication and authorization in Internet of Things (IoT) environments called ACE- OAuth.  The framework is based on a set of building blocks including OAuth 2.0 and CoAP, thus making a well-known and widely used authorization solution suitable for IoT devices.  Existing specifications are used where possible, but where the constraints of IoT devices require it, extensions are added and profiles are defined.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-ace-oauth-authz-24' />

</reference>



<!--&I-D.bormann-6lo-coap-802-15-ie; Expired.  See https://datatracker.ietf.org/doc/search?name=bormann-6lo-coap-802-15-ie&sort=&rfcs=on&activedrafts=on&olddrafts=on-->
<reference anchor='CoAP-802.15.4'>
<front>
<title>Constrained Application Protocol (CoAP) over IEEE 802.15.4 Information Element for IETF</title>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<date month='April' day='4' year='2016' />

<abstract><t>IEEE Std. 802.15.4-2015 defines Information Elements (IE), and draft- kivinen-802-15-ie defines a framework for using these IEs in IETF protocols.  The present specification defines a way to transport CoAP messages in IEs.  This can be used to perform CoAP exchanges with neighboring IEEE 802.15.4 nodes before there is IP connectivity, e.g., to configure that IP connectivity.  draft-wang-6tisch-6top-coapie demonstrates example applications of this for 6TiSCH.  Other areas of application are conceivable even in classic 6LoWPAN networks.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-bormann-6lo-coap-802-15-ie-00' />

</reference>



<!--&I-D.hartke-core-e2e-security-reqs; Expired.  See https://datatracker.ietf.org/doc/search?name=hartke-core-e2e-security-reqs&sort=&rfcs=on&activedrafts=on&olddrafts=on -->
<reference anchor='CoAP-E2E-Sec'>
<front>
<title>Requirements for CoAP End-To-End Security</title>

<author initials='G' surname='Selander' fullname='Goeran Selander'>
    <organization />
</author>

<author initials='F' surname='Palombini' fullname='Francesca Palombini'>
    <organization />
</author>

<author initials='K' surname='Hartke' fullname='Klaus Hartke'>
    <organization />
</author>

<date month='July' day='29' year='2017' />

<abstract><t>This document analyses threats to CoAP message exchanges traversing proxies and derives security requirements for mitigating those threats.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-hartke-core-e2e-security-reqs-03' />

</reference>



<reference anchor='REST'>
<front>
<title>Architectural Styles and the Design of Network-based Software Architectures
</title>

<author initials='R' surname='Fielding' fullname="Roy Fielding">
    <organization />
</author>

<date year='2010' />

</front>

<seriesInfo name='Ph.D. Dissertation,' value='University of California, Irvine' />

<format type="pdf" target='http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf'/>

</reference>


<!--&I-D.mattsson-core-coap-actuators; Expired.  See https://datatracker.ietf.org/doc/search?name=mattsson-core-coap-actuators&sort=&rfcs=on&activedrafts=on&olddrafts=on-->
<reference anchor='CoAP-Actuators'>
<front>
<title>Controlling Actuators with CoAP</title>

<author initials='J' surname='Mattsson' fullname='John Mattsson'>
    <organization />
</author>

<author initials='J' surname='Fornehed' fullname='John Fornehed'>
    <organization />
</author>

<author initials='G' surname='Selander' fullname='Goeran Selander'>
    <organization />
</author>

<author initials='F' surname='Palombini' fullname='Francesca Palombini'>
    <organization />
</author>

<author initials='C' surname='Amsuess' fullname='Christian Amsuess'>
    <organization />
</author>

<date month='September' day='17' year='2018' />

<abstract><t>Being able to trust information from sensors and to securely control actuators are essential in a world of connected and networking things interacting with the physical world.  In this memo we show that just using COAP with a security protocol like DTLS, TLS, or OSCORE is not enough.  We describe several serious attacks any on-path attacker can do, and discusses tougher requirements and mechanisms to mitigate the attacks.  While this document is focused on actuators, some of the attacks apply equally well to sensors.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-mattsson-core-coap-actuators-06' />

</reference>


<!--&I-D.ietf-ace-oscore-profile; Publication requested.  See https://datatracker.ietf.org/doc/search?name=ietf-ace-oscore-profile&sort=&rfcs=on&activedrafts=on&olddrafts=on-->
<reference anchor='OSCORE-PROFILE'>
<front>
<title>OSCORE profile of the Authentication and Authorization for Constrained Environments Framework</title>

<author initials='F' surname='Palombini' fullname='Francesca Palombini'>
    <organization />
</author>

<author initials='L' surname='Seitz' fullname='Ludwig Seitz'>
    <organization />
</author>

<author initials='G' surname='Selander' fullname='Goeran Selander'>
    <organization />
</author>

<author initials='M' surname='Gunnarsson' fullname='Martin Gunnarsson'>
    <organization />
</author>

<date month='February' day='19' year='2019' />

<abstract><t>This memo specifies a profile for the Authentication and Authorization for Constrained Environments (ACE) framework.  It utilizes Object Security for Constrained RESTful Environments (OSCORE) to provide communication security, server authentication, and proof-of-possession for a key owned by the client and bound to an OAuth 2.0 access token.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-ace-oscore-profile-07' />

</reference>



<!--&I-D.ietf-core-oscore-groupcomm; I-D Exists;  See https://datatracker.ietf.org/doc/search?name=ietf-core-oscore-groupcomm&sort=&rfcs=on&activedrafts=on&olddrafts=on-->
<reference anchor='Group-OSCORE'>
<front>
<title>Group OSCORE - Secure Group Communication for CoAP</title>

<author initials='M' surname='Tiloca' fullname='Marco Tiloca'>
    <organization />
</author>

<author initials='G' surname='Selander' fullname='Goeran Selander'>
    <organization />
</author>

<author initials='F' surname='Palombini' fullname='Francesca Palombini'>
    <organization />
</author>

<author initials='J' surname='Park' fullname='Jiye Park'>
    <organization />
</author>

<date month='March' day='8' year='2019' />

<abstract><t>This document describes a mode for protecting group communication over the Constrained Application Protocol (CoAP).  The proposed mode relies on Object Security for Constrained RESTful Environments (OSCORE) and the CBOR Object Signing and Encryption (COSE) format. In particular, it defines how OSCORE is used in a group communication setting, while fulfilling the same security requirements for group requests and responses.  Source authentication of all messages exchanged within the group is provided by means of digital signatures produced by the sender and embedded in the protected CoAP messages.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-core-oscore-groupcomm-04' />

</reference>


<!--&I-D.ietf-core-echo-request-tag; I-D Exists;  See https://datatracker.ietf.org/doc/search?name=ietf-core-echo-request-tag&sort=&rfcs=on&activedrafts=on&olddrafts=on-->
<reference anchor='CoAP-ECHO-REQ-TAG'>
<front>
<title>CoAP: Echo, Request-Tag, and Token Processing</title>

<author initials='C' surname='Amsuess' fullname='Christian Amsuess'>
    <organization />
</author>

<author initials='J' surname='Mattsson' fullname='John Mattsson'>
    <organization />
</author>

<author initials='G' surname='Selander' fullname='Goeran Selander'>
    <organization />
</author>

<date month='March' day='23' year='2019' />

<abstract><t>This document specifies enhancements to the Constrained Application Protocol (CoAP) that mitigate security issues in particular use cases.  The Echo option enables a CoAP server to verify the freshness of a request or to force a client to demonstrate reachability at its claimed network address.  The Request-Tag option allows the CoAP server to match Block-Wise message fragments belonging to the same request.  The updated Token processing requirements for clients ensure secure binding of responses to requests when CoAP is used with security.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-core-echo-request-tag-04' />

</reference>


<!--&I-D.mcgrew-iv-gen; Expired.  See https://datatracker.ietf.org/doc/search?name=mcgrew-iv-gen&sort=&rfcs=on&activedrafts=on&olddrafts=on-->
<reference anchor='IV-GEN'>
<front>
<title>Generation of Deterministic Initialization Vectors (IVs) and Nonces</title>

<author initials='D' surname='McGrew' fullname='David McGrew'>
    <organization />
</author>

<date month='October' day='15' year='2013' />

<abstract><t>Many cryptographic algorithms use deterministic IVs, including CTR, GCM, CCM, GMAC.  This type of IV is also called a (deterministic) nonce.  Deterministic IVs must be distinct, for each fixed key, to guarantee the security of the algorithm.  This note describes best practices for the generation of such IVs, and summarizes how they are generated and used in different protocols.  Some problem areas are highlighted, and test considerations are outlined.  This note will be useful to implementers of algorithms using deterministic IVs, and to protocol or system designers using them.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-mcgrew-iv-gen-03' />

</reference>



<reference anchor="MF00" >
  <front>
    <title>Attacks on Additive Encryption of Redundant Plaintext and Implications on Internet Security</title>
    <author initials="D." surname="McGrew">
      <organization></organization>
    </author>
    <author initials="S." surname="Fluhrer">
      <organization></organization>
    </author>
    <date year="2000"/>
  </front>
  <seriesInfo name="Proceedings of the Seventh Annual Workshop on Selected Areas in Cryptography (SAC 2000)" value="Springer-Verlag."/>
  <seriesInfo name="pp." value="14-28"/>
</reference>


    </references>


<section anchor="examples" title="Scenario Examples">

<t>This section gives examples of OSCORE, targeting scenarios in Section 2.2.1.1 of <xref target="CoAP-E2E-Sec"/>. The message exchanges are made, based on the assumption that there is a security context established between client and server. For simplicity, these examples only indicate the content of the messages without going into detail of the (compressed) COSE message format.</t>

<section anchor="secure-access-to-sensor" title="Secure Access to Sensor">

<t>This example illustrates a client requesting the alarm status from a server.</t>

<figure title="Secure Access to Sensor" anchor="fig-alarm"><artwork align="center"><![CDATA[
Client  Proxy  Server
  |       |       |
  +------>|       |            Code: 0.02 (POST)
  | POST  |       |           Token: 0x8c
  |       |       |          OSCORE: [kid:5f, Partial IV:42]
  |       |       |         Payload: {Code:0.01,
  |       |       |                   Uri-Path:"alarm_status"}
  |       |       |
  |       +------>|            Code: 0.02 (POST)
  |       | POST  |           Token: 0x7b
  |       |       |          OSCORE: [kid:5f, Partial IV:42]
  |       |       |         Payload: {Code:0.01,
  |       |       |                   Uri-Path:"alarm_status"}
  |       |       |
  |       |<------+            Code: 2.04 (Changed)
  |       |  2.04 |           Token: 0x7b
  |       |       |          OSCORE: -
  |       |       |         Payload: {Code:2.05, "0"}
  |       |       |
  |<------+       |            Code: 2.04 (Changed)
  |  2.04 |       |           Token: 0x8c
  |       |       |          OSCORE: -
  |       |       |         Payload: {Code:2.05, "0"}
  |       |       |
  ]]></artwork>
<postamble>
Square brackets [ ... ] indicate content of compressed COSE object. Curly brackets { ... } indicate encrypted data.
</postamble>
</figure>

<t>The CoAP request/response Codes are encrypted by OSCORE and only dummy Codes (POST/Changed) are visible in the header of the OSCORE message. The option Uri-Path ("alarm_status") and payload ("0") are encrypted.</t>

<t>The COSE header of the request contains an identifier (5f), indicating which security context was used to protect the message and a Partial IV (42).</t>

<t>The server verifies the request as specified in <xref target="ver-req"/>. The client verifies the response as specified in <xref target="ver-res"/>.</t>

</section>
<section anchor="secure-subscribe-to-sensor" title="Secure Subscribe to Sensor">

<t>This example illustrates a client requesting subscription to a blood sugar measurement resource (GET /glucose), first receiving the value 220 mg/dl and then a second value 180 mg/dl.</t>


<figure title="Secure Subscribe to Sensor" anchor="fig-blood-sugar"><artwork align="center"><![CDATA[
Client  Proxy  Server
  |       |       |
  +------>|       |            Code: 0.05 (FETCH)
  | FETCH |       |           Token: 0x83
  |       |       |         Observe: 0
  |       |       |          OSCORE: [kid:ca, Partial IV:15]
  |       |       |         Payload: {Code:0.01,
  |       |       |                   Observe:0,  
  |       |       |                   Uri-Path:"glucose"}
  |       |       |
  |       +------>|            Code: 0.05 (FETCH)
  |       | FETCH |           Token: 0xbe
  |       |       |         Observe: 0
  |       |       |          OSCORE: [kid:ca, Partial IV:15]
  |       |       |         Payload: {Code:0.01,
  |       |       |                   Observe:0,  
  |       |       |                   Uri-Path:"glucose"}
  |       |       |
  |       |<------+            Code: 2.05 (Content)
  |       |  2.05 |           Token: 0xbe
  |       |       |         Observe: 7
  |       |       |          OSCORE: -
  |       |       |         Payload: {Code:2.05,  
  |       |       |                   Observe:-,  
  |       |       |                   Content-Format:0, "220"}
  |       |       |
  |<------+       |            Code: 2.05 (Content)
  |  2.05 |       |           Token: 0x83
  |       |       |         Observe: 7
  |       |       |          OSCORE: -
  |       |       |         Payload: {Code:2.05,
  |       |       |                   Observe:-,    
  |       |       |                   Content-Format:0, "220"}
 ...     ...     ...
  |       |       |
  |       |<------+            Code: 2.05 (Content)
  |       |  2.05 |           Token: 0xbe
  |       |       |         Observe: 8
  |       |       |          OSCORE: [Partial IV:36]
  |       |       |         Payload: {Code:2.05,
  |       |       |                   Observe:-,  
  |       |       |                   Content-Format:0, "180"}
  |       |       |
  |<------+       |            Code: 2.05 (Content)
  |  2.05 |       |           Token: 0x83
  |       |       |         Observe: 8
  |       |       |          OSCORE: [Partial IV:36]
  |       |       |         Payload: {Code:2.05,
  |       |       |                   Observe:-,  
  |       |       |                   Content-Format:0, "180"}
  |       |       |
]]></artwork>
<postamble>
Square brackets [ ... ] indicate content of compressed COSE object header.
Curly brackets { ... } indicate encrypted data.
</postamble>
</figure>

<t>The dummy Codes (FETCH/Content) are used to allow forwarding of Observe messages. The options Content-Format (0) and the payload ("220" and "180") are encrypted.</t>

<t>The COSE header of the request contains an identifier (ca), indicating the security context used to protect the message and a Partial IV (15). The COSE header of the second response contains the Partial IV (36). The first response uses the Partial IV of the request.</t>

<t>The server verifies that the Partial IV has not been received before. The client verifies that the responses are bound to the request and that the Partial IVs are greater than any Partial IV previously received in a response bound to the request, except for the notification without Partial IV, which is considered the oldest.</t>

</section>
</section>
<section anchor="deployment-examples" title="Deployment Examples">

<t>For many Internet of Things (IoT) deployments, a 128-bit uniformly
random Master Key is sufficient for encrypting all data exchanged with
the IoT device throughout its lifetime. Two examples are given in this
section. In the first example, the security context is only derived
once from the Master Secret. In the second example, security contexts
are derived multiple times using random inputs.</t>

<section anchor="master-secret-once" title="Security Context Derived Once">

<t>An application that only derives the security context once needs to
handle the loss of mutable security context parameters, e.g., due to
reboot.</t>

<section anchor="seq-numb" title="Sender Sequence Number">

<t>In order to handle loss of Sender Sequence Numbers, the device may
implement procedures for writing to nonvolatile memory during normal
operations and updating the security context after reboot, provided
that the procedures comply with the requirements on the security
context parameters (<xref target="req-params"/>). This section gives
an example of such a procedure.</t>

<t>There are known issues related to writing to nonvolatile
memory. For example, flash drives may have a limited number of erase
operations during its lifetime. Also, the time for a write operation
to nonvolatile memory to be completed may be unpredictable, e.g., due
to caching, which could result in important security context data not
being stored at the time when the device reboots.</t>

<t>However, many devices have predictable limits for writing to nonvolatile memory, are physically limited to only send a small amount of messages per minute, and may have no good source of randomness.</t>


<t>To prevent reuse of Sender Sequence Number, an endpoint may perform the following procedure during normal operations:</t>



<t><list style="symbols">
  <t>Before using a Sender Sequence Number that is evenly divisible by K,
  where K is a positive integer, store the Sender Sequence Number (SSN1) in
  nonvolatile memory.  After booting, the endpoint initiates the new Sender Sequence Number (SSN2) to the value stored in persistent memory plus K plus F: SSN2 = SSN1 + K + F, where F is a positive integer.  <list style="symbols">
      <t>Writing to nonvolatile memory can be costly; the value K gives a trade-off between frequency of storage operations and efficient use of Sender Sequence Numbers.</t>
      <t>Writing to nonvolatile memory may be subject to delays, or failure; F MUST be set so that the last Sender Sequence Number used before reboot is never larger than SSN2.</t>
    </list></t>
</list></t>

<t>If F cannot be set so SSN2 is always larger than the last Sender Sequence Number used before reboot, the method described in this section MUST NOT be used.</t>

</section>
<section anchor="reboot-replay" title="Replay Window">

<t>In case of loss of security context on the server, to prevent accepting replay of previously received requests, the server may perform the following procedure after booting:</t>

<t><list style="symbols">
  <t>The server updates its Sender Sequence Number as specified in <xref target="seq-numb"/> to be used as Partial IV in the response containing the Echo option (next bullet).</t>
  <t>For each stored security context, the first time after booting, the
  server receives an OSCORE request, the server responds with an
  OSCORE protected 4.01 (Unauthorized), containing only the Echo
  option <xref target="CoAP-ECHO-REQ-TAG"/> and no diagnostic
  payload. The server MUST use its Partial IV when generating the AEAD
  nonce and MUST include the Partial IV in the response (see <xref
  target="cose-object"/>). If the server with use of the Echo option
  can verify a second OSCORE request as fresh, then the Partial IV of
  the second request is set as the lower limit of the Replay Window of
  that security context.</t>
</list></t>

</section>
<section anchor="replay-notif" title="Notifications">

<t>To prevent the acceptance of replay of previously received notifications, the client may perform the following procedure after booting:</t>


<t><list style="symbols">
  <t>The client forgets about earlier registrations and removes all Notification Numbers. The client then registers again using the Observe option.</t>
</list></t>

</section>
</section>
<section anchor="master-secret-multiple" title="Security Context Derived Multiple Times">

<t>An application that does not require forward secrecy may allow multiple security contexts to be derived from one Master Secret. The requirements on the security context parameters MUST be fulfilled (<xref target="req-params"/>) even if the client or server is rebooted, recommissioned, or in error cases.</t>

<t>This section gives an example of a protocol that adds randomness to
the ID Context parameter and uses that together with input parameters
preestablished between client and server, in particular Master Secret,
Master Salt, and Sender/Recipient ID (see <xref
target="context-derivation"/>), to derive new security contexts. The
random input is transported between client and server in the 'kid
context' parameter. This protocol MUST NOT be used unless both
endpoints have good sources of randomness.</t>

<t>During normal requests, the ID Context of an established security
context may be sent in the 'kid context', which, together with 'kid',
facilitates for the server to locate a security
context. Alternatively, the 'kid context' may be omitted since the ID
Context is expected to be known to both client and server; see <xref
target="context-hint"/>.</t>

<t>The protocol described in this section may only be needed when the
mutable part of security context is lost in the client or server,
e.g., when the endpoint has rebooted. The protocol may additionally be
used whenever the client and server need to derive a new security
context. For example, if a device is provisioned with one fixed set of
input parameters (including Master Secret, Sender and Recipient
Identifiers), then a randomized ID Context ensures that the security
context is different for each deployment.</t>


<t>
Note that the server needs to be configured to run this protocol when
it is not able to retrieve an existing security context, instead of stopping
processing the message as described in step 2 of <xref target="ver-req"/>.
</t>

<t>The protocol is described below with reference to <xref target="fig-B2"/>. The client or the server may initiate the protocol, in the latter case step 1 is omitted.</t>

<figure title="Protocol for Establishing a New Security Context" anchor="fig-B2"><artwork align="center"><![CDATA[
                      Client                Server
                        |                      |
1. Protect with         |      request #1      |
   ID Context = ID1     |--------------------->| 2. Verify with
                        |  kid_context = ID1   |    ID Context = ID1
                        |                      | 
                        |      response #1     |    Protect with
3. Verify with          |<---------------------|    ID Context = R2||ID1
   ID Context = R2||ID1 |   kid_context = R2   |
                        |                      |
   Protect with         |      request #2      |
   ID Context = R2||R3  |--------------------->| 4. Verify with 
                        | kid_context = R2||R3 |    ID Context = R2||R3
                        |                      | 
                        |      response #2     |    Protect with
5. Verify with          |<---------------------|    ID Context = R2||R3
   ID Context = R2||R3  |                      | 
]]></artwork></figure>

<t><list style="numbers">
  <t>(Optional) If the client does not have a valid security context
  with the server, e.g., because of reboot or because this is the
  first time it contacts the server, then it generates a random string
  R1 and uses this as ID Context together with the input parameters
  shared with the server to derive a first security context. The
  client sends an OSCORE request to the server protected with the
  first security context, containing R1 wrapped in a CBOR bstr as 'kid
  context'. The request may target a special resource used for
  updating security contexts.</t>
  
  <t>The server receives an OSCORE request for which it does not have
  a valid security context, either because the client has generated a
  new security context ID1 = R1 or because the server has lost part
  of its security context, e.g., ID Context, Sender Sequence Number or
  Replay Window. If the server is able to verify the request (see
  <xref target="ver-req"/>) with the new derived first security
  context using the received ID1 (transported in 'kid context') as ID
  Context and the input parameters associated to the received 'kid',
  then the server generates a random string R2 and derives a second
  security context with ID Context = ID2 = R2 || ID1. The server sends
  a 4.01 (Unauthorized) response protected with the second security
  context, containing R2 wrapped in a CBOR bstr as 'kid context', and
  caches R2. R2 MUST NOT be reused as that may lead to reuse of key
  and nonce in response #1. Note that the server may receive several
  requests #1 associated with one security context, leading to
  multiple parallel protocol runs. Multiple instances of R2 may need
  to be cached until one of the protocol runs is completed, see <xref
  target="impl-cons"/>.</t>
  
  <t>The client receives a response with 'kid context' containing a
  CBOR bstr wrapping R2 to an OSCORE request it made with ID Context =
  ID1. The client derives a second security context using ID Context =
  ID2 = R2 || ID1. If the client can verify the response (see <xref
  target="ver-res"/>) using the second security context, then the
  client makes a request protected with a third security context
  derived from ID Context = ID3 = R2 || R3, where R3 is a random byte
  string generated by the client. The request includes R2 || R3
  wrapped in a CBOR bstr as 'kid context'.</t>
  
  <t>If the server receives a request with 'kid context' containing a
  CBOR bstr wrapping ID3, where the first part of ID3 is identical to
  an R2 sent in a previous response #1, which it has not received
  before, then the server derives a third security context with ID
  Context = ID3. The server MUST NOT accept replayed request #2
  messages. If the server can verify the request (see <xref
  target="ver-req"/>) with the third security context, then the server
  marks the third security context to be used with this client and
  removes all instances of R2 associated to this security context from
  the cache. This security context replaces the previous security
  context with the client, and the first and the second security
  contexts are deleted. The server responds using the same security
  context as in the request.</t>

  
  <t>If the client receives a response to the request with the third
  security context and the response verifies (see <xref
  target="ver-res"/>), then the client marks the third security
  context to be used with this server. This security context replaces
  the previous security context with the server, and the first and
  second security contexts are deleted.</t>
</list></t>

<t>If verification fails in any step, the endpoint stops processing that message.</t>

<t>The length of the nonces R1, R2, and R3 is application
specific. The application needs to set the length of each nonce such that
the probability of its value being repeated is negligible; typically,
at least 8 bytes long. Since R2 may be generated as the result of a
replayed request #1, the probability for collision of R2s is impacted
by the birthday paradox. For example, setting the length of R2 to 8
bytes results in an average collision after 2^32 response #1 messages,
which should not be an issue for a constrained server handling on the
order of one request per second.</t>

<t>Request #2 can be an ordinary request. The server performs the
action of the request and sends response #2 after having successfully
completed the operations related to the security context in step 4. The
client acts on response #2 after having successfully completed step
5.</t>

<t>When sending request #2, the client is assured that the Sender Key
(derived with the random value R3) has never been used before. When
receiving response #2, the client is assured that the response
(protected with a key derived from the random value R3 and the Master
Secret) was created by the server in response to request #2.</t>

<t>Similarly, when receiving request #2, the server is assured that
the request (protected with a key derived from the random value R2 and
the Master Secret) was created by the client in response to response
#1. When sending response #2, the server is assured that the Sender
Key (derived with the random value R2) has never been used before.</t>

<t>Implementation and denial-of-service considerations are made in
<xref target="impl-cons"/> and <xref target="attack-cons"/>.</t>

<section anchor="impl-cons" title="Implementation Considerations">

<t>This section add some implementation considerations to the protocol described in the previous section.</t>

<t>The server may only have space for a few security contexts or only
be able to handle a few protocol runs in parallel.  The server may
legitimately receive multiple request #1 messages using the same
immutable security context, e.g., because of packet loss. Replays of old
request #1 messages could be difficult for the server to distinguish
from legitimate. The server needs to handle the case when the maximum
number of cached R2s is reached. If the server receives a request #1
and is not capable of executing it then it may respond with an
unprotected 5.03 (Service Unavailable) error message. The server may clear up state
from protocol runs that never complete, e.g., set a timer when
caching R2, and remove R2 and the associated security contexts from
the cache at timeout. Additionally, state information can be flushed
at reboot.</t>

<t>As an alternative to caching R2, the server could generate R2 in
such a way that it can be sent (in response #1) and verified (at
reception of request #2) as the value of R2 it had generated. Such a
procedure MUST NOT lead to the server accepting replayed request #2
messages. One construction described in the following is based on
using a secret random HMAC key K_HMAC per set of immutable security
context parameters associated with a client. This construction allows
the server to handle verification of R2 in response #2 at the cost of
storing the K_HMAC keys and a slightly larger message overhead in
response #1. Steps below refer to modifications to <xref
target="master-secret-multiple"/>:</t>

<t><list style="symbols">
  <t>In step 2, R2 is generated in the following way. First, the server generates a random K_HMAC (unless it already has one associated with the security context), then it sets R2 = S2 || HMAC(K_HMAC, S2) where S2 is a random byte string, and the HMAC is truncated to 8 bytes. K_HMAC may have an expiration time, after which it is erased. Note that neither R2, S2, nor the derived first and second security contexts need to be cached.</t>
  <t>In step 4, instead of verifying that R2 coincides with a cached value, the server looks up the associated K_HMAC and verifies the truncated HMAC, and the processing continues accordingly depending on verification success or failure.  K_HMAC is used until a run of the protocol is completed (after verification of request #2), or until it expires (whatever comes first), after which K_HMAC is erased. (The latter corresponds to removing the cached values of R2 in step 4 of <xref target="master-secret-multiple"/> and makes the server reject replays of request #2.)</t>
</list></t>

<t>The length of S2 is application specific and the probability for collision of S2s is impacted by the birthday paradox. For example, setting the length of S2 to 8 bytes results in an average collision after 2^32 response #1 messages, which should not be an issue for a constrained server handling on the order of one request per second.</t>

<t>Two endpoints sharing a security context may accidentally initiate
two instances of the protocol at the same time, each in the role of
client, e.g., after a power outage affecting both endpoints. Such a
race condition could potentially lead to both protocols failing, and
both endpoints repeatedly reinitiating the protocol without
converging. Both endpoints can detect this situation, and it can be
handled in different ways. The requests could potentially be more
spread out in time, for example, by only initiating this protocol when
the endpoint actually needs to make a request, potentially adding a
random delay before requests immediately after reboot or if such
parallel protocol runs are detected.</t>

</section>
<section anchor="attack-cons" title="Attack Considerations">

<t>An on-path attacker may inject a message causing the endpoint to process verification of the message. A message crafted without access to the Master Secret will fail to verify.</t>

<t>Replaying an old request with a value of 'kid_context' that the
server does not recognize could trigger the protocol. This causes the
server to generate the first and second security context and send a
response. But if the client did not expect a response, it will be
discarded. This may still result in a denial-of-service attack against
the server, e.g., because of not being able to manage the state
associated with many parallel protocol runs, and it may prevent
legitimate client requests. Implementation alternatives with less data
caching per request #1 message are favorable in this respect; see
<xref target="impl-cons"/>.</t>

<t>Replaying response #1 in response to some request other than
request #1 will fail to verify, since response #1 is associated to
request #1, through the dependencies of ID Contexts and the Partial IV
of request #1 included in the external_aad of response #1.</t>

<t>If request #2 has already been well received, then the server has a
valid security context, so a replay of request #2 is handled by the
normal replay protection mechanism. Similarly, if response #2 has
already been received, a replay of response #2 to some other request
from the client will fail by the normal verification of binding of
response to request.</t>

</section>
</section>
</section>
<section anchor="test-vectors" title="Test Vectors">

<t>This appendix includes the test vectors for different examples of CoAP messages using OSCORE. Given a set of inputs, OSCORE defines how to set up the Security Context in both the client and the server.</t>

<t>Note that in <xref target="tv4"/> and all following test vectors the Token and the Message ID of the OSCORE-protected CoAP messages are set to the same value of the unprotected CoAP message to help the reader with comparisons.</t>



<section anchor="key-der-tv-ms" title="Test Vector 1: Key Derivation with Master Salt">

<t>In this test vector, a Master Salt of 8 bytes is used. The default values are used for AEAD Algorithm and HKDF.</t>

<section anchor="client" title="Client">

<t>Inputs:</t>

<t><list style="symbols">
  <t>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</t>
  <t>Master Salt: 0x9e7ca92223786340 (8 bytes)</t>
  <t>Sender ID: 0x (0 byte)</t>
  <t>Recipient ID: 0x01 (1 byte)</t>
</list></t>

<t>From the previous parameters,</t>

<t><list style="symbols">
  <t>info (for Sender Key): 0x8540f60a634b657910 (9 bytes)</t>
  <t>info (for Recipient Key): 0x854101f60a634b657910 (10 bytes)</t>
  <t>info (for Common IV): 0x8540f60a6249560d (8 bytes)</t>
</list></t>

<t>Outputs:</t>

<t><list style="symbols">
  <t>Sender Key: 0xf0910ed7295e6ad4b54fc793154302ff (16 bytes)</t>
  <t>Recipient Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</t>
  <t>Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes)</t>
</list></t>

<t>From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</t>

<t><list style="symbols">
  <t>sender nonce: 0x4622d4dd6d944168eefb54987c (13 bytes)</t>
  <t>recipient nonce: 0x4722d4dd6d944169eefb54987c (13 bytes)</t>
</list></t>

</section>
<section anchor="server" title="Server">

<t>Inputs:</t>

<t><list style="symbols">
  <t>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</t>
  <t>Master Salt: 0x9e7ca92223786340 (8 bytes)</t>
  <t>Sender ID: 0x01 (1 byte)</t>
  <t>Recipient ID: 0x (0 byte)</t>
</list></t>

<t>From the previous parameters,</t>

<t><list style="symbols">
  <t>info (for Sender Key): 0x854101f60a634b657910 (10 bytes)</t>
  <t>info (for Recipient Key): 0x8540f60a634b657910 (9 bytes)</t>
  <t>info (for Common IV): 0x8540f60a6249560d (8 bytes)</t>
</list></t>

<t>Outputs:</t>

<t><list style="symbols">
  <t>Sender Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</t>
  <t>Recipient Key: 0xf0910ed7295e6ad4b54fc793154302ff (16 bytes)</t>
  <t>Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes)</t>
</list></t>

<t>From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</t>

<t><list style="symbols">
  <t>sender nonce: 0x4722d4dd6d944169eefb54987c (13 bytes)</t>
  <t>recipient nonce: 0x4622d4dd6d944168eefb54987c (13 bytes)</t>
</list></t>

</section>
</section>
<section anchor="key-der-tv" title="Test Vector 2: Key Derivation without Master Salt">

<t>In this test vector, the default values are used for AEAD Algorithm, HKDF, and Master Salt.</t>

<section anchor="client-1" title="Client">

<t>Inputs:</t>

<t><list style="symbols">
  <t>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</t>
  <t>Sender ID: 0x00 (1 byte)</t>
  <t>Recipient ID: 0x01 (1 byte)</t>
</list></t>

<t>From the previous parameters,</t>

<t><list style="symbols">
  <t>info (for Sender Key): 0x854100f60a634b657910 (10 bytes)</t>
  <t>info (for Recipient Key): 0x854101f60a634b657910 (10 bytes)</t>
  <t>info (for Common IV): 0x8540f60a6249560d (8 bytes)</t>
</list></t>

<t>Outputs:</t>

<t><list style="symbols">
  <t>Sender Key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes)</t>
  <t>Recipient Key: 0xe57b5635815177cd679ab4bcec9d7dda (16 bytes)</t>
  <t>Common IV: 0xbe35ae297d2dace910c52e99f9 (13 bytes)</t>
</list></t>

<t>From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</t>

<t><list style="symbols">
  <t>sender nonce: 0xbf35ae297d2dace910c52e99f9 (13 bytes)</t>
  <t>recipient nonce: 0xbf35ae297d2dace810c52e99f9 (13 bytes)</t>
</list></t>

</section>
<section anchor="server-1" title="Server">

<t>Inputs:</t>

<t><list style="symbols">
  <t>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</t>
  <t>Sender ID: 0x01 (1 byte)</t>
  <t>Recipient ID: 0x00 (1 byte)</t>
</list></t>

<t>From the previous parameters,</t>

<t><list style="symbols">
  <t>info (for Sender Key): 0x854101f60a634b657910 (10 bytes)</t>
  <t>info (for Recipient Key): 0x854100f60a634b657910 (10 bytes)</t>
  <t>info (for Common IV): 0x8540f60a6249560d (8 bytes)</t>
</list></t>

<t>Outputs:</t>

<t><list style="symbols">
  <t>Sender Key: 0xe57b5635815177cd679ab4bcec9d7dda (16 bytes)</t>
  <t>Recipient Key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes)</t>
  <t>Common IV: 0xbe35ae297d2dace910c52e99f9 (13 bytes)</t>
</list></t>

<t>From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</t>

<t><list style="symbols">
  <t>sender nonce: 0xbf35ae297d2dace810c52e99f9 (13 bytes)</t>
  <t>recipient nonce: 0xbf35ae297d2dace910c52e99f9 (13 bytes)</t>
</list></t>

</section>
</section>
<section anchor="key-der-kc" title="Test Vector 3: Key Derivation with ID Context">

<t>In this test vector, a Master Salt of 8 bytes and an ID Context of 8 bytes are used. The default values are used for AEAD Algorithm and HKDF.</t>

<section anchor="client-2" title="Client">

<t>Inputs:</t>

<t><list style="symbols">
  <t>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</t>
  <t>Master Salt: 0x9e7ca92223786340 (8 bytes)</t>
  <t>Sender ID: 0x (0 byte)</t>
  <t>Recipient ID: 0x01 (1 byte)</t>
  <t>ID Context: 0x37cbf3210017a2d3 (8 bytes)</t>
</list></t>

<t>From the previous parameters,</t>

<t><list style="symbols">
  <t>info (for Sender Key): 0x85404837cbf3210017a2d30a634b657910 (17 bytes)</t>
  <t>info (for Recipient Key): 0x8541014837cbf3210017a2d30a634b657910 (18 bytes)</t>
  <t>info (for Common IV): 0x85404837cbf3210017a2d30a6249560d (16 bytes)</t>
</list></t>

<t>Outputs:</t>

<t><list style="symbols">
  <t>Sender Key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes)</t>
  <t>Recipient Key: 0xe39a0c7c77b43f03b4b39ab9a268699f (16 bytes)</t>
  <t>Common IV: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes)</t>
</list></t>

<t>From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</t>

<t><list style="symbols">
  <t>sender nonce: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes)</t>
  <t>recipient nonce: 0x2da58fb85ff1b81d0b7181b85e (13 bytes)</t>
</list></t>

</section>
<section anchor="server-2" title="Server">

<t>Inputs:</t>

<t><list style="symbols">
  <t>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</t>
  <t>Master Salt: 0x9e7ca92223786340 (8 bytes)</t>
  <t>Sender ID: 0x01 (1 byte)</t>
  <t>Recipient ID: 0x (0 byte)</t>
  <t>ID Context: 0x37cbf3210017a2d3 (8 bytes)</t>
</list></t>

<t>From the previous parameters,</t>

<t><list style="symbols">
  <t>info (for Sender Key): 0x8541014837cbf3210017a2d30a634b657910 (18 bytes)</t>
  <t>info (for Recipient Key): 0x85404837cbf3210017a2d30a634b657910 (17 bytes)</t>
  <t>info (for Common IV): 0x85404837cbf3210017a2d30a6249560d (16 bytes)</t>
</list></t>

<t>Outputs:</t>

<t><list style="symbols">
  <t>Sender Key: 0xe39a0c7c77b43f03b4b39ab9a268699f (16 bytes)</t>
  <t>Recipient Key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes)</t>
  <t>Common IV: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes)</t>
</list></t>

<t>From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</t>

<t><list style="symbols">
  <t>sender nonce: 0x2da58fb85ff1b81d0b7181b85e (13 bytes)</t>
  <t>recipient nonce: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes)</t>
</list></t>

</section>
</section>
<section anchor="tv4" title="Test Vector 4: OSCORE Request, Client">

<t>This section contains a test vector for an OSCORE-protected CoAP
GET request using the security context derived in <xref
target="key-der-tv-ms"/>. The unprotected request only contains the
Uri-Path and Uri-Host options.</t>

<t>Unprotected CoAP request: 0x44015d1f00003974396c6f63616c686f737483747631 (22 bytes)</t>

<t>Common Context:</t>

<t><list style="symbols">
  <t>AEAD Algorithm: 10 (AES-CCM-16-64-128)</t>
  <t>Key Derivation Function: HKDF SHA-256</t>
  <t>Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes)</t>
</list></t>

<t>Sender Context:</t>

<t><list style="symbols">
  <t>Sender ID: 0x (0 byte)</t>
  <t>Sender Key: 0xf0910ed7295e6ad4b54fc793154302ff (16 bytes)</t>
  <t>Sender Sequence Number: 20</t>
</list></t>

<t>The following COSE and cryptographic parameters are derived:</t>

<t><list style="symbols">
  <t>Partial IV: 0x14 (1 byte)</t>
  <t>kid: 0x (0 byte)</t>
  <t>aad_array: 0x8501810a40411440 (8 bytes)</t>
  <t>AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes)</t>
  <t>plaintext: 0x01b3747631 (5 bytes)</t>
  <t>encryption key: 0xf0910ed7295e6ad4b54fc793154302ff (16 bytes)</t>
  <t>nonce: 0x4622d4dd6d944168eefb549868 (13 bytes)</t>
</list></t>

<t>From the previous parameter, the following is derived:</t>

<t><list style="symbols">
  <t>OSCORE option value: 0x0914 (2 bytes)</t>
  <t>ciphertext: 0x612f1092f1776f1c1668b3825e (13 bytes)</t>
</list></t>

<t>From there:</t>

<t><list style="symbols">
  <t>Protected CoAP request (OSCORE message): 0x44025d1f00003974396c6f63616c686f7374620914ff612f1092f1776f1c1668b3825e (35 bytes)</t>
</list></t>

</section>
<section anchor="tv5" title="Test Vector 5: OSCORE Request, Client">

<t>This section contains a test vector for an OSCORE-protected CoAP GET request using the security context derived in <xref target="key-der-tv"/>. The unprotected request only contains the Uri-Path and Uri-Host options.</t>

<t>Unprotected CoAP request: 0x440171c30000b932396c6f63616c686f737483747631 (22 bytes)</t>

<t>Common Context:</t>

<t><list style="symbols">
  <t>AEAD Algorithm: 10 (AES-CCM-16-64-128)</t>
  <t>Key Derivation Function: HKDF SHA-256</t>
  <t>Common IV: 0xbe35ae297d2dace910c52e99f9 (13 bytes)</t>
</list></t>

<t>Sender Context:</t>

<t><list style="symbols">
  <t>Sender ID: 0x00 (1 bytes)</t>
  <t>Sender Key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes)</t>
  <t>Sender Sequence Number: 20</t>
</list></t>

<t>The following COSE and cryptographic parameters are derived:</t>

<t><list style="symbols">
  <t>Partial IV: 0x14 (1 byte)</t>
  <t>kid: 0x00 (1 byte)</t>
  <t>aad_array: 0x8501810a4100411440 (9 bytes)</t>
  <t>AAD: 0x8368456e63727970743040498501810a4100411440 (21 bytes)</t>
  <t>plaintext: 0x01b3747631 (5 bytes)</t>
  <t>encryption key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes)</t>
  <t>nonce: 0xbf35ae297d2dace910c52e99ed (13 bytes)</t>
</list></t>

<t>From the previous parameter, the following is derived:</t>

<t><list style="symbols">
  <t>OSCORE option value: 0x091400 (3 bytes)</t>
  <t>ciphertext: 0x4ed339a5a379b0b8bc731fffb0 (13 bytes)</t>
</list></t>

<t>From there:</t>

<t><list style="symbols">
  <t>Protected CoAP request (OSCORE message): 0x440271c30000b932396c6f63616c686f737463091400ff4ed339a5a379b0b8bc731fffb0 (36 bytes)</t>
</list></t>

</section>
<section anchor="tv6" title="Test Vector 6: OSCORE Request, Client">

<t>This section contains a test vector for an OSCORE-protected CoAP GET request for an application that sets the ID Context and requires it to be sent in the request, so 'kid context' is present in the protected message. This test vector uses the security context derived in <xref target="key-der-kc"/>. The unprotected request only contains the Uri-Path and Uri-Host options.</t>

<t>Unprotected CoAP request: 0x44012f8eef9bbf7a396c6f63616c686f737483747631 (22 bytes)</t>

<t>Common Context:</t>

<t><list style="symbols">
  <t>AEAD Algorithm: 10 (AES-CCM-16-64-128)</t>
  <t>Key Derivation Function: HKDF SHA-256</t>
  <t>Common IV: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes)</t>
  <t>ID Context: 0x37cbf3210017a2d3 (8 bytes)</t>
</list></t>

<t>Sender Context:</t>

<t><list style="symbols">
  <t>Sender ID: 0x (0 bytes)</t>
  <t>Sender Key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes)</t>
  <t>Sender Sequence Number: 20</t>
</list></t>

<t>The following COSE and cryptographic parameters are derived:</t>

<t><list style="symbols">
  <t>Partial IV: 0x14 (1 byte)</t>
  <t>kid: 0x (0 byte)</t>
  <t>kid context: 0x37cbf3210017a2d3 (8 bytes)</t>
  <t>aad_array: 0x8501810a40411440 (8 bytes)</t>
  <t>AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes)</t>
  <t>plaintext: 0x01b3747631 (5 bytes)</t>
  <t>encryption key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes)</t>
  <t>nonce: 0x2ca58fb85ff1b81c0b7181b84a (13 bytes)</t>
</list></t>

<t>From the previous parameter, the following is derived:</t>

<t><list style="symbols">
  <t>OSCORE option value: 0x19140837cbf3210017a2d3 (11 bytes)</t>
  <t>ciphertext: 0x72cd7273fd331ac45cffbe55c3 (13 bytes)</t>
</list></t>

<t>From there:</t>

<t><list style="symbols">
  <t>Protected CoAP request (OSCORE message): 0x44022f8eef9bbf7a396c6f63616c686f73746b19140837cbf3210017a2d3ff
72cd7273fd331ac45cffbe55c3 (44 bytes)</t>
</list></t>

</section>
<section anchor="tv7" title="Test Vector 7: OSCORE Response, Server">

<t>This section contains a test vector for an OSCORE-protected 2.05 (Content) response to the request in <xref target="tv4"/>. The unprotected response has payload "Hello World!" and no options. The protected response does not contain a 'kid' nor a Partial IV. Note that some parameters are derived from the request.</t>

<t>Unprotected CoAP response: 0x64455d1f00003974ff48656c6c6f20576f726c6421 (21 bytes)</t>

<t>Common Context:</t>

<t><list style="symbols">
  <t>AEAD Algorithm: 10 (AES-CCM-16-64-128)</t>
  <t>Key Derivation Function: HKDF SHA-256</t>
  <t>Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes)</t>
</list></t>

<t>Sender Context:</t>

<t><list style="symbols">
  <t>Sender ID: 0x01 (1 byte)</t>
  <t>Sender Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</t>
  <t>Sender Sequence Number: 0</t>
</list></t>

<t>The following COSE and cryptographic parameters are derived:</t>

<t><list style="symbols">
  <t>aad_array: 0x8501810a40411440 (8 bytes)</t>
  <t>AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes)</t>
  <t>plaintext: 0x45ff48656c6c6f20576f726c6421 (14 bytes)</t>
  <t>encryption key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</t>
  <t>nonce: 0x4622d4dd6d944168eefb549868 (13 bytes)</t>
</list></t>

<t>From the previous parameter, the following is derived:</t>

<t><list style="symbols">
  <t>OSCORE option value: 0x (0 bytes)</t>
  <t>ciphertext: 0xdbaad1e9a7e7b2a813d3c31524378303cdafae119106 (22 bytes)</t>
</list></t>

<t>From there:</t>

<t><list style="symbols">
  <t>Protected CoAP response (OSCORE message): 0x64445d1f0000397490ffdbaad1e9a7e7b2a813d3c31524378303cdafae119106 (32 bytes)</t>
</list></t>

</section>
<section anchor="tv8" title="Test Vector 8: OSCORE Response with Partial IV, Server">

<t>This section contains a test vector for an OSCORE protected 2.05 (Content) response to the request in <xref target="tv4"/>. The unprotected response has payload "Hello World!" and no options. The protected response does not contain a 'kid', but contains a  Partial IV. Note that some parameters are derived from the request.</t>

<t>Unprotected CoAP response: 0x64455d1f00003974ff48656c6c6f20576f726c6421 (21 bytes)</t>

<t>Common Context:</t>

<t><list style="symbols">
  <t>AEAD Algorithm: 10 (AES-CCM-16-64-128)</t>
  <t>Key Derivation Function: HKDF SHA-256</t>
  <t>Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes)</t>
</list></t>

<t>Sender Context:</t>

<t><list style="symbols">
  <t>Sender ID: 0x01 (1 byte)</t>
  <t>Sender Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</t>
  <t>Sender Sequence Number: 0</t>
</list></t>

<t>The following COSE and cryptographic parameters are derived:</t>

<t><list style="symbols">
  <t>Partial IV: 0x00 (1 byte)</t>
  <t>aad_array: 0x8501810a40411440 (8 bytes)</t>
  <t>AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes)</t>
  <t>plaintext: 0x45ff48656c6c6f20576f726c6421 (14 bytes)</t>
  <t>encryption key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</t>
  <t>nonce: 0x4722d4dd6d944169eefb54987c (13 bytes)</t>
</list></t>

<t>From the previous parameter, the following is derived:</t>

<t><list style="symbols">
  <t>OSCORE option value: 0x0100 (2 bytes)</t>
  <t>ciphertext: 0x4d4c13669384b67354b2b6175ff4b8658c666a6cf88e (22 bytes)</t>
</list></t>

<t>From there:</t>

<t><list style="symbols">
  <t>Protected CoAP response (OSCORE message): 0x64445d1f00003974920100ff4d4c13669384b67354b2b6175ff4b8658c666a6cf88e (34 bytes)</t>
</list></t>

</section>
</section>
<section anchor="overview-sec-properties" title="Overview of Security Properties">

<section anchor="threat-model" title="Threat Model">

<t>This section describes the threat model using the terms of <xref target="RFC3552"/>.</t>

<t>It is assumed that the endpoints running OSCORE have not themselves
been compromised. The attacker is assumed to have control of the CoAP
channel over which the endpoints communicate, including intermediary
nodes. The attacker is capable of launching any passive or active
on-path or off-path attacks; including eavesdropping, traffic
analysis, spoofing, insertion, modification, deletion, delay, replay,
man-in-the-middle, and denial-of-service attacks. This means that the
attacker can read any CoAP message on the network and undetectably
remove, change, or inject forged messages onto the wire.</t>

<t>OSCORE targets the protection of the CoAP request/response layer (Section 2 of <xref target="RFC7252"/>) between the endpoints, including the CoAP Payload, Code, Uri-Path/Uri-Query, and the other Class E option instances (<xref target="coap-options"/>).</t>

<t>OSCORE does not protect the CoAP messaging layer (Section 2 of <xref target="RFC7252"/>) or other lower layers involved in routing and transporting the CoAP requests and responses.</t>

<t>Additionally, OSCORE does not protect Class U option instances
(<xref target="coap-options"/>), as these are used to support CoAP
forward proxy operations (see Section 5.7.2 of <xref
target="RFC7252"/>). The supported proxies (forwarding,
cross-protocol, e.g., CoAP to CoAP-mappable protocols such as HTTP)
must be able to change certain Class U options (by instruction from
the Client), resulting in the CoAP request being redirected to the
server. Changes caused by the proxy may result in the request not
reaching the server or reaching the wrong server. For cross-protocol
proxies, mappings are done on the Outer part of the message so these
protocols are essentially used as transport. Manipulation of these
options may thus impact whether the protected message reaches or does
not reach the destination endpoint.</t>

<t>Attacks on unprotected CoAP message fields generally causes denial-of-service attacks which are out of scope of this document, more details are given in <xref target="unprot-fields"/>.</t>

<t>Attacks against the CoAP request-response layer are in scope. OSCORE is intended to protect against eavesdropping, spoofing, insertion, modification, deletion, replay, and man-in-the middle attacks.</t>

<t>OSCORE is susceptible to traffic analysis as discussed later in <xref target="overview-sec-properties"/>.</t>

</section>
<section anchor="supp-proxy-op" title="Supporting Proxy Operations">

<t>CoAP is designed to work with intermediaries reading and/or
changing CoAP message fields to perform supporting operations in
constrained environments, e.g., forwarding and cross-protocol
translations.</t>

<t>Securing CoAP on the transport layer protects the entire message
between the endpoints, in which case CoAP proxy operations are not
possible. In order to enable proxy operations, security on the transport
layer needs to be terminated at the proxy; in which case, the CoAP
message in its entirety is unprotected in the proxy.</t>

<t>Requirements for CoAP end-to-end security are specified in <xref
target="CoAP-E2E-Sec"/>, in particular, forwarding is detailed in
Section 2.2.1. The client and server are assumed to be honest, while
proxies and gateways are only trusted to perform their intended
operations.</t>

<t>By working at the CoAP layer, OSCORE enables different CoAP message
fields to be protected differently, which allows message fields
required for proxy operations to be available to the proxy while
message fields intended for the other endpoint remain protected. In
the remainder of this section, we analyze how OSCORE protects the
protected message fields and the consequences of message fields
intended for proxy operation being unprotected.</t>

</section>
<section anchor="prot-message-fields" title="Protected Message Fields">

<t>Protected message fields are included in the plaintext (<xref
target="plaintext"/>) and the AAD (<xref
target="AAD"/>) of the COSE_Encrypt0 object and encrypted using an
AEAD algorithm.</t>

<t>OSCORE depends on a preestablished random Master Secret (<xref
target="master-secret"/>) used to derive encryption keys, and a
construction for making (key, nonce) pairs unique (<xref
target="kn-uniqueness"/>). Assuming this is true, and the keys are
used for no more data than indicated in <xref target="max-seq"/>,
OSCORE should provide the following guarantees:</t>

<t><list style="symbols">
  <t>Confidentiality: An attacker should not be able to determine the plaintext contents of a given OSCORE message or determine that different plaintexts are related (<xref target="plaintext"/>).</t>
  <t>Integrity: An attacker should not be able to craft a new OSCORE message with protected message fields different from an existing OSCORE message that will be accepted by the receiver.</t>
  <t>Request-response binding: An attacker should not be able to make a client match a response to the wrong request.</t>
  <t>Non-replayability: An attacker should not be able to cause the receiver to accept a message that it has previously received and accepted.</t>
</list></t>

<t>In the above, the attacker is anyone except the endpoints, e.g., a compromised intermediary. Informally, OSCORE provides these properties by AEAD-protecting the plaintext with a strong key and uniqueness of (key, nonce) pairs. AEAD encryption <xref target="RFC5116"/> provides confidentiality and integrity for the data. Response-request binding is provided by including the 'kid' and Partial IV of the request in the AAD of the response. Non-replayability of requests and notifications is provided by using unique (key, nonce) pairs and a replay protection mechanism (application dependent, see <xref target="replay-protection"/>).</t>

<t>OSCORE is susceptible to a variety of traffic analysis attacks
based on observing the length and timing of encrypted packets. OSCORE
does not provide any specific defenses against this form of attack,
but the application may use a padding mechanism to prevent an attacker
from directly determining the length of the padding. However,
information about padding may still be revealed by side-channel
attacks observing differences in timing.</t>

</section>
<section anchor="kn-uniqueness" title="Uniqueness of (key, nonce)">

<t>In this section, we show that (key, nonce) pairs are unique as long as the requirements in Sections <xref target="req-params" format="counter"/> and <xref target="max-seq" format="counter"/> are followed.</t>

<t>Fix a Common Context (<xref target="context-definition"/>) and an endpoint, called the encrypting endpoint. An endpoint may alternate between client and server roles, but each endpoint always encrypts with the Sender Key of its Sender Context. Sender Keys are (stochastically) unique since they are derived with HKDF using unique Sender IDs, so messages encrypted by different endpoints use different keys. It remains to be proven that the nonces used by the fixed endpoint are unique.</t>

<t>Since the Common IV is fixed, the nonces are determined by PIV, where PIV takes the value of the Partial IV of the request or of the response, and by the Sender ID of the endpoint generating that Partial IV (ID_PIV). The nonce construction (<xref target="nonce"/>) with the size of the ID_PIV (S) creates unique nonces for different (ID_PIV, PIV) pairs. There are two cases:</t>

<t>A. For requests, and responses with Partial IV (e.g., Observe notifications):</t>

<t><list style="symbols">
  <t>ID_PIV = Sender ID of the encrypting endpoint</t>
  <t>PIV = current Partial IV of the encrypting endpoint</t>
</list></t>

<t>Since the encrypting endpoint steps the Partial IV for each use, the nonces used in case A are all unique as long as the number of encrypted messages is kept within the required range (<xref target="max-seq"/>).</t>

<t>B. For responses without Partial IV (e.g., single response to a request):</t>

<t><list style="symbols">
  <t>ID_PIV = Sender ID of the endpoint generating the request</t>
  <t>PIV = Partial IV of the request</t>
</list></t>

<t>Since the Sender IDs are unique, ID_PIV is different from the Sender ID of the encrypting endpoint. Therefore, the nonces in case B are different compared to nonces in case A, where the encrypting endpoint generated the Partial IV. Since the Partial IV of the request is verified for replay (<xref target="replay-protection"/>) associated to this Recipient Context, PIV is unique for this ID_PIV, which makes all nonces in case B distinct.</t>

</section>
<section anchor="unprot-fields" title="Unprotected Message Fields">

<t>This section analyzes attacks on message fields that are not protected by OSCORE according to the threat model <xref target="threat-model"/>.</t>

<section anchor="sec-coap-headers" title="CoAP Header Fields">

<t><list style="symbols">
  <t>Version. The CoAP version <xref target="RFC7252"/> is not expected to be sensitive to disclosure. Currently, there is only one CoAP version defined. A change of this parameter is potentially a denial-of-service attack. Future versions of CoAP need to analyze attacks to OSCORE-protected messages due to an adversary changing the CoAP version.</t>

  <t>Token/Token Length. The Token field is a client-local identifier
  for differentiating between concurrent requests <xref
  target="RFC7252"/>. CoAP proxies are allowed to read and change
  Token and Token Length between hops. An eavesdropper reading the
  Token can match requests to responses that can be used in traffic
  analysis. In particular, this is true for notifications, where
  multiple responses are matched to one request. Modifications of
  Token and Token Length by an on-path attacker may become a
  denial-of-service attack, since it may prevent the client to
  identify to which request the response belongs or to find the
  correct information to verify integrity of the response.</t>
  
  <t>Code. The Outer CoAP Code of an OSCORE message is POST or FETCH
  for requests with corresponding response codes. An endpoint
  receiving the message discards the Outer CoAP Code and uses the
  Inner CoAP Code instead (see <xref target="coap-header"/>). Hence,
  modifications from attackers to the Outer Code do not impact the
  receiving endpoint. However, changing the Outer Code from FETCH to a
  Code value for a method that does not work with Observe (such as
  POST) may, depending on proxy implementation since Observe is
  undefined for several Codes, cause the proxy to not forward
  notifications, which is a denial-of-service attack. The use of FETCH
  rather than POST reveals no more than what is revealed by the
  presence of the Outer Observe option.</t>

  <t>Type/Message ID. The Type/Message ID fields <xref target="RFC7252"/> reveal information about the UDP transport binding, e.g., an eavesdropper reading the Type or Message ID gain information about how UDP messages are related to each other. CoAP proxies are allowed to change Type and Message ID. These message fields are not present in CoAP over TCP <xref target="RFC8323"/> and do not impact the request/response message. A change of these fields in a UDP hop is a denial-of-service attack. By sending an ACK, an attacker can make the endpoint believe that it does not need to retransmit the previous message. By sending a RST, an attacker may be able to cancel an observation. By changing a NON to a CON, the attacker can cause the receiving endpoint to ACK messages for which no ACK was requested.</t>

  <t>Length. This field contains the length of the message <xref target="RFC8323"/>, which may be used for traffic analysis. This message field is not present in CoAP over UDP and does not impact the request/response message. A change of Length is a denial-of-service attack similar to changing TCP header fields.</t>
</list></t>

</section>
<section anchor="sec-coap-options" title="CoAP Options">

<t><list style="symbols">
  <t>Max-Age. The Outer Max-Age is set to zero to avoid unnecessary caching of OSCORE error responses. Changing this value thus may cause unnecessary caching. No additional information is carried with this option.</t>
  <t>Proxy-Uri/Proxy-Scheme. These options are used in CoAP forward proxy deployments. With OSCORE, the Proxy-Uri option does not contain the Uri-Path/Uri-Query parts of the URI. The other parts of Proxy-Uri cannot be protected because forward proxies need to change them in order to perform their functions. The server can verify what scheme is used in the last hop, but not what was requested by the client or what was used in previous hops.</t>
  <t>Uri-Host/Uri-Port. In forward proxy deployments, the Uri-Host/Uri-Port may be changed by an adversary, and the application needs to handle the consequences of that (see <xref target="uri-host"/>).  The Uri-Host may either be omitted, reveal information equivalent to that of the IP address, or reveal more privacy-sensitive information, which is discouraged.</t>

  <t>Observe. The Outer Observe option is intended for a proxy to
  support forwarding of Observe messages, but it is ignored by the
  endpoints since the Inner Observe option determines the processing in the
  endpoints. Since the Partial IV provides absolute ordering of
  notifications, it is not possible for an intermediary to spoof
  reordering (see <xref target="observe"/>). The absence of Partial
  IV, since only allowed for the first notification, does not prevent
  correct ordering of notifications. The size and distributions of
  notifications over time may reveal information about the content or
  nature of the notifications.  Cancellations (<xref
  target="observe-registration"/>) are not bound to the corresponding
  registrations in the same way responses are bound to requests in
  OSCORE (see <xref target="prot-message-fields"/>).  However, that does not make attacks based on mismatched
     cancellations possible, since for cancellations to be accepted, all options
     in the decrypted message except for ETag options MUST be the same
     (see <xref
  target="observe"/>).</t>
  
  <t>Block1/Block2/Size1/Size2. The Outer Block options enable
  fragmentation of OSCORE messages in addition to segmentation
  performed by the Inner Block options. The presence of these options
  indicates a large message being sent, and the message size can be
  estimated and used for traffic analysis. Manipulating these options
  is a potential denial-of-service attack, e.g., injection of alleged
  Block fragments. The specification of a maximum size of message,
  MAX_UNFRAGMENTED_SIZE (<xref target="outer-block-options"/>), above
  which messages will be dropped, is intended as one measure to
  mitigate this kind of attack.</t>
  
  <t>No-Response. The Outer No-Response option is used to support
  proxy functionality, specifically to avoid error transmissions from
  proxies to clients, and to avoid bandwidth reduction to servers by
  proxies applying congestion control when not receiving
  responses. Modifying or introducing this option is a potential
  denial-of-service attack against the proxy operations, but since the
  option has an Inner value, its use can be securely agreed upon between the
  endpoints. The presence of this option is not expected to reveal any
  sensitive information about the message exchange.</t>
  
  <t>OSCORE. The OSCORE option contains information about the
  compressed COSE header. Changing this field may cause OSCORE
  verification to fail.</t>
</list></t>

</section>
<section anchor="error-and-signaling-messages" title="Error and Signaling Messages">

<t>Error messages occurring during CoAP processing are protected end-to-end. Error messages occurring during OSCORE processing are not always possible to protect, e.g., if the receiving endpoint cannot locate the right security context. For this setting, unprotected error messages are allowed as specified to prevent extensive retransmissions. Those error messages can be spoofed or manipulated, which is a potential denial-of-service attack.</t>

<t>This document specifies OPTIONAL error codes and specific diagnostic payloads for OSCORE processing error messages. Such messages might reveal information about how many and which security contexts exist on the server. Servers MAY want to omit the diagnostic payload of error messages, use the same error code for all errors, or avoid responding altogether in case of OSCORE processing errors, if that is a security concern for the application. Moreover, clients MUST NOT rely on the error code or the diagnostic payload to trigger specific actions, as these errors are unprotected and can be spoofed or manipulated.</t>

<t>Signaling messages used in CoAP over TCP <xref target="RFC8323"/> are intended to be hop-by-hop; spoofing signaling messages can be used as a denial-of-service attack of a TCP connection.</t>

</section>
<section anchor="http-message-fields" title="HTTP Message Fields">

<t>In contrast to CoAP, where OSCORE does not protect header fields to enable CoAP-CoAP proxy operations, the use of OSCORE with HTTP is restricted to transporting a protected CoAP message over an HTTP hop. Any unprotected HTTP message fields may reveal information about the transport of the OSCORE message and enable various denial-of-service attacks.
It is RECOMMENDED to additionally use TLS <xref target="RFC8446"/> for HTTP hops, which enables encryption and integrity protection of headers, but still leaves some information for traffic analysis.</t>

</section>
</section>
</section>
<section anchor="cddl-sum" title="CDDL Summary">

<t>Data structure definitions in the present specification employ the
CDDL language for conciseness and precision 
<xref target="RFC8610"/>. This appendix summarizes the small subset of CDDL that is used 
in the present specification.</t>

<t>Within the subset being used here, a CDDL rule is of the form <spanx style="verb">name =
type</spanx>, where <spanx style="verb">name</spanx> is the name given to the <spanx style="verb">type</spanx>.
A <spanx style="verb">type</spanx> can be one of:</t>

<t><list style="symbols">
  <t>a reference to another named type, by giving its name.  The
predefined named types used in the present specification are as follows:
<spanx style="verb">uint</spanx>, an unsigned integer (as represented in CBOR by major type 0);
<spanx style="verb">int</spanx>, an unsigned or negative integer (as represented in CBOR by major
type 0 or 1);
<spanx style="verb">bstr</spanx>, a byte string (as represented in CBOR by major type 2);
<spanx style="verb">tstr</spanx>, a text string (as represented in CBOR by major type 3);</t>
  <t>a choice between two types, by giving both types separated by a <spanx style="verb">/</spanx>;</t>
  <t>an array type (as represented in CBOR by major type 4), where the
sequence of elements of the array is described by giving a sequence
of entries separated by commas <spanx style="verb">,</spanx>, and this sequence is enclosed by
square brackets <spanx style="verb">[</spanx> and <spanx style="verb">]</spanx>.
Arrays described by an array description contain elements that
correspond one-to-one to the sequence of entries given.
Each entry of an array description is of the form <spanx style="verb">name : type</spanx>, where
<spanx style="verb">name</spanx> is the name given to the entry and <spanx style="verb">type</spanx> is the type of the
array element corresponding to this entry.</t>
</list></t>

</section>
<section numbered="no" anchor="acknowledgments" title="Acknowledgments">


<t>The following individuals provided input to this document: Christian Amsuess, Tobias Andersson, Carsten Bormann, Joakim Brorsson, Ben Campbell, Esko Dijk, Jaro Fietz, Thomas Fossati, Martin Gunnarsson, Klaus Hartke, Rikard Hoeglund, Mirja Kuehlewind, Kathleen Moriarty, Eric Rescorla, Michael Richardson, Adam Roach, Jim Schaad, Peter van der Stok, Dave Thaler, Martin Thomson, Marco Tiloca, William Vignat, and Malisa Vucinic.</t>

<t>Ludwig Seitz and Goeran Selander worked on this document as part of the CelticPlus project CyberWI, with funding from Vinnova. Ludwig Seitz had additional funding from the SSF project SEC4Factory under the grant RIT17-0032.</t>

</section>

  </back>
</rfc>
