<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "reference.RFC.2119.xml">
<!ENTITY RFC5226 SYSTEM "reference.RFC.5226.xml">
<!ENTITY RFC5234 SYSTEM "reference.RFC.5234.xml">
<!ENTITY RFC5987 SYSTEM "reference.RFC.5987.xml">
<!ENTITY RFC6265 SYSTEM "reference.RFC.6265.xml">
<!ENTITY RFC7230 SYSTEM "reference.RFC.7230.xml">
<!ENTITY RFC7235 SYSTEM "reference.RFC.7235.xml">
<!ENTITY RFC7564 SYSTEM "reference.RFC.7564.xml">
<!ENTITY RFC7615 SYSTEM "reference.RFC.7615.xml">
<!ENTITY W3C.REC-webstorage-20130730 SYSTEM "reference.W3C.REC-webstorage-20130730.xml">

<!ENTITY MUST "MUST">
<!ENTITY MUST_NOT "MUST&nbsp;NOT">
<!ENTITY SHALL "SHALL">
<!ENTITY SHALL_NOT "SHALL&nbsp;NOT">
<!ENTITY REQUIRED "REQUIRED">
<!ENTITY SHOULD "SHOULD">
<!ENTITY SHOULD_NOT "SHOULD&nbsp;NOT">
<!ENTITY RECOMMENDED "RECOMMENDED">
<!ENTITY NOT_RECOMMENDED "NOT&nbsp;RECOMMENDED">
<!ENTITY OPTIONAL "OPTIONAL">
<!ENTITY MAY "MAY">
<!ENTITY minus "&nbhy;">
<!ENTITY _401-B0 "401&nbhy;B0">
<!ENTITY _401-B0-stale "&_401-B0;&nbhy;stale">
<!ENTITY _200-Optional-B0 "200&nbhy;Optional&nbhy;B0">
<!ENTITY _401-B1 "401&nbhy;B1">
<!ENTITY _req-A1 "req&nbhy;A1">
<!ENTITY _req-A3 "req&nbhy;A3">
<!ENTITY _200-B4 "200&nbhy;B4">
<!ENTITY _Authentication-Info "Authentication&nbhy;Info">
<!ENTITY _WWW-Authenticate "WWW&nbhy;Authenticate">
<!ENTITY _Optional-WWW-Authenticate "Optional&nbhy;&_WWW-Authenticate;">
<!ENTITY _Authentication-Control "Authentication&nbhy;Control">
<!ENTITY _Authorization "Authorization">
<!ENTITY _Protocol_version_token "&nbhy;draft07">
<!ENTITY _iso11770-4-dl-2048 "iso-kam3&nbhy;dl&nbhy;2048-sha256">
<!ENTITY _iso11770-4-dl-4096 "iso-kam3&nbhy;dl&nbhy;4096-sha512">
<!ENTITY _iso11770-4-ec-p256 "iso-kam3&nbhy;ec&nbhy;p256-sha256">
<!ENTITY _iso11770-4-ec-p521 "iso-kam3&nbhy;ec&nbhy;p521-sha512">
<!ENTITY _tls-key "tls&nbhy;key">
<!ENTITY _tls-cert "tls&nbhy;cert">
<!ENTITY _auth-scheme "auth&nbhy;scheme">
<!ENTITY _location-when-unauthenticated "location&nbhy;when&nbhy;unauthenticated">
<!ENTITY _location-when-logout "location&nbhy;when&nbhy;logout">
<!ENTITY _nc-max "nc&nbhy;max">
<!ENTITY _nc-window "nc&nbhy;window">
<!ENTITY _logout-timeout "logout&nbhy;timeout">
<!ENTITY _100-continue "100&nbhy;continue">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc number="8053" category="exp" submissionType="IETF" consensus="yes" ipr="trust200902">

  <front>
    <title abbrev="HTTP Auth. Ext. for Interactive Clients">HTTP Authentication Extensions for Interactive Clients</title>

    <author fullname="Yutaka Oiwa" initials="Y." surname="Oiwa">
      <organization abbrev="ITRI, AIST">National Institute of Advanced Industrial Science and Technology</organization>

      <address>
        <postal>
          <street>Information Technology Research Institute</street>
          <street>Tsukuba Central 1</street>
          <street>1-1-1 Umezono</street>
          <city>Tsukuba-shi</city><region>Ibaraki</region>
          <country>Japan</country>
        </postal>

        <email>y.oiwa@aist.go.jp</email>
      </address>
    </author>

    <author fullname="Hajime Watanabe" initials="H." surname="Watanabe">
      <organization abbrev="ITRI, AIST">National Institute of Advanced Industrial Science and Technology</organization>
      <address>
        <postal>
          <street>Information Technology Research Institute</street>
          <street>Tsukuba Central 1</street>
          <street>1-1-1 Umezono</street>
          <city>Tsukuba-shi</city><region>Ibaraki</region>
          <country>Japan</country>
        </postal>

        <email>h-watanabe@aist.go.jp</email>
      </address>
    </author>

    <author fullname="Hiromitsu Takagi" initials="H." surname="Takagi">
      <organization abbrev="ITRI, AIST">National Institute of Advanced Industrial Science and Technology</organization>
      <address>
        <postal>
          <street>Information Technology Research Institute</street>
          <street>Tsukuba Central 1</street>
          <street>1-1-1 Umezono</street>
          <city>Tsukuba-shi</city><region>Ibaraki</region>
          <country>Japan</country>
        </postal>

        <email>takagi.hiromitsu@aist.go.jp</email>
      </address>
    </author>

    <author fullname="Kaoru Maeda" initials="K." surname="Maeda">
      <organization abbrev="Lepidum">Lepidum Co. Ltd.</organization>
      <address>
        <postal>
          <street>Village Sasazuka 3, Suite #602</street>
	  <street>1-30-3 Sasazuka</street>
          <city>Shibuya-ku</city><region>Tokyo</region>
          <country>Japan</country>
        </postal>

        <email>maeda@lepidum.co.jp</email>
      </address>
    </author>

    <author fullname="Tatsuya Hayashi" initials="T." surname="Hayashi">
      <organization abbrev="Lepidum">Lepidum Co. Ltd.</organization>
      <address>
        <postal>
          <street>Village Sasazuka 3, Suite #602</street>
	  <street>1-30-3 Sasazuka</street>
          <city>Shibuya-ku</city><region>Tokyo</region>
          <country>Japan</country>
        </postal>

        <email>hayashi@lepidum.co.jp</email>
      </address>
    </author>

    <author fullname="Yuichi Ioku" initials="Y." surname="Ioku">
      <organization>Individual Contributor</organization>
      <address>
        <email>mutual-work@ioku.org</email>
      </address>
    </author>

    <date month="January" year="2017" /> 

    <area>Security</area>
    <workgroup>HTTPAUTH Working Group</workgroup>

    <keyword>HTTP, authentication</keyword>

    <abstract>
      <t>
   This document specifies extensions for the HTTP authentication
   framework for interactive clients.  Currently, 
   fundamental features of HTTP-level authentication are insufficient for
   complex requirements of various Web-based applications.  This forces
   these applications to implement their own authentication frameworks
   by means such as HTML forms, which becomes one of the hurdles
   against introducing secure authentication mechanisms handled jointly by
   servers and user agents.
   The extended framework fills gaps between Web application requirements and
   HTTP authentication provisions to solve the above problems, while maintaining
   compatibility with existing Web and non-Web uses of HTTP authentication.
      </t>
    </abstract>
  </front>

<middle>

<section title="Introduction">

     <t>
        This document defines several extensions to the current
        HTTP authentication framework, to provide functionality
        comparable with current, widely used,
        form-based Web authentication.  A majority of the recent websites
        on the Internet use custom application-layer
        authentication implementations using Web forms.  The reasons for
        these may vary, but many people believe that the current HTTP
        Basic and Digest authentication methods do not have
        enough functionality (including good user interfaces)
        to support most realistic Web-based applications.
        However, such use of form-based Web authentication
	has several weaknesses against attacks like phishing, 
        because all behavior of the authentication is controlled
        from the server-side application.  This makes it really hard to
        implement any cryptographically strong authentication mechanisms
        into Web systems. To overcome this problem, we need to
        "modernize" the HTTP authentication framework so that better
        client-controlled secure methods can be used with Web applications.

        The extensions proposed in this document include:
        <list style="symbols">
	  <t>optional authentication on HTTP (<xref target="optional-auth" />),</t>
	  <t>log out from both the server and client side (<xref
	  target="auth-control-header" />), and</t>
	  <t>finer control for redirection depending on the authentication status (<xref target="auth-control-header" />)</t>
      </list>
     </t>

  <section title="Terminology">

    <t>The key words "&MUST;", "&MUST_NOT;", "&REQUIRED;", "&SHALL;", "&SHALL_NOT;",
        "&SHOULD;", "&SHOULD_NOT;", "&RECOMMENDED;", "&NOT_RECOMMENDED;", "&MAY;", and
        "&OPTIONAL;" in this document are to be interpreted as described
        in <xref target="RFC2119" />.</t>

    <t>This document distinguishes the terms "client" and "user" in the following way:
       a "client" is an entity understanding and talking HTTP and the specified authentication protocol,
       usually computer software; a "user" is a (usually natural) person
       who wants to access data resources using "a client".</t>

  </section>

</section>

<section anchor="definitions" title="Definitions">

<section anchor="state_term_definitions" title="Terms for Describing Authentication Protocol Flow">
<t>
HTTP Authentication defined in <xref target="RFC7235" /> can involve
several pairs of HTTP requests/responses.
Throughout this document, the following terms are used to categorize those
messages. </t>
<t>For requests:
<list style="hanging" hangIndent="3">
<t hangText="1)">A non-authenticating request is a request not attempting any authentication: a request without any &_Authorization; header field.
</t>
<t hangText="2)">An authenticating request is the opposite: a request with an &_Authorization; header field.
</t>
</list>
For responses:
<list style="hanging" hangIndent="3">
<t hangText="1)">A non-authenticated response is a response that does not involve
any HTTP authentication.  It does not contain any
&_WWW-Authenticate; (<xref target="RFC7235" />) or &_Authentication-Info; header field (<xref target="RFC7615" />).
</t>
<t>
Servers send this response when the requested resource is not
protected by an HTTP authentication mechanism.  In the context of this
specification, non-authentication-related negative responses (e.g., 403
and 404) are also considered non-authenticated responses.
</t>

<t>(See the note on successfully authenticated responses below for some ambiguous cases.)</t>

<t hangText="2)">
An authentication-initializing response is a response that requires or allows clients to start authentication
attempts. Servers send this response when the requested resource is
protected by an HTTP authentication mechanism, and the request meets
one of the following cases:

<list style="symbols">
<t> The request is a non-authenticating request, or</t>
<t> The request contained an authentication trial directed to
    a protection space (realm) other than the one that the server expected.</t>
</list>

The server will specify the protection space for authentication in this response.
</t>

<t>Upon receiving this response, the client's behavior is further divided to two possible
cases:
<list style="symbols">
<t>If the client has no prior knowledge on authentication
credentials (e.g., a username and a password) related to the requested
protection space, the protocol flow terminates and the client will
ask the user to provide authentication credentials.</t>
<t>On the other hand, if the client already has enough authentication credentials
to the requested protection space, the client
will automatically send an authenticating request.
Such cases often occur when the client does not know beforehand that
the current request-URL requires authentication.
</t>
</list>
</t>

<t hangText="3)"> A successfully authenticated response
is a response for an authenticating request meaning that the
authentication attempt was granted.  (Note: if the authentication
scheme used does not use an &_Authentication-Info; header field,
it can't be distinguished from a non-authenticated response.)
</t>

<t hangText="4)"> An intermediate authenticating response
is a response for an
authenticating request that requires more reaction by the client
software without involving users.  Such a response is required when an
authentication scheme requires two or more round-trip messages to
perform authentication, or when an authentication scheme uses some
speculative short-cut method (such as uses of cached shared secrets)
and it fails.
</t>
<t hangText="5)"> A negatively authenticated response
is a response for an authenticating request, which means that the
authentication attempt was declined and cannot continue without
a different set of authentication credentials.  
Clients typically erase the memory of the active credentials
and ask the user for other ones.
</t>
<t>
Usually the format of these responses is the same as the one for
authentication-initializing responses.  Clients can distinguish
negatively authenticated responses from authentication-initializing responses by
comparing the protection spaces contained in the request and in the
response.
</t>
</list>
</t>

<t>
<xref target="figure-client-dia" /> shows a state diagram of generic HTTP authentication with the above message categorization.
Note that many authentication schemes use only a subset of the transitions described in the diagram.
Labels in the figure show the abbreviated names of response types.
</t>
<figure anchor="figure-client-dia" title="Generic State Diagram for HTTP Authentication"  src="http-authext-dia.png" alt="">
<artwork><![CDATA[
      ===========                                -----------------
      NEW REQUEST                               ( UNAUTHENTICATED )
      ===========                                -----------------
           |                                            ^ non-auth.
           v                                            | response
+----------------------+ NO                         +-------------+
| The requested URI    |--------------------------->| send normal |
| known to be auth'ed? |           ---------------->|   request   |
+----------------------+          /                 +-------------+
       YES |                     /             initializing|
           v                    /                          |
  +------------------+ NO      /                           |
  | Can auth-req.(*1)|---------                            |
  | be constructed?  |                                     |
  +------------------+                                     |
       YES |            initializing                       |
           |      ---------------------------------------. |
           |     /                                       v v
           |    |            ----------------    NO  +-----------+
           |    |           ( AUTH-REQUESTED )<------| passwords |
           |    |            ----------------        |etc. known?|
           v    |                                    +-----------+
     +-----------+ negative   -------------   negative     |YES
     |   send    |---------->( AUTH-FAILED )<---------,    |
    /| auth-req  |            -------------           |    |
   / +-----------+\                                   |    v
  |             \  \  intermediate                   +-----------+ 
  |              \  -------------------------------->|   send    | 
  |               \                                  | auth-req  | 
  | non-auth.      \successful            successful +-----------+
  | response (*2)   \                               /     |    ^
  v                  \                             /      |    |
 -----------------    \       --------------      /       `----'
( UNAUTHENTICATED )    ----->( AUTH-SUCCEED )<----    intermediate
 -----------------            --------------
]]>
</artwork>
</figure>
<t>
Note: (*1) For example, the "Digest" scheme requires a server-provided
           nonce to construct client-side challenges.<vspace />
      (*2) In "Basic" and some others, this cannot be distinguished
           from a successfully authenticated response.
</t>

</section>
<section anchor="syntax-notation" title="Syntax Notation">
<t>
This specification uses an extended ABNF syntax defined in <xref
target="RFC7230" /> and  <xref target="RFC5234" />.  The following syntax
definitions are quoted from <xref target="RFC7230" /> and <xref
target="RFC7235" />: auth-scheme, quoted-string, auth-param, SP, BWS, header-field, and challenge.  It also uses the convention of using header field names for specifying the syntax of values for the header field.
</t>
<t>
Additionally, this specification uses the following syntax definitions
as a refinement for token and the right-hand-side of auth-param in <xref target="RFC7235" />.
</t>
<figure anchor="figure-auth-common-syntax" title="The BNF Syntax for Common Notations">
<artwork type="abnf">
 bare-token           = bare-token-lead-char *bare-token-char
 bare-token-lead-char = %x30-39 / %x41-5A / %x61-7A
 bare-token-char      = %x30-39 / %x41-5A / %x61-7A / "-" / "_"
 extension-token      = "-" bare-token 1*("." bare-token)
 extensive-token      = bare-token / extension-token
 integer              = "0" / (%x31-39 *%x30-39)  ; no leading zeros
</artwork>
</figure>
<t>
Extensive-tokens are used in this protocol where the set of acceptable
tokens includes private extensions.  Any extensions of this
protocol &MAY; use either bare-tokens allocated by IANA
(under the procedure described in <xref target="IANA" />), or
extension-tokens with the format
"-&lt;token&gt;.&lt;domain&nbhy;name&gt;", where &lt;domain-name&gt;
is a valid (sub-)domain name on the Internet owned by the party who
defines the extension.
</t>
</section>
</section>

<section anchor="optional-auth" title="Optional Authentication">

<t>
The &_Optional-WWW-Authenticate; header enables a non-mandatory authentication,
which is not possible under the current HTTP authentication mechanism.
</t>

<t>
In several Web applications, users can access the same contents as
both a guest user and an authenticated user.  In most Web applications,
this functionality is implemented using <xref target="RFC6265">HTTP cookies</xref> and custom form-based authentication.
The new authentication method using this message will provide a replacement for
these authentication systems.
</t>

<t>
Servers &MAY; send HTTP non-interim responses
containing the &_Optional-WWW-Authenticate; header as a replacement
for a 401 response when it is authentication-initializing.
The &_Optional-WWW-Authenticate; header &MUST_NOT; be sent on 401 responses
(i.e., a usual WWW-Authenticate header &MUST; be used on 401 responses).
</t>

<figure anchor="figure-200-Optional-WWW-Authenticate" title="BNF Syntax for Optional-WWW-Authenticate Header">
<artwork type="abnf2616">
 Optional-WWW-Authenticate = 1#challenge
</artwork>
</figure>

<t>
<list style="empty">
<t>
Example:<vspace blankLines="0" />
HTTP/1.1 200 OK<vspace blankLines="0" />
&_Optional-WWW-Authenticate;: Basic realm="xxxx"
</t>
</list>
</t>

<t>
The challenges contained in the &_Optional-WWW-Authenticate; header are the same as
those for a 401 response corresponding to the same request.
For authentication-related matters, an optional authentication request will have the same meaning
as a 401 message with a corresponding &_WWW-Authenticate; header (as an authentication-initializing response).
(The behavior for other matters &MAY; be different between
the optional authentication and 401 messages.
For example, clients &MAY; choose to cache the 200 messages
with the &_Optional-WWW-Authenticate; header field but not the 401 messages
by default.)
</t>

<t>
A response with an &_Optional-WWW-Authenticate; header &SHOULD; be
returned from the server only when the request is either non-authenticated
or authenticating to a wrong (not the server's expected) protection space.
If a response is either an intermediate or a negative response 
to a client's authentication attempt, the server &MUST; respond
with a 401 status response with a &_WWW-Authenticate; header instead.
Failure to comply with this rule will render clients unable to distinguish
between authentication successes and failures.
</t>

<t>
The server is &NOT_RECOMMENDED; to include an &_Optional-WWW-Authenticate; header
in a positive response when a client's authentication attempt succeeds.
</t>

<t>
Whenever an authentication scheme supports servers sending some
parameter that gives a hint about the URL space for the corresponding
protection space for the same realm (e.g., "path" or "domain"), servers
requesting non-mandatory authentication &SHOULD; send such a parameter
with the response.  Clients supporting non-mandatory authentication
&MUST; recognize the parameter and &MUST; send a request with an
appropriate authentication credential in an &_Authorization; header
for any URI inside the specified paths.
</t>

<t>
Implementations are not required to support this header
for all of their supported authentication schemes
(i.e., they may choose to implement it only for a subset of their supported schemes).
New authentication schemes can require support of the optional
authentication as a prerequisite, though.
</t>

<section title="Note on Optional-WWW-Authenticate and Use of WWW-Authenticate Header with Non-401 Status">
<t>
In the current specification of HTTP/1.1, it is clarified that the WWW-Authenticate
header can be used with messages with status codes other than 401 (Authentication Required).
In particular, the use of the WWW-Authenticate header with the 200 status messages
implies a very similar meaning to the above-defined Optional-WWW-Authenticate header.
</t>
<t>
The design of Optional-WWW-Authenticate header expects that the use of a new header
guarantees that clients that are unaware of this extension will ignore
the header, and that Web developers can rely on that behavior to implement a
secondary fallback method of authentication.
Several behavioral requirements written in the above section also assume
this property and define a necessary functionality to implement
an optional authentication reliably and consistently.
</t>
<t>
On the other hand, some experiments and discussions on the IETF
mailing list revealed that most of (but not necessarily all of) the
existing HTTP clients, at the time of writing, just ignore the
WWW-Authenticate headers in non-401 messages, giving similar
behavior with the Optional-WWW-Authenticate.  However, every corner
case of behavior was not fully tested or well-defined in the
existing specifications.
</t>
<t>
Considering these situations, the authors of this document chose to use
a new header for a new feature "experiment".  This is to avoid
defining every corner-case behavior for the existing standard
WWW-Authentication header in this experimental document, which could
be considered by some implementers as an incompatible changes to existing
specification. 

</t>
<t>
Experimentally, the authors propose that implementers of the standard
HTTP/1.1 specification (especially implementers of this extension)
implement undefined (implementation-dependent) detailed handling of
the WWW-Authenticate header with non-401 status messages similar as
those defined above for the Optional-WWW-Authenticate header.  For
example, we propose that servers return the 401 status for failed
authentication attempts, even when the unauthenticated request to the
same resource will result in the 200 status.
This can determine how
(whether) non-mandatory authentication using the
standard header fields and status codes can be implemented.

If this experiment is
successful, a future revision of this experimental document may
"bless" and recommend the use of a standard WWW-Authenticate header,
with some stricter requirements on some corner-case behavior.
</t>
</section>

</section>

<section title="Authentication-Control Header" anchor="auth-control-header">

<figure anchor="figure-auth-ctrl-syntax" title="The BNF Syntax for the Authentication-Control Header">
<artwork type="abnf2616">
 Authentication-Control = 1#auth-control-entry
 auth-control-entry     = auth-scheme 1*SP 1#auth-control-param
 auth-control-param     = extensive-token BWS "=" BWS token
                        / extensive-token "*" BWS "=" BWS ext-value
 ext-value              = &lt;see RFC 5987, Section 3.2&gt;
</artwork>
</figure>

<t>
The &_Authentication-Control; header provides more precise control of the
client behavior for Web applications using an HTTP authentication protocol.
This header is supposed to be generated in the application layer, as opposed
to the
&_WWW-Authenticate; headers, which will usually be generated by the Web servers.
</t>

<t>
Clients &MAY; freely choose any subset of these parameters to be supported.
Also, these may choose to support any of the parameters for
only a subset of their supported authentication schemes.

However, authentication schemes can require/recommend
support for some of these parameters as a prerequisite.
</t>

<t>
The &_Authentication-Control; header contains one or more "authentication control entries",
each of which corresponds to a single realm for a specific authentication scheme.
If the &_auth-scheme; specified for an entry supports the HTTP "realm" feature,
that entry &MUST; contain the "realm" parameter.
If not, the entry &MUST_NOT; contain the "realm" parameter.
</t>

<t>
Among the multiple entries in the header,
the relevant entries in the header are those corresponding to an
&_auth-scheme; and a realm (if any) for which "the authentication
process is being performed or going to be performed".  In more
detail:
<list style="format (%d)">
<t>
If the response is either an authentication-initializing response
or a negatively authenticated response, there
can be multiple challenges in the WWW-Authenticate header (or
the Optional-WWW-Authenticate header defined in this extension),
each of which corresponds to a different scheme and realm.
In this case, the client has a choice about the scheme and realm they will use to authenticate.
Only the entry in the &_Authentication-Control; header corresponding to that scheme and realm are relevant.
</t>
<t>
If the response is either an intermediate authenticating response or
a successfully authenticated response, 
the scheme and realm given in the Authorization header of the 
HTTP request will determine the currently ongoing authentication process.
Only the entry corresponding to that scheme and realm are relevant.
</t>
</list>
</t>

<t>
The server &MAY; send an &_Authentication-Control; header
containing non-relevant entries.
The client &MUST; ignore all non-relevant entries it received.
</t>

<t>
Every entry contains one or more parameters, each of which is a
name-value pair.  The name of each parameter &MUST; be an
extensive-token.
Clients &MUST; ignore any unknown parameters contained in
this header.
The entries for the same &_auth-scheme; and the realm &MUST_NOT;
contain duplicated parameters for the same name.
Clients &MAY; either take any one of those duplicated entries
or ignore all of them.
</t>

<t>
The type of parameter value depends on the
parameter name as defined in the following subsections.
Regardless of the type, however, the recipients &MUST; accept
both quoted and unquoted representations of values as defined in HTTP.
If the parameter is defined to have a string value,
implementations &MUST; send any value outside of the "token"
ABNF syntax in either a quoted form or an ext-value form (see <xref target="sec-extvalue" />).
If the parameter is defined as a token (or similar) or an integer,
the value &SHOULD; follow the corresponding ABNF syntax after possible
unquoting of the quoted-string value (as defined in HTTP) and
&MUST; be sent in a plain (not an ext-value) form.
(Note: the rest of this document will show all string-value parameters
in quoted forms, and it will show others in unquoted forms.)
</t>

<t>
Any parameters contained in this header &MAY; be ignored by
clients. Also, even when a client accepts this header, users are able
to circumvent the semantics of this header.  Therefore, if this header
is used for security purposes, its use &MUST; be limited to providing
some non-fundamental additional security measures valuable for
end-users (such as client-side logout for protection against console
takeover).  Server-side applications &MUST_NOT; rely on the use of
this header for protecting server-side resources.
</t>

<t>
Note: The header syntax allows servers to specify Authentication-Control for
multiple authentication schemes, either as multiple occurrences of
this header or as a combined single header (see Section 3.2.2 of <xref target="RFC7230" /> for rationale).
The same care as for parsing multiple authentication challenges needs to be taken.
</t>

<section title="Non-ASCII Extended Header Parameters" anchor="sec-extvalue">
<t>
Parameters contained in the Authentication-Control header
&MAY; be extended to non-ASCII values using the framework described in <xref target="RFC5987" />.
All servers and clients &MUST; be capable of receiving and sending values encoded in
<xref target="RFC5987" /> syntax.
</t>
<t>
If a value to be sent contains only ASCII characters, the field &MUST; be sent
using plain RFC 7235 syntax. The syntax as extended by ext-value &MUST_NOT; be used in this case.
</t>
<t>
If a value (except the "realm" header) 
contains one or more non-ASCII characters, the parameter &SHOULD; be sent
using the ext-value syntax defined in Section 3.2 of <xref target="RFC5987" />.
Such a parameter &MUST; have a charset value of "UTF-8", and the
language value &MUST; always be omitted (have an empty value).
The same parameter &MUST_NOT; be sent more than once, regardless of the syntax used.
</t>
<t>
For example, a parameter "username" with the value "Renee of France" &SHOULD; be sent as
&lt; username="Renee of France" &gt;.  If the value is "Ren&lt;e acute&gt;e of France", it &SHOULD; be
sent as <vspace blankLines="0" /> &lt; username*=UTF-8''Ren%C3%89e%20of%20France &gt; instead.
</t>
<t>
Interoperability note: 
<xref target="RFC7235" />, Section 2.2, defines the "realm" authentication parameter
that cannot be replaced by the "realm*" extend parameter.
This means that the use of non-ASCII values for an authentication realm
is not the defined behavior in HTTP.
Unfortunately, some people currently use a non-ASCII realm parameter in reality,
but even its encoding scheme is not well defined.
<vspace blankLines="0" />
Given this background, this document does not specify how to handle
a non-ASCII "realm" parameter in the extended header fields.
If needed, the authors propose using a non-extended
"realm" parameter form, with a wish for maximum interoperability.
</t>
</section>

<section title="Auth-Style Parameter" anchor="auth-control-auth-style">
<t>
Example:<vspace blankLines="0" />
&_Authentication-Control;: Digest realm="protected space",<vspace />
&nbsp; &nbsp; &nbsp; &nbsp; auth-style=modal
</t>

<t>
The parameter "auth-style" specifies the server's preference for
user interface behavior for user authentication.
This parameter can be included in any kind of response; however, it
is only meaningful for either authentication-initializing or
negatively authenticated responses.
The value of this parameter &MUST; be one of the bare-tokens, "modal" or "non-modal".
When the &_Optional-WWW-Authenticate; header is used, the value of
this parameter &MUST; be disregarded and the value "non-modal" is
implied.
</t>

<t>
The value "modal" means that the server thinks the content of the
response (body and other content-related headers) is valuable only for
users refusing the authentication request.  The clients are expected
to ask the user for a password before processing the content.  This behavior
is common for most of the current implementations of Basic and Digest authentication schemes.
</t>

<t>
The value "non-modal" means that the server thinks that the content of the
response (body and other content-related headers) is valuable for
users before processing an authentication request.
The clients are expected to first process the content 
and then provide users with the opportunity to perform authentication.
</t>

<t>
The default behavior for clients is implementation dependent, and
it may also depend on authentication schemes.
The proposed default behavior is "modal" for all authentication schemes
unless otherwise specified.
</t>

<t>
The above two different methods of authentication possibly introduce an observable difference of semantics when the response contains
state-changing side effects; for example, it can affect how <xref
target="RFC6265">Cookie headers</xref> in 401 responses are processed.
However, the server applications &SHOULD_NOT; depend on the existence of such side effects.
</t>

</section>
<section title="Location-When-Unauthenticated Parameter" anchor="auth-control-loc-unauth">
<t>
Example:<vspace blankLines="0" />
&_Authentication-Control;: Mutual realm="auth-space-1",<vspace />
&nbsp; &nbsp; &_location-when-unauthenticated;="http://www.example.com/login.html"
</t>

<t>
The parameter "&_location-when-unauthenticated;" specifies a location to which
any unauthenticated clients should be redirected.
This header can be used, for example, when there is a central login page
for the entire Web application.
The value of this parameter is a string that contains a URL location.
If a received URL is not absolute, the clients &SHOULD;
consider it a relative URL from the current location.
</t>
<t>
This parameter &MAY; be used with a 401 response for an authentication-initializing response.
It can also be contained, although this is &NOT_RECOMMENDED;, in a positive response
with an &_Optional-WWW-Authenticate; header.
The clients &MUST; ignore this parameter when a response is either
successfully authenticated or intermediately authenticated.
</t>
<t>
When a client receives an authentication-initiating response
with this parameter, and if the
client has to ask users for authentication credentials,
the client will treat the entire response
as if it were a 303 "See Other" response with a Location header that
contains the value of this parameter (i.e., the client will be redirected
to the specified location with a GET request).  Unlike a normal 303
response, if the client can process authentication without the user's
interaction, this parameter &MUST; be ignored.
</t>
</section>

<section title="No-Auth Parameter" anchor="auth-control-no-auth">
<t>
Example:<vspace blankLines="0" />
&_Authentication-Control;: Basic realm="entrance", no-auth=true
</t>

<t>
The parameter "no-auth" is a variant of the
&_location-when-unauthenticated; parameter; it specifies that new
authentication attempts are not to be performed on this location in order to
improve the user experience, without specifying the redirection on the HTTP
level.  This header can be used, for example, when there is a central
login page for the entire Web application and when an explicit user interaction
with the Web content is desired before authentication.  The value of this parameter &MUST; be a token
"true".  If the value is incorrect, the client &MAY; ignore this
parameter.
</t>
<t>
This parameter &MAY; be used with authentication-initiating responses.
It can also be contained, although this is &NOT_RECOMMENDED;, in a positive response
with an &_Optional-WWW-Authenticate; header.
The clients &MUST; ignore this parameter when a response is either
successfully authenticated or intermediately authenticated.
</t>
<t>
When a client receives an authentication-initiating 
response with this parameter, if the
client has to ask users for authentication credentials,
the client will ignore the &_WWW-Authenticate; header contained in the
response and treat the whole response as a normal negative 4xx-class
response instead of giving the user an opportunity to start
authentication. If the client can process authentication without the
user's interaction, this parameter &MUST; be ignored.
</t>
<t>
Using this parameter along with the &_location-when-unauthenticated; parameter
is meaningless. If both were supplied, clients &SHOULD; ignore
the &_location-when-unauthenticated; parameter.
</t>
<t>
This parameter &SHOULD_NOT; be used as a security measure to
prevent authentication attempts, as it is easily circumvented by
users.  This parameter &SHOULD; be used solely for improving the user
experience of Web applications.
</t>
</section>

<section title="Location-When-Logout Parameter" anchor="auth-control-loc-logout">
<t>
Example:<vspace blankLines="0" />
&_Authentication-Control;: Digest realm="protected space",<vspace />
&nbsp; &nbsp; &_location-when-logout;="http://www.example.com/byebye.html"
</t>

<t>
The parameter "&_location-when-logout;" specifies a location where
the client is to be redirected when the user explicitly requests a logout.
The value of this parameter &MUST; be a string that contains a URL location.
If a given URL is not absolute, the clients &MUST; consider it a relative URL
from the current location.
</t>
<t>
This parameter &MAY; be used with successfully authenticated
responses.  If this parameter is contained in other kinds of
responses, the clients &MUST; ignore this parameter.
</t>
<t>
When the user tells the client to terminate the current authentication
period, if the client currently displays a page supplied by a response
with this parameter, the client will automatically change the current
location to the location specified in this parameter using a new GET
request, as if it has received a 303 response.  Any operations related
to logout (e.g., erasing memories of username, authentication
credential, and all related one-time credentials such as nonce or keys)
&SHOULD; occur before processing a page transition.
</t>
<t>
When the user requests the client for the termination of an
authentication period, if the client supports this parameter but the
server response does not contain this parameter, the client's
&RECOMMENDED; behavior is as follows: if the request corresponding to
the current content was the GET method, reload the page without the
authentication credential.  Otherwise, keep the current content as-is
and simply forget the authentication status.  The client &SHOULD_NOT;
replay a non-idempotent request without the user's explicit approval.
</t>
<t>
Web applications are encouraged to send this parameter
with an appropriate value for any responses (except those with
redirection (3XX) statuses) for non-GET requests.
</t>
<t>
See <xref target="examples" /> for some examples for possible deployment
of this parameter.
</t>
</section>

<section title="Logout-Timeout Parameter" anchor="auth-control-logout-timeout">
<t>
Example:<vspace blankLines="0" />
&_Authentication-Control;: Basic realm="entrance", &_logout-timeout;=300
</t>

<t>
The parameter "&_logout-timeout;", when contained in a
successfully authenticated response, means that any authentication
credentials and state related to the current protection space are to
be discarded if the time specified in this header (in seconds) has passed
since the time this header was received.  The value &MUST; be an integer.
As a special case, the value 0 means that the server is logging the client
out immediately from the current authentication space and that the client
is now returned to the unauthenticated state.  This does not, however, mean that the
long-term memories for the passwords and passwords-related details
(such as password reminders and auto fill-ins) should be removed.
If a new timeout value is
received for the same authentication space, it cancels the previous
timeout and sets a new timeout.
</t>
</section>

<section title="Username Parameter" anchor="auth-control-user">
<t>
Example:<vspace blankLines="0" />
&_Authentication-Control;: Basic realm="configuration", username="admin"
</t>

<t>
The parameter "username" tells us that the only "username" to be accepted
by the server is the value given in this parameter.
</t>
<t>
This parameter is particularly useful, for example, for
routers and other network appliances with a Web configuration interface.
Many of those use an HTTP Basic authentication with one predefined username,
with many varieties such as "admin", "root", "user", etc.
In the current situation, users have almost no hint about the valid username
upon the authentication request.  Some show the valid value in a "realm" string,
some in the 401-status response page, shown _after_ the user gave up the authentication
and canceled the authentication dialog.
If this parameter is given, the client Web browser can auto-fill the
username field in the authentication dialog before the users attempt to authenticate themselves.
</t>
<t>
This parameter &MAY; be used with authentication-initiating responses or
negatively authenticated responses requiring another attempt at authentication.
The clients &MUST; ignore this parameter when a response is either
successfully authenticated or intermediately authenticated.
</t>
<t>
If the authentication scheme to be used has a syntax limitation on the allowed
usernames (e.g., Basic and Digest do not allow colons in usernames); the
specified value &MUST; follow that limitation.  Clients &SHOULD; ignore
any values that do not conform to such limitations.
</t>
<t>
Also, if the used authentication scheme requires a specific style of
text preparation for the username (e.g., PRECIS <xref target="RFC7564" />
string preparation or Unicode normalization), 
the server &SHOULD; send the values satisfying such requirements
(so that clients can use the given username as is).
</t>
<t>
Clients &MAY; still send any authentication requests with
other usernames, possibly in vain.
Clients are not required (also not forbidden) to give users opportunities 
for supplying a username different from the server-specified one.
Servers are also not strictly required to reject usernames other than specified,
but doing so will usually result in bad user experiences and may confuse users and clients.
</t>
<t>
Although this parameter is useful in a specific class of use cases,
using it in a general use case has many security implications and possible pitfalls.
Please consult <xref target="sec:username" /> before deciding to use this parameter.
</t>
</section>

</section>

<section anchor="examples" title="Usage Examples">
<t>This section shows some examples for applying this extension to
typical websites that use forms and cookies for managing
authentication and authorization.  The content of this section is
not normative and is for illustrative purposes only.
</t>
<t>
In these examples, we assume that there are two kinds of 
clients (Web browsers).
One kind of these implements all features described in the previous
sections.  We also assume that browsers will have a user interface that
allows users to deactivate (log out from) current authentication sessions.
The other kind are the "existing" implementations that do not support any of these features.
</t>
<t>
When not explicitly specified, all settings described below are to be
applied with Authentication-Control headers, and these can be sent to
clients regardless of the authentication status (these will be silently
ignored whenever not effective).
</t>
<section title="Example 1: A Portal Site">
<t>This subsection provides an example application for a site whose
structure is somewhat similar to conventional portal sites.  In
particular, most Web pages are available for guest
(unauthenticated) users, and, if authentication is performed, the content
of these pages is customized for each user.  We assume that the site
has the following kinds of pages currently:
<list style="symbols">
<t>Content pages</t>
<t>Pages/mechanism for performing authentication:
<list style="symbols">
<t>There is one page that asks for a username and a password using a HTML POST form.</t>
<t>After the authentication attempt, the user will be redirected to
either the page that was previously displayed before the
authentication or some specific page.</t>
</list>
</t>
<t>A de-authentication (logout) page.</t>
</list>
</t>
<section title="Case 1: A Simple Application">
<t>
When such a site does not require specific actions upon login and logout, the following simple settings can be used:
<list style="symbols">
<t>Set up an optional authentication to all pages available to guests.  Set up
an Authentication-Control header with the "auth-style=non-modal" setting.</t>
<t>If there are pages only available to authenticated users, set up a
mandatory authentication with the "auth-style=non-modal" setting.</t>
<t>No specific pages for authentication are needed.  It will be performed automatically, directed by the above setting.</t>
<t>A de-authentication page is also not needed.  If the site has one, put "logout-timeout=0" there.</t>
<t>For all pages for POST requests, it is advisable to have a "location-when-logout=&lt;some page&gt;".</t>
</list>
</t>
</section>

<section title="Case 2: Specific Action Required on Logout">
<t>
If the site requires specific actions upon logout, the following settings can be used:
<list style="symbols">
<t>All settings in Case 1 are applied.</t>
<t>For all pages, set up the Authentication-Control header "location-when-logout=&lt;de-authentication page&gt;".</t>
<t>In the de-authentication page, no specific setup is needed.  If there are any direct links to the de-authentication page, put "logout-timeout=0".</t>
</list>
</t>
</section>

<section title="Case 3: Specific Page Displayed before Login">
<t>
If the site needs to display a specific page before login actions (some announcements, user notices, or even advertisements), the following settings can be applied:
<list style="symbols">
<t>Set up an optional authentication to all pages available to guests.
  Set up an Authentication-Control header with "no-auth=true".  Put a link to a specific login page in contents.</t>
<t>If there are pages only available to authenticated users, set up a
mandatory authentication with the "location-when-unauthenticated=&lt;the login page&gt;".</t>
<t>For the specific login page, set up a mandatory authentication.</t> 
<t>For all pages for POST requests, it is advisable to have "location-when-logout=&lt;some page&gt;", too.</t>
<t>De-authentication pages are not needed.  If the site has one, put "logout-timeout=0".</t>
</list>
</t>
</section>

</section>

<section title="Example 2: Authenticated User-Only Sites">
<t>
If almost all pages in the target site require authentication (e.g., an Internet banking site),
or if there is no need to support both unauthenticated and authenticated users on the same resource,
the settings will become simpler. The following are examples for such a site:
<list style="symbols">
<t>Set up a mandatory authentication to all pages available to authenticated users.
Set up an Authentication-Control header with the "auth-style=non-modal" setting.</t>
<t>Set up a handler for the 401-status that requests users to authenticate.</t>
<t>For all pages for POST requests, it is advisable to have a "location-when-logout=&lt;some page&gt;", too.</t>
<t>De-authentication pages are not needed.  If the site will have one, put "logout-timeout=0" there.</t>
</list>
</t>
</section>

<section title="When to Use Cookies">
<t>
In current websites using form-based authentication,
<xref target="RFC6265">Cookies</xref> are used for managing both authorization and application sessions.
Using the extensions in this document, the former features will be
provided by using (extended) HTTP authentication/authorization mechanisms.
In some cases, there will be ambiguity on whether some functions
are for authorization management or for session management.  The following hints will be
helpful for deciding which features to use.
</t>
<t>
<list style="symbols">
<t>
If there is a need to serve multiple sessions for
a single user using multiple browsers concurrently,
use a Cookie for distinguishing between sessions for the same user.
(C.f. if there is a need to distinguish between sessions in the same browser,
<xref target="W3C.REC-webstorage-20130730">HTML5 Web Storage</xref> features can be used instead of Cookies.)
</t>
<t>
If a website is currently deploying a session time-out feature,
consider who benefits from the feature.  In most cases, the main
requirement for such a feature is to protect users from having their 
consoles and browsers hijacked (i.e., benefits are on the users' side).
In such cases, the time-out features provided in this extension can be used.
On the other hand, the requirement is to protect the server's privilege
(e.g., when some regulations require limiting the time difference between
a user's two-factor authentication and financial transaction commitment;
the requirement is strictly on the servers' side),
that should be managed on the server side using Cookies or other
session-management mechanisms.
</t>
</list>
</t>
</section>

<section title="Parallel Deployment with Form/Cookie Authentication">
<t>
In some transition periods, sites may need to support both
HTTP-layer and form-based authentication.
The following example shows one way to achieve that.
</t>
<t>
<list style="symbols">
<t>
If Cookies are used even for HTTP-authenticated users, each session
determined by Cookies &SHOULD; identify which authentication has been used for the session.
</t>
<t>
First, set up any of the above settings for enabling HTTP-layer authentication.
</t>
<t>
For unauthenticated users, add the following things to the Web pages,
unless the client supports this extension and HTTP-level authentication:
<list style="symbols">
<t>
For non-mandatory authenticated pages, add a link to the form-based authenticated pages.
</t>
<t>
For mandatory authenticated pages, either put a link to form-based authenticated pages
or put an HTML-level redirection (using &lt;META http-equiv="refresh" ...&gt; element) to such pages.
</t>
</list>
</t>
<t>
In the form-based authenticated pages, if users are not authenticated, the page
can provide a redirection for HTTP-level authentication by the
"location-when-unauthenticated" setting.
</t>
<t>
Users are identified for authorization and content customization by the following logic:

<list style="symbols">
<t>
First, check the result of the HTTP-level authentication.
If there is a Cookie session tied to a specific user, both should match.
</t>
<t>
If the user is not authenticated on the HTTP-level, use the conventional
form-based method to determine the user.
</t>
<t>
If there is a Cookie tied to HTTP authentication
but there is no corresponding HTTP authentication result,
that session will be discarded (because 
it means that authentication is deactivated by the corresponding user).
</t>
</list>
</t>
</list>
</t>
</section>

</section>

<section title="Methods to Extend This Protocol">

<t>
If a private extension to this protocol is implemented,
it &MUST; use the extension-param to avoid conflicts with this protocol
and any other extensions.
(Standardized extensions or extensions that are being standardized &MAY; use either bare-tokens or extension-tokens.)
</t>

<t>When bare-tokens are used in this protocol, these
&MUST; be allocated by IANA.  Any tokens used for non-private,
non-experimental parameters are &RECOMMENDED; to be registered with
IANA, regardless of the kind of tokens used.
</t>

<t>
Extension-tokens &MAY; be freely used for any non-standard, private,
and/or experimental uses.  An extension-token &MUST; use the format
"&nbhy;&lt;bare-token&gt;.&lt;domain&nbhy;name&gt;", where
&lt;domain-name&gt; is a validly registered (sub-)domain name on the
Internet owned by the party that defines the extensions.
Any unknown parameter name is to be ignored regardless of whether it is 
an extension-token or a bare-token.
</t>

</section>

<section anchor="IANA" title="IANA Considerations">
<t>
This document defines two new entries for the "Permanent Message Header Field Names" registry.
</t>

<texttable>
<ttcol></ttcol><ttcol>Entry 1:</ttcol><ttcol>Entry 2:</ttcol>
<c>Header Field Name</c><c>Optional-WWW-Authenticate</c><c>Authentication-Control</c>
<c>Protocol</c>         <c>http</c>                     <c>http</c>
<c>Status</c>           <c>experimental</c>             <c>experimental</c>
<c>Change Control</c>   <c>IETF</c>                     <c>IETF</c>
<c>Spec. Document</c>   <c><xref target="optional-auth" /> of this document</c><c><xref target="auth-control-header" /> of this document</c>
</texttable>

<t>
This document also establishes the "HTTP Authentication Control Parameters" registry.
The registry manages case-insensitive ASCII strings.  The string &MUST; follow
the extensive-token syntax defined in <xref target="syntax-notation" />.
</t>

<t>
To acquire registered tokens, a specification for the use of such
tokens &MUST; be available as a publicly accessible document (see 
"Specification Required" in <xref target="RFC5226" />).
</t>

<t>
Registrations for authentication control parameters are required to include a
description of the control extension.
New registrations are advised to provide the following information:
<list style="symbols">
<t>Token: A token used in HTTP headers for identifying the algorithm.</t>
<t>Specification: A reference for the specification defining the algorithm.</t>
</list>
</t>

<t>
The initial content of this registry is as follows:
</t>
<texttable>
<ttcol>Token</ttcol><ttcol>Specification</ttcol>
<c>auth-style</c><c><xref target="auth-control-auth-style" /> of this document</c>
<c>location-when-unauthenticated</c><c><xref target="auth-control-loc-unauth" /> of this document</c>
<c>no-auth</c><c><xref target="auth-control-no-auth" /> of this document</c>
<c>location-when-logout</c><c><xref target="auth-control-loc-logout" /> of this document</c>
<c>logout-timeout</c><c><xref target="auth-control-logout-timeout" /> of this document</c>
<c>username</c><c><xref target="auth-control-user" /> of this document</c>
</texttable>
</section>

<section anchor="Security" title="Security Considerations">

<t>The purpose of the logout timeout feature in the Authentication-control
header is to protect users of clients from impersonation caused by an
attacker having access to the same console.  The server application implementers
&SHOULD; be aware that the directive may always be ignored by either
malicious clients or clients not supporting this extension.
If the purpose of introducing a timeout for an authentication period
is to protect server-side resources, this protection
&MUST; be implemented by other means such as <xref target="RFC6265">HTTP Cookies</xref>.
</t>

<t>
All parameters in the &_Authentication-Control; header &SHOULD_NOT; be used
for any security-enforcement purposes.  Server-side applications &MUST_NOT; assume
that the header will be honored by clients and users.
</t>

<section anchor="sec:username" title="Security Implication of the Username Parameter">
<t>
The "username" parameter sometimes reveals sensitive information about the
HTTP server and its configurations that are useful for security attacks.
In general, common security practice suggests that any kind of information
on the existence/non-existence of a specific username shall not be disclosed
before successful authentication.  Obviously, the "username" parameter
contradicts this practice.
</t>
<t>
Given this background, the use of the "username" parameter &SHOULD; be strictly limited
to cases where all of the following conditions are met:
<list style="format (%d)">
<t> the valid username is pre-configured and not modifiable (such as root, admin, or similar ones);</t>
<t> the valid username for such an appliance is publicly known (for example, written in a manual document); and</t>
<t> either the valid username for the server is easily guessable by
other means (for example, from the model number shown in an unauthenticated page),
or the server is accessible only from limited networks.</t>
</list>
Most importantly, the "username" parameter &SHOULD_NOT; be used in any case when the valid usernames can be
changed/configured by users or administrators.
</t>

</section>
</section>

</middle>

  <back>
    <references title="Normative References">
      &RFC2119;

      &RFC5226;

      &RFC5234;

      &RFC5987;

      &RFC7230;

      &RFC7235;

    </references>

    <references title="Informative References">

      &RFC6265;

      &RFC7564;

      &RFC7615;

      &W3C.REC-webstorage-20130730;

    </references>

    <section anchor="info" title="(Informative) Applicability of Features for Each Message">
    <t>
    This section provides a cross-reference table showing the applicability of 
    the features provided in this specification to each kind of response
    described in <xref target="state_term_definitions" />.
    The table provided in this section is for informative purposes only.
    </t>

    <texttable>
    <ttcol></ttcol>
    <ttcol>init.</ttcol>
    <ttcol>success.</ttcol>
    <ttcol>intermed.</ttcol>
    <ttcol>neg.</ttcol>

    <c>Optional auth.</c>
    <c>O</c>
    <c>n</c>
    <c>N</c>
    <c>N</c>

    <c>auth-style</c>
    <c>O</c>
    <c>-</c>
    <c>-</c>
    <c>O</c>

    <c>loc.-when-unauth.</c>
    <c>O</c>
    <c>I</c>
    <c>I</c>
    <c>i</c>
    
    <c>no-auth</c>
    <c>O</c>
    <c>I</c>
    <c>I</c>
    <c>i</c>
    
    <c>loc.-when-logout</c>
    <c>-</c>
    <c>O</c>
    <c>-</c>
    <c>-</c>

    <c>logout-timeout</c>
    <c>-</c>
    <c>O</c>
    <c>-</c>
    <c>-</c>

    <c>username</c>
    <c>O</c>
    <c>-</c>
    <c>-</c>
    <c>O</c>

    </texttable>

    <t>Legends:
    <vspace />O = &MAY; contain; n = &SHOULD_NOT; contain; N = &MUST_NOT; contain<vspace />
              i = &SHOULD; be ignored; I = &MUST; be ignored;<vspace />
              - = meaningless (to be ignored)<vspace />
</t>
    </section>

  </back>
</rfc>

