<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc number="8245"
     submissionType="IETF"
     consensus="yes"
     ipr="trust200902" 
     category="std" 
     updates="5444">

  <front>
    <title abbrev="Usage of RFC 5444">Rules for Designing Protocols Using
    the&nbsp;Generalized&nbsp;Packet/&wj;Message&nbsp;Format&nbsp;from&nbsp;RFC&nbsp;5444</title>

    <author fullname="Thomas Clausen" initials="T" surname="Clausen">
      <organization>Ecole Polytechnique</organization>
      <address>
        <postal>
          <street></street>
          <city>91128 Palaiseau Cedex</city>
          <region></region>
          <country>France</country>
        </postal>
        <phone>+33-6-6058-9349</phone>
        <email>T.Clausen@computer.org</email>
        <uri>http://www.thomasclausen.org</uri>
      </address>
    </author>

  <author initials="C.M." surname="Dearlove" fullname="Christopher Dearlove">
      <organization abbrev="BAE Systems">BAE Systems Applied Intelligence Laboratories</organization>
      <address>
        <postal>
          <street>
            West Hanningfield Road
          </street>
          <city>
            Great Baddow, Chelmsford
          </city>
          <country>
            United Kingdom
          </country>
        </postal>
        <email>chris.dearlove@baesystems.com</email>
        <uri>http://www.baesystems.com</uri>
      </address>
    </author>
    
    <author fullname="Ulrich Herberg" initials="U" surname="Herberg">
      <address>
        <email>ulrich@herberg.name</email>
          <uri>http://www.herberg.name</uri>
      </address>
    </author>

    <author fullname="Henning Rogge" initials="H" surname="Rogge">
      <organization>Fraunhofer FKIE</organization>
      <address>
        <postal>
          <street>
            Fraunhofer Strasse 20
          </street>
          <city>
            53343 Wachtberg
          </city>
          <country>
            Germany
          </country>
        </postal>
        <email>henning.rogge@fkie.fraunhofer.de</email>
      </address>
    </author>

    <date month="October" year="2017"/>

    <workgroup>Network Working Group</workgroup>
    <keyword>MANET</keyword>

    <abstract>
    	<t>
RFC 5444 specifies a generalized Mobile Ad Hoc Network (MANET) packet/message format and describes an
intended use for multiplexed MANET routing protocol messages; this use is
mandated by RFC 5498 when using the MANET port or protocol number that it specifies.
This document updates RFC 5444 by providing rules and recommendations for how
the multiplexer operates and how protocols can use the packet/message format.
In particular, the mandatory rules prohibit a number of uses that have been
suggested in various proposals and that would have led to interoperability
problems, to the impediment of protocol extension development, and/or to an
inability to use optional generic parsers.
	</t>
    </abstract>

  </front>

  <middle>

<section title="Introduction" anchor="introduction">

  <t>
   <xref target="RFC5444"/> specifies a generalized packet/message format that
   is designed for use by MANET routing protocols. 
  </t>

  <t>
    <xref target="RFC5444"/> was designed following experiences with <xref target="RFC3626"/>, which attempted to provide a packet/message format accommodating diverse protocol extensions but did not fully succeed. <xref target="RFC5444"/> was designed as a common building block for use by both proactive and reactive MANET routing protocols.
  </t>

  <t>
    <xref target="RFC5498"/> mandates the use of this packet/message format
    and of the  packet multiplexing process described in an appendix to
    <xref target="RFC5444"/> by protocols operating over the MANET IP protocol and UDP port
    numbers that were allocated by <xref target="RFC5498"/>.
  </t>

  <section title="History and Purpose">

    <t>
    	 Since the publication of <xref target="RFC5444"/> in 2009, several RFCs have been published, including <xref target="RFC5497"/>, <xref target="RFC6130"/>, <xref target="RFC6621"/>, <xref target="RFC7181"/>, <xref target="RFC7182"/>, <xref target="RFC7183"/>, <xref target="RFC7188"/>, <xref target="RFC7631"/>, and <xref target="RFC7722"/>, that use the format of <xref target="RFC5444"/>. The ITU-T recommendation <xref target="G9903"/> also uses the format of <xref target="RFC5444"/> for encoding some of its control signals.  In developing these specifications, experience with the use of <xref target="RFC5444"/> has been acquired, specifically with respect to how to write specifications using <xref target="RFC5444"/> so as to ensure forward compatibility of a protocol with future extensions, to enable the creation of efficient messages, and to enable the use of an efficient and generic parser for all protocols using <xref target="RFC5444"/>.
    </t>

    <t>
	 During the same time period, other suggestions have been made to use <xref target="RFC5444"/> in a manner that would inhibit the development of interoperable protocol extensions, that would potentially lead to inefficiencies, or that would lead to incompatibilities with generic parsers for <xref target="RFC5444"/>. While these uses were not all explicitly prohibited by <xref target="RFC5444"/>, they are strongly discouraged. This document is intended to prohibit such uses, to present experiences from designing protocols using <xref target="RFC5444"/>, and to provide these as guidelines (with their rationale) for future protocol designs using <xref target="RFC5444"/>.
    </t>
	      
  </section>

  <section title="Features of RFC 5444">

    <t>
      <xref target="RFC5444"/> performs two main functions:
      <list style="symbols">
        <t>
          It defines a packet/message format for use by MANET routing
          protocols. As far as <xref target="RFC5444"/> is concerned, it is up
          to each protocol that uses it to implement the required message
          parsing and formation. It is natural, especially when implementing
          more than one such protocol, to implement these processes using
          protocol-independent packet/message creation and parsing procedures,
          however, this is not required by <xref target="RFC5444"/>. Some
          comments in this document might be particularly applicable to such a
          case, but all that is required is that the messages passed to and
          from protocols are correctly formatted and that packets containing
          those messages are correctly formatted as described in the following
          point.
        </t>

        <t>
Appendix A of <xref target="RFC5444"/>, combined with the intended usage described in
Appendix B of <xref target="RFC5444"/>, specifies a multiplexing and demultiplexing
process whereby an entity that can be referred to as the "RFC 5444
multiplexer" manages packets that travel a single (logical) hop and contain
messages that are owned by individual protocols. Note that in this document,
the "RFC 5444 multiplexer" is referred to as the "multiplexer", or as the
"demultiplexer" when performing that function. A packet can contain messages
from more than one protocol.  This process is mandated for use on the
MANET UDP port and IP protocol (alternative means for the
transport of packets) by <xref target="RFC5498"/>.  The multiplexer is
responsible for creating packets and for parsing Packet Headers,
extracting messages, and passing them to the appropriate protocol
according to their type (the first octet in the message).
        </t>
      </list>
    </t>

    <section title="Packet/Message Format">

      <t>
        Among the characteristics and design objectives of the packet/message
	format of <xref target="RFC5444"/> are the following:

	   <list style="symbols">

    	     <t>
     		  It is designed for carrying MANET routing protocol control signals.
	     </t>

    	     <t>	
            It defines a packet as a Packet Header with a set of Packet TLVs
	    (Type-Length-Value structures), followed by a set of
	    messages. Each message has a well-defined structure consisting of
	    a Message Header (designed for making processing and forwarding
	    decisions) followed by a set of Message TLVs, and a set of
	    (address, type, value) associations using Address Blocks and their
	    Address Block TLVs. The packet/message
	    format from <xref target="RFC5444"/> then enables the use of simple and generic parsing logic for Packet Headers, Message Headers, and message content.

            <vspace blankLines="1"/>

	    A packet can include messages from different protocols, such as the
	    Neighborhood Discovery Protocol (NHDP)
	    <xref target="RFC6130"/> and the Optimized Link State Routing
	    Protocol version 2 (OLSRv2) <xref target="RFC7181"/>, in a
	    single transmission.  This was observed in <xref target="RFC3626"/> to be
	    beneficial, especially in wireless networks where media contention can be significant.
	     </t>

          <t>
            Its packets are designed to travel between two neighboring interfaces, which will result in a single decrement of the IPv4 TTL or IPv6 hop limit. The Packet Header and any Packet TLVs can thus convey information relevant to that link (for example, the Packet Sequence Number can be used to count transmission successes across that link). Packets are designed to be constructed for a single-hop transmission; a packet transmission following a successful packet reception is (by design) a new packet that can include all, some, or none of the received messages, plus possibly additional messages either received in separate packets or generated locally at that router. Messages can thus travel more than one hop and are designed to carry end-to-end protocol signals.
          </t>
		
          <t>
            It supports "internal extensibility" using TLVs; an extension can
	    add information to an existing message without that information
	    rendering the message unparseable or unusable by a router that
	    does not support the extension. An extension is typically of the
	    protocol that created the message to be extended, for example,
	    <xref target="RFC7181"/> adds information to the HELLO messages
	    created by <xref target="RFC6130"/>. 
However, an extension can
	    also be independent of the protocol; for example, <xref
	    target="RFC7182"/> can add Integrity Check Value (ICV) and timestamp information to any message (or to a packet, thus extending the multiplexer).

            <vspace blankLines="1"/>

            Information, in the form of TLVs, can be added to the message as a
	    whole (such as the integrity information specified in <xref target="RFC7182"/>)
	    or can be associated with specific addresses in the message (such
	    as the Multipoint Relay (MPR) selection and link metric information added to HELLO messages by <xref target="RFC7181"/>). An extension can also add addresses to a message.
	     </t>

          <t>
            It uses address aggregation into compact Address Blocks by exploiting commonalities between addresses. In many deployments, addresses (IPv4 and IPv6) used on interfaces share a common prefix that need not be repeated. Using IPv6, several addresses (of the same interface) might have common interface identifiers that need not be repeated.
          </t>

    	    <t>
     	      It sets up common namespaces, formats, and data structures for use by different protocols where common parsing logic can be used. For example, <xref target="RFC5497"/> defines a generic TLV format for representing time information (such as interval time or validity time).
	    </t>

    	    <t>
           It contains a minimal Message Header (a maximum of five elements:
	   type, originator, sequence number, hop count, and hop limit) that
	   permit decisions regarding whether to locally process a message or forward a message (thus enabling MANET-wide flooding of a message) without processing the body of the message.
	    </t>

        </list>

      </t>

      </section>

    <section title="Multiplexing and Demultiplexing">

      <t>
        The multiplexer (and demultiplexer) is defined in Appendix A of <xref
	target="RFC5444"/>. Its purpose is to allow multiple protocols to
	share the same IP protocol or UDP port. That sharing was made
	necessary by the separation of <xref target="RFC6130"/> from <xref
	target="RFC7181"/> as separate protocols and by the allocation of a
	single IP protocol and UDP port to all MANET protocols, including
	those protocols following <xref target="RFC5498"/>, which states: 
<list><t>All interoperable protocols running on these well-known IANA
allocations MUST conform to <xref target="RFC5444"/>. <xref target="RFC5444"/> provides a common format that
enables one or more protocols to share the IANA allocations defined in this
document unambiguously.</t></list>

 The multiplexer is the mechanism in <xref target="RFC5444"/> that enables that sharing.
      </t>

      <t>
        The primary purposes of the multiplexer are to:
        <list style="symbols">
          <t>
            Accept messages from MANET protocols, which also indicate over which interface(s) the messages are to be sent and to which destination address. The latter can be a unicast address or the "LL-MANET-Routers" link-local multicast address defined in <xref target="RFC5498"/>.
          </t>
          <t>
            Collect messages (possibly from multiple protocols) for the same
	    local interface and destination, into packets to be sent one logical hop, and to send packets using the MANET UDP port or IP protocol defined in <xref target="RFC5498"/>.
          </t>
          <t>
            Extract messages from received packets and pass them to their owning protocols.
          </t>
        </list>
      </t>

      <t>
The multiplexer's relationship is with the protocols that own the
corresponding Message Types.  Where those protocols have their own
relationships (for example, as extensions), this is the responsibility of the
protocols.  For example, OLSRv2 <xref target="RFC7181"/> extends the HELLO
messages created by NHDP <xref target="RFC6130"/>. However, the multiplexer
will deliver HELLO messages to NHDP and will expect to receive HELLO messages
from NHDP; the relationship between NHDP and OLSRv2 is between those two
protocols.
      </t>

      <t>
        The multiplexer is also responsible for the Packet Header, including
	any Packet Sequence Number and Packet TLVs. It can accept some
	additional instructions from protocols, can pass additional information to protocols, and will follow some additional rules; see <xref target="Packets_and_Messages"/>.
      </t>

    </section>

  </section>

  <section title="Status of This Document">

    <t>
    	This document updates <xref target="RFC5444"/> and is published on the
	Standards Track (rather than as Informational) because it specifies and mandates constraints on the use of <xref target="RFC5444"/> that, if not followed, make forms of extensions of those protocols impossible, impede the ability to generate efficient messages, or make desirable forms of generic parsers impossible.
    </t>

    <t>
      Each use of key words from <xref target="RFC2119"/> (see <xref
      target="terminology"/>) can be considered an update to <xref
      target="RFC5444"/>. In most cases, these codify obvious best practice or
      constrain the use of <xref target="RFC5444"/> in the circumstances where
      this specification is applicable (see <xref
      target="applicability_statement"/>). In a few circumstances, operation
      of <xref target="RFC5444"/> is modified. These are all circumstances
      that do not occur in its main and current uses, specifically by <xref target="RFC6130"/> and <xref target="RFC7181"/> (that might already include the requirement, particularly through <xref target="RFC7188"/>). That such modifying cases are an update to <xref target="RFC5444"/> is explicitly indicated in this specification.
    </t>

  </section>
  
</section>

<section title="Terminology" anchor="terminology">

  <t>
    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
    "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
    "OPTIONAL" in this document are to be interpreted as described in BCP&nbsp;14
    <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when,
    they appear in all capitals, as shown here.
  </t>

  <t>
Use of those key words applies directly to existing and future implementations
of <xref target="RFC5444"/>. It also applies to existing and future protocols
that use or update that RFC.
  </t>

  <t>
    This document uses the terminology and notation defined in <xref
    target="RFC5444"/>; the terms "packet", "Packet Header", "message",
    "Message Header", "address", "Address Block", "TLV", "TLV Block", and
    other related terms are to be interpreted as described therein.
  </t>

  <t>
    Additionally, this document uses the following terminology:
		
    <list style="hanging">

     <t hangText="Full Type (of TLV):">
       As per <xref target="RFC5444"/>, the 16-bit combination of the TLV
       Type and Type Extension is given the symbolic name
       &lt;tlv&nbhy;fulltype&gt;. This document uses the term "Full Type",
       which is not used in <xref target="RFC5444"/>, but is assigned (by this document) as
       standard terminology.

     </t>
      <t hangText="Owning Protocol:"> 
        As per <xref target="RFC5444"/>, for each Message Type, a protocol -- unless specified otherwise, the one making the IANA reservation for that Message Type -- is designated as the "owning protocol" of that Message Type. The demultiplexer inspects the Message Type of each received message and delivers each message to its corresponding "owning protocol".
	</t>
    </list>

  </t>

</section>

<section title="Applicability Statement" anchor="applicability_statement">

  <t>
This document does not specify a protocol but documents constraints
on how to design protocols that use the generic packet/message format 
defined in <xref target="RFC5444"/> that, if not followed, makes forms of extensions
of those protocols impossible, impedes the ability to generate
efficient (small) messages, or makes desirable forms of generic
parsers impossible.  The use of the <xref target="RFC5444"/> format is mandated by
<xref target="RFC5498"/> for all protocols running over the MANET protocol and port,
defined therein.  Thus, the constraints in this document apply to all
protocols running over the MANET IP protocol or UDP port.  The constraints
are strongly recommended for other uses of <xref target="RFC5444"/>.
  </t>
		
</section>

<section title="Information Transmission">

  <t>
    Protocols need to transmit information from one instance implementing the protocol to another.
  </t>

  <section title="Where to Record Information">

    <t>
      A protocol has the following choices as to where to put information for transmission:
      <list style="symbols">
        <t>
          in a TLV to be added to the Packet Header;
        </t>
        <t>
          in a message of a type owned by another protocol; or
        </t>
        <t>
          in a message of a type owned by the protocol.
        </t>
      </list>
    </t>

    <t>
      The first case (a Packet TLV) can only be used when the information is
      to be carried one hop. It SHOULD only be used either where the
      information relates to the packet as a whole (for example, packet
      integrity check values and timestamps, as specified in <xref
      target="RFC7182"/>) or if the information is expected to have a wider application than a single protocol. A protocol can also request that the Packet Header include Packet Sequence Numbers but does not control those numbers.
    </t>

    <t>
      The second case (in a message of a type owned by another protocol) is only possible if the adding protocol is an extension to the owning protocol; for example, OLSRv2 <xref target="RFC7181"/> is an extension of NHDP <xref target="RFC6130"/>.
    </t>

    <t>
      The third case is the normal case for a new protocol.
    </t>

    <t>
      A protocol extension can either be simply an update of the protocol (the
      third case) or be a new protocol that also updates another protocol (the
      second case). An example of the latter is that OLSRv2 <xref
      target="RFC7181"/> is a protocol that also extends the HELLO message
      owned by NHDP <xref target="RFC6130"/>; it is thus an example of both
      the second and third cases (the latter using the OLSRv2 owned Topology
      Control (TC) message). An extension to <xref target="RFC5444"/>, such as
      <xref target="RFC7182"/>, is considered to be an extension to all
      protocols. Protocols SHOULD be designed to enable extension by any of
      these means to be possible, and some of the rules in this document (in
      Sections <xref target="attributes2" format="counter"/> and <xref
      target="integrity" format="counter"/>, specifically) are to help facilitate that.
    </t> 

  </section>

  <section title="Message and TLV Type Allocation">
  
    <t>
      Protocols SHOULD be conservative in the number of new Message Types that they require, as the total available number of allocatable Message Types is only 224. Protocol design SHOULD consider whether different functions can be implemented by differences in TLVs carried in the same Message Type rather than using multiple Message Types.
    </t>

    <t>
      The TLV Type space, although greater than the Message Type space, SHOULD also be used efficiently. The Full Type of a TLV occupies two octets; thus, there are many more available TLV Full Types than there are Message Types. However, in some cases (currently LINK_METRIC from <xref target="RFC7181"/> and ICV and TIMESTAMP from <xref target="RFC7182"/>, all in the global TLV Type space), a TLV Type with a complete set of 256 TLV Full Types is defined (but not necessarily allocated).
    </t>

    <t>
      Each Message Type has an associated block of Message-Type-specific TLV
      Types (128 to 233, each with 256 type extensions) both for Address Block TLV Types and Message TLV Types. TLV Types from within these blocks SHOULD be used in preference to the Message-Type-independent Message TLV Types (0 to 127, each with 256 type extensions) when a TLV is specific to a message.
    </t>

    <t>
      The Expert Review guidelines in <xref target="RFC5444"/> are updated
      accordingly, as described in <xref target="IANA"/>.
    </t>

  </section>

  <section title="Message Recognition">
    <t>
      A message contains a Message Header and a Message Body; note that the Message TLV Block is considered part of the latter. The Message Header contains information whose primary purpose is to decide whether to process the message and whether to forward the message.  
    </t>

    <t>
      A protocol might need to recognize whether a message, especially a
      flooded message, is one that it has previously received (for example, to
      determine whether to process and/or forward it, or to discard it). A
      message can be recognized as one that has been previously seen if it
      contains sufficient information in its Message Header. A message MUST be
      so recognized by the combination of  its Message Type, Originator
      Address, and Message Sequence Number. The inclusion of Message Type
      allows each protocol to manage its own Message Sequence Numbers and also
      allows for the possibility that different Message Types can have greatly
      differing transmission rates. 

As an example of such use, <xref
      target="RFC7181"/> contains a general purpose process for managing
      processing and forwarding decisions, although specifically for use
      with MPR flooding. 

(Blind flooding can be handled similarly by assuming that all other routers are MPR selectors; it is not necessary in this case to differentiate between interfaces on which a message is received.)
    </t>

    <t>
      Most protocol information is thus contained in the Message Body. A model
      of how such information can be viewed is described in Sections <xref
      target="attributes1" format="counter"/> and <xref target="attributes2" format="counter"/>. To use that model, addresses (for example, of neighboring or otherwise known routers) SHOULD be recorded in Address Blocks, not as data in TLVs. Recording addresses in TLV Value fields both breaks the model of addresses as identities and associated information (attributes) and also inhibits address compression. However, in some cases, alternative addresses (e.g., hardware addresses when the Address Block is recording IP addresses) can be carried as TLV Values. Note that a message contains a Message Address Length field that can be used to allow carrying alternative message sizes, but only one length of addresses can be used in a single message, in all Address Blocks and the Originator Address, and is established by the router and protocol generating the message.
    </t>

  </section>

  <section title="Message Multiplexing and Packets" anchor="Packets_and_Messages">

    <t>
      The multiplexer has to handle message multiplexing into packets and
      the transmission of said packets, as well as packet reception and demultiplexing into messages. The multiplexer and the protocols that use it are subject to the following rules.
    </t>

    <section title="Packet Transmission" anchor="Packet_Transmission">

      <t>
        Packets are formed for transmission through the following steps:

        <list style="symbols">
 
          <t>
            Outgoing messages are created by their owning protocol and MAY be
	    modified by any extending protocols if the owning protocol permits
	    this. Messages MAY also be forwarded by their owning protocol. It
	    is strongly RECOMMENDED that messages are not modified in the
	    latter case, other than updates to their hop count and hop limit
	    fields, as described in Section 7.1.1 of <xref
	    target="RFC5444"/>. 

Note that this includes having an identical octet representation, including not allowing a different TLV representation of the same information. This is because it enables end-to-end authentication that ignores (zeros) those two fields (only), as is done in the Message TLV ICV (Integrity Check Value) calculations in <xref target="RFC7182"/>. Protocols MUST document their behavior with regard to modifiability of messages.
          </t>

          <t>
            Outgoing messages are then sent to the multiplexer. The owning protocol MUST indicate which interface(s) the messages are to be sent on and their destination address. Note that packets travel one hop; the destination is therefore either a link-local multicast address (if the packet is being multicast) or the address of the neighbor interface to which the packet is sent.
          </t>

          <t>
            The owning protocol MAY request that messages are kept together in
	    a packet; the multiplexer SHOULD respect this request if at all
	    possible. The multiplexer SHOULD combine messages that are sent on
	    the same interface in a packet, whether from the same or different
	    protocols, provided that in so doing the multiplexer does not
	    cause an IP packet to exceed the current Maximum Transmission Unit
	    (MTU). Note that the multiplexer cannot fragment messages; creating suitably sized messages that will not cause the MTU to be exceeded if sent in a single message packet is the responsibility of the protocol generating the message. If a larger message is created, then only IP fragmentation is available to allow the packet to be sent; this is generally considered undesirable, especially when transmission can be unreliable.
          </t>

          <t>
            The multiplexer MAY delay messages in order to assemble more efficient packets. It MUST respect any constraints on such delays requested by the protocol if it is practical to do so.
          </t>

          <t>
            If requested by a protocol, the multiplexer MUST (and otherwise
	    MAY) include a Packet Sequence Number in the packet. Such a
	    request MUST be respected as long as the protocol is active. Note
	    that the errata to <xref target="RFC5444"/> indicates that the
	    Packet Sequence Number SHOULD be specific to the interface on
	    which the packet is sent. This specification updates <xref
	    target="RFC5444"/> by requiring that this sequence number MUST be
	    specific to that interface and also that separate sequence numbers
	    MUST be maintained for each destination to which packets are sent
	    with included Packet Sequence Numbers. Addition of Packet Sequence
	    Numbers MUST be consistent (i.e., for each interface and destination, the Packet Sequence Number MUST be added to all packets or to none).
          </t>

          <t>
            An extension to the multiplexer MAY add TLVs to the packet. 
	    It MAY also add TLVs to the messages, in which case it is considered as also
	    extending the corresponding protocols. For example, <xref
	    target="RFC7182"/> can be used by the multiplexer to add Packet
	    TLVs or Message TLVs, or it can be used by the protocol to add Message TLVs.
          </t>

        </list>

      </t>

    </section>

    <section title="Packet Reception">

      <t>
        When a packet is received, the following steps are performed by the demultiplexer and by protocols:

        <list style="symbols">

          <t>
            The Packet Header and the organization into the messages that it contains MUST be verified by the demultiplexer.
          </t>

          <t>
            The packet and/or the messages it contains MAY also be verified by an extension to the demultiplexer, such as <xref target="RFC7182"/>.
          </t>

          <t>
            Each message MUST be sent to its owning protocol or discarded if
	    the Message Type is not recognized. 
The demultiplexer MUST also make available to the protocol the Packet Header
and the source and destination addresses in the IP datagram that included the packet.
	  </t>

          <t>
            The demultiplexer MUST remove any Message TLVs that were added by
	    an extension to the multiplexer. The message MUST be passed on to
	    the protocol exactly as received from (another instance of) the
	    protocol. This is, in part, an implementation detail. For example,
	    an implementation of the multiplexer and of <xref
	    target="RFC7182"/> could add a Message TLV either in the
	    multiplexer or in the protocol and remove it in the same place on reception. An implementation MUST ensure that the message passed to a protocol is as it would be passed from that protocol by the same implementation, i.e., that the combined implementation on a router is self-consistent, and that messages included in packets by the multiplexer are independent of this implementation detail.
          </t>

          <t>
            The owning protocol MUST verify each message for correctness; it MUST allow any extending protocol(s) to also contribute to this verification.
          </t>

          <t>
            The owning protocol MUST process each message. In some cases, which will be defined in the protocol specification, this processing will determine that the message will be ignored. Except in the latter case, the owning protocol MUST also allow any extending protocols to process the message.
          </t>

          <t>
            The owning protocol MUST manage the hop count and/or hop limit in the message. It is RECOMMENDED that these are handled as described in Appendix B of <xref target="RFC5444"/>; they MUST be so handled if using hop-count-dependent TLVs such as those defined in <xref target="RFC5497"/>.
          </t>

        </list>
      </t>

    <section title="Other Information">

      <t>
        In addition to the messages between the multiplexer and the protocols in each direction, the following additional information (summarized from other sections in this specification) can be exchanged.
        <list style="symbols">
          <t>
            The packet source and destination addresses MUST be sent from the
	    demultiplexer to the protocol.
          </t>
          <t>
            The Packet Header, including the Packet Sequence Number, MUST be
	    sent from the (de)multiplexer to the protocol if present. (An implementation MAY choose to only do so or only report the Packet Sequence Number, on request.)
          </t>
          <t>
            A protocol MAY require that all outgoing packets contain a Packet Sequence Number.
          </t>
          <t>
            The interface over which a message is to be sent and its
	    destination address MUST be sent from protocol to multiplexer. The
	    destination address MAY be a multicast address, in particular, the
	    LL-MANET-Routers link-local multicast address defined in <xref target="RFC5498"/>.
          </t>
          <t>
            A request to keep messages together in one packet MAY be sent from protocol to multiplexer.
          </t>
          <t>
            A requested maximum message delay MAY be sent from protocol to multiplexer.
          </t>
        </list>
      </t>

      <t>
        The protocol SHOULD also be aware of the MTU that will apply to its messages, if this is available.
      </t>

    </section>

    </section>
       
  </section>

  <section title="Messages, Addresses, and Attributes" anchor="attributes1">

    <t>
      The information in a Message Body, including Message TLVs and Address
      Block TLVs, consists of:
      <list style="symbols">
        <t>
          Attributes of the message, in which each attribute consists of a Full Type, a length, and a Value (of that length).
        </t>
        <t>
          A set of addresses, which are carried in one or more Address Blocks.
        </t>
        <t>
         Attributes of each address, in which each attribute consists of a Full Type, a length, and a Value (of that length).
        </t>
      </list>
    </t>

    <t>
      Attributes are carried in TLVs. For Message TLVs, the mapping from TLV to attribute is one to one. For Address Block TLVs, the mapping from TLV to attribute is one to many: one TLV can carry attributes for multiple addresses, but only one attribute per address. Attributes for different addresses can be the same or different.
    </t>

    <t>
      <xref target="RFC5444"/> requires that when a TLV Full Type is defined,
      then it MUST also define how to handle the cases of multiple TLVs of the
      same type applying to the same information element - i.e., when more
      than one Packet TLV of the same TLV Full Type is included in the same
      Packet Header, when more than one Message TLV of the same TLV Full Type
      is included in the same Message TLV Block, or when more than one Address
      Block TLV of the same TLV Full Type applies to the same value of any
      address. It is RECOMMENDED that when defining a new TLV Full Type, a rule of the following form is adopted.
      <list style="symbols">
        <t>
          If used, there MUST be only one TLV of that Full Type
	  associated with the packet (Packet TLV), message (Message TLV), or any value of any address (Address Block TLV).
        </t>
      </list>
      Note that this applies to address values; an address can appear more than once in a message, but the restriction on associating TLVs with addresses covers all copies of that address. It is RECOMMENDED that addresses are not repeated in a message.
    </t>

    <t>
      A conceptual way to view this information is described in <xref target="representation"/>.
    </t>

  </section>

  <section title="Addresses Require Attributes" anchor="attributes2">

    <t>
	 It is not mandatory in <xref target="RFC5444"/> to associate an address with attributes using Address Block TLVs. Information about an address could thus, in principle, be carried using:
      <list style="symbols">
        <t>
          The simple presence of an address.
        </t>
        <t>
          The ordering of addresses in an Address Block.
        </t>
        <t>
          The use of different meanings for different Address Blocks.
        </t>
      </list>
    </t>
	
    <t>
      This specification, however, requires that those methods of carrying information MUST NOT be used for any protocol using <xref target="RFC5444"/>. Information about the meaning of an address MUST only be carried using Address Block TLVs.
    </t>

    <t>
      In addition, rules for the extensibility of OLSRv2 and NHDP are described in <xref target="RFC7188"/>. This specification extends their applicability to other uses of <xref target="RFC5444"/>.
    </t>

    <t>
      These rules are:
      <list style="symbols">
        <t>
          A protocol MUST NOT assign any meaning to the presence or absence of an address (either in a Message or in a given Address Block in a Message), to the ordering of addresses in an Address Block, or to the division of addresses among Address Blocks.
        </t>
        <t>
          A protocol MUST NOT reject a message based on the inclusion of a TLV of an unrecognized type. The protocol MUST ignore any such TLVs when processing the message. The protocol MUST NOT remove or change any such TLVs if the message is to be forwarded unchanged.
        </t>
        <t>
          A protocol MUST NOT reject a message based on the inclusion of an unrecognized Value in a TLV of a recognized type. The protocol MUST ignore any such Values when processing the message but MUST NOT ignore recognized Values in such a TLV. The protocol MUST NOT remove or change any such TLVs if the message is to be forwarded unchanged.
        </t>
        <t>
          Similar restrictions to the two preceding points apply to the demultiplexer, which also MUST NOT reject a packet based on an unrecognized message; although it will reject any such messages, it MUST deliver any other messages in the packet to their owning protocols.
        </t>
      </list>
    </t>

    <t>
      The following points indicate the reasons for these rules based on considerations of extensibility and efficiency.
    </t>

    <t>
      Assigning a meaning to the presence, absence, or location of an address would reduce the extensibility of the protocol, prevent the approach to information representation described in <xref target="representation"/>, and reduce the options available for message optimization described in <xref target="efficiency"/>.
    </t>

    <t>
      To consider how the simple presence of an address conveying information
      would have restricted the development of an extension, two examples are considered: one actual (included in the base specification, but which could have been added later) and one hypothetical.
    </t>

    <t>
      The basic function of NHDP's HELLO messages <xref target="RFC6130"/> is to indicate that addresses are of neighbors, using the LINK_STATUS and OTHER_NEIGHB TLVs. (The message can also indicate the router's own addresses, which could also serve as a further example.)
    </t>

    <t>
      An extension to NHDP might decide to use the HELLO message to report that an address is one that could be used for a specialized purpose rather than for normal NHDP-based purposes. Such an example already exists in the use of LOST Values in the LINK_STATUS and OTHER_NEIGHB TLVs to report that an address is of a router known not to be a neighbor.
    </t>

    <t>
A future example could be to indicate that an address is to be added
to a "blacklist" of addresses not to be used.  This would use a new
TLV (or a new Value of an existing TLV, see below).  If no other TLVs
were attached to such a blacklisted address, then an unmodified
implementation of NHDP would ignore that address, as required; if any
other TLVs were attached to that address, then that implementation
would process that address for those TLVs.  Had NHDP been designed so
that just the presence of an address indicated a neighbor, this
blacklist extension would not be possible, as an unmodified
implementation of NHDP would treat all blacklisted addresses as
neighbors.
    </t>

    <t>
      Rejecting a message because it contains an unrecognized TLV Type or an unrecognized TLV Value reduces the extensibility of the protocol.
    </t>

    <t>
      For example, OLSRv2 <xref target="RFC7181"/> is, among other things, an extension to NHDP. It adds information to addresses in an NHDP HELLO message using a LINK_METRIC TLV. A non-OLSRv2 implementation of NHDP (for example, to support Simplified Multicast Flooding (SMF) <xref target="RFC6621"/>) will still process the HELLO message, ignoring the LINK_METRIC TLVs.
    </t>

    <t>
      Also, the blacklisting described in the example above could be signaled not with a new TLV but with a new Value of a LINK_STATUS or OTHER_NEIGHB TLV (requiring an IANA allocation as described in <xref target="RFC7188"/>), as is already done in the LOST case.
    </t>

    <t>
      The creation of Multi-Topology OLSRv2 (MT-OLSRv2) <xref target="RFC7722"/>, as an extension to OLSRv2 that can interoperate with unextended instances of OLSRv2, would not have been possible without these restrictions (which were applied to NHDP and OLSRv2 by <xref target="RFC7188"/>).
    </t>

    <t>
      These restrictions do not, however, mean that added information is completely ignored for purposes of the base protocol. Suppose that a faulty implementation of OLSRv2 (including NHDP) creates a HELLO message that assigns two different values of the same link metric to an address, something that is not permitted by <xref target="RFC7181"/>. A receiving OLSRv2-aware implementation of NHDP will reject such a message, even though a receiving OLSRv2-unaware implementation of NHDP will process it. This is because the OLSRv2-aware implementation has access to additional information (that the HELLO message is definitely invalid and the message is best ignored) as it is unknown what other errors it might contain.
    </t>

  </section>

  <section title="TLVs">

    <t>
      Within a message, the attributes are represented by TLVs. Particularly for Address Block TLVs, different TLVs can represent the same information. For example, using the LINK_STATUS TLV defined in <xref target="RFC6130"/>, if some addresses have Value SYMMETRIC and some have Value HEARD, arranged in that order, then this information can be represented using two single-value TLVs or one multivalue TLV. The latter can be used even if the addresses are not so ordered.
    </t>

    <t>
      A protocol MAY use any representation of information using TLVs that
      convey the required information. A protocol SHOULD use an efficient
      representation, but this is a quality of implementation issue. A
      protocol MUST recognize any permitted representation of the information;
      even if it chooses to, for example, only use multivalue TLVs, it MUST recognize single-value TLVs (and vice versa).
    </t>

    <t>
      A protocol defining new TLVs MUST respect the naming and organizational rules in <xref target="RFC7631"/>. It SHOULD follow the guidance in <xref target="RFC7188"/>, see <xref target="tlvvalues"/>. (This specification does not, however, relax the application of <xref target="RFC7188"/> where it is mandated.)
    </t>

  </section>

  <section title="Message Integrity" anchor="integrity">

    <t>
      In addition to not rejecting a message due to unknown TLVs or TLV Values, a protocol MUST NOT reject a message based on the inclusion of a TLV of an unrecognized type. The protocol MUST ignore any such TLVs when processing the message. The protocol MUST NOT
remove or change any such TLVs if the message is to be forwarded
unchanged. Such behavior may have the following consequences:

      <list style="symbols">

        <t>
          It might disrupt the operation of an extension of which it is unaware. Note that it is the responsibility of a protocol extension to handle interoperation with unextended instances of the protocol. For example, OLSRv2 <xref target="RFC7181"/> adds an MPR_WILLING TLV to HELLO messages (created by NHDP <xref target="RFC6130"/>, of which it is an extension) to recognize this case (and for other reasons).
        </t>

        <t>
          It would prevent the operation of end-to-end message authentication using <xref target="RFC7182"/> or any similar mechanism. The use of immutable (apart from hop count and/or hop limit) messages by a protocol is strongly RECOMMENDED for that reason.
        </t>

      </list>

    </t>

  </section>

</section>

<section title="Structure">

  <t>
    This section concerns the properties of the format defined in <xref target="RFC5444"/> itself, rather than the properties of protocols using it.
  </t>

  <t>
    The elements defined in <xref target="RFC5444"/> have structures that are managed by a number of flags fields:
    <list style="symbols">
      <t>
        Packet flags field (4 bits, 2 used) that manages the contents of the Packet Header.
      </t>
      <t>
        Message flags field (4 bits, 4 used) that manages the contents of the Message Header.
      </t>
      <t>
        Address Block flags field (8 bits, 4 used) that manages the contents of an Address Block.
      </t>
      <t>
        TLV flags field (8 bits, 5 used) that manages the contents of a TLV.
      </t>
    </list>
  </t>

  <t>
    Note that all of these flags are structural; they specify which elements are present or absent, field lengths, or whether a field has one or multiple values in it.
  </t>
    
    <t>	
    	In the current version of <xref target="RFC5444"/>, indicated by
	version number 0 in the &lt;version&gt; field of the Packet Header,
	unused bits in these flags fields are stated as "are RESERVED and SHOULD each be cleared ('0') on transmission and SHOULD be
ignored on reception". For the avoidance of any compatibility issues, with
regard to version number 0, this is updated to "MUST each be cleared ('0') on transmission and MUST be ignored on reception".
</t>
    	
    <t>
    	If a specification updating <xref target="RFC5444"/> introduces new flags in one of the flags fields of a packet, Address Block, or TLV (there being no unused flags in the message flags field), the following rules MUST be followed:
    	
    <list style="symbols">
      <t>
        The version number contained in the &lt;version&gt; field of the Packet Header MUST NOT be 0.
      </t>
    		
    	 <t>
        The new flag(s) MUST indicate the structure of the corresponding packet, Address Block, or TLV. They MUST NOT be used to indicate any other semantics, such as message forwarding behavior.
      </t>
    </list>
  </t>

  <t>
    An update that would be incompatible with the current specification of <xref target="RFC5444"/> SHOULD NOT be created unless there is a pressing reason for it that cannot be satisfied using the current specification (e.g., by use of a suitable Message TLV or Address Block TLV).
  </t>

  <t>
    During the development of <xref target="RFC5444"/> (and since publication
    thereof), some proposals have been made to use these RESERVED flags to
    specify behavior rather than structure, message forwarding in
    particular. These proposals were, after due consideration, not accepted
    for a number of reasons. These reasons include that message forwarding, in
    particular, is protocol specific; for example, <xref target="RFC7181"/> forwards messages using its MPR mechanism rather than a "blind" flooding mechanism. (These proposals were made during the development of <xref target="RFC5444"/> when there were still unused message flags. Later addition of a 4-bit Message Address Length field later left no unused message flags, but other flags fields still have unused flags.)
  </t>

</section>

<section title="Message Efficiency" anchor="efficiency">

	<t>
	  The ability to organize addresses into the same or different Address
	  Blocks and to change the order of addresses within an Address Block (as
	  well as the flexibility of the TLV specification) enables avoiding
	  unnecessary repetition of information and can consequently generate
	  smaller messages. There are no algorithms for address organization, compression, or for TLV usage in <xref target="RFC5444"/>; any algorithms that leave the information content unchanged MAY be used when generating a message. See also <xref target="automation"/>.
	</t>

  <section title="Address Block Compression">

    <t>
      <xref target="RFC5444"/> allows the addresses in an Address Block to be compressed. A protocol generating a message SHOULD compress addresses as much as it can.
    </t>

    <t>
      Addresses in an Address Block consist of a Head, a Mid, and a Tail, where all addresses in an Address Block have the same Head and Tail but different Mids. Each has a length that is greater than or equal to zero, the sum of the lengths being the address length. (The Mid length is deduced from this relationship.) Compression is possible when the Head and/or the Tail have non-zero length. An additional compression is possible when the Tail consists of all zero-valued octets. Expected use cases include IPv4 and IPv6 addresses from within the same prefix and that therefore have a common Head, IPv4 subnets with a common zero-valued Tail, and IPv6 addresses with a common Tail representing an interface identifier as well as having a possible common Head. Note that when, for example, IPv4 addresses have a common Head, their Tail will usually have length zero.
    </t>

    <t>
      For example:
      <list style="symbols">
        <t>
          The IPv4 addresses 192.0.2.1 and 192.0.2.2 would, for greatest efficiency, have a 3-octet Head, a 1-octet Mid, and a 0-octet Tail.
        </t>
        <t>
          The IPv6 addresses 2001:DB8:prefix1:interface and 2001:DB8:prefix2:interface that use the same interface identifier but completely different prefixes (except as noted) would, for greatest efficiency, have a 4-octet head, a 4-octet Mid, and an 8-octet Tail. (They could have a larger Head and/or Tail and a smaller Mid if the prefixes have any octets in common.)
        </t>
      </list>
    </t>

    <t>
      Putting addresses into a message efficiently also requires consideration
      of the following:
      <list style="symbols">
        <t>
          The split of the addresses into Address Blocks.
        </t>
        <t>
          The order of the addresses within the Address Blocks.
        </t>
      </list>
    </t>

    <t> 
      This split and/or ordering is for efficiency only; it does not provide any information. The split of the addresses affects both the address compression and the TLV efficiency (see <xref target="tlvs"/>); the order of the addresses within an Address Block affects only the TLV efficiency. However, using more Address Blocks than needed can increase the message size due to the overhead of each Address Block and the following TLV Block, and/or if additional TLVs are now required.
    </t>

    <t>
      The order of addresses can be as simple as sorting the addresses, but if many addresses have the same TLV Types attached, it might be more useful to put these addresses together, either within the same Address Block as other addresses or in a separate Address Block. A separate Address Block might also improve address compression, for example, if more than one address form is used (such as from independent subnets). An example of the possible use of address ordering is a HELLO message from <xref target="RFC6130"/> that could be generated with local interface addresses first and neighbor addresses later. These could be in separate Address Blocks.
    </t>

  </section>

  <section title="TLVs" anchor="tlvs">

    <t>
      When considering TLVs, the main opportunities for creating more efficient messages are in Address Block TLVs rather than Message TLVs. The approaches described here apply to each Address Block.
    </t>

    <t>
An Address Block TLV provides attributes for one address or a contiguous (as
stored in the Address Block) set of addresses (with a special case for when
this set is of all of the addresses in the Address Block).

When associated with more than one address, a TLV can be single value (associating the same attribute with each address) or multivalue (associating a separate attribute with each address).
    </t>

    <t>
      The approach that is simplest to implement is to use multivalue TLVs
      that cover all affected addresses. However, unless care is taken to
      order addresses appropriately, these affected addresses might not all be
      contiguous. Some approaches to this are the following:
      <list style="symbols">
        <t>
          Reorder the addresses. It is, for example, possible (though not straightforward, and beyond the scope of this document to describe exactly how) to order all addresses in HELLO message as specified in <xref target="RFC6130"/> so that all TLVs used only cover contiguous addresses. This is even possible if the MPR TLV specified in OLSRv2 <xref target="RFC7181"/> is added; but it is not possible, in general, if the LINK_METRIC TLV specified in OLSRv2 <xref target="RFC7181"/> is also added.
        </t>
        <t>
          Allow the TLV to span over addresses that do not need the
	  corresponding attribute and use a Value that indicates no information; see <xref target="tlvvalues"/>.
        </t>
        <t>
Use more than one TLV.  Note that this can be efficient when the TLVs become
single-value TLVs.  In a typical case where a LINK_STATUS TLV uses only the
Values HEARD and SYMMETRIC, with enough addresses sorted appropriately, two
single-value TLVs can be more efficient than one multivalue TLV.  If only one
Value is involved (such as NHDP in a steady state with LINK_STATUS equal to
SYMMETRIC in all cases) then one single-value TLV SHOULD always be used.
	</t>
      </list>
    </t>

  </section>

  <section title="TLV Values" anchor="tlvvalues">

    <t>
If, for example, an Address Block contains five addresses, the first
two and the last two requiring Values assigned using a LINK_STATUS
TLV but the third does not, then this can be indicated using two
TLVs.  It is, however, more efficient to do this with one multivalue
LINK_STATUS TLV, assigning the third address the Value UNSPECIFIED (as defined
in <xref target="RFC7188"/>). In general, use of UNSPECIFIED Values allows use
of fewer TLVs and is thus often an efficiency gain; however, a long run of
consecutive UNSPECIFIED Values (more than the overhead of a TLV) can make use
of more TLVs more efficient.
    </t>

    <t>
      Some other TLVs might need a different approach. As noted in <xref target="RFC7188"/>, but implicitly permissible before then, the LINK_METRIC TLV (defined in <xref target="RFC7181"/>) has two octet Values whose first four bits are flags indicating whether the metric applies in four cases; if these are all zero, then the metric does not apply in this case, which is thus the equivalent of an UNSPECIFIED Value.
    </t>

    <t>
      <xref target="RFC7188"/> requires that protocols that extend <xref
      target="RFC6130"/> and <xref target="RFC7181"/> allow unspecified values
      in TLVs where applicable; it is here RECOMMENDED that all protocols
      follow that advice. In particular, it is RECOMMENDED that when defining
      an Address Block TLV with discrete Values, an UNSPECIFIED Value is
      defined with the same value (255), and a modified approach should be
      used where possible for other Address Block TLVs (for example, as is
      done for a LINK_METRIC TLV, though not necessarily using that exact approach).
    </t>

    <t>
      It might be argued that provision of an unspecified value (of any form) to allow an Address Block TLV to cover unaffected addresses is not always necessary because addresses can be reordered to avoid this. However, ordering addresses to avoid this for all TLVs that might be used is not, in general, possible.
    </t>

    <t>
      In addition, <xref target="RFC7188"/> recommends that if a TLV Value
      (per address for an Address Block TLV) has a single-length that does not match the defined length for that TLV Type, then the following rules are adopted:
      <list style="symbols">
        <t>
          If the received single-length is greater than the expected single length, then the excess octets MUST be ignored.
        </t>
        <t>
          If the received single-length is less than the expected single length, then the absent octets MUST be considered to have all bits cleared (0).
        </t>
      </list>
      This specification RECOMMENDS a similar rule for all protocols defining new TLVs.
    </t>

  </section>

</section>

<section anchor="Security" title="Security Considerations">

  <t>
    This document does not specify a protocol but provides rules and recommendations for how to design protocols using <xref target="RFC5444"/>, whose security considerations apply.
  </t>

  <t>
    If the recommendation from <xref target="Packet_Transmission"/> is
    followed, which specifies that messages are not modified (except for hop count and hop limit) when forwarded, then the security framework for <xref target="RFC5444"/> (specified in <xref target="RFC7182"/>) can be used in full. If that recommendation is not followed, then the Packet TLVs from <xref target="RFC7182"/> can be used, but the Message TLVs from <xref target="RFC7182"/> cannot be used as intended.
  </t>

  <t>
    In either case, a protocol using <xref target="RFC5444"/> MUST document whether it is using <xref target="RFC7182"/> and if so, how.
  </t>

</section>

<section anchor="IANA" title="IANA Considerations">

<t>
    The Expert Review guidelines in <xref target="RFC5444"/> are updated to include the general requirement that:
    <list style="symbols">
      <t>
        The Designated Expert will consider the limited TLV and (especially)
	Message Type space when considering whether a requested allocation is
	allowed and whether a more efficient allocation than that requested is possible.
      </t>
    </list>
  </t>

  <t>IANA has added this document as a reference for the following Mobile Ad
  hoc NETwork (MANET) Parameters registries:
<?rfc subcompact="yes"?>
<list style="symbols">
<t>Message Types</t>
<t>Packet TLV Types</t>
<t>Message TLV Types</t>
<t>Address Block TLV Types</t>
</list>
  </t>
<?rfc subcompact="no"?>

</section>

  </middle>

  <back>

 <references title="Normative References">

<?rfc include="reference.RFC.2119"?>    
<?rfc include="reference.RFC.5444"?>
<?rfc include="reference.RFC.5498"?>
<?rfc include="reference.RFC.7182"?>
<?rfc include="reference.RFC.7631"?>
<?rfc include="reference.RFC.8174"?>
    </references>

    <references title="Informative References">
<?rfc include="reference.RFC.3626"?>
<?rfc include="reference.RFC.5497"?>
<?rfc include="reference.RFC.6130"?>
<?rfc include="reference.RFC.6621"?>
<?rfc include="reference.RFC.7181"?>
<?rfc include="reference.RFC.7183"?>
<?rfc include="reference.RFC.7188"?>
<?rfc include="reference.RFC.7722"?>
  
	<reference anchor="G9903">
  		<front>
  			<title>
G.9903 : Narrowband orthogonal frequency division multiplexing power line
communication transceivers for G3-PLC networks
			</title>
                <author><organization>ITU-T</organization></author>
			<date month="August" year="2017" />
		</front>
<seriesInfo name="ITU-T Recommendation" value="G.9903"/>
  </reference>
    
</references>

  <section title="Information Representation" anchor="representation">

    <t>
      This section describes a conceptual way to consider the information in a message. It can be used as the basis of an approach to parsing a message from the information that it contains and to creating a message from the information that it is to contain. However, there is no requirement that a protocol does so. This approach can be used either to inform a protocol design or by a protocol (or generic parser) implementer.
    </t>

    <t>
      A message (excluding the Message Header) can be represented by two, possibly multivalued, maps:
      <list style="symbols">
        <t>
          Message: (Full Type) -> (length, Value)
        </t>
        <t>
          Address: (address, Full Type) -> (length, Value)
        </t>
      </list>
    </t>

    <t>
      These maps (plus a representation of the Message Header) can be the basis for a generic representation of information in a message. Such maps can be created by parsing the message or can be constructed using the protocol rules for creating a message and later converted into the octet form of the message specified in <xref target="RFC5444"/>.
    </t>

    <t>
      While of course any implementation of software that represents software
      in the above form can specify an Application Programming Interface (API)
      for that software, such an interface is not proposed here. First, a full
      API would be specific to a programming language. Second, even within the
      above framework, there are alternative approaches to such an
      interface. For example, and for illustrative purposes only, consider the
      alternative address mappings:
      <list style="symbols">
       <t>
         Input: address and Full Type. Output: list of (length, Value)
	 pairs. Note that for most Full Types, it will be known in advance that
	 this list will have a length of zero or one. The list of addresses that can be used as inputs with non-empty output would need to be provided as a separate output.
       </t>
       <t>
         Input: Full Type. Output: list of (address, length, Value)
	 triples. As this list length can be significant, a possible output
	 will be of one or two iterators that will allow iterating through
	 that list. (One iterator that can detect the end of the list or a pair of iterators specifying a range.)
       </t>
      </list>
    </t>

    <t>
      Additional differences in the interface might relate to, for example, the ordering of output lists.
    </t>

  </section>

  <section title="Automation" anchor="automation">

    <t>
      There is scope for creating a protocol-independent optimizer for <xref
      target="RFC5444"/> messages that performs appropriate address
      re-organization (ordering and Address Block separation) and TLV changes
      (of number, of being single value or multivalue, and use of unspecified values) to create more compact messages. The possible gain depends on the efficiency of the original message creation and the specific details of the message. Note that this process cannot be TLV Type independent; for example, a LINK_METRIC TLV has a more complicated Value structure than a LINK_STATUS TLV does if using UNSPECIFIED Values.
   </t>

   <t>
     Such a protocol-independent optimizer MAY be used by the router generating a message but MUST NOT be used on a message that is forwarded unchanged by a router.
   </t>

  </section>

<section anchor="acknowledgments" title="Acknowledgments" numbered="no">
<t>The authors thank Cedric Adjih (INRIA) and Justin Dean (NRL) for their
contributions as authors of RFC 5444.</t>
</section>
  </back>

</rfc>
