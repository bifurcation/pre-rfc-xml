<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<?rfc toc="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no"?>
<?rfc strict="no"?>

<rfc number="6020" ipr="pre5378Trust200902" category="std" >
    <front>
    <title abbrev="YANG">YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)</title>

    <author initials="M" surname="Bjorklund" fullname='Martin Bjorklund' role="editor">
      <organization>Tail-f Systems</organization>
      <address>
        <email>mbj@tail-f.com</email>
      </address>
    </author>
	<date month="September" year="2010"/>

    <abstract>
	<t>
  YANG is a data modeling language used to model configuration and
  state data manipulated by the Network Configuration Protocol (NETCONF), NETCONF remote procedure calls, and NETCONF
  notifications.
	</t>
</abstract>
</front>
<middle>
<section title="Introduction">
    <t>
YANG is a data modeling language used to model configuration and state
data manipulated by the Network Configuration Protocol (NETCONF), NETCONF remote procedure calls, and NETCONF notifications.
YANG is used to model the operations and content layers of NETCONF
(see the NETCONF Configuration Protocol <xref target="RFC4741"/>, Section 1.1).
    </t>
    <t>
This document describes the syntax and semantics of the YANG language,
how the data model defined in a YANG module is represented in the
Extensible Markup Language (XML), and how NETCONF operations are used
to manipulate the data.
    </t>
</section>
<section title="Keywords">
    <t>
The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and
&quot;OPTIONAL&quot; in this document are to be interpreted as described in BCP
14, <xref target="RFC2119"/>.
    </t>
</section>
<section title="Terminology">
<t>
 <list style="symbols">
 <t>
anyxml: A data node that can contain an unknown chunk of XML data.
 </t>
 <t>
augment: Adds new schema nodes to a previously defined schema node.
 </t>
 <t>
base type: The type from which a derived type was derived,
which may be either a built-in type or another derived type.
 </t>
 <t>
built-in type: A YANG data type defined in the YANG language,
such as uint32 or string.
 </t>
 <t>
choice: A schema node where only one of a number of identified
alternatives is valid.
 </t>
 <t>
configuration data: The set of writable data that
is required to transform a system from its initial default state
into its current state <xref target="RFC4741"/>.
 </t>
 <t>
conformance: A measure of how accurately a device follows a data
model.
 </t>
 <t>
container: An interior data node that exists in at most one
instance in the data tree.  A container has no value, but rather a
set of child nodes.
 </t>
 <t>
data definition statement: A statement that defines new data
nodes.  One of container, leaf, leaf-list, list, choice, case,
augment, uses, and anyxml.
 </t>
 <t>
data model: A data model describes how data is represented and
accessed.
 </t>
 <t>
data node: A node in the schema tree that can be instantiated in a
data tree.  One of container, leaf, leaf-list, list, and anyxml.
 </t>
 <t>
data tree: The instantiated tree of configuration and state data on
a device.
 </t>
 <t>
derived type: A type that is derived from a built-in type (such as
uint32), or another derived type.
 </t>
 <t>
device deviation: A failure of the device to implement the module
faithfully.
 </t>
 <t>
extension: An extension attaches non-YANG semantics to statements.  The
extension statement defines new statements to express these
semantics.
 </t>
 <t>
feature: A mechanism for marking a portion of the model as optional.
Definitions can be tagged with a feature name and are only valid on
devices that support that feature.
 </t>
 <t>
grouping: A reusable set of schema nodes, which may be used locally
in the module, in modules that include it, and by other
modules that import from it.  The grouping statement is not a data
definition statement and, as such, does not define any nodes in the
schema tree.
 </t>
 <t>
identifier: Used to identify different kinds of YANG items by name.
 </t>
 <t>
instance identifier: A mechanism for identifying a particular
node in a data tree.
 </t>
 <t>
interior node: Nodes within a hierarchy that are not leaf nodes.
 </t>
 <t>
leaf: A data node that exists in at most one instance in the data
tree.  A leaf has a value but no child nodes.
 </t>
 <t>
leaf-list: Like the leaf node but defines a set of 
uniquely identifiable nodes rather than a single node.
Each node has a value but no child nodes.
 </t>
 <t>
list: An interior data node that may exist in multiple instances in
the data tree.  A list has no value, but rather a set of child
nodes.
 </t>
 <t>
module: A YANG module defines a hierarchy of nodes that can be
used for NETCONF-based operations.  With its definitions and
the definitions it imports or includes from elsewhere, a module
is self-contained and &quot;compilable&quot;.
 </t>
 <t>
RPC: A Remote Procedure Call, as used within the NETCONF
protocol.
 </t>
 <t>
RPC operation: A specific Remote Procedure Call, as used within
the NETCONF protocol. It is also called a protocol operation.
 </t>
 <t>
schema node: A node in the schema tree.  One of container, leaf,
leaf-list, list, choice, case, rpc, input, output,
notification, and anyxml.
 </t>
 <t>
schema node identifier: A mechanism for identifying a particular
node in the schema tree.
 </t>
 <t>
schema tree: The definition hierarchy specified within a module.
 </t>
 <t>
state data: The additional data on a system that is not
configuration data such as read-only status information and collected
statistics <xref target="RFC4741"/>.
 </t>
 <t>
submodule: A partial module definition that contributes derived
types, groupings, data nodes, RPCs, and notifications to a module.
A YANG module can be constructed from a number of submodules.
 </t>
 <t>
top-level data node: A data node where there is no other data node
between it and a module or submodule statement.
 </t>
 <t>
uses: The &quot;uses&quot; statement is used to instantiate the set of schema
nodes defined in a grouping statement.  The instantiated nodes may
be refined and augmented to tailor them to any specific needs.
 </t>
 </list>
</t>
<section title="Mandatory Nodes" anchor="mandatory-nodes">
    <t>
A mandatory node is one of:
    </t>
<t>
 <list style="symbols">
 <t>
A leaf, choice, or anyxml node with a &quot;mandatory&quot; statement with the
value &quot;true&quot;.
 </t>
 <t>
A list or leaf-list node with a &quot;min&#8209;elements&quot; statement with a
value greater than zero.
 </t>
 <t>
A container node without a &quot;presence&quot; statement, which has at
least one mandatory node as a child.
 </t>
 </list>
</t>
</section>
</section>
<section title="YANG Overview">
<section title="Functional Overview">
    <t>
YANG is a language used to model data for the NETCONF protocol.  A
YANG module defines a hierarchy of data that can be used for
NETCONF-based operations, including configuration, state data, Remote
Procedure Calls (RPCs), and notifications.  This allows a complete
description of all data sent between a NETCONF client and server.
    </t>
    <t>
YANG models the hierarchical organization of data as a tree in which
each node has a name, and either a value or a set of child nodes.
YANG provides clear and concise descriptions of the nodes, as well as
the interaction between those nodes.
    </t>
    <t>
YANG structures data models into modules and submodules.  A module can
import data from other external modules, and include data from
submodules.  The hierarchy can be augmented, allowing one module to
add data nodes to the hierarchy defined in another module.  This
augmentation can be conditional, with new nodes appearing only if
certain conditions are met.
    </t>
    <t>
YANG models can describe constraints to be enforced on the data,
restricting the appearance or value of nodes based on the presence or
value of other nodes in the hierarchy.  These constraints are
enforceable by either the client or the server, and valid content MUST
abide by them.
    </t>
    <t>
YANG defines a set of built-in types, and has a type mechanism through
which additional types may be defined.  Derived types can restrict
their base type&apos;s set of valid values using mechanisms like range or
pattern restrictions that can be enforced by clients or servers.  They
can also define usage conventions for use of the derived type, such as
a string-based type that contains a host name.
    </t>
    <t>
YANG permits the definition of reusable groupings of nodes.  The
instantiation of these groupings can refine or augment the nodes,
allowing it to tailor the nodes to its particular needs.  Derived
types and groupings can be defined in one module or submodule and used
in either that location or in another module or submodule that imports
or includes it.
    </t>
    <t>
YANG data hierarchy constructs include defining lists where list
entries are identified by keys that distinguish them from each other.
Such lists may be defined as either sorted by user or automatically
sorted by the system.  For user-sorted lists, operations are defined
for manipulating the order of the list entries.
    </t>
    <t>
YANG modules can be translated into an equivalent XML syntax called YANG
Independent Notation (YIN) (<xref target="YIN"/>), allowing applications using XML
parsers and Extensible Stylesheet Language Transformations (XSLT) scripts to operate on the models.  The conversion
from YANG to YIN is lossless, so content in YIN can be round-tripped
back into YANG.
    </t>
    <t>
YANG strikes a balance between high-level data modeling and low-level
bits-on-the-wire encoding.  The reader of a YANG module can see the
high-level view of the data model while understanding how the data
will be encoded in NETCONF operations.
    </t>
    <t>
YANG is an extensible language, allowing extension statements to be
defined by standards bodies, vendors, and individuals.  The statement
syntax allows these extensions to coexist with standard YANG
statements in a natural way, while extensions in a YANG module stand
out sufficiently for the reader to notice them.
    </t>
    <t>
YANG resists the tendency to solve all possible problems, limiting the
problem space to allow expression of NETCONF data models, not
arbitrary XML documents or arbitrary data models.  The data models
described by YANG are designed to be easily operated upon by NETCONF
operations.
    </t>
    <t>
To the extent possible, YANG maintains compatibility with Simple Network Management Protocol's (SNMP&apos;s) SMIv2
(Structure of Management Information version 2 <xref target="RFC2578"/>, <xref target="RFC2579"/>).
SMIv2-based MIB modules can be automatically translated into YANG
modules for read-only access.  However, YANG is not concerned with
reverse translation from YANG to SMIv2.
    </t>
    <t>
Like NETCONF, YANG targets smooth integration with the device&apos;s native
management infrastructure.  This allows implementations to leverage
their existing access control mechanisms to protect or expose elements
of the data model.
    </t>
</section>
<section title="Language Overview">
    <t>
This section introduces some important constructs used in YANG that
will aid in the understanding of the language specifics in later
sections.  This progressive approach handles the inter-related nature
of YANG concepts and statements.  A detailed description of YANG
statements and syntax begins in <xref target="yang-statements"/>. 
    </t>
<section title="Modules and Submodules">
    <t>
A module contains three types of statements: module-header statements,
revision statements, and definition statements.  The module header
statements describe the module and give information about the module
itself, the revision statements give information about the history of
the module, and the definition statements are the body of the module
where the data model is defined.
    </t>
    <t>
A NETCONF server may implement a number of modules, allowing multiple
views of the same data, or multiple views of disjoint subsections of
the device&apos;s data.  Alternatively, the server may implement only one
module that defines all available data.  
    </t>
    <t>
A module may be divided into submodules, based on the needs of the
module owner.  The external view remains that of a single module,
regardless of the presence or size of its submodules.
    </t>
    <t>
The &quot;include&quot; statement allows a module or submodule to reference
material in submodules, and the &quot;import&quot; statement allows references
to material defined in other modules.
    </t>
</section>
<section title="Data Modeling Basics">
    <t>
YANG defines four types of nodes for data modeling.  In each of
the following subsections, the example shows the YANG syntax as well
as a corresponding NETCONF XML representation.
    </t>
<section title="Leaf Nodes">
    <t>
A leaf node contains simple data like an integer or a string. It has
exactly one value of a particular type and no child nodes.
    </t>
    <t>
YANG Example:
    </t>
	<figure>
	    <artwork><![CDATA[
    leaf host-name {
        type string;
        description "Hostname for this system";
    }
	    ]]></artwork>
	</figure>
    <t>
NETCONF XML Example:
    </t>
	<figure>
	    <artwork><![CDATA[
    <host-name>my.example.com</host-name>
	    ]]></artwork>
	</figure>
    <t>
The &quot;leaf&quot; statement is covered in <xref target="leaf"/>.
    </t>
</section>
<section title="Leaf-List Nodes">
    <t>
A leaf-list is a sequence of leaf nodes with exactly one value of a
particular type per leaf.
    </t>
    <t>
YANG Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  leaf-list domain-search {
      type string;
      description "List of domain names to search";
  }
	    ]]></artwork>
	</figure>
    <t>
NETCONF XML Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  <domain-search>high.example.com</domain-search>
  <domain-search>low.example.com</domain-search>
  <domain-search>everywhere.example.com</domain-search>
	    ]]></artwork>
	</figure>
    <t>
The &quot;leaf&#8209;list&quot; statement is covered in <xref target="leaf-list"/>.
    </t>
</section>
<section title="Container Nodes">
    <t>
A container node is used to group related nodes in a subtree. A
container has only child nodes and no value. A container may contain
any number of child nodes of any type (including leafs, lists,
containers, and leaf-lists).
    </t>
    <t>
YANG Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  container system {
      container login {
          leaf message {
              type string;
              description 
                  "Message given at start of login session";
          }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
NETCONF XML Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  <system>
    <login>
      <message>Good morning</message>
    </login>
  </system>
	    ]]></artwork>
	</figure>
    <t>
The &quot;container&quot; statement is covered in <xref target="container"/>.
    </t>
</section>
<section title="List Nodes">
    <t>
A list defines a sequence of list entries. Each entry is like a
structure or a record instance, and is uniquely identified by the
values of its key leafs.  A list can define multiple key leafs and may
contain any number of child nodes of any type (including leafs, lists,
containers etc.).
    </t>
    <t>
YANG Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  list user {
      key "name";
      leaf name {
          type string;
      }
      leaf full-name {
          type string;
      }
      leaf class {
          type string;
      }
  }
	    ]]></artwork>
	</figure>
    <t>
NETCONF XML Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  <user>
    <name>glocks</name>
    <full-name>Goldie Locks</full-name>
    <class>intruder</class>
  </user>
  <user>
    <name>snowey</name>
    <full-name>Snow White</full-name>
    <class>free-loader</class>
  </user>
  <user>
    <name>rzell</name>
    <full-name>Rapun Zell</full-name>
    <class>tower</class>
  </user>
	    ]]></artwork>
	</figure>
    <t>
The &quot;list&quot; statement is covered in <xref target="list"/>.
    </t>
</section>
<section title="Example Module">
    <t>
These statements are combined to define the module:
    </t>
	<figure>
	    <artwork><![CDATA[
  // Contents of "acme-system.yang"
  module acme-system {
      namespace "http://acme.example.com/system";
      prefix "acme";

      organization "ACME Inc.";
      contact "joe@acme.example.com";
      description
          "The module for entities implementing the ACME system.";

      revision 2007-06-09 {
          description "Initial revision.";
      }

      container system {
          leaf host-name {
              type string;
              description "Hostname for this system";
          }

          leaf-list domain-search {
              type string;
              description "List of domain names to search";
          }

          container login {
              leaf message {
                  type string;
                  description
                      "Message given at start of login session";
              }

              list user {
                  key "name";
                  leaf name {
                      type string;
                  }
                  leaf full-name {
                      type string;
                  }
                  leaf class {
                      type string;
                  }
              }
          }
      }
  }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="State Data">
    <t>
YANG can model state data, as well as configuration data, based
on the &quot;config&quot; statement.  When a node is tagged with &quot;config false&quot;,
its subhierarchy is flagged as state data, to be reported using
NETCONF&apos;s &lt;get&gt; operation, not the &lt;get&#8209;config&gt; operation.  Parent
containers, lists, and key leafs are reported also, giving the context
for the state data.
    </t>
    <t>
In this example, two leafs are defined for each interface, a
configured speed and an observed speed.  The observed speed is not
configuration, so it can be returned with NETCONF &lt;get&gt; operations,
but not with &lt;get&#8209;config&gt; operations.  The observed speed is not
configuration data, and it cannot be manipulated using &lt;edit&#8209;config&gt;.
    </t>
	<figure>
	    <artwork><![CDATA[
  list interface {
      key "name";

      leaf name {
          type string;
      }
      leaf speed {
          type enumeration {
              enum 10m;
              enum 100m;
              enum auto;
          }
      }
      leaf observed-speed {
          type uint32;
          config false;
      }
  }
	    ]]></artwork>
	</figure>
</section>
<section title="Built-In Types">
    <t>
YANG has a set of built-in types, similar to those of many programming
languages, but with some differences due to special requirements from
the management domain.  The following table summarizes the built-in
types discussed in <xref target="built-in"/>:
    </t>
<?rfc compact="yes"?><texttable>
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Description</ttcol>
<c>binary</c>
<c>Any binary data</c>
<c>bits</c>
<c>A set of bits or flags</c>
<c>boolean</c>
<c>&quot;true&quot; or &quot;false&quot;</c>
<c>decimal64</c>
<c>64-bit signed decimal number</c>
<c>empty</c>
<c>A leaf that does not have any value</c>
<c>enumeration</c>
<c>Enumerated strings</c>
<c>identityref</c>
<c>A reference to an abstract identity</c>
<c>instance-identifier</c>
<c>References a data tree node</c>
<c>int8</c>
<c>8-bit signed integer</c>
<c>int16</c>
<c>16-bit signed integer</c>
<c>int32</c>
<c>32-bit signed integer</c>
<c>int64</c>
<c>64-bit signed integer</c>
<c>leafref</c>
<c>A reference to a leaf instance</c>
<c>string</c>
<c>Human-readable string</c>
<c>uint8</c>
<c>8-bit unsigned integer</c>
<c>uint16</c>
<c>16-bit unsigned integer</c>
<c>uint32</c>
<c>32-bit unsigned integer</c>
<c>uint64</c>
<c>64-bit unsigned integer</c>
<c>union</c>
<c>Choice of member types</c>
</texttable>
<?rfc compact="no"?>    <t>
The &quot;type&quot; statement is covered in <xref target="type"/>.
    </t>
</section>
<section title="Derived Types (typedef)">
    <t>
YANG can define derived types from base types using the &quot;typedef&quot;
statement.  A base type can be either a built-in type or a derived
type, allowing a hierarchy of derived types.
    </t>
    <t>
A derived type can be used as the argument for the &quot;type&quot; statement.
    </t>
    <t>
YANG Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  typedef percent {
      type uint8 {
          range "0 .. 100";
      }
      description "Percentage";
  }

  leaf completed {
      type percent;
  }
	    ]]></artwork>
	</figure>
    <t>
NETCONF XML Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  <completed>20</completed>
	    ]]></artwork>
	</figure>
    <t>
The &quot;typedef&quot; statement is covered in <xref target="typedef"/>.
    </t>
</section>
<section title="Reusable Node Groups (grouping)">
    <t>
Groups of nodes can be assembled into reusable collections using the
&quot;grouping&quot; statement.  A grouping defines a set of nodes that are
instantiated with the &quot;uses&quot; statement:
    </t>
	<figure>
	    <artwork><![CDATA[
  grouping target {
      leaf address {
          type inet:ip-address;
          description "Target IP address";
      }
      leaf port {
          type inet:port-number;
          description "Target port number";
      }
  }

  container peer {
      container destination {
          uses target;
      }
  }
	    ]]></artwork>
	</figure>
    <t>
NETCONF XML Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  <peer>
    <destination>
      <address>192.0.2.1</address>
      <port>830</port>
    </destination>
  </peer>
	    ]]></artwork>
	</figure>
    <t>
The grouping can be refined as it is used, allowing certain statements
to be overridden.  In this example, the description is refined:
    </t>
	<figure>
	    <artwork><![CDATA[
  container connection {
      container source {
          uses target {
              refine "address" {
                  description "Source IP address";
              }
              refine "port" {
                  description "Source port number";
              }
          }
      }
      container destination {
          uses target {
              refine "address" {
                  description "Destination IP address";
              }
              refine "port" {
                  description "Destination port number";
              }
          }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
The &quot;grouping&quot; statement is covered in <xref target="grouping"/>.
    </t>
</section>
<section title="Choices">
    <t>
YANG allows the data model to segregate incompatible nodes into
distinct choices using the &quot;choice&quot; and &quot;case&quot; statements.  The
&quot;choice&quot; statement contains a set of &quot;case&quot; statements that define
sets of schema nodes that cannot appear together.  Each &quot;case&quot; may
contain multiple nodes, but each node may appear in only one &quot;case&quot;
under a &quot;choice&quot;.
    </t>
    <t>
When an element from one case is created, all elements from all
other cases are implicitly deleted.  The device handles the
enforcement of the constraint, preventing incompatibilities from
existing in the configuration.
    </t>
    <t>
The choice and case nodes appear only in the schema tree, not in the
data tree or NETCONF messages.  The additional levels of hierarchy are not
needed beyond the conceptual schema.
    </t>
    <t>
YANG Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  container food {
    choice snack {
        case sports-arena {
            leaf pretzel {
                type empty;
            }
            leaf beer {
                type empty;
            }
        }
        case late-night {
            leaf chocolate {
                type enumeration {
                    enum dark;
                    enum milk;
                    enum first-available;
                }
            }
        }
    }
 }
	    ]]></artwork>
	</figure>
    <t>
NETCONF XML Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  <food>
    <pretzel/>
    <beer/>
  </food>
	    ]]></artwork>
	</figure>
    <t>
The &quot;choice&quot; statement is covered in <xref target="choice"/>.
    </t>
</section>
<section title="Extending Data Models (augment)">
    <t>
YANG allows a module to insert additional nodes into data models,
including both the current module (and its submodules) or an external
module.  This is useful for example for vendors to add vendor-specific
parameters to standard data models in an interoperable way.
    </t>
    <t>
The &quot;augment&quot; statement defines the location in the data
model hierarchy where new nodes are inserted, and the &quot;when&quot; statement
defines the conditions when the new nodes are valid.
    </t>
    <t>
YANG Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  augment /system/login/user {
      when "class != 'wheel'";
      leaf uid {
          type uint16 {
              range "1000 .. 30000";
          }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
This example defines a &quot;uid&quot; node that only is valid when the user&apos;s
&quot;class&quot; is not &quot;wheel&quot;.
    </t>
    <t>
If a module augments another module, the XML representation of the data
will reflect the prefix of the augmenting module.  For example, if the
above augmentation were in a module with prefix &quot;other&quot;, the XML would
look like:
    </t>
    <t>
NETCONF XML Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  <user>
    <name>alicew</name>
    <full-name>Alice N. Wonderland</full-name>
    <class>drop-out</class>
    <other:uid>1024</other:uid>
  </user>
	    ]]></artwork>
	</figure>
    <t>
The &quot;augment&quot; statement is covered in <xref target="augment"/>.
    </t>
</section>
<section title="RPC Definitions">
    <t>
YANG allows the definition of NETCONF RPCs.  The operations' names, input
parameters, and output parameters are modeled using YANG data
definition statements.
    </t>
    <t>
YANG Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  rpc activate-software-image {
      input {
          leaf image-name {
              type string;
          }
      }
      output {
          leaf status {
              type string;
          }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
NETCONF XML Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <activate-software-image xmlns="http://acme.example.com/system">
      <image-name>acmefw-2.3</image-name>
   </activate-software-image>
  </rpc>

  <rpc-reply message-id="101"
             xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <status xmlns="http://acme.example.com/system">
      The image acmefw-2.3 is being installed.
    </status>
  </rpc-reply>
	    ]]></artwork>
	</figure>
    <t>
The &quot;rpc&quot; statement is covered in <xref target="rpc"/>.
    </t>
</section>
<section title="Notification Definitions">
    <t>
YANG allows the definition of notifications suitable for NETCONF.
YANG data definition statements are used to model the content of the
notification.
    </t>
    <t>
YANG Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  notification link-failure {
      description "A link failure has been detected";
      leaf if-name {
          type leafref {
              path "/interface/name";
          }
      }
      leaf if-admin-status {
          type admin-status;
      }
      leaf if-oper-status {
          type oper-status;
      }
  }
	    ]]></artwork>
	</figure>
    <t>
NETCONF XML Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  <notification
      xmlns="urn:ietf:params:netconf:capability:notification:1.0">
    <eventTime>2007-09-01T10:00:00Z</eventTime>
    <link-failure xmlns="http://acme.example.com/system"> 
      <if-name>so-1/2/3.0</if-name>
      <if-admin-status>up</if-admin-status>
      <if-oper-status>down</if-oper-status>
    </link-failure>
  </notification>
	    ]]></artwork>
	</figure>
    <t>
The &quot;notification&quot; statement is covered in <xref target="notification"/>.
    </t>
</section>
</section>
</section>
<section title="Language Concepts">
<section title="Modules and Submodules">
    <t>
The module is the base unit of definition in YANG.  A module
defines a single data model.  A module can define a complete, cohesive
model, or augment an existing data model with additional nodes.
    </t>
    <t>
Submodules are partial modules that contribute definitions to a module.
A module may include any number of submodules, but each submodule may
belong to only one module.
    </t>
    <t>
The names of all standard modules and submodules MUST be unique.
Developers of enterprise modules are RECOMMENDED to choose names for
their modules that will have a low probability of colliding with
standard or other enterprise modules, e.g., by using the enterprise or
organization name as a prefix for the module name.
    </t>
    <t>
A module uses the &quot;include&quot; statement to include its submodules, and
the &quot;import&quot; statement to reference external modules.  Similarly, a
submodule uses the &quot;import&quot; statement to reference other modules,
and uses the &quot;include&quot; statement to reference other submodules
within its module.  A module or submodule MUST NOT include submodules
from other modules, and a submodule MUST NOT import its own module.
    </t>
    <t>
The import and include statements are used to make definitions
available to other modules and submodules:
    </t>
<t>
 <list style="symbols">
 <t>
For a module or submodule to reference definitions in an external
module, the external module MUST be imported.
 </t>
 <t>
For a module to reference definitions in one of its submodules, the
module MUST include the submodule.
 </t>
 <t>
For a submodule to reference definitions in a second submodule of
the same module, the first submodule MUST include the second
submodule. 
 </t>
 </list>
</t>
    <t>
There MUST NOT be any circular chains of imports or includes.  For
example, if submodule &quot;a&quot; includes submodule &quot;b&quot;, &quot;b&quot; cannot include
&quot;a&quot;.
    </t>
    <t>
When a definition in an external module is referenced, a locally
defined prefix MUST be used, followed by &quot;:&quot;, and then the external
identifier.  References to definitions in the local module MAY use the
prefix notation.  Since built-in data types do not belong to any
module and have no prefix, references to built-in data types (e.g.,
int32) cannot use the prefix notation.
    </t>
<section title="Import and Include by Revision">
    <t>
Published modules evolve independently over time.  In order to allow
for this evolution, modules need to be imported using specific
revisions.  When a module is written, it uses the current revisions of
other modules, based on what is available at the time.  As future
revisions of the imported modules are published, the importing module
is unaffected and its contents are unchanged.  When the author of the
module is prepared to move to the most recently published revision of
an imported module, the module is republished with an updated &quot;import&quot;
statement.  By republishing with the new revision, the authors
explicitly indicate their acceptance of any changes in the imported
module.
    </t>
    <t>
For submodules, the issue is related but simpler.  A module or
submodule that includes submodules needs to specify the revision of the
included submodules.  If a submodule changes, any module or submodule
that includes it needs to be updated.
    </t>
    <t>
For example, module &quot;b&quot; imports module &quot;a&quot;.
    </t>
	<figure>
	    <artwork><![CDATA[
  module a {
      revision 2008-01-01 { ... }
      grouping a {
          leaf eh { .... }
      }
  }

  module b {
      import a { 
          prefix p;
          revision-date 2008-01-01;
      }

      container bee {
          uses p:a;
      }
  }
	    ]]></artwork>
	</figure>
    <t>
When the author of &quot;a&quot; publishes a new revision, the changes may not be
acceptable to the author of &quot;b&quot;.  If the new revision is acceptable,
the author of &quot;b&quot; can republish with an updated revision in the &quot;import&quot;
statement.
    </t>
</section>
<section title="Module Hierarchies">
    <t>
YANG allows modeling of data in multiple hierarchies, where data may
have more than one top-level node.  Models that have multiple
top-level nodes are sometimes convenient, and are supported by YANG.
    </t>
    <t>
NETCONF is capable of carrying any XML content as the payload in the
&lt;config&gt; and &lt;data&gt; elements.  The top-level nodes of YANG modules are
encoded as child elements, in any order, within these elements.  This
encapsulation guarantees that the corresponding NETCONF messages are
always well-formed XML documents.
    </t>
    <t>
For example:
    </t>
	<figure>
	    <artwork><![CDATA[
  module my-config {
      namespace "http://example.com/schema/config";
      prefix "co";

      container system { ... }
      container routing { ... }
  }
	    ]]></artwork>
	</figure>
    <t>
could be encoded in NETCONF as:
    </t>
	<figure>
	    <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
      <target>
        <running/>
      </target>
      <config>
        <system xmlns="http://example.com/schema/config">
          <!-- system data here -->
        </system>
        <routing xmlns="http://example.com/schema/config">
          <!-- routing data here -->
        </routing>
      </config>
    </edit-config>
  </rpc>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="File Layout">
    <t>
YANG modules and submodules are typically stored in files, one module
or submodule per file.  The name of the file SHOULD be of the form:
    </t>
	<figure>
	    <artwork><![CDATA[
  module-or-submodule-name ['@' revision-date] ( '.yang' / '.yin' )
	    ]]></artwork>
	</figure>
    <t>
YANG compilers can find imported modules and included submodules via
this convention.  While the YANG language defines modules, tools may
compile submodules independently for performance and manageability
reasons.  Errors and warnings that cannot be detected during
submodule compilation may be delayed until the submodules are linked
into a cohesive module.
    </t>
</section>
<section title="XML Namespaces" anchor="intro-namespaces">
    <t>
All YANG definitions are specified within a module that is bound to a
particular XML namespace <xref target="XML-NAMES"/>, which is a globally unique URI
<xref target="RFC3986"/>.  A NETCONF client or server uses the namespace during XML
encoding of data.
    </t>
    <t>
Namespaces for modules published in RFC streams <xref target="RFC4844"/> MUST be assigned by
IANA, see <xref target="iana"/>.
    </t>
    <t>
Namespaces for private modules are assigned by the organization owning
the module without a central registry.  Namespace URIs MUST be chosen
so they cannot collide with standard or other enterprise namespaces,
for example by using the enterprise or organization name in the
namespace.
    </t>
    <t>
The &quot;namespace&quot; statement is covered in <xref target="namespace"/>.
    </t>
<section title="YANG XML Namespace" anchor="yang-namespace">
    <t>
YANG defines an XML namespace for NETCONF &lt;edit&#8209;config&gt; operations and
&lt;error&#8209;info&gt; content.  The name of this namespace is
&quot;urn:ietf:params:xml:ns:yang:1&quot;.
    </t>
</section>
</section>
<section title="Resolving Grouping, Type, and Identity Names">
    <t>
Grouping, type, and identity names are resolved in the context in
which they are defined, rather than the context in which they are
used.  Users of groupings, typedefs, and identities are not required
to import modules or include submodules to satisfy all references made
by the original definition.  This behaves like static scoping in a
conventional programming language.
    </t>
    <t>
For example, if a module defines a grouping in which a type is
referenced, when the grouping is used in a second module, the type is
resolved in the context of the original module, not the second module.
There is no worry over conflicts if both modules define the type,
since there is no ambiguity.
    </t>
</section>
<section title="Nested Typedefs and Groupings" anchor="nested-scoping">
    <t>
Typedefs and groupings may appear nested under many YANG statements,
allowing these to be lexically scoped by the hierarchy under which
they appear.  This allows types and groupings to be defined near where
they are used, rather than placing them at the top level of the
hierarchy.  The close proximity increases readability.
    </t>
    <t>
Scoping also allows types to be defined without concern for
naming conflicts between types in different submodules.  Type names
can be specified without adding leading strings designed to prevent name
collisions within large modules.
    </t>
    <t>
Finally, scoping allows the module author to keep types and groupings
private to their module or submodule, preventing their reuse.  Since
only top-level types and groupings (i.e., those appearing as
substatements to a module or submodule statement) can be used outside
the module or submodule, the developer has more control over what
pieces of their module are presented to the outside world, supporting
the need to hide internal information and maintaining a boundary
between what is shared with the outside world and what is kept
private.
    </t>
    <t>
Scoped definitions MUST NOT shadow definitions at a higher scope.  A
type or grouping cannot be defined if a higher level in the schema
hierarchy has a definition with a matching identifier.
    </t>
    <t>
A reference to an unprefixed type or grouping, or one which uses the
prefix of the current module, is resolved by locating the closest
matching &quot;typedef&quot; or &quot;grouping&quot; statement among the immediate
substatements of each ancestor statement.
    </t>
</section>
<section title="Conformance" anchor="conformance">
    <t>
Conformance is a measure of how accurately a device follows the
model.  Generally speaking, devices are responsible for implementing
the model faithfully, allowing applications to treat devices which
implement the model identically.  Deviations from the model can reduce
the utility of the model and increase fragility of applications
that use it.
    </t>
    <t>
YANG modelers have three mechanisms for conformance:
    </t>
<t>
 <list style="symbols">
 <t>
the basic behavior of the model
 </t>
 <t>
optional features that are part of the model
 </t>
 <t>
deviations from the model
 </t>
 </list>
</t>
    <t>
We will consider each of these in sequence.
    </t>
<section title="Basic Behavior">
    <t>
The model defines a contract between the NETCONF client and server,
which allows both parties to have faith the other knows the syntax and
semantics behind the modeled data.  The strength of YANG lies in the
strength of this contract.
    </t>
</section>
<section title="Optional Features">
    <t>
In many models, the modeler will allow sections of the model to be
conditional.  The device controls whether these conditional portions
of the model are supported or valid for that particular device.
    </t>
    <t>
For example, a syslog data model may choose to include the ability to
save logs locally, but the modeler will realize that this is only
possible if the device has local storage.  If there is no local
storage, an application should not tell the device to save logs.
    </t>
    <t>
YANG supports this conditional mechanism using a construct called
&quot;feature&quot;.  Features give the modeler a mechanism for making portions
of the module conditional in a manner that is controlled by the
device.  The model can express constructs that are not universally
present in all devices.  These features are included in the model
definition, allowing a consistent view and allowing applications to
learn which features are supported and tailor their behavior to the
device.
    </t>
    <t>
A module may declare any number of features, identified by simple
strings, and may make portions of the module optional based on those
features.  If the device supports a feature, then the corresponding
portions of the module are valid for that device.  If the device
doesn&apos;t support the feature, those parts of the module are not valid,
and applications should behave accordingly.
    </t>
    <t>
Features are defined using the &quot;feature&quot; statement.  Definitions in
the module that are conditional to the feature are noted by the
&quot;if&#8209;feature&quot; statement with the name of the feature as its argument.
    </t>
    <t>
Further details are available in <xref target="feature"/>.
    </t>
</section>
<section title="Deviations">
    <t>
In an ideal world, all devices would be required to implement the
model exactly as defined, and deviations from the model would not be
allowed.  But in the real world, devices are often not able or
designed to implement the model as written.  For YANG-based
automation to deal with these device deviations, a mechanism must
exist for devices to inform applications of the specifics of such
deviations.
    </t>
    <t>
For example, a BGP module may allow any number of BGP peers, but a
particular device may only support 16 BGP peers.  Any application
configuring the 17th peer will receive an error.  While an error may
suffice to let the application know it cannot add another peer, it
would be far better if the application had prior knowledge of this
limitation and could prevent the user from starting down the path that
could not succeed.
    </t>
    <t>
Device deviations are declared using the &quot;deviation&quot; statement, which
takes as its argument a string that identifies a node in the schema tree.
The contents of the statement details the manner in which the device
implementation deviates from the contract as defined in the module.
    </t>
    <t>
Further details are available in <xref target="deviation"/>.
    </t>
</section>
<section title="Announcing Conformance Information in the &lt;hello&gt; Message">
    <t>
The namespace URI MUST be advertised as a capability in the NETCONF
&lt;hello&gt; message to indicate support for the YANG module by a NETCONF
server.  The capability URI advertised MUST be of the form:
    </t>
	<figure>
	    <artwork><![CDATA[
  capability-string   = namespace-uri [ parameter-list ]
  parameter-list      = "?" parameter *( "&" parameter )
  parameter           = revision-parameter /
                        module-parameter /
                        feature-parameter /
                        deviation-parameter
  revision-parameter  = "revision=" revision-date
  module-parameter    = "module=" module-name
  feature-parameter   = "features=" feature *( "," feature )
  deviation-parameter = "deviations=" deviation *( "," deviation )
	    ]]></artwork>
	</figure>
    <t>
Where &quot;revision&#8209;date&quot; is the revision of the module (see <xref target="revision"/>)
that the NETCONF server implements, &quot;module&#8209;name&quot; is the name of
module as it appears in the &quot;module&quot; statement (see <xref target="module"/>),
&quot;namespace&#8209;uri&quot; is the namespace URI for the module as it appears in
the &quot;namespace&quot; statement (see <xref target="namespace"/>), &quot;feature&quot; is the name of
an optional feature implemented by the device (see <xref target="feature"/>), and
&quot;deviation&quot; is the name of a module defining device deviations (see
<xref target="deviation"/>).
    </t>
    <t>
In the parameter list, each named parameter MUST occur at most once.
    </t>
<section title="Modules">
    <t>
Servers indicate the names of supported modules via the &lt;hello&gt;
message.  Module namespaces are encoded as the base URI in the
capability string, and the module name is encoded as the &quot;module&quot;
parameter to the base URI.
    </t>
    <t>
A server MUST advertise all revisions of all modules it implements.
    </t>
    <t>
For example, this &lt;hello&gt; message advertises one module &quot;syslog&quot;.
    </t>
	<figure>
	    <artwork><![CDATA[
    <hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <capability>
        http://example.com/syslog?module=syslog&amp;revision=2008-04-01
      </capability>
    </hello>
	    ]]></artwork>
	</figure>
</section>
<section title="Features">
    <t>
Servers indicate the names of supported features via the &lt;hello&gt;
message.  In &lt;hello&gt; messages, the features are encoded in the
&quot;features&quot; parameter within the URI.  The value of this parameter is a
comma-separated list of feature names that the device supports for
the specific module.
    </t>
    <t>
For example, this &lt;hello&gt; message advertises one module, informing
the client that it supports the &quot;local&#8209;storage&quot; feature of module
&quot;syslog&quot;.
    </t>
	<figure>
	    <artwork><![CDATA[
    <hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <capability>
        http://example.com/syslog?module=syslog&amp;features=local-storage
      </capability>
    </hello>
	    ]]></artwork>
	</figure>
</section>
<section title="Deviations">
    <t>
Device deviations are announced via the &quot;deviations&quot; parameter.
The value of the &quot;deviations&quot; parameter is a comma-separated list of
modules containing deviations from the capability&apos;s module.
    </t>
    <t>
For example, this &lt;hello&gt; message advertises two modules, informing
the client that it deviates from module &quot;syslog&quot; according to the
deviations listed in the module &quot;my&#8209;devs&quot;.
    </t>
	<figure>
	    <artwork><![CDATA[
  <hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <capability>
        http://example.com/syslog?module=syslog&amp;deviations=my-devs
      </capability>
      <capability>
        http://example.com/my-deviations?module=my-devs
      </capability>
    </hello>
	    ]]></artwork>
	</figure>
</section>
</section>
</section>
<section title="Data Store Modification">
    <t>
Data models may allow the server to alter the configuration
data store in ways not explicitly directed via NETCONF protocol
messages.  For example, a data model may define leafs that are
assigned system-generated values when the client does not provide
one.  A formal mechanism for specifying the circumstances where
these changes are allowed is out of scope for this specification.
    </t>
</section>
</section>
<section title="YANG Syntax">
    <t>
The YANG syntax is similar to that of SMIng <xref target="RFC3780"/> and
programming languages like C and C++.  This C-like syntax was
chosen specifically for its readability, since YANG values the time
and effort of the readers of models above those of modules writers and
YANG tool-chain developers.  This section introduces the YANG
syntax.
    </t>
    <t>
YANG modules use the UTF-8 <xref target="RFC3629"/> character encoding.
    </t>
<section title="Lexical Tokenization">
    <t>
YANG modules are parsed as a series of tokens.  This section details
the rules for recognizing tokens from an input stream.  YANG
tokenization rules are both simple and powerful.  The simplicity is
driven by a need to keep the parsers easy to implement, while the
power is driven by the fact that modelers need to express their models
in readable formats.
    </t>
<section title="Comments">
    <t>
Comments are C++ style.  A single line comment starts with &quot;//&quot; and
ends at the end of the line.  A block comment is enclosed within
&quot;/*&quot; and &quot;*/&quot;.
    </t>
</section>
<section title="Tokens" anchor="tokens">
    <t>
A token in YANG is either a keyword, a string, a semicolon (&quot;;&quot;), or braces (&quot;{&quot; or &quot;}&quot;).  A
string can be quoted or unquoted.  A keyword is either one of the
YANG keywords defined in this document, or a prefix identifier,
followed by &quot;:&quot;, followed by a language extension keyword.  Keywords are case
sensitive.  See <xref target="identifiers"/> for a formal definition of identifiers.
    </t>
</section>
<section title="Quoting" anchor="quoting">
    <t>
If a string contains any space or tab characters, a semicolon (&quot;;&quot;),
braces (&quot;{&quot; or &quot;}&quot;), or comment sequences (&quot;//&quot;, &quot;/*&quot;, or &quot;*/&quot;), then
it MUST be enclosed within double or single quotes.
    </t>
    <t>
If the double-quoted string contains a line break followed by space or
tab characters that are used to indent the text according to the
layout in the YANG file, this leading whitespace is stripped from the
string, up to and including the column of the double quote character,
or to the first non-whitespace character, whichever occurs first.  In
this process, a tab character is treated as 8 space characters.
    </t>
    <t>
If the double-quoted string contains space or tab characters before a
line break, this trailing whitespace is stripped from the string.
    </t>
    <t>
A single-quoted string (enclosed within &apos; &apos;) preserves each character
within the quotes.  A single quote character cannot occur in a single-quoted string, even when preceded by a backslash.
    </t>
    <t>
Within a double-quoted string (enclosed within &quot; &quot;), a backslash
character introduces a special character, which depends on
the character that immediately follows the backslash:
    </t>
	<figure>
	    <artwork><![CDATA[
 \n      new line
 \t      a tab character
 \"      a double quote
 \\      a single backslash
	    ]]></artwork>
	</figure>
<!--"-->
    <t>
If a quoted string is followed by a plus character (&quot;+&quot;), followed by
another quoted string, the two strings are concatenated into one
string, allowing multiple concatenations to build one string.
Whitespace trimming and substitution of backslash-escaped characters in
double-quoted strings is done before concatenation.
    </t>
<section title="Quoting Examples">
    <t>
The following strings are equivalent:
    </t>
	<figure>
	    <artwork><![CDATA[
  hello
  "hello"
  'hello'
  "hel" + "lo"
  'hel' + "lo"
	    ]]></artwork>
	</figure>
    <t>
The following examples show some special strings:
    </t>
	<figure>
	    <artwork><![CDATA[
  "\""  - string containing a double quote
  '"'   - string containing a double quote
  "\n"  - string containing a new line character
  '\n'  - string containing a backslash followed 
          by the character n
	    ]]></artwork>
	</figure>
    <t>
The following examples show some illegal strings:
    </t>
	<figure>
	    <artwork><![CDATA[
  ''''  - a single-quoted string cannot contain single quotes
  """   - a double quote must be escaped in a double-quoted string
	    ]]></artwork>
	</figure>
<!--"-->    
<t>
The following strings are equivalent:
    </t>
	<figure>
	    <artwork><![CDATA[
      "first line
         second line"

  "first line\n" + "  second line"
	    ]]></artwork>
	</figure>
</section>
</section>
</section>
<section title="Identifiers" anchor="identifiers">
    <t>
Identifiers are used to identify different kinds of YANG items by
name.  Each identifier starts with an uppercase or lowercase ASCII
letter or an underscore character, followed by zero or more ASCII
letters, digits, underscore characters, hyphens, and dots.
Implementations MUST support identifiers up to 64 characters in
length.  Identifiers are case sensitive.  The identifier syntax is
formally defined by the rule &quot;identifier&quot; in <xref target="grammar"/>.  Identifiers
can be specified as quoted or unquoted strings.
    </t>
<section title="Identifiers and Their Namespaces">
    <t>
Each identifier is valid in a namespace that depends on the type of
the YANG item being defined.  All identifiers defined in a namespace
MUST be unique.
    </t>
<t>
 <list style="symbols">
 <t>
All module and submodule names share the same global module
identifier namespace.
 </t>
 <t>
All extension names defined in a module and its submodules share the
same extension identifier namespace.
 </t>
 <t>
All feature names defined in a module and its submodules share the
same feature identifier namespace.
 </t>
 <t>
All identity names defined in a module and its submodules share the
same identity identifier namespace.
 </t>
 <t>
All derived type names defined within a parent node or at the
top level of the module or its submodules share the same type
identifier namespace. This namespace is scoped to all descendant
nodes of the parent node or module.  This means that any descendent
node may use that typedef, and it MUST NOT define a typedef with the
same name.
 </t>
 <t>
All grouping names defined within a parent node or at the top level of
the module or its submodules share the same grouping identifier
namespace. This namespace is scoped to all descendant nodes of the
parent node or module.  This means that any descendent node may use
that grouping, and it MUST NOT define a grouping with the same name.
 </t>
 <t>
All leafs, leaf-lists, lists, containers, choices, rpcs,
notifications, and anyxmls defined (directly or through a uses
statement) within a parent node or at the top level of the module or
its submodules share the same identifier namespace.  This namespace
is scoped to the parent node or module, unless the parent node is a
case node.  In that case, the namespace is scoped to the closest
ancestor node that is not a case or choice node.
 </t>
 <t>
All cases within a choice share the same case identifier namespace.
This namespace is scoped to the parent choice node.
 </t>
 </list>
</t>
    <t>
Forward references are allowed in YANG.
    </t>
</section>
</section>
<section title="Statements">
    <t>
A YANG module contains a sequence of statements.  Each statement
starts with a keyword, followed by zero or one argument, followed
either by a semicolon (&quot;;&quot;) or a block of substatements enclosed
within braces (&quot;{ }&quot;):
    </t>
	<figure>
	    <artwork><![CDATA[
  statement = keyword [argument] (";" / "{" *statement "}")
	    ]]></artwork>
	</figure>
    <t>
The argument is a string, as defined in <xref target="tokens"/>.
    </t>
<section title="Language Extensions" anchor="extensions">
    <t>
A module can introduce YANG extensions by using the &quot;extension&quot;
keyword (see <xref target="extension"/>).  The extensions can be imported by other
modules with the &quot;import&quot; statement (see <xref target="import"/>).  When an imported
extension is used, the extension&apos;s keyword MUST be qualified using the
prefix with which the extension&apos;s module was imported.  If an
extension is used in the module where it is defined, the extension&apos;s
keyword MUST be qualified with the module&apos;s prefix.
    </t>
    <t>
Since submodules cannot include the parent module, any extensions in
the module that need to be exposed to submodules MUST be defined in a
submodule.  Submodules can then include this submodule to find the
definition of the extension.
    </t>
    <t>
If a YANG compiler does not support a particular extension, which
appears in a YANG module as an unknown-statement (see <xref target="grammar"/>), the
entire unknown-statement MAY be ignored by the compiler.
    </t>
</section>
</section>
<section title="XPath Evaluations" anchor="xpath">
    <t>
YANG relies on XML Path Language (XPath) 1.0 <xref target="XPATH"/> as a notation for specifying many
inter-node references and dependencies.  NETCONF clients and servers
are not required to implement an XPath interpreter, but MUST ensure
that the requirements encoded in the data model are enforced.  The
manner of enforcement is an implementation decision.  The XPath
expressions MUST be syntactically correct, and all prefixes used MUST
be present in the XPath context (see <xref target="xpath-context"/>).  An
implementation may choose to implement them by hand, rather than using
the XPath expression directly.
    </t>
    <t>
The data model used in the XPath expressions is the same as that used
in XPath 1.0 <xref target="XPATH"/>, with the same extension for root node children
as used by XSLT 1.0 <xref target="XSLT"/> (Section 3.1).  Specifically, it means that
the root node may have any number of element nodes as its children.
    </t>
<section title="XPath Context" anchor="xpath-context">
    <t>
All YANG XPath expressions share the following XPath context
definition:
    </t>
<t>
 <list style="symbols">
 <t>
The set of namespace declarations is the set of all &quot;import&quot;
statements&apos; prefix and namespace pairs in the module where the XPath
expression is specified, and the &quot;prefix&quot;
statement&apos;s prefix for the &quot;namespace&quot; statement&apos;s URI.
 </t>
 <t>
Names without a namespace prefix belong to the same namespace as the
identifier of the current node.  Inside a grouping, that namespace is
affected by where the grouping is used (see <xref target="uses"/>).
 </t>
 <t>
The function library is the core function library defined in
<xref target="XPATH"/>, and a function &quot;current()&quot; that returns a node set with
the initial context node.
 </t>
 <t>
The set of variable bindings is empty.
 </t>
 </list>
</t>
    <t>
The mechanism for handling unprefixed names is adopted from XPath 2.0
<xref target="XPATH2.0"/>, and helps simplify XPath expressions in YANG.  No
ambiguity may ever arise because YANG node identifiers are always
qualified names with a non-null namespace URI.
    </t>
    <t>
The context node varies with the YANG XPath
expression, and is specified where the YANG statement with the XPath
expression is defined.
    </t>
</section>
</section>
<section title="Schema Node Identifier" anchor="schema-node-id">
    <t>
A schema node identifier is a string that identifies a node in the
schema tree.  It has two forms, &quot;absolute&quot; and &quot;descendant&quot;, defined
by the rules &quot;absolute&#8209;schema&#8209;nodeid&quot; and &quot;descendant&#8209;schema&#8209;nodeid&quot;
in <xref target="grammar"/>, respectively.  A schema node identifier consists of a
path of identifiers, separated by slashes (&quot;/&quot;).  In an absolute
schema node identifier, the first identifier after the leading slash
is any top-level schema node in the local module or in all imported modules.
    </t>
    <t>
References to identifiers defined in external modules MUST be
qualified with appropriate prefixes, and references to identifiers
defined in the current module and its submodules MAY use a prefix.
    </t>
    <t>
For example, to identify the child node &quot;b&quot; of top-level node &quot;a&quot;, the
string &quot;/a/b&quot; can be used.
    </t>
</section>
</section>
<section title="YANG Statements" anchor="yang-statements">
    <t>
The following sections describe all of the YANG statements.
    </t>
    <t>
Note that even a statement that does not have any substatements
defined in YANG can have vendor-specific extensions as
substatements.  For example, the &quot;description&quot; statement does not
have any substatements defined in YANG, but the following is
legal:
    </t>
	<figure>
	    <artwork><![CDATA[
  description "some text" {
      acme:documentation-flag 5;
  }
	    ]]></artwork>
	</figure>
<section title="The module Statement" anchor="module">
    <t>
The &quot;module&quot; statement defines the module&apos;s name, and groups all
statements that belong to the module together.  The &quot;module&quot;
statement&apos;s argument is the name of the module, followed by a block of
substatements that hold detailed module information.  The module name
follows the rules for identifiers in <xref target="identifiers"/>.
    </t>
    <t>
Names of modules published in RFC streams <xref target="RFC4844"/> MUST be assigned by IANA,
see <xref target="iana"/>.
    </t>
    <t>
Private module names are assigned by the organization owning the
module without a central registry. It is RECOMMENDED to choose
module names that will have a low probability of colliding with
standard or other enterprise modules and submodules, e.g., by using the
enterprise or organization name as a prefix for the module name.
    </t>
    <t>
A module typically has the following layout:
    </t>
	<figure>
	    <artwork><![CDATA[
  module <module-name> {

      // header information
      <yang-version statement>
      <namespace statement>
      <prefix statement>

      // linkage statements
      <import statements>
      <include statements>

      // meta information
      <organization statement>
      <contact statement>
      <description statement>
      <reference statement>

      // revision history
      <revision statements>

      // module definitions
      <other statements>
  }
	    ]]></artwork>
	</figure>
<section title="The module&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>anyxml</c>
<c><xref format="counter" target="anyxml"/></c>
<c>0..n</c>
<c>augment</c>
<c><xref format="counter" target="augment"/></c>
<c>0..n</c>
<c>choice</c>
<c><xref format="counter" target="choice"/></c>
<c>0..n</c>
<c>contact</c>
<c><xref format="counter" target="contact"/></c>
<c>0..1</c>
<c>container</c>
<c><xref format="counter" target="container"/></c>
<c>0..n</c>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>deviation</c>
<c><xref format="counter" target="deviation"/></c>
<c>0..n</c>
<c>extension</c>
<c><xref format="counter" target="extension"/></c>
<c>0..n</c>
<c>feature</c>
<c><xref format="counter" target="feature"/></c>
<c>0..n</c>
<c>grouping</c>
<c><xref format="counter" target="grouping"/></c>
<c>0..n</c>
<c>identity</c>
<c><xref format="counter" target="identity"/></c>
<c>0..n</c>
<c>import</c>
<c><xref format="counter" target="import"/></c>
<c>0..n</c>
<c>include</c>
<c><xref format="counter" target="include"/></c>
<c>0..n</c>
<c>leaf</c>
<c><xref format="counter" target="leaf"/></c>
<c>0..n</c>
<c>leaf-list</c>
<c><xref format="counter" target="leaf-list"/></c>
<c>0..n</c>
<c>list</c>
<c><xref format="counter" target="list"/></c>
<c>0..n</c>
<c>namespace</c>
<c><xref format="counter" target="namespace"/></c>
<c>1</c>
<c>notification</c>
<c><xref format="counter" target="notification"/></c>
<c>0..n</c>
<c>organization</c>
<c><xref format="counter" target="organization"/></c>
<c>0..1</c>
<c>prefix</c>
<c><xref format="counter" target="prefix"/></c>
<c>1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>revision</c>
<c><xref format="counter" target="revision"/></c>
<c>0..n</c>
<c>rpc</c>
<c><xref format="counter" target="rpc"/></c>
<c>0..n</c>
<c>typedef</c>
<c><xref format="counter" target="typedef"/></c>
<c>0..n</c>
<c>uses</c>
<c><xref format="counter" target="uses"/></c>
<c>0..n</c>
<c>yang-version</c>
<c><xref format="counter" target="yang-version"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="The yang-version Statement" anchor="yang-version">
    <t>
The optional &quot;yang&#8209;version&quot; statement specifies which version of the
YANG language was used in developing the module.  The statement&apos;s
argument is a string.  If present, it MUST contain the value &quot;1&quot;,
which is the current YANG version and the default value.
    </t>
    <t>
Handling of the &quot;yang&#8209;version&quot; statement for versions other than &quot;1&quot;
(the version defined here) is out of scope for this specification.
Any document that defines a higher version will need to define the
backward compatibility of such a higher version.
    </t>
</section>
<section title="The namespace Statement" anchor="namespace">
    <t>
The &quot;namespace&quot; statement defines the XML namespace that all
identifiers defined by the module are qualified by, with the
exception of data node identifiers defined inside a grouping (see
<xref target="uses"/> for details).  The argument to the &quot;namespace&quot; statement is the
URI of the namespace.
    </t>
    <t>
See also <xref target="intro-namespaces"/>.
    </t>
</section>
<section title="The prefix Statement" anchor="prefix">
    <t>
The &quot;prefix&quot; statement is used to define the prefix associated with
the module and its namespace. The &quot;prefix&quot; statement&apos;s argument is the
prefix string that is used as a prefix to access a module.  The
prefix string MAY be used to refer to definitions contained in the
module, e.g., &quot;if:ifName&quot;.  A prefix follows the same rules as an
identifier (see <xref target="identifiers"/>).
    </t>
    <t>
When used inside the &quot;module&quot; statement, the &quot;prefix&quot; statement
defines the prefix to be used when this module is imported.  To
improve readability of the NETCONF XML, a NETCONF client or server
that generates XML or XPath that use prefixes SHOULD use the prefix
defined by the module, unless there is a conflict.
    </t>
    <t>
When used inside the &quot;import&quot; statement, the &quot;prefix&quot; statement
defines the prefix to be used when accessing definitions inside the
imported module.  When a reference to an identifier from the imported
module is used, the prefix string for the imported module is used in
combination with a colon (&quot;:&quot;) and the identifier, e.g., &quot;if:ifIndex&quot;.
To improve readability of YANG modules, the prefix defined by a module
SHOULD be used when the module is imported, unless there is a
conflict.  If there is a conflict, i.e., two different modules that
both have defined the same prefix are imported, at least one of them
MUST be imported with a different prefix.
    </t>
    <t>
All prefixes, including the prefix for the module itself MUST be
unique within the module or submodule.
    </t>
</section>
<section title="The import Statement" anchor="import">
    <t>
The &quot;import&quot; statement makes definitions from one module available
inside another module or submodule.  The argument is the name of the
module to import, and the statement is followed by a block of
substatements that holds detailed import information.  When a module
is imported, the importing module may:
    </t>
<t>
 <list style="symbols">
 <t>
use any grouping and typedef defined at the top level in the
imported module or its submodules.
 </t>
 <t>
use any extension, feature, and identity defined in the imported
module or its submodules.
 </t>
 <t>
use any node in the imported module&apos;s schema tree in
&quot;must&quot;, &quot;path&quot;, and &quot;when&quot; statements, or as the target node in 
&quot;augment&quot; and &quot;deviation&quot; statements.
 </t>
 </list>
</t>
    <t>
The mandatory &quot;prefix&quot; substatement assigns a prefix for the imported
module that is scoped to the importing module or submodule. Multiple
&quot;import&quot; statements may be specified to import from different modules.
    </t>
    <t>
When the optional &quot;revision&#8209;date&quot; substatement is present, any
typedef, grouping, extension, feature, and identity referenced by
definitions in the local module are taken from the specified revision
of the imported module.  It is an error if the specified revision of
the imported module does not exist.  If no &quot;revision&#8209;date&quot;
substatement is present, it is undefined from which revision of the
module they are taken.
    </t>
    <t>
Multiple revisions of the same module MUST NOT be imported.
    </t>
<?rfc compact="yes"?><texttable>
<preamble>The import&apos;s Substatements</preamble>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>prefix</c>
<c><xref format="counter" target="prefix"/></c>
<c>1</c>
<c>revision-date</c>
<c><xref format="counter" target="revision-date"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?><section title="The import&apos;s revision-date Statement" anchor="revision-date">
    <t>
The import&apos;s &quot;revision&#8209;date&quot; statement is used to specify the exact
version of the module to import.  The &quot;revision&#8209;date&quot; statement MUST
match the most recent &quot;revision&quot; statement in the imported module.
    </t>
</section>
</section>
<section title="The include Statement" anchor="include">
    <t>
The &quot;include&quot; statement is used to make content from a submodule
available to that submodule&apos;s parent module, or to another submodule
of that parent module.  The argument is an identifier that is the
name of the submodule to include.  Modules are only allowed to include
submodules that belong to that module, as defined by the &quot;belongs&#8209;to&quot;
statement (see <xref target="belongs-to"/>).  Submodules are only allowed to include
other submodules belonging to the same module.
    </t>
    <t>
When a module includes a submodule, it incorporates the contents of
the submodule into the node hierarchy of the module.  When a submodule
includes another submodule, the target submodule&apos;s definitions are
made available to the current submodule.
    </t>
    <t>
When the optional &quot;revision&#8209;date&quot; substatement is present, the
specified revision of the submodule is included in the module.  It is
an error if the specified revision of the submodule does not exist.
If no &quot;revision&#8209;date&quot; substatement is present, it is undefined which
revision of the submodule is included.
    </t>
    <t>
Multiple revisions of the same submodule MUST NOT be included.
    </t>
<?rfc compact="yes"?><texttable>
<preamble>The includes&apos;s Substatements</preamble>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>revision-date</c>
<c><xref format="counter" target="revision-date"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="The organization Statement" anchor="organization">
    <t>
The &quot;organization&quot; statement defines the party responsible for this
module.  The argument is a string that is used to specify a textual
description of the organization(s) under whose auspices this module
was developed.
    </t>
</section>
<section title="The contact Statement" anchor="contact">
    <t>
The &quot;contact&quot; statement provides contact information for the module.
The argument is a string that is used to specify contact information
for the person or persons to whom technical queries concerning this
module should be sent, such as their name, postal address, telephone
number, and electronic mail address.
    </t>
</section>
<section title="The revision Statement" anchor="revision">
    <t>
The &quot;revision&quot; statement specifies the editorial revision history of
the module, including the initial revision.  A series of revision
statements detail the changes in the module&apos;s definition.  The
argument is a date string in the format &quot;YYYY&#8209;MM&#8209;DD&quot;, followed by a
block of substatements that holds detailed revision information.  A
module SHOULD have at least one initial &quot;revision&quot; statement.  For
every published editorial change, a new one SHOULD be added in front
of the revisions sequence, so that all revisions are in reverse
chronological order.
    </t>
<section title="The revision&apos;s Substatement">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
</section>
<section title="Usage Example">
	<figure>
	    <artwork><![CDATA[
  module acme-system {
      namespace "http://acme.example.com/system";
      prefix "acme";

      import ietf-yang-types { 
          prefix "yang"; 
      }

      include acme-types;

      organization "ACME Inc.";
      contact
          "Joe L. User

           ACME, Inc.
           42 Anywhere Drive
           Nowhere, CA 95134
           USA

           Phone: +1 800 555 0100
           EMail: joe@acme.example.com";

      description
          "The module for entities implementing the ACME protocol.";

      revision "2007-06-09" {
          description "Initial revision.";
      }

      // definitions follow...
  }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The submodule Statement">
    <t>
While the primary unit in YANG is a module, a YANG module can itself
be constructed out of several submodules. Submodules allow a module
designer to split a complex model into several pieces where all the
submodules contribute to a single namespace, which is defined by the
module that includes the submodules.
    </t>
    <t>
The &quot;submodule&quot; statement defines the submodule&apos;s name, and groups all
statements that belong to the submodule together.  The &quot;submodule&quot;
statement&apos;s argument is the name of the submodule, followed by a block
of substatements that hold detailed submodule information.  The
submodule name follows the rules for identifiers in <xref target="identifiers"/>.
    </t>
    <t>
Names of submodules published in RFC streams <xref target="RFC4844"/> MUST be assigned by
IANA, see <xref target="iana"/>.
    </t>
    <t>
Private submodule names are assigned by the organization owning the
submodule without a central registry. It is RECOMMENDED to choose
submodule names that will have a low probability of colliding with
standard or other enterprise modules and submodules, e.g., by using the
enterprise or organization name as a prefix for the submodule name.
    </t>
    <t>
A submodule typically has the following layout:
    </t>
	<figure>
	    <artwork><![CDATA[
  submodule <module-name> {
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
      <yang-version statement>
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
      // module identification
      <belongs-to statement>

      // linkage statements
      <import statements>
      <include statements>

      // meta information
      <organization statement>
      <contact statement>
      <description statement>
      <reference statement>

      // revision history
      <revision statements>

      // module definitions
      <other statements>
  }
	    ]]></artwork>
	</figure>
<section title="The submodule&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>anyxml</c>
<c><xref format="counter" target="anyxml"/></c>
<c>0..n</c>
<c>augment</c>
<c><xref format="counter" target="augment"/></c>
<c>0..n</c>
<c>belongs-to</c>
<c><xref format="counter" target="belongs-to"/></c>
<c>1</c>
<c>choice</c>
<c><xref format="counter" target="choice"/></c>
<c>0..n</c>
<c>contact</c>
<c><xref format="counter" target="contact"/></c>
<c>0..1</c>
<c>container</c>
<c><xref format="counter" target="container"/></c>
<c>0..n</c>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>deviation</c>
<c><xref format="counter" target="deviation"/></c>
<c>0..n</c>
<c>extension</c>
<c><xref format="counter" target="extension"/></c>
<c>0..n</c>
<c>feature</c>
<c><xref format="counter" target="feature"/></c>
<c>0..n</c>
<c>grouping</c>
<c><xref format="counter" target="grouping"/></c>
<c>0..n</c>
<c>identity</c>
<c><xref format="counter" target="identity"/></c>
<c>0..n</c>
<c>import</c>
<c><xref format="counter" target="import"/></c>
<c>0..n</c>
<c>include</c>
<c><xref format="counter" target="include"/></c>
<c>0..n</c>
<c>leaf</c>
<c><xref format="counter" target="leaf"/></c>
<c>0..n</c>
<c>leaf-list</c>
<c><xref format="counter" target="leaf-list"/></c>
<c>0..n</c>
<c>list</c>
<c><xref format="counter" target="list"/></c>
<c>0..n</c>
<c>notification</c>
<c><xref format="counter" target="notification"/></c>
<c>0..n</c>
<c>organization</c>
<c><xref format="counter" target="organization"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>revision</c>
<c><xref format="counter" target="revision"/></c>
<c>0..n</c>
<c>rpc</c>
<c><xref format="counter" target="rpc"/></c>
<c>0..n</c>
<c>typedef</c>
<c><xref format="counter" target="typedef"/></c>
<c>0..n</c>
<c>uses</c>
<c><xref format="counter" target="uses"/></c>
<c>0..n</c>
<c>yang-version</c>
<c><xref format="counter" target="yang-version"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="The belongs-to Statement" anchor="belongs-to">
    <t>
The &quot;belongs&#8209;to&quot; statement specifies the module to which the submodule
belongs.  The argument is an identifier that is the name of the
module.
    </t>
    <t>
A submodule MUST only be included by the module to which it belongs, or
by another submodule that belongs to that module.
    </t>
    <t>
The mandatory &quot;prefix&quot; substatement assigns a prefix for the module to
which the submodule belongs. All definitions in the local submodule
and any included submodules can be accessed by using the prefix.
    </t>
<?rfc compact="yes"?><texttable>
<preamble>The belongs-to&apos;s Substatements</preamble>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>prefix</c>
<c><xref format="counter" target="prefix"/></c>
<c>1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="Usage Example">
	<figure>
	    <artwork><![CDATA[
  submodule acme-types {

      belongs-to "acme-system" {
          prefix "acme";
      }

      import ietf-yang-types { 
          prefix "yang"; 
      }

      organization "ACME Inc.";
      contact
          "Joe L. User

           ACME, Inc.
           42 Anywhere Drive
           Nowhere, CA 95134
           USA

           Phone: +1 800 555 0100
           EMail: joe@acme.example.com";

      description
          "This submodule defines common ACME types.";

      revision "2007-06-09" {
          description "Initial revision.";
      }

      // definitions follows...
  }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The typedef Statement" anchor="typedef">
    <t>
The &quot;typedef&quot; statement defines a new type that may be used locally
in the module, in modules or submodules which include it, and by other
modules that import from it, according to the rules in
<xref target="nested-scoping"/>.  The new type is called the &quot;derived type&quot;, and the
type from which it was derived is called the &quot;base type&quot;.  All derived
types can be traced back to a YANG built-in type.
    </t>
    <t>
The &quot;typedef&quot; statement&apos;s argument is an identifier that is the name
of the type to be defined, and MUST be followed by a block of
substatements that holds detailed typedef information.
    </t>
    <t>
The name of the type MUST NOT be one of the YANG built-in types.  If
the typedef is defined at the top level of a YANG module or submodule,
the name of the type to be defined MUST be unique within the module.
    </t>
<section title="The typedef&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>default</c>
<c><xref format="counter" target="typedef-default"/></c>
<c>0..1</c>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
<c>type</c>
<c><xref format="counter" target="typedef-type"/></c>
<c>1</c>
<c>units</c>
<c><xref format="counter" target="units"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="The typedef&apos;s type Statement" anchor="typedef-type">
    <t>
The &quot;type&quot; statement, which MUST be present, defines the base type
from which this type is derived.  See <xref target="type"/> for details.
    </t>
</section>
<section title="The units Statement" anchor="units">
    <t>
The &quot;units&quot; statement, which is optional, takes as an argument a string
that contains a textual definition of the units associated with the
type.
    </t>
</section>
<section title="The typedef&apos;s default Statement" anchor="typedef-default">
    <t>
The &quot;default&quot; statement takes as an argument a string that contains a
default value for the new type.
    </t>
    <t>
The value of the &quot;default&quot; statement MUST be valid according to the type
specified in the &quot;type&quot; statement.
    </t>
    <t>
If the base type has a default value, and the new derived type does
not specify a new default value, the base type&apos;s default value is also
the default value of the new derived type.
    </t>
    <t>
If the type&apos;s default value is not valid according to the new
restrictions specified in a derived type or leaf definition, the
derived type or leaf definition MUST specify a new default value
compatible with the restrictions.
    </t>
</section>
<section title="Usage Example">
	<figure>
	    <artwork><![CDATA[
  typedef listen-ipv4-address {
      type inet:ipv4-address;
      default "0.0.0.0";
  }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The type Statement" anchor="type">
    <t>
The &quot;type&quot; statement takes as an argument a string that is the
name of a YANG built-in type (see <xref target="built-in"/>) or a derived type (see
<xref target="typedef"/>), followed by an optional block of substatements that are
used to put further restrictions on the type.
    </t>
    <t>
The restrictions that can be applied depend on the type being
restricted.  The restriction statements for all built-in types are
described in the subsections of <xref target="built-in"/>.
    </t>
<section title="The type&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>bit</c>
<c><xref format="counter" target="bit"/></c>
<c>0..n</c>
<c>enum</c>
<c><xref format="counter" target="enum"/></c>
<c>0..n</c>
<c>length</c>
<c><xref format="counter" target="length"/></c>
<c>0..1</c>
<c>path</c>
<c><xref format="counter" target="path"/></c>
<c>0..1</c>
<c>pattern</c>
<c><xref format="counter" target="pattern"/></c>
<c>0..n</c>
<c>range</c>
<c><xref format="counter" target="range"/></c>
<c>0..1</c>
<c>require-instance</c>
<c><xref format="counter" target="require-instance"/></c>
<c>0..1</c>
<c>type</c>
<c><xref format="counter" target="type"/></c>
<c>0..n</c>
</texttable>
<?rfc compact="no"?></section>
</section>
<section title="The container Statement" anchor="container">
    <t>
The &quot;container&quot; statement is used to define an interior data node
in the schema tree.  It takes one argument, which is an identifier,
followed by a block of substatements that holds detailed container
information.
    </t>
    <t>
A container node does not have a value, but it has a list of child
nodes in the data tree.  The child nodes are defined in the
container&apos;s substatements.
    </t>
<section title="Containers with Presence" anchor="container-presence">
    <t>
YANG supports two styles of containers, those that exist only for
organizing the hierarchy of data nodes, and those whose presence in
the configuration has an explicit meaning.
    </t>
    <t>
In the first style, the container has no meaning of its own, existing
only to contain child nodes.  This is the default style.
    </t>
    <t>
For example, the set of scrambling options for Synchronous Optical Network (SONET) interfaces may be
placed inside a &quot;scrambling&quot; container to enhance the organization of
the configuration hierarchy, and to keep these nodes together.  The
&quot;scrambling&quot; node itself has no meaning, so removing the node when it
becomes empty relieves the user from performing this task.
    </t>
    <t>
In the second style, the presence of the container itself is
configuration data, representing a single bit of configuration data.
The container acts as both a configuration knob and a means of
organizing related configuration.  These containers are explicitly
created and deleted.
    </t>
    <t>
YANG calls this style a &quot;presence container&quot; and it is indicated
using the &quot;presence&quot; statement, which takes as its argument a text
string indicating what the presence of the node means.
    </t>
    <t>
For example, an &quot;ssh&quot; container may turn on the ability to log into
the device using ssh, but can also contain any ssh-related
configuration knobs, such as connection rates or retry limits.
    </t>
    <t>
The &quot;presence&quot; statement (see <xref target="presence"/>) is used to give semantics to
the existence of the container in the data tree.
    </t>
</section>
<section title="The container&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>anyxml</c>
<c><xref format="counter" target="anyxml"/></c>
<c>0..n</c>
<c>choice</c>
<c><xref format="counter" target="choice"/></c>
<c>0..n</c>
<c>config</c>
<c><xref format="counter" target="config"/></c>
<c>0..1</c>
<c>container</c>
<c><xref format="counter" target="container"/></c>
<c>0..n</c>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>grouping</c>
<c><xref format="counter" target="grouping"/></c>
<c>0..n</c>
<c>if-feature</c>
<c><xref format="counter" target="if-feature"/></c>
<c>0..n</c>
<c>leaf</c>
<c><xref format="counter" target="leaf"/></c>
<c>0..n</c>
<c>leaf-list</c>
<c><xref format="counter" target="leaf-list"/></c>
<c>0..n</c>
<c>list</c>
<c><xref format="counter" target="list"/></c>
<c>0..n</c>
<c>must</c>
<c><xref format="counter" target="must"/></c>
<c>0..n</c>
<c>presence</c>
<c><xref format="counter" target="presence"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
<c>typedef</c>
<c><xref format="counter" target="typedef"/></c>
<c>0..n</c>
<c>uses</c>
<c><xref format="counter" target="uses"/></c>
<c>0..n</c>
<c>when</c>
<c><xref format="counter" target="when"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="The must Statement" anchor="must">
    <t>
The &quot;must&quot; statement, which is optional, takes as an argument a string
that contains an XPath expression (see <xref target="xpath"/>).  It is used to
formally declare a constraint on valid data.  The constraint is
enforced according to the rules in <xref target="constraints"/>.
    </t>
    <t>
When a datastore is validated, all &quot;must&quot; constraints are conceptually
evaluated once for each data node in the data tree, and for all leafs
with default values in use (see <xref target="leaf-default-value"/>).  If a data
node does not exist in the data tree, and it does not have a default
value, its &quot;must&quot; statements are not evaluated.
    </t>
    <t>
All such constraints MUST evaluate to true for the data to be valid.
    </t>
    <t>
The XPath expression is conceptually evaluated in the following
context, in addition to the definition in <xref target="xpath-context"/>:
    </t>
<t>
 <list style="symbols">
 <t>
The context node is the node in the data tree for which the
&quot;must&quot; statement is defined.
 </t>
 <t>
The accessible tree is made up of all nodes in the data tree, and
all leafs with default values in use (see <xref target="leaf-default-value"/>).
 </t>
 </list>
</t>
    <t>
The accessible tree depends on the context node:
    </t>
<t>
 <list style="symbols">
 <t>
If the context node represents configuration, the tree is the data
in the NETCONF datastore where the context node exists.  The XPath
root node has all top-level configuration data nodes in all modules
as children.
 </t>
 <t>
If the context node represents state data, the tree is
all state data on the device, and the &lt;running/&gt; datastore.
The XPath root node has all top-level data nodes in all modules as
children.
 </t>
 <t>
If the context node represents notification content, the tree is the
notification XML instance document.  The XPath root node has the
element representing the notification being defined as the only
child.
 </t>
 <t>
If the context node represents RPC input parameters, the tree is the
RPC XML instance document.  The XPath root node has the
element representing the RPC operation being defined as the only
child.
 </t>
 <t>
If the context node represents RPC output parameters, the tree is
the RPC reply instance document.  The XPath root node has the
elements representing the RPC output parameters as children.
 </t>
 </list>
</t>
    <t>
The result of the XPath expression is converted to a boolean value
using the standard XPath rules.
    </t>
    <t>
Note that since all leaf values in the data tree are conceptually
stored in their canonical form (see Sections <xref target="leaf" format="counter"/> and <xref target="leaf-list" format="counter"/>), any XPath
comparisons are done on the canonical value.
    </t>
    <t>
Also note that the XPath expression is conceptually evaluated.  This means
that an implementation does not have to use an XPath evaluator on the
device.  How the evaluation is done in practice is an
implementation decision.
    </t>
</section>
<section title="The must&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>error-app-tag</c>
<c><xref format="counter" target="error-app-tag"/></c>
<c>0..1</c>
<c>error-message</c>
<c><xref format="counter" target="error-message"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?><section title="The error-message Statement" anchor="error-message">
    <t>
The &quot;error&#8209;message&quot; statement, which is optional, takes a string
as an argument.  If the constraint evaluates to false, the string is
passed as &lt;error&#8209;message&gt; in the &lt;rpc&#8209;error&gt;.
    </t>
</section>
<section title="The error-app-tag Statement" anchor="error-app-tag">
    <t>
The &quot;error&#8209;app&#8209;tag&quot; statement, which is optional, takes a string
as an argument.  If the constraint evaluates to false, the string is
passed as &lt;error&#8209;app&#8209;tag&gt; in the &lt;rpc&#8209;error&gt;.
    </t>
</section>
<section title="Usage Example of must and error-message">
	<figure>
	    <artwork><![CDATA[
  container interface {
      leaf ifType {
          type enumeration {
              enum ethernet;
              enum atm;
          }
      }
      leaf ifMTU {
          type uint32;
      }
      must "ifType != 'ethernet' or " +
           "(ifType = 'ethernet' and ifMTU = 1500)" {
          error-message "An ethernet MTU must be 1500";
      }
      must "ifType != 'atm' or " +
           "(ifType = 'atm' and ifMTU <= 17966 and ifMTU >= 64)" {
          error-message "An atm MTU must be  64 .. 17966";
      }
  }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The presence Statement" anchor="presence">
    <t>
The &quot;presence&quot; statement assigns a meaning to the presence of a
container in the data tree.  It takes as an argument a string that
contains a textual description of what the node&apos;s presence means.
    </t>
    <t>
If a container has the &quot;presence&quot; statement, the container&apos;s existence
in the data tree carries some meaning.  Otherwise, the container is
used to give some structure to the data, and it carries no meaning by
itself.
    </t>
    <t>
See <xref target="container-presence"/> for additional information.
    </t>
</section>
<section title="The container&apos;s Child Node Statements">
    <t>
Within a container, the &quot;container&quot;, &quot;leaf&quot;, &quot;list&quot;, &quot;leaf&#8209;list&quot;,
&quot;uses&quot;, &quot;choice&quot;, and &quot;anyxml&quot; statements can be used to define child
nodes to the container.
    </t>
</section>
<section title="XML Mapping Rules">
    <t>
A container node is encoded as an XML element.  The element&apos;s local
name is the container&apos;s identifier, and its namespace is the
module&apos;s XML namespace (see <xref target="namespace"/>).
    </t>
    <t>
The container&apos;s child nodes are encoded as subelements to the
container element.  If the container defines RPC input or output
parameters, these subelements are encoded in the same order as they
are defined within the &quot;container&quot; statement.  Otherwise, the
subelements are encoded in any order.
    </t>
    <t>
A NETCONF server that replies to a &lt;get&gt; or &lt;get&#8209;config&gt; request MAY
choose not to send a container element if the container node does not
have the &quot;presence&quot; statement and no child nodes exist.  Thus, a
client that receives an &lt;rpc&#8209;reply&gt; for a &lt;get&gt; or &lt;get&#8209;config&gt;
request, must be prepared to handle the case that a container node
without a &quot;presence&quot; statement is not present in the XML.
    </t>
</section>
<section title="NETCONF &lt;edit&#8209;config&gt; Operations">
    <t>
Containers can be created, deleted, replaced, and modified through
&lt;edit&#8209;config&gt;, by using the &quot;operation&quot; attribute (see <xref target="RFC4741"/>,
Section 7.2) in the container&apos;s XML element.
    </t>
    <t>
If a container does not have a &quot;presence&quot; statement and the last child
node is deleted, the NETCONF server MAY delete the container.
    </t>
    <t>
When a NETCONF server processes an &lt;edit&#8209;config&gt; request, the
elements of procedure for the container node are:
    </t>
<t>
 <list style="empty">
 <t>
If the operation is &quot;merge&quot; or &quot;replace&quot;, the node is created if it
does not exist.
 </t>
 <t>
If the operation is &quot;create&quot;, the node is created if it does not
exist.  If the node already exists, a &quot;data&#8209;exists&quot; error is
returned.
 </t>
 <t>
If the operation is &quot;delete&quot;, the node is deleted if it exists.  If
the node does not exist, a &quot;data&#8209;missing&quot; error is returned.
 </t>
 </list>
</t>
</section>
<section title="Usage Example" anchor="container-xml-encoding-example">
    <t>
Given the following container definition:
    </t>
	<figure>
	    <artwork><![CDATA[
  container system {
      description "Contains various system parameters";
      container services {
          description "Configure externally available services";
          container "ssh" {
              presence "Enables SSH";
              description "SSH service specific configuration";
              // more leafs, containers and stuff here...
          }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
A corresponding XML instance example:
    </t>
	<figure>
	    <artwork><![CDATA[
  <system>
    <services>
      <ssh/>
    </services>
  </system>
	    ]]></artwork>
	</figure>
    <t>
Since the &lt;ssh&gt; element is present, ssh is enabled.
    </t>
    <t>
To delete a container with an &lt;edit&#8209;config&gt;:
    </t>
	<figure>
	    <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
      <target>
        <running/>
      </target>
      <config>
        <system xmlns="http://example.com/schema/config">
          <services>
            <ssh nc:operation="delete"/>
          </services>
        </system>
      </config>
    </edit-config>
  </rpc>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The leaf Statement" anchor="leaf">
    <t>
The &quot;leaf&quot; statement is used to define a leaf node in the schema tree.
It takes one argument, which is an identifier, followed by a block of
substatements that holds detailed leaf information.
    </t>
    <t>
A leaf node has a value, but no child nodes in the data tree.
Conceptually, the value in the data tree is always in the canonical
form (see <xref target="canonical"/>).
    </t>
    <t>
A leaf node exists in zero or one instances in the data tree.
    </t>
    <t>
The &quot;leaf&quot; statement is used to define a scalar variable of a
particular built-in or derived type.
    </t>
<section title="The leaf&apos;s default value" anchor="leaf-default-value">
    <t>
The default value of a leaf is the value that the server uses if the
leaf does not exist in the data tree.  The usage of the default value
depends on the leaf&apos;s closest ancestor node in the schema tree that
is not a non-presence container:
    </t>
<t>
 <list style="symbols">
 <t>
If no such ancestor exists in the schema tree, the default value
MUST be used.
 </t>
 <t>
Otherwise, if this ancestor is a case node, the default value
MUST be used if any node from the case exists in the data tree, or
if the case node is the choice&apos;s default case, and no
nodes from any other case exist in the data tree.
 </t>
 <t>
Otherwise, the default value MUST be used if the ancestor node
exists in the data tree. 
 </t>
 </list>
</t>
    <t>
In these cases, the default value is said to be in use.
    </t>
    <t>
When the default value is in use, the server MUST operationally
behave as if the leaf was present in the data tree with the default
value as its value.
    </t>
    <t>
If a leaf has a &quot;default&quot; statement, the leaf&apos;s default value is
the value of the &quot;default&quot; statement.  Otherwise, if the leaf&apos;s
type has a default value, and the leaf is not mandatory, then the
leaf&apos;s default value is the type&apos;s default value.  In all other
cases, the leaf does not have a default value.
    </t>
</section>
<section title="The leaf&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>config</c>
<c><xref format="counter" target="config"/></c>
<c>0..1</c>
<c>default</c>
<c><xref format="counter" target="leaf-default"/></c>
<c>0..1</c>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>if-feature</c>
<c><xref format="counter" target="if-feature"/></c>
<c>0..n</c>
<c>mandatory</c>
<c><xref format="counter" target="mandatory"/></c>
<c>0..1</c>
<c>must</c>
<c><xref format="counter" target="must"/></c>
<c>0..n</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
<c>type</c>
<c><xref format="counter" target="leaf-type"/></c>
<c>1</c>
<c>units</c>
<c><xref format="counter" target="units"/></c>
<c>0..1</c>
<c>when</c>
<c><xref format="counter" target="when"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="The leaf&apos;s type Statement" anchor="leaf-type">
    <t>
The &quot;type&quot; statement, which MUST be present, takes as an argument the
name of an existing built-in or derived type.  The optional substatements
specify restrictions on this type.  See <xref target="type"/> for details.
    </t>
</section>
<section title="The leaf&apos;s default Statement" anchor="leaf-default">
    <t>
The &quot;default&quot; statement, which is optional, takes as an argument a
string that contains a default value for the leaf.
    </t>
    <t>
The value of the &quot;default&quot; statement MUST be valid according to the
type specified in the leaf&apos;s &quot;type&quot; statement.
    </t>
    <t>
The &quot;default&quot; statement MUST NOT be present on nodes where
&quot;mandatory&quot; is true.
    </t>
</section>
<section title="The leaf&apos;s mandatory Statement" anchor="mandatory">
    <t>
The &quot;mandatory&quot; statement, which is optional, takes as an argument the
string &quot;true&quot; or &quot;false&quot;, and puts a constraint on valid data.  If not
specified, the default is &quot;false&quot;.
    </t>
    <t>
If &quot;mandatory&quot; is &quot;true&quot;, the behavior of the constraint depends on
the type of the leaf&apos;s closest ancestor node in the schema tree that
is not a non-presence container (see <xref target="container-presence"/>):
    </t>
<t>
 <list style="symbols">
 <t>
If no such ancestor exists in the schema tree, the leaf MUST exist.
 </t>
 <t>
Otherwise, if this ancestor is a case node, the leaf MUST exist if
any node from the case exists in the data tree.
 </t>
 <t>
Otherwise, the leaf MUST exist if the ancestor node exists in the
data tree.
 </t>
 </list>
</t>
    <t>
This constraint is enforced according to the rules in <xref target="constraints"/>.
    </t>
</section>
<section title="XML Mapping Rules">
    <t>
A leaf node is encoded as an XML element.  The element&apos;s local name is
the leaf&apos;s identifier, and its namespace is the module&apos;s XML
namespace (see <xref target="namespace"/>).
    </t>
    <t>
The value of the leaf node is encoded to XML according to the type,
and sent as character data in the element.
    </t>
    <t>
A NETCONF server that replies to a &lt;get&gt; or &lt;get&#8209;config&gt; request MAY
choose not to send the leaf element if its value is the default
value.  Thus, a client that receives an &lt;rpc&#8209;reply&gt; for a &lt;get&gt; or
&lt;get&#8209;config&gt; request, MUST be prepared to handle the case that a leaf
node with a default value is not present in the XML.  In this case,
the value used by the server is known to be the default value.
    </t>
    <t>
See <xref target="leaf-xml-encoding-example"/> for an example.
    </t>
</section>
<section title="NETCONF &lt;edit&#8209;config&gt; Operations" anchor="leaf-edit">
    <t>
When a NETCONF server processes an &lt;edit&#8209;config&gt; request, the
elements of procedure for the leaf node are:
    </t>
<t>
 <list style="empty">
 <t>
If the operation is &quot;merge&quot; or &quot;replace&quot;, the node is created if it
does not exist, and its value is set to the value found in the XML
RPC data.
 </t>
 <t>
If the operation is &quot;create&quot;, the node is created if it does not
exist.  If the node already exists, a &quot;data&#8209;exists&quot; error is
returned.
 </t>
 <t>
If the operation is &quot;delete&quot;, the node is deleted if it exists.  If
the node does not exist, a &quot;data&#8209;missing&quot; error is returned.
 </t>
 </list>
</t>
</section>
<section title="Usage Example" anchor="leaf-xml-encoding-example">
    <t>
Given the following &quot;leaf&quot; statement, placed in the previously defined
&quot;ssh&quot; container (see <xref target="container-xml-encoding-example"/>):
    </t>
	<figure>
	    <artwork><![CDATA[
  leaf port {
      type inet:port-number;
      default 22;
      description "The port to which the SSH server listens"
  }
	    ]]></artwork>
	</figure>
    <t>
A corresponding XML instance example:
    </t>
	<figure>
	    <artwork><![CDATA[
  <port>2022</port>
	    ]]></artwork>
	</figure>
    <t>
To set the value of a leaf with an &lt;edit&#8209;config&gt;:
    </t>
	<figure>
	    <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
      <target>
        <running/>
      </target>
      <config>
        <system xmlns="http://example.com/schema/config">
          <services>
            <ssh>
              <port>2022</port>
            </ssh>
          </services>
        </system>
      </config>
    </edit-config>
  </rpc>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The leaf-list Statement" anchor="leaf-list">
    <t>
Where the &quot;leaf&quot; statement is used to define a simple scalar variable
of a particular type, the &quot;leaf&#8209;list&quot; statement is used to define an
array of a particular type.  The &quot;leaf&#8209;list&quot; statement takes one
argument, which is an identifier, followed by a block of substatements
that holds detailed leaf-list information.
    </t>
    <t>
The values in a leaf-list MUST be unique.
    </t>
    <t>
Conceptually, the values in the data tree are always in the canonical
form (see <xref target="canonical"/>).
    </t>
    <t>
If the type referenced by the leaf-list has a default value, it has no
effect in the leaf-list.
    </t>
<section title="Ordering" anchor="intro-ordering">
    <t>
YANG supports two styles for ordering the entries within lists and
leaf-lists.  In many lists, the order of list entries does not impact
the implementation of the list&apos;s configuration, and the device is free
to sort the list entries in any reasonable order.  The &quot;description&quot;
string for the list may suggest an order to the device implementor.
YANG calls this style of list &quot;system ordered&quot; and they are indicated
with the statement &quot;ordered-by system&quot;.
    </t>
    <t>
For example, a list of valid users would typically be sorted
alphabetically, since the order in which the users appeared in
the configuration would not impact the creation of those users&apos;
accounts. 
    </t>
    <t>
In the other style of lists, the order of list entries matters for
the implementation of the list&apos;s configuration and the user is
responsible for ordering the entries, while the device maintains that
order.  YANG calls this style of list &quot;user ordered&quot; and they are
indicated with the statement &quot;ordered-by user&quot;.
    </t>
    <t>
For example, the order in which firewall filters entries are applied
to incoming traffic may affect how that traffic is filtered.  The user
would need to decide if the filter entry that discards all TCP traffic
should be applied before or after the filter entry that allows all
traffic from trusted interfaces.  The choice of order would be
crucial.
    </t>
    <t>
YANG provides a rich set of facilities within NETCONF&apos;s &lt;edit&#8209;config&gt;
operation that allows the order of list entries in user-ordered lists
to be controlled.  List entries may be inserted or rearranged,
positioned as the first or last entry in the list, or positioned
before or after another specific entry.
    </t>
    <t>
The &quot;ordered&#8209;by&quot; statement is covered in <xref target="ordered-by"/>.
    </t>
</section>
<section title="The leaf-list&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>config</c>
<c><xref format="counter" target="config"/></c>
<c>0..1</c>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>if-feature</c>
<c><xref format="counter" target="if-feature"/></c>
<c>0..n</c>
<c>max-elements</c>
<c><xref format="counter" target="max-elements"/></c>
<c>0..1</c>
<c>min-elements</c>
<c><xref format="counter" target="min-elements"/></c>
<c>0..1</c>
<c>must</c>
<c><xref format="counter" target="must"/></c>
<c>0..n</c>
<c>ordered-by</c>
<c><xref format="counter" target="ordered-by"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
<c>type</c>
<c><xref format="counter" target="type"/></c>
<c>1</c>
<c>units</c>
<c><xref format="counter" target="units"/></c>
<c>0..1</c>
<c>when</c>
<c><xref format="counter" target="when"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="The min-elements Statement" anchor="min-elements">
    <t>
The &quot;min&#8209;elements&quot; statement, which is optional, takes as an argument
a non-negative integer that puts a constraint on valid list entries.
A valid leaf-list or list MUST have at least min-elements entries.
    </t>
    <t>
If no &quot;min&#8209;elements&quot; statement is present, it defaults to zero.
    </t>
    <t>
The behavior of the constraint depends on the type of the leaf-list&apos;s
or list&apos;s closest ancestor node in the schema tree that is not a
non-presence container (see <xref target="container-presence"/>):
    </t>
<t>
 <list style="symbols">
 <t>
If this ancestor is a case node, the constraint is enforced if any
other node from the case exists.
 </t>
 <t>
Otherwise, it is enforced if the ancestor node exists.
 </t>
 </list>
</t>
    <t>
The constraint is further enforced according to the rules in
<xref target="constraints"/>.
    </t>
</section>
<section title="The max-elements Statement" anchor="max-elements">
    <t>
The &quot;max&#8209;elements&quot; statement, which is optional, takes as an argument a
positive integer or the string &quot;unbounded&quot;, which puts a constraint on
valid list entries.  A valid leaf-list or list always has at most
max-elements entries.
    </t>
    <t>
If no &quot;max&#8209;elements&quot; statement is present, it defaults to &quot;unbounded&quot;.
    </t>
    <t>
The &quot;max&#8209;elements&quot; constraint is enforced according to the rules in
<xref target="constraints"/>.
    </t>
</section>
<section title="The ordered-by Statement" anchor="ordered-by">
    <t>
The &quot;ordered&#8209;by&quot; statement defines whether the order of entries within
a list are determined by the user or the system.  The argument is one
of the strings &quot;system&quot; or &quot;user&quot;.  If not present, order defaults to
&quot;system&quot;.
    </t>
    <t>
This statement is ignored if the list represents state data, RPC
output parameters, or notification content.
    </t>
    <t>
See <xref target="intro-ordering"/> for additional information.
    </t>
<section title="ordered-by system">
    <t>
The entries in the list are sorted according to an unspecified order.
Thus, an implementation is free to sort the entries in the most
appropriate order.  An implementation SHOULD use the same order for
the same data, regardless of how the data were created.  Using a
deterministic order will make comparisons possible using simple tools
like &quot;diff&quot;.
    </t>
    <t>
This is the default order.
    </t>
</section>
<section title="ordered-by user">
    <t>
The entries in the list are sorted according to an order defined by
the user.  This order is controlled by using special XML attributes
in the &lt;edit&#8209;config&gt; request.  See <xref target="leaf-list-edit"/> for details.
    </t>
</section>
</section>
<section title="XML Mapping Rules">
    <t>
A leaf-list node is encoded as a series of XML elements.  Each
element&apos;s local name is the leaf-list&apos;s identifier, and its namespace
is the module&apos;s XML namespace (see <xref target="namespace"/>).
    </t>
    <t>
The value of each leaf-list entry is encoded to XML according to the
type, and sent as character data in the element.
    </t>
    <t>
The XML elements representing leaf-list entries MUST appear in the
order specified by the user if the leaf-list is &quot;ordered-by user&quot;;
otherwise, the order is implementation-dependent.  The XML elements
representing leaf-list entries MAY be interleaved with other sibling
elements, unless the leaf-list defines RPC input or output
parameters.
    </t>
    <t>
See <xref target="leaf-list-xml-encoding-example"/> for an example.
    </t>
</section>
<section title="NETCONF &lt;edit&#8209;config&gt; Operations" anchor="leaf-list-edit">
    <t>
Leaf-list entries can be created and deleted, but not modified,
through &lt;edit&#8209;config&gt;, by using the &quot;operation&quot; attribute in the
leaf-list entry&apos;s XML element.
    </t>
    <t>
In an &quot;ordered-by user&quot; leaf-list, the attributes &quot;insert&quot; and &quot;value&quot;
in the YANG XML namespace (<xref target="yang-namespace"/>) can be used to control where
in the leaf-list the entry is inserted.  These can be used during
&quot;create&quot; operations to insert a new leaf-list entry, or during &quot;merge&quot;
or &quot;replace&quot; operations to insert a new leaf-list entry or move an
existing one.
    </t>
    <t>
The &quot;insert&quot; attribute can take the values &quot;first&quot;, &quot;last&quot;, &quot;before&quot;,
and &quot;after&quot;.  If the value is &quot;before&quot; or &quot;after&quot;, the &quot;value&quot;
attribute MUST also be used to specify an existing entry in the
leaf-list.
    </t>
    <t>
If no &quot;insert&quot; attribute is present in the &quot;create&quot; operation, it
defaults to &quot;last&quot;.
    </t>
    <t>
If several entries in an &quot;ordered-by user&quot; leaf-list are modified in
the same &lt;edit&#8209;config&gt; request, the entries are modified one at the
time, in the order of the XML elements in the request.
    </t>
    <t>
In a &lt;copy&#8209;config&gt;, or an &lt;edit&#8209;config&gt; with a &quot;replace&quot; operation
that covers the entire leaf-list, the leaf-list order is the same as
the order of the XML elements in the request.
    </t>
    <t>
When a NETCONF server processes an &lt;edit&#8209;config&gt; request, the
elements of procedure for a leaf-list node are:
    </t>
<t>
 <list style="empty">
 <t>
If the operation is &quot;merge&quot; or &quot;replace&quot;, the leaf-list entry is
created if it does not exist.
 </t>
 <t>
If the operation is &quot;create&quot;, the leaf-list entry is created if it
does not exist.  If the leaf-list entry already exists, a
&quot;data&#8209;exists&quot; error is returned.
 </t>
 <t>
If the operation is &quot;delete&quot;, the entry is deleted from the
leaf-list if it exists.  If the leaf-list entry does not exist, a
&quot;data&#8209;missing&quot; error is returned.
 </t>
 </list>
</t>
</section>
<section title="Usage Example" anchor="leaf-list-xml-encoding-example">
	<figure>
	    <artwork><![CDATA[
  leaf-list allow-user  {
      type string;
      description "A list of user name patterns to allow";
  }
	    ]]></artwork>
	</figure>
    <t>
A corresponding XML instance example:
    </t>
	<figure>
	    <artwork><![CDATA[
  <allow-user>alice</allow-user>
  <allow-user>bob</allow-user>
	    ]]></artwork>
	</figure>
    <t>
To create a new element in this list, using the default &lt;edit&#8209;config&gt;
operation &quot;merge&quot;:
    </t>
	<figure>
	    <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
      <target>
        <running/>
      </target>
      <config>
        <system xmlns="http://example.com/schema/config">
          <services>
            <ssh>
              <allow-user>eric</allow-user>
            </ssh>
          </services>
        </system>
      </config>
    </edit-config>
  </rpc>
	    ]]></artwork>
	</figure>
    <t>
Given the following ordered-by user leaf-list:
    </t>
	<figure>
	    <artwork><![CDATA[
  leaf-list cipher  {
      type string;
      ordered-by user;
      description "A list of ciphers";
  }
	    ]]></artwork>
	</figure>
    <t>
The following would be used to insert a new cipher &quot;blowfish&#8209;cbc&quot; after
&quot;3des&#8209;cbc&quot;:
    </t>
	<figure>
	    <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:yang="urn:ietf:params:xml:ns:yang:1">
    <edit-config>
      <target>
        <running/>
      </target>
      <config>
        <system xmlns="http://example.com/schema/config">
          <services>
            <ssh>
              <cipher nc:operation="create"
                      yang:insert="after"
                      yang:value="3des-cbc">blowfish-cbc</cipher>
            </ssh>
          </services>
        </system>
      </config>
    </edit-config>
  </rpc>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The list Statement" anchor="list">
    <t>
The &quot;list&quot; statement is used to define an interior data node in the
schema tree.  A list node may exist in multiple instances in the data
tree.  Each such instance is known as a list entry.  The &quot;list&quot;
statement takes one argument, which is an identifier, followed by a
block of substatements that holds detailed list information.
    </t>
    <t>
A list entry is uniquely identified by the values of the list&apos;s keys,
if defined.
    </t>
<section title="The list&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>anyxml</c>
<c><xref format="counter" target="anyxml"/></c>
<c>0..n</c>
<c>choice</c>
<c><xref format="counter" target="choice"/></c>
<c>0..n</c>
<c>config</c>
<c><xref format="counter" target="config"/></c>
<c>0..1</c>
<c>container</c>
<c><xref format="counter" target="container"/></c>
<c>0..n</c>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>grouping</c>
<c><xref format="counter" target="grouping"/></c>
<c>0..n</c>
<c>if-feature</c>
<c><xref format="counter" target="if-feature"/></c>
<c>0..n</c>
<c>key</c>
<c><xref format="counter" target="key"/></c>
<c>0..1</c>
<c>leaf</c>
<c><xref format="counter" target="leaf"/></c>
<c>0..n</c>
<c>leaf-list</c>
<c><xref format="counter" target="leaf-list"/></c>
<c>0..n</c>
<c>list</c>
<c><xref format="counter" target="list"/></c>
<c>0..n</c>
<c>max-elements</c>
<c><xref format="counter" target="max-elements"/></c>
<c>0..1</c>
<c>min-elements</c>
<c><xref format="counter" target="min-elements"/></c>
<c>0..1</c>
<c>must</c>
<c><xref format="counter" target="must"/></c>
<c>0..n</c>
<c>ordered-by</c>
<c><xref format="counter" target="ordered-by"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
<c>typedef</c>
<c><xref format="counter" target="typedef"/></c>
<c>0..n</c>
<c>unique</c>
<c><xref format="counter" target="unique"/></c>
<c>0..n</c>
<c>uses</c>
<c><xref format="counter" target="uses"/></c>
<c>0..n</c>
<c>when</c>
<c><xref format="counter" target="when"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="The list&apos;s key Statement" anchor="key">
    <t>
The &quot;key&quot; statement, which MUST be present if the list represents
configuration, and MAY be present otherwise, takes as an argument a
string that specifies a space-separated list of leaf identifiers of
this list.  A leaf identifier MUST NOT appear more than once in the
key.  Each such leaf identifier MUST refer to a child leaf of the
list.  The leafs can be defined directly in substatements to the
list, or in groupings used in the list.
    </t>
    <t>
The combined values of all the leafs specified in the key are used to
uniquely identify a list entry.  All key leafs MUST be given values
when a list entry is created.  Thus, any default values in the key
leafs or their types are ignored.  It also implies that any mandatory
statement in the key leafs are ignored.
    </t>
    <t>
A leaf that is part of the key can be of any built-in or derived type,
except it MUST NOT be the built-in type &quot;empty&quot;.
    </t>
    <t>
All key leafs in a list MUST have the same value for their &quot;config&quot; as
the list itself.
    </t>
    <t>
The key string syntax is formally defined by the rule &quot;key&#8209;arg&quot; in
<xref target="grammar"/>.
    </t>
</section>
<section title="The list&apos;s unique Statement" anchor="unique">
    <t>
The &quot;unique&quot; statement is used to put constraints on valid list
entries.  It takes as an argument a string that contains a space-separated list of schema node identifiers, which MUST be given in the
descendant form (see the rule &quot;descendant&#8209;schema&#8209;nodeid&quot; in
<xref target="grammar"/>).  Each such schema node identifier MUST refer to a leaf.
    </t>
    <t>
If one of the referenced leafs represents configuration data, then all
of the referenced leafs MUST represent configuration data.
    </t>
    <t>
The &quot;unique&quot; constraint specifies that the combined values of all the
leaf instances specified in the argument string, including leafs with
default values, MUST be unique within all list entry instances in
which all referenced leafs exist.  The constraint is enforced
according to the rules in <xref target="constraints"/>.
    </t>
    <t>
The unique string syntax is formally defined by the rule &quot;unique&#8209;arg&quot;
in <xref target="grammar"/>.
    </t>
<section title="Usage Example">
    <t>
With the following list:
    </t>
	<figure>
	    <artwork><![CDATA[
  list server {
      key "name";
      unique "ip port";
      leaf name {
          type string;
      }
      leaf ip {
          type inet:ip-address;
      }
      leaf port {
          type inet:port-number;
      }
  }
	    ]]></artwork>
	</figure>
    <t>
The following configuration is not valid:
    </t>
	<figure>
	    <artwork><![CDATA[
  <server>
    <name>smtp</name>
    <ip>192.0.2.1</ip>
    <port>25</port>
  </server>

  <server>
    <name>http</name>
    <ip>192.0.2.1</ip>
    <port>25</port>
  </server>
	    ]]></artwork>
	</figure>
    <t>
The following configuration is valid, since the &quot;http&quot; and &quot;ftp&quot; list
entries do not have a value for all referenced leafs, and are thus not
taken into account when the &quot;unique&quot; constraint is enforced:
    </t>
	<figure>
	    <artwork><![CDATA[
  <server>
    <name>smtp</name>
    <ip>192.0.2.1</ip>
    <port>25</port>
  </server>

  <server>
    <name>http</name>
    <ip>192.0.2.1</ip>
  </server>

  <server>
    <name>ftp</name>
    <ip>192.0.2.1</ip>
  </server>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The list&apos;s Child Node Statements">
    <t>
Within a list, the &quot;container&quot;, &quot;leaf&quot;, &quot;list&quot;, &quot;leaf&#8209;list&quot;, &quot;uses&quot;,
&quot;choice&quot;, and &quot;anyxml&quot; statements can be used to define child nodes to
the list.
    </t>
</section>
<section title="XML Mapping Rules">
    <t>
A list is encoded as a series of XML elements, one for each entry in
the list.  Each element&apos;s local name is the list&apos;s identifier, and its
namespace is the module&apos;s XML namespace (see <xref target="namespace"/>).
    </t>
    <t>
The list&apos;s key nodes are encoded as subelements to the list&apos;s
identifier element, in the same order as they are defined within the
&quot;key&quot; statement.
    </t>
    <t>
The rest of the list&apos;s child nodes are encoded as subelements to the
list element, after the keys.  If the list defines RPC input or output
parameters, the subelements are encoded in the same order as they are
defined within the &quot;list&quot; statement.  Otherwise, the subelements are
encoded in any order.
    </t>
    <t>
The XML elements representing list entries MUST appear in the order
specified by the user if the list is &quot;ordered-by user&quot;, otherwise the
order is implementation-dependent.  The XML elements representing list
entries MAY be interleaved with other sibling elements, unless the
list defines RPC input or output parameters.
    </t>
</section>
<section title="NETCONF &lt;edit&#8209;config&gt; Operations">
    <t>
List entries can be created, deleted, replaced, and modified through
&lt;edit&#8209;config&gt;, by using the &quot;operation&quot; attribute in the list&apos;s XML
element.  In each case, the values of all keys are used to
uniquely identify a list entry.  If all keys are not specified for a
list entry, a &quot;missing&#8209;element&quot; error is returned.
    </t>
    <t>
In an &quot;ordered-by user&quot; list, the attributes &quot;insert&quot; and &quot;key&quot; in the
YANG XML namespace (<xref target="yang-namespace"/>) can be used to control where in the
list the entry is inserted.  These can be used during &quot;create&quot;
operations to insert a new list entry, or during &quot;merge&quot; or &quot;replace&quot;
operations to insert a new list entry or move an existing one.
    </t>
    <t>
The &quot;insert&quot; attribute can take the values &quot;first&quot;, &quot;last&quot;, &quot;before&quot;,
and &quot;after&quot;.  If the value is &quot;before&quot; or &quot;after&quot;, the &quot;key&quot; attribute
MUST also be used, to specify an existing element in the list.  The
value of the &quot;key&quot; attribute is the key predicates of the full
instance identifier (see <xref target="inst-id"/>) for the list entry.
    </t>
    <t>
If no &quot;insert&quot; attribute is present in the &quot;create&quot; operation, it
defaults to &quot;last&quot;.
    </t>
    <t>
If several entries in an &quot;ordered-by user&quot; list are modified in
the same &lt;edit&#8209;config&gt; request, the entries are modified one at the
time, in the order of the XML elements in the request.
    </t>
    <t>
In a &lt;copy&#8209;config&gt;, or an &lt;edit&#8209;config&gt; with a &quot;replace&quot; operation
that covers the entire list, the list entry order is the same as the
order of the XML elements in the request.
    </t>
    <t>
When a NETCONF server processes an &lt;edit&#8209;config&gt; request, the
elements of procedure for a list node are:
    </t>
<t>
 <list style="empty">
 <t>
If the operation is &quot;merge&quot; or &quot;replace&quot;, the list entry is created
if it does not exist.  If the list entry already exists and the
&quot;insert&quot; and &quot;key&quot; attributes are present, the list entry is moved
according to the values of the &quot;insert&quot; and &quot;key&quot; attributes.  If
the list entry exists and the &quot;insert&quot; and &quot;key&quot; attributes are not
present, the list entry is not moved.
 </t>
 <t>
If the operation is &quot;create&quot;, the list entry is created if it does
not exist.  If the list entry already exists, a &quot;data&#8209;exists&quot; error
is returned.
 </t>
 <t>
If the operation is &quot;delete&quot;, the entry is deleted from the list if
it exists.  If the list entry does not exist, a &quot;data&#8209;missing&quot;
error is returned.
 </t>
 </list>
</t>
</section>
<section title="Usage Example">
    <t>
Given the following list:
    </t>
	<figure>
	    <artwork><![CDATA[
  list user {
      key "name";
      config true;
      description "This is a list of users in the system.";

      leaf name {
          type string;
      }
      leaf type {
          type string;
      }
      leaf full-name {
          type string;
      }
  }
	    ]]></artwork>
	</figure>
    <t>
A corresponding XML instance example:
    </t>
	<figure>
	    <artwork><![CDATA[
  <user>
    <name>fred</name>
    <type>admin</type>
    <full-name>Fred Flintstone</full-name>
  </user>
	    ]]></artwork>
	</figure>
    <t>
To create a new user &quot;barney&quot;:
    </t>
	<figure>
	    <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
      <target>
        <running/>
      </target>
      <config>
        <system xmlns="http://example.com/schema/config">
          <user nc:operation="create">
            <name>barney</name>
            <type>admin</type>
            <full-name>Barney Rubble</full-name>
          </user>
        </system>
      </config>
    </edit-config>
  </rpc>
	    ]]></artwork>
	</figure>
    <t>
To change the type of &quot;fred&quot; to &quot;superuser&quot;:
    </t>
	<figure>
	    <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
      <target>
        <running/>
      </target>
      <config>
        <system xmlns="http://example.com/schema/config">
          <user>
            <name>fred</name>
            <type>superuser</type>
          </user>
        </system>
      </config>
    </edit-config>
  </rpc>
	    ]]></artwork>
	</figure>
    <t>
Given the following ordered-by user list:
    </t>
	<figure>
	    <artwork><![CDATA[
  list user {
      description "This is a list of users in the system.";
      ordered-by user;
      config true;

      key "name";

      leaf name {
          type string;
      }
      leaf type {
          type string;
      }
      leaf full-name {
          type string;
      }
  }
	    ]]></artwork>
	</figure>
    <t>
The following would be used to insert a new user &quot;barney&quot; after the user
&quot;fred&quot;:
    </t>
	<figure>
	    <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:yang="urn:ietf:params:xml:ns:yang:1">
    <edit-config>
      <target>
        <running/>
      </target>
      <config>
        <system xmlns="http://example.com/schema/config"
             xmlns:ex="http://example.com/schema/config">
          <user nc:operation="create"
                yang:insert="after"
                yang:key="[ex:name='fred']">
            <name>barney</name>
            <type>admin</type>
            <full-name>Barney Rubble</full-name>
          </user>
        </system>
      </config>
    </edit-config>
  </rpc>
	    ]]></artwork>
	</figure>
    <t>
The following would be used to move the user &quot;barney&quot; before the user
&quot;fred&quot;:
    </t>
	<figure>
	    <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:yang="urn:ietf:params:xml:ns:yang:1">
    <edit-config>
      <target>
        <running/>
      </target>
      <config>
        <system xmlns="http://example.com/schema/config"
             xmlns:ex="http://example.com/schema/config">
          <user nc:operation="merge"
                yang:insert="before"
                yang:key="[ex:name='fred']">
            <name>barney</name>
          </user>
        </system>
      </config>
    </edit-config>
  </rpc>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The choice Statement" anchor="choice">
    <t>
The &quot;choice&quot; statement defines a set of alternatives, only one of
which may exist at any one time.  The argument is an identifier,
followed by a block of substatements that holds detailed choice
information.  The identifier is used to identify the choice node in
the schema tree.  A choice node does not exist in the data tree.
    </t>
    <t>
A choice consists of a number of branches, defined with the &quot;case&quot;
substatement.  Each branch contains a number of child nodes.  The
nodes from at most one of the choice&apos;s branches exist at the same
time.
    </t>
    <t>
See <xref target="edit-config-processing"/> for additional information.
    </t>
<section title="The choice&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>anyxml</c>
<c><xref format="counter" target="anyxml"/></c>
<c>0..n</c>
<c>case</c>
<c><xref format="counter" target="case"/></c>
<c>0..n</c>
<c>config</c>
<c><xref format="counter" target="config"/></c>
<c>0..1</c>
<c>container</c>
<c><xref format="counter" target="container"/></c>
<c>0..n</c>
<c>default</c>
<c><xref format="counter" target="choice-default"/></c>
<c>0..1</c>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>if-feature</c>
<c><xref format="counter" target="if-feature"/></c>
<c>0..n</c>
<c>leaf</c>
<c><xref format="counter" target="leaf"/></c>
<c>0..n</c>
<c>leaf-list</c>
<c><xref format="counter" target="leaf-list"/></c>
<c>0..n</c>
<c>list</c>
<c><xref format="counter" target="list"/></c>
<c>0..n</c>
<c>mandatory</c>
<c><xref format="counter" target="choice-mandatory"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
<c>when</c>
<c><xref format="counter" target="when"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="The choice&apos;s case Statement" anchor="case">
    <t>
The &quot;case&quot; statement is used to define branches of the choice.  It
takes as an argument an identifier, followed by a block of
substatements that holds detailed case information.
    </t>
    <t>
The identifier is used to identify the case node in the schema
tree.  A case node does not exist in the data tree.
    </t>
    <t>
Within a &quot;case&quot; statement, the &quot;anyxml&quot;, &quot;choice&quot;, &quot;container&quot;,
&quot;leaf&quot;, &quot;list&quot;, &quot;leaf&#8209;list&quot;, and &quot;uses&quot; statements can be used to
define child nodes to the case node.  The identifiers of all these
child nodes MUST be unique within all cases in a choice.  For example,
the following is illegal:
    </t>
	<figure>
	    <artwork><![CDATA[
  choice interface-type {     // This example is illegal YANG
      case a {
          leaf ethernet { ... }
      }
      case b {
          container ethernet { ...}
      }
  }
	    ]]></artwork>
	</figure>
    <t>
As a shorthand, the &quot;case&quot; statement can be omitted if the branch
contains a single &quot;anyxml&quot;, &quot;container&quot;, &quot;leaf&quot;, &quot;list&quot;, or &quot;leaf&#8209;list&quot;
statement.  In this case, the identifier of the case node is the
same as the identifier in the branch statement.  The following
example: 
    </t>
	<figure>
	    <artwork><![CDATA[
  choice interface-type {
      container ethernet { ... }
  }
	    ]]></artwork>
	</figure>
    <t>
is equivalent to:
    </t>
	<figure>
	    <artwork><![CDATA[
  choice interface-type {
      case ethernet {
          container ethernet { ... }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
The case identifier MUST be unique within a choice.
    </t>
<section title="The case&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>anyxml</c>
<c><xref format="counter" target="anyxml"/></c>
<c>0..n</c>
<c>choice</c>
<c><xref format="counter" target="choice"/></c>
<c>0..n</c>
<c>container</c>
<c><xref format="counter" target="container"/></c>
<c>0..n</c>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>if-feature</c>
<c><xref format="counter" target="if-feature"/></c>
<c>0..n</c>
<c>leaf</c>
<c><xref format="counter" target="leaf"/></c>
<c>0..n</c>
<c>leaf-list</c>
<c><xref format="counter" target="leaf-list"/></c>
<c>0..n</c>
<c>list</c>
<c><xref format="counter" target="list"/></c>
<c>0..n</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
<c>uses</c>
<c><xref format="counter" target="uses"/></c>
<c>0..n</c>
<c>when</c>
<c><xref format="counter" target="when"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
</section>
<section title="The choice&apos;s default Statement" anchor="choice-default">
    <t>
The &quot;default&quot; statement indicates if a case should be considered as the
default if no child nodes from any of the choice&apos;s cases exist.  The
argument is the identifier of the &quot;case&quot; statement.  If the &quot;default&quot;
statement is missing, there is no default case.
    </t>
    <t>
The &quot;default&quot; statement MUST NOT be present on choices where
&quot;mandatory&quot; is true.
    </t>
    <t>
The default case is only important when considering the default values
of nodes under the cases.  The default values for nodes under the
default case are used if none of the nodes under any of the cases are
present.
    </t>
    <t>
There MUST NOT be any mandatory nodes (<xref target="mandatory-nodes"/>) directly
under the default case.
    </t>
    <t>
Default values for child nodes under a case are only used if one
of the nodes under that case is present, or if that case is the default
case.  If none of the nodes under a case are present and the case is
not the default case, the default values of the cases&apos; child nodes are
ignored.
    </t>
    <t>
In this example, the choice defaults to &quot;interval&quot;, and the default
value will be used if none of &quot;daily&quot;, &quot;time&#8209;of&#8209;day&quot;, or &quot;manual&quot; are
present.  If &quot;daily&quot; is present, the default value for &quot;time&#8209;of&#8209;day&quot;
will be used.
    </t>
	<figure>
	    <artwork><![CDATA[
  container transfer {
      choice how {
          default interval;
          case interval {
              leaf interval {
                  type uint16;
                  default 30;
                  units minutes;
              }
          }
          case daily {
              leaf daily {
                  type empty;
              }
              leaf time-of-day {
                  type string;
                  units 24-hour-clock;
                  default 1am;
              }
          }
          case manual {
              leaf manual {
                  type empty;
              }
          }
      }
  }
	    ]]></artwork>
	</figure>
</section>
<section title="The choice&apos;s mandatory Statement" anchor="choice-mandatory">
    <t>
The &quot;mandatory&quot; statement, which is optional, takes as an argument the
string &quot;true&quot; or &quot;false&quot;, and puts a constraint on valid data.  If
&quot;mandatory&quot; is &quot;true&quot;, at least one node from exactly one of the
choice&apos;s case branches MUST exist.
    </t>
    <t>
If not specified, the default is &quot;false&quot;.
    </t>
    <t>
The behavior of the constraint depends on the type of the choice&apos;s
closest ancestor node in the schema tree which is not a non-presence
container (see <xref target="container-presence"/>):
    </t>
<t>
 <list style="symbols">
 <t>
If this ancestor is a case node, the constraint is enforced if any
other node from the case exists.
 </t>
 <t>
Otherwise, it is enforced if the ancestor node exists.
 </t>
 </list>
</t>
    <t>
The constraint is further enforced according to the rules in
<xref target="constraints"/>.
    </t>
</section>
<section title="XML Mapping Rules">
    <t>
The choice and case nodes are not visible in XML.
    </t>
    <t>
The child nodes of the selected &quot;case&quot; statement MUST be encoded in
the same order as they are defined in the &quot;case&quot; statement if they are
part of an RPC input or output parameter definition.  Otherwise, the
subelements are encoded in any order.
    </t>
</section>
<section title="NETCONF &lt;edit&#8209;config&gt; Operations">
    <t>
Since only one of the choice&apos;s cases can be valid at any time, the
creation of a node from one case implicitly deletes all nodes from all
other cases.  If an &lt;edit&#8209;config&gt; operation creates a node from a
case, the NETCONF server will delete any existing nodes that are
defined in other cases inside the choice.
    </t>
</section>
<section title="Usage Example" anchor="choice-example">
    <t>
Given the following choice:
    </t>
	<figure>
	    <artwork><![CDATA[
  container protocol {
      choice name {
          case a {
              leaf udp {
                  type empty;
              }
          }
          case b {
              leaf tcp {
                 type empty;
              }
          }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
A corresponding XML instance example:
    </t>
	<figure>
	    <artwork><![CDATA[
  <protocol>
    <tcp/>
  </protocol>
	    ]]></artwork>
	</figure>
    <t>
To change the protocol from tcp to udp:
    </t>
	<figure>
	    <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
      <target>
        <running/>
      </target>
      <config>
        <system xmlns="http://example.com/schema/config">
          <protocol>
            <udp nc:operation="create"/>
          </protocol>
        </system>
      </config>
    </edit-config>
  </rpc>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The anyxml Statement" anchor="anyxml">
    <t>
The &quot;anyxml&quot; statement defines an interior node in the schema tree.
It takes one argument, which is an identifier, followed by a block of
substatements that holds detailed anyxml information.
    </t>
    <t>
The &quot;anyxml&quot; statement is used to represent an unknown chunk of XML.  No
restrictions are placed on the XML.  This can be useful, for example,
in RPC replies.  An example is the &lt;filter&gt; parameter in the
&lt;get&#8209;config&gt; operation.
    </t>
    <t>
An anyxml node cannot be augmented (see <xref target="augment"/>).
    </t>
    <t>
Since the use of anyxml limits the manipulation of the content, 
it is RECOMMENDED that the &quot;anyxml&quot; statement not be used to represent
configuration data.
    </t>
    <t>
An anyxml node exists in zero or one instances in the data tree.
    </t>
<section title="The anyxml&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>config</c>
<c><xref format="counter" target="config"/></c>
<c>0..1</c>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>if-feature</c>
<c><xref format="counter" target="if-feature"/></c>
<c>0..n</c>
<c>mandatory</c>
<c><xref format="counter" target="mandatory"/></c>
<c>0..1</c>
<c>must</c>
<c><xref format="counter" target="must"/></c>
<c>0..n</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
<c>when</c>
<c><xref format="counter" target="when"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="XML Mapping Rules">
    <t>
An anyxml node is encoded as an XML element.  The element&apos;s local name
is the anyxml&apos;s identifier, and its namespace is the module&apos;s XML
namespace (see <xref target="namespace"/>).  The value of the anyxml node is encoded
as XML content of this element.
    </t>
    <t>
Note that any prefixes used in the encoding are local to each instance
encoding.  This means that the same XML may be encoded differently by
different implementations.
    </t>
</section>
<section title="NETCONF &lt;edit&#8209;config&gt; Operations">
    <t>
An anyxml node is treated as an opaque chunk of data.  This data can
be modified in its entirety only.
    </t>
    <t>
Any &quot;operation&quot; attributes present on subelements of an anyxml node
are ignored by the NETCONF server.
    </t>
    <t>
When a NETCONF server processes an &lt;edit&#8209;config&gt; request, the
elements of procedure for the anyxml node are:
    </t>
<t>
 <list style="empty">
 <t>
If the operation is &quot;merge&quot; or &quot;replace&quot;, the node is created if it
does not exist, and its value is set to the XML content of the
anyxml node found in the XML RPC data.
 </t>
 <t>
If the operation is &quot;create&quot;, the node is created if it does not
exist, and its value is set to the XML content of the anyxml node
found in the XML RPC data.  If the node already exists, a
&quot;data&#8209;exists&quot; error is returned.
 </t>
 <t>
If the operation is &quot;delete&quot;, the node is deleted if it exists.  If
the node does not exist, a &quot;data&#8209;missing&quot; error is returned.
 </t>
 </list>
</t>
</section>
<section title="Usage Example">
    <t>
Given the following &quot;anyxml&quot; statement:
    </t>
	<figure>
	    <artwork><![CDATA[
  anyxml data;
	    ]]></artwork>
	</figure>
    <t>
The following are two valid encodings of the same anyxml value:
    </t>
	<figure>
	    <artwork><![CDATA[
  <data xmlns:if="http://example.com/ns/interface">
    <if:interface>
      <if:ifIndex>1</if:ifIndex>
    </if:interface>
  </data>

  <data>
    <interface xmlns="http://example.com/ns/interface">
      <ifIndex>1</ifIndex>
    </interface>
  </data>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The grouping Statement" anchor="grouping">
    <t>
The &quot;grouping&quot; statement is used to define a reusable block of nodes,
which may be used locally in the module, in modules that include it,
and by other modules that import from it, according to the rules in
<xref target="nested-scoping"/>.  It takes one argument, which is an identifier,
followed by a block of substatements that holds detailed grouping
information.
    </t>
    <t>
The &quot;grouping&quot; statement is not a data definition statement and, as such,
does not define any nodes in the schema tree.
    </t>
    <t>
A grouping is like a &quot;structure&quot; or a &quot;record&quot; in conventional
programming languages.
    </t>
    <t>
Once a grouping is defined, it can be referenced in a &quot;uses&quot;
statement (see <xref target="uses"/>).  A grouping MUST NOT reference itself, neither
directly nor indirectly through a chain of other groupings.
    </t>
    <t>
If the grouping is defined at the top level of a YANG module or
submodule, the grouping&apos;s identifier MUST be unique within the module.
    </t>
    <t>
A grouping is more than just a mechanism for textual substitution, but
defines a collection of nodes.  Identifiers appearing inside the
grouping are resolved relative to the scope in which the grouping is
defined, not where it is used.  Prefix mappings, type names, grouping
names, and extension usage are evaluated in the hierarchy where the
&quot;grouping&quot; statement appears.  For extensions, this means that
extensions are applied to the grouping node, not the uses node.
    </t>
<section title="The grouping&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>anyxml</c>
<c><xref format="counter" target="anyxml"/></c>
<c>0..n</c>
<c>choice</c>
<c><xref format="counter" target="choice"/></c>
<c>0..n</c>
<c>container</c>
<c><xref format="counter" target="container"/></c>
<c>0..n</c>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>grouping</c>
<c><xref format="counter" target="grouping"/></c>
<c>0..n</c>
<c>leaf</c>
<c><xref format="counter" target="leaf"/></c>
<c>0..n</c>
<c>leaf-list</c>
<c><xref format="counter" target="leaf-list"/></c>
<c>0..n</c>
<c>list</c>
<c><xref format="counter" target="list"/></c>
<c>0..n</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
<c>typedef</c>
<c><xref format="counter" target="typedef"/></c>
<c>0..n</c>
<c>uses</c>
<c><xref format="counter" target="uses"/></c>
<c>0..n</c>
</texttable>
<?rfc compact="no"?></section>
<section title="Usage Example" anchor="grouping-endpt">
	<figure>
	    <artwork><![CDATA[
  import ietf-inet-types {
      prefix "inet";
  }

  grouping endpoint {
      description "A reusable endpoint group.";
      leaf ip {
          type inet:ip-address;
      }
      leaf port {
          type inet:port-number;
      }
  }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The uses Statement" anchor="uses">
    <t>
The &quot;uses&quot; statement is used to reference a &quot;grouping&quot; definition.  It
takes one argument, which is the name of the grouping.
    </t>
    <t>
The effect of a &quot;uses&quot; reference to a grouping is that the nodes
defined by the grouping are copied into the current schema tree, and
then updated according to the &quot;refine&quot; and &quot;augment&quot; statements.
    </t>
    <t>
The identifiers defined in the grouping are not bound to a namespace
until the contents of the grouping are added to the schema tree via a
&quot;uses&quot; statement that does not appear inside a &quot;grouping&quot; statement,
at which point they are bound to the namespace of the current module.
    </t>
<section title="The uses&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>augment</c>
<c><xref format="counter" target="augment"/></c>
<c>0..1</c>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>if-feature</c>
<c><xref format="counter" target="if-feature"/></c>
<c>0..n</c>
<c>refine</c>
<c><xref format="counter" target="refine"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
<c>when</c>
<c><xref format="counter" target="when"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="The refine Statement" anchor="refine">
    <t>
Some of the properties of each node in the grouping can be refined
with the &quot;refine&quot; statement.  The argument is a string that
identifies a node in the grouping.  This node is called the refine&apos;s
target node.  If a node in the grouping is not present as a target
node of a &quot;refine&quot; statement, it is not refined, and thus used exactly
as it was defined in the grouping.
    </t>
    <t>
The argument string is a descendant schema node identifier (see
<xref target="schema-node-id"/>).
    </t>
    <t>
The following refinements can be done:
    </t>
<t>
 <list style="symbols">
 <t>
A leaf or choice node may get a default value, or a new default
value if it already had one.
 </t>
 <t>
Any node may get a specialized &quot;description&quot; string.
 </t>
 <t>
Any node may get a specialized &quot;reference&quot; string.
 </t>
 <t>
Any node may get a different &quot;config&quot; statement.
 </t>
 <t>
A leaf, anyxml, or choice node may get a different &quot;mandatory&quot; statement.
 </t>
 <t>
A container node may get a &quot;presence&quot; statement.
 </t>
 <t>
A leaf, leaf-list, list, container, or anyxml node may get additional &quot;must&quot;
expressions.
 </t>
 <t>
A leaf-list or list node may get a different &quot;min&#8209;elements&quot; or
&quot;max&#8209;elements&quot; statement.
 </t>
 </list>
</t>
</section>
<section title="XML Mapping Rules">
    <t>
Each node in the grouping is encoded as if it was defined inline,
even if it is imported from another module with another XML
namespace.
    </t>
</section>
<section title="Usage Example">
    <t>
To use the &quot;endpoint&quot; grouping defined in <xref target="grouping-endpt"/> in a
definition of an HTTP server in some other module, we can do:
    </t>
	<figure>
	    <artwork><![CDATA[
  import acme-system {
      prefix "acme";
  }

  container http-server {
      leaf name {
          type string;
      }
      uses acme:endpoint;
  }
	    ]]></artwork>
	</figure>
    <t>
A corresponding XML instance example:
    </t>
	<figure>
	    <artwork><![CDATA[
  <http-server>
    <name>extern-web</name>
    <ip>192.0.2.1</ip>
    <port>80</port>
  </http-server>
	    ]]></artwork>
	</figure>
    <t>
If port 80 should be the default for the HTTP server, default
can be added:
    </t>
	<figure>
	    <artwork><![CDATA[
  container http-server {
      leaf name {
          type string;
      }
      uses acme:endpoint {
          refine port {
              default 80;
          }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
If we want to define a list of servers, and each server has the ip and
port as keys, we can do:
    </t>
	<figure>
	    <artwork><![CDATA[
  list server {
      key "ip port";
      leaf name {
          type string;
      }
      uses acme:endpoint;
  }
	    ]]></artwork>
	</figure>
    <t>
The following is an error:
    </t>
	<figure>
	    <artwork><![CDATA[
  container http-server {
      uses acme:endpoint;
      leaf ip {          // illegal - same identifier "ip" used twice
          type string;
      }
  }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The rpc Statement" anchor="rpc">
    <t>
The &quot;rpc&quot; statement is used to define a NETCONF RPC operation.  It takes
one argument, which is an identifier, followed by a block of
substatements that holds detailed rpc information.  This argument is
the name of the RPC, and is used as the element name directly under
the &lt;rpc&gt; element, as designated by the substitution group
&quot;rpcOperation&quot; in <xref target="RFC4741"/>.
    </t>
    <t>
The &quot;rpc&quot; statement defines an rpc node in the schema tree.  Under the
rpc node, a schema node with the name &quot;input&quot;, and a schema node with
the name &quot;output&quot; are also defined.  The nodes &quot;input&quot; and &quot;output&quot; are
defined in the module&apos;s namespace.
    </t>
<section title="The rpc&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>grouping</c>
<c><xref format="counter" target="grouping"/></c>
<c>0..n</c>
<c>if-feature</c>
<c><xref format="counter" target="if-feature"/></c>
<c>0..n</c>
<c>input</c>
<c><xref format="counter" target="input"/></c>
<c>0..1</c>
<c>output</c>
<c><xref format="counter" target="output"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
<c>typedef</c>
<c><xref format="counter" target="typedef"/></c>
<c>0..n</c>
</texttable>
<?rfc compact="no"?></section>
<section title="The input Statement" anchor="input">
    <t>
The &quot;input&quot; statement, which is optional, is used to define input
parameters to the RPC operation.  It does not take an argument.  The
substatements to &quot;input&quot; define nodes under the RPC&apos;s input node.
    </t>
    <t>
If a leaf in the input tree has a &quot;mandatory&quot; statement with the value
&quot;true&quot;, the leaf MUST be present in a NETCONF RPC invocation.
Otherwise, the server MUST return a &quot;missing&#8209;element&quot; error.
    </t>
    <t>
If a leaf in the input tree has a default value, the NETCONF server
MUST use this value in the same cases as described in
<xref target="leaf-default-value"/>.  In these cases, the server MUST operationally
behave as if the leaf was present in the NETCONF RPC invocation with
the default value as its value.
    </t>
    <t>
If a &quot;config&quot; statement is present for any node in the input tree, the
&quot;config&quot; statement is ignored.
    </t>
    <t>
If any node has a &quot;when&quot; statement that would evaluate to
false, then this node MUST NOT be present in the input tree.
    </t>
<section title="The input&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>anyxml</c>
<c><xref format="counter" target="anyxml"/></c>
<c>0..n</c>
<c>choice</c>
<c><xref format="counter" target="choice"/></c>
<c>0..n</c>
<c>container</c>
<c><xref format="counter" target="container"/></c>
<c>0..n</c>
<c>grouping</c>
<c><xref format="counter" target="grouping"/></c>
<c>0..n</c>
<c>leaf</c>
<c><xref format="counter" target="leaf"/></c>
<c>0..n</c>
<c>leaf-list</c>
<c><xref format="counter" target="leaf-list"/></c>
<c>0..n</c>
<c>list</c>
<c><xref format="counter" target="list"/></c>
<c>0..n</c>
<c>typedef</c>
<c><xref format="counter" target="typedef"/></c>
<c>0..n</c>
<c>uses</c>
<c><xref format="counter" target="uses"/></c>
<c>0..n</c>
</texttable>
<?rfc compact="no"?></section>
</section>
<section title="The output Statement" anchor="output">
    <t>
The &quot;output&quot; statement, which is optional, is used to define output
parameters to the RPC operation.  It does not take an argument.  The
substatements to &quot;output&quot; define nodes under the RPC&apos;s output node.
    </t>
    <t>
If a leaf in the output tree has a &quot;mandatory&quot; statement with the
value &quot;true&quot;, the leaf MUST be present in a NETCONF RPC
reply.
    </t>
    <t>
If a leaf in the output tree has a default value, the NETCONF client
MUST use this value in the same cases as described in
<xref target="leaf-default-value"/>.  In these cases, the client MUST operationally
behave as if the leaf was present in the NETCONF RPC reply with
the default value as its value.
    </t>
    <t>
If a &quot;config&quot; statement is present for any node in the output tree,
the &quot;config&quot; statement is ignored.
    </t>
    <t>
If any node has a &quot;when&quot; statement that would evaluate to
false, then this node MUST NOT be present in the output tree.
    </t>
<section title="The output&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>anyxml</c>
<c><xref format="counter" target="anyxml"/></c>
<c>0..n</c>
<c>choice</c>
<c><xref format="counter" target="choice"/></c>
<c>0..n</c>
<c>container</c>
<c><xref format="counter" target="container"/></c>
<c>0..n</c>
<c>grouping</c>
<c><xref format="counter" target="grouping"/></c>
<c>0..n</c>
<c>leaf</c>
<c><xref format="counter" target="leaf"/></c>
<c>0..n</c>
<c>leaf-list</c>
<c><xref format="counter" target="leaf-list"/></c>
<c>0..n</c>
<c>list</c>
<c><xref format="counter" target="list"/></c>
<c>0..n</c>
<c>typedef</c>
<c><xref format="counter" target="typedef"/></c>
<c>0..n</c>
<c>uses</c>
<c><xref format="counter" target="uses"/></c>
<c>0..n</c>
</texttable>
<?rfc compact="no"?></section>
</section>
<section title="XML Mapping Rules">
    <t>
An rpc node is encoded as a child XML element to the &lt;rpc&gt; element
defined in <xref target="RFC4741"/>.  The element&apos;s local name is the rpc&apos;s identifier, and
its namespace is the module&apos;s XML namespace (see <xref target="namespace"/>).
    </t>
    <t>
Input parameters are encoded as child XML elements to the rpc node&apos;s
XML element, in the same order as they are defined within the
&quot;input&quot; statement.
    </t>
    <t>
If the RPC operation invocation succeeded, and no output parameters are
returned, the &lt;rpc&#8209;reply&gt; contains a single &lt;ok/&gt; element defined in
<xref target="RFC4741"/>.  If output parameters are returned, they are encoded as
child elements to the &lt;rpc&#8209;reply&gt; element defined in <xref target="RFC4741"/>, in the
same order as they are defined within the &quot;output&quot; statement.
    </t>
</section>
<section title="Usage Example">
    <t>
The following example defines an RPC operation:
    </t>
	<figure>
	    <artwork><![CDATA[
  module rock {
      namespace "http://example.net/rock";
      prefix "rock";

      rpc rock-the-house {
          input {
              leaf zip-code {
                  type string;
              }
          }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
A corresponding XML instance example of the complete rpc and rpc-reply:
    </t>
	<figure>
	    <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <rock-the-house xmlns="http://example.net/rock">
      <zip-code>27606-0100</zip-code>
    </rock-the-house>
  </rpc>

  <rpc-reply message-id="101"
             xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The notification Statement" anchor="notification">
    <t>
The &quot;notification&quot; statement is used to define a NETCONF notification.
It takes one argument, which is an identifier, followed by a block of
substatements that holds detailed notification information.  The
&quot;notification&quot; statement defines a notification node in the schema
tree.
    </t>
    <t>
If a leaf in the notification tree has a &quot;mandatory&quot; statement with
the value &quot;true&quot;, the leaf MUST be present in a NETCONF notification.
    </t>
    <t>
If a leaf in the notification tree has a default value, the NETCONF client
MUST use this value in the same cases as described in
<xref target="leaf-default-value"/>.  In these cases, the client MUST operationally
behave as if the leaf was present in the NETCONF notification with
the default value as its value.
    </t>
    <t>
If a &quot;config&quot; statement is present for any node in the notification
tree, the &quot;config&quot; statement is ignored.
    </t>
<section title="The notification&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>anyxml</c>
<c><xref format="counter" target="anyxml"/></c>
<c>0..n</c>
<c>choice</c>
<c><xref format="counter" target="choice"/></c>
<c>0..n</c>
<c>container</c>
<c><xref format="counter" target="container"/></c>
<c>0..n</c>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>grouping</c>
<c><xref format="counter" target="grouping"/></c>
<c>0..n</c>
<c>if-feature</c>
<c><xref format="counter" target="if-feature"/></c>
<c>0..n</c>
<c>leaf</c>
<c><xref format="counter" target="leaf"/></c>
<c>0..n</c>
<c>leaf-list</c>
<c><xref format="counter" target="leaf-list"/></c>
<c>0..n</c>
<c>list</c>
<c><xref format="counter" target="list"/></c>
<c>0..n</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
<c>typedef</c>
<c><xref format="counter" target="typedef"/></c>
<c>0..n</c>
<c>uses</c>
<c><xref format="counter" target="uses"/></c>
<c>0..n</c>
</texttable>
<?rfc compact="no"?></section>
<section title="XML Mapping Rules">
    <t>
A notification node is encoded as a child XML element to the
&lt;notification&gt; element defined in NETCONF Event Notifications
<xref target="RFC5277"/>.  The element&apos;s local name is the notification&apos;s identifier, and
its namespace is the module&apos;s XML namespace (see <xref target="namespace"/>).
    </t>
</section>
<section title="Usage Example">
    <t>
The following example defines a notification:
    </t>
	<figure>
	    <artwork><![CDATA[
  module event {

      namespace "http://example.com/event";
      prefix "ev";

      notification event {
          leaf event-class {
              type string;
          }
          anyxml reporting-entity;
          leaf severity {
              type string;
          }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
A corresponding XML instance example of the complete notification:
    </t>
	<figure>
	    <artwork><![CDATA[
  <notification
    xmlns="urn:ietf:params:xml:ns:netconf:notification:1.0">
    <eventTime>2008-07-08T00:01:00Z</eventTime>
    <event xmlns="http://example.com/event">
      <event-class>fault</event-class>
      <reporting-entity>
        <card>Ethernet0</card>
      </reporting-entity>
      <severity>major</severity>
    </event>
  </notification>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The augment Statement" anchor="augment">
    <t>
The &quot;augment&quot; statement allows a module or submodule to add to the
schema tree defined in an external module, or the current module and
its submodules, and to add to the nodes from a grouping in a &quot;uses&quot;
statement.  The argument is a string that identifies a node in the
schema tree.  This node is called the augment&apos;s target node.  The
target node MUST be either a container, list, choice, case, input,
output, or notification node.  It is augmented with the nodes defined
in the substatements that follow the &quot;augment&quot; statement.
    </t>
    <t>
The argument string is a schema node identifier (see
<xref target="schema-node-id"/>).  If the &quot;augment&quot; statement is on
the top level in
a module or submodule, the absolute form (defined by the rule
&quot;absolute&#8209;schema&#8209;nodeid&quot; in <xref target="grammar"/>) of a schema node identifier
MUST be used.  If the &quot;augment&quot; statement is a substatement to the
&quot;uses&quot; statement, the descendant form (defined by the rule
&quot;descendant&#8209;schema&#8209;nodeid&quot; in <xref target="grammar"/>) MUST be used.
    </t>
    <t>
If the target node is a container, list, case, input, output, or
notification node, the &quot;container&quot;, &quot;leaf&quot;, &quot;list&quot;, &quot;leaf&#8209;list&quot;,
&quot;uses&quot;, and &quot;choice&quot; statements can be used within the &quot;augment&quot;
statement.
    </t>
    <t>
If the target node is a choice node, the &quot;case&quot; statement, or a case
shorthand statement (see <xref target="case"/>) can be used within the &quot;augment&quot;
statement.
    </t>
    <t>
If the target node is in another module, then nodes added by the
augmentation MUST NOT be mandatory nodes (see <xref target="mandatory-nodes"/>).
    </t>
    <t>
The &quot;augment&quot; statement MUST NOT add multiple nodes with the same name
from the same module to the target node.
    </t>
<section title="The augment&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>anyxml</c>
<c><xref format="counter" target="anyxml"/></c>
<c>0..n</c>
<c>case</c>
<c><xref format="counter" target="case"/></c>
<c>0..n</c>
<c>choice</c>
<c><xref format="counter" target="choice"/></c>
<c>0..n</c>
<c>container</c>
<c><xref format="counter" target="container"/></c>
<c>0..n</c>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>if-feature</c>
<c><xref format="counter" target="if-feature"/></c>
<c>0..n</c>
<c>leaf</c>
<c><xref format="counter" target="leaf"/></c>
<c>0..n</c>
<c>leaf-list</c>
<c><xref format="counter" target="leaf-list"/></c>
<c>0..n</c>
<c>list</c>
<c><xref format="counter" target="list"/></c>
<c>0..n</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
<c>uses</c>
<c><xref format="counter" target="uses"/></c>
<c>0..n</c>
<c>when</c>
<c><xref format="counter" target="when"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="XML Mapping Rules">
    <t>
All data nodes defined in the &quot;augment&quot; statement are defined as XML
elements in the XML namespace of the module where the &quot;augment&quot; is
specified.
    </t>
    <t>
When a node is augmented, the augmenting child nodes are encoded as
subelements to the augmented node, in any order.
    </t>
</section>
<section title="Usage Example">
    <t>
In namespace http://example.com/schema/interfaces, we have:
    </t>
	<figure>
	    <artwork><![CDATA[
  container interfaces {
      list ifEntry {
          key "ifIndex";

          leaf ifIndex {
              type uint32;
          }
          leaf ifDescr {
              type string;
          }
          leaf ifType {
              type iana:IfType;
          }
          leaf ifMtu {
              type int32;
          }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
Then, in namespace http://example.com/schema/ds0, we have:
    </t>
	<figure>
	    <artwork><![CDATA[
  import interface-module {
      prefix "if";
  }
  augment "/if:interfaces/if:ifEntry" {
      when "if:ifType='ds0'";
      leaf ds0ChannelNumber {
          type ChannelNumber;
      }
  }
	    ]]></artwork>
	</figure>
    <t>
A corresponding XML instance example:
    </t>
	<figure>
	    <artwork><![CDATA[
  <interfaces xmlns="http://example.com/schema/interfaces"
              xmlns:ds0="http://example.com/schema/ds0">
    <ifEntry>
      <ifIndex>1</ifIndex>
      <ifDescr>Flintstone Inc Ethernet A562</ifDescr>
      <ifType>ethernetCsmacd</ifType>
      <ifMtu>1500</ifMtu>
    </ifEntry>
    <ifEntry>
      <ifIndex>2</ifIndex>
      <ifDescr>Flintstone Inc DS0</ifDescr>
      <ifType>ds0</ifType>
      <ds0:ds0ChannelNumber>1</ds0:ds0ChannelNumber>
    </ifEntry>
  </interfaces>
	    ]]></artwork>
	</figure>
    <t>
As another example, suppose we have the choice defined in
<xref target="choice-example"/>.  The following construct can be used to extend the
protocol definition:
    </t>
	<figure>
	    <artwork><![CDATA[
  augment /ex:system/ex:protocol/ex:name {
      case c {
          leaf smtp {
              type empty;
          }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
A corresponding XML instance example:
    </t>
	<figure>
	    <artwork><![CDATA[
  <ex:system>
    <ex:protocol>
      <ex:tcp/>
    </ex:protocol>
  </ex:system>
	    ]]></artwork>
	</figure>
    <t>
or
    </t>
	<figure>
	    <artwork><![CDATA[
  <ex:system>
    <ex:protocol>
      <other:smtp/>
    </ex:protocol>
  </ex:system>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The identity Statement" anchor="identity">
    <t>
The &quot;identity&quot; statement is used to define a new globally unique,
abstract, and untyped identity.  Its only purpose is to denote its
name, semantics, and existence.  An identity can either be defined
from scratch or derived from a base identity.  The identity&apos;s argument
is an identifier that is the name of the identity.  It is followed by
a block of substatements that holds detailed identity information.
    </t>
    <t>
The built-in datatype &quot;identityref&quot; (see <xref target="identityref"/>) can be used to
reference identities within a data model.
    </t>
<section title="The identity&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>base</c>
<c><xref format="counter" target="base"/></c>
<c>0..1</c>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="The base Statement" anchor="base">
    <t>
The &quot;base&quot; statement, which is optional, takes as an argument a string
that is the name of an existing identity, from which the new identity
is derived.  If no &quot;base&quot; statement is present, the identity is defined
from scratch.
    </t>
    <t>
If a prefix is present on the base name, it refers to an identity
defined in the module that was imported with that prefix, or the local
module if the prefix matches the local module&apos;s prefix.  Otherwise, an
identity with the matching name MUST be defined in the current module
or an included submodule.
    </t>
    <t>
Since submodules cannot include the parent module, any identities in
the module that need to be exposed to submodules MUST be defined in a
submodule.  Submodules can then include this submodule to find the
definition of the identity.
    </t>
    <t>
An identity MUST NOT reference itself, neither directly nor indirectly
through a chain of other identities.
    </t>
</section>
<section title="Usage Example" anchor="identity-example">
	<figure>
	    <artwork><![CDATA[
  module crypto-base {
      namespace "http://example.com/crypto-base";
      prefix "crypto";

      identity crypto-alg {
          description
             "Base identity from which all crypto algorithms
              are derived.";
      }
  }

  module des {
      namespace "http://example.com/des";
      prefix "des";

      import "crypto-base" {
          prefix "crypto";
      }

      identity des {
          base "crypto:crypto-alg";
          description "DES crypto algorithm";
      }

      identity des3 {
          base "crypto:crypto-alg";
          description "Triple DES crypto algorithm";
      }
  }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The extension Statement" anchor="extension">
    <t>
The &quot;extension&quot; statement allows the definition of new statements
within the YANG language.  This new statement definition can be
imported and used by other modules.
    </t>
    <t>
The statement&apos;s argument is an identifier that is the new keyword for
the extension and must be followed by a block of substatements that
holds detailed extension information.  The purpose of the &quot;extension&quot;
statement is to define a keyword, so that it can be imported and used
by other modules.
    </t>
    <t>
The extension can be used like a normal YANG statement, with the
statement name followed by an argument if one is defined by the
extension, and an optional block of substatements.  The statement&apos;s
name is created by combining the prefix of the module in which the
extension was defined, a colon (&quot;:&quot;), and the extension&apos;s keyword,
with no interleaving whitespace.  The substatements of an extension
are defined by the extension, using some mechanism outside the scope
of this specification.  Syntactically, the substatements MUST be YANG
statements, or also defined using &quot;extension&quot; statements.  YANG
statements in extensions MUST follow the syntactical rules in
<xref target="grammar"/>.
    </t>
<section title="The extension&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>argument</c>
<c><xref format="counter" target="extension-arg"/></c>
<c>0..1</c>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="The argument Statement" anchor="extension-arg">
    <t>
The &quot;argument&quot; statement, which is optional, takes as an argument a
string that is the name of the argument to the keyword.  If no
argument statement is present, the keyword expects no argument when it
is used.
    </t>
    <t>
The argument&apos;s name is used in the YIN mapping, where it is used as an
XML attribute or element name, depending on the argument&apos;s &quot;yin-element&quot; statement.
    </t>
<section title="The argument&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>yin-element</c>
<c><xref format="counter" target="yin-element"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="The yin-element Statement" anchor="yin-element">
    <t>
The &quot;yin&#8209;element&quot; statement, which is optional, takes as an argument
the string &quot;true&quot; or &quot;false&quot;.  This statement indicates if the
argument is mapped to an XML element in YIN or to an XML
attribute (see <xref target="YIN"/>).
    </t>
    <t>
If no &quot;yin&#8209;element&quot; statement is present, it defaults to &quot;false&quot;.
    </t>
</section>
</section>
<section title="Usage Example" anchor="extension-example">
    <t>
To define an extension:
    </t>
	<figure>
	    <artwork><![CDATA[
  module my-extensions {
    ...

    extension c-define {
      description
        "Takes as argument a name string.
        Makes the code generator use the given name in the
        #define.";
      argument "name";
    }
  }
	    ]]></artwork>
	</figure>
    <t>
To use the extension:
    </t>
	<figure>
	    <artwork><![CDATA[
  module my-interfaces {
    ...
    import my-extensions {
      prefix "myext";
    }
    ...

    container interfaces {
      ...
      myext:c-define "MY_INTERFACES";
    }
  }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Conformance-Related Statements" anchor="conformance-stmts">
    <t>
This section defines statements related to conformance, as described
in <xref target="conformance"/>.
    </t>
<section title="The feature Statement" anchor="feature">
    <t>
The &quot;feature&quot; statement is used to define a mechanism by which
portions of the schema are marked as conditional.  A feature name is
defined that can later be referenced using the &quot;if&#8209;feature&quot; statement
(see <xref target="if-feature"/>).  Schema nodes tagged with a feature are ignored by
the device unless the device supports the given feature.  This allows
portions of the YANG module to be conditional based on conditions on
the device.  The model can represent the abilities of the device
within the model, giving a richer model that allows for differing
device abilities and roles.
    </t>
    <t>
The argument to the &quot;feature&quot; statement is the name of the new
feature, and follows the rules for identifiers in <xref target="identifiers"/>.  This
name is used by the &quot;if&#8209;feature&quot; statement to tie the schema nodes to
the feature.
    </t>
    <t>
In this example, a feature called &quot;local&#8209;storage&quot; represents the
ability for a device to store syslog messages on local storage of some
sort.  This feature is used to make the &quot;local&#8209;storage&#8209;limit&quot; leaf
conditional on the presence of some sort of local storage.  If the
device does not report that it supports this feature, the
&quot;local&#8209;storage&#8209;limit&quot; node is not supported.
    </t>
	<figure>
	    <artwork><![CDATA[
  module syslog {
      ...
      feature local-storage {
          description
              "This feature means the device supports local
               storage (memory, flash or disk) that can be used to
               store syslog messages.";
      }

      container syslog {
          leaf local-storage-limit {
              if-feature local-storage;
              type uint64;
              units "kilobyte";
              config false;
              description
                  "The amount of local storage that can be
                   used to hold syslog messages.";
          }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
The &quot;if&#8209;feature&quot; statement can be used in many places within the YANG
syntax.  Definitions tagged with &quot;if&#8209;feature&quot; are ignored when the
device does not support that feature.
    </t>
    <t>
A feature MUST NOT reference itself, neither directly nor indirectly
through a chain of other features.
    </t>
    <t>
In order for a device to implement a feature that is dependent on any
other features (i.e., the feature has one or more &quot;if&#8209;feature&quot;
sub-statements), the device MUST also implement all the dependant
features.
    </t>
<section title="The feature&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>if-feature</c>
<c><xref format="counter" target="if-feature"/></c>
<c>0..n</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
</section>
<section title="The if-feature Statement" anchor="if-feature">
    <t>
The &quot;if&#8209;feature&quot; statement makes its parent statement conditional.
The argument is the name of a feature, as defined by a &quot;feature&quot;
statement.  The parent statement is implemented by servers that
support this feature.  If a prefix is present on the feature name, it
refers to a feature defined in the module that was imported with that
prefix, or the local module if the prefix matches the local module&apos;s
prefix.  Otherwise, a feature with the matching name MUST be defined in
the current module or an included submodule.
    </t>
    <t>
Since submodules cannot include the parent module, any features in the
module that need to be exposed to submodules MUST be defined in a
submodule.  Submodules can then include this submodule to find the
definition of the feature.
    </t>
</section>
<section title="The deviation Statement" anchor="deviation">
    <t>
The &quot;deviation&quot; statement defines a hierarchy of a module that the
device does not implement faithfully.  The argument is a string that
identifies the node in the schema tree where a deviation from the
module occurs.  This node is called the deviation&apos;s target node.  The
contents of the &quot;deviation&quot; statement give details about the deviation.
    </t>
    <t>
The argument string is an absolute schema node identifier (see
<xref target="schema-node-id"/>).
    </t>
    <t>
Deviations define the way a device or class of devices deviate from
a standard.  This means that deviations MUST never be part of a
published standard, since they are the mechanism for learning how
implementations vary from the standards.
    </t>
    <t>
Device deviations are strongly discouraged and MUST only be used as a
last resort.  Telling the application how a device fails to follow a
standard is no substitute for implementing the standard correctly.  A
device that deviates from a module is not fully compliant with the
module.
    </t>
    <t>
However, in some cases, a particular device may not have the hardware or
software ability to support parts of a standard module.  When this
occurs, the device makes a choice either to treat attempts to configure
unsupported parts of the module as an error that is reported
back to the unsuspecting application or ignore those incoming
requests.  Neither choice is acceptable.
    </t>
    <t>
Instead, YANG allows devices to document portions of a base module
that are not supported or supported but with different syntax, by
using the &quot;deviation&quot; statement.
    </t>
<section title="The deviation&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>deviate</c>
<c><xref format="counter" target="deviate"/></c>
<c>1..n</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="The deviate Statement" anchor="deviate">
    <t>
The &quot;deviate&quot; statement defines how the device&apos;s implementation of the
target node deviates from its original definition.  The argument is
one of the strings &quot;not&#8209;supported&quot;, &quot;add&quot;, &quot;replace&quot;, or &quot;delete&quot;.
    </t>
    <t>
The argument &quot;not&#8209;supported&quot; indicates that the target node is not
implemented by this device.
    </t>
    <t>
  The argument &quot;add&quot; adds properties to the target node.  The
  properties to add are identified by substatements to the &quot;deviate&quot;
  statement.  If a property can only appear once, the property MUST
  NOT exist in the target node.
    </t>
    <t>
  The argument &quot;replace&quot; replaces properties of the target node.  The
  properties to replace are identified by substatements to the
  &quot;deviate&quot; statement.  The properties to replace MUST exist in the
  target node.
    </t>
    <t>
  The argument &quot;delete&quot; deletes properties from the target node.  The
  properties to delete are identified by substatements to the &quot;delete&quot;
  statement.  The substatement's keyword MUST match a corresponding
  keyword in the target node, and the argument's string MUST be equal
  to the corresponding keyword's argument string in the target node.
    </t>
<?rfc compact="yes"?><texttable>
<preamble>The deviates&apos;s Substatements</preamble>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>config</c>
<c><xref format="counter" target="config"/></c>
<c>0..1</c>
<c>default</c>
<c><xref format="counter" target="leaf-default"/></c>
<c>0..1</c>
<c>mandatory</c>
<c><xref format="counter" target="mandatory"/></c>
<c>0..1</c>
<c>max-elements</c>
<c><xref format="counter" target="max-elements"/></c>
<c>0..1</c>
<c>min-elements</c>
<c><xref format="counter" target="min-elements"/></c>
<c>0..1</c>
<c>must</c>
<c><xref format="counter" target="must"/></c>
<c>0..n</c>
<c>type</c>
<c><xref format="counter" target="type"/></c>
<c>0..1</c>
<c>unique</c>
<c><xref format="counter" target="unique"/></c>
<c>0..n</c>
<c>units</c>
<c><xref format="counter" target="units"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="Usage Example">
    <t>
In this example, the device is informing client applications that it
does not support the &quot;daytime&quot; service in the style of RFC 867.
    </t>
	<figure>
	    <artwork><![CDATA[
  deviation /base:system/base:daytime {
      deviate not-supported;
  }
	    ]]></artwork>
	</figure>
    <t>
The following example sets a device-specific default value to a leaf
that does not have a default value defined:
    </t>
	<figure>
	    <artwork><![CDATA[
  deviation /base:system/base:user/base:type {
      deviate add {
          default "admin"; // new users are 'admin' by default
      }
  }
	    ]]></artwork>
	</figure>
    <t>
In this example, the device limits the number of name servers to 3:
    </t>
	<figure>
	    <artwork><![CDATA[
  deviation /base:system/base:name-server {
      deviate replace {
          max-elements 3;
      }
  }
	    ]]></artwork>
	</figure>
    <t>
If the original definition is:
    </t>
	<figure>
	    <artwork><![CDATA[
  container system {
      must "daytime or time";
      ...
  }
	    ]]></artwork>
	</figure>
    <t>
a device might remove this must constraint by doing:
    </t>
	<figure>
	    <artwork><![CDATA[
  deviation "/base:system" {
      deviate delete {
          must "daytime or time";
      }
  }
	    ]]></artwork>
	</figure>
</section>
</section>
</section>
<section title="Common Statements">
    <t>
This section defines substatements common to several other
statements.
    </t>
<section title="The config Statement" anchor="config">
    <t>
The &quot;config&quot; statement takes as an argument the string &quot;true&quot; or
&quot;false&quot;.  If &quot;config&quot; is &quot;true&quot;, the definition represents
configuration.  Data nodes representing configuration will be part of
the reply to a &lt;get&#8209;config&gt; request, and can be sent in a
&lt;copy&#8209;config&gt; or &lt;edit&#8209;config&gt; request.
    </t>
    <t>
If &quot;config&quot; is &quot;false&quot;, the definition represents state data.  Data
nodes representing state data will be part of the reply to a &lt;get&gt;,
but not to a &lt;get&#8209;config&gt; request, and cannot be sent in a
&lt;copy&#8209;config&gt; or &lt;edit&#8209;config&gt; request.
    </t>
    <t>
If &quot;config&quot; is not specified, the default is the same as the parent
schema node&apos;s &quot;config&quot; value.  If the parent node is a &quot;case&quot; node,
the value is the same as the &quot;case&quot; node&apos;s parent &quot;choice&quot; node.
    </t>
    <t>
If the top node does not specify a &quot;config&quot; statement, the default is
&quot;true&quot;.
    </t>
    <t>
If a node has &quot;config&quot; set to &quot;false&quot;, no node underneath it can have
&quot;config&quot; set to &quot;true&quot;.
    </t>
</section>
<section title="The status Statement" anchor="status">
    <t>
The &quot;status&quot; statement takes as an argument one of the strings &quot;current&quot;,
&quot;deprecated&quot;, or &quot;obsolete&quot;.
    </t>
<t>
 <list style="symbols">
 <t>
&quot;current&quot; means that the definition is current and valid.
 </t>
 <t>
&quot;deprecated&quot; indicates an obsolete definition, but it permits
new/continued implementation in order to foster
interoperability with older/existing implementations.
 </t>
 <t>
&quot;obsolete&quot; means the definition is obsolete and SHOULD NOT be
implemented and/or can be removed from implementations.
 </t>
 </list>
</t>
    <t>
If no status is specified, the default is &quot;current&quot;.
    </t>
    <t>
If a definition is &quot;current&quot;, it MUST NOT reference a &quot;deprecated&quot; or
&quot;obsolete&quot; definition within the same module.
    </t>
    <t>
If a definition is &quot;deprecated&quot;, it MUST NOT reference an &quot;obsolete&quot;
definition within the same module.
    </t>
    <t>
For example, the following is illegal:
    </t>
	<figure>
	    <artwork><![CDATA[
  typedef my-type {
    status deprecated;
    type int32;
  }

  leaf my-leaf {
    status current;
    type my-type; // illegal, since my-type is deprecated
  }
	    ]]></artwork>
	</figure>
</section>
<section title="The description Statement" anchor="description">
    <t>
The &quot;description&quot; statement takes as an argument a string that
contains a human-readable textual description of this definition.  The
text is provided in a language (or languages) chosen by the module
developer; for the sake of interoperability, it is RECOMMENDED to
choose a language that is widely understood among the community of
network administrators who will use the module.
    </t>
</section>
<section title="The reference Statement" anchor="reference">
    <t>
The &quot;reference&quot; statement takes as an argument a string that is used
to specify a textual cross-reference to an external document, either
another module that defines related management information, or a
document that provides additional information relevant to this
definition.
    </t>
    <t>
For example, a typedef for a &quot;uri&quot; data type could look like:
    </t>
	<figure>
	    <artwork><![CDATA[
  typedef uri {
    type string;
    reference
      "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax";
    ...
  }
	    ]]></artwork>
	</figure>
</section>
<section title="The when Statement" anchor="when">
    <t>
The &quot;when&quot; statement makes its parent data definition statement
conditional.  The node defined by the parent data definition statement
is only valid when the condition specified by the &quot;when&quot; statement is
satisfied.  The statement&apos;s argument is an XPath expression (see
<xref target="xpath"/>), which is used to formally specify this condition. If the
XPath expression conceptually evaluates to &quot;true&quot; for a particular
instance, then the node defined by the parent data definition
statement is valid; otherwise, it is not.
    </t>
    <t>
See <xref target="edit-config-processing"/> for additional information.
    </t>
    <t>
The XPath expression is conceptually evaluated in the following
context, in addition to the definition in <xref target="xpath-context"/>:
    </t>
<t>
 <list style="symbols">
 <t>
If the &quot;when&quot; statement is a child of an &quot;augment&quot; statement, then
the context node is the augment&apos;s target node in the data tree, if
the target node is a data node.  Otherwise, the context node is the
closest ancestor node to the target node that is also a data node.
 </t>
 <t>
If the &quot;when&quot; statement is a child of a &quot;uses&quot;, &quot;choice&quot;, or &quot;case&quot;
statement, then the context node is the closest ancestor node to the
&quot;uses&quot;, &quot;choice&quot;, or &quot;case&quot; node that is also a data node.
 </t>
 <t>
If the &quot;when&quot; statement is a child of any other data definition
statement, the context node is the data definition&apos;s node in the
data tree.
 </t>
 <t>
The accessible tree is made up of all nodes in the data tree, and
all leafs with default values in use (see <xref target="leaf-default-value"/>).
 </t>
 </list>
</t>
    <t>
The accessible tree depends on the context node:
    </t>
<t>
 <list style="symbols">
 <t>
If the context node represents configuration, the tree is the data
in the NETCONF datastore where the context node exists.  The XPath
root node has all top-level configuration data nodes in all modules
as children.
 </t>
 <t>
If the context node represents state data, the tree is
all state data on the device, and the &lt;running/&gt; datastore.
The XPath root node has all top-level data nodes in all modules as
children.
 </t>
 <t>
If the context node represents notification content, the tree is the
notification XML instance document.  The XPath root node has the
element representing the notification being defined as the only
child.
 </t>
 <t>
If the context node represents RPC input parameters, the tree is the
RPC XML instance document.  The XPath root node has the
element representing the RPC operation being defined as the only
child.
 </t>
 <t>
If the context node represents RPC output parameters, the tree is
the RPC reply instance document.  The XPath root node has the
elements representing the RPC output parameters as children.
 </t>
 </list>
</t>
    <t>
The result of the XPath expression is converted to a boolean value
using the standard XPath rules.
    </t>
    <t>
Note that the XPath expression is conceptually evaluated.  This means
that an implementation does not have to use an XPath evaluator on the
device.  The &quot;when&quot; statement can very well be implemented with
specially written code.
    </t>
</section>
</section>
</section>
<section title="Constraints" anchor="constraints">
<section title="Constraints on Data">
    <t>
Several YANG statements define constraints on valid data.  These
constraints are enforced in different ways, depending on what type of
data the statement defines.
    </t>
<t>
 <list style="symbols">
 <t>
If the constraint is defined on configuration data, it MUST be true in
a valid configuration data tree.
 </t>
 <t>
If the constraint is defined on state data, it MUST be true in a reply
to a &lt;get&gt; operation without a filter.
 </t>
 <t>
If the constraint is defined on notification content, it MUST be true
in any notification instance.
 </t>
 <t>
If the constraint is defined on RPC input parameters, it MUST be true
in an invocation of the RPC operation.
 </t>
 <t>
If the constraint is defined on RPC output parameters, it MUST be true
in the RPC reply.
 </t>
 </list>
</t>
</section>
<section title="Hierarchy of Constraints">
    <t>
Conditions on parent nodes affect constraints on child nodes as a
natural consequence of the hierarchy of nodes.  &quot;must&quot;, &quot;mandatory&quot;,
&quot;min&#8209;elements&quot;, and &quot;max&#8209;elements&quot; constraints are not enforced if the
parent node has a &quot;when&quot; or &quot;if&#8209;feature&quot; property that is not
satisfied on the current device.
    </t>
    <t>
In this example, the &quot;mandatory&quot; constraint on the &quot;longitude&quot; leaf are
not enforced on devices that lack the &quot;has&#8209;gps&quot; feature:
    </t>
	<figure>
	    <artwork><![CDATA[
    container location {
        if-feature has-gps;
        leaf longitude {
            mandatory true;
            ...
        }
    }
	    ]]></artwork>
	</figure>
</section>
<section title="Constraint Enforcement Model">
    <t>
For configuration data, there are three windows when constraints MUST
be enforced:
    </t>
<t>
 <list style="symbols">
 <t>
during parsing of RPC payloads
 </t>
 <t>
during processing of NETCONF operations
 </t>
 <t>
during validation
 </t>
 </list>
</t>
    <t>
Each of these scenarios is considered in the following sections.
    </t>
<section title="Payload Parsing" anchor="payload-parsing">
    <t>
When content arrives in RPC payloads, it MUST be well-formed XML,
following the hierarchy and content rules defined by the set of models
the device implements.
    </t>
<t>
 <list style="symbols">
 <t>
If a leaf data value does not match the type constraints for the
leaf, including those defined in the type&apos;s &quot;range&quot;, &quot;length&quot;, and
&quot;pattern&quot; properties, the server MUST reply with an &quot;invalid&#8209;value&quot;
error-tag in the rpc-error, and with the error-app-tag and
error-message associated with the constraint, if any exist.
 </t>
 <t>
If all keys of a list entry are not present, the server MUST reply
with a &quot;missing&#8209;element&quot; error-tag in the rpc-error.
 </t>
 <t>
If data for more than one case branch of a choice is present, the
server MUST reply with a &quot;bad&#8209;element&quot; in the rpc-error.
 </t>
 <t>
If data for a node tagged with &quot;if&#8209;feature&quot; is present, and the
feature is not supported by the device, the server MUST reply with an
&quot;unknown&#8209;element&quot; error-tag in the rpc-error.
 </t>
 <t>
If data for a node tagged with &quot;when&quot; is present, and the &quot;when&quot;
condition evaluates to &quot;false&quot;, the server MUST reply with an
&quot;unknown&#8209;element&quot; error-tag in the rpc-error.
 </t>
 <t>
For insert handling, if the value for the attributes &quot;before&quot; and
&quot;after&quot; are not valid for the type of the appropriate key leafs, the
server MUST reply with a &quot;bad&#8209;attribute&quot; error-tag in the rpc-error.
 </t>
 <t>
If the attributes &quot;before&quot; and &quot;after&quot; appears in any element that
is not a list whose &quot;ordered&#8209;by&quot; property is &quot;user&quot;, the server
MUST reply with an &quot;unknown&#8209;attribute&quot; error-tag in the rpc-error.
 </t>
 </list>
</t>
</section>
<section title="NETCONF &lt;edit&#8209;config&gt; Processing" anchor="edit-config-processing">
    <t>
After the incoming data is parsed, the NETCONF server performs the
&lt;edit&#8209;config&gt; operation by applying the data to the configuration
datastore.  During this processing, the following errors MUST be
detected:
    </t>
<t>
 <list style="symbols">
 <t>
Delete requests for non-existent data.
 </t>
 <t>
Create requests for existent data.
 </t>
 <t>
Insert requests with &quot;before&quot; or &quot;after&quot; parameters that do not
exist.
 </t>
 </list>
</t>
    <t>
During &lt;edit&#8209;config&gt; processing:
    </t>
<t>
 <list style="symbols">
 <t>
If the NETCONF operation creates data nodes under a &quot;choice&quot;, any
existing nodes from other &quot;case&quot; branches are deleted by the server.
 </t>
 <t>
If the NETCONF operation modifies a data node such that any node&apos;s
&quot;when&quot; expression becomes false, then the node with the &quot;when&quot;
expression is deleted by the server.
 </t>
 </list>
</t>
</section>
<section title="Validation" anchor="validation">
    <t>
When datastore processing is complete, the final contents MUST obey
all validation constraints.  This validation processing is performed
at differing times according to the datastore.  If the datastore is
&lt;running/&gt; or &lt;startup/&gt;, these constraints MUST be enforced at the
end of the &lt;edit&#8209;config&gt; or &lt;copy&#8209;config&gt; operation.  If the datastore
is &lt;candidate/&gt;, the constraint enforcement is delayed until a &lt;commit&gt;
or &lt;validate&gt; operation.
    </t>
<t>
 <list style="symbols">
 <t>
Any &quot;must&quot; constraints MUST evaluate to &quot;true&quot;.
 </t>
 <t>
Any referential integrity constraints defined via the &quot;path&quot;
statement MUST be satisfied.
 </t>
 <t>
Any &quot;unique&quot; constraints on lists MUST be satisfied.
 </t>
 <t>
The &quot;min&#8209;elements&quot; and &quot;max&#8209;elements&quot; constraints are enforced for
lists and leaf-lists.
 </t>
 </list>
</t>
</section>
</section>
</section>
<section title="Built-In Types" anchor="built-in">
    <t>
YANG has a set of built-in types, similar to those of many programming
languages, but with some differences due to special requirements from
the management information model.  
    </t>
    <t>
Additional types may be defined, derived from those built-in types or
from other derived types.  Derived types may use subtyping to formally
restrict the set of possible values.
    </t>
    <t>
The different built-in types and their derived types allow different kinds
of subtyping, namely length and regular expression restrictions of
strings (Sections <xref target="length" format="counter"/> and <xref target="pattern" format="counter"/>) and range restrictions of numeric types
(<xref target="range"/>).
    </t>
    <t>
The lexical representation of a value of a certain type is used
in the NETCONF messages and when specifying default values
and numerical ranges in YANG modules.
    </t>
<section title="Canonical Representation" anchor="canonical">
    <t>
For most types, there is a single canonical representation of the
type&apos;s values.  Some types allow multiple lexical representations of
the same value, for example, the positive integer &quot;17&quot; can be
represented as &quot;+17&quot; or &quot;17&quot;.  Implementations MUST support all
lexical representations specified in this document.
    </t>
    <t>
When a NETCONF server sends data, it MUST be in the canonical form.
    </t>
    <t>
Some types have a lexical representation that depends on the XML
context in which they occur.  These types do not have a canonical
form.
    </t>
</section>
<section title="The Integer Built-In Types">
    <t>
The integer built-in types are int8, int16, int32, int64, uint8, uint16,
uint32, and uint64.  They represent signed and unsigned integers of
different sizes:
    </t>
<t>
 <list style="hanging">
	<t hangText="int8">
represents integer values between -128 and 127, inclusively.
 </t>
	<t hangText="int16">
represents integer values between -32768 and 32767, inclusively.
 </t>
	<t hangText="int32">
represents integer values between -2147483648 and 2147483647, inclusively.
 </t>
	<t hangText="int64">
represents integer values between -9223372036854775808 and
9223372036854775807, inclusively.
 </t>
	<t hangText="uint8">
represents integer values between 0 and 255, inclusively.
 </t>
	<t hangText="uint16">
represents integer values between 0 and 65535, inclusively.
 </t>
	<t hangText="uint32">
represents integer values between 0 and 4294967295, inclusively.
 </t>
	<t hangText="uint64">
represents integer values between 0 and 18446744073709551615, inclusively.
 </t>
 </list>
</t>
<section title="Lexical Representation">
    <t>
An integer value is lexically represented as an optional sign
(&quot;+&quot; or &quot;&#8209;&quot;), followed by a sequence of decimal digits.  If no sign is
specified, &quot;+&quot; is assumed.
    </t>
    <t>
For convenience, when specifying a default value for an integer in a
YANG module, an alternative lexical representation can be used,
which represents the value in a hexadecimal or octal notation.  The
hexadecimal notation consists of an optional sign (&quot;+&quot; or &quot;&#8209;&quot;), the
characters &quot;0x&quot; followed a number of hexadecimal digits, where letters
may be uppercase or lowercase.  The octal notation consists of an
optional sign (&quot;+&quot; or &quot;&#8209;&quot;), the character &quot;0&quot; followed a number of
octal digits.
    </t>
    <t>
Note that if a default value in a YANG module has a leading zero
(&quot;0&quot;), it is interpreted as an octal number.  In the XML instance
documents, an integer is always interpreted as a decimal number, and
leading zeros are allowed.
    </t>
    <t>
Examples:
    </t>
	<figure>
	    <artwork><![CDATA[
  // legal values
  +4711                       // legal positive value
  4711                        // legal positive value
  -123                        // legal negative value
  0xf00f                      // legal positive hexadecimal value
  -0xf                        // legal negative hexadecimal value
  052                         // legal positive octal value

  // illegal values
  - 1                         // illegal intermediate space
	    ]]></artwork>
	</figure>
</section>
<section title="Canonical Form">
    <t>
The canonical form of a positive integer does not include the sign
&quot;+&quot;.  Leading zeros are prohibited.  The value zero is represented as
&quot;0&quot;.
    </t>
</section>
<section title="Restrictions">
    <t>
All integer types can be restricted with the &quot;range&quot; statement (<xref target="range"/>).
    </t>
</section>
<section title="The range Statement" anchor="range">
    <t>
The &quot;range&quot; statement, which is an optional substatement to the &quot;type&quot;
statement, takes as an argument a range expression string.  It is used
to restrict integer and decimal built-in types, or types
derived from those.
    </t>
    <t>
A range consists of an explicit value, or a lower-inclusive bound, two
consecutive dots &quot;..&quot;, and an upper-inclusive bound.  Multiple values
or ranges can be given, separated by &quot;|&quot;.  If multiple values or
ranges are given, they all MUST be disjoint and MUST be in ascending
order.  If a range restriction is applied to an already range-restricted
type, the new restriction MUST be equal or more limiting, that is
raising the lower bounds, reducing the upper bounds, removing explicit
values or ranges, or splitting ranges into multiple ranges with
intermediate gaps.  Each explicit value and range boundary value given
in the range expression MUST match the type being restricted, or be
one of the special values &quot;min&quot; or &quot;max&quot;.  &quot;min&quot; and &quot;max&quot; mean the
minimum and maximum value accepted for the type being restricted,
respectively.
    </t>
    <t>
The range expression syntax is formally defined by the rule
&quot;range&#8209;arg&quot; in <xref target="grammar"/>.
    </t>
<section title="The range&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>error-app-tag</c>
<c><xref format="counter" target="error-app-tag"/></c>
<c>0..1</c>
<c>error-message</c>
<c><xref format="counter" target="error-message"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
</section>
<section title="Usage Example">
	<figure>
	    <artwork><![CDATA[
  typedef my-base-int32-type {
      type int32 {
          range "1..4 | 10..20";
      }
  }

  typedef my-type1 {
      type my-base-int32-type {
          // legal range restriction
          range "11..max"; // 11..20
      }
  }

  typedef my-type2 {
      type my-base-int32-type {
          // illegal range restriction
          range "11..100";
      }
  }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The decimal64 Built-In Type">
    <t>
The decimal64 type represents a subset of the real numbers, which can
be represented by decimal numerals.  The value space of decimal64 is
the set of numbers that can be obtained by multiplying a 64-bit signed
integer by a negative power of ten, i.e., expressible as
&quot;i&nbsp;x&nbsp;10^-n&quot; where i is an integer64 and n is an integer
between 1 and 18, inclusively.
    </t>
<section title="Lexical Representation">
    <t>
A decimal64 value is lexically represented as an optional sign
(&quot;+&quot; or &quot;&#8209;&quot;), followed by a sequence of decimal digits, optionally
followed by a period (&apos;.&apos;) as a decimal indicator and a sequence of
decimal digits.  If no sign is specified, &quot;+&quot; is assumed.
    </t>
</section>
<section title="Canonical Form">
    <t>
The canonical form of a positive decimal64 does not include the sign
&quot;+&quot;.  The decimal point is required.  Leading and trailing zeros are
prohibited, subject to the rule that there MUST be at least one digit
before and after the decimal point.  The value zero is represented as
&quot;0.0&quot;.
    </t>
</section>
<section title="Restrictions">
    <t>
A decimal64 type can be restricted with the &quot;range&quot; statement
(<xref target="range"/>).
    </t>
</section>
<section title="The fraction-digits Statement" anchor="fraction-digits">
    <t>
The &quot;fraction&#8209;digits&quot; statement, which is a substatement to the
&quot;type&quot; statement, MUST be present if the type is &quot;decimal64&quot;.  It
takes as an argument an integer between 1 and 18, inclusively.  It
controls the size of the minimum difference between values of a
decimal64 type, by restricting the value space to numbers that are
expressible as &quot;i&nbsp;x&nbsp;10^-n&quot; where n is the fraction-digits
argument.
    </t>
    <t>
The following table lists the minimum and maximum value for each
fraction-digit value:
    </t>
<?rfc compact="yes"?><texttable>
<ttcol align='left'> fraction-digit</ttcol>
<ttcol align='left'>min</ttcol>
<ttcol align='left'>max</ttcol>
<c>1</c>
<c>-922337203685477580.8</c>
<c>922337203685477580.7</c>
<c>2</c>
<c>-92233720368547758.08</c>
<c>92233720368547758.07</c>
<c>3</c>
<c>-9223372036854775.808</c>
<c>9223372036854775.807</c>
<c>4</c>
<c>-922337203685477.5808</c>
<c>922337203685477.5807</c>
<c>5</c>
<c>-92233720368547.75808</c>
<c>92233720368547.75807</c>
<c>6</c>
<c>-9223372036854.775808</c>
<c>9223372036854.775807</c>
<c>7</c>
<c>-922337203685.4775808</c>
<c>922337203685.4775807</c>
<c>8</c>
<c>-92233720368.54775808</c>
<c>92233720368.54775807</c>
<c>9</c>
<c>-9223372036.854775808</c>
<c>9223372036.854775807</c>
<c>10</c>
<c>-922337203.6854775808</c>
<c>922337203.6854775807</c>
<c>11</c>
<c>-92233720.36854775808</c>
<c>92233720.36854775807</c>
<c>12</c>
<c>-9223372.036854775808</c>
<c>9223372.036854775807</c>
<c>13</c>
<c>-922337.2036854775808</c>
<c>922337.2036854775807</c>
<c>14</c>
<c>-92233.72036854775808</c>
<c>92233.72036854775807</c>
<c>15</c>
<c>-9223.372036854775808</c>
<c>9223.372036854775807</c>
<c>16</c>
<c>-922.3372036854775808</c>
<c>922.3372036854775807</c>
<c>17</c>
<c>-92.23372036854775808</c>
<c>92.23372036854775807</c>
<c>18</c>
<c>-9.223372036854775808</c>
<c>9.223372036854775807</c>
</texttable>
<?rfc compact="no"?></section>
<section title="Usage Example">
	<figure>
	    <artwork><![CDATA[
  typedef my-decimal {
      type decimal64 {
          fraction-digits 2;
          range "1 .. 3.14 | 10 | 20..max";
      }
  }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The string Built-In Type">
    <t>
The string built-in type represents human-readable strings in YANG.  Legal
characters are tab, carriage return, line feed, and the legal
characters of Unicode and ISO/IEC 10646 <xref target="ISO.10646"/>:
    </t>
	<figure>
	    <artwork><![CDATA[
  ;; any Unicode character, excluding the surrogate blocks,
  ;; FFFE, and FFFF.
  string = *char
  char = %x9 / %xA / %xD / %x20-D7FF / %xE000-FFFD /
         %x10000-10FFFF
	    ]]></artwork>
	</figure>
<section title="Lexical Representation">
    <t>
A string value is lexically represented as character data in
the XML instance documents.
    </t>
</section>
<section title="Canonical Form">
    <t>
The canonical form is the same as the lexical representation.
No Unicode normalization is performed of string values.
    </t>
</section>
<section title="Restrictions">
    <t>
A string can be restricted with the &quot;length&quot; (<xref target="length"/>) and &quot;pattern&quot;
(<xref target="pattern"/>) statements.
    </t>
</section>
<section title="The length Statement" anchor="length">
    <t>
The &quot;length&quot; statement, which is an optional substatement to the
&quot;type&quot; statement, takes as an argument a length expression string.  It
is used to restrict the built-in type &quot;string&quot;, or types derived from
&quot;string&quot;.
    </t>
    <t>
A &quot;length&quot; statement restricts the number of Unicode characters in the
string.
    </t>
    <t>
A length range consists of an explicit value, or a lower bound, two
consecutive dots &quot;..&quot;, and an upper bound.  Multiple values or ranges
can be given, separated by &quot;|&quot;.  Length-restricting values MUST NOT be
negative.  If multiple values or ranges are given, they all MUST be
disjoint and MUST be in ascending order.  If a length restriction is
applied to an already length-restricted type, the new restriction MUST
be equal or more limiting, that is, raising the lower bounds, reducing
the upper bounds, removing explicit length values or ranges, or
splitting ranges into multiple ranges with intermediate gaps.  A
length value is a non-negative integer, or one of the special values
&quot;min&quot; or &quot;max&quot;.  &quot;min&quot; and &quot;max&quot; mean the minimum and maximum length
accepted for the type being restricted, respectively.  An
implementation is not required to support a length value larger than
18446744073709551615.
    </t>
    <t>
The length expression syntax is formally defined by the rule
&quot;length&#8209;arg&quot; in <xref target="grammar"/>.
    </t>
<section title="The length&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>error-app-tag</c>
<c><xref format="counter" target="error-app-tag"/></c>
<c>0..1</c>
<c>error-message</c>
<c><xref format="counter" target="error-message"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
</section>
<section title="Usage Example">
	<figure>
	    <artwork><![CDATA[
  typedef my-base-str-type {
      type string {
          length "1..255";
      }
  }

  type my-base-str-type {
      // legal length refinement
      length "11 | 42..max"; // 11 | 42..255
  }

  type my-base-str-type {
      // illegal length refinement
      length "1..999";
  }
	    ]]></artwork>
	</figure>
</section>
<section title="The pattern Statement" anchor="pattern">
    <t>
The &quot;pattern&quot; statement, which is an optional substatement to the
&quot;type&quot; statement, takes as an argument a regular expression string, as
defined in <xref target="XSD-TYPES"/>.   It is used to
restrict the built-in type &quot;string&quot;, or types derived from &quot;string&quot;,
to values that match the pattern.
    </t>
    <t>
If the type has multiple &quot;pattern&quot; statements, the expressions are
ANDed together, i.e., all such expressions have to match.
    </t>
    <t>
If a pattern restriction is applied to an already pattern-restricted
type, values must match all patterns in the base type, in addition to
the new patterns.
    </t>
<section title="The pattern&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>error-app-tag</c>
<c><xref format="counter" target="error-app-tag"/></c>
<c>0..1</c>
<c>error-message</c>
<c><xref format="counter" target="error-message"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
</section>
<section title="Usage Example">
    <t>
With the following type:
    </t>
	<figure>
	    <artwork><![CDATA[
  type string {
      length "0..4";
      pattern "[0-9a-fA-F]*";
  }
	    ]]></artwork>
	</figure>
    <t>
the following strings match:
    </t>
	<figure>
	    <artwork><![CDATA[
  AB          // legal
  9A00        // legal
	    ]]></artwork>
	</figure>
    <t>
and the following strings do not match:
    </t>
	<figure>
	    <artwork><![CDATA[
  00ABAB      // illegal, too long
  xx00        // illegal, bad characters
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The boolean Built-In Type">
    <t>
The boolean built-in type represents a boolean value.
    </t>
<section title="Lexical Representation">
    <t>
The lexical representation of a boolean value is a string with a value
of &quot;true&quot; or &quot;false&quot;. These values MUST be in lowercase.
    </t>
</section>
<section title="Canonical Form">
    <t>
The canonical form is the same as the lexical representation.
    </t>
</section>
<section title="Restrictions">
    <t>
A boolean cannot be restricted.
    </t>
</section>
</section>
<section title="The enumeration Built-In Type">
    <t>
The enumeration built-in type represents values from a set of assigned
names.
    </t>
<section title="Lexical Representation">
    <t>
The lexical representation of an enumeration value is the
assigned name string.
    </t>
</section>
<section title="Canonical Form">
    <t>
The canonical form is the assigned name string.
    </t>
</section>
<section title="Restrictions">
    <t>
An enumeration cannot be restricted.
    </t>
</section>
<section title="The enum Statement" anchor="enum">
    <t>
The &quot;enum&quot; statement, which is a substatement to the &quot;type&quot; statement,
MUST be present if the type is &quot;enumeration&quot;.  It is repeatedly used
to specify each assigned name of an enumeration type.  It takes as an
argument a string which is the assigned name.  The string MUST NOT
be empty and MUST NOT have any leading or trailing whitespace
characters.  The use of Unicode control codes SHOULD be avoided.
    </t>
    <t>
The statement is optionally followed by a block of substatements that
holds detailed enum information.
    </t>
    <t>
All assigned names in an enumeration MUST be unique.
    </t>
<section title="The enum&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
<c>value</c>
<c><xref format="counter" target="enum-value"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="The value Statement" anchor="enum-value">
    <t>
The &quot;value&quot; statement, which is optional, is used to associate an
integer value with the assigned name for the enum.  This integer value
MUST be in the range -2147483648 to 2147483647, and it MUST be unique
within the enumeration type.  The value is unused by YANG and the XML
encoding, but is carried as a convenience to implementors.
    </t>
    <t>
If a value is not specified, then one will be automatically
assigned.  If the &quot;enum&quot; substatement is the first one defined,
the assigned value is zero (0); otherwise, the assigned value
is one greater than the current highest enum value.
    </t>
    <t>
If the current highest value is equal to 2147483647,
then an enum value MUST be specified for &quot;enum&quot; substatements
following the one with the current highest value.
    </t>
</section>
</section>
<section title="Usage Example">
	<figure>
	    <artwork><![CDATA[
  leaf myenum {
      type enumeration {
          enum zero;
          enum one;
          enum seven {
              value 7;
          }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
The lexical representation of the leaf &quot;myenum&quot; with value
&quot;seven&quot; is:
    </t>
	<figure>
	    <artwork><![CDATA[
  <myenum>seven</myenum>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The bits Built-In Type">
    <t>
The bits built-in type represents a bit set.  That is, a bits value is
a set of flags identified by small integer position numbers starting
at 0.  Each bit number has an assigned name.
    </t>
<section title="Restrictions">
    <t>
A bits type cannot be restricted.
    </t>
</section>
<section title="Lexical Representation">
    <t>
The lexical representation of the bits type is a space-separated list of the individual bit values that are set.  An empty
string thus represents a value where no bits are set.
    </t>
</section>
<section title="Canonical Form">
    <t>
In the canonical form, the bit values are separated by a single space
character and they appear ordered by their position (see <xref target="position"/>).
    </t>
</section>
<section title="The bit Statement" anchor="bit">
    <t>
The &quot;bit&quot; statement, which is a substatement to the &quot;type&quot; statement,
MUST be present if the type is &quot;bits&quot;.  It is repeatedly used to
specify each assigned named bit of a bits type.  It takes as an
argument a string that is the assigned name of the bit.  It is
followed by a block of substatements that holds detailed bit
information.  The assigned name follows the same syntax rules as an
identifier (see <xref target="identifiers"/>).
    </t>
    <t>
All assigned names in a bits type MUST be unique.
    </t>
<section title="The bit&apos;s Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> substatement</ttcol>
<ttcol align='left'>section</ttcol>
<ttcol align='left'>cardinality</ttcol>
<c>description</c>
<c><xref format="counter" target="description"/></c>
<c>0..1</c>
<c>reference</c>
<c><xref format="counter" target="reference"/></c>
<c>0..1</c>
<c>status</c>
<c><xref format="counter" target="status"/></c>
<c>0..1</c>
<c>position</c>
<c><xref format="counter" target="position"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="The position Statement" anchor="position">
    <t>
The &quot;position&quot; statement, which is optional, takes as an argument
a non-negative integer value that specifies the bit&apos;s position within
a hypothetical bit field.  The position value MUST be
in the range 0 to 4294967295, and it MUST be unique within
the bits type.  The value is unused by YANG and the NETCONF messages, but
is carried as a convenience to implementors.
    </t>
    <t>
If a bit position is not specified, then one will be automatically
assigned.  If the &quot;bit&quot; substatement is the first one defined,
the assigned value is zero (0); otherwise, the assigned value
is one greater than the current highest bit position.
    </t>
    <t>
If the current highest bit position value is equal to 4294967295,
then a position value MUST be specified for &quot;bit&quot; substatements
following the one with the current highest position value.
    </t>
</section>
</section>
<section title="Usage Example">
    <t>
Given the following leaf:
    </t>
	<figure>
	    <artwork><![CDATA[
  leaf mybits {
      type bits {
          bit disable-nagle {
              position 0;
          }
          bit auto-sense-speed {
              position 1;
          }
          bit 10-Mb-only {
              position 2;
          }
      }
      default "auto-sense-speed";
  }
	    ]]></artwork>
	</figure>
    <t>
The lexical representation of this leaf
with bit values disable-nagle and 10-Mb-only set would be:
    </t>
	<figure>
	    <artwork><![CDATA[
  <mybits>disable-nagle 10-Mb-only</mybits>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The binary Built-In Type">
    <t>
The binary built-in type represents any binary data, i.e., a sequence
of octets.
    </t>
<section title="Restrictions">
    <t>
A binary can be restricted with the &quot;length&quot; (<xref target="length"/>) statement. The
length of a binary value is the number of octets it contains.
    </t>
</section>
<section title="Lexical Representation">
    <t>
Binary values are encoded with the base64 encoding scheme (see
<xref target="RFC4648"/>, Section 4).
    </t>
</section>
<section title="Canonical Form">
    <t>
The canonical form of a binary value follows the rules in <xref target="RFC4648"/>.
    </t>
</section>
</section>
<section title="The leafref Built-In Type">
    <t>
The leafref type is used to reference a particular leaf instance in
the data tree.  The &quot;path&quot; substatement (<xref target="path"/>) selects a set of leaf
instances, and the leafref value space is the set of values of these
leaf instances.
    </t>
    <t>
If the leaf with the leafref type represents configuration data, the
leaf it refers to MUST also represent configuration.  Such a leaf puts
a constraint on valid data.  All leafref nodes MUST reference existing
leaf instances or leafs with default values in use (see
<xref target="leaf-default-value"/>) for the data to be valid.  This constraint is
enforced according to the rules in <xref target="constraints"/>.
    </t>
    <t>
There MUST NOT be any circular chains of leafrefs.
    </t>
    <t>
If the leaf that the leafref refers to is conditional based on one or
more features (see <xref target="if-feature"/>), then the leaf with the leafref type MUST
also be conditional based on at least the same set of features.
    </t>
<section title="Restrictions">
    <t>
A leafref cannot be restricted.
    </t>
</section>
<section title="The path Statement" anchor="path">
    <t>
The &quot;path&quot; statement, which is a substatement to the &quot;type&quot; statement,
MUST be present if the type is &quot;leafref&quot;.  It takes as an argument a
string that MUST refer to a leaf or leaf-list node.
    </t>
    <t>
The syntax for a path argument is a subset of the XPath abbreviated
syntax.  Predicates are used only for constraining the values for the
key nodes for list entries.  Each predicate consists of exactly one
equality test per key, and multiple adjacent predicates MAY be present
if a list has multiple keys.  The syntax is formally defined by the
rule &quot;path&#8209;arg&quot; in <xref target="grammar"/>.
    </t>
    <t>
The predicates are only used when more than one key reference is
needed to uniquely identify a leaf instance.  This occurs if a list
has multiple keys, or a reference to a leaf other than the key in a
list is needed.  In these cases, multiple leafrefs are typically
specified, and predicates are used to tie them together.
    </t>
    <t>
The &quot;path&quot; expression evaluates to a node set consisting of zero, one,
or more nodes.  If the leaf with the leafref type represents
configuration data, this node set MUST be non-empty.
    </t>
    <t>
The &quot;path&quot; XPath expression is conceptually evaluated in the following
context, in addition to the definition in <xref target="xpath-context"/>:
    </t>
<t>
 <list style="symbols">
 <t>
The context node is the node in the data tree for which the
&quot;path&quot; statement is defined.
 </t>
 </list>
</t>
    <t>
The accessible tree depends on the context node:
    </t>
<t>
 <list style="symbols">
 <t>
If the context node represents configuration data, the tree is the
data in the NETCONF datastore where the context node exists.  The
XPath root node has all top-level configuration data nodes in all
modules as children.
 </t>
 <t>
Otherwise, the tree is all state data on the device, and the
&lt;running/&gt; datastore.  The XPath root node has all top-level data
nodes in all modules as children.
 </t>
 </list>
</t>
</section>
<section title="Lexical Representation">
    <t>
A leafref value is encoded the same way as the leaf it references.
    </t>
</section>
<section title="Canonical Form">
    <t>
The canonical form of a leafref is the same as the canonical form of
the leaf it references.
    </t>
</section>
<section title="Usage Example">
    <t>
With the following list:
    </t>
	<figure>
	    <artwork><![CDATA[
  list interface {
      key "name";
      leaf name {
          type string;
      }
      leaf admin-status {
          type admin-status;
      }
      list address {
          key "ip";
          leaf ip {
              type yang:ip-address;
          }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
The following leafref refers to an existing interface:
    </t>
	<figure>
	    <artwork><![CDATA[
  leaf mgmt-interface {
      type leafref {
          path "../interface/name";
      }
  }
	    ]]></artwork>
	</figure>
    <t>
An example of a corresponding XML snippet:
    </t>
	<figure>
	    <artwork><![CDATA[
  <interface>
    <name>eth0</name>
  </interface>
  <interface>
    <name>lo</name>
  </interface>

  <mgmt-interface>eth0</mgmt-interface>
	    ]]></artwork>
	</figure>
    <t>
The following leafrefs refer to an existing address of an interface:
    </t>
	<figure>
	    <artwork><![CDATA[
  container default-address {
      leaf ifname {
          type leafref {
              path "../../interface/name";
          }
      }
      leaf address {
          type leafref {
              path "../../interface[name = current()/../ifname]"
                 + "/address/ip";
          }
      }
  }          
	    ]]></artwork>
	</figure>
    <t>
An example of a corresponding XML snippet:
    </t>
	<figure>
	    <artwork><![CDATA[
  <interface>
    <name>eth0</name>
    <admin-status>up</admin-status>
    <address>
      <ip>192.0.2.1</ip>
    </address>
    <address>
      <ip>192.0.2.2</ip>
    </address>
  </interface>
  <interface>
    <name>lo</name>
    <admin-status>up</admin-status>
    <address>
      <ip>127.0.0.1</ip>
    </address>
  </interface>

  <default-address>
    <ifname>eth0</ifname>
    <address>192.0.2.2</address>
  </default-address>
	    ]]></artwork>
	</figure>
    <t>
The following list uses a leafref for one of its keys.  This is
similar to a foreign key in a relational database.
    </t>
	<figure>
	    <artwork><![CDATA[
  list packet-filter {
      key "if-name filter-id";
      leaf if-name {
          type leafref {
              path "/interface/name";
          }
      }
      leaf filter-id {
          type uint32;
      }
      ...
  }
	    ]]></artwork>
	</figure>
    <t>
An example of a corresponding XML snippet:
    </t>
	<figure>
	    <artwork><![CDATA[
  <interface>
    <name>eth0</name>
    <admin-status>up</admin-status>
    <address>
      <ip>192.0.2.1</ip>
    </address>
    <address>
      <ip>192.0.2.2</ip>
    </address>
  </interface>

  <packet-filter>
    <if-name>eth0</if-name>
    <filter-id>1</filter-id>
    ...
  </packet-filter>
  <packet-filter>
    <if-name>eth0</if-name>
    <filter-id>2</filter-id>
    ...
  </packet-filter>
	    ]]></artwork>
	</figure>
    <t>
The following notification defines two leafrefs to refer to an
existing admin-status:
    </t>
	<figure>
	    <artwork><![CDATA[
  notification link-failure {
      leaf if-name {
          type leafref {
              path "/interface/name";
          }
      }
      leaf admin-status {
          type leafref {
              path
                "/interface[name = current()/../if-name]"
              + "/admin-status";
          }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
An example of a corresponding XML notification:
    </t>
	<figure>
	    <artwork><![CDATA[
  <notification
    xmlns="urn:ietf:params:xml:ns:netconf:notification:1.0">
    <eventTime>2008-04-01T00:01:00Z</eventTime>
    <link-failure xmlns="http://acme.example.com/system">
      <if-name>eth0</if-name>
      <admin-status>up</admin-status>
    </link-failure>
  </notification>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The identityref Built-In Type" anchor="identityref">
    <t>
The identityref type is used to reference an existing identity (see
<xref target="identity"/>). 
    </t>
<section title="Restrictions">
    <t>
An identityref cannot be restricted.
    </t>
</section>
<section title="The identityref&apos;s base Statement" anchor="base-identityref">
    <t>
The &quot;base&quot; statement, which is a substatement to the &quot;type&quot; statement,
MUST be present if the type is &quot;identityref&quot;.  The argument is the
name of an identity, as defined by an &quot;identity&quot; statement.  If a prefix
is present on the identity name, it refers to an identity defined in the
module that was imported with that prefix.  Otherwise, an identity
with the matching name MUST be defined in the current module or an
included submodule.
    </t>
    <t>
Valid values for an identityref are any identities derived from the
identityref&apos;s base identity.  On a particular server, the valid values
are further restricted to the set of identities defined in the modules
supported by the server.
    </t>
</section>
<section title="Lexical Representation">
    <t>
An identityref is encoded as the referred identity&apos;s qualified name
as defined in <xref target="XML-NAMES"/>.  If the prefix is not present, the
namespace of the identityref is the default namespace in effect on the
element that contains the identityref value.
    </t>
    <t>
When an identityref is given a default value using the &quot;default&quot;
statement, the identity name in the default value MAY have a prefix.
If a prefix is present on the identity name, it refers to an identity
defined in the module that was imported with that prefix.  Otherwise,
an identity with the matching name MUST be defined in the current
module or an included submodule.
    </t>
</section>
<section title="Canonical Form">
    <t>
Since the lexical form depends on the XML context in which the
value occurs, this type does not have a canonical form.
    </t>
</section>
<section title="Usage Example">
    <t>
With the identity definitions in <xref target="identity-example"/> and the following
module:
    </t>
	<figure>
	    <artwork><![CDATA[
  module my-crypto {

      namespace "http://example.com/my-crypto";
      prefix mc;

      import "crypto-base" {
          prefix "crypto";
      }

      identity aes {
          base "crypto:crypto-alg";
      }

      leaf crypto {
          type identityref {
              base "crypto:crypto-alg";
          }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
the leaf &quot;crypto&quot; will be encoded as follows, if the value is the
&quot;des3&quot; identity defined in the &quot;des&quot; module:
    </t>
	<figure>
	    <artwork><![CDATA[
  <crypto xmlns:des="http://example.com/des">des:des3</crypto>
	    ]]></artwork>
	</figure>
    <t>
Any prefixes used in the encoding are local to each instance encoding.
This means that the same identityref may be encoded differently by
different implementations.  For example, the following example encodes
the same leaf as above:
    </t>
	<figure>
	    <artwork><![CDATA[
  <crypto xmlns:x="http://example.com/des">x:des3</crypto>
	    ]]></artwork>
	</figure>
    <t>
If the &quot;crypto&quot; leaf&apos;s value instead is &quot;aes&quot; defined in the
&quot;my&#8209;crypto&quot; module, it can be encoded as:
    </t>
	<figure>
	    <artwork><![CDATA[
  <crypto xmlns:mc="http://example.com/my-crypto">mc:aes</crypto>
	    ]]></artwork>
	</figure>
    <t>
or, using the default namespace:
    </t>
	<figure>
	    <artwork><![CDATA[
  <crypto>aes</crypto>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The empty Built-In Type">
    <t>
The empty built-in type represents a leaf that does not have any value, 
it conveys information by its presence or absence.
    </t>
    <t>
An empty type cannot have a default value.
    </t>
<section title="Restrictions">
    <t>
An empty type cannot be restricted.
    </t>
</section>
<section title="Lexical Representation">
    <t>
Not applicable.
    </t>
</section>
<section title="Canonical Form">
    <t>
Not applicable.
    </t>
</section>
<section title="Usage Example">
    <t>
The following leaf
    </t>
	<figure>
	    <artwork><![CDATA[
  leaf enable-qos {
      type empty;
  }
	    ]]></artwork>
	</figure>
    <t>
will be encoded as
    </t>
	<figure>
	    <artwork><![CDATA[
  <enable-qos/>
	    ]]></artwork>
	</figure>
    <t>
if it exists.
    </t>
</section>
</section>
<section title="The union Built-In Type">
    <t>
The union built-in type represents a value that corresponds to one of
its member types.
    </t>
    <t>
When the type is &quot;union&quot;, the &quot;type&quot; statement (<xref target="type"/>) MUST be
present.  It is used to repeatedly specify each member type of the
union.  It takes as an argument a string that is the name of a member
type.
    </t>
    <t>
A member type can be of any built-in or derived type, except it MUST
NOT be one of the built-in types &quot;empty&quot; or &quot;leafref&quot;.
    </t>
    <t>
When a string representing a union data type is validated, the string
is validated against each member type, in the order they are specified
in the &quot;type&quot; statement, until a match is found.
    </t>
    <t>
Any default value or &quot;units&quot; property defined in the member types is
not inherited by the union type.
    </t>
    <t>
Example:
    </t>
	<figure>
	    <artwork><![CDATA[
  type union {
      type int32;
      type enumeration {
          enum "unbounded";
      }
  }
	    ]]></artwork>
	</figure>
<section title="Restrictions">
    <t>
A union cannot be restricted.  However, each member type can be
restricted, based on the rules defined in <xref target="built-in"/>.
    </t>
</section>
<section title="Lexical Representation">
    <t>
The lexical representation of a union is a value that 
corresponds to the representation of any one of the member types. 
    </t>
</section>
<section title="Canonical Form">
    <t>
The canonical form of a union value is the same as the canonical form
of the member type of the value.
    </t>
</section>
</section>
<section title="The instance-identifier Built-In Type" anchor="inst-id">
    <t>
The instance-identifier built-in type is used to uniquely identify a
particular instance node in the data tree.  
    </t>
    <t>
The syntax for an instance-identifier is a subset of the XPath
abbreviated syntax, formally defined by the rule &quot;instance&#8209;identifier&quot;
in <xref target="grammar"/>.  It is used to uniquely identify a node in the data
tree.  Predicates are used only for specifying the values for the key
nodes for list entries, a value of a leaf-list entry, or a positional
index for a list without keys.  For identifying list entries with keys,
each predicate consists of one equality test per key, and each key
MUST have a corresponding predicate.
    </t>
    <t>
If the leaf with the instance-identifier type represents configuration
data, and the &quot;require&#8209;instance&quot; property (<xref target="require-instance"/>) is
&quot;true&quot;, the node it refers to MUST also represent configuration.  Such
a leaf puts a constraint on valid data.  All such leaf nodes MUST
reference existing nodes or leaf nodes with their default value in use
(see <xref target="leaf-default-value"/>) for the data to be valid.  This constraint
is enforced according to the rules in <xref target="constraints"/>.
    </t>
    <t>
The &quot;instance&#8209;identifier&quot; XPath expression is conceptually evaluated
in the following context, in addition to the definition in
<xref target="xpath-context"/>:
    </t>
<t>
 <list style="symbols">
 <t>
The context node is the root node in the accessible tree.
 </t>
 </list>
</t>
    <t>
The accessible tree depends on the leaf with the instance-identifier
type:
    </t>
<t>
 <list style="symbols">
 <t>
If this leaf represents configuration data, the tree is the data in
the NETCONF datastore where the leaf exists.  The XPath root node
has all top-level configuration data nodes in all modules as
children.
 </t>
 <t>
Otherwise, the tree is all state data on the device, and the
&lt;running/&gt; datastore.  The XPath root node has all top-level data
nodes in all modules as children.
 </t>
 </list>
</t>
<section title="Restrictions">
    <t>
An instance-identifier can be restricted with the &quot;require&#8209;instance&quot;
statement (<xref target="require-instance"/>).
    </t>
</section>
<section title="The require-instance Statement" anchor="require-instance">
    <t>
The &quot;require&#8209;instance&quot; statement, which is a substatement to the
&quot;type&quot; statement, MAY be present if the type is &quot;instance&#8209;identifier&quot;.
It takes as an argument the string &quot;true&quot; or &quot;false&quot;.  If this
statement is not present, it defaults to &quot;true&quot;.
    </t>
    <t>
If &quot;require&#8209;instance&quot; is &quot;true&quot;, it means that the instance being
referred MUST exist for the data to be valid.  This constraint is
enforced according to the rules in <xref target="constraints"/>.
    </t>
    <t>
If &quot;require&#8209;instance&quot; is &quot;false&quot;, it means that the instance being
referred MAY exist in valid data.
    </t>
</section>
<section title="Lexical Representation">
    <t>
An instance-identifier value is lexically represented as a
string.  All node names in an instance-identifier value MUST be
qualified with explicit namespace prefixes, and these prefixes MUST be
declared in the XML namespace scope in the instance-identifier&apos;s XML
element.
    </t>
    <t>
Any prefixes used in the encoding are local to each instance encoding.
This means that the same instance-identifier may be encoded
differently by different implementations.
    </t>
</section>
<section title="Canonical Form">
    <t>
Since the lexical form depends on the XML context in which the
value occurs, this type does not have a canonical form.
    </t>
</section>
<section title="Usage Example">
    <t>
The following are examples of instance identifiers:
    </t>
	<figure>
	    <artwork><![CDATA[
  /* instance-identifier for a container */
  /ex:system/ex:services/ex:ssh

  /* instance-identifier for a leaf */
  /ex:system/ex:services/ex:ssh/ex:port

  /* instance-identifier for a list entry */
  /ex:system/ex:user[ex:name='fred']

  /* instance-identifier for a leaf in a list entry */
  /ex:system/ex:user[ex:name='fred']/ex:type

  /* instance-identifier for a list entry with two keys */
  /ex:system/ex:server[ex:ip='192.0.2.1'][ex:port='80']

  /* instance-identifier for a leaf-list entry */
  /ex:system/ex:services/ex:ssh/ex:cipher[.='blowfish-cbc']

  /* instance-identifier for a list entry without keys */
  /ex:stats/ex:port[3]
	    ]]></artwork>
	</figure>
</section>
</section>
</section>
<section title="Updating a Module">
    <t>
As experience is gained with a module, it may be desirable to revise
that module.  However, changes are not allowed if they have any
potential to cause interoperability problems between a client using an
original specification and a server using an updated specification.
    </t>
    <t>
For any published change, a new &quot;revision&quot; statement (<xref target="revision"/>) MUST
be included in front of the existing &quot;revision&quot; statements.  If there
are no existing &quot;revision&quot; statements, then one MUST be added to
identify the new revision.  Furthermore, any necessary changes MUST be
applied to any meta-data statements, including the &quot;organization&quot; and
&quot;contact&quot; statements (Sections <xref target="organization" format="counter"/>, <xref target="contact" format="counter"/>).
    </t>
    <t>
Note that definitions contained in a module are available to be
imported by any other module, and are referenced in &quot;import&quot;
statements via the module name.  Thus, a module name MUST NOT be
changed.  Furthermore, the &quot;namespace&quot; statement MUST NOT be changed,
since all XML elements are qualified by the namespace.
    </t>
    <t>
Obsolete definitions MUST NOT be removed from modules since their
identifiers may still be referenced by other modules.
    </t>
    <t>
A definition may be revised in any of the following ways:
    </t>
<t>
 <list style="symbols">
 <t>
An &quot;enumeration&quot; type may have new enums added, provided the old
enums&apos;s values do not change.
 </t>
 <t>
A &quot;bits&quot; type may have new bits added, provided the old bit
positions do not change. 
 </t>
 <t>
A &quot;range&quot;, &quot;length&quot;, or &quot;pattern&quot; statement may expand the allowed
value space.
 </t>
 <t>
A &quot;default&quot; statement may be added to a leaf that does not have a
default value (either directly or indirectly through its type).
 </t>
 <t>
A &quot;units&quot; statement may be added.
 </t>
 <t>
A &quot;reference&quot; statement may be added or updated.
 </t>
 <t>
A &quot;must&quot; statement may be removed or its constraint relaxed.
 </t>
 <t>
A &quot;mandatory&quot; statement may be removed or changed from &quot;true&quot; to
&quot;false&quot;.
 </t>
 <t>
A &quot;min&#8209;elements&quot; statement may be removed, or changed to require fewer
elements.
 </t>
 <t>
A &quot;max&#8209;elements&quot; statement may be removed, or changed to allow more
elements.
 </t>
 <t>
A &quot;description&quot; statement may be added or clarified without changing
the semantics of the definition.
 </t>
 <t>
New typedefs, groupings, rpcs, notifications, extensions, features,
and identities may be added.
 </t>
 <t>
New data definition statements may be added if they do not add
mandatory nodes (<xref target="mandatory-nodes"/>) to existing nodes or at the
top level in a module or submodule, or if they are conditionally
dependent on a new feature (i.e., have an &quot;if&#8209;feature&quot; statement that
refers to a new feature).
 </t>
 <t>
A new &quot;case&quot; statement may be added.
 </t>
 <t>
A node that represented state data may be changed to represent
configuration, provided it is not mandatory (<xref target="mandatory-nodes"/>).
 </t>
 <t>
An &quot;if&#8209;feature&quot; statement may be removed, provided its node is not
mandatory (<xref target="mandatory-nodes"/>). 
 </t>
 <t>
A &quot;status&quot; statement may be added, or changed from &quot;current&quot; to
&quot;deprecated&quot; or &quot;obsolete&quot;, or from &quot;deprecated&quot; to &quot;obsolete&quot;.
 </t>
 <t>
A &quot;type&quot; statement may be replaced with another &quot;type&quot; statement
that does not change the syntax or semantics of the type.  For
example, an inline type definition may be replaced with a typedef,
but an int8 type cannot be replaced by an int16, since the syntax
would change.
 </t>
 <t>
Any set of data definition nodes may be replaced with another set of
syntactically and semantically equivalent nodes.  For example, a set
of leafs may be replaced by a uses of a grouping with the same
leafs.
 </t>
 <t>
A module may be split into a set of submodules, or a submodule may be
removed, provided the definitions in the module do not change in any
other way than allowed here.
 </t>
 <t>
The &quot;prefix&quot; statement may be changed, provided all local uses of the
prefix also are changed.
 </t>
 </list>
</t>
    <t>
Otherwise, if the semantics of any previous definition are changed
(i.e., if a non-editorial change is made to any definition other than
those specifically allowed above), then this MUST be achieved by a new
definition with a new identifier.
    </t>
    <t>
In statements that have any data definition statements as
substatements, those data definition substatements MUST NOT be
reordered.
    </t>
</section>
<section title="YIN" anchor="YIN">
    <t>
A YANG module can be translated into an alternative XML-based
syntax called YIN. The translated module is called a YIN
module. This section describes symmetric mapping rules between the
two formats.
    </t>
    <t>
The YANG and YIN formats contain equivalent information using
different notations.  The YIN notation enables developers to represent
YANG data models in XML and therefore use the rich set of XML-based
tools for data filtering and validation, automated generation of code
and documentation, and other tasks.  Tools like XSLT or XML validators
can be utilized.
    </t>
    <t>
The mapping between YANG and YIN does not modify the information
content of the model.  Comments and whitespace are not preserved.
    </t>
<section title="Formal YIN Definition">
    <t>
There is a one-to-one correspondence between YANG keywords and YIN
elements.  The local name of a YIN element is identical to the
corresponding YANG keyword.  This means, in particular, that the
document element (root) of a YIN document is always &lt;module&gt; or
&lt;submodule&gt;.
    </t>
    <t>
YIN elements corresponding to the YANG keywords belong to the
namespace whose associated URI is &quot;urn:ietf:params:xml:ns:yang:yin:1&quot;.
    </t>
    <t>
YIN elements corresponding to extension keywords belong to the
namespace of the YANG module where the extension keyword is declared
via the &quot;extension&quot; statement.
    </t>
    <t>
The names of all YIN elements MUST be properly qualified with their
namespaces specified above using the standard mechanisms of
<xref target="XML-NAMES"/>, i.e., &quot;xmlns&quot; and &quot;xmlns:xxx&quot; attributes.
    </t>
    <t>
The argument of a YANG statement is represented in YIN either as an XML
attribute or a subelement of the keyword element.  <xref target="yymap"/> defines the
mapping for the set of YANG keywords.  For extensions, the
argument mapping is specified within the &quot;extension&quot; statement (see
<xref target="extension"/>).  The following rules hold for arguments:
    </t>
<t>
 <list style="symbols">
 <t>
If the argument is represented as an attribute, this attribute has
no namespace.
 </t>
 <t>
If the argument is represented as an element, it is qualified by the
same namespace as its parent keyword element.
 </t>
 <t>
If the argument is represented as an element, it MUST be the first
child of the keyword element.
 </t>
 </list>
</t>
    <t>
Substatements of a YANG statement are represented as (additional) children
of the keyword element and their relative order MUST be the same as
the order of substatements in YANG.
    </t>
    <t>
Comments in YANG MAY be mapped to XML comments.
    </t>
<?rfc compact="yes"?><texttable anchor="yymap">
<preamble>Mapping of arguments of the YANG statements.</preamble>
<ttcol align='left'> keyword</ttcol>
<ttcol align='left'>argument name</ttcol>
<ttcol align='left'>yin-element</ttcol>
<c>anyxml</c>
<c>name</c>
<c>false</c>
<c>argument</c>
<c>name</c>
<c>false</c>
<c>augment</c>
<c>target-node</c>
<c>false</c>
<c>base</c>
<c>name</c>
<c>false</c>
<c>belongs-to</c>
<c>module</c>
<c>false</c>
<c>bit</c>
<c>name</c>
<c>false</c>
<c>case</c>
<c>name</c>
<c>false</c>
<c>choice</c>
<c>name</c>
<c>false</c>
<c>config</c>
<c>value</c>
<c>false</c>
<c>contact</c>
<c>text</c>
<c>true</c>
<c>container</c>
<c>name</c>
<c>false</c>
<c>default</c>
<c>value</c>
<c>false</c>
<c>description</c>
<c>text</c>
<c>true</c>
<c>deviate</c>
<c>value</c>
<c>false</c>
<c>deviation</c>
<c>target-node</c>
<c>false</c>
<c>enum</c>
<c>name</c>
<c>false</c>
<c>error-app-tag</c>
<c>value</c>
<c>false</c>
<c>error-message</c>
<c>value</c>
<c>true</c>
<c>extension</c>
<c>name</c>
<c>false</c>
<c>feature</c>
<c>name</c>
<c>false</c>
<c>fraction-digits</c>
<c>value</c>
<c>false</c>
<c>grouping</c>
<c>name</c>
<c>false</c>
<c>identity</c>
<c>name</c>
<c>false</c>
<c>if-feature</c>
<c>name</c>
<c>false</c>
<c>import</c>
<c>module</c>
<c>false</c>
<c>include</c>
<c>module</c>
<c>false</c>
<c>input</c>
<c>&lt;no argument&gt;</c>
<c>n/a</c>
<c>key</c>
<c>value</c>
<c>false</c>
<c>leaf</c>
<c>name</c>
<c>false</c>
<c>leaf-list</c>
<c>name</c>
<c>false</c>
<c>length</c>
<c>value</c>
<c>false</c>
<c>list</c>
<c>name</c>
<c>false</c>
<c>mandatory</c>
<c>value</c>
<c>false</c>
<c>max-elements</c>
<c>value</c>
<c>false</c>
<c>min-elements</c>
<c>value</c>
<c>false</c>
<c>module</c>
<c>name</c>
<c>false</c>
<c>must</c>
<c>condition</c>
<c>false</c>
<c>namespace</c>
<c>uri</c>
<c>false</c>
<c>notification</c>
<c>name</c>
<c>false</c>
<c>ordered-by</c>
<c>value</c>
<c>false</c>
<c>organization</c>
<c>text</c>
<c>true</c>
<c>output</c>
<c>&lt;no argument&gt;</c>
<c>n/a</c>
<c>path</c>
<c>value</c>
<c>false</c>
<c>pattern</c>
<c>value</c>
<c>false</c>
<c>position</c>
<c>value</c>
<c>false</c>
<c>prefix</c>
<c>value</c>
<c>false</c>
<c>presence</c>
<c>value</c>
<c>false</c>
<c>range</c>
<c>value</c>
<c>false</c>
<c>reference</c>
<c>text</c>
<c>true</c>
<c>refine</c>
<c>target-node</c>
<c>false</c>
<c>require-instance</c>
<c>value</c>
<c>false</c>
<c>revision</c>
<c>date</c>
<c>false</c>
<c>revision-date</c>
<c>date</c>
<c>false</c>
<c>rpc</c>
<c>name</c>
<c>false</c>
<c>status</c>
<c>value</c>
<c>false</c>
<c>submodule</c>
<c>name</c>
<c>false</c>
<c>type</c>
<c>name</c>
<c>false</c>
<c>typedef</c>
<c>name</c>
<c>false</c>
<c>unique</c>
<c>tag</c>
<c>false</c>
<c>units</c>
<c>name</c>
<c>false</c>
<c>uses</c>
<c>name</c>
<c>false</c>
<c>value</c>
<c>value</c>
<c>false</c>
<c>when</c>
<c>condition</c>
<c>false</c>
<c>yang-version</c>
<c>value</c>
<c>false</c>
<c>yin-element</c>
<c>value</c>
<c>false</c>
</texttable>
<?rfc compact="no"?><section title="Usage Example">
    <t>
The following YANG module:
    </t>
	<figure>
	    <artwork><![CDATA[
  module acme-foo {
      namespace "http://acme.example.com/foo";
      prefix "acfoo";

      import my-extensions {
          prefix "myext";
      }

      list interface {
          key "name";
          leaf name {
              type string;
          }

          leaf mtu {
              type uint32;
              description "The MTU of the interface.";
              myext:c-define "MY_MTU";
          }
      }
  }
	    ]]></artwork>
	</figure>
    <t>
where the extension &quot;c&#8209;define&quot; is defined in <xref target="extension-example"/>, is
translated into the following YIN:
    </t>
	<figure>
	    <artwork><![CDATA[
  <module name="acme-foo"
          xmlns="urn:ietf:params:xml:ns:yang:yin:1"
          xmlns:acfoo="http://acme.example.com/foo"
          xmlns:myext="http://example.com/my-extensions">

    <namespace uri="http://acme.example.com/foo"/>
    <prefix value="acfoo"/>

    <import module="my-extensions">
      <prefix value="myext"/>
    </import>

    <list name="interface">
      <key value="name"/>
      <leaf name="name">
        <type name="string"/>
      </leaf>
      <leaf name="mtu">
        <type name="uint32"/>
        <description>
          <text>The MTU of the interface.</text>
        </description>
        <myext:c-define name="MY_MTU"/>
      </leaf>
    </list>
  </module>
	    ]]></artwork>
	</figure>
</section>
</section>
</section>
<section title="YANG ABNF Grammar" anchor="grammar">
    <t>
In YANG, almost all statements are unordered.  The ABNF grammar
<xref target="RFC5234"/> defines the canonical order.  To improve module readability,
it is RECOMMENDED that clauses be entered in this order.
    </t>
    <t>
Within the ABNF grammar, unordered statements are marked with
comments.
    </t>
    <t>
This grammar assumes that the scanner replaces YANG comments with a
single space character.
    </t>
<t>&lt;CODE BEGINS> file "yang.abnf"</t>
	<figure>
	    <artwork><![CDATA[
module-stmt         = optsep module-keyword sep identifier-arg-str
                      optsep
                      "{" stmtsep
                          module-header-stmts
                          linkage-stmts
                          meta-stmts
                          revision-stmts
                          body-stmts
                      "}" optsep

submodule-stmt      = optsep submodule-keyword sep identifier-arg-str
                      optsep
                      "{" stmtsep
                          submodule-header-stmts
                          linkage-stmts
                          meta-stmts 
                          revision-stmts
                          body-stmts
                      "}" optsep

module-header-stmts = ;; these stmts can appear in any order
                      [yang-version-stmt stmtsep]
                       namespace-stmt stmtsep
                       prefix-stmt stmtsep

submodule-header-stmts =
                      ;; these stmts can appear in any order
                      [yang-version-stmt stmtsep]
                       belongs-to-stmt stmtsep

meta-stmts          = ;; these stmts can appear in any order
                      [organization-stmt stmtsep]
                      [contact-stmt stmtsep]
                      [description-stmt stmtsep]
                      [reference-stmt stmtsep]

linkage-stmts       = ;; these stmts can appear in any order
                      *(import-stmt stmtsep)
                      *(include-stmt stmtsep)

revision-stmts      = *(revision-stmt stmtsep)

body-stmts          = *((extension-stmt /
                         feature-stmt /
                         identity-stmt /
                         typedef-stmt /
                         grouping-stmt /
                         data-def-stmt /
                         augment-stmt /
                         rpc-stmt /
                         notification-stmt /
                         deviation-stmt) stmtsep)

data-def-stmt       = container-stmt /
                      leaf-stmt /
                      leaf-list-stmt /
                      list-stmt /
                      choice-stmt /
                      anyxml-stmt /
                      uses-stmt

yang-version-stmt   = yang-version-keyword sep yang-version-arg-str
                      optsep stmtend

yang-version-arg-str = < a string that matches the rule
                        yang-version-arg >

yang-version-arg    = "1"

import-stmt         = import-keyword sep identifier-arg-str optsep
                      "{" stmtsep
                          prefix-stmt stmtsep
                          [revision-date-stmt stmtsep]
                      "}"

include-stmt        = include-keyword sep identifier-arg-str optsep
                      (";" /
                       "{" stmtsep
                           [revision-date-stmt stmtsep]
                       "}")

namespace-stmt      = namespace-keyword sep uri-str optsep stmtend

uri-str             = < a string that matches the rule
                        URI in RFC 3986 >

prefix-stmt         = prefix-keyword sep prefix-arg-str
                      optsep stmtend

belongs-to-stmt     = belongs-to-keyword sep identifier-arg-str
                      optsep
                      "{" stmtsep
                          prefix-stmt stmtsep
                      "}"

organization-stmt   = organization-keyword sep string
                      optsep stmtend

contact-stmt        = contact-keyword sep string optsep stmtend

description-stmt    = description-keyword sep string optsep
                      stmtend

reference-stmt      = reference-keyword sep string optsep stmtend

units-stmt          = units-keyword sep string optsep stmtend

revision-stmt       = revision-keyword sep revision-date optsep
                      (";" /
                       "{" stmtsep
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                       "}")

revision-date       =  date-arg-str

revision-date-stmt = revision-date-keyword sep revision-date stmtend

extension-stmt      = extension-keyword sep identifier-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [argument-stmt stmtsep]
                           [status-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                       "}")

argument-stmt       = argument-keyword sep identifier-arg-str optsep
                      (";" /
                       "{" stmtsep
                           [yin-element-stmt stmtsep]
                       "}")      

yin-element-stmt    = yin-element-keyword sep yin-element-arg-str
                      stmtend

yin-element-arg-str = < a string that matches the rule
                        yin-element-arg >

yin-element-arg     = true-keyword / false-keyword

identity-stmt       = identity-keyword sep identifier-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [base-stmt stmtsep]
                           [status-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                       "}")

base-stmt           = base-keyword sep identifier-ref-arg-str
                      optsep stmtend

feature-stmt        = feature-keyword sep identifier-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           *(if-feature-stmt stmtsep)
                           [status-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                       "}")

if-feature-stmt     = if-feature-keyword sep identifier-ref-arg-str
                      optsep stmtend

typedef-stmt        = typedef-keyword sep identifier-arg-str optsep
                      "{" stmtsep
                          ;; these stmts can appear in any order
                          type-stmt stmtsep
                          [units-stmt stmtsep]
                          [default-stmt stmtsep]
                          [status-stmt stmtsep]
                          [description-stmt stmtsep]
                          [reference-stmt stmtsep]
                       "}"

type-stmt           = type-keyword sep identifier-ref-arg-str optsep
                      (";" /
                       "{" stmtsep
                           type-body-stmts
                       "}")

type-body-stmts     = numerical-restrictions /
                      decimal64-specification /
                      string-restrictions /
                      enum-specification /
                      leafref-specification /
                      identityref-specification /
                      instance-identifier-specification /
                      bits-specification /
                      union-specification

numerical-restrictions = range-stmt stmtsep

range-stmt          = range-keyword sep range-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [error-message-stmt stmtsep]
                           [error-app-tag-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                        "}")

decimal64-specification = fraction-digits-stmt

fraction-digits-stmt = fraction-digits-keyword sep
                       fraction-digits-arg-str stmtend

fraction-digits-arg-str = < a string that matches the rule
                           fraction-digits-arg >

fraction-digits-arg = ("1" ["0" / "1" / "2" / "3" / "4" /
                            "5" / "6" / "7" / "8"])
                      / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9"

string-restrictions = ;; these stmts can appear in any order
                      [length-stmt stmtsep]
                      *(pattern-stmt stmtsep)

length-stmt         = length-keyword sep length-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [error-message-stmt stmtsep]
                           [error-app-tag-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                        "}")

pattern-stmt        = pattern-keyword sep string optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [error-message-stmt stmtsep]
                           [error-app-tag-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                        "}")

default-stmt        = default-keyword sep string stmtend

enum-specification  = 1*(enum-stmt stmtsep)

enum-stmt           = enum-keyword sep string optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [value-stmt stmtsep]
                           [status-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                        "}")

leafref-specification =
                      ;; these stmts can appear in any order
                      path-stmt stmtsep
                      [require-instance-stmt stmtsep]

path-stmt           = path-keyword sep path-arg-str stmtend

require-instance-stmt = require-instance-keyword sep 
                         require-instance-arg-str stmtend

require-instance-arg-str = < a string that matches the rule
                           require-instance-arg >

require-instance-arg = true-keyword / false-keyword


instance-identifier-specification =
                      [require-instance-stmt stmtsep]

identityref-specification =
                      base-stmt stmtsep

union-specification = 1*(type-stmt stmtsep)

bits-specification  = 1*(bit-stmt stmtsep)

bit-stmt            = bit-keyword sep identifier-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [position-stmt stmtsep]
                           [status-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                         "}"
                       "}")

position-stmt       = position-keyword sep
                      position-value-arg-str stmtend

position-value-arg-str = < a string that matches the rule
                           position-value-arg >

position-value-arg  = non-negative-integer-value

status-stmt         = status-keyword sep status-arg-str stmtend

status-arg-str      = < a string that matches the rule
                        status-arg >

status-arg          = current-keyword /
                      obsolete-keyword /
                      deprecated-keyword

config-stmt         = config-keyword sep
                      config-arg-str stmtend

config-arg-str      = < a string that matches the rule
                        config-arg >

config-arg          = true-keyword / false-keyword

mandatory-stmt      = mandatory-keyword sep
                      mandatory-arg-str stmtend

mandatory-arg-str   = < a string that matches the rule
                        mandatory-arg >

mandatory-arg       = true-keyword / false-keyword

presence-stmt       = presence-keyword sep string stmtend

ordered-by-stmt     = ordered-by-keyword sep
                      ordered-by-arg-str stmtend

ordered-by-arg-str  = < a string that matches the rule
                        ordered-by-arg >

ordered-by-arg      = user-keyword / system-keyword

must-stmt           = must-keyword sep string optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [error-message-stmt stmtsep]
                           [error-app-tag-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                        "}")

error-message-stmt  = error-message-keyword sep string stmtend

error-app-tag-stmt  = error-app-tag-keyword sep string stmtend

min-elements-stmt   = min-elements-keyword sep 
                      min-value-arg-str stmtend

min-value-arg-str   = < a string that matches the rule
                        min-value-arg >

min-value-arg       = non-negative-integer-value

max-elements-stmt   = max-elements-keyword sep 
                      max-value-arg-str stmtend

max-value-arg-str   = < a string that matches the rule
                        max-value-arg >

max-value-arg       = unbounded-keyword /
                      positive-integer-value

value-stmt          = value-keyword sep integer-value stmtend

grouping-stmt       = grouping-keyword sep identifier-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [status-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                           *((typedef-stmt /
                              grouping-stmt) stmtsep)
                           *(data-def-stmt stmtsep)
                       "}")

container-stmt      = container-keyword sep identifier-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [when-stmt stmtsep]
                           *(if-feature-stmt stmtsep)
                           *(must-stmt stmtsep)
                           [presence-stmt stmtsep]
                           [config-stmt stmtsep]
                           [status-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                           *((typedef-stmt /
                              grouping-stmt) stmtsep)
                           *(data-def-stmt stmtsep)
                       "}")
                       
leaf-stmt           = leaf-keyword sep identifier-arg-str optsep
                      "{" stmtsep
                          ;; these stmts can appear in any order
                          [when-stmt stmtsep]
                          *(if-feature-stmt stmtsep)
                          type-stmt stmtsep
                          [units-stmt stmtsep]
                          *(must-stmt stmtsep)
                          [default-stmt stmtsep]
                          [config-stmt stmtsep]
                          [mandatory-stmt stmtsep]
                          [status-stmt stmtsep]
                          [description-stmt stmtsep]
                          [reference-stmt stmtsep]
                       "}"

leaf-list-stmt      = leaf-list-keyword sep identifier-arg-str optsep
                      "{" stmtsep
                          ;; these stmts can appear in any order
                          [when-stmt stmtsep]
                          *(if-feature-stmt stmtsep)
                          type-stmt stmtsep
                          [units-stmt stmtsep]
                          *(must-stmt stmtsep)
                          [config-stmt stmtsep]
                          [min-elements-stmt stmtsep]
                          [max-elements-stmt stmtsep]
                          [ordered-by-stmt stmtsep]
                          [status-stmt stmtsep]
                          [description-stmt stmtsep]
                          [reference-stmt stmtsep]
                       "}"

list-stmt           = list-keyword sep identifier-arg-str optsep
                      "{" stmtsep
                          ;; these stmts can appear in any order
                          [when-stmt stmtsep]
                          *(if-feature-stmt stmtsep)
                          *(must-stmt stmtsep)
                          [key-stmt stmtsep]
                          *(unique-stmt stmtsep)
                          [config-stmt stmtsep]
                          [min-elements-stmt stmtsep]
                          [max-elements-stmt stmtsep]
                          [ordered-by-stmt stmtsep]
                          [status-stmt stmtsep]
                          [description-stmt stmtsep]
                          [reference-stmt stmtsep]
                          *((typedef-stmt /
                             grouping-stmt) stmtsep)
                          1*(data-def-stmt stmtsep)
                       "}"

key-stmt            = key-keyword sep key-arg-str stmtend

key-arg-str         = < a string that matches the rule
                        key-arg >

key-arg             = node-identifier *(sep node-identifier)

unique-stmt         = unique-keyword sep unique-arg-str stmtend

unique-arg-str      = < a string that matches the rule
                        unique-arg >

unique-arg          = descendant-schema-nodeid
                      *(sep descendant-schema-nodeid)

choice-stmt         = choice-keyword sep identifier-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [when-stmt stmtsep]
                           *(if-feature-stmt stmtsep)
                           [default-stmt stmtsep]
                           [config-stmt stmtsep]
                           [mandatory-stmt stmtsep]
                           [status-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                           *((short-case-stmt / case-stmt) stmtsep)
                       "}")

short-case-stmt     = container-stmt /
                      leaf-stmt /
                      leaf-list-stmt /
                      list-stmt /
                      anyxml-stmt

case-stmt           = case-keyword sep identifier-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [when-stmt stmtsep]
                           *(if-feature-stmt stmtsep)
                           [status-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                           *(data-def-stmt stmtsep)
                       "}")

anyxml-stmt         = anyxml-keyword sep identifier-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [when-stmt stmtsep]
                           *(if-feature-stmt stmtsep)
                           *(must-stmt stmtsep)
                           [config-stmt stmtsep]
                           [mandatory-stmt stmtsep]
                           [status-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                        "}")

uses-stmt           = uses-keyword sep identifier-ref-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [when-stmt stmtsep]
                           *(if-feature-stmt stmtsep)
                           [status-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                           *(refine-stmt stmtsep)
                           *(uses-augment-stmt stmtsep)
                       "}")

refine-stmt         = refine-keyword sep refine-arg-str optsep
                      (";" /
                       "{" stmtsep
                           (refine-container-stmts /
                            refine-leaf-stmts /
                            refine-leaf-list-stmts /
                            refine-list-stmts /
                            refine-choice-stmts /
                            refine-case-stmts /
                            refine-anyxml-stmts)
                       "}")

refine-arg-str      = < a string that matches the rule
                        refine-arg >

refine-arg          = descendant-schema-nodeid

refine-container-stmts =
                      ;; these stmts can appear in any order
                      *(must-stmt stmtsep)
                      [presence-stmt stmtsep]
                      [config-stmt stmtsep]
                      [description-stmt stmtsep]
                      [reference-stmt stmtsep]

refine-leaf-stmts   = ;; these stmts can appear in any order
                      *(must-stmt stmtsep)
                      [default-stmt stmtsep]
                      [config-stmt stmtsep]
                      [mandatory-stmt stmtsep]
                      [description-stmt stmtsep]
                      [reference-stmt stmtsep]

refine-leaf-list-stmts =
                      ;; these stmts can appear in any order
                      *(must-stmt stmtsep)
                      [config-stmt stmtsep]
                      [min-elements-stmt stmtsep]
                      [max-elements-stmt stmtsep]
                      [description-stmt stmtsep]
                      [reference-stmt stmtsep]

refine-list-stmts   = ;; these stmts can appear in any order
                      *(must-stmt stmtsep)
                      [config-stmt stmtsep]
                      [min-elements-stmt stmtsep]
                      [max-elements-stmt stmtsep]
                      [description-stmt stmtsep]
                      [reference-stmt stmtsep]

refine-choice-stmts = ;; these stmts can appear in any order
                      [default-stmt stmtsep]
                      [config-stmt stmtsep]
                      [mandatory-stmt stmtsep]
                      [description-stmt stmtsep]
                      [reference-stmt stmtsep]

refine-case-stmts   = ;; these stmts can appear in any order
                      [description-stmt stmtsep]
                      [reference-stmt stmtsep]


refine-anyxml-stmts = ;; these stmts can appear in any order
                      *(must-stmt stmtsep)
                      [config-stmt stmtsep]
                      [mandatory-stmt stmtsep]
                      [description-stmt stmtsep]
                      [reference-stmt stmtsep]

uses-augment-stmt   = augment-keyword sep uses-augment-arg-str optsep
                      "{" stmtsep
                          ;; these stmts can appear in any order
                          [when-stmt stmtsep]
                          *(if-feature-stmt stmtsep)
                          [status-stmt stmtsep]
                          [description-stmt stmtsep]
                          [reference-stmt stmtsep]
                          1*((data-def-stmt stmtsep) /
                             (case-stmt stmtsep))
                       "}"

uses-augment-arg-str = < a string that matches the rule
                         uses-augment-arg >

uses-augment-arg    = descendant-schema-nodeid

augment-stmt        = augment-keyword sep augment-arg-str optsep
                      "{" stmtsep
                          ;; these stmts can appear in any order
                          [when-stmt stmtsep]
                          *(if-feature-stmt stmtsep)
                          [status-stmt stmtsep]
                          [description-stmt stmtsep]
                          [reference-stmt stmtsep]
                          1*((data-def-stmt stmtsep) /
                             (case-stmt stmtsep))
                       "}"

augment-arg-str     = < a string that matches the rule
                        augment-arg >

augment-arg         = absolute-schema-nodeid

unknown-statement   = prefix ":" identifier [sep string] optsep
                      (";" / "{" *unknown-statement2 "}")

unknown-statement2   = [prefix ":"] identifier [sep string] optsep
                      (";" / "{" *unknown-statement2 "}")

when-stmt           = when-keyword sep string optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                        "}")

rpc-stmt            = rpc-keyword sep identifier-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           *(if-feature-stmt stmtsep)
                           [status-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                           *((typedef-stmt /
                              grouping-stmt) stmtsep)
                           [input-stmt stmtsep]
                           [output-stmt stmtsep]
                       "}")      

input-stmt          = input-keyword optsep
                      "{" stmtsep
                          ;; these stmts can appear in any order
                          *((typedef-stmt /
                             grouping-stmt) stmtsep)
                          1*(data-def-stmt stmtsep)
                      "}"

output-stmt         = output-keyword optsep
                      "{" stmtsep
                          ;; these stmts can appear in any order
                          *((typedef-stmt /
                             grouping-stmt) stmtsep)
                          1*(data-def-stmt stmtsep)
                      "}"

notification-stmt   = notification-keyword sep
                      identifier-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           *(if-feature-stmt stmtsep)
                           [status-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                           *((typedef-stmt /
                              grouping-stmt) stmtsep)
                           *(data-def-stmt stmtsep)
                       "}")      

deviation-stmt      = deviation-keyword sep
                      deviation-arg-str optsep
                      "{" stmtsep
                          ;; these stmts can appear in any order
                          [description-stmt stmtsep]
                          [reference-stmt stmtsep]
                          (deviate-not-supported-stmt /
                            1*(deviate-add-stmt /
                               deviate-replace-stmt /
                               deviate-delete-stmt))
                      "}"

deviation-arg-str   = < a string that matches the rule
                        deviation-arg >

deviation-arg       = absolute-schema-nodeid

deviate-not-supported-stmt =
                      deviate-keyword sep
                      not-supported-keyword optsep
                      (";" /
                       "{" stmtsep
                       "}")

deviate-add-stmt    = deviate-keyword sep add-keyword optsep
                      (";" /
                       "{" stmtsep
                           [units-stmt stmtsep]
                           *(must-stmt stmtsep)
                           *(unique-stmt stmtsep)
                           [default-stmt stmtsep]
                           [config-stmt stmtsep]
                           [mandatory-stmt stmtsep]
                           [min-elements-stmt stmtsep]
                           [max-elements-stmt stmtsep]
                       "}")

deviate-delete-stmt = deviate-keyword sep delete-keyword optsep
                      (";" /
                       "{" stmtsep
                           [units-stmt stmtsep]
                           *(must-stmt stmtsep)
                           *(unique-stmt stmtsep)
                           [default-stmt stmtsep]
                       "}")

deviate-replace-stmt = deviate-keyword sep replace-keyword optsep
                      (";" /
                       "{" stmtsep
                           [type-stmt stmtsep]
                           [units-stmt stmtsep]
                           [default-stmt stmtsep]
                           [config-stmt stmtsep]
                           [mandatory-stmt stmtsep]
                           [min-elements-stmt stmtsep]
                           [max-elements-stmt stmtsep]
                       "}")

;; Ranges

range-arg-str       = < a string that matches the rule
                        range-arg >

range-arg           = range-part *(optsep "|" optsep range-part)

range-part          = range-boundary
                      [optsep ".." optsep range-boundary]

range-boundary      = min-keyword / max-keyword /
                      integer-value / decimal-value

;; Lengths

length-arg-str      = < a string that matches the rule
                        length-arg >

length-arg          = length-part *(optsep "|" optsep length-part)

length-part         = length-boundary
                      [optsep ".." optsep length-boundary]

length-boundary     = min-keyword / max-keyword /
                      non-negative-integer-value

;; Date

date-arg-str        = < a string that matches the rule
                        date-arg >

date-arg            = 4DIGIT "-" 2DIGIT "-" 2DIGIT

;; Schema Node Identifiers

schema-nodeid       = absolute-schema-nodeid /
                      descendant-schema-nodeid

absolute-schema-nodeid = 1*("/" node-identifier)

descendant-schema-nodeid =
                      node-identifier
                      absolute-schema-nodeid

node-identifier     = [prefix ":"] identifier


;; Instance Identifiers

instance-identifier = 1*("/" (node-identifier *predicate))

predicate           = "[" *WSP (predicate-expr / pos) *WSP "]"

predicate-expr      = (node-identifier / ".") *WSP "=" *WSP
                      ((DQUOTE string DQUOTE) /
                       (SQUOTE string SQUOTE))

pos                 = non-negative-integer-value


;; leafref path

path-arg-str        = < a string that matches the rule
                        path-arg >

path-arg            = absolute-path / relative-path

absolute-path       = 1*("/" (node-identifier *path-predicate))

relative-path       = 1*(".." "/") descendant-path

descendant-path     = node-identifier 
                      [*path-predicate absolute-path]

path-predicate      = "[" *WSP path-equality-expr *WSP "]"

path-equality-expr  = node-identifier *WSP "=" *WSP path-key-expr

path-key-expr       = current-function-invocation *WSP "/" *WSP
                      rel-path-keyexpr

rel-path-keyexpr    = 1*(".." *WSP "/" *WSP)
                      *(node-identifier *WSP "/" *WSP)
                      node-identifier

;;; Keywords, using abnfgen's syntax for case-sensitive strings

;; statement keywords
anyxml-keyword      = 'anyxml'
argument-keyword    = 'argument'
augment-keyword     = 'augment'
base-keyword        = 'base'
belongs-to-keyword  = 'belongs-to'
bit-keyword         = 'bit'
case-keyword        = 'case'
choice-keyword      = 'choice'
config-keyword      = 'config'
contact-keyword     = 'contact'
container-keyword   = 'container'
default-keyword     = 'default'
description-keyword = 'description'
enum-keyword        = 'enum'
error-app-tag-keyword = 'error-app-tag'
error-message-keyword = 'error-message'
extension-keyword   = 'extension'
deviation-keyword   = 'deviation'
deviate-keyword     = 'deviate'
feature-keyword     = 'feature'
fraction-digits-keyword = 'fraction-digits'
grouping-keyword    = 'grouping'
identity-keyword    = 'identity'
if-feature-keyword  = 'if-feature'
import-keyword      = 'import'
include-keyword     = 'include'
input-keyword       = 'input'
key-keyword         = 'key'
leaf-keyword        = 'leaf'
leaf-list-keyword   = 'leaf-list'
length-keyword      = 'length'
list-keyword        = 'list'
mandatory-keyword   = 'mandatory'
max-elements-keyword = 'max-elements'
min-elements-keyword = 'min-elements'
module-keyword      = 'module'
must-keyword        = 'must'
namespace-keyword   = 'namespace'
notification-keyword= 'notification'
ordered-by-keyword  = 'ordered-by'
organization-keyword= 'organization'
output-keyword      = 'output'
path-keyword        = 'path'
pattern-keyword     = 'pattern'
position-keyword    = 'position'
prefix-keyword      = 'prefix'
presence-keyword    = 'presence'
range-keyword       = 'range'
reference-keyword   = 'reference'
refine-keyword      = 'refine'
require-instance-keyword = 'require-instance'
revision-keyword    = 'revision'
revision-date-keyword = 'revision-date'
rpc-keyword         = 'rpc'
status-keyword      = 'status'
submodule-keyword   = 'submodule'
type-keyword        = 'type'
typedef-keyword     = 'typedef'
unique-keyword      = 'unique'
units-keyword       = 'units'
uses-keyword        = 'uses'
value-keyword       = 'value'
when-keyword        = 'when'
yang-version-keyword= 'yang-version'
yin-element-keyword = 'yin-element'

;; other keywords

add-keyword         = 'add'
current-keyword     = 'current'
delete-keyword      = 'delete'
deprecated-keyword  = 'deprecated'
false-keyword       = 'false'
max-keyword         = 'max'
min-keyword         = 'min'
not-supported-keyword = 'not-supported'
obsolete-keyword    = 'obsolete'
replace-keyword     = 'replace'
system-keyword      = 'system'
true-keyword        = 'true'
unbounded-keyword   = 'unbounded'
user-keyword        = 'user'

current-function-invocation = current-keyword *WSP "(" *WSP ")"

;; Basic Rules

prefix-arg-str      = < a string that matches the rule
                        prefix-arg >

prefix-arg          = prefix

prefix              = identifier

identifier-arg-str  = < a string that matches the rule
                        identifier-arg >

identifier-arg      = identifier

;; An identifier MUST NOT start with (('X'|'x') ('M'|'m') ('L'|'l'))
identifier          = (ALPHA / "_")
                      *(ALPHA / DIGIT / "_" / "-" / ".")

identifier-ref-arg-str = < a string that matches the rule
                        identifier-ref-arg >

identifier-ref-arg  = [prefix ":"] identifier

string              = < an unquoted string as returned by
                        the scanner >

integer-value       = ("-" non-negative-integer-value)  /
                       non-negative-integer-value

non-negative-integer-value = "0" / positive-integer-value

positive-integer-value = (non-zero-digit *DIGIT)

zero-integer-value  = 1*DIGIT

stmtend             = ";" / "{" *unknown-statement "}"

sep                 = 1*(WSP / line-break)
                      ; unconditional separator

optsep              = *(WSP / line-break)

stmtsep             = *(WSP / line-break / unknown-statement)

line-break          = CRLF / LF 

non-zero-digit      = %x31-39
 
decimal-value       = integer-value ("." zero-integer-value)

SQUOTE              = %x27
                      ; ' (Single Quote)

;;
;; RFC 5234 core rules.
;;

ALPHA               = %x41-5A / %x61-7A
                      ; A-Z / a-z

CR                  = %x0D
                      ; carriage return

CRLF                = CR LF
                      ; Internet standard new line

DIGIT               = %x30-39
                      ; 0-9

DQUOTE              = %x22
                      ; " (Double Quote)

HEXDIG              = DIGIT /
                      %x61 / %x62 / %x63 / %x64 / %x65 / %x66
                      ; only lower-case a..f

HTAB                = %x09
                      ; horizontal tab

LF                  = %x0A
                      ; linefeed

SP                  = %x20
                      ; space

VCHAR               = %x21-7E
                      ; visible (printing) characters

WSP                 = SP / HTAB
                      ; whitespace
	    ]]></artwork>
	</figure>
<t>&lt;CODE ENDS></t>
</section>
<!--"-->
<section title="Error Responses for YANG Related Errors" anchor="yang-errors">
    <t>
A number of NETCONF error responses are defined for error cases
related to the data-model handling. If the relevant YANG statement has
an &quot;error&#8209;app&#8209;tag&quot; substatement, that overrides the default value
specified below.
    </t>
<section title="Error Message for Data That Violates a unique Statement">
    <t>
If a NETCONF operation would result in configuration data where a
unique constraint is invalidated, the following error is returned:
    </t>
	<figure>
	    <artwork><![CDATA[
  error-tag:      operation-failed
  error-app-tag:  data-not-unique
  error-info:     <non-unique>: Contains an instance identifier that
                  points to a leaf that invalidates the unique
                  constraint. This element is present once for each
                  non-unique leaf.

                  The <non-unique> element is in the YANG 
                  namespace ("urn:ietf:params:xml:ns:yang:1").
	    ]]></artwork>
	</figure>
</section>
<section title="Error Message for Data That Violates a max-elements Statement">
    <t>
If a NETCONF operation would result in configuration data where a list
or a leaf-list would have too many entries the following error is
returned:
    </t>
	<figure>
	    <artwork><![CDATA[
  error-tag:      operation-failed
  error-app-tag:  too-many-elements   
	    ]]></artwork>
	</figure>
    <t>
This error is returned once, with the error-path identifying the list
node, even if there are more than one extra child present.
    </t>
</section>
<section title="Error Message for Data That Violates a min-elements Statement">
    <t>
If a NETCONF operation would result in configuration data where a list
or a leaf-list would have too few entries the following error is
returned:
    </t>
	<figure>
	    <artwork><![CDATA[
  error-tag:      operation-failed
  error-app-tag:  too-few-elements   
	    ]]></artwork>
	</figure>
    <t>
This error is returned once, with the error-path identifying the list
node, even if there are more than one child missing.
    </t>
</section>
<section title="Error Message for Data That Violates a must Statement">
    <t>
If a NETCONF operation would result in configuration data where the
restrictions imposed by a &quot;must&quot; statement is violated the following
error is returned, unless a specific &quot;error&#8209;app&#8209;tag&quot; substatement is
present for the &quot;must&quot; statement.
    </t>
	<figure>
	    <artwork><![CDATA[
  error-tag:      operation-failed
  error-app-tag:  must-violation
	    ]]></artwork>
	</figure>
</section>
<section title="Error Message for Data That Violates a require-instance Statement">
    <t>
If a NETCONF operation would result in configuration data where a leaf
of type &quot;instance&#8209;identifier&quot; marked with require-instance &quot;true&quot;
refers to a non-existing instance, the following error is returned:
    </t>
	<figure>
	    <artwork><![CDATA[
  error-tag:      data-missing
  error-app-tag:  instance-required
  error-path:     Path to the instance-identifier leaf.
	    ]]></artwork>
	</figure>
</section>
<section title="Error Message for Data That Does Not Match a leafref Type">
    <t>
If a NETCONF operation would result in configuration data where a leaf
of type &quot;leafref&quot; refers to a non-existing instance, the following
error is returned:
    </t>
	<figure>
	    <artwork><![CDATA[
  error-tag:      data-missing
  error-app-tag:  instance-required
  error-path:     Path to the leafref leaf.
	    ]]></artwork>
	</figure>
</section>
<section title="Error Message for Data That Violates a mandatory choice Statement">
    <t>
If a NETCONF operation would result in configuration data where no
nodes exists in a mandatory choice, the following error is returned:
    </t>
	<figure>
	    <artwork><![CDATA[
  error-tag:      data-missing
  error-app-tag:  missing-choice
  error-path:     Path to the element with the missing choice.
  error-info:     <missing-choice>: Contains the name of the missing
                  mandatory choice.

                  The <missing-choice> element is in the YANG 
                  namespace ("urn:ietf:params:xml:ns:yang:1").
	    ]]></artwork>
	</figure>
</section>
<section title="Error Message for the &quot;insert&quot; Operation">
    <t>
If the &quot;insert&quot; and &quot;key&quot; or &quot;value&quot; attributes are used in an
&lt;edit&#8209;config&gt; for a list or leaf-list node, and the &quot;key&quot; or &quot;value&quot;
refers to a non-existing instance, the following error is returned:
    </t>
	<figure>
	    <artwork><![CDATA[
  error-tag:      bad-attribute
  error-app-tag:  missing-instance
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="IANA Considerations" anchor="iana">
    <t>
This document defines a registry for YANG module and submodule names.
The name of the registry is &quot;YANG Module Names&quot;.
    </t>
    <t>
The registry shall record for each entry:
    </t>
<t>
 <list style="symbols">
 <t>
the name of the module or submodule
 </t>
 <t>
for modules, the assigned XML namespace
 </t>
 <t>
for modules, the prefix of the module
 </t>
 <t>
for submodules, the name of the module it belongs to
 </t>
 <t>
a reference to the (sub)module&apos;s documentation (e.g., the RFC
number)
 </t>
 </list>
</t>
    <t>
There are no initial assignments.
    </t>
    <t>
For allocation, RFC publication is required as per RFC 5226 <xref target="RFC5226"/>.
All registered YANG module names MUST comply with the rules for
identifiers stated in <xref target="identifiers"/>, and MUST have a module name
prefix.
    </t>
    <t>
The module name prefix &apos;ietf&#8209;&apos; is reserved for IETF stream documents
<xref target="RFC4844"/>, while the module name prefix &apos;irtf&#8209;&apos; is reserved for IRTF
stream documents.  Modules published in other RFC streams MUST have a
similar suitable prefix.
    </t>
    <t>
All module and submodule names in the registry MUST be unique.
    </t>
    <t>
All XML namespaces in the registry MUST be unique.
    </t>
    <t>
This document registers two URIs for the YANG and YIN XML namespaces
in the IETF XML registry <xref target="RFC3688"/>.  Following the format in RFC 3688, the
following have been registered.
    </t>
	<figure>
	    <artwork><![CDATA[
  URI: urn:ietf:params:xml:ns:yang:yin:1
  URI: urn:ietf:params:xml:ns:yang:1

  Registrant Contact: The IESG.

  XML: N/A, the requested URIs are XML namespaces.
	    ]]></artwork>
	</figure>
    <t>
This document registers two new media types as defined in the
following sections.
    </t>
<section title="Media type application/yang">
	<figure>
	    <artwork><![CDATA[
  MIME media type name:  application

  MIME subtype name:  yang

  Mandatory parameters:  none

  Optional parameters:  none

  Encoding considerations:  8-bit

  Security considerations:  See Section 15 in RFC 6020

  Interoperability considerations:  None

  Published specification:  RFC 6020

  Applications that use this media type:

    YANG module validators, web servers used for downloading YANG
    modules, email clients, etc.

  Additional information:

     Magic Number:  None

     File Extension:  .yang

     Macintosh file type code:  'TEXT'

  Personal and email address for further information:
     Martin Bjorklund <mbj@tail-f.com>

  Intended usage:  COMMON

  Author:
     This specification is a work item of the IETF NETMOD working group,
     with mailing list address <netmod@ietf.org>.

  Change controller:
     The IESG <iesg@ietf.org>
	    ]]></artwork>
	</figure>
</section>
<section title="Media type application/yin+xml">
	<figure>
	    <artwork><![CDATA[
  MIME media type name:  application

  MIME subtype name:  yin+xml

  Mandatory parameters:  none

  Optional parameters:

     "charset":  This parameter has identical semantics to the charset
     parameter of the "application/xml" media type as specified in
     [RFC3023].

  Encoding considerations: 

     Identical to those of "application/xml" as
     described in [RFC3023], Section 3.2.

  Security considerations:  See Section 15 in RFC 6020

  Interoperability considerations:  None

  Published specification:  RFC 6020

  Applications that use this media type:

    YANG module validators, web servers used for downloading YANG
    modules, email clients, etc.

  Additional information:

     Magic Number:  As specified for "application/xml" in [RFC3023],
                    Section 3.2.

     File Extension:  .yin

     Macintosh file type code:  'TEXT'

  Personal and email address for further information:
     Martin Bjorklund <mbj@tail-f.com>

  Intended usage:  COMMON

  Author:
     This specification is a work item of the IETF NETMOD working group,
     with mailing list address <netmod@ietf.org>.

  Change controller:
     The IESG <iesg@ietf.org>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Security Considerations">
    <t>
This document defines a language with which to write and read
descriptions of management information. The language itself has no
security impact on the Internet.
    </t>
    <t>
The same considerations are relevant as for the base NETCONF protocol
(see <xref target="RFC4741"/>, Section 9).
    </t>
    <t>
Data modeled in YANG might contain sensitive information. RPCs
or notifications defined in YANG might transfer sensitive information.
    </t>
    <t>
Security issues are related to the usage of data modeled
in YANG. Such issues shall be dealt with in documents
describing the data models and documents about the
interfaces used to manipulate the data e.g.,
the NETCONF documents.
    </t>
    <t>
Data modeled in YANG is dependent upon:
    </t>
<t>
 <list style="symbols">
 <t>
the security of the transmission infrastructure used
to send sensitive information.
 </t>
 <t>
the security of applications that store or release
such sensitive information.
 </t>
 <t>
adequate authentication and access control mechanisms
to restrict the usage of sensitive data.
 </t>
 </list>
</t>
    <t>
YANG parsers need to be robust with respect to malformed documents.
Reading malformed documents from unknown or untrusted sources could
result in an attacker gaining privileges of the user running the YANG
parser.  In an extreme situation, the entire machine could be
compromised.
    </t>
</section>
<section title="Contributors">
    <t>
The following people all contributed significantly to the initial
YANG document:
    </t>
	<figure>
	    <artwork><![CDATA[
 - Andy Bierman (Brocade)
 - Balazs Lengyel (Ericsson)
 - David Partain (Ericsson)
 - Juergen Schoenwaelder (Jacobs University Bremen)
 - Phil Shafer (Juniper Networks)
	    ]]></artwork>
	</figure>
</section>
<section title="Acknowledgements">
    <t>
The editor wishes to thank the following individuals, who all provided
helpful comments on various versions of this document: Mehmet Ersue,
Washam Fan, Joel Halpern, Leif Johansson, Ladislav Lhotka, Gerhard
Muenz, Tom Petch, Randy Presuhn, David Reid, and Bert Wijnen.
    </t>
</section>
</middle>
<back>


  <references title="Normative References">

    <reference anchor="RFC2119">
      <front>
        <title>Key words for use in RFCs to Indicate Requirement Levels</title>
        <author initials="S." surname="Bradner" fullname="S.  Bradner">
          <organization>Harvard University</organization>
        </author>
        <date month="March" year="1997"/>
        <abstract>
          <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.</t>
        </abstract>
      </front>
      <seriesInfo name="BCP" value="14"/>
      <seriesInfo name="RFC" value="2119"/>
      <format type="TXT" octets="4723" target="ftp://ftp.isi.edu/in-notes/rfc2119.txt"/>
    </reference>

<reference anchor='RFC3023'>

<front>
<title>XML Media Types</title>
<author initials='M.' surname='Murata' fullname='M. Murata'>
<organization /></author>
<author initials='S.' surname='St. Laurent' fullname='S. St. Laurent'>
<organization /></author>
<author initials='D.' surname='Kohn' fullname='D. Kohn'>
<organization /></author>
<date year='2001' month='January' />
<abstract>
<t>This document standardizes five new media types -- text/xml, application/xml, text/xml-external-parsed-entity, application/xml- external-parsed-entity, and application/xml-dtd -- for use in exchanging network entities that are related to the Extensible Markup Language (XML).  This document also standardizes a convention (using the suffix '+xml') for naming media types outside of these five types when those media types represent XML MIME (Multipurpose Internet Mail Extensions) entities. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3023' />

</reference>


    <reference anchor="RFC3629">
      <front>
	<title>UTF-8, a transformation format of ISO 10646</title>
	<author initials="F." surname="Yergeau" fullname="F. Yergeau">
	  <organization/>
	</author>
	<date year="2003" month="November"/>
	<abstract>
	  <t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems. The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo. UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values. This memo obsoletes and replaces RFC 2279. </t>
	</abstract>
      </front>
      <seriesInfo name="STD" value="63"/>
      <seriesInfo name="RFC" value="3629"/>
      <format type="TXT" octets="33856" target="ftp://ftp.isi.edu/in-notes/rfc3629.txt"/>
    </reference>

<reference anchor="RFC3688">
  <front>
    <title>The IETF XML Registry</title>
    <author initials="M." surname="Mealling" fullname="M. Mealling">
      <organization/>
    </author>
    <date year="2004" month="January"/>
    <abstract>
      <t>This document describes an IANA maintained registry for IETF standards which use Extensible Markup Language (XML) related items such as Namespaces, Document Type Declarations (DTDs), Schemas, and Resource Description Framework (RDF) Schemas. </t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="81"/>
  <seriesInfo name="RFC" value="3688"/>
  <format type="TXT" octets="17325" target="ftp://ftp.isi.edu/in-notes/rfc3688.txt"/>
</reference>

<reference anchor="RFC3986">
  <front>
    <title abbrev="URI Generic Syntax">Uniform Resource Identifier (URI): Generic Syntax</title>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address>
        <postal>
          <street>Massachusetts Institute of Technology</street>
          <street>77 Massachusetts Avenue</street>
          <city>Cambridge</city>
          <region>MA</region>
          <code>02139</code>
          <country>USA</country>
        </postal>
        <phone>+1-617-253-5702</phone>
        <facsimile>+1-617-258-5999</facsimile>
        <email>timbl@w3.org</email>
        <uri>http://www.w3.org/People/Berners-Lee/</uri>
      </address>
    </author>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding">
      <organization abbrev="Day Software">Day Software</organization>
      <address>
        <postal>
          <street>5251 California Ave., Suite 110</street>
          <city>Irvine</city>
          <region>CA</region>
          <code>92617</code>
          <country>USA</country>
        </postal>
        <phone>+1-949-679-2960</phone>
        <facsimile>+1-949-679-2972</facsimile>
        <email>fielding@gbiv.com</email>
        <uri>http://roy.gbiv.com/</uri>
      </address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe Systems">Adobe Systems Incorporated</organization>
      <address>
        <postal>
          <street>345 Park Ave</street>
          <city>San Jose</city>
          <region>CA</region>
          <code>95110</code>
          <country>USA</country>
        </postal>
        <phone>+1-408-536-3024</phone>
        <email>LMM@acm.org</email>
        <uri>http://larry.masinter.net/</uri>
      </address>
    </author>
    <date year="2005" month="January"/>
    <area>Applications</area>
    <keyword>uniform resource identifier</keyword>
    <keyword>URI</keyword>
    <keyword>URL</keyword>
    <keyword>URN</keyword>
    <keyword>WWW</keyword>
    <keyword>resource</keyword>
    <abstract>
      <t>
A Uniform Resource Identifier (URI) is a compact sequence of characters
that identifies an abstract or physical resource.  This specification
defines the generic URI syntax and a process for resolving URI references
that might be in relative form, along with guidelines and security
considerations for the use of URIs on the Internet.
The URI syntax defines a grammar that is a superset of all valid URIs,
allowing an implementation to parse the common components of a URI
reference without knowing the scheme-specific requirements of every
possible identifier.  This specification does not define a generative
grammar for URIs; that task is performed by the individual
specifications of each URI scheme.
</t>
    </abstract>
  </front>
  <seriesInfo name="STD" value="66"/>
  <seriesInfo name="RFC" value="3986"/>
  <format type="TXT" octets="141811" target="ftp://ftp.isi.edu/in-notes/rfc3986.txt"/>
  <format type="HTML" octets="213584" target="http://xml.resource.org/public/rfc/html/rfc3986.html"/>
  <format type="XML" octets="163534" target="http://xml.resource.org/public/rfc/xml/rfc3986.xml"/>
</reference>


    <reference anchor="RFC4648">
      <front>
	<title>The Base16, Base32, and Base64 Data Encodings</title>
	<author initials="S." surname="Josefsson" fullname="S. Josefsson">
	  <organization/>
	</author>
	<date year="2006" month="October"/>
	<abstract>
	  <t>This document describes the commonly used base 64, base 32, and base 16 encoding schemes. It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings. [STANDARDS TRACK]</t>
	</abstract>
      </front>
      <seriesInfo name="RFC" value="4648"/>
      <format type="TXT" octets="35491" target="ftp://ftp.isi.edu/in-notes/rfc4648.txt"/>
    </reference>

    <reference anchor="RFC4741">
      <front>
	<title>NETCONF Configuration Protocol</title>
	<author initials="R." surname="Enns" fullname="R. Enns">
	  <organization/>
	</author>
	<date year="2006" month="December"/>
	<abstract>
	  <t>The Network Configuration Protocol (NETCONF) defined in this document provides mechanisms to install, manipulate, and delete the configuration of network devices. It uses an Extensible Markup Language (XML)-based data encoding for the configuration data as well as the protocol messages. The NETCONF protocol operations are realized on top of a simple Remote Procedure Call (RPC) layer. [STANDARDS TRACK]</t>
	</abstract>
      </front>
      <seriesInfo name="RFC" value="4741"/>
      <format type="TXT" octets="173914" target="ftp://ftp.isi.edu/in-notes/rfc4741.txt"/>
    </reference>


<reference anchor="RFC5226">
  <front>
    <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
    <author initials="T." surname="Narten" fullname="T. Narten">
      <organization/>
    </author>
    <author initials="H." surname="Alvestrand" fullname="H. Alvestrand">
      <organization/>
    </author>
    <date year="2008" month="May"/>
    <abstract>
      <t>Many protocols make use of identifiers consisting of constants and other well-known values. Even after a protocol has been defined and deployment has begun, new values may need to be assigned (e.g., for a new option type in DHCP, or a new encryption or authentication transform for IPsec). To ensure that such quantities have consistent values and interpretations across all implementations, their assignment must be administered by a central authority. For IETF protocols, that role is provided by the Internet Assigned Numbers Authority (IANA).&lt;/t&gt;&lt;t&gt; In order for IANA to manage a given namespace prudently, it needs guidelines describing the conditions under which new values can be assigned or when modifications to existing values can be made. If IANA is expected to play a role in the management of a namespace, IANA must be given clear and concise instructions describing that role. This document discusses issues that should be considered in formulating a policy for assigning values to a namespace and provides guidelines for authors on the specific text that must be included in documents that place demands on IANA.&lt;/t&gt;&lt;t&gt; This document obsoletes RFC 2434. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="26"/>
  <seriesInfo name="RFC" value="5226"/>
  <format type="TXT" octets="66160" target="ftp://ftp.isi.edu/in-notes/rfc5226.txt"/>
</reference>

<reference anchor="RFC5234">
  <front>
    <title>Augmented BNF for Syntax Specifications: ABNF</title>
    <author initials="D." surname="Crocker" fullname="D. Crocker">
      <organization/>
    </author>
    <author initials="P." surname="Overell" fullname="P. Overell">
      <organization/>
    </author>
    <date year="2008" month="January"/>
  </front>
  <seriesInfo name="STD" value="68"/>
  <seriesInfo name="RFC" value="5234"/>
  <format type="TXT" octets="26359" target="ftp://ftp.isi.edu/in-notes/rfc5234.txt"/>
</reference>

<reference anchor="RFC5277">
  <front>
    <title>NETCONF Event Notifications</title>
    <author initials="S." surname="Chisholm" fullname="S. Chisholm">
      <organization/>
    </author>
    <author initials="H." surname="Trevino" fullname="H. Trevino">
      <organization/>
    </author>
    <date year="2008" month="July"/>
    <abstract>
      <t>This document defines mechanisms that provide an asynchronous message notification delivery service for the Network Configuration protocol (NETCONF).  This is an optional capability built on top of the base NETCONF definition.  This document defines the capabilities and operations necessary to support this service. [STANDARDS TRACK]</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="5277"/>
  <format type="TXT" octets="70878" target="ftp://ftp.isi.edu/in-notes/rfc5277.txt"/>
</reference>

    <!--
	http://www.iso.org/iso/catalogue_detail.htm?csnumber=39921
    -->
    <reference anchor="ISO.10646">
      <front>
	<title>Information Technology - Universal Multiple-Octet Coded Character Set (UCS)</title>
	<author>
	  <organization>International Organization for Standardization</organization>
	</author>
	<date year="2003"/>
      </front>
      <seriesInfo name="ISO" value="Standard 10646:2003"/>
    </reference>


    <!--
	curl http://xml.resource.org/public/rfc/bibxml4/reference.W3C.REC-xml-names-20091208.xml > .ref ; xmllint -\-format .ref | grep -v '\?xml'
    -->
    <reference anchor="XML-NAMES" target="http://www.w3.org/TR/2009/REC-xml-names-20091208">
      <front>
        <title>Namespaces in XML 1.0 (Third Edition)</title>
        <author initials="D." surname="Hollander" fullname="Dave Hollander">
          <organization/>
        </author>
        <author initials="R." surname="Tobin" fullname="Richard Tobin">
          <organization/>
        </author>
        <author initials="H." surname="Thompson" fullname="Henry S. Thompson">
          <organization/>
        </author>
        <author initials="T." surname="Bray" fullname="Tim Bray">
          <organization/>
        </author>
        <author initials="A." surname="Layman" fullname="Andrew Layman">
          <organization/>
        </author>
        <date month="December" day="8" year="2009"/>
      </front>
      <seriesInfo name="World Wide Web Consortium Recommendation" value="REC-xml-names-20091208"/>
      <format type="HTML" target="http://www.w3.org/TR/2009/REC-xml-names-20091208"/>
    </reference>

    <!--
	http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html	
    -->
    <reference anchor="XSD-TYPES" target="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028">
      <front>
        <title>XML Schema Part 2: Datatypes Second Edition</title>
        <author initials="A." surname="Malhotra" fullname="Ashok Malhotra">
          <organization/>
        </author>
        <author initials="P." surname="Biron" fullname="Paul V. Biron">
          <organization/>
        </author>
        <date month="October" day="28" year="2004"/>
      </front>
      <seriesInfo name="World Wide Web Consortium Recommendation" value="REC-xmlschema-2-20041028"/>
      <format type="HTML" target="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028"/>
    </reference>

    <!-- 
    http://xml.resource.org/public/rfc/bibxml4/reference.W3C.REC-xpath-19991116.xml 
-->
    
    <reference anchor="XPATH" target="http://www.w3.org/TR/1999/REC-xpath-19991116">
      <front>
        <title>XML Path Language (XPath) Version 1.0</title>
        <author initials="J." surname="Clark" fullname="James Clark">
          <organization/>
        </author>
        <author initials="S." surname="DeRose" fullname="Steven DeRose">
          <organization/>
        </author>
        <date month="November" day="16" year="1999"/>
      </front>
      <seriesInfo name="World Wide Web Consortium Recommendation" value="REC-xpath-19991116"/>
      <format type="HTML" target="http://www.w3.org/TR/1999/REC-xpath-19991116"/>
    </reference>

  </references>

  <references title="Informative References">

    <reference anchor="RFC2578">
      <front>
	<title abbrev="SMIv2">Structure of Management Information Version 2 (SMIv2)</title>
	<author initials="K." surname="McCloghrie" fullname="Keith McCloghrie" role="editor">
	  <organization>Cisco Systems, Inc.</organization>
	  <address>
	    <postal>
	      <street>170 West Tasman Drive</street>
	      <city>San Jose</city>
	      <region>CA</region>
	      <code>95134-1706</code>
	      <country>US</country>
	    </postal>
	    <phone>+1 408 526 5260</phone>
	    <email>kzm@cisco.com</email>
	  </address>
	</author>
	<author initials="D." surname="Perkins" fullname="David Perkins" role="editor">
	  <organization>SNMPinfo</organization>
	  <address>
	    <postal>
	      <street>3763 Benton Street</street>
	      <city>Santa Clara</city>
	      <region>CA</region>
	      <code>95051</code>
	      <country>US</country>
	    </postal>
	    <phone>+1 408 221 8702</phone>
	    <email>dperkins@snmpinfo.com</email>
	  </address>
	</author>
	<author initials="J." surname="Schoenwaelder" fullname="Juergen Schoenwaelder" role="editor">
	  <organization>TU Braunschweig</organization>
	  <address>
	    <postal>
	      <street>Bueltenweg 74/75</street>
	      <street>38106 Braunschweig</street>
	      <country>DE</country>
	    </postal>
	    <phone>+49 531 3913283</phone>
	    <email>schoenw@ibr.cs.tu-bs.de</email>
	  </address>
	</author>
	<date year="1999" month="April"/>
      </front>
      <seriesInfo name="STD" value="58"/>
      <seriesInfo name="RFC" value="2578"/>
      <format type="TXT" octets="89712" target="ftp://ftp.isi.edu/in-notes/rfc2578.txt"/>
    </reference>

    <reference anchor="RFC2579">
      <front>
	<title>Textual Conventions for SMIv2</title>
	<author initials="K." surname="McCloghrie" fullname="Keith McCloghrie" role="editor">
	  <organization>Cisco Systems, Inc.</organization>
	  <address>
	    <postal>
	      <street>170 West Tasman Drive</street>
	      <city>San Jose</city>
	      <region>CA</region>
	      <code>95134-1706</code>
	      <country>US</country>
	    </postal>
	    <phone>+1 408 526 5260</phone>
	    <email>kzm@cisco.com</email>
	  </address>
	</author>
	<author initials="D." surname="Perkins" fullname="David Perkins" role="editor">
	  <organization>SNMPinfo</organization>
	  <address>
	    <postal>
	      <street>3763 Benton Street</street>
	      <city>Santa Clara</city>
	      <region>CA</region>
	      <code>95051</code>
	      <country>US</country>
	    </postal>
	    <phone>+1 408 221 8702</phone>
	    <email>dperkins@snmpinfo.com</email>
	  </address>
	</author>
	<author initials="J." surname="Schoenwaelder" fullname="Juergen Schoenwaelder" role="editor">
	  <organization>TU Braunschweig</organization>
	  <address>
	    <postal>
	      <street>Bueltenweg 74/75</street>
	      <street>38106 Braunschweig</street>
	      <country>DE</country>
	    </postal>
	    <phone>+49 531 3913283</phone>
	    <email>schoenw@ibr.cs.tu-bs.de</email>
	  </address>
	</author>
	<date year="1999" month="April"/>
      </front>
      <seriesInfo name="STD" value="58"/>
      <seriesInfo name="RFC" value="2579"/>
      <format type="TXT" octets="59039" target="ftp://ftp.isi.edu/in-notes/rfc2579.txt"/>
    </reference>

    <reference anchor="RFC3780">
      <front>
	<title>SMIng - Next Generation Structure of Management Information</title>
	<author initials="F." surname="Strauss" fullname="F. Strauss">
	  <organization/>
	</author>
	<author initials="J." surname="Schoenwaelder" fullname="J. Schoenwaelder">
	  <organization/>
	</author>
	<date year="2004" month="May"/>
	<abstract>
	  <t>This memo defines the base SMIng (Structure of Management Information, Next Generation) language. SMIng is a data definition language that provides a protocol-independent representation for management information. Separate RFCs define mappings of SMIng to specific management protocols, including SNMP. This memo defines an Experimental Protocol for the Internet community. </t>
	</abstract>
      </front>
      <seriesInfo name="RFC" value="3780"/>
      <format type="TXT" octets="141049" target="ftp://ftp.isi.edu/in-notes/rfc3780.txt"/>
    </reference>

<reference anchor="RFC4844">
  <front>
    <title>The RFC Series and RFC Editor</title>
    <author initials="L." surname="Daigle" fullname="L. Daigle">
      <organization/>
    </author>
    <author>
      <organization>Internet Architecture Board</organization>
    </author>
    <date year="2007" month="July"/>
    <abstract>
      <t>This document describes the framework for an RFC Series and an RFC Editor function that incorporate the principles of organized community involvement and accountability that has become necessary as the Internet technical community has grown, thereby enabling the RFC Series to continue to fulfill its mandate.  This memo provides information for the Internet community.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="4844"/>
  <format type="TXT" octets="38752" target="ftp://ftp.isi.edu/in-notes/rfc4844.txt"/>
</reference>


    <!--
    http://xml.resource.org/public/rfc/bibxml4/reference.W3C.REC-xslt-19991116.xml
    -->
    <reference anchor="XSLT" target="http://www.w3.org/TR/1999/REC-xslt-19991116">
      <front>
        <title>XSL Transformations (XSLT) Version 1.0</title>
        <author initials="J." surname="Clark" fullname="James Clark">
          <organization/>
          </author>
          <date month="November" day="16" year="1999"/>
          </front>
          <seriesInfo name="World Wide Web Consortium Recommendation" value="REC-xslt-19991116"/>
          <format type="HTML" target="http://www.w3.org/TR/1999/REC-xslt-19991116"/>
    </reference>

    <!--
        http://xml.resource.org/public/rfc/bibxml4/reference.W3C.CR-xpath20-20060608.xml
    -->
<reference anchor="XPATH2.0" target="http://www.w3.org/TR/2007/REC-xpath20-20070123">
  <front>
    <title>XML Path Language (XPath) 2.0</title>
    <author initials="A." surname="Berglund" fullname="Anders Berglund">
      <organization/>
    </author>
    <author initials="S." surname="Boag" fullname="Scott Boag">
      <organization/>
    </author>
    <author initials="D." surname="Chamberlin" fullname="Don Chamberlin">
      <organization/>
    </author>
    <author initials="M." surname="Fernandez" fullname="Mary F. Fernandez">
      <organization/>
    </author>
    <author initials="M." surname="Kay" fullname="Michael Kay">
      <organization/>
    </author>
    <author initials="J." surname="Robie" fullname="Jonathan Robie">
      <organization/>
    </author>
    <author initials="J." surname="Simeon" fullname="Jerome Simeon">
      <organization/>
    </author>
    <date month="January" day="23" year="2007"/>
  </front>
  <seriesInfo name="World Wide Web Consortium Recommendation" value="REC-xpath20-20070123"/>
  <format type="HTML" target="http://www.w3.org/TR/2007/REC-xpath20-20070123"/>
</reference>


  </references>

</back></rfc>
