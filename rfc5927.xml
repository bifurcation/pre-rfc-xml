<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc rfcedstyle="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc    
category="info"
ipr="pre5378Trust200902"
number="5927" >

<front>
<title>ICMP Attacks against TCP</title>

<author
    fullname="Fernando Gont"
    initials="F."
    surname="Gont">
    <organization abbrev="UTN/FRH">Universidad Tecnologica Nacional / Facultad Regional Haedo</organization>
    <address>
        <postal>
         <street>Evaristo Carriego 2644</street>
		<code>1706</code><city>Haedo</city>
		<region>Provincia de Buenos Aires</region>
		<country>Argentina</country>
        </postal>
        <phone>+54 11 4650 8472</phone>
        <email>fernando@gont.com.ar</email>
		<uri>http://www.gont.com.ar</uri>
    </address>
</author>    

<date month="July" year="2010"/> 
<area>Transport</area>
<workgroup>TCP Maintenance and Minor Extensions (tcpm)</workgroup>

<keyword>vulnerability</keyword>
<keyword>blind attacks</keyword>
<keyword>connection-reset attack</keyword>
<keyword>performance-degrading attack</keyword>
<keyword>throughput-reduction attack</keyword>
<keyword>source quench</keyword>
<keyword>PMTUD</keyword>
<keyword>Path-MTU Discovery</keyword>
<keyword>ICMP Destination Unreachable</keyword>

<!-- [rfced] Please note that after you have approved the document,
post-xml2rfc changes will be made to update the header and boilerplate as
described in RFC 5741. -->

 <abstract>     <t>
This document discusses the use of the Internet Control Message Protocol (ICMP)
to perform a variety of attacks against the Transmission Control Protocol
(TCP).  Additionally, this document describes a number of widely implemented modifications to TCP's handling of ICMP error messages that help to mitigate these issues.
</t>
 </abstract>
</front>  

<middle> 

<section title="Introduction">

<t>
ICMP <xref target="RFC0792"/> <xref target="RFC4443"/> is a fundamental part of the TCP/IP protocol
suite, and is used mainly for reporting network error conditions.  However, the
current specifications do not recommend any kind of validation checks on the
received ICMP error messages, thus allowing a variety of attacks against TCP
<xref target="RFC0793"/> by means of ICMP, which include blind
connection-reset, blind throughput-reduction, and blind performance-degrading
attacks.  All of these attacks can be performed even when the attacker is off-path, without
the need to sniff the packets that correspond to the attacked TCP connection. 

</t>

<t>
While the possible security implications of ICMP have been known in the
research community for a long time, there has never been an official proposal
on how to deal with these vulnerabilities.  In 2005, a disclosure process was
carried out by the UK's National Infrastructure Security Co-ordination Centre
(NISCC) (now CPNI, Centre for the Protection of National Infrastructure), with
the collaboration of other computer emergency response teams.  A large number
of implementations were found vulnerable to either all or a subset of the
attacks discussed in this document <xref target="NISCC"/><xref
target="US-CERT"/>.  The affected systems ranged from TCP/IP implementations
meant for desktop computers, to TCP/IP implementations meant for core Internet
routers. 
</t>

<t>It is clear that implementations should be more cautious when processing ICMP error messages, to eliminate or mitigate the use of ICMP to perform attacks against TCP <xref target="RFC4907"/>.</t>

<t>This document aims to raise awareness of the use of ICMP to perform a variety of attacks against TCP, and discusses several counter-measures that eliminate or minimize the impact of these attacks.  Most of the these counter-measures can be implemented while still remaining compliant with the current specifications, as they simply describe reasons for not taking the advice provided in the specifications in terms of "SHOULDs", but still comply with the requirements stated as "MUSTs". 
</t>
<t>
We note that the counter-measures discussed in this document are not part of standard TCP behavior, and this document does not change that state of affairs.  The consensus of the TCPM WG (TCP Maintenance and Minor Extensions Working Group) was to document this widespread implementation of nonstandard TCP behavior but to not change the TCP standard.
</t>

<t>
<xref target="backgroundinfo"/> provides background information on ICMP.  <xref target="constraints"/> discusses the constraints in the general counter-measures that can be implemented against the attacks described in this document.  <xref target="solutions"/> describes several general validation checks that can be implemented to mitigate any ICMP-based attack. 
Finally, <xref target="resetattack"/>, <xref target="sourcequenchattack"/>, and <xref target="pmtudattack"/>, discuss a variety of ICMP attacks that can be performed against TCP, and describe attack-specific counter-measures that eliminate or greatly mitigate their impact.
</t>

<t>
 The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
 NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
 "OPTIONAL" in this document are to be interpreted as described in
 RFC 2119 <xref target="RFC2119"/>.
</t>
</section>

<section title="Background" anchor="backgroundinfo">

<section title="The Internet Control Message Protocol (ICMP)">
<t>
The Internet Control Message Protocol (ICMP) is used in the Internet architecture mainly to perform the fault-isolation function, that is, the group of actions that hosts and routers take to determine that there is some
network failure <xref target="RFC0816"/>.
</t>

<t>
When an intermediate router detects a network problem while trying to forward
an IP packet, it will usually send an ICMP error message to the source system,
to inform the source system of the network problem taking place.  In the same
way, there are a number of scenarios in which an end-system may generate an
ICMP error message if it finds a problem while processing a datagram.  The
received ICMP errors are handed to the corresponding transport-protocol
instance, which will usually perform a fault recovery function. 
</t>

<t>It is important to note that ICMP error messages are transmitted unreliably
and may be discarded due to data corruption, network congestion, or
rate-limiting.  Thus, while they provide useful information, upper-layer
protocols cannot depend on ICMP for correct operation.</t> 

<t>It should be noted that there are no timeliness requirements for ICMP error
messages.  ICMP error messages could be delayed for various reasons, and at
least in theory could be received with an arbitrarily long delay.  For example,
there are no existing requirements that a router flush any queued ICMP error
messages when it is rebooted.</t> 


<section title="ICMP for IP version 4 (ICMPv4)" anchor="icmpv4">

<t>
<xref target="RFC0792"/> specifies the Internet Control Message Protocol (ICMP) to be used with the Internet Protocol version 4 (IPv4) -- henceforth "ICMPv4".  It defines, among other things, a number of error messages that can be used by end-systems and intermediate systems to report errors to the sending system.  The Host Requirements RFC <xref target="RFC1122"/> classifies ICMPv4 error messages into those that indicate "soft errors", and those that indicate "hard errors", thus roughly defining the semantics of them.
</t>

<t>The ICMPv4 specification <xref target="RFC0792"/> also defines the ICMPv4 Source Quench message (type 4, code 0), which is meant to provide a mechanism for flow control and congestion control. 
</t>

<t><xref target="RFC1191"/> defines a mechanism called "Path MTU Discovery" (PMTUD), which makes use of ICMPv4 error messages of type 3 (Destination Unreachable), code 4 (fragmentation needed and DF bit set) to allow systems to determine the MTU of an arbitrary internet path. 
</t>

<t>Finally, <xref target="RFC4884"/> redefines selected ICMPv4 messages to include an extension structure and a length attribute, such that those ICMPv4 messages can carry additional information by encoding that information in the extension structure.</t>


<t>Appendix D of <xref target="RFC4301"/> provides information about which ICMPv4 error messages are produced by hosts, intermediate routers, or both.
</t>
</section>

<section title="ICMP for IP version 6 (ICMPv6)" anchor="icmpv6">

<t>
<xref target="RFC4443"/> specifies the Internet Control Message Protocol (ICMPv6) to be used with the Internet Protocol version 6 (IPv6) <xref target="RFC2460"/>.
</t>
<t>
<xref target="RFC4443"/> defines the "Packet Too Big" (type 2, code 0) error
message, which is analogous to the ICMPv4 "fragmentation needed and DF bit set" (type 3, code 4) error message.  <xref target="RFC1981"/> defines the Path MTU Discovery mechanism for IP version 6, which makes use of these messages to determine the MTU of an arbitrary internet path.
</t>

<t>Finally, <xref target="RFC4884"/> redefines selected ICMPv6 messages to include an extension structure and a length attribute, such that those ICMPv6 messages can carry additional information by encoding that information in the extension structure.</t>

<t>Appendix D of <xref target="RFC4301"/> provides information about which ICMPv6 error messages are produced by hosts, intermediate routers, or both.
</t>

</section>
</section>

<section title="Handling of ICMP Error Messages" anchor="handling">

<t>
The Host Requirements RFC <xref target="RFC1122"/> states in Section 4.2.3.9 that TCP MUST act on an ICMP error message passed up from the IP
layer, directing it to the connection that triggered the error.
</t>
<t>
In order to allow ICMP messages to be demultiplexed by the receiving system, part of the original packet that triggered the message is included in the payload of the ICMP error message.  Thus, the receiving system can use that information to match the ICMP error to the transport protocol instance that triggered it.
</t>

<t>
Neither the Host Requirements RFC <xref target="RFC1122"/> nor the original TCP specification <xref target="RFC0793"/> recommends any validation checks on the received ICMP messages.  Thus, as long as the ICMP payload contains the information that identifies an existing communication instance, it will be processed by the corresponding transport-protocol instance, and the corresponding action will be performed.
</t>
<t>
Therefore, in the case of TCP, an attacker could send a crafted ICMP error message to the attacked system, and, as long as he is able to guess the four-tuple (i.e., Source IP Address, Source TCP port, Destination IP Address, and Destination TCP port) that identifies the communication instance to be attacked, he will be able to use ICMP to perform a variety of attacks.
</t>

<t>Generally, the four-tuple required to perform these attacks is not known.  However, as discussed in <xref target="Watson"/> and <xref target="RFC4953"/>, there are a number of scenarios (notably that of TCP connections established between two BGP routers <xref target="RFC4271"/>) in which an attacker may be able to know or guess the four-tuple that identifies a TCP connection.  In such a case, if we assume the attacker knows the two systems involved in the TCP connection to be attacked, both the client-side and the server-side IP addresses could be known or be within a reasonable number of possibilities.  Furthermore, as most Internet services use the so-called "well-known" ports, only the client port number might need to be guessed.  In such a scenario, an attacker would need to send, in principle, at most 65536 packets to perform any of the attacks described in this document.  These issues are exacerbated by the fact that most systems choose the port numbers they use for outgoing connections from a subset of the whole port number space, thus reducing the amount of work needed to successfully perform these attacks.</t>

<t>
The need to be more cautious when processing received ICMP error messages in
order to mitigate or eliminate the impact of the attacks described in this RFC has been documented by the Internet Architecture Board (IAB) in <xref target="RFC4907"/>.
</t>
</section>

<section title="Handling of ICMP Error Messages in the Context of IPsec" anchor="IPsec">
<t>Section 5.2 of <xref target="RFC4301"/> describes the processing of inbound
IP traffic in the case of "unprotected-to-protected".  In the case of ICMP,
when an unprotected ICMP error message is received, it is matched to the
corresponding security association by means of the SPI (Security Parameters
Index) included in the payload of the ICMP error message.  Then, local policy
is applied to determine whether to accept or reject the message and, if
accepted, what action to take as a result.  For example, if an ICMP Destination Unreachable
message is received, the implementation must decide whether to act on it,
reject it, or act on it with constraints.  


Section 8 ("Path MTU/DF Processing")
discusses the processing of unauthenticated ICMPv4 "fragmentation needed and DF
bit set" (type 3, code 4) 
and ICMPv6 "Packet Too Big" (type 2, code 0) messages
when an IPsec implementation is configured to process (vs. ignore) such
messages.</t> 

<t>Section 6.1.1 of <xref target="RFC4301"/> notes that processing of unauthenticated ICMP error messages may result in denial or degradation of service, and therefore it would be desirable to ignore such messages.  However, it also notes that in many cases, ignoring these ICMP messages can degrade service, e.g., because of a failure to process PMTUD and redirection messages, and therefore there is also a motivation for accepting and acting upon them.  It finally states that to accommodate both ends of this spectrum, a compliant IPsec implementation MUST permit a local administrator to configure an IPsec implementation to accept or reject unauthenticated ICMP traffic, and that this control MUST be at the granularity of ICMP type and MAY be at the granularity of ICMP type and code.  Additionally, an implementation SHOULD incorporate mechanisms and parameters for dealing with such traffic.</t>
<t>Thus, the policy to apply for the processing of unprotected ICMP error messages is left up to the implementation and administrator.</t>
</section>

</section>

<section title="Constraints in the Possible Solutions" anchor="constraints">
<t>If a host wants to perform validation checks on the received ICMP error
messages before acting on them, it is limited by the piece of the packet that
triggered the error that the sender of the ICMP error message chose to include in the ICMP payload.  This constrains the possible validation checks, as the number of bytes of the packet that triggered the error message that is included in the ICMP payload is limited.</t>

<t>
For ICMPv4, <xref target="RFC0792"/> states that the IP header plus the first 64&nbsp;bits of the packet that triggered the ICMPv4 message are to be included in the payload of the ICMPv4 error message.  Thus, it is assumed that all data needed to identify a transport protocol instance and process the ICMPv4 error message is contained in the first 64 bits of the transport protocol header.  Section 3.2.2 of <xref target="RFC1122"/> states that "the Internet header and at least the first 8 data octets of the datagram that triggered the error" are to be included in the payload of ICMPv4 error messages, and that "more than 8 octets MAY be sent", thus allowing implementations to include more data from the original packet than those required by the original ICMPv4 specification.  The "Requirements for IP Version 4 Routers" RFC <xref target="RFC1812"/> states that ICMPv4 error messages "SHOULD contain as much of the original datagram as possible without the length of the ICMP datagram exceeding 576&nbsp;bytes".
</t>

<t>Thus, for ICMPv4 messages generated by hosts, we can only expect to get the entire IP header of the original packet, plus the first 64&nbsp;bits of its payload.  For TCP, this means that the only fields that will be included in the ICMPv4 payload are the source port number, the destination port number, and the 32-bit TCP sequence number.  This clearly imposes a constraint on the possible validation checks that can be performed, as there is not much information available on which to perform them.</t>

<t>This means, for example, that even if TCP were signing its segments by means of the TCP MD5 signature option <xref target="RFC2385"/>, this mechanism could not be used as a counter-measure against ICMP-based attacks, because, as ICMP messages include only a piece of the TCP segment that triggered the error, the MD5 <xref target="RFC1321"/> signature could not be recalculated.  In the same way, even if the attacked peer were authenticating its packets at the IP layer <xref target="RFC4301"/>, because only a part of the original IP packet would be available, the signature used for authentication could not be recalculated, and thus the authentication header in the original packet could not be used as a counter-measure for ICMP-based attacks against TCP.</t>

<t><xref target="RFC4884"/> updated <xref target="RFC0792"/> and specified that
ICMPv4 Destination Unreachable (type 3), Time Exceeded (type 11), and Parameter
Problem (type 12) messages that have an ICMP Extension Structure appended include at least 128 octets in the "original datagram" field.  This would improve the situation, but at the time of this writing, <xref target="RFC4884"/> is not yet widely deployed for end-systems.
</t>

<t>For IPv6, the payload of ICMPv6 error messages includes as many octets from the IPv6 packet that triggered the ICMPv6 error message as will fit without making the resulting ICMPv6 error message exceed the minimum IPv6 MTU (1280 octets) <xref target="RFC4443"/>.  Thus, more information is available than in the IPv4 case.
</t>

<t>
Hosts could require ICMP error messages to be authenticated <xref target="RFC4301"/>, in order to act upon them.  However, while this requirement could make sense for those ICMP error messages sent by hosts, it would not be feasible for those ICMP error messages generated by routers, as this would imply either that the attacked system should have a security association <xref target="RFC4301"/> with every existing intermediate system, or that it should be able to establish one dynamically.  Current levels of deployment of protocols for dynamic establishment of security associations makes this unfeasible.   Additionally, this would require routers to use certificates with paths compatible for all hosts on the network.  Finally, there may be some scenarios, such as embedded devices, in which the processing power requirements of authentication might not allow IPsec authentication to be implemented effectively.
</t>
</section>

<section title="General Counter-Measures against ICMP Attacks" anchor="solutions">
<t>
The following subsections describe a number of mitigation techniques that help to eliminate or mitigate the impact of the attacks discussed in this document.  Rather than being alternative counter-measures, they can be implemented together to increase the protection against these attacks.
</t>

<section title="TCP Sequence Number Checking" anchor="TCPseqchecking">
<t>The current specifications do not impose any validity checks on the TCP segment that is contained in the ICMP payload.  For instance, no checks are performed to verify that a received ICMP error message has been triggered by a segment that was "in flight" to the destination.  Thus, even stale ICMP error messages will be acted upon.
</t>

<t>
Many TCP implementations have incorporated a validation check such that they
react only to those ICMP error messages that appear to relate to segments
currently "in flight" to the destination system.  These implementations check that the TCP sequence number contained in the payload of the ICMP error message is within the range SND.UNA =&lt; SEG.SEQ &lt; SND.NXT.  This means that they require that the sequence number be within the range of the data already sent but not yet acknowledged.  If an ICMP error message does not pass this check, it is discarded.
</t>

<t>
Even if an attacker were able to guess the four-tuple that identifies the TCP connection, this additional check would reduce the possibility of considering a spoofed ICMP packet as valid to Flight_Size/2^^32 (where Flight_Size is the number of data bytes already sent to the remote peer, but not yet acknowledged <xref target="RFC5681"/>).  For connections in the SYN-SENT or SYN-RECEIVED states, this would reduce the possibility of considering a spoofed ICMP packet as valid to 1/2^^32.  For a TCP endpoint with no data "in flight", this would completely eliminate the possibility of success of these attacks.
</t>

<t>This validation check has been implemented in Linux <xref target="Linux"/> for many years, in OpenBSD <xref target="OpenBSD"/> since 2004, and in FreeBSD <xref target="FreeBSD"/> and NetBSD <xref target="NetBSD"/> since 2005.
</t>

<t>It is important to note that while this check greatly increases the number of packets required to perform any of the attacks discussed in this document, this may not be enough in those scenarios in which bandwidth is easily available and/or large TCP windows <xref target="RFC1323"/> are in use.  Additionally, this validation check does not help to prevent on-path attacks, that is, attacks performed in scenarios in which the attacker can sniff the packets that correspond to the target TCP connection.</t>

<t>It should be noted that, as there are no timeliness requirements for ICMP error messages, the TCP Sequence Number check described in this section might cause legitimate ICMP error messages to be discarded.  Also, even if this check is enforced, TCP might end up responding to stale ICMP error messages (e.g., if the Sequence Number for the corresponding direction of the data transfer wraps around).</t>

</section>


<section title="Port Randomization" anchor="portrandomization">
<t>
As discussed in the previous sections, in order to perform any of the attacks described in this document, an attacker would need to guess (or know) the four-tuple that identifies the connection to be attacked.  Increasing the port number range used for outgoing TCP connections, and randomizing the port number chosen for each outgoing TCP connection, would make it harder for an attacker to perform any of the attacks discussed in this document.
</t>
<t><xref target="PORT-RANDOM"/> recommends that transport protocols randomize the ephemeral ports used by clients, and proposes a number of randomization algorithms.
</t>
</section>

<section title="Filtering ICMP Error Messages Based on the ICMP Payload" anchor="filtering">
<t>
The source address of ICMP error messages does not need to be spoofed to perform the attacks described in this document, as the ICMP error messages might legitimately come from an intermediate system.  Therefore, simple filtering based on the source address of ICMP error messages does not serve as a counter-measure against these attacks.  However, a more advanced packet filtering can be implemented in middlebox devices such as firewalls and NATs.  Middleboxes implementing such advanced filtering look at the payload of the ICMP error messages, and perform ingress and egress packet filtering based on the source address of the IP header contained in the payload of the ICMP error message.  As the source address contained in the payload of the ICMP error message does need to be spoofed to perform the attacks described in this document, this kind of advanced filtering serves as a counter-measure against these attacks.  As with traditional egress filtering <xref target="IP-filtering"/>, egress filtering based on the ICMP payload can help to prevent users of the network being protected by the firewall from successfully performing ICMP attacks against TCP connections established between external systems.  Additionally, ingress filtering based on the ICMP payload can prevent TCP connections established between internal systems from being attacked by external systems.  <xref target="ICMP-Filtering"/> provides examples of ICMP filtering based on the ICMP payload.</t>
<t>
This filtering technique has been implemented in OpenBSD's Packet Filter <xref target="OpenBSD-PF"/>, which has in turn been ported to a number of systems, including FreeBSD <xref target="FreeBSD"/>.
</t>
</section>

</section>




<section title="Blind Connection-Reset Attack" anchor="resetattack">
<section title="Description" anchor="resetdescription">

<t>
When TCP is handed an ICMP error message, it will perform its fault recovery function, as follows:
</t>

<t>
<list style="symbols">
<t>
If the network problem being reported is a "hard error", TCP will abort the corresponding connection.
</t>
<t>
If the network problem being reported is a "soft error", TCP will just record this information, and repeatedly retransmit its data until they either get acknowledged, or the connection times out.
</t>
</list>
</t>

<t>
The Host Requirements RFC <xref target="RFC1122"/> states (in Section 4.2.3.9) that a host SHOULD abort the corresponding connection when receiving an ICMPv4 error message that indicates a "hard error", and states that ICMPv4 error messages of type 3 (Destination Unreachable), codes 2 (protocol unreachable), 3 (port unreachable), and 4 (fragmentation needed and DF bit set) should be considered as indicating "hard errors".  In the case of ICMPv4 port unreachables, the specifications are ambiguous, as Section 4.2.3.9 of <xref target="RFC1122"/> states that TCP SHOULD abort the corresponding connection in response to them, but Section&nbsp;3.2.2.1 of the same RFC (<xref target="RFC1122"/>) states that TCP MUST abort the connection in response to them.</t>

<t>While <xref target="RFC4443"/> did not exist when <xref target="RFC1122"/> was published, one could extrapolate the concept of "hard errors" to ICMPv6 error messages of type 1 (Destination Unreachable), codes 1 (communication with destination administratively prohibited), and 4 (port unreachable).
</t>
<t>
Thus, an attacker could use ICMP to perform a blind connection-reset attack by sending any ICMP error message that indicates a "hard error" to either of the two TCP endpoints of the connection.  Because of TCP's fault recovery policy, the connection would be immediately aborted. 
</t>
<t>
Some stacks are known to extrapolate ICMP "hard errors" across TCP connections, increasing the impact of this attack, as a single ICMP packet could bring down all the TCP connections between the corresponding peers.
</t>

<t>
It is important to note that even if TCP itself were protected against the
blind connection-reset attack described in <xref target="Watson"/> and <xref
target="TCPM-TCPSECURE"/> by means of authentication at the network layer <xref
target="RFC4301"/>, by means of the TCP MD5 signature option <xref
target="RFC2385"/>, by means of the TCP-AO <xref target="RFC5925"/>,
<!-- <xref target="TCP-AUTH-OPT"/> --> or by means of the mechanism specified in <xref target="TCPM-TCPSECURE"/>, the blind connection-reset attack described in this document would still succeed.
</t>

</section>
<section title="Attack-Specific Counter-Measures" anchor="connresetcountermeasures">

<t>An analysis of the circumstances in which ICMP messages that indicate "hard
errors" may be received can shed some light on opportunities to mitigate the impact of ICMP-based blind connection-reset attacks.</t>

<t>
<list style="hanging">
<t hangText="ICMPv4 type 3 (Destination Unreachable), code 2 (protocol unreachable)"><vspace blankLines="1"/>
This ICMP error message indicates that the host sending the ICMP error message received a packet meant for a transport protocol it does not support.  For connection-oriented protocols such as TCP, one could expect to receive such an error as the result of a connection-establishment attempt.  However, it would be strange to get such an error during the life of a connection, as this would indicate that support for that transport protocol has been removed from the system sending the error message during the life of the corresponding connection.
</t>

<t hangText="ICMPv4 type 3 (Destination Unreachable), code 3 (port unreachable)"><vspace blankLines="1"/>
This error message indicates that the system sending the ICMP error message
received a packet meant for a socket (IP address, port number) on which there
is no process listening.  Those transport protocols that have their own
mechanisms for signaling this condition should not be receiving these error
messages, as the protocol would signal the port unreachable condition by means
of its own mechanisms.  

Assuming that once a connection is established it is not
usual for the transport protocol to change (or be reloaded), it should be
unusual to get these error messages. 
</t>

<t hangText="ICMPv4 type 3 (Destination Unreachable), code 4 (fragmentation needed and DF bit set)"><vspace blankLines="1"/>
This error message indicates that an intermediate node needed to fragment a datagram, but the DF (Don't Fragment) bit in the IP header was set.  It is considered a "soft error" when TCP implements PMTUD, and a "hard error" if TCP does not implement PMTUD.  Those TCP/IP stacks that do not implement PMTUD (or have disabled it) but support IP fragmentation/reassembly should not be sending their IP packets with the DF bit set, and thus should not be receiving these ICMP error messages.  Some TCP/IP stacks that do not implement PMTUD and that do not support IP fragmentation/reassembly are known to send their packets with the DF bit set, and thus could legitimately receive these ICMP error messages.</t>

<t hangText="ICMPv6 type 1 (Destination Unreachable), code 1 (communication with destination
administratively prohibited) 
"><vspace blankLines="1"/>
This error message indicates that the destination is unreachable because of an administrative policy.  For connection-oriented protocols such as TCP, one could expect to receive such an error as the result of a connection-establishment attempt.  Receiving such an error for a connection in any of the synchronized states would mean that the administrative policy changed during the life of the connection.  However, in the same way this error condition (which was not present when the connection was established) appeared, it could get solved in the near term.
</t>

<t hangText="ICMPv6 type 1 (Destination Unreachable), code 4 (port unreachable)"><vspace blankLines="1"/>
This error message is analogous to the ICMPv4 type 3 (Destination Unreachable), code 3 (port unreachable) error message discussed above.  Therefore, the same considerations apply. 
</t>
</list>
</t>
<t>
The Host Requirements RFC <xref target="RFC1122"/> states in Section 4.2.3.9 that TCP SHOULD abort the corresponding connection in response to ICMPv4 messages of type 3 (Destination Unreachable), codes 2 (protocol unreachable), 3 (port unreachable), and 4 (fragmentation needed and DF bit set).  However, Section 3.2.2.1 states that TCP MUST accept an ICMPv4 port unreachable (type 3, code 3) for the same purpose as a RST.  Therefore, for ICMPv4 messages of type 3, codes 2 and 4, there is room to go against the advice provided in the existing specifications, while in the case of ICMPv4 messages of type 3, code&nbsp;3, there is ambiguity in the specifications that may or may not provide some room to go against that advice. </t>

<t>Based on this analysis, most popular TCP implementations treat all ICMP
"hard errors" received for connections in any of the synchronized states
(ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, or
TIME-WAIT) as "soft errors".  That is, they do not abort the corresponding
connection upon receipt of them.  Additionally, they do not extrapolate ICMP
errors across TCP connections.  This policy is based on the premise that TCP
should be as robust as possible.  Aborting the connection would be to ignore
the valuable feature of the Internet -- that for many internal failures, it reconstructs its function without any disruption of the endpoints <xref target="RFC0816"/>.</t>

<t>It should be noted that treating ICMP "hard errors" as "soft errors" for connections in any of the synchronized states may prevent TCP from responding quickly to a legitimate ICMP error message.</t>

<t>It is interesting to note that, as ICMP error messages are transmitted unreliably, transport protocols should not depend on them for correct functioning.  In the event one of these messages were legitimate, the corresponding connection would eventually time out.  Also, applications may still be notified asynchronously about the error condition, and thus may still abort their connections on their own if they consider it appropriate.
</t>

<t>In scenarios such as that in which an intermediate system sets the DF bit in
the segments transmitted by a TCP that does not implement PMTUD, or the TCP at
one of the endpoints of the connection is dynamically disabled, TCP would only
abort the connection after a USER TIMEOUT <xref target="RFC0793"/>, losing
responsiveness.  However, these scenarios are very unlikely in production
environments, and it is probably preferable to potentially lose responsiveness
for the sake of robustness.  It should also be noted that applications may
still be notified asynchronously about the error condition, and thus may still
abort their connections on their own if they consider it appropriate.</t> 

<t>In scenarios of multipath routing or route changes, failures in some (but
not all) of the paths may elicit ICMP error messages that would likely not
cause a connection abort if any of the counter-measures described in this
section were implemented.  However, aborting the connection would be to ignore
the valuable feature of the Internet -- that for many internal failures, it reconstructs its function without any disruption of the endpoints <xref target="RFC0816"/>.  That is, communication should survive if there is still a working path to the destination system <xref target="DClark"/>.  Additionally, applications may still be notified asynchronously about the error condition, and thus may still abort their connections on their own if they consider it appropriate.
</t>

<t>This counter-measure has been implemented in BSD-derived TCP/IP implementations (e.g., <xref target="FreeBSD"/>, <xref target="NetBSD"/>, and <xref target="OpenBSD"/>) for more than ten years <xref target="Wright"/><xref target="McKusick"/>.  The Linux kernel has also implemented this policy for more than ten years <xref target="Linux"/>.</t>

</section>

</section>

<section title="Blind Throughput-Reduction Attack" anchor="sourcequenchattack">
<section title="Description">
<t>
The Host Requirements RFC <xref target="RFC1122"/> states in Section 4.2.3.9 that hosts MUST react to ICMPv4 Source Quench messages by slowing transmission on the connection.  Thus, an attacker could send ICMPv4 Source Quench (type 4, code 0) messages to a TCP endpoint to make it reduce the rate at which it sends data to the other endpoint of the connection.  <xref target="RFC1122"/> further adds that the RECOMMENDED procedure is to put the corresponding connection in the slow-start phase of TCP's congestion control algorithm <xref target="RFC5681"/>.  In the case of those implementations that use an initial congestion window of one segment, a sustained attack would reduce the throughput of the attacked connection to about SMSS (Sender Maximum Segment Size) <xref target="RFC5681"/> bytes per RTT (round-trip time).  The throughput achieved during an attack might be a little higher if a larger initial congestion window is in use <xref target="RFC3390"/>.
</t>
</section>
<section title="Attack-Specific Counter-Measures"
anchor="sourcequenchcountermeasures">

<t>
As discussed in the "Requirements for IP Version 4 Routers" RFC <xref
target="RFC1812"/>, research seems to suggest that ICMPv4 Source Quench messages are an
ineffective (and unfair) antidote for congestion.  
<xref target="RFC1812"/> further states that routers SHOULD NOT send ICMPv4
Source Quench messages in response to congestion.  Furthermore, TCP implements
its own congestion control mechanisms (<xref target="RFC5681"/> <xref
target="RFC3168"/>) that do not depend on ICMPv4 Source Quench messages.</t> 
<t>Based on this reasoning, a large number of implementations completely ignore
ICMPv4 Source Quench messages meant for TCP connections.  This behavior has been
implemented in, at least, Linux <xref target="Linux"/> since 2004, and in
FreeBSD <xref target="FreeBSD"/>, NetBSD <xref target="NetBSD"/>, and OpenBSD
<xref target="OpenBSD"/> since 2005.  However, it must be noted that this
behavior violates the requirement in <xref target="RFC1122"/> to react to ICMPv4
Source Quench messages by slowing transmission on the connection. 
</t>

</section>
</section>

<section title="Blind Performance-Degrading Attack" anchor="pmtudattack">
<section title="Description" anchor="pmtudescription">
<t>
When one IP system has a large amount of data to send to another system, the data will be transmitted as a series of IP datagrams.  It is usually preferable that these datagrams be of the largest size that does not require fragmentation anywhere along the path from the source to the destination.  This datagram size is referred to as the Path MTU (PMTU) and is equal to the minimum of the MTUs of each hop in the path.  A technique called "Path MTU Discovery" (PMTUD) lets IP systems determine the Path MTU of an arbitrary internet path.  <xref target="RFC1191"/> and <xref target="RFC1981"/> specify the PMTUD mechanism for IPv4 and IPv6, respectively.
</t>
<t>
The PMTUD mechanism for IPv4 uses the Don't Fragment (DF) bit in the IP header to dynamically discover the Path MTU.  The basic idea behind the PMTUD mechanism is that a source system assumes that the MTU of the path is that of the first hop, and sends all its datagrams with the DF bit set.  If any of the datagrams is too large to be forwarded without fragmentation by some intermediate router, the router will discard the corresponding datagram and will return an ICMPv4 "Destination Unreachable, fragmentation needed and DF set" (type 3, code 4) error message to the sending system.  This message will report the MTU of the constricting hop, so that the sending system can reduce the assumed Path-MTU accordingly.
</t>
<t>For IPv6, intermediate systems do not fragment packets.  Thus, there's an
"implicit" DF bit set in every packet sent on a network.  If any of the
datagrams is too large to be forwarded without fragmentation by some
intermediate router, the router will discard the corresponding datagram, and
will return an ICMPv6 "Packet Too Big" (type 2, code 0) error message to the sending system.  This message will report the MTU of the constricting hop, so that the sending system can reduce the assumed Path-MTU accordingly.
</t>

<t>As discussed in both <xref target="RFC1191"/> and <xref target="RFC1981"/>, the Path-MTU Discovery mechanism can be used to attack TCP.  An attacker could send a crafted ICMPv4 "Destination Unreachable, fragmentation needed and DF set" packet (or their ICMPv6 counterpart) to the sending system, advertising a small Next-Hop MTU.  As a result, the attacked system would reduce the size of the packets it sends for the corresponding connection accordingly.
</t>

<t>The effect of this attack is two-fold.  On one hand, it will increase the headers/data ratio, thus increasing the overhead needed to send data to the remote TCP endpoint.  On the other hand, if the attacked system wanted to keep the same throughput it was achieving before being attacked, it would have to increase the packet rate.  On virtually all systems, this will lead to an increased processing overhead, thus degrading the overall system performance.
</t>

<t>A particular scenario that may take place is one in which an attacker reports a Next-Hop MTU smaller than or equal to the amount of bytes needed for headers (IP header, plus TCP header).  For example, if the attacker reports a Next-Hop MTU of 68 bytes, and the amount of bytes used for headers (IP header, plus TCP header) is larger than 68&nbsp;bytes, the assumed Path-MTU will not even allow the attacked system to send a single byte of application data without fragmentation.  This particular scenario might lead to unpredictable results.  Another possible scenario is one in which a TCP connection is being secured by means of IPsec.  If the Next-Hop MTU reported by the attacker is smaller than the amount of bytes needed for headers (IP and IPsec, in this case), the assumed Path-MTU will not even allow the attacked system to send a single byte of the TCP header without fragmentation.  This is another scenario that may lead to unpredictable results.
</t>


<t>For IPv4, the reported Next-Hop MTU could be as small as 68 octets, as <xref target="RFC0791"/> requires every internet module to be able to forward a datagram of 68 octets without further fragmentation.  For IPv6, while the required minimum IPv6 MTU is 1280, the reported Next-Hop MTU can be smaller than 1280 octets <xref target="RFC2460"/>.  If the reported Next-Hop MTU is smaller than the minimum IPv6 MTU, the receiving host is not required to reduce the Path-MTU to a value smaller than 1280, but is required to include a fragmentation header in the outgoing packets to that destination from that moment on. 
</t>

</section>

<section title="Attack-Specific Counter-Measures" anchor="pmtudfix">
<t>The IETF has standardized a Path-MTU Discovery mechanism called "Packetization Layer Path MTU Discovery" (PLPMTUD) that does not depend on ICMP error messages.  Implementation of the aforementioned mechanism in replacement of the traditional PMTUD (specified in <xref target="RFC1191"/> and <xref target="RFC1981"/>) eliminates this vulnerability.  However, it can also lead to an increase in PMTUD convergence time.</t>
<t>
This section describes a modification to the PMTUD mechanism specified in <xref target="RFC1191"/> and <xref target="RFC1981"/> that has been incorporated in OpenBSD and NetBSD (since 2005) to improve TCP's resistance to the blind performance-degrading attack described in <xref target="pmtudescription"/>.  The described counter-measure basically disregards ICMP messages when a connection makes progress, without violating any of the requirements stated in <xref target="RFC1191"/> and <xref target="RFC1981"/>.
</t>
<t>
Henceforth, we will refer to both ICMPv4 "fragmentation needed and DF bit set" and ICMPv6 "Packet Too Big" messages as "ICMP Packet Too Big" messages.
</t>
<t>
In addition to the general validation check described in <xref target="TCPseqchecking"/>, these implementations include a modification to TCP's reaction to ICMP "Packet Too Big" error messages that disregards them when a connection makes progress, and honors them only after the corresponding data have been retransmitted a specified number of times.  This means that upon receipt of an ICMP "Packet Too Big" error message, TCP just records this information, and honors it only when the corresponding data have already been retransmitted a specified number of times.
</t>

<t>While this basic policy would greatly mitigate the impact of the attack against the PMTUD mechanism, it would also mean that it might take TCP more time to discover the Path-MTU for a TCP connection.  This would be particularly annoying for connections that have just been established, as it might take TCP several transmission attempts (and the corresponding timeouts) before it discovers the PMTU for the corresponding connection.  Thus, this policy would increase the time it takes for data to begin to be received at the destination host.</t>

<t>
In order to protect TCP from the attack against the PMTUD mechanism, while still allowing TCP to quickly determine the initial Path-MTU for a connection, the aforementioned implementations have divided the traditional PMTUD mechanism into two stages: Initial Path-MTU Discovery and Path-MTU Update.
</t>

<t>
The Initial Path-MTU Discovery stage is when TCP tries to send segments that are larger than the ones that have so far been sent and acknowledged for this connection.
That is, in the Initial Path-MTU Discovery stage, TCP has no record of these large segments getting to the destination host, and thus these implementations believe the network when it reports that these packets are too large to reach the destination host without being fragmented.
</t>

<t>
The Path-MTU Update stage is when TCP tries to send segments that are equal to or smaller than the ones that have already been sent and acknowledged for this connection.  During the Path-MTU Update stage, TCP already has knowledge of the estimated Path-MTU for the given connection.  Thus, in this case, these implementations are more cautious with the errors being reported by the network.
</t>

<t>
In order to allow TCP to distinguish segments between those performing Initial Path-MTU Discovery and those performing Path-MTU Update, two new variables are introduced to TCP: maxsizesent and maxsizeacked.
</t>

<t>
The maxsizesent variable holds the size (in octets) of the largest packet that has so far been sent for this connection.  It is initialized to 68 (the minimum IPv4 MTU) when the underlying Internet Protocol is IPv4, and is initialized to 1280 (the minimum IPv6 MTU) when the underlying Internet Protocol is IPv6.  Whenever a packet larger than maxsizesent octets is sent, maxsizesent is set to that value.
</t>
<t>On the other hand, maxsizeacked holds the size (in octets) of the largest packet (data, plus headers) that has so far been acknowledged for this connection.  It is initialized to 68 (the minimum IPv4 MTU) when the underlying Internet Protocol is IPv4, and is initialized to 1280 (the minimum IPv6 MTU) when the underlying Internet Protocol is IPv6.  Whenever an acknowledgement for a packet larger than maxsizeacked octets is received, maxsizeacked is set to the size of that acknowledged packet.  Note that because of TCP's cumulative acknowledgement, a single ACK may acknowledge the receipt of more than one packet.  When that happens, the algorithm may "incorrectly" assume it is in the "Path-MTU Update" stage, rather than the "Initial Path-MTU Discovery" stage (as described below).
</t>

<t>
Upon receipt of an ICMP "Packet Too Big" error message, the Next-Hop MTU claimed by the ICMP message (henceforth "claimedmtu") is compared with maxsizesent.  If claimedmtu is larger than maxsizesent, then the ICMP error message is silently discarded.  The rationale for this is that the ICMP error message cannot be legitimate if it claims to have been triggered by a packet larger than the largest packet we have so far sent for this connection.</t>

<t>
If this check is passed, claimedmtu is compared with maxsizeacked.  If claimedmtu is equal to or larger than maxsizeacked, TCP is supposed to be at the Initial Path-MTU Discovery stage, and thus the ICMP "Packet Too Big" error message is honored immediately.  That is, the assumed Path-MTU is updated according to the Next-Hop MTU claimed in the ICMP error message.  Also, maxsizesent is reset to the minimum MTU of the Internet Protocol in use (68 for IPv4, and 1280 for IPv6).
</t>

<t>
On the other hand, if claimedmtu is smaller than maxsizeacked, TCP is supposed to be in the Path-MTU Update stage.  At this stage, these implementations are more cautious with the errors being reported by the network, and therefore just record the received error message, and delay the update of the assumed Path-MTU.
</t>

<t>To perform this delay, one new variable and one new parameter are introduced
to TCP: nsegrto and MAXSEGRTO. The nsegrto variable holds the number of times a specified
segment has timed out.  It is initialized to zero, and is incremented by one
every time the corresponding segment times out.  MAXSEGRTO specifies the number
of times a given segment must time out before an ICMP "Packet Too Big" error message can be honored, and can be set, in principle, to any value greater than or equal to&nbsp;0.
</t>

<t>Thus, if nsegrto is greater than or equal to MAXSEGRTO, and there's a pending ICMP "Packet Too Big" error message, the corresponding error message is processed.  At that point, maxsizeacked is set to claimedmtu, and maxsizesent is set to 68 (for IPv4) or 1280 (for IPv6).</t>

<t>If, while there is a pending ICMP "Packet Too Big" error message, the TCP SEQ claimed by the pending message is acknowledged (i.e., an ACK that acknowledges that sequence number is received), then the "pending error" condition is cleared.
</t>



<t>The rationale behind performing this delayed processing of ICMP "Packet Too Big" messages is that if there is progress on the connection, the ICMP "Packet Too Big" errors must be a false claim.  By checking for progress on the connection, rather than just for staleness of the received ICMP messages, TCP is protected from attack even if the offending ICMP messages are "in window", and as a corollary, is made more robust to spurious ICMP messages triggered by, for example, corrupted TCP segments.
</t>


<t>
MAXSEGRTO can be set, in principle, to any value greater than or equal to 0.  Setting MAXSEGRTO to 0 would make TCP perform the traditional PMTUD mechanism defined in <xref target="RFC1191"/> and <xref target="RFC1981"/>.  A MAXSEGRTO of 1 provides enough protection for most cases.  In any case, implementations are free to choose higher values for this constant.  MAXSEGRTO could be a function of the Next-Hop MTU claimed in the received ICMP "Packet Too Big" message.  That is, higher values for MAXSEGRTO could be imposed when the received ICMP "Packet Too Big" message claims a Next-Hop MTU that is smaller than some specified value.  Both OpenBSD and NetBSD set MAXSEGRTO to 1.
</t>

<t>In the event a higher level of protection is desired at the expense of a higher delay in the discovery of the Path-MTU, an implementation could consider TCP to always be in the Path-MTU Update stage, thus always delaying the update of the assumed Path-MTU.
</t>

<t><xref target="pmtudfixinaction"/> shows this counter-measure in action.  <xref target="pseudocode"/> shows this counter-measure in pseudo-code. </t>

<t>
It is important to note that the mechanism described in this section is an improvement to the current Path-MTU discovery mechanism, to mitigate its security implications.  The current PMTUD mechanism, as specified by <xref target="RFC1191"/> and <xref target="RFC1981"/>, still suffers from some functionality problems <xref target="RFC2923"/> that this document does not aim to address.  A mechanism that addresses those issues is described in <xref target="RFC4821"/>.
</t>
</section>

<section title="The Counter-Measure for the PMTUD Attack in Action" anchor="pmtudfixinaction">
<t>
This section illustrates the operation of the counter-measure for the ICMP attack against the PMTUD mechanism that has been implemented in OpenBSD and NetBSD.  It shows both how the fix protects TCP from being attacked and how the counter-measure works in normal scenarios.  As discussed in <xref target="pmtudfix"/>, this section assumes the PMTUD-specific counter-measure is implemented in addition to the TCP sequence number checking described in <xref target="TCPseqchecking"/>.
</t>
<t><xref target="scenario"/> illustrates a hypothetical scenario in which two hosts are connected by means of three intermediate routers.  It also shows the MTU of each hypothetical hop.  All the following subsections assume the network setup of this figure.</t>
<t>Also, for simplicity's sake, all subsections assume an IP header of 20&nbsp;octets and a TCP header of 20 octets.  Thus, for example, when the PMTU is assumed to be 1500 octets, TCP will send segments that contain, at most, 1460 octets of data.</t>
<t>For simplicity's sake, all the following subsections assume the TCP implementation at Host 1 (H1) has chosen a MAXSEGRTO of 1.
</t>

<figure title="Hypothetical Scenario" anchor="scenario">
<artwork>
+----+        +----+        +----+        +----+        +----+
| H1 |--------| R1 |--------| R2 |--------| R3 |--------| H2 |
+----+        +----+        +----+        +----+        +----+
      MTU=4464      MTU=2048      MTU=1500      MTU=4464
</artwork>
<postamble></postamble>
</figure>

<section title="Normal Operation for Bulk Transfers" anchor="normalop">
<t>This subsection shows the counter-measure in normal operation, when a TCP connection is used for bulk transfers.  That is, it shows how the counter-measure works when there is no attack taking place and a TCP connection is used for transferring large amounts of data.  This section assumes that just after the connection is established, one of the TCP endpoints begins to transfer data in packets that are as large as possible.
</t>

<figure title="Normal Operation for Bulk Transfers" anchor="bulktransferfig">
<artwork>
    Host 1                                       Host 2

1.    --&gt;            &lt;SEQ=100&gt;&lt;CTL=SYN&gt;           --&gt;
2.    &lt;--      &lt;SEQ=X&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;      &lt;--
3.    --&gt;       &lt;SEQ=101&gt;&lt;ACK=X+1&gt;&lt;CTL=ACK&gt;       --&gt;
4.    --&gt; &lt;SEQ=101&gt;&lt;ACK=X+1&gt;&lt;CTL=ACK&gt;&lt;DATA=4424&gt;  --&gt;
5.       &lt;--- ICMP "Packet Too Big" MTU=2048, TCPseq#=101 &lt;--- R1
6.    --&gt; &lt;SEQ=101&gt;&lt;ACK=X+1&gt;&lt;CTL=ACK&gt;&lt;DATA=2008&gt;  --&gt;
7.       &lt;--- ICMP "Packet Too Big" MTU=1500, TCPseq#=101 &lt;--- R2
8.    --&gt; &lt;SEQ=101&gt;&lt;ACK=X+1&gt;&lt;CTL=ACK&gt;&lt;DATA=1460&gt;  --&gt;
9.    &lt;--      &lt;SEQ=X+1&gt;&lt;ACK=1561&gt;&lt;CTL=ACK&gt;       &lt;--
</artwork>
<postamble></postamble>
</figure>

<t>The nsegrto variable is initialized to zero.  Both maxsizeacked and maxsizesent are
initialized to the minimum MTU for the Internet Protocol being used (68 for IPv4, and 1280 for IPv6).
</t>
<t>
In lines 1 to 3, the three-way handshake takes place, and the connection is established.  In line 4, H1 tries to send a full-sized TCP segment.  As described by <xref target="RFC1191"/> and <xref target="RFC1981"/>, in this case, TCP will try to send a segment with 4424 bytes of data, which will result in an IP packet of 4464 octets.  Therefore, maxsizesent is set to 4464.  When the packet reaches R1, it elicits an ICMP "Packet Too Big" error message.</t>
<t>
In line 5, H1 receives the ICMP error message, which reports a Next-Hop MTU of 2048 octets.  After performing the TCP sequence number check described in <xref target="TCPseqchecking"/>, the Next-Hop MTU reported by the ICMP error message (claimedmtu) is compared with maxsizesent.  As it is smaller than maxsizesent, it passes the check, and thus is then compared with maxsizeacked.  As claimedmtu is larger than maxsizeacked, TCP assumes that the corresponding TCP segment was performing the Initial PMTU Discovery.  Therefore, the TCP at H1 honors the ICMP message by updating the assumed Path-MTU.  The maxsizesent variable is reset to the minimum MTU of the Internet Protocol in use (68 for IPv4, and 1280 for IPv6). 
</t>
<t>In line 6, the TCP at H1 sends a segment with 2008 bytes of data, which results in an IP packet of 2048 octets.  The maxsizesent variable is thus set to 2008 bytes.  When the packet reaches R2, it elicits an ICMP "Packet Too Big" error message.
</t>
<t>
In line 7, H1 receives the ICMP error message, which reports a Next-Hop MTU of 1500 octets.  After performing the TCP sequence number check, the Next-Hop MTU reported by the ICMP error message (claimedmtu) is compared with maxsizesent.  As it is smaller than maxsizesent, it passes the check, and thus is then compared with maxsizeacked.  As claimedmtu is larger than maxsizeacked, TCP assumes that the corresponding TCP segment was performing the Initial PMTU Discovery.  Therefore, the TCP at H1 honors the ICMP message by updating the assumed Path-MTU.  The maxsizesent variable is reset to the minimum MTU of the Internet Protocol in use.
</t>
<t>In line 8, the TCP at H1 sends a segment with 1460 bytes of data, which results in an IP packet of 1500 octets.  Thus, maxsizesent is set to 1500.  This packet reaches H2, where it elicits an acknowledgement (ACK) segment.
</t>
<t>In line 9, H1 finally gets the acknowledgement for the data segment.  As the corresponding packet was larger than maxsizeacked, TCP updates maxsizeacked, setting it to 1500.  At this point, TCP has discovered the Path-MTU for this TCP connection.
</t>
</section>

<section title="Operation during Path-MTU Changes" anchor="pmtuchanges">
<t>
Let us suppose a TCP connection between H1 and H2 has already been established, and that the PMTU for the connection has already been discovered to be 1500.  At this point, both maxsizesent and maxsizeacked are equal to 1500, and nsegrto is equal to 0.  Suppose some time later the PMTU decreases to 1492.  For simplicity, let us suppose that the Path-MTU has decreased because the MTU of the link between R2 and R3 has decreased from 1500 to 1492.  <xref target="pmtuchangesfig"/> illustrates how the counter-measure would work in this scenario.
</t>

<figure title="Operation during Path-MTU Changes" anchor="pmtuchangesfig">
<artwork>
    Host 1                                       Host 2

1.                   (Path-MTU decreases)
2.    --&gt;  &lt;SEQ=100&gt;&lt;ACK=X&gt;&lt;CTL=ACK&gt;&lt;DATA=1460&gt;   --&gt;
3.       &lt;--- ICMP "Packet Too Big" MTU=1492, TCPseq#=100 &lt;--- R2
4.                   (Segment times out)
5.    --&gt;  &lt;SEQ=100&gt;&lt;ACK=X&gt;&lt;CTL=ACK&gt;&lt;DATA=1452&gt;   --&gt;
6.    &lt;--        &lt;SEQ=X&gt;&lt;ACK=1552&gt;&lt;CTL=ACK&gt;       &lt;--
</artwork>
<postamble></postamble>
</figure>

<t>In line 1, the Path-MTU for this connection decreases from 1500 to 1492.  In line 2, the TCP at H1, without being aware of the Path-MTU change, sends a 1500-byte packet to H2.  When the packet reaches R2, it elicits an ICMP "Packet Too Big" error message.
</t>
<t>
In line 3, H1 receives the ICMP error message, which reports a Next-Hop MTU of
1492 octets.  After performing the TCP sequence number check, the Next-Hop MTU
reported by the ICMP error message (claimedmtu) is compared with maxsizesent.
As claimedmtu is smaller than maxsizesent, it is then compared with
maxsizeacked.  As claimedmtu is smaller than maxsizeacked (full-sized packets
were getting to the remote endpoint), this packet is assumed to be performing
Path-MTU Update, and a "pending error" condition is recorded.
</t>
<t>In line 4, the segment times out.  Thus, nsegrto is incremented by 1.
As nsegrto is greater than or equal to MAXSEGRTO, the assumed Path-MTU is updated.  The nsegrto variable is reset to 0, maxsizeacked is set to claimedmtu, and maxsizesent is set to the minimum MTU of the Internet Protocol in use.
</t>
<t>In line 5, H1 retransmits the data using the updated PMTU, and thus maxsizesent is set to 1492.  The resulting packet reaches H2, where it elicits an acknowledgement (ACK) segment.
</t>
<t>In line 6, H1 finally gets the acknowledgement for the data segment.  At this point, TCP has discovered the new Path-MTU for this TCP connection.
</t>

</section>

<section title="Idle Connection Being Attacked">
<t>Let us suppose a TCP connection between H1 and H2 has already been established, and the PMTU for the connection has already been discovered to be 1500.
<xref target="idleconnfig"/> shows a sample time-line diagram that illustrates an idle connection being attacked. 
</t>

<figure title="Idle Connection Being Attacked" anchor="idleconnfig">
<artwork>
    Host 1                                       Host 2

1.    --&gt;   &lt;SEQ=100&gt;&lt;ACK=X&gt;&lt;CTL=ACK&gt;&lt;DATA=50&gt;    --&gt;
2.    &lt;--        &lt;SEQ=X&gt;&lt;ACK=150&gt;&lt;CTL=ACK&gt;        &lt;--
3.       &lt;--- ICMP "Packet Too Big" MTU=68, TCPseq#=100 &lt;---
4.       &lt;--- ICMP "Packet Too Big" MTU=68, TCPseq#=100 &lt;---
5.       &lt;--- ICMP "Packet Too Big" MTU=68, TCPseq#=100 &lt;---
</artwork>
<postamble></postamble>
</figure>

<t>In line 1, H1 sends its last bunch of data.  In line 2, H2 acknowledges the
receipt of these data.  Then the connection becomes idle.  In lines 3, 4, and
5, an attacker sends forged ICMP "Packet Too Big" error messages to H1.
Regardless of how many packets it sends and of the TCP sequence number each ICMP packet includes, none of these ICMP error messages will pass the TCP sequence number check described in <xref target="TCPseqchecking"/>, as H1 has no unacknowledged data "in flight" to H2.  Therefore, the attack does not succeed.
</t>
</section>
<section title="Active Connection Being Attacked after Discovery of the Path-MTU">
<t>Let us suppose an attacker attacks a TCP connection for which the PMTU has already been discovered.  In this case, as illustrated in <xref target="scenario"/>, the PMTU would be found to be 1500 bytes.  <xref target="activeconnfig"/> shows a possible packet exchange.</t>

<figure title="Active Connection Being Attacked after Discovery of PMTU" anchor="activeconnfig">
<artwork>
    Host 1                                       Host 2

1.    --&gt;  &lt;SEQ=100&gt;&lt;ACK=X&gt;&lt;CTL=ACK&gt;&lt;DATA=1460&gt;   --&gt;
2.    --&gt;  &lt;SEQ=1560&gt;&lt;ACK=X&gt;&lt;CTL=ACK&gt;&lt;DATA=1460&gt;  --&gt;
3.    --&gt;  &lt;SEQ=3020&gt;&lt;ACK=X&gt;&lt;CTL=ACK&gt;&lt;DATA=1460&gt;  --&gt;
4.    --&gt;  &lt;SEQ=4480&gt;&lt;ACK=X&gt;&lt;CTL=ACK&gt;&lt;DATA=1460&gt;  --&gt;
5.       &lt;--- ICMP "Packet Too Big" MTU=68, TCPseq#=100 &lt;---
6.    &lt;--       &lt;SEQ=X&gt;&lt;CTL=ACK&gt;&lt;ACK=1560&gt;        &lt;--
</artwork>
<postamble></postamble>
</figure>

<t>As we assume the PMTU has already been discovered, we also assume both maxsizesent and maxsizeacked are equal to 1500.  We assume nsegrto is equal to zero, as there have been no segment timeouts.
</t>
<t>In lines 1, 2, 3, and 4, H1 sends four data segments to H2.  In line&nbsp;5, an attacker sends a forged ICMP error message to H1.  We assume the attacker is lucky enough to guess both the four-tuple that identifies the connection and a valid TCP sequence number.  As the Next-Hop MTU claimed in the ICMP "Packet Too Big" message (claimedmtu) is smaller than maxsizeacked, this packet is assumed to be performing Path-MTU Update.  Thus, the error message is recorded. 
</t>
<t>In line 6, H1 receives an acknowledgement for the segment sent in line 1, before it times out.  At this point, the "pending error" condition is cleared, and the recorded ICMP "Packet Too Big" error message is ignored.  Therefore, the attack does not succeed.
</t>
</section>

<section title="TCP Peer Attacked when Sending Small Packets Just after the Three-Way Handshake" anchor="attackhandshake">
<t>This section analyzes a scenario in which a TCP peer that is sending small segments just after the connection has been established is attacked.  The connection could be in use by protocols such as SMTP <xref target="RFC5321"/> and HTTP <xref target="RFC2616"/>, for example, which usually behave like this.
</t>
<t>
<xref target="attackhandshakefig"/> shows a possible packet exchange for such a
scenario.
</t>

<figure title="TCP Peer Attacked when Sending Small Packets Just&nbsp;after&nbsp;the&nbsp;Three-Way Handshake" anchor="attackhandshakefig">
<artwork>
    Host 1                                       Host 2

1.    --&gt;           &lt;SEQ=100&gt;&lt;CTL=SYN&gt;            --&gt;
2.    &lt;--      &lt;SEQ=X&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;      &lt;--
3.    --&gt;       &lt;SEQ=101&gt;&lt;ACK=X+1&gt;&lt;CTL=ACK&gt;       --&gt;
4.    --&gt;  &lt;SEQ=101&gt;&lt;ACK=X+1&gt;&lt;CTL=ACK&gt;&lt;DATA=100&gt;  --&gt;
5.    &lt;--       &lt;SEQ=X+1&gt;&lt;ACK=201&gt;&lt;CTL=ACK&gt;       &lt;--
6.    --&gt;  &lt;SEQ=201&gt;&lt;ACK=X+1&gt;&lt;CTL=ACK&gt;&lt;DATA=100&gt;  --&gt;
7.    --&gt;  &lt;SEQ=301&gt;&lt;ACK=X+1&gt;&lt;CTL=ACK&gt;&lt;DATA=100&gt;  --&gt;
8.       &lt;--- ICMP "Packet Too Big" MTU=150, TCPseq#=201 &lt;--- 
</artwork>
<postamble></postamble>
</figure>

<t>The nsegrto variable is initialized to zero.  Both maxsizesent and maxsizeacked are initialized to the minimum MTU for the Internet Protocol being used (68 for IPv4, and 1280 for IPv6). 
</t>
<t>
In lines 1 to 3, the three-way handshake takes place, and the connection is established.  At this point, the assumed Path-MTU for this connection is 4464.  In line 4, H1 sends a small segment (which results in a 140-byte packet) to H2.  Therefore, maxsizesent is set to 140.  In line 5, this segment is acknowledged, and thus maxsizeacked is set to 140.
</t>

<t>In lines 6 and 7, H1 sends two small segments to H2.  In line 8, while the segments from lines 6 and 7 are still "in flight" to H2, an attacker sends a forged ICMP "Packet Too Big" error message to H1.  Assuming the attacker is lucky enough to guess a valid TCP sequence number, this ICMP message will pass the TCP sequence number check.  The Next-Hop MTU reported by the ICMP error message (claimedmtu) is then compared with maxsizesent.  As claimedmtu is larger than maxsizesent, the ICMP error message is silently discarded.  Therefore, the attack does not succeed.
</t>
</section>

</section>

<section title="Pseudo-Code for the Counter-Measure for the Blind Performance-Degrading Attack" anchor="pseudocode">
<t>This section contains a pseudo-code version of the counter-measure described in <xref target="pmtudfix"/> for the blind performance-degrading attack described in <xref target="pmtudattack"/>.  It is meant as guidance for developers on how to implement this counter-measure.
</t>

<t>The pseudo-code makes use of the following variables, constants, and functions:
</t>

<list style="hanging">
<t hangText="ack"><vspace blankLines="0"/>Variable holding the acknowledgement number contained in the TCP segment that has just been received.</t>
<t hangText="acked_packet_size"><vspace blankLines="0"/>Variable holding the
packet size (data, plus headers) that the ACK that has just been received is acknowledging.</t> 
<t hangText="adjust_mtu()"><vspace blankLines="0"/>Function that adjusts the MTU for this connection, according to the ICMP "Packet Too Big" that was last received.</t> 
<t hangText="claimedmtu"><vspace blankLines="0"/>Variable holding the Next-Hop MTU advertised by the ICMP "Packet Too Big" error message.</t>
<t hangText="claimedtcpseq"><vspace blankLines="0"/>Variable holding the TCP sequence number contained in the payload of the ICMP "Packet Too Big" message that has just been received or was last recorded.</t>
<t hangText="current_mtu"><vspace blankLines="0"/>Variable holding the assumed Path-MTU for this connection.</t>
<t hangText="drop_message()"><vspace blankLines="0"/>Function that performs the necessary actions to drop the ICMP message being processed.</t>
<t hangText="initial_mtu"><vspace blankLines="0"/>Variable holding the MTU for new connections, as explained in <xref target="RFC1191"/> and <xref target="RFC1981"/>.</t> 
<t hangText="maxsizeacked"><vspace blankLines="0"/>Variable holding the largest packet size (data, plus headers) that has so far been acked for this connection, as explained in <xref target="pmtudfix"/>.</t>
<t hangText="maxsizesent"><vspace blankLines="0"/>Variable holding the largest packet size (data, plus headers) that has so far been sent for this connection, as explained in <xref target="pmtudfix"/>.</t>
<t hangText="nsegrto"><vspace blankLines="0"/>Variable holding the number of times this segment has timed out, as explained in <xref target="pmtudfix"/>.</t>  
<t hangText="packet_size"><vspace blankLines="0"/>Variable holding the size of the IP datagram being sent.</t> 
<t hangText="pending_message"><vspace blankLines="0"/>Variable (flag) that indicates whether there is a pending ICMP "Packet Too Big" message to be processed.</t> 
<t hangText="save_message()"><vspace blankLines="0"/>Function that records the ICMP "Packet Too Big" message that has just been received.</t>
<t hangText="MINIMUM_MTU"><vspace blankLines="0"/>Constant holding the minimum MTU for the Internet Protocol in use (68 for IPv4, and 1280 for IPv6).</t> 
<t hangText="MAXSEGRTO"><vspace blankLines="0"/>Constant holding the number of
times a given segment must time out before an ICMP "Packet Too Big" error message can be honored.</t>
</list>

<figure>
<artwork>
EVENT: New TCP connection

 current_mtu = initial_mtu;
 maxsizesent = MINIMUM_MTU;
 maxsizeacked = MINIMUM_MTU;
 nsegrto = 0;
 pending_message = 0;

EVENT: Segment is sent

 if (packet_size &gt; maxsizesent)
      maxsizesent = packet_size;

EVENT: Segment is received

 if (acked_packet_size &gt; maxsizeacked)
      maxsizeacked = acked_packet_size;

 if (pending_message)
      if (ack &gt; claimedtcpseq){
           pending_message = 0;
           nsegrto = 0;
      }

EVENT: ICMP "Packet Too Big" message is received

 if (claimedmtu &lt;= MINIMUM_MTU)
      drop_message();

 if (claimedtcpseq &lt; SND.UNA || claimedtcpseq &gt;= SND.NXT)
      drop_message();

 else {
      if (claimedmtu &gt; maxsizesent || claimedmtu &gt;= current_mtu)
           drop_message();

      else {
           if (claimedmtu &gt; maxsizeacked){
                adjust_mtu();
                current_mtu = claimedmtu;
                maxsizesent = MINIMUM_MTU;
           }

           else {
                pending_message = 1;
                save_message();
           }
      }
 }

EVENT: Segment times out

 nsegrto++;

 if (pending_message && nsegrto &gt;= MAXSEGRTO){
      adjust_mtu();
      nsegrto = 0;
      pending_message = 0;
      maxsizeacked = claimedmtu;
      maxsizesent = MINIMUM_MTU;
      current_mtu = claimedmtu;
 }
</artwork>
</figure>

<t>
<list style="hanging">
<t hangText="Notes:"><vspace blankLines="0"/>All comparisons between sequence numbers must be performed using sequence number arithmetic.<vspace blankLines="0"/>
<vspace blankLines="1"/>
The pseudo-code implements the mechanism described in <xref target="pmtudfix"/>, the TCP sequence number checking described in <xref target="TCPseqchecking"/>, and the validation check on the advertised Next-Hop MTU described in <xref target="RFC1191"/> and <xref target="RFC1981"/>.
</t>
</list>
</t>
</section>

</section>
<section title="Security Considerations">
<t>
This document describes the use of ICMP error messages to perform a number of
attacks against TCP, and describes a number of widely implemented counter-measures that either eliminate or reduce the impact of these attacks when they are performed by off-path attackers.
</t>

<t><xref target="TCPseqchecking"/> describes a validation check that could be
enforced on ICMP error messages, such that TCP reacts only to those ICMP error
messages that appear to relate to segments currently "in flight" to the destination system.  This requires more effort on the side of an off-path attacker at the expense of possible reduced responsiveness to network errors.</t>

<t><xref target="portrandomization"/> describes how randomization of TCP ephemeral ports requires more effort on the side of the attacker to successfully exploit any of the attacks described in this document.</t>

<t><xref target="filtering"/> describes how ICMP error messages could possibly be filtered based on their payload, to prevent users of the local network from successfully performing attacks against third-party connections.  This is analogous to ingress filtering and egress filtering of IP packets <xref target="IP-filtering"/>.</t>

<t><xref target="connresetcountermeasures"/> describes an attack-specific counter-measure for the blind connection-reset attack.  It describes the processing of ICMP "hard errors" as "soft errors" when they are received for connections in any of the synchronized states.  This counter-measure eliminates the aforementioned vulnerability in synchronized connections at the expense of possible reduced responsiveness in some network scenarios.</t>

<t><xref target="sourcequenchcountermeasures"/> describes an attack-specific
counter-measure for the blind throughput-reduction attack.  It suggests that
the aforementioned vulnerability can be eliminated by ignoring ICMPv4 Source
Quench messages meant for TCP connections.  This is in accordance with research
results that indicate that ICMPv4 Source Quench messages are ineffective and are
an unfair antidote for congestion.</t>

<t>Finally, <xref target="pmtudfix"/> describes an attack-specific counter-measure for the blind performance-degrading attack.  It consists of the validation check described in <xref target="TCPseqchecking"/>, with a modification that makes TCP react to ICMP "Packet Too Big" error messages such that they are processed when an outstanding TCP segment times out.  This counter-measure parallels the Packetization Layer Path MTU Discovery (PLPMTUD) mechanism <xref target="RFC4821"/>.  It should be noted that if this counter-measure is implemented, in some scenarios TCP may respond more slowly to valid ICMP "Packet Too Big" error messages.</t>

<t>A discussion of these and other attack vectors for performing similar attacks against TCP (along with possible counter-measures) can be found in <xref target="CPNI-TCP"/> and <xref target="TCP-SECURITY"/>.</t>
</section>

<section title="Acknowledgements">
<t>
This document was inspired by Mika Liljeberg, while discussing some issues related to <xref target="RFC5461"/> by private e-mail.  The author would like to thank (in alphabetical order): Bora Akyol, Mark Allman, Ran Atkinson, James Carlson, Alan Cox, Theo de Raadt, Wesley Eddy, Lars Eggert, Ted Faber, Juan Fraschini, Markus Friedl, Guillermo Gont, John Heffner, Alfred Hoenes, Vivek Kakkar, Michael Kerrisk, Mika Liljeberg, Matt Mathis, David Miller, Toby Moncaster, Miles Nordin, Eloy Paris, Kacheong Poon, Andrew Powell, Pekka Savola, Donald Smith, Pyda Srisuresh, Fred Templin, and Joe Touch for contributing many valuable comments.
</t>

<t>Juan Fraschini and the author of this document implemented freely available audit tools to help vendors audit their systems by reproducing the attacks discussed in this document.  These tools are available at http://www.gont.com.ar/tools/index.html.
</t>

<t>Markus Friedl, Chad Loder, and the author of this document produced and tested in OpenBSD <xref target="OpenBSD"/> the first implementation of the counter-measure described in <xref target="pmtudfix"/>.  This first implementation helped to test the effectiveness of the ideas introduced in this document, and has served as a reference implementation for other operating systems.
</t>

<t>The author would like to thank the UK's Centre for the Protection of
National Infrastructure (CPNI) -- formerly the National Infrastructure Security Co-ordination Centre (NISCC) -- for coordinating the disclosure of these issues with a large number of vendors and CSIRTs (Computer Security Incident Response Teams).
</t>

<t>
The author wishes to express deep and heartfelt gratitude
to Jorge Oscar Gont and Nelida Garcia, for their precious motivation
and guidance.
</t>
</section>

</middle>

<back>
<references title="Normative References">
	<?rfc include="reference.RFC.0791" ?>
	<?rfc include="reference.RFC.0792" ?>
	<?rfc include="reference.RFC.0793" ?>
	<?rfc include="reference.RFC.2119" ?>
	<?rfc include="reference.RFC.1122" ?>
	<?rfc include="reference.RFC.1191" ?>
	<?rfc include="reference.RFC.1812" ?>
	<?rfc include="reference.RFC.1981" ?>
	<?rfc include="reference.RFC.4301" ?>
	<?rfc include="reference.RFC.2460" ?>
	<?rfc include="reference.RFC.4443" ?>
	<?rfc include="reference.RFC.4884" ?>
</references>
<references title="Informative References">
	<?rfc include="reference.RFC.0816" ?>
	<?rfc include="reference.RFC.1321" ?>
	<?rfc include="reference.RFC.1323" ?>
	<?rfc include="reference.RFC.2385" ?>
	<?rfc include="reference.RFC.5681" ?>
	<?rfc include="reference.RFC.2616" ?>
	<?rfc include="reference.RFC.5321" ?>
	<?rfc include="reference.RFC.2923" ?>
	<?rfc include="reference.RFC.3168" ?>
	<?rfc include="reference.RFC.3390" ?>
	<?rfc include="reference.RFC.4271" ?>
	<?rfc include="reference.RFC.4821" ?>
	<?rfc include="reference.RFC.4907" ?>
	<?rfc include="reference.RFC.4953" ?>
	<?rfc include="reference.RFC.5925" ?>

<!--
<reference anchor='TCP-AUTH-OPT'>
<front>
<title>The TCP Authentication Option</title>

<author initials='J' surname='Touch' fullname='Joseph Touch'>
  <organization />
</author>

<author initials='A' surname='Mankin' fullname='Allison Mankin'>
  <organization />
</author>

<author initials='R' surname='Bonica' fullname='Ronald Bonica'>
  <organization />
</author>

<date month='March' year='2010' />

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>
-->

	<reference anchor="CPNI-TCP">
		<front>
			<title>Security Assessment of the Transmission Control Protocol (TCP)</title>
			<author initials="" surname="CPNI" fullname= "CPNI">
				<organization></organization>
			</author>
			<date year=""/>
		</front>
		<seriesInfo name="http://www.cpni.gov.uk/Docs/tn-03-09-security-assessment-TCP.pdf," value="2009" />
	</reference>

<reference anchor='TCP-SECURITY'>
<front>
<title>Security Assessment of the Transmission Control Protocol (TCP)</title>

<author initials='F' surname='Gont' fullname='Fernando Gont'>
 <organization />
</author>

<date month='February' day='19' year='2010' />

<abstract><t>This document contains a security assessment of the
specifications of the Transmission Control Protocol (TCP), and of a number of
mechanisms and policies in use by popular TCP implementations. Additionally,
it contains best current practices for hardening a TCP
implementation.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />
<format type='TXT'
     target='http://www.ietf.org/internet-drafts/draft-ietf-tcpm-tcp-security-01.txt'
/>
</reference>

	<reference anchor="Watson">
		<front>
			<title>Slipping in the Window: TCP Reset Attacks</title>
			<author initials="P.A." surname="Watson" fullname="Paul A. Watson">
				<organization></organization>
			</author>
			<date year=""/>
		</front>
		<seriesInfo name="CanSecWest Conference," value="2004"/>
	</reference>

	<reference anchor="Wright">
		<front>
			<title>TCP/IP Illustrated, Volume 2: The Implementation</title>
			<author initials="G.R." surname="Wright" fullname= "Gary R. Wright">
				<organization></organization>
			</author>

			<author initials="W.R." surname="Stevens" fullname= "W. Richard Stevens">
				<organization></organization>
			</author>
			<date year=""/>
		</front>
		<seriesInfo name="Addison-Wesley," value="1994"/>
	</reference>
	<reference anchor="McKusick">
		<front>
			<title>The Design and Implementation of the 4.4 BSD Operating System</title>
			<author initials="M.K." surname="McKusick" fullname= "Marshall Kirk McKusick">
				<organization></organization>
			</author>

			<author initials="K." surname="Bostic" fullname= "Keith Bostic">
				<organization></organization>
			</author>

			<author initials="M.J." surname="Karels" fullname= "Michael J. Karels">
				<organization></organization>
			</author>

			<author initials="J.S." surname="Quarterman" fullname= "John S. Quarterman">
				<organization></organization>
			</author>

			<date year=""/>
		</front>
		<seriesInfo name="Addison-Wesley," value="1996"/>
	</reference>  

	<reference anchor="DClark">
		<front>
			<title>The Design Philosophy of the DARPA Internet Protocols</title>
			<author initials="D. D." surname="Clark" fullname= "David D. Clark">
				<organization></organization>
			</author>
			<date year="1988"/>
		</front>
		<seriesInfo name="Computer Communication Review" value="Vol. 18, No. 4"/>
	</reference>


	<reference anchor="Linux">
		<front>
			<title>http://www.kernel.org</title>
			<author initials="" surname="The Linux Project" fullname="The Linux Kernel web site">
				<organization></organization>
			</author>
			<date year=""/>
		</front>
	</reference>

	<reference anchor="FreeBSD">
		<front>
			<title>http://www.freebsd.org</title>
			<author initials="" surname="The FreeBSD Project" fullname="The FreeBSD Project">
				<organization></organization>
			</author>
			<date year=""/>
		</front>
	</reference>

	<reference anchor="NetBSD">
		<front>
			<title>http://www.netbsd.org</title>
			<author initials="" surname="The NetBSD Project" fullname="The NetBSD Project">
				<organization></organization>
			</author>
			<date year=""/>
		</front>
	</reference>

	<reference anchor="OpenBSD">
		<front>
			<title>http://www.openbsd.org</title>
			<author initials="" surname="The OpenBSD Project" fullname="The OpenBSD Project">
				<organization></organization>
			</author>
			<date year=""/>
		</front>
	</reference>

	<reference anchor="ICMP-Filtering">
		<front>
			<title>Filtering of ICMP error messages</title>
			<author initials="F.G." surname="Gont" fullname="Fernando Gont">
				<organization></organization>
			</author>
			<date year=""/>
		</front>
		<seriesInfo name="" value="http://www.gont.com.ar/papers/filtering-of-icmp-error-messages.pdf"/>
	</reference>

	<reference anchor="OpenBSD-PF">
		<front>
			<title>http://www.openbsd.org/faq/pf/</title>
			<author initials="" surname="The OpenBSD Packet Filter" fullname="The OpenBSD Packet Filter">
				<organization></organization>
			</author>
			<date year=""/>
		</front>
	</reference>

	<reference anchor="NISCC">
		<front>
			<title>NISCC Vulnerability Advisory 532967/NISCC/ICMP:
Vulnerability Issues in ICMP packets with TCP payloads</title> 
			<author initials="" surname="NISCC" fullname="National
			  Infrastructure Security Co-ordination Centre"> 
				<organization></organization>
			</author>
			<date year="2005"/>
		</front>
		<seriesInfo name="" value="http://www.cpni.gov.uk/docs/re-20050412-00303.pdf?lang=en" />

	</reference>

	<reference anchor="IP-filtering">
		<front>
			<title>NISCC Technical Note 01/2006: Egress and Ingress
Filtering</title> 
			<author initials="" surname="NISCC" fullname="National
			  Infrastructure Security Co-ordination Centre">  
				<organization></organization>
			</author>
			<date year="2006"/>
		</front>
		<seriesInfo name="" value="http://www.cpni.gov.uk/Docs/re-20060420-00294.pdf"/>

	</reference>

	<reference anchor="US-CERT">
		<front>
			<title>US-CERT Vulnerability Note VU#222750: TCP/IP Implementations do not adequately validate ICMP error messages</title>
			<author initials="" surname="US-CERT" fullname="United States Computer Emergency Readiness Team">
				<organization></organization>
			</author>
			<date year=""/>
		</front>
		<seriesInfo name="http://www.kb.cert.org/vuls/id/222750,"
value="2005" />
	</reference>


<reference anchor='TCPM-TCPSECURE'>
<front>
<title>Improving TCP's Robustness to Blind In-Window Attacks</title>

<author initials='A' surname='Ramaiah' fullname='Anantha Ramaiah'>
 <organization />
</author>

<author initials='R' surname='Stewart' fullname='Randall Stewart'>
 <organization />
</author>

<author initials='M' surname='Dalal' fullname='Mitesh Dalal'>
 <organization />
</author>

<date month='May' day='4' year='2010' />

<abstract><t>TCP has historically been considered protected against spoofed
off- path packet injection attacks by relying on the fact that it is difficult
to guess the four-tuple (the source and destination IP addresses and the source
and destination ports) in combination with the 32 bit sequence number(s).  A
combination of increasing window sizes and applications using longer term
connections (e.g., H-323 or Border Gateway Protocol [RFC4271]) have left
modern TCP implementations more vulnerable to these types of spoofed packet
injection attacks.  Many of these long-term TCP applications tend to have
predictable IP addresses and ports, which makes it far easier for the four-tuple
(four-tuple is the same as the socket pair mentioned in [RFC0793]) to be
guessed.  Having guessed the four-tuple correctly, an attacker can inject a TCP
segment with the RST bit set, the SYN bit set or data into a TCP connection by
systematically guessing the sequence number of the spoofed segment to be in
the current receive window.  This can cause the connection to abort or cause
data corruption.  This document specifies small modifications to the way TCP
handles inbound segments that can reduce the chances of a successful
attack.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />
<format type='TXT'
     target='http://www.ietf.org/internet-drafts/draft-ietf-tcpm-tcpsecure-13.txt'
/>
</reference>

<reference anchor='PORT-RANDOM'>
<front>
<title>Transport Protocol Port Randomization Recommendations</title>

<author initials='M' surname='Larsen' fullname='Michael Larsen'>
 <organization />
</author>

<author initials='F' surname='Gont' fullname='Fernando Gont'>
 <organization />
</author>

<date month='April' day='12' year='2010' />

<abstract><t>During the las few years, awareness has been raised about a
number of "blind" attacks that can be performed against the Transmission
Control Protocol (TCP) and similar protocols.  The consequences of these
attacks range from throughput-reduction to broken connections or data
corruption.  These attacks rely on the attacker's ability to guess or know the
five-tuple (Protocol, Source Address, Destination Address, Source Port,
Destination Port) that identifies the transport protocol instance to be
attacked.  This document describes a number of simple and efficient methods
for the selection of the client port number, such that the possibility of an
attacker guessing the exact value is reduced.  While this is not a replacement
for cryptographic methods for protecting the transport-protocol instance, the
described port number obfuscation algorithms provide improved security/
obfuscation with very little effort and without any key management overhead.
The algorithms described in this document are local policies that may be
incrementally deployed, and that do not violate the specifications of any of
the transport protocols that may benefit from them, such as TCP, UDP,
UDP-lite, SCTP, DCCP, and RTP (provided the RTP application explicitly signals
the RTP and RTCP port numbers).</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />
<format type='TXT'
     target='http://www.ietf.org/internet-drafts/draft-ietf-tsvwg-port-randomization-07.txt'
/>
</reference>

	<?rfc include="reference.RFC.5461" ?>

</references>
</back>
</rfc>
