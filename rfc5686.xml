<?xml version="1.0" encoding="us-ascii"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
 <!ENTITY rfc2629 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml">
 <!ENTITY rfc2119 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
 <!ENTITY rfc3264 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3264.xml">
 <!ENTITY rfc3550 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3550.xml">
 <!ENTITY rfc3551 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3551.xml">
 <!ENTITY rfc4288 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4288.xml">
 <!ENTITY rfc4566 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4566.xml">
 <!ENTITY rfc4855 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4855.xml">
 <!ENTITY rfc4856 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4856.xml">
 <!ENTITY rfc5117 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5117.xml">
]>
<rfc number="5686" category="std" ipr="pre5378Trust200902">
<?rfc toc="yes" ?>
<?rfc rfcedstyle="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>

<front>
  <title abbrev="RTP Payload Format for UEMCLIP">
  RTP Payload Format for mU-law EMbedded Codec for Low-delay IP
  communication (UEMCLIP) Speech Codec</title>
  <author initials="Y.H." surname="Hiwasaki" fullname="Yusuke Hiwasaki">
    <organization>NTT Corporation</organization>
    <address>
      <postal>
        <street>3-9-11 Midori-cho,</street>
        <street>Musashino-shi</street>
	<city>Tokyo</city>
	<code>180-8585</code>
	<country>Japan</country>
      </postal>
      <phone>+81(422)59-4815</phone>
      <email>hiwasaki.yusuke@lab.ntt.co.jp</email>
    </address>
  </author>
  <author initials="H.O." surname="Ohmuro" fullname="Hitoshi Ohmuro">
    <organization>NTT Corporation</organization>
    <address>
      <postal>
        <street>3-9-11 Midori-cho,</street>
        <street>Musashino-shi</street>
	<city>Tokyo</city>
	<code>180-8585</code>
	<country>Japan</country>
      </postal>
      <phone>+81(422)59-2151</phone>
      <email>ohmuro.hitoshi@lab.ntt.co.jp</email>
    </address>
  </author>
  <date month="October" year="2009"/>
  <area>Real-time Applications</area>
  <workgroup>Audio/Video Transport</workgroup>
  <keyword>RTP Payload type</keyword>
  <keyword>MIME</keyword>
  <keyword>UEMCLIP</keyword>
  <keyword>PCMU</keyword>
  <keyword>Speech Coding</keyword>
  <abstract>
    <t>This document describes the RTP payload format of a mU-law
    EMbedded Coder for Low-delay IP communication (UEMCLIP), an
    enhanced speech codec of ITU-T G.711. The bitstream has a scalable
    structure with an embedded u-law bitstream, also known as PCMU,
    thus providing a handy transcoding operation between narrowband
    and wideband speech.</t> </abstract>

</front>

<middle>

<section anchor="sec_intro" title="Introduction">

<t>
This document specifies the payload format for sending UEMCLIP-encoded (mU-law
EMbedded Coder for Low-delay IP communication)
speech using the Real-time Transport Protocol (RTP) <xref target="RFC3550"/>. UEMCLIP is a proprietary codec that enhances u-law ITU-T
G.711 <xref target="ITU-T-G.711"/> and that is designed to help the market for smooth transition towards
the forthcoming wideband communication environment while achieving a
very small media transcoding load with the existing terminals, in
which the implementation of G.711 is mandatory.
</t>

<t>
It should be noted that, generally speaking, codecs are negotiated and
changed using an SDP exchange. Also, <xref target="RFC3550"/> defines
general RTP mixer and translator models, where media transcoding may
not take place at the node. For those cases, the design concept of the
embedded structure is not useful.  However, there are other cases when
costly transcoding is unavoidable in commonly deployed types of
Multi-point Control Units (MCUs), which terminate media and RTCP
packets <xref target="RFC5117"/>, and when narrowband and wideband
terminals coexist. This embedded bitstream structure can reduce the
media transcoding to a simple bitstream truncation.
</t>

<t>
The background and the basic idea of the media format is described in
<xref target="sec_background"/>. The details of the payload format
are given in <xref target="sec_bitformat"/>. The transcoding issues
with G.711 are discussed in <xref target="sec_g711interoperability"/>, and the considerations for congestion control are in
<xref target="sec_congestion"/>. In
<xref target="sec_payloadformatparam"/>, the payload format parameters
for a media type registration for UEMCLIP RTP payload format and Session Description Protocol (SDP)
mappings are provided. The security considerations and IANA
considerations are dealt with in <xref target="sec_security"/> and <xref target="sec_iana"/>, respectively. 
</t>

<section anchor="sec_terminology" title="Terminology">

<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref target="RFC2119"/>.</t>

</section>

</section>

<section anchor="sec_background" title="Media Format Background">

<t>
UEMCLIP is an enhanced version of u-law ITU-T G.711,
otherwise known as PCMU <xref target="RFC4856"/>. It is targeted at
Voice over Internet Protocol (VoIP) applications, and its main goal is
to provide a wideband communication platform that is highly
interoperable with existing terminals equipped with G.711 and to
stimulate the market to gradually shift to using wideband
communication. In widely deployed multi-point conferencing systems,
the packets usually go through RTCP-terminating (RTP Control Protocol) MCUs,
"Topo-RTCP-terminating-MCU" as defined in <xref target="RFC5117"/>. Because the G.711 bitstream is embedded in the
bitstream, costly media transcoding can be avoided in this case.</t>

<t>
This document does not discuss the implementation details of the
encoder and decoder, but only describes the bitstream format.</t>

<t>
Because of its scalable nature, there are a number of sub-bitstreams
(sub-layer) in a UEMCLIP bitstream. By choosing appropriate
sub-layers, the codec can adapt to the following requirements:

<list style="symbols">
<t>Sampling frequency,</t>
<t>Number of channels,</t>
<t>Speech quality, and</t>
<t>Bit-rate.</t>
</list>

The UEMCLIP codec operates at a 20-ms frame, and includes three
sub-coders as shown in <xref target="tab_sublayer"/>. The core layer
is u-law G.711 at 64 kbit/s, and other two are quality and bandwidth
enhancement layers with bit-rate of 16 kbit/s each.
</t>

<?rfc compact="no"?>

<texttable anchor="tab_sublayer" title="Sub-Layer Description">
<ttcol align="center">Layer</ttcol>
<ttcol align="left">Description</ttcol>
<ttcol align="right">Bit-rate</ttcol>
<ttcol align="left">Coding algorithm</ttcol>
<c>a</c><c>G.711 core</c><c>64</c><c>u-law PCM</c>
<c>b</c><c>Lower-band enhancement</c><c>16</c><c>Time domain block quantization</c>
<c>c</c><c>Higher-band</c><c>16</c><c>MDCT block quantization</c>
</texttable>

<?rfc compact="yes"?>

<t>
Based on these sub-layers, the UEMCLIP codec operates in four modes as
shown in <xref target="tab_modes"/>. Here, "Ch" is the number of
channels and "Fs" is the sampling frequency in kHz. It should be noted
that the current version only supports single-channel operation and
there might be future extensions with multi-channel capabilities.
The absent Modes 2 and 5 are reserved for possible
future extension to 32 kHz sampling modes. As the mode definition is
expected to grow, any other modes not defined in this table MUST NOT
be used for compatibility and interoperability reasons.</t>

<?rfc compact="no"?>

<texttable anchor="tab_modes" title="Mode Description">
<ttcol align="center">Mode</ttcol>
<ttcol align="center">Ch</ttcol>
<ttcol align="right">Fs</ttcol>
<ttcol align="center">Layer a</ttcol>
<ttcol align="center">Layer b</ttcol>
<ttcol align="center">Layer c</ttcol>
<ttcol align="right">Bit-rate w/o headers [kbit/s]</ttcol>
<ttcol align="right">Total bit-rate [kbit/s]</ttcol>
<c>0</c><c>1</c><c> 8</c><c>x</c><c>-</c><c>-</c><c>64</c><c>67.2</c>
<c>1</c><c>1</c><c>16</c><c>x</c><c>-</c><c>x</c><c>80</c><c>84.0</c>
<c>2</c><c>-</c><c> -</c><c>-</c><c>-</c><c>-</c><c>-</c><c>-</c>
<c>3</c><c>1</c><c> 8</c><c>x</c><c>x</c><c>-</c><c>80</c><c>84.0</c>
<c>4</c><c>1</c><c>16</c><c>x</c><c>x</c><c>x</c><c>96</c><c>100.8</c>
<c>5</c><c>-</c><c> -</c><c>-</c><c>-</c><c>-</c><c>-</c><c>-</c>
</texttable>

<?rfc compact="yes"?>

<t>
The UEMCLIP bitstream contains internal headers and other side-information
apart from the layer data.  This results in total bit-rate larger than
the sum of the layers shown in the above table.  The detail of the
internal headers and auxiliary information are described in <xref target="sec_mainheader"/>.</t>

<t>
Defining the sampling frequency and the number of channels does not
result in a singular mode, i.e., there can be multiple modes for the
same sampling frequency or number of channels. The supported modes
would differ between implementations; thus, the sender and the receiver
must negotiate what mode to use for transmission.
</t>

</section>

<section anchor="sec_bitformat" title="Payload Format">

<t>
As an RTP payload, the UEMCLIP bitstream can contain one or more frames as
shown in <xref target="fig_rtpformat"/>.</t>

<figure anchor="fig_rtpformat" title="RTP Payload Format">
<artwork>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                      RTP Header                               |
 +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
 |                                                               |
 |                 one or more frames of UEMCLIP                 |
 |                                                               |
 +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
</artwork>
</figure>

<t>
The UEMCLIP bitstream has a scalable structure; thus, it is possible to
reconstruct the signal by decoding a part of it. A UEMCLIP frame is
composed of a main header (MH) followed by one or more (up to three)
sub-layers (SLs) as shown in <xref target="fig_bitstream"/>.</t>

<figure anchor="fig_bitstream" title="A UEMCLIP Frame (Bitstream Format)">
<artwork>
                         +--+-------+//-+
                         |MH| SL #1 |...|
                         +--+-------+//-+
</artwork>
</figure>

<t>
As a sub-layer, the core layer, i.e., "Layer a", MUST always be
included. It should be noted that the location of the core layer may
or may not immediately follow MH field. The decoder MUST always refer
to the layer indices for proper decoding because the order of the
sub-layers is arbitrary.</t>

<t>
The UEMCLIP bitstream does not explicitly include the following
information: mode and sampling frequency (Fs). As described before,
this information MUST be exchanged while establishing a connection,
for example, by means of SDP.</t>

<section anchor="sec_rtphdrusg" title="RTP Header Usage">
<t>
Each RTP packet starts with a fixed RTP header, as explained in <xref target="RFC3550"/>. The following fields of the RTP fixed header used
specifically for UEMCLIP streams are emphasized:

<list style="hanging">

<t hangText="Payload type:">The assignment of an RTP payload type for
this packet format is outside the scope of this document; however, it
is expected that a payload type in the dynamic range shall be
assigned.</t>

<t hangText="Timestamp:">This encodes the sampling instant of the
first speech signal sample in the RTP data packet. For UEMCLIP
streams, the RTP timestamp MUST advance based on a clock either at
8000 or 16000 (Hz). In cases where the audio sampling rate can
change during a session, the RTP timestamp rate MUST be equal to the
maximum rate (in Hz) given in the mode range (see <xref target="sec_dyntx"/>).  This implies that the RTP timestamp rate for UEMCLIP payload type MUST
NOT change during a session. For example, for a UEMCLIP stream with 8-kHz
audio sampling, where a transition to a 16-kHz audio sampling mode is
allowed, the RTP time stamp must always advance using the 16-kHz clock
rate. For a fixed audio sampling mode, the RTP
timestamp rate should be either 8 or 16 kHz, depending on the sampling
rate.</t>

<t hangText="Marker bit:">If the codec is used for applications with
discontinuous transmission (DTX, or silence compression), the first
packet after a silence period during which packets have not been
transmitted contiguously SHOULD have the marker bit in the RTP data
header set to one. The marker bit in all other packets MUST be
zero. Applications without DTX MUST set the marker bit to zero.</t>

</list>
</t>
</section>

<section anchor="sec_multiframe" title="Multiple Frames in an RTP Packet">

<t>
More than one UEMCLIP frame may be included in a single RTP packet by
a sender. However, senders have the following additional restrictions:

<list style="symbols">
<t> A single RTP packet SHOULD NOT include more UEMCLIP frames than
will fit in the path MTU.</t>
<t> All frames contained in a single RTP packet MUST be of the same
mode.</t>
<t>Frames MUST NOT be split between RTP packets.</t>
</list>

It is RECOMMENDED that the number of frames contained within an RTP
packet be consistent with the application.  Since UEMCLIP is designed
for telephony applications where delay has a great impact on the
quality, then fewer frames per packet for lower delay, is
preferable.</t>

</section>

<section anchor="sec_payloaddata" title="Payload Data">
<t>
In a UEMCLIP bitstream, all numbers are encoded in a network
byte order.</t>

<section anchor="sec_mainheader" title="Main Header">

<t>
The main header (MH) is placed at the top of a frame and has a size of 6
bytes. The content of the main header is shown in <xref target="fig_mainheader"/>.</t>

<figure anchor="fig_mainheader" title="UEMCLIP Main Header Format (MH)">
<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      MX       |                      PC                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          PC(cont'd)           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>
</figure>

<t>
<list style="hanging">

<t hangText="Mixing information (MX):">8 bits</t>
<t>Mixing information field. This field is only relevant when 
Topo-RTCP-terminating-MCUs are utilized to interpret these fields.
 See <xref target="sec_mixinfo"/> for details
of the fields.</t>

<t hangText="Packet-loss Concealment information (PC):">40 bits</t>

<t>Packet-loss concealment (PLC) information
  field. See <xref target="sec_plcinfo"/>.</t>


</list>
</t>

<section anchor="sec_mixinfo" title="Mixing Information Field">

<figure anchor="fig_mixinfo" title="Mixing Information Field (MX)">
<artwork>
                         0 1 2 3 4 5 6 7 
                        +-+-+-+-+-+-+-+-+
                        |C|R|V|   PW1   |
                        |1|1|1|         |
                        +-+-+-+-+-+-+-+-+
</artwork>
</figure>
<t>
<list style="hanging">

<t hangText="Check bit #1 (C1):">1 bit</t>
<t>Validity flag of V1 and PW1. This bit being "1" indicates that both
parameters are valid, and "0" indicates that the parameters should be
ignored. If any of these parameters is invalid, this bit should be set
to "0". This flag is mainly intended for 
a UEMCLIP-conscious Topo-RTCP-terminating-MCU. This flag should be set to "0"
in case of upward transcoding from G.711
(see <xref target="sec_g711interoperability"/>).</t>

<t hangText="Reserved bit #1 (R1):">1 bit</t>
<t>This bit should be ignored. The default of this bit is 0.</t>

<t hangText="VAD flag #1 (V1):">1 bit</t>
<t>Voice activity detection flag of the current frame, designed to be
used for MCU operations. This flag being "1" indicates that the frame
is an active (voice) segment, and "0" indicates that it is an inactive
(non-voice) or a silent segment. This flag is specifically designed
for mixing information. DTX judgment based this flag is not
recommended.
</t>

<t hangText="Power #1 (PW1):">5 bits</t>
<t>Signal power code of the current frame. 

The code is obtained by calculating a root mean square (RMS) of "Layer
a" and encoding this RMS using G.711 u-law <xref target="ITU-T-G.711"/>.
Denoting the encoded RMS as R, then PW1 is obtained by PW1
= ((~R)&gt;&gt;2) &amp; 0x1F, where "~", "&gt;&gt;", "&amp;" are one's
complement arithmetic, right SHIFT, and bitwise AND operators,
respectively.
</t>

</list>
</t>
</section>

<section anchor="sec_plcinfo" title="PLC Information Field">

<figure anchor="fig_plcinfo" title="PLC Information Field (PC)">
<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|C|R2 |V|   K   |U|     P1      |U|     P2      |      PW2      |
|2|   |2|       |1|             |2|             |               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      R3       |
|               |
+-+-+-+-+-+-+-+-+
</artwork>
</figure>
<t>
<list style="hanging">

<t hangText="Check bit #2 (C2):">1 bit</t>
<t>Validity flag of V2, K, U1, P1, U2, P2, and PW2. If the flag is
"1", it means that all these parameters are valid, and "0" means that
the parameters should be ignored.  If any of these parameters is
invalid, this bit should be set to "0". Similarly to C1, this flag
should be set to "0" in case of upward transcoding from G.711 (see
<xref target="sec_g711interoperability"/>).</t>

<t hangText="Reserved bit #2 (R2):">2 bits</t>
<t>These bits should be ignored. The default of these bits are 0.</t>

<t hangText="VAD flag #2 (V2):">1 bit</t>
<t>Voice activity detection flag of the current frame, designed to be
used for packet-loss concealment. This might not be the same as V1 in the
mixing information, and might not be synchronous to the marker bit in
the RTP header. DTX judgment based this flag is not recommended.</t>

<t hangText="Frame indicator (K):">4 bits</t>
<t>This value indicates the frame offset of U2, P2, and PW2. Since it
is a better idea to carry the speech feature parameters as PLC
information in a different frame to maintain the speech quality, this
frame offset value gives with which frame the parameters are to be
associated. The value ranges between "0" and "15". If the current
frame number is N, for example, the value K indicates that U2, P2, and
PW2 are associated with the frame of N-K. The frame indicator is equal to the
difference in the RTP sequence number when one UEMCLIP frame is
contained in a single RTP packet.
</t>

<t hangText="V/UV flag #1 (U1):">1 bit</t>
<t>Voiced/Unvoiced signal indicator of the current frame.
This flag being "0" indicates that the frame
is a voiced signal segment, and "1" indicates that it is an unvoiced
signal segment.</t>

<t hangText="Pitch lag #1 (P1):">7 bits</t>
<t>Pitch code of the current frame. The actual pitch lag is calculated
as P1+20 samples in 8-kHz sampling rate. Pitch lag must be 20 &lt;= pitch length &lt;=
120. Codes ranging between "0x65" and "0x7F" are not used.
To obtain the pitch lag, any pitch estimation method can be used,
such as the one used in G.711 Appendix I <xref target="ITU-T-G.711Appendix1"/>.
</t>

<t hangText="V/UV flag #2 (U2):">1 bit</t>
<t>Voiced/Unvoiced signal indicator of the offset frame. This flag
being "0" indicates that the frame is a voiced signal segment, and "1"
indicates that it is an unvoiced signal segment. The offset value is
defined as K.
</t>

<t hangText="Pitch lag #2 (P2):">7 bits</t>

<t>Pitch code of the offset frame. The offset value is defined as
K. The calculation method is identical to "P1", except that it is
based on the signal of offset frame.</t>

<t hangText="Power #2 (PW2):">8 bits</t>
<t>Signal power code of the offset frame. The offset value is defined
as K.</t>

<t hangText="Reserved bits #3 (R3):">8 bits</t>
<t>These bits should be ignored. The default of all bits are "0".</t>
</list>
</t>

</section>

</section>

<section anchor="sec_sublayer" title="Sub-Layer">

<t>
Sub-layer (SL) is a sub-header followed by layer bitstreams, as shown
in <xref target="fig_sublayer"/>.  The sub-header indicates the layer
location and the number of bytes.
</t>

<figure anchor="fig_sublayer" title="Sub-Layer Format (SL)">

<artwork>
  0                   1                   2                   
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7   . . .
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+//-+-+-+
 |CI |FI |QI |R4 |      SB       |               LD         ...  |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+//-+-+-+
</artwork>
</figure>

<t>
<list style="hanging">
<t hangText="Channel index (CI):">2 bits</t>
<t>Indicates the channel number. For all modes given in <xref target="tab_modes"/>, this should be "0". The detail is given in
<xref target="tab_layeridx"/>.</t>

<t hangText="Frequency index (FI):">2 bits</t>
<t>Indicates the frequency number. "0" means that the layer is in the
base frequency band, higher number means that the layer is in
respective frequency band. The detail is given in <xref target="tab_layeridx"/>.</t>

<t hangText="Quality index (QI):">2 bits</t>
<t>Indicates the quality layer number. "0" means that the layer is in
the base layer, and higher number means that the layer is in
respective quality layer. The detail is given in <xref target="tab_layeridx"/>.</t>

<t hangText="Reserved #4 (R4):">2 bits</t>
<t>Not used (reserved). The default value is "0".</t>

<t hangText="Sub-layer Size (SB):">8 bits</t>
<t>Indicates the byte size of the following sub-layer data.</t>

<t hangText="Layer Data (LD):">SB*8 bits</t>
<t>The actual sub-layer data.</t>
</list>

For all the layers shown in <xref target="tab_sublayer"/>, the layer
indices are shown in <xref target="tab_layeridx"/>.</t>

<?rfc compact="no"?>

<texttable anchor="tab_layeridx" title="Layer Indices">
<ttcol align="center">Layer</ttcol>
<ttcol align="center">CI</ttcol>
<ttcol align="center">FI</ttcol>
<ttcol align="center">QI</ttcol>
<c>a</c><c>0</c><c>0</c><c>0</c>
<c>b</c><c>0</c><c>0</c><c>1</c>
<c>c</c><c>0</c><c>1</c><c>0</c>
</texttable>

<?rfc compact="yes"?>

</section>

</section>

</section>

<section anchor="sec_g711interoperability" title="Transcoding between UEMCLIP and G.711">

<t>
As given in <xref target="sec_background"/>, the u-law-encoded G.711
bitstream (Layer a) is the core layer of a UEMCLIP bitstream, and is
always embedded. This means that media transcoding from the UEMCLIP
bitstream to G.711 does not have to undergo decoding and re-encoding
procedures, but simple extraction would suffice. However, this does
not apply for the reverse procedure, i.e., transcoding from G.711 to
UEMCLIP, because the auxiliary information in the main header (MH)
must be assigned separately. It should be noted that this media
transcoding is useful for a Media Translator (Topo-Media-Translator)
or a Point-to-Multipoint Using RTCP
Terminating MCU (Topo-RTCP-terminating-MCU) in <xref target="RFC5117"/>, and all the requirements apply. This means that a
transcoding device of this sort MUST rewrite RTCP packets, together
with the RTP media packets.</t>

<t>
The transcoding from UEMCLIP to u-law G.711 can be done easily by
finding an appropriate sub-layer. Within a frame, the transcoder
should look for a sub-layer with a layer index of "0x00", and subsequent LD
that has a size of SB*8 bits (UEMCLIP has a 20-ms frame thus, SB=160)
are the actual G.711 bitstream data. It should be noted that the
transcoder should not always expect the core layer to be located right
after the main header.
</t>

<t>
On the other hand, the transcoding from G.711 to UEMCLIP is not
entirely straightforward. Since there are no means to generate
enhancement sub-layers, a G.711 bitstream can only be converted to
UEMCLIP Mode 0 bitstream. If the original G.711 bitstream is encoded
in A-law, it should first be converted to u-law to become the core
layer. Because a UEMCLIP frame size is 20 ms, a u-law-encoded G.711
bitstream MUST be a 160-sample chunk to become a core layer. For the
main header contents, when the UEMCLIP encoder is not available, it
should follow these guidelines:

<list style="symbols">

<t> The check bits for mixing and PLC (C1 and C2) are set to 0.</t>

<t> The reserved bits (R1 to R3) in MH are set to respective default values.</t>
</list>

For the core layer (i.e., u-law G.711 bitstream), it should have the
following sub-layer header: 

<list style="symbols">

<t> All CI, FI, QI, and R4 MUST be 0.</t>
<t> Sub-layer size (SB) MUST be 160 for a 20-ms frame.</t>
</list>

</t>

</section>

<section anchor="sec_congestion" title="Congestion Control Considerations">

<t>
The general congestion control considerations for transporting RTP
data also apply to UEMCLIP over RTP <xref target="RFC3550"/> as well
as any applicable RTP profile like Audio-Visual Profile (AVP) <xref target="RFC3551"/>.</t>

<t>
The bandwidth of a UEMCLIP bitstream can be reduced by changing to
lower-bit-rate modes. The embedded layer structure of UEMCLIP may help
to control congestion, when dynamic mode changing (see <xref target="sec_dyntx"/>) is available, and the range of modes is
obtained by offer-answer negotiation as given in <xref target="sec_offeranswer"/>. It should be noted that this involves
proper RTCP handling when the bit-rate is modified in an RTP
translator or a mixer <xref target="RFC3550"/>.</t>

<t>
Packing more frames in each RTP payload can reduce the number of
packets sent, and hence the overhead from IP/UDP/RTP headers, at the
expense of increased delay and reduced error robustness against packet
losses. It should be treated with care because increased delay means
reduced quality.</t>


</section>

<section anchor="sec_payloadformatparam" title="Payload Format Parameters">

<section anchor="sec_mediatype" title="Media Type Registration">
<t>
This registration is done using the template defined in <xref target="RFC4288"/> and following <xref target="RFC4855"/>.

<list style="hanging">

<t hangText="Media type name:">audio</t>

<t hangText="Media subtype name:">UEMCLIP</t>

<t hangText="Required parameters:">
   <list style="hanging">
   <t hangText="Rate:">Defines the sampling rate, and it MUST be either
   8000 or 16000. See <xref target="sec_dyntx"/> "Mode specification"
   of RFC 5686 (this RFC) for details.</t></list></t>

<t hangText="Optional parameters:"> 
   <list style="hanging">
   <t hangText="ptime:">See RFC 4566 <xref target="RFC4566"/>.</t>
   <t hangText="maxptime:">See RFC 4566 <xref target="RFC4566"/>.</t>

   <t hangText="mode:">Indicates the range of dynamically changeable
   modes during a session. Possible values are a comma-separated list of
   modes from the supported mode set: 0, 1, 3, and 4. If only one mode
   is specified, it means that the mode must not be changed during the
   session. When not specified, the mode transmission defaults to a
   singular mode as specified in <xref target="tab_defaultmodes"/>. See
   <xref target="sec_dyntx"/> "Mode specification" of RFC 5686 (this
   RFC) for details.</t> 

</list></t>

<t hangText="Encoding considerations:">This media type is framed and
   contains binary data. See Section 4.8 of RFC 4288.</t>

<t hangText="Security considerations:">See <xref target="sec_security"/> "Security Considerations" of RFC 5686 (this
   RFC).</t>

<t hangText="Interoperability considerations:"> This media may be 
   readily transcoded to u-law-encoded ITU-T G.711. See <xref target="sec_g711interoperability"/> "Transcoding between UEMCLIP
   and G.711" of RFC
   5686 (this RFC).</t>

<t hangText="Published specification:">RFC 5686 (this RFC)</t>

<t hangText="Applications that use this media type:">Audio and video
streaming and conferencing tools.</t>

<t hangText="Additional information:">None</t>

<t hangText="Intended usage:">COMMON</t>

<t hangText="Restrictions on usage:">This media type depends on RTP
framing, and hence is only defined for transfer via RTP.</t>

<t hangText="Person &amp; email address to contact for further information:">
<vspace blankLines="0"/>
Yusuke Hiwasaki &lt;hiwasaki.yusuke@lab.ntt.co.jp&gt;</t>

<t hangText="Author:">Yusuke Hiwasaki</t>

<t hangText="Change Controller:">IETF Audio/Video Transport Working
Group delegated from the IESG</t>

</list>
</t>
</section>

<section anchor="sec_sdpparam" title="Mapping to SDP Parameters">
<t>
The media types audio/UEMCLIP are mapped to fields in the Session
Description Protocol (SDP) <xref target="RFC4566"/> as follows:

<list style="hanging">

<t hangText="Media name:">The "m=" line of SDP MUST be audio.</t>

<t hangText="Encoding name:">Registered media subtype name should be
used for the "a=rtpmap" line.</t>

<t hangText="Sampling Frequency:">Depending on the mode, clock rate
(sampling frequency) specified in "a=rtpmap" MUST be selected from the
ones defined in <xref target="tab_modes"/>. See <xref target="sec_dyntx"/> for details.</t>

<t hangText="Encoding parameters:">Since this is an audio stream, the
encoding parameters indicate the number of audio channels, and this
SHOULD default to "1", as selected from the ones defined in <xref target="tab_modes"/>. This is OPTIONAL.</t>

<t hangText="Packet time:">A frame length of any UEMCLIP is 20 ms,
thus the argument of "a=ptime" SHOULD be a multiple of "20". When not
listed in SDP, it should also default to the minimum size: "20".</t>

<t hangText="UMECLIP specific:">Any description specific to UEMCLIP
is defined in the Format Specification Parameters ("a=fmtp"). Each
parameter MUST be separated with ";", and if any attribute (value)
exists, it MUST be defined with "=". For compatibility reasons, any
application/terminal MUST ignore any parameters that it does not
understand. This is to ensure the upper-compatibility with parameters
added in future enhancements. The mode specification should
be made here (see <xref target="sec_dyntx"/>).</t>

</list></t>


<section anchor="sec_dyntx" title="Mode Specification">
<t>
Since UEMCLIP codec can operate in number of modes (bit-rates), it is
desirable to specify the range of modes at which an encoder or a decoder
can operate. When exchanging SDP messages, an offerer should
specify all possible combinations of mode numbers as arguments to
"mode=" in "a=fmtp" line, delimited by commas ",". In case of
specifying multiple modes, those SHOULD appear in the descending
priority order.
</t>

<t>
Although UEMCLIP decoders SHOULD accept bitstreams in any modes, an
implementation may fail to adapt to the dynamic mode changes during a
session. For this reason, an application may choose to operate
either with one fixed mode or with multiple modes that can be dynamically
changed. If the mode is to be fixed and changes are not allowed, this
can be indicated by specifying a single mode per payload type.
</t>

<t>
The mode numbers that can be specified in a payload type as arguments
to "mode" are restricted by a combination of a clock rate and a number
of audio channels. This is because SDP binds a payload type to a
combination of a sampling frequency and a number of audio
channels. <xref target="tab_defaultmodes"/> gives selectable mode
numbers that are attributed with clock rates. When mode specifications are
not given at all, a payload type MUST default to a single mode using
the default value specified in this table.
</t>

<?rfc compact="no"?>

<texttable anchor="tab_defaultmodes" title="Default Modes">
<ttcol align="right">Clock rate</ttcol>
<ttcol align="center">Channels</ttcol>
<ttcol align="center">Selectable modes</ttcol>
<ttcol align="center">Default mode</ttcol>
<c>8000</c><c>1</c><c>0,3</c><c>0</c>
<c>16000</c><c>1</c><c>0,1,3,4</c><c>1</c>
</texttable>

<?rfc compact="yes"?>

<t>
It should be noted that a mode attributed with a larger sampling
frequency (Fs) is not used in conjunction with smaller clock rates
specified in "a=rtpmap". This means that Modes 0 and 3 can be
specified in a payload type having a clock rate of both 8000 and 16000
in "a=rtpmap", but Modes 1 and 4 cannot be specified with one having
a clock rate of 8000.
</t>

</section>

</section>

<section anchor="sec_offeranswer" title="Offer-Answer Model Considerations">

<section anchor="sec_offeranswer_guide" title="Offer-Answer Guidelines">
<t>
The procedures related to exchanging SDP messages MUST follow <xref target="RFC3264"/>. The following is a detailed list on the semantics
of using the UEMCLIP payload format in an offer-answer exchange.

<list style="symbols">

<t>
An offerer SHOULD offer every possible combination of UEMCLIP payload
type it can handle, i.e., sampling frequency, channel number, and fmtp
parameters, in a preferred order. When the transmission bandwidth is
restricted, it MUST be offered in accordance to the restriction. </t>

<t>
When multiple UEMCLIP payload types are offered, it is RECOMMENDED
that the answerer select a single UEMCLIP payload type and answer it
back.</t>

<t>
In a UEMCLIP payload type, an answerer MUST answer back suitable mode
number(s) as a subset of what has been offered. This means that there
is a symmetry assumption on sent and received streams, and the offerer
MUST NOT send in modes that it does not offer.</t>

<t>
In an offering/answering SDP, any fmtp parameters that are not known
MUST be ignored. If any unknown/undefined parameters should be
offered, an answerer MUST delete the entry from the answer message.
</t>

<t>
A receiver of an SDP message MUST only use specified payload types and
modes. When a mode specification is missing, i.e., a mode is not
specified at all, the session MUST default to one single mode without
mode changes during a session. For this case, the default mode values,
as shown in <xref target="tab_defaultmodes"/>, MUST be used based on
the sampling frequency and number of channels. This table must be
looked up only when there are no mode specifications; thus, the
offerer/answerer MUST NOT assume that the default modes are always
available when it is not in the specified list of modes.
</t>

<t>
When an offered condition does not fit an answerer's capabilities, it
naturally MUST NOT answer any of the conditions, and the session MAY
proceed to re-INVITE, if possible. If a condition (mode) is decided
upon, an offerer and an answerer MUST transmit on this condition.</t>

</list>
</t>
</section>

<section anchor="sec_sdpexample" title="Examples">

<t>When an offerer indicates that he/she wishes to dynamically switch
between modes (0,1,3, and 4) during a session, an example of an
offered SDP could be:

<figure>
<artwork>
  v=0
  o=john 51050101 51050101 IN IP4 offhost.example.com
  s=-
  c=IN IP4 offhost.example.com
  t=0 0
  m=audio 5004 RTP/AVP 96
  a=rtpmap:96 UEMCLIP/16000/1
  a=fmtp:96 mode=4,1,3,0
</artwork>
</figure>

It should be noted that the listed modes appears in the offerer's
preference.</t>

<t>
When an answerer can only operate in Modes 1 and 0 but can dynamically
switch between those modes during a session, an answerer MUST delete
the entries of Mode 3 and 4, and answer back as:

<figure>
<artwork>
  v=0
  o=lena 549947322 549947322 IN IP4 anshost.example.org
  s=-
  c=IN IP4 anshost.example.org
  t=0 0
  m=audio 5004 RTP/AVP 96
  a=rtpmap:96 UEMCLIP/16000/1
  a=fmtp:96 mode=1,0
</artwork>
</figure>

As a result, both would start communicating in either Mode 1 or 0, and
can dynamically switch between those modes during the session.
</t>

<t>
On the other hand, when the answerer is capable of communicating
either in Modes 1 or 0, and cannot switch between modes during a
session, an example of such answer is as follows:

<figure>
<artwork>
  v=0
  o=lena 549947322 549947322 IN IP4 anshost.example.org
  s=-
  c=IN IP4 anshost.example.org
  t=0 0
  m=audio 5004 RTP/AVP 96
  a=rtpmap:96 UEMCLIP/16000/1
  a=fmtp:96 mode=1
</artwork>
</figure>

As a result, both will start communicating in Mode 1. It should be
noted that mode change during this session is not allowed because the
answerer responded with a single mode, and answerer selected Mode 1
above Mode 0 according to the offered order.</t>

<t>
If an offerer does not want a mode change during a session but is
capable of receiving either Modes 4 or 1 bitstreams, the SDP should
somewhat look like:

<figure>
<artwork>
  v=0
  o=john 51050101 51050101 IN IP4 offhost.example.com
  s=-
  c=IN IP4 offhost.example.com
  t=0 0
  m=audio 5004 RTP/AVP 96 97
  a=rtpmap:96 UEMCLIP/16000/1
  a=fmtp:96 mode=4
  a=rtpmap:97 UEMCLIP/16000/1
  a=fmtp:97 mode=1
</artwork>
</figure>

and if the answerer prefers to communicate in Mode 1, an answer would
be:

<figure>
<artwork>
  v=0
  o=lena 549947322 549947322 IN IP4 anshost.example.org
  s=-
  c=IN IP4 anshost.example.org
  t=0 0
  m=audio 5004 RTP/AVP 97
  a=rtpmap:97 UEMCLIP/16000/1
  a=fmtp:97 mode=1
</artwork>
</figure>

Please note that it is RECOMMENDED to select a single UEMCLIP payload
type for answers.</t>

<t>
The "ptime" attribute is used to denote the desired packetization
interval. When not specified, it SHOULD default to 20. Since UEMCLIP
uses 20-ms frames, ptime values of multiples of 20 imply multiple
frames per packet.

In the example below, the ptime is set to 60, and this means that
offerer wants to receive 3 frames in each packet. 

<figure>
<artwork>
  v=0
  o=kosuke 2890844730 2890844730 IN IP4 anotherhost.example.com
  s=-
  c=IN IP4 anotherhost.example.com
  t=0 0
  m=audio 5004 RTP/AVP 96
  a=ptime:60
  a=rtpmap:96 UEMCLIP/16000/1
</artwork>
</figure>

When mode specification is not present, it should default to a fixed
mode, and in this case, Mode 1 (see <xref target="sec_dyntx"/>).

</t>

</section>

</section>

</section>

<section anchor="sec_security" title="Security Considerations">
<t>
RTP packets using the payload format defined in this specification are
subject to the security considerations discussed in the RTP
specification <xref target="RFC3550"/> and any appropriate
profiles. This implies that confidentiality of the media streams is
achieved by encryption unless the applicable profile specifies other means.</t>

<t>
A potential denial-of-service threat exists for data encoding using
compression techniques that have non-uniform receiver-end
computational load. The attacker can inject pathological datagrams
into the stream that are complex to decode and cause the receiver
output to become overloaded. However, the UEMCLIP covered in this document
do not exhibit any significant non-uniformity.</t>

<t>
Another potential threat is memory attacks by illegal layer indices
or byte numbers. The implementor of the decoder should always be aware
that the indicated numbers may be corrupted and not point to the
right sub-layer, and they may force reading beyond the bitstream
boundaries. It is advised that a decoder implementation reject layers of such indices.</t>

</section>

<section anchor="sec_iana" title="IANA Considerations">
<t>
One new media subtype (audio/UEMCLIP) has been
registered by IANA. For details, see <xref target="sec_mediatype"/>.</t>

</section>
</middle>

<back>

<?rfc rfcedstyle="no" ?>

<references title="Normative References">

&rfc2119;
&rfc3264;
&rfc3550;
&rfc3551;
&rfc4288;
&rfc4566;
&rfc4855;
&rfc4856;
&rfc5117;
<reference anchor="ITU-T-G.711">
  <front>
    <title>Pulse code modulation (PCM) of voice frequencies</title>
    <author>
      <organization>International Telecommunications Union</organization>
    </author>
    <date month="November" year="1988"/>
  </front>
  <seriesInfo name="ITU-T" value="Recommendation G.711"/>
</reference>


</references>

<references title="Informative References">

<reference anchor="ITU-T-G.711Appendix1">
  <front>
    <title>Pulse code modulation (PCM) of voice frequencies,
    Appendix I: A high quality low-complexity algorithm for packet
    loss concealment with G.711</title>
    <author>
      <organization>International Telecommunications Union</organization>
    </author>
    <date month="September" year="1999"/>
  </front>
  <seriesInfo name="ITU-T" value="Recommendation G.711 Appendix I"/>
</reference>

</references>

<?rfc rfcedstyle="yes" ?>

</back>
</rfc>
