<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc compact="yes"?>  
<?rfc subcompact="no"?>

<rfc number="7532" category="std" submissionType="IETF" consensus="yes" ipr="pre5378Trust200902">

<front>

    <title abbrev="NSDB Protocol for Federated File Systems">
    Namespace Database (NSDB) Protocol for Federated File Systems
    </title>


<author initials='J.L' surname="Lentini" fullname='James Lentini'>
    <organization>
	NetApp
    </organization>
    <address>
	<postal>
	    <street>1601 Trapelo Rd, Suite 16</street>
	    <city>Waltham</city>
	    <region>MA</region>
	    <code>02451</code>
	    <country>United States</country>
	</postal>
	<phone>+1 781-768-5359</phone>
	<email>jlentini@netapp.com</email>
    </address>
</author>


<author initials='R.T' surname="Tewari" fullname='Renu Tewari'>
    <organization>
	IBM Almaden
    </organization>
    <address>
	<postal>
	    <street>650 Harry Rd</street>
	    <city>San Jose</city>
	    <region>CA</region>
	    <code>95120</code>
	    <country>United States</country>
	</postal>
	<email>tewarir@us.ibm.com</email>
    </address>
</author>


<author initials='C.L' surname="Lever" fullname='Charles Lever' role="editor">
    <organization>
	Oracle Corporation
    </organization>
    <address>
	<postal>
	    <street>1015 Granger Avenue</street>
	    <city>Ann Arbor</city>
	    <region>MI</region>
	    <code>48104</code>
	    <country>United States</country>
	</postal>
	<phone>+1 248-614-5091</phone>
	<email>chuck.lever@oracle.com</email>
    </address>
</author>

    <date month="March" year="2015" />

    <area> Internet </area>
    <workgroup> NFSv4 Working Group </workgroup>
    <keyword>Federated File Systems</keyword>

    <abstract>

    <t> This document describes a file system federation
    protocol that enables file access and namespace traversal
    across collections of independently administered
    fileservers.  The protocol specifies a set of interfaces by
    which fileservers with different administrators can form
    a fileserver federation that provides a namespace composed
    of the file systems physically hosted on and exported by the
    constituent fileservers.  </t>

    </abstract>


</front>

<middle>

    <section title="Introduction">

    <t> A federated file system enables file access and namespace
    traversal in a uniform, secure, and consistent manner across
    multiple independent fileservers within an enterprise or
    across multiple enterprises. </t>

    <t> This document specifies a set of protocols that allow
    fileservers, possibly from different vendors and with
    different administrators, to cooperatively form a federation
    containing one or more federated file systems. Each federated
    file system's namespace is composed of the file systems physically
    hosted on and exported by the federation's fileservers. A
    federation comprises a common namespace across all its
    fileservers. A federation can project multiple namespaces and
    enable clients to traverse each one. A federation can contain
    an arbitrary number of namespace repositories, each belonging
    to a different administrative entity and each rendering a part
    of the namespace. A federation might also have an arbitrary number
    of administrative entities responsible for administering disjoint
    subsets of the fileservers. </t>

    <t> Traditionally, building a namespace that spans
    multiple fileservers has been difficult for two reasons.
    First, the fileservers that export pieces of the namespace
    are often not in the same administrative domain. Second, there
    is no standard mechanism for the fileservers to cooperatively
    present the namespace. Fileservers may provide proprietary
    management tools, and in some cases, an administrator may be
    able to use the proprietary tools to build a shared
    namespace out of the exported file systems.  However, relying on
    vendor-specific proprietary tools does not work in larger enterprises
    or when collaborating across enterprises because the fileservers
    are likely to be from multiple vendors or use different software
    versions, each with their own namespace protocols, with no common
    mechanism to manage the namespace or exchange namespace information. </t>

    <t> The federated file system protocols in this document define
    how to construct a namespace accessible by an Network File System (NFS)
    version 4.0
    <xref target="RFC7530"/>, NFSv4.1 <xref target="RFC5661"/>, or newer
    client and have been designed to accommodate other file-access
    protocols in the future. </t>

    <t> The requirements for federated file systems are described
    in <xref target="RFC5716"/>. A protocol for administering
    a fileserver's namespace is described in <xref target="RFC7533"/>.
    The mechanism for discovering the root of a federated namespace is
    described in <xref target="RFC6641"/>. </t>

    <t> In the rest of the document, the term "fileserver" denotes a
    fileserver that is part of a federation. </t>

    <section title="Requirements Language">

    <t> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
        "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",
        "MAY", and "OPTIONAL" in this document are to be
        interpreted as described in <xref target="RFC2119"/>.
    </t>

    </section>

    </section>

    <section title="Overview of Features and Concepts">

    <section title="File-Access Protocol">

        <t> A file-access protocol is a network protocol for
        accessing data. The NFSv4.0 protocol <xref target="RFC7530"/>
        is an example of a file-access protocol. </t>

    </section>

    <section title="File-Access Client">

        <t> File-access clients are standard, off-the-shelf network-attached
	storage (NAS) clients that communicate with
        fileservers using a standard file-access protocol. </t>

    </section>

    <section title="Fileserver">

        <t> Fileservers are servers that store physical fileset
        data or refer file-access clients to other fileservers.
        A fileserver provides access to its shared file system
        data via a file-access protocol.  A fileserver may be
        implemented in a number of different ways, including a
        single system, a cluster of systems, or some other
        configuration. </t>

    </section>

    <section title="Referral">

        <t> A referral is a mechanism by which a fileserver
        redirects a file-access client to a different
        fileserver or export. The exact information contained in a
        referral varies from one file-access protocol to another.
        The NFSv4.0 protocol, for example, defines the fs_locations
        attribute for returning referral information to NFSv4.0
        clients. The NFSv4.1 protocol introduces the
        fs_locations_info attribute that can return richer referral
        information to its clients.  NFSv4.1 fileservers may use
        either attribute during a referral.  Both attributes are
        defined in <xref target="RFC5661"/>. </t>

    </section>

    <section title="Namespace">

        <t> The goal of a unified namespace is to make all
        managed data available to any file-access client via the
        same path in a common file system namespace.  This should
        be achieved with minimal or zero configuration on file-access
        clients.  In particular, updates to the common namespace
        should not require configuration changes to any file-access
        client. </t>

        <t> Filesets, which are the units of data management, are
        a set of files and directories.  From the perspective of
        file-access clients, the common namespace is constructed by
        mounting filesets that are physically located on different
        fileservers.  The namespace, which is defined in terms
        of fileset names and locations, is stored in a set of
        namespace repositories, each managed by an administrative
        entity. </t>

        <t> The namespace schema defines the model used for populating,
        modifying, and querying the namespace repositories.  It is not
        required by the federation that the namespace be common
        across all fileservers.  It should be possible to have
        several independently rooted namespaces. </t>

    </section>

    <section title="Fileset">

        <t> A fileset is loosely defined as a set of files and the
        directory tree that contains them.  The fileset abstraction
        is the basic unit of data management.  Depending on the
        configuration, a fileset may be anything from an individual
        directory of an exported file system to an entire exported
        file system on a fileserver. </t>

    </section>

    <section title="Fileset Name (FSN)" anchor="fileset_name">

        <t> A fileset is uniquely represented by its fileset name
        (FSN).  An FSN is considered unique across a federation.
        After an FSN is created, it is associated with one or more
        fileset locations (FSLs) on one or more fileservers. </t>

        <t> An FSN consists of: </t>

        <t>
        <list style="hanging" hangIndent="6">

            <t hangText="   NsdbName:"> the network location of the
            Namespace Database (NSDB) node that contains authoritative
            information for this FSN. </t>

            <t hangText="   FsnUuid:"> a UUID
            (universally unique identifier), conforming to
            <xref target="RFC4122"/>, that is used to uniquely
            identify an FSN. </t>

            <t hangText="   FsnTTL:"> the time-to-live of the FSN's
            FSL information, in seconds.  Fileservers MUST NOT use
            cached FSL records after the parent FSN's FsnTTL has expired.
            An FsnTTL value of zero indicates that fileservers MUST NOT
            cache the results of resolving this FSN.</t>
        </list>
        </t>

        <t> The NsdbName is not physically stored as an attribute
        of the record.  The NsdbName is obvious to any client that
        accesses an NSDB and is indeed authenticated in cases where
        Transport Layer Security (TLS) is in effect. </t>

        <t> The FsnUuid and NsdbName values never change during an FSN's
        lifetime.  However, an FSN's FSL information can change over
        time and is typically cached on fileservers for performance.
        More detail on FSL caching is provided in
        <xref target="fsl_caching"/>. </t>

        <t> An FSN record may also contain: </t>


        <t>
        <list style="hanging" hangIndent="6">

            <t hangText="   Annotations:"> name/value pairs
            that can be interpreted by a fileserver. The semantics
            of this field are not defined by this document. These
            tuples are intended to be used by higher-level
            protocols. </t>

            <t hangText="   Descriptions:"> text
            descriptions. The semantics of this field are
            not defined by this document. </t>

        </list>
        </t>

    </section>

    <section title="Fileset Location (FSL)">

        <t> An FSL describes one physical location where a complete
        copy of the fileset's data resides.  An FSL contains generic
        and type-specific information that together describe how to
        access the fileset data at this location.  An FSL's attributes
        can be used by a fileserver to decide which locations it will
        return to a file-access client. </t>

        <t> An FSL consists of: </t>


        <t>
        <list style="hanging" hangIndent="6">

            <t hangText="   FslUuid:"> a UUID, conforming to
            <xref target="RFC4122"/>, that is used to uniquely
            identify an FSL. </t>

            <t hangText="   FsnUuid:"> the UUID of the
            FSL's FSN. </t>

            <t hangText="   NsdbName:"> the network location of the
            NSDB node that contains authoritative information for
            this FSL. </t>

        </list>
        </t>

        <t> The NsdbName is not stored as an attribute of an FSL
        record for the same reason it is not stored in FSN records. </t>

        <t> An FSL record may also contain: </t>


        <t>
        <list style="hanging" hangIndent="6">

            <t hangText="   Annotations:"> name/value pairs
            that can be interpreted by a fileserver. The semantics
            of this field are not defined by this document. These
            tuples are intended to be used by higher-level
            protocols. </t>

            <t hangText="   Descriptions:"> text
            descriptions. The semantics of this field are
            not defined by this document. </t>

        </list>
        </t>

        <t> In addition to the attributes defined above, an FSL
        record contains attributes that allow a fileserver to
        construct referrals.  For each file-access protocol, a
        corresponding FSL record subtype is defined. </t>

        <t> This document defines an FSL subtype for NFS.  An NFS
        FSL contains information suitable for use in one of the
        NFSv4 referral attributes (e.g., fs_locations or
        fs_locations_info, described in <xref target="RFC5661" />).
        <xref target="fedfsnfsfsl" /> describes the contents of an
        NFS FSL record. </t>

        <t> A fileset may also be accessible by file-access
        protocols other than NFS.  The contents and format of
        such FSL subtypes are not defined in this document. </t>

        <section anchor="nfs-uri" title="The NFS URI Scheme">

        <t> To capture the location of an NFSv4 fileset, we extend
        the NFS URL scheme specified in <xref target="RFC2224"/>.
        This extension follows rules for defining Uniform Resource
        Identifier schemes (see <xref target="RFC3986"/>).  In the
        following text, we refer to this extended NFS URL scheme as
        an NFS URI. </t>

        <t> An NFS URI MUST contain both an authority and a path
        component.  It MUST NOT contain a query component or a
        fragment component.  Use of the familiar "nfs" scheme name
        is retained. </t>

            <section title="The NFS URI Authority Component">

            <t> The rules for encoding the authority component of a
            generic URI are specified in section 3.2 of
            <xref target="RFC3986"/>.  The authority component of
            an NFS URI MUST contain the host subcomponent.  For
            globally scoped NFS URIs, a hostname used in such URIs
            SHOULD be a fully qualified domain name.  See section
            3.2.2 of <xref target="RFC3986"/> for rules on
            encoding non-ASCII characters in hostnames. </t>

            <t> An NFS URI MAY contain a port subcomponent as
            described in section 3.2.3 of <xref target="RFC3986"/>.
            If this subcomponent is missing, a port value of 2049
            is assumed, as specified in <xref target="RFC7530"/>,
            Section 3.1. </t>

            </section>

            <section title="The NFS URI Path Component">

            <t> The rules for encoding the path component of a
            generic URI are specified in Section 3.3 of
            <xref target="RFC3986"/>. </t>

            <t> According to Sections 5 and 6 of
            <xref target="RFC2224"/>, NFS URLs specify a pathname
            relative to an NFS fileserver's public filehandle.
            However, NFSv4 fileservers do not expose a public
            filehandle.  Instead, NFSv4 pathnames contained in an
            NFS URI are evaluated relative to the pseudoroot of the
            fileserver identified in the URI's authority component.
            </t>

            <t> Each component of an NFSv4 pathname is represented
            as a component4 string (see Section 3.2, "Basic Data
            Types", of <xref target="RFC5661" />).  The component4
            elements of an NFSv4 pathname are encoded as path
            segments in an NFS URI.  NFSv4 pathnames MUST be
            expressed in an NFS URI as an absolute path.
            An NFS URI path component MUST NOT be empty.
            The NFS URI path component starts with a slash ("/")
            character, followed by one or more path segments
            that each start with a slash ("/") character
            <xref target="RFC3986"/>. </t>

            <t> Therefore, a double slash always follows the
            authority component of an NFS URI.  For example, the
            NFSv4 pathname "/" is represented by two slash ("/")
            characters following an NFS URI's authority component.
            </t>

            <t>The component names of an NFSv4 pathname MUST be prepared using
            the component name rules defined in Section
            12 ("Internationalization") of <xref target="RFC7530"/>
            prior to encoding the path component of an NFS URI.
            As specified in <xref target="RFC3986"/>, any non-ASCII characters
            and any URI-reserved characters, such as the slash ("/")
            character, contained in a component4 element MUST be
            represented by URI percent encoding. </t>

            </section>

            <section title="Encoding an NFS Location in an FSL">

            <t> The path component of an NFS URI encodes the
            rootpath field of the NFSv4 fs_location4 data type or
            the "fli_rootpath" of the NFSv4 fs_locations_item4 data
            type (see <xref target="RFC5661"/>). </t>

            <t> In its server field, the NFSv4 fs_location4 data type
            contains a list of universal addresses and DNS labels.
            Each may optionally include a port number.  The exact
            encoding requirements for this information is found in
            Section 12.6 of <xref target="RFC7530"/>.  The NFSv4
            fs_locations_item4 data type encodes the same data in its
            fli_entries field (see <xref target="RFC5661"/>).  This
            information is encoded in the authority component of an
            NFS URI. </t>

            <t> The server and fli_entries fields can encode
            multiple server hostnames that share the same pathname.
            An NFS URI, and hence an FSL record, represents only a
            single hostname and pathname pair.  An NFS fileserver
            MUST NOT combine a set of FSL records into a single
            fs_location4 or fs_locations_item4 unless each FSL
            record in the set contains the same rootpath value and
            extended file system information. </t>

            </section>

        </section>

        <section title="Mutual Consistency across Fileset Locations">

        <t> All of the FSLs that have the same FSN (and thereby
        reference the same fileset) are equivalent from the
        point of view of access by a file-access client.  Different
        fileset locations for an FSN represent the same data,
        though potentially at different points in time.
        Fileset locations are equivalent but not identical.
        Locations may be either read-only or read-write.
        Typically, multiple read-write locations are backed
        by a clustered file system while read-only locations
        are replicas created by a federation-initiated or
        external replication operation.  Read-only locations may
        represent consistent point-in-time copies of a
        read-write location.  The federation protocols,
        however, cannot prevent subsequent changes to a
        read-only location nor guarantee point-in-time
        consistency of a read-only location if the
        read-write location is changing.  </t>

        <t> Regardless of the type, one file-access client may
        be referred to a location described by one FSL while
        another client chooses to use a location described by
        another FSL.  Since updates to each fileset location
        are not controlled by the federation protocol, it is the
        responsibility of administrators to guarantee the
        functional equivalence of the data.  </t>

        <t> The federation protocols do not guarantee that
        different fileset locations are mutually consistent in
        terms of the currency of their data.  However, they provide
        a means to publish currency information so that all
        fileservers in a federation can convey the same information
        to file-access clients during referrals.  Clients use this
        information to ensure they do not revert to an out-of-date
        version of a fileset's data when switching between fileset
        locations.  NFSv4.1 provides guidance on how replication can
        be handled in such a manner.  In particular, see Section 11.7
        of <xref target="RFC5661"/>.  </t>

        </section>

        <section title="Caching of Fileset Locations" anchor="fsl_caching">

        <t> To resolve an FSN to a set of FSL records, a
        fileserver queries the NSDB node named in the FSN
        for FSL records associated with this FSN.  The parent
        FSN's FsnTTL attribute (see <xref target="fileset_name"/>)
        specifies the period of time during which a fileserver may
        cache these FSL records. </t>

        <t> The combination of FSL caching and FSL migration presents
        a challenge. For example, suppose there are three fileservers
        named A, B, and C.  Suppose further that fileserver A
        contains a junction J to fileset X stored on fileserver B
        (see <xref target="junctions"/> for a description of junctions).
        </t>

        <t> Now suppose that fileset X is migrated from fileserver B
        to fileserver C, and the corresponding FSL information for
        fileset X in the authoritative NSDB is updated.  </t>

        <t> If fileserver A has cached FSLs for fileset X, a
        file-access client traversing junction J on fileserver A
        will be referred to fileserver B, even though fileset X has
        migrated to fileserver C. If fileserver A had not cached the
        FSL records, it would have queried the NSDB and obtained the
        correct location of fileset X.  </t>

        <t> Typically, the process of fileset migration leaves a
        redirection on the source fileserver in place of a migrated
        fileset (without such a redirection, file-access clients
        would find an empty space where the migrated fileset was,
        which defeats the purpose of a managed migration).  </t>

        <t> This redirection might be a new junction that targets
        the same FSN as other junctions referring to the migrated
        fileset, or it might be some other kind of directive,
        depending on the fileserver implementation, that simply
        refers file-access clients to the new location of the
        migrated fileset.  </t>

        <t> Back to our example.  Suppose, as part of the migration
        process, a junction replaces fileset X on fileserver B.
        Later, either:

        <list style="symbols">

        <t> New file-access clients are referred to fileserver
        B by stale FSL information cached on fileserver A, or </t>

        <t> File-access clients continue to access fileserver
        B because they cache stale location data for fileset X. </t>

        </list>

        </t>

        <t> In either case, thanks to the redirection, file-access
        clients are informed by fileserver B that fileset X has
        moved to fileserver C.  </t>

        <t> Such redirecting junctions (here, on fileserver B)
        would not be required to be in place forever. They need to
        stay in place at least until FSL entries cached on
        fileservers and locations cached on file-access clients
        for the target fileset are invalidated.  </t>

        <t> The FsnTTL field in the FSL's parent FSN (see
        <xref target="fileset_name"/>) specifies an upper bound for
        the lifetime of cached FSL information and thus can act
        as a lower bound for the lifetime of redirecting junctions. </t>

        <t> For example, suppose the FsnTTL field contains the value
        3600 seconds (one hour).  In such a case, administrators
        SHOULD keep the redirection in place for at least one hour
        after a fileset migration has taken place because a referring
        fileserver might cache the FSL data during that time before
        refreshing it. </t>

        <t> To get file-access clients to access the destination
        fileserver more quickly, administrators SHOULD set the
        FsnTTL field of the migrated fileset to a low number or
        zero before migration begins.  It can be reset to a
        more reasonable number at a later point.  </t>

        <t> Note that some file-access protocols do not communicate
        location cache expiry information to file-access clients.
        In some cases, it may be difficult to determine an
        appropriate lifetime for redirecting junctions because
        file-access clients may cache location information
        indefinitely.  </t>

        </section>

        <section title="Generating a Referral from Fileset Locations" anchor="fsl_referral">

        <t> After resolving an FSN to a set of FSL records, the
        fileserver generates a referral to redirect a file-access
        client to one or more of the FSN's FSLs. The fileserver
        converts the FSL records to a referral format understood
        by a particular file-access client, such as an NFSv4
        fs_locations or fs_locations_info attribute. </t>

        <t> To give file-access clients as many options as
        possible, the fileserver SHOULD include the maximum
        possible number of FSL records in a referral. However,
        the fileserver MAY omit some of the FSL records
        from the referral. For example, the fileserver might
        omit an FSL record because of limitations in the file-access
	protocol's referral format.  </t>

        <t> For a given FSL record, the fileserver MAY
        convert or reduce the FSL record's contents in a manner
        appropriate to the referral format. For example,
        an NFS FSL record contains all the data necessary to
        construct an fs_locations_info attribute,
        but an fs_locations_info attribute contains
        several pieces of information that are not found
        in the simpler fs_locations attribute.  A fileserver
        constructs entries in an fs_locations attribute using
        the relevant contents of an NFS FSL record.  </t>

        <t> Whenever the fileserver converts or reduces
        FSL data, the fileserver SHOULD attempt to maintain
        the original meaning where possible. For example, an
        NFS FSL record contains the rank and order information
        that is included in an fs_locations_info attribute
        (see NFSv4.1's FSLI4BX_READRANK, FSLI4BX_READORDER,
        FSLI4BX_WRITERANK, and FSLI4BX_WRITEORDER). While
        this rank and order information is not explicitly
        expressible in an fs_locations attribute, the
        fileserver can arrange the fs_locations
        attribute's locations list based on the rank and order
        values.  </t>

        <t> Another example:  A single NFS FSL record contains
        the hostname of one fileserver.  A single fs_locations
        attribute can contain a list of fileserver names.  An NFS
        fileserver MAY combine two or more FSL records into a
        single entry in an fs_locations or fs_locations_info array
        only if each FSL record contains the same pathname and
        extended file system information. </t>

        <t> Refer to Sections 11.9 and 11.10 of the NFSv4.1 protocol specification
        <xref target="RFC5661"/>
        for further details.  </t>

        </section>

    </section>

    <section title="Namespace Database (NSDB)">

        <t> The NSDB service is a federation-wide service that
        provides interfaces to define, update, and query FSN
        information, FSL information, and FSN-to-FSL mapping
        information.  </t>

        <t> An individual repository of namespace information
        is called an NSDB node.  The difference between the NSDB
        service and an NSDB node is analogous to that between the
        DNS service and a particular DNS server.  </t>

        <t> Each NSDB node is managed by a single administrative
        entity.  A single administrative entity can manage
        multiple NSDB nodes.  </t>

        <t> Each NSDB node stores the definition of the FSNs
        for which it is authoritative.  It also stores the
        definitions of the FSLs associated with those FSNs.  An
        NSDB node is authoritative for the filesets that it
        defines.  </t>

        <t> An NSDB MAY be replicated throughout the federation.
        If an NSDB is replicated, the NSDB MUST exhibit loose,
        converging consistency as defined in <xref target="RFC3254"/>.
        The mechanism by which this is achieved is outside the
        scope of this document. Many Lightweight Directory Access Protocol (LDAP) implementations support
        replication.  These features MAY be used to replicate
        the NSDB. </t>

        <section title="NSDB Client">

            <t> Each NSDB node supports an LDAP
            <xref target="RFC4510"/> interface.  An NSDB client
            is software that uses the LDAP protocol to access or
            update namespace information stored on an NSDB node.
            </t>

            <t> A domain's administrative entity uses NSDB client
            software to manage information stored on NSDB nodes. Details of
	    these transactions are discussed in <xref target="nsdb-ops-admins"/>.</t>

            <t> Fileservers act as an NSDB client when contacting a
            particular NSDB node to resolve an FSN to a set of FSL
            records.  The resulting location information is then
            transferred to file-access clients via referrals.
            Therefore, file-access clients never need to access
            NSDBs directly. These transactions are described in <xref
	    target="nsdb-ops-fileservers"/>.</t>

        </section>

    </section>

    <section title="Junctions and Referrals" anchor="junctions">

        <t> A junction is a point in a particular fileset namespace
        where a specific target fileset may be attached.  If a
        file-access client traverses the path leading from the root
        of a federated namespace to the junction referring to a
        target fileset, it should be able to mount and access the
        data in that target fileset (assuming appropriate
        permissions).  In other words, a junction can be viewed as a
        reference from a directory in one fileset to the root of the
        target fileset.  </t>

        <t> A junction can be implemented as a special marker on a
        directory or by some other mechanism in the fileserver's
        underlying file system.  What data is used by the fileserver
        to represent junctions is not defined by this document.  The
        essential property is that given a junction, a fileserver
        must be able to find the FSN for the target fileset.  </t>

        <t> When a file-access client reaches a junction, the
        fileserver refers the client to a list of FSLs associated
        with the FSN targeted by the junction.  The client can then
        mount one of the associated FSLs.  </t>

        <t> The federation protocols do not limit where and
        how many times a fileset is mounted in the namespace.
        Filesets can be nested; a fileset can be mounted under
        another fileset.  </t>

    </section>

    <section title="Unified Namespace and the Root Fileset">

        <t> The root fileset, when defined, is the top-level fileset
        of the federation-wide namespace. The root of the unified
        namespace is the top level directory of this fileset. A set of
        designated fileservers in the federation can export the root
        fileset to render the federation-wide unified namespace. When
        a file-access client mounts the root fileset from any of these
        designated fileservers, it can view a common federation-wide
        namespace.  </t>

    </section>

    <section anchor="sec:uuid" title="UUID Considerations">

        <t> To ensure FSN and FSL records are unique across a domain,
        Federated File System (FedFS) employs UUIDs conforming to <xref target="RFC4122"/> to
        form the distinguished names of LDAP records containing FedFS
        data (see <xref target="fedfsfsn"/>).  </t>

        <t> Because junctions store a tuple containing an FSN UUID and
        the name and port of an NSDB node, an FSN UUID must be unique
        only on a single NSDB node.  An FSN UUID collision can be
        detected immediately when an administrator attempts to publish
        an FSN or FSL by storing it under a specific NSDB Container Entry
        (NCE) on an authoritative NSDB host.  </t>

        <t> Note that one NSDB node may store multiple NCEs, each under
        a different namingContext.  If an NSDB node must contain more
        than one NCE, the federation's admin entity SHOULD provide a
        robust method for preventing FSN UUID collisions between FSNs
        that reside on the same NSDB node but under different NCEs.  </t>

        <t> Because FSLs are children of FSNs, FSL UUIDs must be unique
        for just a single FSN.  As with FSNs, as soon as an FSL is
        published, its uniqueness is guaranteed.  </t>

        <t> A fileserver performs the operations described in
        <xref target="nsdb-ops-fileservers"/> as an unauthenticated user.
        Thus, distinguished names of FSN and FSL records, as well as
        the FSN and FSL records themselves, are required to be readable
        by anyone who can bind anonymously to an NSDB node.  Therefore,
        FSN and FSL UUIDs should be considered public information.  </t>

        <t> Version 1 UUIDs contain a host's Media Access Control (MAC) address and a timestamp
        in the clear.  This gives provenance to each UUID, but attackers
        can use such details to guess information about the host where the
        UUID was generated.  Security-sensitive installations should be
        aware that on externally facing NSDBs, UUIDs can reveal
        information about the hosts where they are generated.  </t>

        <t> In addition, version 1 UUIDs depend on the notion that a
        hardware MAC address is unique across machines.  As virtual
        machines do not depend on unique physical MAC addresses and,
        in any event, an administrator can modify the physical MAC
        address, version 1 UUIDs are no longer considered sufficient.  </t>

        <t> To minimize the probability of UUIDs colliding, a
        consistent procedure for generating UUIDs should be used
        throughout a federation.  Within a federation, UUIDs SHOULD be
        generated using the procedure described for version 4 of the
        UUID variant specified in <xref target="RFC4122"/>.  </t>

    </section>

    </section>

    <section title="Examples">

    <t> In this section we provide examples and discussion of
    the basic operations facilitated by the federated
    file system protocol:  creating a fileset, adding a replica of a
    fileset, resolving a junction, and creating a junction. </t>

    <section title="Creating a Fileset and Its FSL(s)">

        <t> A fileset is the abstraction of a set of files and
        the directory tree that contains them.  The fileset
        abstraction is the fundamental unit of data management
        in the federation.  This abstraction is implemented by
        an actual directory tree whose root location is
        specified by a fileset location (FSL).  </t>

        <t> In this section, we describe the basic requirements
        for starting with a directory tree and creating a
        fileset that can be used in the federation protocols.
        Note that we do not assume that the process of creating
        a fileset requires any transformation of the files or
        the directory hierarchy.  The only thing that is
        required by this process is assigning the fileset a
        fileset name (FSN) and expressing the location of the
        implementation of the fileset as an FSL.  </t>

        <t> There are many possible variations to this
        procedure, depending on how the FSN that binds the FSL
        is created and whether other replicas of the fileset
        exist, are known to the federation, and need to be bound
        to the same FSN.  </t>

        <t> It is easiest to describe this in terms of how to
        create the initial implementation of the fileset and
        then describe how to add replicas.  </t>

        <section title="Creating a Fileset and an FSN">

            <t> The following administrative steps create 
                an FSN, which is used to track all
                replicas of a single physical dataset.  </t>

        <t>
            <list style="numbers">

            <t> Choose the NSDB node that will keep
                track of the FSL(s) and related
                information for the fileset. </t>

            <t> Create an FSN in the NSDB node.

                <vspace blankLines="1" />

                The FSN UUID is chosen by the administrator
                or generated automatically by administration software.
                The former case is used if the fileset is being
                restored, perhaps as part of disaster
                recovery, and the administrator wishes to
                specify the FSN UUID in order to permit
                existing junctions that reference that
                FSN to work again.

                <vspace blankLines="1" />

                At this point, the FSN exists, but its
                fileset locations are unspecified. </t>

            <t> For the FSN created above, create an
                FSL in the NSDB node that describes the
                physical location of the fileset data.  </t>

            </list>
        </t>

        </section>

        <section title="Adding a Replica of a Fileset">

        <t> Adding a replica is straightforward:  the NSDB
        node and the FSN are already known.  The only
        remaining step is to add another FSL. </t>

        <t> Note that the federation protocols provide only
        the mechanisms to register and unregister replicas
        of a fileset. Fileserver-to-fileserver replication
        protocols are not defined. </t>

        </section>

    </section>

    <section title="Junction Resolution">

        <t> A fileset may contain references to other filesets.
        These references are represented by junctions.  If a
        file-access client requests access to a fileset object that
        is a junction, the fileserver resolves the junction to
        discover one or more FSLs that implement the referenced
        fileset. </t>

        <t> There are many possible variations to this
        procedure, depending on how the junctions are
        represented by the fileserver and how the fileserver
        performs junction resolution. </t>

        <t> Step 4 is the only step that interacts directly with
        the federation protocols.  The rest of the steps may
        use platform-specific interfaces. </t>

        <t>
        <list style="numbers">

            <t> The fileserver determines that the object being
            accessed is a junction.  </t>

            <t> The fileserver does a local lookup to find the
            FSN of the target fileset.  </t>

            <t> Using the FSN, the fileserver finds the NSDB
            node responsible for the target FSN.  </t>

            <t> The fileserver contacts that NSDB node and
            asks for the set of FSLs that implement the target
            FSN.  The NSDB node responds with a (possibly
            empty) set of FSLs.  </t>

            <t> The fileserver converts one or more of the FSLs to
            the location type used by the file-access client (e.g.,
            an NFSv4 fs_locations attribute as described in
            <xref target="RFC5661"/>).  </t>

            <t> The fileserver redirects (in whatever manner is
            appropriate for the client) the client to the
            location(s).  </t>

        </list>
        </t>

    </section>

    <section title="Example Use Cases for Fileset Annotations">

        <t> Fileset annotations can convey additional attributes of
        a fileset.  For example, fileset annotations can be used to
        define relationships between filesets that can be used by
        an auxiliary replication protocol.  Consider the scenario
        where a fileset is created and mounted at some point in
        the namespace.  A snapshot of the read-write FSL of that
        fileset is taken periodically at different frequencies
        (say, a daily or weekly snapshot).  The
        different snapshots are mounted at different locations
        in the namespace. </t>

        <t> The daily snapshots are considered as
        different filesets from the weekly ones, but both are
        related to the source fileset.  We can define
        an annotation labeling the filesets as source and
        replica.  The replication protocol can use this
        information to copy data from one or more FSLs of the
        source fileset to all the FSLs of the replica fileset.
        The replica filesets are read-only while the source
        fileset is read-write. </t>

        <t> This follows the traditional Andrew File System (AFS)
        model of mounting the read-only volume at a path in the
        namespace different from that of the read-write volume
        <xref target="AFS"/>. </t>

        <t> The federation protocol does not control or manage
        the relationship among filesets.  It merely enables
        annotating the filesets with user-defined relationships.
        </t>

        <t> Another potential use for annotations is recording
        references to an FSN. A single annotation containing
        the number of references could be defined, or multiple
        annotations, one per reference, could be used to store
        detailed information on the location of each reference.
        </t>

        <t> As with the replication annotation described above, the
        maintenance of reference information would not be controlled
        by the federation protocol. The information would most
        likely be non-authoritative because the ability to
        create a junction does not require the authority to
        update the FSN record. In any event, such annotations
        could be useful to administrators for determining if an
        FSN is referenced by a junction. </t>

    </section>
    </section>

    <section title="NSDB Configuration and Schema" anchor= "nsdb-config">

    <t> This section describes how an NSDB is constructed using
    an LDAP Version 3 <xref target="RFC4510"/> directory.
    <xref target="ldap-config"/> describes the basic properties of
    the LDAP configuration that MUST be used in order to ensure
    compatibility between different implementations.
    <xref target="ldap-schema"/> defines the new LDAP
    attribute types and the new object types; it also specifies how the
    distinguished name (DN) of each object instance MUST be
    constructed.  </t>

    <section title="LDAP Configuration" anchor="ldap-config">

        <t> An NSDB is constructed using an LDAP directory.
        This LDAP directory MAY have multiple naming contexts.
        The LDAP directory's entry specific to Digital Signature Algorithm (DSA) (its rootDSE)
        has a multi-valued namingContext attribute.  Each value
        of the namingContext attribute is the DN of a naming
        context's root entry (see <xref target="RFC4512"/>). </t>

        <t> For each naming context that contains federation
        entries (e.g., FSNs and FSLs): </t>

        <t>
        <list style="numbers">

        <t> There MUST be an LDAP entry that is superior
            to all of the naming context's federation entries in
            the Directory Information Tree (DIT). This entry is
            termed the NSDB Container Entry (NCE). The NCE's
            children are FSNs. An FSN's children are FSLs.
            </t>

        <t> The naming context's root entry MUST include
            "fedfsNsdbContainerInfo" (defined in
            <xref target="nsdbcontainer"/>)
            as one of its object classes. The
            fedfsNsdbContainerInfo's fedfsNceDN
            attribute is used to locate the naming context's
            NCE.
        </t>

        </list>
        </t>

        <t> If a naming context does not contain federation entries,
        it will not contain an NCE, and its root entry will not include
        a "fedfsNsdbContainerInfo" as one of its object classes. </t>

        <t> A fedfsNsdbContainerInfo's fedfsNceDN attribute
        contains the distinguished name (DN) of the NSDB Container
        Entry residing under this naming context. The fedfsNceDN
        attribute MUST NOT be empty. </t>

        <t> For example, an LDAP directory might have the following
        entries: </t>

        <figure><artwork><![CDATA[
        -+ [root DSE]
         |  namingContext: o=fedfs
         |  namingContext: dc=example,dc=com
         |  namingContext: ou=system
         |
         |
         +---- [o=fedfs]
         |      fedfsNceDN: o=fedfs
         |
         |
         +---- [dc=example,dc=com]
         |      fedfsNceDN: ou=fedfs,ou=corp-it,dc=example,dc=com
         |
         |
         +---- [ou=system]
        ]]></artwork></figure>

        <t> In this case, the "o=fedfs" namingContext has an NSDB
        Container Entry at "o=fedfs", the "dc=example,dc=com" namingContext
        has an NSDB Container Entry at "ou=fedfs,ou=corp-it,dc=example,dc=com",
        and the "ou=system" namingContext has no NSDB Container Entry. </t>

        <t> The NSDB SHOULD be configured with one or more privileged
        LDAP users. These users are able to modify the contents of the
        LDAP database. An administrator that performs the operations
        described in <xref target="nsdb-ops-admins"/> SHOULD authenticate
        using the DN of a privileged LDAP user. </t>

        <t> It MUST be possible for an unprivileged (unauthenticated)
        user to perform LDAP queries that access the NSDB data. A
        fileserver performs the operations described in
        <xref target="nsdb-ops-fileservers"/> as an unprivileged user. </t>

        <t> All implementations SHOULD use the same schema.  At minimum,
        each MUST use a schema that includes all objects named in the
        following sections, with all associated attributes.  If it is
        necessary for an implementation to extend the schema defined
        here, consider using one of the following ways to extend the
        schema: </t>

        <t>
            <list style="symbols">

            <t> Define a fedfsAnnotation key and values (see <xref
            target="fedfsAnnotation"/>).  Register the new key and
            values with IANA (see <xref target="annotation-registry"/>).
            </t>

            <t> Define additional attribute types and object classes,
            then have entries inherit from a class defined in this
            document and from the implementation-defined ones. </t>

            </list>
        </t>

        <t> Given the above configuration guidelines, an NSDB SHOULD
        be constructed using a dedicated LDAP server.  If LDAP
        directories are needed for other purposes, such as to store
        user account information, use of a separate LDAP server
        for those is RECOMMENDED.  By using an LDAP server dedicated
        to storing NSDB records, there is no need to disturb the
        configuration of any other LDAP directories that store
        information unrelated to an NSDB. </t>

    </section>

    <section title="LDAP Schema" anchor="ldap-schema">

        <t> The schema definitions provided in this document use the LDAP schema
        syntax defined in <xref target="RFC4512"/>. The definitions are
        formatted to allow the reader to easily extract them from the document.
        The reader can use the following shell script to extract the definitions: </t>

        <figure><artwork><![CDATA[
        <CODE BEGINS>

        #!/bin/sh
        grep '^ *///' | sed 's?^ */// ??' | sed 's?^ *///$??'

        <CODE ENDS>
        ]]></artwork></figure>

        <t> If the above script is stored in a file called "extract.sh", and
        this document is in a file called "spec.txt", then the reader can do: </t>

        <figure><artwork><![CDATA[
        <CODE BEGINS>

        sh extract.sh < spec.txt > fedfs.schema

        <CODE ENDS>
        ]]></artwork></figure>

        <t> The effect of the script is to remove leading white space from each
            line, plus a sentinel sequence of "///". </t>

        <t> Code components extracted from this document must include the
            following license: </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
  /// #
  /// # Copyright (c) 2015 IETF Trust and the persons identified
  /// # as authors of the code.  All rights reserved.
  /// #
  /// # The authors of the code are:
  /// # J. Lentini, C. Everhart, D. Ellard, R. Tewari, and M. Naik.
  /// #
  /// # Redistribution and use in source and binary forms, with
  /// # or without modification, are permitted provided that the
  /// # following conditions are met:
  /// #
  /// # - Redistributions of source code must retain the above
  /// #   copyright notice, this list of conditions and the
  /// #   following disclaimer.
  /// #
  /// # - Redistributions in binary form must reproduce the above
  /// #   copyright notice, this list of conditions and the
  /// #   following disclaimer in the documentation and/or other
  /// #   materials provided with the distribution.
  /// #
  /// # - Neither the name of Internet Society, IETF or IETF
  /// #   Trust, nor the names of specific contributors, may be
  /// #   used to endorse or promote products derived from this
  /// #   software without specific prior written permission.
  /// #
  /// #   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
  /// #   AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
  /// #   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  /// #   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  /// #   FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
  /// #   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  /// #   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  /// #   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  /// #   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  /// #   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  /// #   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  /// #   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  /// #   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  /// #   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  /// #   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  /// #
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        <section title="LDAP Attributes">

        <t> The following definitions are used in this document: </t>

        <t>
            <list style="symbols">

            <t> The name attribute described in <xref target="RFC4519"/>.  </t>

            <t> The Integer syntax (1.3.6.1.4.1.1466.115.121.1.27) described in <xref target="RFC4517"/>.  </t>

            <t> The integerMatch rule described in <xref target="RFC4517"/>.  </t>

            <t> The Octet String syntax (1.3.6.1.4.1.1466.115.121.1.40) described in <xref target="RFC4517"/>.  </t>

            <t> The octetStringMatch rule described in <xref target="RFC4517"/>.  </t>

            <t> The Boolean syntax (1.3.6.1.4.1.1466.115.121.1.7) described in <xref target="RFC4517"/>.  </t>

            <t> The booleanMatch rule described in <xref target="RFC4517"/>.  </t>

            <t> The distinguishedNameMatch rule described in <xref target="RFC4517"/>.  </t>

            <t> The DN syntax (1.3.6.1.4.1.1466.115.121.1.12) described in <xref target="RFC4517"/>.  </t>

            <t> The labeledURI attribute described in <xref target="RFC2079"/>.  </t>

            <t> The UUID syntax (1.3.6.1.1.16.1) described in <xref target="RFC4530"/>.  </t>

            <t> The UuidMatch rule described in <xref target="RFC4530"/>.  </t>

            <t> The UuidOrderingMatch rule described in <xref target="RFC4530"/>.  </t>

            </list>
        </t>

        <section title="fedfsUuid">

            <t> A fedfsUuid is the base type for all of the
            universally unique identifiers (UUIDs) used by the
            federated file system protocols.  </t>

            <t> The fedfsUuid type is based on rules and syntax
            defined in <xref target="RFC4530"/>. </t>

            <t> A fedfsUuid is a single-valued LDAP attribute. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.1 NAME 'fedfsUuid'
        ///     DESC 'A UUID used by NSDB'
        ///     EQUALITY uuidMatch
        ///     ORDERING uuidOrderingMatch
        ///     SYNTAX 1.3.6.1.1.16.1
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsFsnUuid">

            <t> A fedfsFsnUuid represents the UUID component of an FSN.
            An NSDB SHOULD ensure that no two FSNs it stores have the same
            fedfsFsnUuid. </t>

            <t> This attribute is single-valued.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.4 NAME 'fedfsFsnUuid'
        ///     DESC 'The FSN UUID component of an FSN'
        ///     SUP fedfsUuid
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsFsnTTL">

            <t> A fedfsFsnTTL is the time-to-live in seconds of a
            cached FSN and its child FSL records.  It corresponds to
            the FsnTTL as defined in <xref target="fileset_name"/>.
            See also <xref target="fsl_caching"/> for
            information about caching FSLs.  A fedfsFsnTTL MUST be
            encoded as an Integer syntax value
            <xref target="RFC4517"/> in the range [0, 4294967295].  </t>

            <t> This attribute is single-valued.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.11 NAME 'fedfsFsnTTL'
        ///     DESC 'Time to live of an FSN tree'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNceDN">

            <t> A fedfsNceDN stores a distinguished name (DN). </t>

            <t> This attribute is single-valued.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.14 NAME 'fedfsNceDN'
        ///     DESC 'NCE Distinguished Name'
        ///     EQUALITY distinguishedNameMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.12
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.12 is the DN
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsFslUuid">

            <t> A fedfsFslUuid represents the UUID of an FSL.
            An NSDB SHOULD ensure that no two FSLs it stores have the same
            fedfsFslUuid. </t>

            <t> This attribute is single-valued.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.8 NAME 'fedfsFslUuid'
        ///     DESC 'UUID of an FSL'
        ///     SUP fedfsUuid
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsAnnotation" anchor="fedfsAnnotation">

            <t> A fedfsAnnotation contains an object annotation
            formatted as a key/value pair. </t>

            <t> This attribute is multi-valued; an object type that
            permits annotations may have any number of annotations
            per instance. </t>

            <t> A fedfsAnnotation attribute is a human-readable
            sequence of UTF-8 characters with no non-terminal NUL
            characters. The value MUST be formatted according to
            the following ABNF <xref target="RFC5234"/> rules: </t>

<figure><artwork type="abnf">
   ANNOTATION = KEY "=" VALUE 
   KEY        = ITEM 
   VALUE      = ITEM 
   ITEM       = *WSP DQUOTE UTF8-octets DQUOTE *WSP 
</artwork>
</figure>
           <t> DQUOTE and WSP are defined in <xref target="RFC5234"/>,
           and UTF8-octets is defined in <xref target="RFC3629"/>. </t>

           <t> The following escape sequences are allowed: </t>

            <texttable>
            <ttcol align='center'>escape sequence</ttcol>
            <ttcol align='center'>replacement</ttcol>
                <c>\\</c>
                <c>\ </c>
                <c>\"</c>
                <c>" </c>
            </texttable>

            <t> A fedfsAnnotation value might be processed as follows: </t>

                <t><list style="numbers">
            <t> Parse the attribute value according to the ANNOTATION rule,
                ignoring the escape sequences above. </t>
            <t> Scan through results of the previous step and replace the
                escape sequences above. </t>
                </list></t>

            <t> A fedfsAnnotation attribute that does not adhere to this
            format SHOULD be ignored in its entirety.  It MUST NOT prevent
            further processing of its containing entry. </t>

            <t> The following are examples of valid fedfsAnnotation attributes: </t>

            <figure><artwork><![CDATA[
         "key1" = "foo"
         "another key" = "x=3"
         "key-2" = "A string with \" and \\ characters."
         "key3"="bar"
            ]]></artwork></figure>

            <t>These correspond to the following key/value pairs: </t>

            <texttable>
            <ttcol align='center'>key</ttcol>
            <ttcol align='center'>value</ttcol>
                <c>key1</c>
                <c>foo</c>
                <c>another key</c>
                <c>x=3</c>
                <c>key-2</c>
                <c>A string with " and \ characters.</c>
                <c>key3</c>
                <c>bar</c>
            </texttable>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.12 NAME 'fedfsAnnotation'
        ///     DESC 'Annotation of an object'
        ///     SUP name
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsDescr">

            <t> A fedfsDescr stores an object description.
            The description MUST be encoded as a UTF-8 string.  </t>

            <t> This attribute is multi-valued, which permits
            any number of descriptions per entry.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.13 NAME 'fedfsDescr'
        ///     DESC 'Description of an object'
        ///     SUP name
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsNfsURI">

            <t> A fedfsNfsURI stores the host and pathname components
            of an FSL.  A fedfsNfsURI MUST be encoded as an NFS URI
            (see <xref target="nfs-uri"/>). </t>

            <t> The fedfsNfsURI is a subtype of the labeledURI type
            <xref target="RFC2079"/>, with the same encoding rules. </t>

            <t> This attribute is single-valued.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.120 NAME 'fedfsNfsURI'
        ///     DESC 'Location of fileset'
        ///     SUP labeledURI
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsNfsCurrency">

            <t> A fedfsNfsCurrency stores the NFSv4.1 fs_locations_server's
            fls_currency value <xref target="RFC5661"/>. A fedfsNfsCurrency
            MUST be encoded as an Integer syntax value <xref target="RFC4517"/>
            in the range [-2147483648, 2147483647]. </t>

            <t> This attribute is single-valued.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.103 NAME 'fedfsNfsCurrency'
        ///     DESC 'up-to-date measure of the data'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsGenFlagWritable">

            <t> A fedfsNfsGenFlagWritable stores the
            value of an FSL's NFSv4.1 FSLI4GF_WRITABLE bit
            <xref target="RFC5661"/>. A value of "TRUE"
            indicates the bit is set. A value of
            "FALSE" indicates the bit is not set. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
       ///
       /// attributetype (
       ///     1.3.6.1.4.1.31103.1.104 NAME 'fedfsNfsGenFlagWritable'
       ///     DESC 'Indicates if the file system is writable'
       ///     EQUALITY booleanMatch
       ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.7
       ///     SINGLE-VALUE
       ///     )
       ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.7 is the Boolean
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsGenFlagGoing">

            <t> A fedfsNfsGenFlagGoing stores the
            value of an FSL's NFSv4.1 FSLI4GF_GOING bit
            <xref target="RFC5661"/>. A value of "TRUE"
            indicates the bit is set. A value of
            "FALSE" indicates the bit is not set. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.105 NAME 'fedfsNfsGenFlagGoing'
        ///     DESC 'Indicates if the file system is going'
        ///     EQUALITY booleanMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.7
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.7 is the Boolean
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsGenFlagSplit">

            <t> A fedfsNfsGenFlagSplit stores the
            value of an FSL's NFSv4.1 FSLI4GF_SPLIT bit
            <xref target="RFC5661"/>. A value of "TRUE"
            indicates the bit is set. A value of
            "FALSE" indicates the bit is not set. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.106 NAME 'fedfsNfsGenFlagSplit'
        ///     DESC 'Indicates if there are multiple file systems'
        ///     EQUALITY booleanMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.7
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.7 is the Boolean
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsTransFlagRdma">

            <t> A fedfsNfsTransFlagRdma stores the
            value of an FSL's NFSv4.1 FSLI4TF_RDMA bit
            <xref target="RFC5661"/>. A value of "TRUE"
            indicates the bit is set. A value of
            "FALSE" indicates the bit is not set. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.107 NAME 'fedfsNfsTransFlagRdma'
        ///     DESC 'Indicates if the transport supports RDMA'
        ///     EQUALITY booleanMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.7
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.7 is the Boolean
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsClassSimul">

            <t> A fedfsNfsClassSimul contains the FSL's NFSv4.1
            FSLI4BX_CLSIMUL <xref target="RFC5661"/> value. A
            fedfsNfsClassSimul MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.108 NAME 'fedfsNfsClassSimul'
        ///     DESC 'The simultaneous-use class of the file system'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsClassHandle">

            <t> A fedfsNfsClassHandle contains the FSL's NFSv4.1
            FSLI4BX_CLHANDLE <xref target="RFC5661"/> value. A
            fedfsNfsClassHandle MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.109 NAME 'fedfsNfsClassHandle'
        ///     DESC 'The handle class of the file system'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsClassFileid">

            <t> A fedfsNfsClassFileid contains the FSL's NFSv4.1
            FSLI4BX_CLFILEID <xref target="RFC5661"/> value. A
            fedfsNfsClassFileid MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.110 NAME 'fedfsNfsClassFileid'
        ///     DESC 'The fileid class of the file system'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsClassWritever">

            <t> A fedfsNfsClassWritever contains the FSL's NFSv4.1
            FSLI4BX_CLWRITEVER <xref target="RFC5661"/> value. A
            fedfsNfsClassWritever MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.111 NAME 'fedfsNfsClassWritever'
        ///     DESC 'The write-verifier class of the file system'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsClassChange">

            <t> A fedfsNfsClassChange contains the FSL's NFSv4.1
            FSLI4BX_CLCHANGE <xref target="RFC5661"/> value. A
            fedfsNfsClassChange MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.112 NAME 'fedfsNfsClassChange'
        ///     DESC 'The change class of the file system'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsClassReaddir">

            <t> A fedfsNfsClassReaddir contains the FSL's NFSv4.1
            FSLI4BX_CLREADDIR <xref target="RFC5661"/> value. A
            fedfsNfsClassReaddir MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.113 NAME 'fedfsNfsClassReaddir'
        ///     DESC 'The readdir class of the file system'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsReadRank">

            <t> A fedfsNfsReadRank contains the FSL's NFSv4.1
            FSLI4BX_READRANK <xref target="RFC5661"/> value. A
            fedfsNfsReadRank MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.114 NAME 'fedfsNfsReadRank'
        ///     DESC 'The read rank of the file system'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsReadOrder">

            <t> A fedfsNfsReadOrder contains the FSL's NFSv4.1
            FSLI4BX_READORDER <xref target="RFC5661"/> value. A
            fedfsNfsReadOrder MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.115 NAME 'fedfsNfsReadOrder'
        ///     DESC 'The read order of the file system'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsWriteRank">

            <t> A fedfsNfsWriteRank contains the FSL's
            FSLI4BX_WRITERANK <xref target="RFC5661"/> value. A
            fedfsNfsWriteRank MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>


            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.116 NAME 'fedfsNfsWriteRank'
        ///     DESC 'The write rank of the file system'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsWriteOrder">

            <t> A fedfsNfsWriteOrder contains the FSL's
            FSLI4BX_WRITEORDER <xref target="RFC5661"/> value. A
            fedfsNfsWriteOrder MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.117 NAME 'fedfsNfsWriteOrder'
        ///     DESC 'The write order of the file system'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsVarSub">

            <t> A fedfsNfsVarSub stores the
            value of an FSL's NFSv4.1 FSLI4IF_VAR_SUB bit
            <xref target="RFC5661"/>. A value of "TRUE"
            indicates the bit is set. A value of
            "FALSE" indicates the bit is not set. </t>
            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.118 NAME 'fedfsNfsVarSub'
        ///     DESC 'Indicates if variable substitution is present'
        ///     EQUALITY booleanMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.7
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.7 is the Boolean
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsValidFor">

            <t> A fedfsNfsValidFor stores an FSL's NFSv4.1 fs_locations_info
            fli_valid_for value <xref target="RFC5661"/>. A fedfsNfsValidFor
            MUST be encoded as an Integer syntax value <xref target="RFC4517"/>
            in the range [-2147483648, 2147483647].  </t>

            <t> An FSL's parent's fedfsFsnTTL value and its fedfsNfsValidFor
            value MAY be different.  </t>

            <t> This attribute is single-valued.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.19 NAME 'fedfsNfsValidFor'
        ///     DESC 'Valid for time'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

            <t> &lt;CODE ENDS> </t>

        </section>

        </section> <!-- LDAP Attributes -->

        <section title="LDAP Object Classes">

        <section title="fedfsNsdbContainerInfo" anchor="nsdbcontainer">

            <t> A fedfsNsdbContainerInfo describes the location of
            the NCE.  </t>

            <t> A fedfsNsdbContainerInfo's fedfsNceDN attribute is
            REQUIRED.  </t>

            <t> A fedfsNsdbContainerInfo's fedfsAnnotation and
            fedfsDescr attributes are OPTIONAL.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
       ///
       /// objectclass (
       ///     1.3.6.1.4.1.31103.1.1001 NAME 'fedfsNsdbContainerInfo'
       ///     DESC 'Describes NCE location'
       ///     SUP top AUXILIARY
       ///     MUST (
       ///             fedfsNceDN
       ///     )
       ///     MAY (
       ///             fedfsAnnotation
       ///             $ fedfsDescr
       ///     ))
       ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsFsn" anchor="fedfsfsn">

            <t> A fedfsFsn represents an FSN.  </t>

            <t> A fedfsFsn's fedfsFsnUuid and fedfsFsnTTL attributes
            are REQUIRED.  </t>

            <t> A fedfsFsn's fedfsAnnotation and
            fedfsDescr attributes are OPTIONAL.  </t>

            <t> The DN of an FSN is REQUIRED to take the following
            form: "fedfsFsnUuid=$FSNUUID,$NCE", where $FSNUUID
            is the UUID of the FSN and $NCE is the DN of the NCE.
            Since LDAP requires a DN to be unique, this ensures that
            each FSN entry has a unique UUID value within the LDAP
            directory.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// objectclass (
        ///     1.3.6.1.4.1.31103.1.1002 NAME 'fedfsFsn'
        ///     DESC 'Represents a fileset'
        ///     SUP top STRUCTURAL
        ///     MUST (
        ///             fedfsFsnUuid
        ///             $ fedfsFsnTTL
        ///     )
        ///     MAY (
        ///             fedfsAnnotation
        ///             $ fedfsDescr
        ///     ))
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsFsl" anchor="fedfsfsl">

            <t> The fedfsFsl object class represents an FSL.  </t>

            <t> The fedfsFsl is an abstract object class. Protocol-specific
	    subtypes of this object class are used to
            store FSL information. The fedfsNfsFsl object
            class defined in <xref target="fedfsnfsfsl"/>
            is used to record an NFS FSL's
            location.  Other subtypes MAY be defined for other
            protocols (e.g., Common Internet File System (CIFS)).  </t>

            <t> A fedfsFsl's fedfsFslUuid and fedfsFsnUuid
            attributes are REQUIRED.  </t>

            <t> A fedfsFsl's fedfsAnnotation and fedfsDescr
            attributes are OPTIONAL.  </t>

            <t> The DN of an FSL is REQUIRED to take the following
            form: "fedfsFslUuid=$FSLUUID,fedfsFsnUuid=$FSNUUID,$NCE",
            where $FSLUUID is the FSL's UUID, $FSNUUID is the FSN's
            UUID, and $NCE is the DN of the NCE.  Since LDAP
            requires a DN to be unique, this ensures that each
            FSL entry has a unique UUID value within the LDAP
            directory.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// objectclass (
        ///     1.3.6.1.4.1.31103.1.1003 NAME 'fedfsFsl'
        ///     DESC 'A physical location of a fileset'
        ///     SUP top ABSTRACT
        ///     MUST (
        ///             fedfsFslUuid
        ///             $ fedfsFsnUuid
        ///     )
        ///     MAY (
        ///             fedfsAnnotation
        ///             $ fedfsDescr
        ///     ))
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsNfsFsl" anchor="fedfsnfsfsl">

            <t> A fedfsNfsFsl is used to represent an
            NFS FSL. The fedfsNfsFsl inherits all of the
            attributes of the fedfsFsl and extends the
            fedfsFsl with information specific to the
            NFS protocol. </t>

            <t> The DN of an NFS FSL is REQUIRED to take the following
            form: "fedfsFslUuid=$FSLUUID,fedfsFsnUuid=$FSNUUID,$NCE",
            where $FSLUUID is the FSL's UUID, $FSNUUID is the FSN's
            UUID, and $NCE is the DN of the NCE.  Since LDAP
            requires a DN to be unique, this ensures that each
            NFS FSL entry has a unique UUID value within the LDAP
            directory.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// objectclass (
        ///     1.3.6.1.4.1.31103.1.1004 NAME 'fedfsNfsFsl'
        ///     DESC 'An NFS location of a fileset'
        ///     SUP fedfsFsl STRUCTURAL
        ///     MUST (
        ///             fedfsNfsURI
        ///             $ fedfsNfsCurrency
        ///             $ fedfsNfsGenFlagWritable
        ///             $ fedfsNfsGenFlagGoing
        ///             $ fedfsNfsGenFlagSplit
        ///             $ fedfsNfsTransFlagRdma
        ///             $ fedfsNfsClassSimul
        ///             $ fedfsNfsClassHandle
        ///             $ fedfsNfsClassFileid
        ///             $ fedfsNfsClassWritever
        ///             $ fedfsNfsClassChange
        ///             $ fedfsNfsClassReaddir
        ///             $ fedfsNfsReadRank
        ///             $ fedfsNfsReadOrder
        ///             $ fedfsNfsWriteRank
        ///             $ fedfsNfsWriteOrder
        ///             $ fedfsNfsVarSub
        ///             $ fedfsNfsValidFor
        ///     ))
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        </section>

    </section>

    </section>

    <section title="NSDB Operations" anchor="nsdb-ops">

    <t> The operations defined by the protocol can be described
    as several sub-protocols that are used by entities within
    a federation to perform different roles.  </t>

    <t> The first of these sub-protocols defines how the state
    of an NSDB node can be initialized and updated.  The
    primary use of this sub-protocol is by an administrator to
    add, edit, or delete filesets, their properties, and their
    fileset locations.  </t>

    <t> The second of these sub-protocols defines the queries
    that are sent to an NSDB node in order to perform
    resolution (or to find other information about the data
    stored within that NSDB node) and the responses returned
    by the NSDB node.  The primary use of this sub-protocol
    is by a fileserver in order to perform resolution, but
    it may also be used by an administrator to query the state
    of the system.  </t>

    <t> The first and second sub-protocols are defined as LDAP
    operations, using the schema defined in the previous section.
    If each NSDB node is a standard LDAP server, then, in
    theory, it is unnecessary to describe the LDAP operations in
    detail because the operations are ordinary LDAP operations
    to query and update records.  However, we do not require
    that an NSDB node implement a complete LDAP service.
    Therefore, we define the minimum level of
    LDAP functionality required to implement an NSDB node. </t>

    <t> The NSDB sub-protocols are defined in
    <xref target="nsdb-ops-admins"/> and
    <xref target="nsdb-ops-fileservers"/>.
    The descriptions of LDAP messages in these
    sections use the LDAP Data Interchange Format (LDIF)
    <xref target="RFC2849"/>. In order to differentiate constant
    and variable strings in the LDIF specifications, variables
    are prefixed by a $ character and use all uppercase characters.
    For example, a variable named FOO would be specified as $FOO. </t>

    <t> This document uses the term "NSDB client" to refer to an LDAP
    client that uses either of the NSDB sub-protocols.</t>

    <t> The third sub-protocol defines the queries and
    other requests that are sent to a fileserver in order to
    get information from it or to modify the state of the
    fileserver in a manner related to the federation
    protocols.  The primary purpose of this protocol is for
    an administrator to create or delete a junction or discover
    related information about a particular fileserver. </t>

    <t> The third sub-protocol is defined as an Open Network Computing (ONC)
    Remote Procedure Call (RPC) protocol.
    The reason for using ONC RPC instead of LDAP is that all
    fileservers support ONC RPC, but some do not support an LDAP
    directory server.  </t>

    <t> The ONC RPC administration protocol is defined in
    <xref target="RFC7533"/>. </t>

    <section title="NSDB Operations for Administrators" anchor="nsdb-ops-admins">

        <t> The admin entity initiates and controls the commands
        to manage fileset and namespace information.  The protocol
        used for communicating between the admin entity and each
        NSDB node MUST be the LDAPv3 <xref target="RFC4510"/>
        protocol.  </t>

        <t> The names we assign to these operations are entirely
        for the purpose of exposition in this document and are
        not part of the LDAP dialogs.  </t>

        <section title="Create an FSN">

        <t> This operation creates a new FSN in
        the NSDB by adding a new fedfsFsn entry in the
        NSDB's LDAP directory. </t>

        <t> A fedfsFsn entry contains a fedfsFsnUuid.
        The administrator chooses the fedfsFsnUuid by the
        process described in <xref target="sec:uuid"/>.
        A fedfsFsn entry also contains a fedfsFsnTTL.
        The fedfsFsnTTL is chosen by the administrator
        as described in <xref target="fsl_caching"/>. </t>

        <section title="LDAP Request">

            <t> This operation is implemented using the LDAP ADD
            request described by the LDIF below. </t>

            <figure><artwork><![CDATA[
        dn: fedfsFsnUuid=$FSNUUID,$NCE
        changeType: add
        objectClass: fedfsFsn
        fedfsFsnUuid: $FSNUUID
        fedfsFsnTTL: $TTL
            ]]></artwork></figure>

            <t> For example, if $FSNUUID is
            "e8c4761c-eb3b-4307-86fc-f702da197966", $TTL
            is "300" seconds, and $NCE is "o=fedfs", the
            operation would be: </t>

            <figure><artwork><![CDATA[
        dn: fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs
        changeType: add
        objectClass: fedfsFsn
        fedfsFsnUuid: e8c4761c-eb3b-4307-86fc-f702da197966
        fedfsFsnTTL: 300
            ]]></artwork></figure>

        </section>

        </section>

        <section title="Delete an FSN">

        <t> This operation deletes an FSN by removing a
        fedfsFsn entry in the NSDB's LDAP directory. </t>

        <t> If the FSN entry being deleted has child FSL entries,
        this function MUST return an error.  This ensures that the
        NSDB will not contain any orphaned FSL entries. A compliant LDAP
        implementation will meet this requirement since Section 4.8
        of <xref target="RFC4511"/> defines the LDAP delete operation
        to only be capable of removing leaf entries.  </t>

        <t> Note that the FSN delete function removes the
        fileset only from a federation namespace (by removing
        the records for that FSN from the NSDB node that
        receives this request).  The fileset and its data
        are not deleted.  Any junction that has this FSN as
        its target may continue to point to this
        non-existent FSN.  A dangling reference may be
        detected when a fileserver tries to resolve a junction
        that refers to the deleted FSN.  </t>

        <section title="LDAP Request">

            <t> This operation is implemented using the LDAP
            DELETE request described by the LDIF below. </t>

            <figure><artwork><![CDATA[
        dn: fedfsFsnUuid=$FSNUUID,$NCE
        changeType: delete
            ]]></artwork></figure>

            <t> For example, if $FSNUUID is
            "e8c4761c-eb3b-4307-86fc-f702da197966" and $NCE
            is "o=fedfs", the operation would be: </t>

            <figure><artwork><![CDATA[
        dn: fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs
        changeType: delete
            ]]></artwork></figure>

        </section>

        </section>

        <section title="Create an FSL">

        <t> This operation creates a new FSL for the
        given FSN by adding a new fedfsFsl entry in the
        NSDB's LDAP directory. </t>

        <t> A fedfsFsl entry contains a fedfsFslUuid and
        fedfsFsnUuid.  The
        administrator chooses the fedfsFslUuid.  The process
        for choosing the fedfsFslUuid is described in
        <xref target="sec:uuid"/>.  The fedfsFsnUuid is
        the UUID of the FSL's FSN. </t>

        <t> The administrator will also set additional
        attributes depending on the FSL type. </t>

        <section title="LDAP Request">

            <t> This operation is implemented using the LDAP
            ADD request described by the LDIF below (Note:
            the LDIF shows the creation of an NFS FSL.)  </t>

            <figure><artwork><![CDATA[

        dn: fedfsFslUuid=$FSLUUID,fedfsFsnUuid=$FSNUUID,$NCE
        changeType: add
        objectClass: fedfsNfsFsl
        fedfsFslUuid: $FSLUUID
        fedfsFsnUuid: $FSNUUID
        fedfsNfsURI: nfs://$HOST:$PORT//$PATH
        fedfsNfsCurrency: $CURRENCY
        fedfsNfsGenFlagWritable: $WRITABLE
        fedfsNfsGenFlagGoing: $GOING
        fedfsNfsGenFlagSplit: $SPLIT
        fedfsNfsTransFlagRdma: $RDMA
        fedfsNfsClassSimul: $CLASS_SIMUL
        fedfsNfsClassHandle:$CLASS_HANDLE
        fedfsNfsClassFileid:$CLASS_FILEID
        fedfsNfsClassWritever:$CLASS_WRITEVER
        fedfsNfsClassChange: $CLASS_CHANGE
        fedfsNfsClassReaddir: $CLASS_READDIR
        fedfsNfsReadRank: $READ_RANK
        fedfsNfsReadOrder: $READ_ORDER
        fedfsNfsWriteRank: $WRITE_RANK
        fedfsNfsWriteOrder: $WRITE_ORDER
        fedfsNfsVarSub: $VAR_SUB
        fedfsNfsValidFor: $TIME
        fedfsAnnotation: $ANNOTATION
        fedfsDescr: $DESCR

            ]]></artwork></figure>

            <t> For example, if $FSNUUID is "e8c4761c-eb3b-4307-86fc-f702da197966",
            $FSLUUID is "ba89a802-41a9-44cf-8447-dda367590eb3",
            $HOST is "server.example.com", $PORT is "20049",
            $PATH is stored in the file "/tmp/fsl_path", $CURRENCY is "0" (an up-to-date
            copy), the FSL is writable, but not going, split, or accessible
	    via Remote Direct Memory Access (RDMA),
            the simultaneous-use class is "1", the handle class is "0", the fileid class is
            "1", the write-verifier class is "1", the change class is "1", the readdir class is
            "9", the read rank is "7", the read order is "8", the write rank is "5", the
            write order is "6", variable substitution is false, $TIME is "300"
            seconds, $ANNOTATION is ""foo" = "bar"", $DESC is "This is a description.",
            and $NCE is "o=fedfs", the operation would be (for readability, the DN is
            split into two lines): </t>

            <figure><artwork><![CDATA[

        dn: fedfsFslUuid=ba89a802-41a9-44cf-8447-dda367590eb3,
         fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs
        changeType: add
        objectClass: fedfsNfsFsl
        fedfsFslUuid: ba89a802-41a9-44cf-8447-dda367590eb3
        fedfsFsnUuid: e8c4761c-eb3b-4307-86fc-f702da197966
        fedfsNfsURI: nfs://server.example.com:20049//tmp/fsl_path
        fedfsNfsCurrency: 0
        fedfsNfsGenFlagWritable: TRUE
        fedfsNfsGenFlagGoing: FALSE
        fedfsNfsGenFlagSplit: FALSE
        fedfsNfsTransFlagRdma: FALSE
        fedfsNfsClassSimul: 1
        fedfsNfsClassHandle: 0
        fedfsNfsClassFileid: 1
        fedfsNfsClassWritever: 1
        fedfsNfsClassChange: 1
        fedfsNfsClassReaddir: 9
        fedfsNfsReadRank: 7
        fedfsNfsReadOrder: 8
        fedfsNfsWriteRank: 5
        fedfsNfsWriteOrder: 6
        fedfsNfsVarSub: FALSE
        fedfsNfsValidFor: 300
        fedfsAnnotation: "foo" = "bar"
        fedfsDescr: This is a description.

            ]]></artwork></figure>

        </section>

        <section title="Selecting fedfsNfsFsl Values">

            <t> The fedfsNfsFSl object class is used to describe
	    NFSv4-accessible filesets. For the reasons described
            in <xref target="fsl_referral"/>, administrators SHOULD
            choose reasonable values for all LDAP attributes of an
	    NFSv4-accessible fedfsNfsFsl even though some of these LDAP
            attributes are not explicitly contained in an NFSv4
            fs_locations attribute. </t>

            <t> When the administrator is unable to choose reasonable
            values for the LDAP attributes not explicitly contained
            in an NFSv4 fs_locations attribute, the values in the
            following table are RECOMMENDED. </t>

            <texttable>
            <ttcol align='left'>LDAP attribute</ttcol>
            <ttcol align='left'>LDAP value</ttcol>
            <ttcol align='left'>Notes</ttcol>
                <c>fedfsNfsCurrency</c>
                <c>negative value</c>
                <c>Indicates that the server does not know the currency (see
		Section 11.10.1 of <xref target="RFC5661"/>).</c>
                <c>fedfsNfsGenFlagWritable</c>
                <c>FALSE</c>
                <c>Leaving unset is not harmful (see Section 11.10.1 of <xref target="RFC5661"/>).</c>
                <c>fedfsNfsGenFlagGoing</c>
                <c>FALSE</c>
                <c>NFS client will detect a migration event if the FSL becomes unavailable.</c>
                <c>fedfsNfsGenFlagSplit</c>
                <c>TRUE</c>
                <c>Safe to assume that the FSL is split.</c>
                <c>fedfsNfsTransFlagRdma</c>
                <c>TRUE</c>
                <c>NFS client will detect if RDMA access is available.</c>
                <c>fedfsNfsClassSimul</c>
                <c>0</c>
                <c>0 is treated as non-matching (see Section 11.10.1 of <xref target="RFC5661"/>).</c>
                <c>fedfsNfsClassHandle</c>
                <c>0</c>
                <c>See fedfsNfsClassSimul note.</c>
                <c>fedfsNfsClassFileid</c>
                <c>0</c>
                <c>See fedfsNfsClassSimul note.</c>
                <c>fedfsNfsClassWritever</c>
                <c>0</c>
                <c>See fedfsNfsClassSimul note.</c>
                <c>fedfsNfsClassChange</c>
                <c>0</c>
                <c>See fedfsNfsClassSimul note.</c>
                <c>fedfsNfsClassReaddir</c>
                <c>0</c>
                <c>See fedfsNfsClassSimul note.</c>
                <c>fedfsNfsReadRank</c>
                <c>0</c>
                <c>Highest value ensures FSL will be tried.</c>
                <c>fedfsNfsReadOrder</c>
                <c>0</c>
                <c>See fedfsNfsReadRank note.</c>
                <c>fedfsNfsWriteRank</c>
                <c>0</c>
                <c>See fedfsNfsReadRank note.</c>
                <c>fedfsNfsWriteOrder</c>
                <c>0</c>
                <c>See fedfsNfsReadRank note.</c>
                <c>fedfsNfsVarSub</c>
                <c>FALSE</c>
                <c>NFSv4 does not define variable substitution in paths.</c>
                <c>fedfsNfsValidFor</c>
                <c>0</c>
                <c>Indicates no appropriate refetch interval (see Section 11.10.2 of <xref target="RFC5661"/>).</c>
            </texttable>

        </section>

        </section>

        <section title="Delete an FSL">

        <t> This operation deletes an FSL record.
        The admin requests the NSDB node storing the fedfsFsl to
        delete it from its database.  This operation does
        not result in fileset data being deleted on any fileserver. </t>

        <section title="LDAP Request">

            <t> The admin sends an LDAP DELETE request to the NSDB node
            to remove the FSL. </t>

            <figure><artwork><![CDATA[
        dn: fedfsFslUuid=$FSLUUID,fedfsFsnUuid=$FSNUUID,$NCE
        changeType: delete
            ]]></artwork></figure>

            <t> For example, if $FSNUUID is "e8c4761c-eb3b-4307-86fc-f702da197966",
            $FSLUUID is "ba89a802-41a9-44cf-8447-dda367590eb3", and $NCE is
            "o=fedfs", the operation would be (for readability, the DN is split into
            two lines): </t>

            <figure><artwork><![CDATA[
        dn: fedfsFslUuid=ba89a802-41a9-44cf-8447-dda367590eb3,
         fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs
        changeType: delete
            ]]></artwork></figure>

        </section>

        </section>

        <section title="Update an FSL">

        <t> This operation updates the attributes of a given FSL.
        This command results in a change in the attributes of the
        fedfsFsl at the NSDB node maintaining this FSL.
        The values of the fedfsFslUuid and fedfsFsnUuid attributes
        MUST NOT change during an FSL update.
        </t>

        <section title="LDAP Request">

            <t> The admin sends an LDAP MODIFY request to the NSDB node
            to update the FSL. </t>

            <figure><artwork><![CDATA[
        dn: fedfsFslUuid=$FSLUUID,fedfsFsnUuid=$FSNUUID,$NCE
        changeType: modify
        replace: $ATTRIBUTE-TYPE
            ]]></artwork></figure>

            <t> For example, if $FSNUUID is "e8c4761c-eb3b-4307-86fc-f702da197966",
            $FSLUUID is "ba89a802-41a9-44cf-8447-dda367590eb3", $NCE is "o=fedfs",
            and the administrator wished to change the NFS read rank to 10, the operation
            would be (for readability, the DN is split into two lines): </t>

            <figure><artwork><![CDATA[
        dn: fedfsFslUuid=ba89a802-41a9-44cf-8447-dda367590eb3,
         fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs
        changeType: modify
        replace: fedfsNfsReadClass
        fedfsNfsReadRank: 10
            ]]></artwork></figure>

        </section>

        </section>

    </section>

    <section title="NSDB Operations for Fileservers" anchor="nsdb-ops-fileservers">

        <section title="NSDB Container Entry (NCE) Enumeration">

        <t> To find the NCEs for the NSDB nsdb.example.com, a fileserver would do
        the following: </t>

            <figure><artwork><![CDATA[
     nce_list = empty
     connect to the LDAP directory at nsdb.example.com
     for each namingContext value $BAR in the root DSE
         /* $BAR is a DN */
         query for a fedfsNceDN value at $BAR
         /*
          * The RFC 4516 LDAP URL for this search would be
          *
          *  ldap://nsdb.example.com:389/$BAR?fedfsNceDN??
          *                      (objectClass=fedfsNsdbContainerInfo)
          *
          */
         if a fedfsNceDN value is found
             add the value to the nce_list
            ]]></artwork></figure>

        </section>

        <section title="Lookup FSLs for an FSN">

        <t> Using an LDAP search, the fileserver can obtain
        all of the FSLs for a given FSN. The FSN's fedfsFsnUuid
        is used as the search key. The following examples use
        the LDAP Uniform Resource Identifier (URI) format defined
        in <xref target="RFC4516"/>. </t>

        <t> To obtain a list of all FSLs for $FSNUUID on the NSDB
        named $NSDBNAME, the following search can be used
        (for readability, the URI is split into two lines): </t>

        <figure><artwork><![CDATA[
    for each $NCE in nce_list
        ldap://$NSDBNAME/fedfsFsnUuid=$FSNUUID,$NCE??one?
            (objectClass=fedfsFsl)
        ]]></artwork></figure>

        <t> This search is for the children of the object with DN
        "fedfsFsnUuid=$FSNUUID,$NCE" with a filter for
        "objectClass=fedfsFsl". The scope value of "one" restricts
        the search to the entry's children (rather than the entire
        subtree below the entry), and the filter ensures that only
        FSL entries are returned. </t>

        <t> For example, if $NSDBNAME is "nsdb.example.com", $FSNUUID
        is "e8c4761c-eb3b-4307-86fc-f702da197966", and $NCE is
        "o=fedfs", the search would be (for readability, the URI is split
        into three lines): </t>

        <figure><artwork><![CDATA[
    ldap://nsdb.example.com/
            fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs
            ??one?(objectClass=fedfsFsl)
        ]]></artwork></figure>

        <t> The following search can be used to obtain
        only the NFS FSLs for $FSNUUID on the NSDB named
        $NSDBNAME (for readability, the URI is split into two lines): </t>

        <figure><artwork><![CDATA[
    for each $NCE in nce_list
        ldap://$NSDBNAME/fedfsFsnUuid=$FSNUUID,$NCE??one?
            (objectClass=fedfsNfsFsl)
        ]]></artwork></figure>

        <t> This also searches for the children of the object with DN
        "fedfsFsnUuid=$FSNUUID,$NCE", but the filter for
        "objectClass = fedfsNfsFsl" restricts the results to only
        NFS FSLs. </t>

        <t> For example, if $NSDBNAME is nsdb.example.com, $FSNUUID
        is "e8c4761c-eb3b-4307-86fc-f702da197966", and $NCE is
        "o=fedfs", the search would be (for readability, the URI is split
        into three lines): </t>

        <figure><artwork><![CDATA[
    ldap://nsdb.example.com/
            fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs
            ??one?(objectClass=fedfsNfsFsl)
        ]]></artwork></figure>

        <t> The fileserver will generate a referral based on the
        set of FSLs returned by these queries using the process
        described in <xref target="fsl_referral"/>. </t>

        </section>

    </section>

    <section title="NSDB Operations and LDAP Referrals">

        <t> The LDAPv3 protocol defines an LDAP referral mechanism
        that allows an LDAP server to redirect an LDAP client. LDAPv3
        defines two types of LDAP referrals: the Referral type defined
        in Section 4.1.10 of <xref target="RFC4511"/> and the
        SearchResultReference type defined in Section 4.5.3 of
        <xref target="RFC4511"/>. In both cases, the LDAP referral
        lists one or more URIs for services that can be used to
        complete the operation. In the remainder of this document,
        the term "LDAP referral" is used to indicate either of these
        types. </t>

        <t> If an NSDB operation results in an LDAP referral, the
        NSDB client MAY follow the LDAP referral. An NSDB client's
        decision to follow an LDAP referral is implementation and
        configuration dependent. For example, an NSDB client might
        be configured to follow only those LDAP referrals that were
        received over a secure channel or only those that target an
        NSDB that supports encrypted communication. If an NSDB client
        chooses to follow an LDAP referral, the NSDB client MUST
        process the LDAP referral and prevent looping as described in
        Section 4.1.10 of <xref target="RFC4511"/>. </t>

    </section>

    </section>

    <section title="Security Considerations">

    <t> Both the NFSv4 and LDAPv3 protocols provide security mechanisms. When used in
    conjunction with the federated file system protocols described in
    this document, the use of these mechanisms is RECOMMENDED. Specifically,
    the use of RPCSEC_GSS <xref target="RFC2203"/>, which is built on the
    Generic Security Service Application Program Interface (GSS-API) <xref target="RFC2743"/>, is RECOMMENDED on all NFS connections
    between a file-access client and fileserver. The security considerations
    sections of the NFSv4.0 <xref target="RFC7530"/> and NFSv4.1 <xref target="RFC5661"/>
    specifications contain special considerations for the handling of GETATTR
    operations for the fs_locations and fs_locations_info attributes. </t>

    <t> NSDB nodes and NSDB clients MUST implement support for TLS
    <xref target="RFC5246"/>, as described in <xref target="RFC4513"/>.
    For all LDAP connections established by the federated file system
    protocols, the use of TLS is RECOMMENDED. </t>

    <t> If an NSDB client chooses to follow an LDAP referral, the NSDB
    client SHOULD authenticate the LDAP referral's target NSDB using the
    target NSDB's credentials (not the credentials of the NSDB that
    generated the LDAP referral). The NSDB client SHOULD NOT follow an
    LDAP referral that targets an NSDB for which it does not know the
    NSDB's credentials. </t>

    <t> Within a federation, there are two types of components an attacker
    may compromise: a fileserver and an NSDB. </t>

    <t> If an attacker compromises a fileserver, the attacker can interfere
    with a file-access client's file system input/output (I/O) operations
    (e.g., by returning fictitious data in the response to a read request) or
    can fabricate a referral.
    The attacker's abilities are the same regardless of whether or not the
    federation protocols are in use. While the federation protocols do not
    give the attacker additional capabilities, they are additional targets for
    attack. The LDAP protocol described in <xref target="nsdb-ops-fileservers"/>
    SHOULD be secured using the methods described above to defeat attacks
    on a fileserver via this channel. </t>

    <t> If an attacker compromises an NSDB, the attacker will be able to
    forge FSL information and thus poison the fileserver's referral
    information. Therefore, an NSDB should be as secure as the fileservers
    that query it. The LDAP operations described in <xref target="nsdb-ops"/>
    SHOULD be secured using the methods described above to defeat attacks
    on an NSDB via this channel. </t>

    <t> A fileserver binds anonymously when performing NSDB operations.
    Thus, the contents and distinguished names of FSN and FSL records are
    required to be readable by anyone who can bind anonymously to an NSDB
    service. <xref target="sec:uuid" /> presents the security considerations
    in the choice of the type of UUID used in these records. </t>

    <t> It should be noted that the federation protocols do not directly
    provide access to file system data. The federation protocols only
    provide a mechanism for building a namespace. All data transfers
    occur between a file-access client and fileserver just as they would if
    the federation protocols were not in use. As a result, the federation
    protocols do not require new user authentication and authorization
    mechanisms or require a fileserver to act as a proxy for a client. </t>

    </section>

    <section title="IANA Considerations">

        <section title="Registry for the fedfsAnnotation Key Namespace"
                 anchor="annotation-registry">

        <t> This document defines the fedfsAnnotation key in
        <xref target="fedfsAnnotation"/>.  The fedfsAnnotation key namespace
        is managed by IANA. IANA has created and now maintains a new
        registry entitled "FedFS Annotation Keys".  The location of this
        registry is under a new heading called "Federated File System
        (FedFS) Parameters".  The URL address is
        &lt;http://www.iana.org/assignments/fedfs-parameters&gt;. </t>

        <t> Future registrations are to be administered by IANA using the
        "First Come First Served" policy defined in <xref target="RFC5226"/>.
        Registration requests MUST include the key (a valid UTF-8 string of
        any length), a brief description of the key's purpose, and an email
        contact for the registration. For viewing, the registry should be
        sorted lexicographically by key. There are no initial assignments
        for this registry. </t>

        </section>

        <section title="Registry for FedFS Object Identifiers">

        <t> Using the process described in <xref target="RFC2578"/>, one of
        the authors was assigned the Internet Private Enterprise
        Numbers range 1.3.6.1.4.1.31103.x. Within this range, the subrange
        1.3.6.1.4.1.31103.1.x is permanently dedicated for use by the
        federated file system protocols.  Unassigned OIDs in this range
        MAY be used for Private Use or Experimental Use as defined in
        <xref target="RFC5226" />.  New permanent FedFS OID assignments
        MUST NOT be made using OIDs in this range. </t>

        <t> IANA has created and now maintains a new registry entitled "FedFS
        Object Identifiers" for the purpose of recording the allocations of
        FedFS Object Identifiers (OIDs) specified by this document.  No
        future allocations in this registry are allowed. </t>

        <t> The location of this registry is under the heading
        "Federated File System (FedFS) Parameters", created in
        <xref target="annotation-registry"/>.  The URL address is
        &lt;http://www.iana.org/assignments/fedfs-parameters&gt;. </t>

        <t> For viewing, the registry has been sorted numerically by OID
        value. The contents of the "FedFS Object Identifiers" registry are
        given in <xref target="oid_registry"/>. </t>

        <t> Note: A descriptor designated below as "historic" reserves an OID
        used in a past version of the NSDB protocol.  Registering such OIDs
        retains compatibility among existing implementations of the NSDB
        protocol.  This document does not otherwise refer to historic OIDs. </t>

      <texttable anchor="oid_registry">
        <ttcol align='left' >OID</ttcol>
        <ttcol align='left' >Description</ttcol>
        <ttcol align='left' >Reference</ttcol>

        <c> 1.3.6.1.4.1.31103.1.1    </c> <c> fedfsUuid               </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.2    </c> <c> fedfsNetAddr            </c> <c> historic </c>
        <c> 1.3.6.1.4.1.31103.1.3    </c> <c> fedfsNetPort            </c> <c> historic </c>
        <c> 1.3.6.1.4.1.31103.1.4    </c> <c> fedfsFsnUuid            </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.5    </c> <c> fedfsNsdbName           </c> <c> historic </c>
        <c> 1.3.6.1.4.1.31103.1.6    </c> <c> fedfsNsdbPort           </c> <c> historic </c>
        <c> 1.3.6.1.4.1.31103.1.7    </c> <c> fedfsNcePrefix          </c> <c> historic </c>
        <c> 1.3.6.1.4.1.31103.1.8    </c> <c> fedfsFslUuid            </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.9    </c> <c> fedfsFslHost            </c> <c> historic </c>
        <c> 1.3.6.1.4.1.31103.1.10   </c> <c> fedfsFslPort            </c> <c> historic </c>
        <c> 1.3.6.1.4.1.31103.1.11   </c> <c> fedfsFslTTL             </c> <c> historic </c>
        <c> 1.3.6.1.4.1.31103.1.12   </c> <c> fedfsAnnotation         </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.13   </c> <c> fedfsDescr              </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.14   </c> <c> fedfsNceDN              </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.15   </c> <c> fedfsFsnTTL             </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.100  </c> <c> fedfsNfsPath            </c> <c> historic </c>
        <c> 1.3.6.1.4.1.31103.1.101  </c> <c> fedfsNfsMajorVer        </c> <c> historic </c>
        <c> 1.3.6.1.4.1.31103.1.102  </c> <c> fedfsNfsMinorVer        </c> <c> historic </c>
        <c> 1.3.6.1.4.1.31103.1.103  </c> <c> fedfsNfsCurrency        </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.104  </c> <c> fedfsNfsGenFlagWritable </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.105  </c> <c> fedfsNfsGenFlagGoing    </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.106  </c> <c> fedfsNfsGenFlagSplit    </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.107  </c> <c> fedfsNfsTransFlagRdma   </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.108  </c> <c> fedfsNfsClassSimul      </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.109  </c> <c> fedfsNfsClassHandle     </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.110  </c> <c> fedfsNfsClassFileid     </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.111  </c> <c> fedfsNfsClassWritever   </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.112  </c> <c> fedfsNfsClassChange     </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.113  </c> <c> fedfsNfsClassReaddir    </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.114  </c> <c> fedfsNfsReadRank        </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.115  </c> <c> fedfsNfsReadOrder       </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.116  </c> <c> fedfsNfsWriteRank       </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.117  </c> <c> fedfsNfsWriteOrder      </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.118  </c> <c> fedfsNfsVarSub          </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.119  </c> <c> fedfsNfsValidFor        </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.120  </c> <c> fedfsNfsURI             </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.1001 </c> <c> fedfsNsdbContainerInfo  </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.1002 </c> <c> fedfsFsn                </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.1003 </c> <c> fedfsFsl                </c> <c> RFC 7532 </c>
        <c> 1.3.6.1.4.1.31103.1.1004 </c> <c> fedfsNfsFsl             </c> <c> RFC 7532 </c>
      </texttable>

        </section>

        <section title="LDAP Descriptor Registration">

    <t> In accordance with Sections 3.4 and 4 of <xref target="RFC4520"/>,
    the object identifier descriptors defined in this document (listed below) have
    been registered via the Expert Review process. </t>

<?rfc subcompact="yes" ?>
    <t>
        <list style="hanging">
        <t hangText="Subject:"> Request for LDAP Descriptor Registration </t>
        <t hangText="Person &amp; email address to contact for further information:">
            See "Author/Change Controller" </t>
        <t hangText="Specification:"> RFC 7532 </t>
        <t hangText="Author/Change Controller:"> IESG (iesg@ietf.org) </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.1 </t>
        <t hangText="Descriptor (short name):"> fedfsUuid </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.2 </t>
        <t hangText="Descriptor (short name):"> fedfsNetAddr </t>
        <t hangText="Usage:"> attribute type (historic) </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.3 </t>
        <t hangText="Descriptor (short name):"> fedfsNetPort </t>
        <t hangText="Usage:"> attribute type (historic) </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.4 </t>
        <t hangText="Descriptor (short name):"> fedfsFsnUuid </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.5 </t>
        <t hangText="Descriptor (short name):"> fedfsNsdbName </t>
        <t hangText="Usage:"> attribute type (historic) </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.6 </t>
        <t hangText="Descriptor (short name):"> fedfsNsdbPort </t>
        <t hangText="Usage:"> attribute type (historic) </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.7 </t>
        <t hangText="Descriptor (short name):"> fedfsNcePrefix </t>
        <t hangText="Usage:"> attribute type (historic) </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.8 </t>
        <t hangText="Descriptor (short name):"> fedfsFslUuid </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.9 </t>
        <t hangText="Descriptor (short name):"> fedfsFslHost </t>
        <t hangText="Usage:"> attribute type (historic) </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.10 </t>
        <t hangText="Descriptor (short name):"> fedfsFslPort </t>
        <t hangText="Usage:"> attribute type (historic) </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.11 </t>
        <t hangText="Descriptor (short name):"> fedfsFslTTL </t>
        <t hangText="Usage:"> attribute type (historic) </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.12 </t>
        <t hangText="Descriptor (short name):"> fedfsAnnotation </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.13 </t>
        <t hangText="Descriptor (short name):"> fedfsDescr </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.14 </t>
        <t hangText="Descriptor (short name):"> fedfsNceDN </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.15 </t>
        <t hangText="Descriptor (short name):"> fedfsFsnTTL </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.100 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsPath </t>
        <t hangText="Usage:"> attribute type (historic) </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.101 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsMajorVer </t>
        <t hangText="Usage:"> attribute type (historic) </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.102 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsMinorVer </t>
        <t hangText="Usage:"> attribute type (historic) </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.103 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsCurrency </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.104 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsGenFlagWritable </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.105  </t>
        <t hangText="Descriptor (short name):"> fedfsNfsGenFlagGoing </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.106 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsGenFlagSplit </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.107 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsTransFlagRdma </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.108 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsClassSimul </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.109 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsClassHandle </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.110 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsClassFileid </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.111 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsClassWritever </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.112 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsClassChange </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.113 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsClassReaddir </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.114 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsReadRank </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.115 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsReadOrder </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.116 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsWriteRank </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.117 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsWriteOrder </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.118 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsVarSub </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.119 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsValidFor </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.120 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsURI </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.1001 </t>
        <t hangText="Descriptor (short name):"> fedfsNsdbContainerInfo </t>
        <t hangText="Usage:"> object class </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.1002 </t>
        <t hangText="Descriptor (short name):"> fedfsFsn </t>
        <t hangText="Usage:"> object class </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.1003 </t>
        <t hangText="Descriptor (short name):"> fedfsFsl </t>
        <t hangText="Usage:"> object class </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.1004 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsFsl </t>
        <t hangText="Usage:"> object class </t>
        </list>
    </t>
<?rfc subcompact="no" ?>

        </section>

    </section>

    <section title="Glossary">

<t>
<list style="hanging">

<t hangText="Administrator:"> A user with the necessary authority to
    initiate administrative tasks on one or more servers.  </t>

<t hangText="Admin Entity:"> A server or agent that administers a
    collection of fileservers and persistently stores the namespace
    information.  </t>

<t hangText="File-Access Client:"> Standard off-the-shelf, network-attached
storage (NAS) client software that communicates with
    fileservers using a standard file-access protocol. </t>

<t hangText="Federation:"> A set of fileserver collections and
    singleton fileservers that use a common set of interfaces and
    protocols in order to provide to file-access clients a federated
    namespace accessible through a file system access protocol.  </t>

<t hangText="Fileserver:"> A server that stores physical fileset data
    or refers file-access clients to other fileservers.  A fileserver
    provides access to its shared file system data via a file-access
    protocol. </t>

<t hangText="Fileset:"> The abstraction of a set of files and the
    directory tree that contains them. A fileset is the 
    fundamental unit of data management in the federation.

    <vspace blankLines="1" />

    Note that all files within a fileset are descendants of one
    directory and that filesets do not span file systems.  </t>

<t hangText="File System:"> A self-contained unit of export for a
    fileserver and the mechanism used to implement filesets.  The
    fileset does not need to be rooted at the root of the file system,
    nor at the export point for the file system.

    <vspace blankLines="1" />

    A single file system MAY implement more than one fileset, if the
    file-access protocol and the fileserver permit this. </t>

<t hangText="File-Access Protocol:"> A network file system access
    protocol such as NFSv3 <xref
    target="RFC1813"/>, NFSv4 <xref target="RFC7530"/>, or
    CIFS (Common Internet File System) <xref target="MS-SMB"/> 
    <xref target="MS-SMB2"/> <xref target="MS-CIFS"/>.  </t>

<t hangText="FSL (Fileset Location):"> The location of the
    implementation of a fileset at a particular moment in time.  An FSL
    MUST be something that can be translated into a protocol-specific
    description of a resource that a file-access client can access directly,
    such as an fs_locations attribute (for NFSv4) or a share name (for
    CIFS). </t>

<t hangText="FSN (Fileset Name):"> A platform-independent and globally
    unique name for a fileset.  Two FSLs that implement replicas of
    the same fileset MUST have the same FSN, and if a fileset is
    migrated from one location to another, the FSN of that fileset
    MUST remain the same.  </t>

<t hangText="Junction:"> A file system object used to link a directory
    name in the current fileset with an object within another fileset. 
    The server-side "link" from a leaf node in one fileset to the root
    of another fileset.  </t>

<t hangText="Namespace:"> A filename/directory tree that a
    sufficiently authorized file-access client can observe.  </t>

<t hangText="NSDB (Namespace Database) Service:"> A service that maps
    FSNs to FSLs.  The NSDB may also be used to store other
    information, such as annotations for these mappings and their
    components.  </t>

<t hangText="NSDB Node:"> The name or location of a server that
    implements part of the NSDB service and is responsible for keeping
    track of the FSLs (and related information) that implement a given
    partition of the FSNs.  </t>

<t hangText="Referral:"> A server response to a file-access client
    access that directs the client to evaluate the current object as a
    reference to an object at a different location (specified by an FSL)
    in another fileset and possibly hosted on another fileserver.  The
    client re-attempts the access to the object at the new location. 
    </t>

<t hangText="Replica:"> A redundant implementation of a
    fileset.  Each replica shares the same FSN but has a different
    FSL.

    <vspace blankLines="1" />

    Replicas may be used to increase availability or performance. 
    Updates to replicas of the same fileset MUST appear to occur in
    the same order; therefore, each replica is self-consistent at
    any moment.

    <vspace blankLines="1" />

    We do not assume that updates to each replica occur simultaneously.
    If a replica is offline or unreachable, the other replicas may be
    updated.  </t>

<t hangText="Server Collection:"> A set of fileservers administered as
    a unit.  A server collection may be administered with
    vendor-specific software.

    <vspace blankLines="1" />

    The namespace provided by a server collection could be part of the
    federated namespace.  </t>

<t hangText="Singleton Server:">  A server collection containing only one server; a
    stand-alone fileserver.  </t>

</list>
</t>
    </section>

</middle>

<back>

    <references title='Normative References'>

<?rfc include="reference.RFC.2079" ?>

<?rfc include="reference.RFC.2119" ?>

<?rfc include="reference.RFC.2203" ?>

<?rfc include="reference.RFC.2578" ?>
 
<?rfc include="reference.RFC.2743" ?>

<?rfc include="reference.RFC.2849" ?>

<?rfc include="reference.RFC.3629" ?> 

<?rfc include="reference.RFC.3986" ?>

<?rfc include="reference.RFC.4122" ?>
 
<?rfc include="reference.RFC.4510" ?>

<?rfc include="reference.RFC.4511" ?>
 
<?rfc include="reference.RFC.4512" ?>

<?rfc include="reference.RFC.4513" ?>

<?rfc include="reference.RFC.4516" ?>
 
<?rfc include="reference.RFC.4517" ?>

<?rfc include="reference.RFC.4519" ?>
 
<?rfc include="reference.RFC.4520" ?>
 
<?rfc include="reference.RFC.4530" ?>

<?rfc include="reference.RFC.5226" ?>

<?rfc include="reference.RFC.5234" ?> 
 
<?rfc include="reference.RFC.5246" ?>
 
<?rfc include="reference.RFC.5661" ?>

<!--  draft-ietf-nfsv4-rfc3530bis in Cluster 182 EDIT -->
<reference anchor="RFC7530" target='http://www.rfc-editor.org/info/rfc7530'>
        <front>
                <title>Network File System (NFS) Version 4 Protocol</title>
                <author initials="T." surname="Haynes" role="editor">
                        <organization />
                </author>
                <author initials="D." surname="Noveck" role="editor">
                        <organization />
                </author>
                <date month="March" year="2015" />
        </front>
        <seriesInfo name="RFC" value="7530"/>
</reference>

</references>


    <references title='Informative References'>

<?rfc include="reference.RFC.1813" ?>

<?rfc include="reference.RFC.2224" ?>

<?rfc include="reference.RFC.3254" ?>

<reference anchor="AFS">
	<front>
		<title>An Overview of the Andrew File System</title>
		<author initials="J. H." surname="Howard">
			<organization />
		</author>
		<date year="1988" />
	</front>
	<seriesInfo name="Proceedings of the USENIX Winter Technical Conference" value=""/>
</reference>
 
<?rfc include="reference.RFC.5716" ?>

<!--  draft-ietf-nfsv4-federated-fs-admin in Cluster 182 REF -->
<reference anchor="RFC7533" target='http://www.rfc-editor.org/info/rfc7533'>
	<front>
		<title>Administration Protocol for Federated File Systems</title>
		<author initials="J." surname="Lentini">
			<organization />
		</author>
		<author initials="R." surname="Tewari">
			<organization />
		</author>
		<author initials="C." surname="Lever" role="editor">
			<organization />
		</author>
		<date month="March" year="2015" />
	</front>
	<seriesInfo name="RFC" value="7533"/>
</reference>
 

<?rfc include="reference.RFC.6641" ?>
 
<?rfc include="reference.RFC.5662" ?>

<!-- For an example of citing an MS specification, see RFC 5422 -->

<reference anchor="MS-SMB">
	<front>
		<title>Server Message Block (SMB) Protocol Specification</title>
                <author>                                                                       
<organization>Microsoft Corporation                                                                
</organization>
                </author>

		<date month="May" year="2014" />
	</front>
	<seriesInfo name="MS-SMB" value="43.0"/>
</reference>

<!-- For an example of citing an MS specification, see RFC 5422 -->

<reference anchor="MS-SMB2">
	<front>
		<title>Server Message Block (SMB) Version 2 Protocol Specification</title>
                <author>                                                                           
<organization>Microsoft Corporation                                                                
</organization>
                </author>

		<date month="May" year="2014" />
	</front>
	<seriesInfo name="MS-SMB2" value="46.0"/>
</reference>

<!-- For an example of citing an MS specification, see RFC 5422 -->

<reference anchor="MS-CIFS">
	<front>
		<title>Common Internet File System (CIFS) Protocol Specification</title>
		<author>
<organization>Microsoft Corporation
</organization>
		</author>
		<date month="May" year="2014" />
	</front>
	<seriesInfo name="MS-CIFS" value="24.0"/>
</reference>

    </references>

    <section anchor="app-additional" title="Acknowledgments" numbered="no">

      <t>
        Daniel Ellard contributed significant parts of this document.
      </t>

      <t>
        The authors and editor would like to thank Craig Everhart and
        Manoj Naik, who were co-authors of an earlier draft version of this
        document.  In addition, we would like to thank Andy Adamson,
        Paul Lemahieu, Mario Wurzl, and Robert Thurlow for helping to
        author this document.
      </t>

      <t>
        We would like to thank George Amvrosiadis, Trond Myklebust,
        Howard Chu, and Nicolas Williams for their comments and review.
      </t>

      <t>
        The editor gratefully acknowledges the IESG reviewers,
        whose constructive comments helped make this a much stronger
        document.
      </t>

      <t>
        Finally, we would like to thank Andy Adamson, Rob Thurlow,
        and Tom Haynes for helping to get this document out the door.
      </t>

      <t>
        The extract.sh shell script and formatting conventions were
        first described by the authors of the NFSv4.1 XDR specification
        <xref target="RFC5662"/>.
      </t>

    </section>

</back>
</rfc>
