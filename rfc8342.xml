<?xml version="1.0" encoding="US-ASCII"?>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>

<?rfc toc="yes"?>
<?rfc compact="no"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no"?>
<?rfc strict="yes"?>

<rfc ipr="trust200902" updates="7950"  category="std"
    number="8342" submissionType="IETF" consensus="yes">

 <front>

  <title abbrev="NMDA">Network Management Datastore Architecture (NMDA)</title>

    <author initials="M" surname="Bjorklund" fullname='Martin Bjorklund' >
      <organization>Tail-f Systems</organization>
      <address>
        <email>mbj@tail-f.com</email>
      </address>
    </author>

    <author initials="J" surname="Schoenwaelder" fullname='Juergen Schoenwaelder' >
      <organization>Jacobs University</organization>
      <address>
        <email>j.schoenwaelder@jacobs-university.de</email>
      </address>
    </author>

    <author initials="P" surname="Shafer" fullname='Phil Shafer' >
      <organization>Juniper Networks</organization>
      <address>
        <email>phil@juniper.net</email>
      </address>
    </author>

    <author initials="K" surname="Watsen" fullname='Kent Watsen' >
      <organization>Juniper Networks</organization>
      <address>
        <email>kwatsen@juniper.net</email>
      </address>
    </author>

    <author initials="R" surname="Wilton" fullname='Robert Wilton' >
      <organization>Cisco Systems</organization>
      <address>
        <email>rwilton@cisco.com</email>
      </address>
    </author>

<date month="March" year="2018"/>

<abstract>
    <t>
Datastores are a fundamental concept binding the data models written
in the YANG data modeling language to network management protocols
such as the Network Configuration Protocol (NETCONF) and RESTCONF.
This document defines an architectural framework for datastores based on the
experience gained with the initial simpler model, addressing requirements that
were not well supported in the initial model.  This document updates RFC 7950.
    </t>
</abstract>
</front>

<middle>
<section title="Introduction" anchor="introduction">
    <t>
This document provides an architectural framework for datastores
as they are used by network management protocols such as
the Network Configuration Protocol (NETCONF) <xref target="RFC6241"/>,
RESTCONF <xref target="RFC8040"/>, and the YANG data modeling language
<xref target="RFC7950"/>.  Datastores are a fundamental concept
binding network management data models to network management protocols.
Agreement on a common architectural model of datastores ensures that
data models can be written in a way that is network management protocol
agnostic.  This architectural framework identifies a set of conceptual
datastores, but it does not mandate that all network management
protocols expose all these conceptual datastores.  This architecture
is agnostic with regard to the encoding used by network management
protocols.
    </t>
    <t>
This document updates RFC 7950 by refining the definition of the
accessible tree for some XML Path Language (XPath) context
(see <xref target="xpath"/>) and the invocation context of operations
(see <xref target="invocation"/>).
    </t>

  <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
  "SHALL&nbsp;NOT", "SHOULD", "SHOULD&nbsp;NOT", "RECOMMENDED",
  "NOT&nbsp;RECOMMENDED", "MAY", and "OPTIONAL" in this document
  are to be interpreted as described in BCP&nbsp;14
  <xref format="default" pageno="false" target="RFC2119"/>
  <xref format="default" pageno="false" target="RFC8174"/> when,
  and only when, they appear in all capitals, as shown here.</t>

</section>

<section title="Objectives" anchor="objectives">
    <t>
Network management data objects can often take two different values:
the value configured by the user or an application (configuration) and
the value that the device is actually using (operational state). These
two values may be different for a number of reasons, e.g., system
internal interactions with hardware, interaction with protocols or
other devices, or simply the time it takes to propagate a
configuration change to the software and hardware components of a
system. Furthermore, configuration and operational state data objects
may have different lifetimes.
    </t>
    <t>
The original model of datastores required these data objects to be
modeled twice in the YANG schema -- as &quot;config true&quot; objects and as
&quot;config false&quot; objects. The convention adopted by the interfaces data
model <xref target="RFC8343"/> and the IP data model <xref target="RFC8344"/>
was to use two separate branches rooted at the root of the data tree: one
branch for configuration data objects and one branch for operational state
data objects.
    </t>
    <t>
The duplication of definitions and the ad hoc separation of
operational state data from configuration data lead to a number of
problems. Having configuration and operational state data in separate
branches in the data model is operationally complicated and impacts
the readability of module definitions. Furthermore, the relationship
between the branches is not machine readable, and filter expressions
operating on configuration and on related operational state are
different.
    </t>
    <t>
With the revised architectural model of datastores defined in this
document, the data objects are defined only once in the YANG schema
but independent instantiations can appear in different datastores,
e.g., one for a configured value and another for an operationally used
value. This provides a more elegant and simpler solution to the
problem.
    </t>
    <t>
The revised architectural model of datastores supports additional
datastores for systems that support more advanced processing chains
converting configuration to operational state. For example, some
systems support configuration that is not currently used (so&nbhy;called
"inactive configuration") or they support configuration templates that
are used to expand configuration data via a common template.
    </t>
</section>
<section title="Terminology" anchor="terminology">
    <t>
This document defines the following terminology. Some of the terms are
revised definitions of terms originally defined in <xref target="RFC6241"/> and
<xref target="RFC7950"/> (see also <xref target="background"/>). The
revised definitions are semantically equivalent to the definitions found in
<xref target="RFC6241"/> and <xref target="RFC7950"/>. It is expected that the
revised definitions provided in this section will replace the definitions in
<xref target="RFC6241"/> and <xref target="RFC7950"/> when these documents are
revised.
    </t>
<t>
 <list style="symbols">
 <t>
datastore: A conceptual place to store and access information.  A
datastore might be implemented, for example, using files, a
database, flash memory locations, or combinations thereof.
A datastore maps to an instantiated YANG data tree.
 </t>
 <t>
schema node: A node in the schema tree.  The formal definition is
provided in RFC 7950.
 </t>
 <t>
datastore schema: The combined set of schema nodes for all modules
supported by a particular datastore, taking into consideration any
deviations and enabled features for that datastore.
 </t>
 <t>
configuration: Data that is required to get a device from its
initial default state into a desired operational state.
This data is modeled in YANG using &quot;config true&quot; nodes.
Configuration can originate from different sources.
 </t>
 <t>
configuration datastore: A datastore holding configuration.
 </t>
 <t>
running configuration datastore: A configuration datastore holding
the current configuration of the device.  It may include
configuration that requires further transformations before it can be
applied.  This datastore is referred to as &quot;&lt;running&gt;&quot;.
 </t>
 <t>
candidate configuration datastore: A configuration datastore that
can be manipulated without impacting the device&apos;s running
configuration datastore and that can be committed to the running
configuration datastore.  This datastore is referred to as
&quot;&lt;candidate&gt;&quot;.
 </t>
 <t>
startup configuration datastore: A configuration datastore holding
the configuration loaded by the device into the running
configuration datastore when it boots.  This datastore is
referred to as &quot;&lt;startup&gt;&quot;.
 </t>
 <t>
intended configuration: Configuration that is intended to be
used by the device.  It represents the configuration after all
configuration transformations to &lt;running&gt; have been performed
and is the configuration that the system attempts to apply.
 </t>
 <t>
intended configuration datastore: A configuration datastore holding
the complete intended configuration of the device.  This datastore
is referred to as &quot;&lt;intended&gt;&quot;.
 </t>
 <t>
configuration transformation: The addition, modification, or removal
of configuration between the &lt;running&gt; and &lt;intended&gt; datastores.
Examples of configuration transformations include the removal of
inactive configuration and the configuration produced through the
expansion of templates.
 </t>
 <t>
conventional configuration datastore: One of the following set of
configuration datastores: &lt;running&gt;, &lt;startup&gt;, &lt;candidate&gt;,
and &lt;intended&gt;.  These datastores share a common datastore schema, and
protocol operations allow copying data between these datastores.  The
term &quot;conventional&quot; is chosen as a generic umbrella term for these
datastores.
 </t>
 <t>
conventional configuration: Configuration that is stored
in any of the conventional configuration datastores.
 </t>
 <t>
dynamic configuration datastore: A configuration datastore holding
configuration obtained dynamically during the operation of a device
through interaction with other systems, rather than through one of
the conventional configuration datastores.
 </t>
 <t>
dynamic configuration: Configuration obtained via a dynamic
configuration datastore.
 </t>
 <t>
learned configuration: Configuration that has been learned via
protocol interactions with other systems and that is neither
conventional nor dynamic configuration.
 </t>
 <t>
system configuration: Configuration that is supplied by
the device itself.
 </t>
 <t>
default configuration: Configuration that is not explicitly provided
but for which a value defined in the data model is used.
 </t>
 <t>
applied configuration: Configuration that is actively in use by a
device.  Applied configuration originates from conventional,
dynamic, learned, system, and default configuration.
 </t>
 <t>
system state: The additional data on a system that is not
configuration, such as read&nbhy;only status information and
collected statistics. System state is transient and modified by
interactions with internal components or other systems.
System state is modeled in YANG using &quot;config false&quot; nodes.
 </t>
 <t>
operational state: The combination of applied configuration and
system state.
 </t>
 <t>
operational state datastore: A datastore holding the
complete operational state of the device.  This datastore
is referred to as &quot;&lt;operational&gt;&quot;.
 </t>
 <t>
origin: A metadata annotation indicating the origin of a data&nbsp;item.
 </t>
 <t>
remnant configuration: Configuration that remains part of the
applied configuration for a period of time after it has been removed
from the intended configuration or dynamic configuration.  The time
period may be minimal or may last until all resources used by the
newly deleted configuration (e.g., network connections, memory
allocations, file handles) have been deallocated.
 </t>
 </list>
</t>
    <t>
The following additional terms are not datastore specific, but they are
commonly used and are thus defined here as well:
    </t>
<t>
 <list style="symbols">
 <t>
client: An entity that can access YANG-defined data on a server,
over some network management protocol.
 </t>
 <t>
server: An entity that provides access to YANG-defined data to a
client, over some network management protocol.
 </t>
 <t>
notification: A server-initiated message indicating that a certain
event has been recognized by the server.
 </t>
 <t>
remote procedure call: An operation that can be invoked by a client
on a server.
 </t>
 </list>
</t>
</section>
<section title="Background" anchor="background">
    <t>
NETCONF <xref target="RFC6241"/> provides the following definitions:
    </t>
<t>
 <list style="symbols">
 <t>
datastore: A conceptual place to store and access information.  A
datastore might be implemented, for example, using files, a
database, flash memory locations, or combinations thereof.
 </t>
 <t>
configuration datastore: The datastore holding the complete set of
configuration that is required to get a device from its initial
default state into a desired operational state.
 </t>
 </list>
</t>
    <t>
YANG 1.1 <xref target="RFC7950"/> provides the following
refinements when NETCONF is used with YANG (which is the usual case,
but note that NETCONF was defined before YANG existed):
    </t>
<t>
 <list style="symbols">
 <t>
datastore: When modeled with YANG, a datastore is realized as an
instantiated data tree.
 </t>
 <t>
configuration datastore: When modeled with YANG, a configuration
datastore is realized as an instantiated data tree with
configuration.
 </t>
 </list>
</t>
    <t>
<xref target="RFC6244"/> defined operational state data as follows:
    </t>
<t>
 <list style="symbols">
 <t>
<!-- Verbatim paragraph from RFC 6244.  Treating as DNE -->
Operational state data is a set of data that has been obtained by
the system at runtime and influences the system&apos;s behavior similar
to configuration data.  In contrast to configuration data,
operational state is transient and modified by interactions with
internal components or other systems via specialized protocols.
<!-- End of verbatim paragraph from RFC 6244. -->
 </t>
 </list>
</t>
    <t>
Section 4.3.3 of <xref target="RFC6244"/> discusses operational state and
mentions, among other things, the option to consider operational state as
being stored in another datastore.
Section&nbsp;4.4 of <xref target="RFC6244"/> then concludes that, at the time
of its writing, modeling state as distinct leafs and distinct branches is the
recommended approach.
    </t>
    <t>
Implementation experience and requests from operators
<xref target="OpState-Reqs"/> <xref target="OpState-Modeling"/>
indicate that the datastore model initially designed for NETCONF and
refined by YANG needs to be extended.  In particular, the notion of
intended configuration and applied configuration has developed.
    </t>

<section title="Original Model of Datastores" anchor="original-model-of-datastores">
    <t>
The following drawing shows the original model of datastores as it is
currently used by NETCONF <xref target="RFC6241"/>:
    </t>
<figure anchor="oldarch"><artwork><![CDATA[
       +-------------+                 +-----------+
       | <candidate> |                 | <startup> |
       |  (ct, rw)   |<---+       +--->| (ct, rw)  |
       +-------------+    |       |    +-----------+
              |           |       |           |
              |         +-----------+         |
              +-------->| <running> |<--------+
                        | (ct, rw)  |
                        +-----------+
                              |
                              v
                       operational state  <--- control plane
                           (cf, ro)

       ct = config true; cf = config false
       rw = read-write; ro = read-only
       boxes denote datastores
]]></artwork></figure>

    <t>
Note that this diagram simplifies the model: "read-only" (ro) and
"read&nbhy;write" (rw) are to be understood from the client&apos;s
perspective, at a conceptual level.  In NETCONF, for example, support for
&lt;candidate&gt; and &lt;startup&gt; is optional, and &lt;running&gt; does
not have to be writable.  Furthermore, &lt;startup&gt; can only be modified by
copying &lt;running&gt; to &lt;startup&gt; in the standardized NETCONF
datastore editing model.  The RESTCONF protocol does not expose these
differences and instead provides only a writable unified datastore, which
hides whether edits are done through &lt;candidate&gt;, by directly modifying
&lt;running&gt;, or via some other implementation-specific mechanism.
RESTCONF also hides how configuration is made persistent.  Note that
implementations may also have additional datastores that can propagate changes
to &lt;running&gt;. NETCONF explicitly mentions so&nbhy;called "named
datastores".
    </t>
    <t>
Some observations:
    </t>
<t>
 <list style="symbols">
 <t>
Operational state has not been defined as a datastore, although there
were proposals in the past to introduce an operational state
datastore.
 </t>
 <t>
The NETCONF &lt;get&gt; operation returns the contents of &lt;running&gt;
together with the operational state.  It is therefore necessary that
&quot;config false&quot; data be in a different branch than the
&quot;config&nbsp;true&quot; data if the operational state can have a
different lifetime compared to configuration or if configuration is not
immediately or successfully applied. 
 </t>
 <t>
Several implementations have proprietary mechanisms that allow
clients to store inactive data in &lt;running&gt;.  Inactive data is
conceptually removed before validation.
 </t>
 <t>
Some implementations have proprietary mechanisms that allow clients
to define configuration templates in &lt;running&gt;.  These
templates are expanded automatically by the system, and the
resulting configuration is applied internally.
 </t>
 <t>
Some operators have reported that it is essential for them to be
able to retrieve the configuration that has actually been
successfully applied, which may be a subset or a superset of the
&lt;running&gt; configuration.
 </t>
 </list>
</t>
</section>
</section>
<section title="Architectural Model of Datastores" anchor="datastore-model">
    <t>
Below is a new conceptual model of datastores, extending the original
model in order to reflect the experience gained with the original
model.
    </t>

<figure anchor="newarch"><artwork><![CDATA[
  +-------------+                 +-----------+
  | <candidate> |                 | <startup> |
  |  (ct, rw)   |<---+       +--->| (ct, rw)  |
  +-------------+    |       |    +-----------+
         |           |       |           |
         |         +-----------+         |
         +-------->| <running> |<--------+
                   | (ct, rw)  |
                   +-----------+
                         |
                         |        // configuration transformations,
                         |        // e.g., removal of nodes marked as
                         |        // "inactive", expansion of
                         |        // templates
                         v
                   +------------+
                   | <intended> | // subject to validation
                   | (ct, ro)   |
                   +------------+
                         |        // changes applied, subject to
                         |        // local factors, e.g., missing
                         |        // resources, delays
                         |
    dynamic              |   +-------- learned configuration
    configuration        |   +-------- system configuration
    datastores -----+    |   +-------- default configuration
                    |    |   |
                    v    v   v
                 +---------------+
                 | <operational> | <-- system state
                 | (ct + cf, ro) |
                 +---------------+

  ct = config true; cf = config false
  rw = read-write; ro = read-only
  boxes denote named datastores
]]></artwork></figure>

<section title="Conventional Configuration Datastores" anchor="conventional-configuration-datastores">
    <t>
The conventional configuration datastores are a set of configuration
datastores that share exactly the same datastore schema, allowing data
to be copied between them.  The term is meant as a generic umbrella
description of these datastores.  If a module does not contain any
configuration data nodes and it is not needed to satisfy any imports,
then it MAY be omitted from the datastore schema for the conventional
configuration datastores.  The set of datastores include:
    </t>
<t>
 <list style="symbols">
 <t>
&lt;running&gt;
 </t>
 <t>
&lt;candidate&gt;
 </t>
 <t>
&lt;startup&gt;
 </t>
 <t>
&lt;intended&gt;
 </t>
 </list>
</t>
    <t>
Other conventional configuration datastores may be defined in future
documents.
    </t>
    <t>
The flow of data between these datastores is depicted in
<xref target="datastore-model"/>.
    </t>
    <t>
The specific protocols may define explicit operations to copy between
these datastores, e.g., NETCONF defines the &lt;copy&#8209;config&gt;
operation.
    </t>

<section title="The Startup Configuration Datastore (&lt;startup&gt;)" anchor="the-startup-configuration-datastore-startup">
    <t>
The startup configuration datastore (&lt;startup&gt;) is a configuration
datastore holding the configuration loaded by the device when it
boots.  &lt;startup&gt; is only present on devices that separate the startup
configuration from the running configuration datastore.
    </t>
    <t>
The startup configuration datastore may not be supported by all
protocols or implementations.
    </t>
    <t>
On devices that support non-volatile storage, the contents of
&lt;startup&gt; will typically persist across reboots via that storage.  At
boot time, the device loads the saved startup configuration into
&lt;running&gt;.  To save a new startup configuration, data is copied to
&lt;startup&gt; via either implicit or explicit protocol operations.
    </t>
</section>

<section title="The Candidate Configuration Datastore (&lt;candidate&gt;)" anchor="the-candidate-configuration-datastore-candidate">
    <t>
The candidate configuration datastore (&lt;candidate&gt;) is a configuration
datastore that can be manipulated without impacting the device&apos;s
current configuration and that can be committed to &lt;running&gt;.
    </t>
    <t>
The candidate configuration datastore may not be supported by all
protocols or implementations.
    </t>
    <t>
&lt;candidate&gt; does not typically persist across reboots, even in the
presence of non&nbhy;volatile storage.  If &lt;candidate&gt; is stored using
non&nbhy;volatile storage, it is reset at boot time to the contents
of &lt;running&gt;.
    </t>
</section>
<section title="The Running Configuration Datastore (&lt;running&gt;)" anchor="the-running-configuration-datastore-running">
    <t>
The running configuration datastore (&lt;running&gt;) is a configuration
datastore that holds the current configuration of the
device.  It MAY include configuration that requires further
transformation before it can be applied, e.g., inactive
configuration, or template-mechanism-oriented configuration that
needs further expansion.  However, &lt;running&gt; MUST always be a
valid configuration data tree, as defined in Section&nbsp;8.1 of
<xref target="RFC7950"/>.
    </t>
    <t>
&lt;running&gt; MUST be supported if the device can be configured via
conventional configuration datastores.
    </t>
    <t>
If a device does not have a distinct &lt;startup&gt; and non&nbhy;volatile
storage is available, the device will typically use that non&nbhy;volatile
storage to allow &lt;running&gt; to persist across reboots.
    </t>
</section>

<section title="The Intended Configuration Datastore (&lt;intended&gt;)" anchor="the-intended-configuration-datastore-intended">
    <t>
The intended configuration datastore (&lt;intended&gt;) is a read&nbhy;only
configuration datastore.  It represents the configuration after all
configuration transformations to &lt;running&gt; are performed (e.g.,
template expansion, removal of inactive configuration) and is the
configuration that the system attempts to apply.
    </t>
    <t>
&lt;intended&gt; is tightly coupled to &lt;running&gt;. Whenever data is
written to &lt;running&gt;, the server MUST also immediately update and
validate &lt;intended&gt;.
    </t>
    <t>
&lt;intended&gt; MAY also be updated independently of &lt;running&gt; if the
effect of a configuration transformation changes, but &lt;intended&gt; MUST
always be a valid configuration data tree, as defined in Section&nbsp;8.1
of <xref target="RFC7950"/>.
    </t>
    <t>
For simple implementations, &lt;running&gt; and &lt;intended&gt; are
identical.
    </t>
    <t>
The contents of &lt;intended&gt; are also related to the &quot;config
true&quot; subset of &lt;operational&gt;; hence, a client can determine to
what extent the intended configuration is currently in use by checking to see
whether the contents of &lt;intended&gt; also appear in &lt;operational&gt;.
    </t>
    <t>
&lt;intended&gt; does not persist across reboots; its relationship with
&lt;running&gt; makes that unnecessary.
    </t>
    <t>
Currently, there are no standard mechanisms defined that affect
&lt;intended&gt; so that it would have different content than
&lt;running&gt;, but this architecture allows for such mechanisms to be
defined.
    </t>
    <t>
One example of such a mechanism is support for marking nodes as
inactive in &lt;running&gt;.  Inactive nodes are not copied to
&lt;intended&gt;.  A second example is support for templates, which can
perform transformations on the configuration from &lt;running&gt; to
the configuration written to &lt;intended&gt;.
    </t>
</section>
</section>
<section title="Dynamic Configuration Datastores" anchor="dynamic-configuration-datastores">
    <t>
The model recognizes the need for dynamic configuration datastores
that are, by definition, not part of the persistent configuration of a
device.  In some contexts, these have been termed "ephemeral datastores",
since the information is ephemeral, i.e., lost upon reboot.  The
dynamic configuration datastores interact with the rest of the system
through &lt;operational&gt;.
    </t>
    <t>
The datastore schema for a dynamic configuration datastore MAY differ
from the datastore schema used for conventional configuration
datastores.  If a module does not contain any configuration data nodes
and it is not needed to satisfy any imports, then it MAY be omitted
from the datastore schema for the dynamic configuration datastore.
    </t>
</section>
<section title="The Operational State Datastore (&lt;operational&gt;)" anchor="the-operational-state-datastore-operational">
    <t>
The operational state datastore (&lt;operational&gt;) is a read&nbhy;only
datastore that consists of all &quot;config true&quot; and &quot;config
false&quot; nodes defined in the datastore&apos;s schema.  In the original
NETCONF model, the operational state only had &quot;config false&quot; nodes.
The reason for incorporating &quot;config true&quot; nodes here is to be able
to expose all operational settings without having to replicate definitions in
the data models.
    </t>
    <t>
&lt;operational&gt; contains system state and all configuration actually
used by the system.  This includes all applied configuration from
&lt;intended&gt;, learned configuration, system-provided configuration, and
default values defined by any supported data models.  In addition,
&lt;operational&gt; also contains applied configuration from dynamic
configuration datastores.
    </t>
    <t>
The datastore schema for &lt;operational&gt; MUST be a superset of the
combined datastore schema used in all configuration datastores, except
that configuration data nodes supported in a configuration datastore
MAY be omitted from &lt;operational&gt; if a server is not able to
accurately report them.
    </t>
    <t>
Requests to retrieve nodes from &lt;operational&gt; always return the value
in use if the node exists, regardless of any default value specified
in the YANG module.  If no value is returned for a given node, then
this implies that the node is not used by the device.
    </t>
    <t>
The interpretation of what constitutes being &quot;in use&quot; by the system
is dependent on both the schema definition and the device implementation.
Generally, functionality that is enabled and operational on the system would
be considered to be &quot;in use&quot;. Conversely, functionality that is
neither enabled nor operational on the system is considered not to be
&quot;in use&quot;; hence, it SHOULD be omitted from &lt;operational&gt;.
    </t>
    <t>
&lt;operational&gt; SHOULD conform to any constraints specified in the data
model, but given the principal aim of returning &quot;in use&quot; values, it
is possible that constraints MAY be violated under some circumstances
(e.g., an abnormal value is &quot;in use&quot;, the structure of a list is
being modified, or remnant configuration (see <xref target="remnant"/>) still
exists). Note that deviations SHOULD be used when it is known in advance that
a device does not fully conform to the &lt;operational&gt; schema.
    </t>
    <t>
Only semantic constraints MAY be violated. These are the YANG &quot;when&quot;,
&quot;must&quot;, &quot;mandatory&quot;, &quot;unique&quot;,
&quot;min&#8209;elements&quot;, and &quot;max&#8209;elements&quot; statements;
and the uniqueness of key values.
    </t>
    <t>
Syntactic constraints MUST NOT be violated, including hierarchical
organization, identifiers, and type-based constraints.  If a node in
&lt;operational&gt; does not meet the syntactic constraints, then it
MUST&nbsp;NOT be returned, and some other mechanism should be used to flag
the error.
    </t>
    <t>
&lt;operational&gt; does not persist across reboots.
    </t>
<section title="Remnant Configuration" anchor="remnant">
    <t>
Changes to configuration may take time to percolate through to
&lt;operational&gt;.  During this period, &lt;operational&gt; may contain
nodes for both the previous and current configuration, as closely as
possible tracking the current operation of the device.  Such remnant
configuration from the previous configuration persists until the
system has released resources used by the newly deleted configuration
(e.g., network connections, memory allocations, file handles).
    </t>
    <t>
Remnant configuration is a common example of where the semantic
constraints defined in the data model cannot be relied upon for
&lt;operational&gt;, since the system may have remnant configuration whose
constraints were valid with the previous configuration and that are
not valid with the current configuration.  Since constraints on
&quot;config false&quot; nodes may refer to &quot;config true&quot; nodes,
remnant configuration may force the violation of those constraints.
    </t>
</section>
<section title="Missing Resources" anchor="missing-resources">
    <t>
Configuration in &lt;intended&gt; can refer to resources that are not
available or otherwise not physically present.  In these situations,
these parts of &lt;intended&gt; are not applied.  The data
appears in &lt;intended&gt; but does not appear in &lt;operational&gt;.
    </t>
    <t>
A typical example is an interface configuration that refers to an
interface that is not currently present.  In such a situation, the
interface configuration remains in &lt;intended&gt; but the interface
configuration will not appear in &lt;operational&gt;.
    </t>
    <t>
Note that configuration validity cannot depend on the current state of
such resources, since that would imply that removing a resource might
render the configuration invalid.  This is unacceptable, especially
given that rebooting such a device would cause it to restart with an
invalid configuration.  Instead, we allow configuration for missing
resources to exist in &lt;running&gt; and &lt;intended&gt;, but it will not
appear in &lt;operational&gt;.
    </t>
</section>
<section title="System-Controlled Resources" anchor="system-controlled-resources">
    <t>
Sometimes, resources are controlled by the device and the corresponding
system-controlled data appears in (and disappears from) &lt;operational&gt;
dynamically.  If a system-controlled resource has matching configuration
in &lt;intended&gt; when it appears, the system will try to apply the
configuration; this causes the configuration to appear in
&lt;operational&gt; eventually (if application of the configuration was
successful).
    </t>
</section>

<section title="Origin Metadata Annotation" anchor="origin-metadata-annotation">
    <t>
As configuration flows into &lt;operational&gt;, it is conceptually marked
with a metadata annotation <xref target="RFC7952"/> that indicates its origin.
The origin applies to all configuration nodes except non&nbhy;presence
containers.  The &quot;origin&quot; metadata annotation is defined in
<xref target="yang-module"/>.  The values are YANG identities.  The following
identities are defined:
    </t>
<t>
 <list style="symbols">
 <t>
origin: abstract base identity from which the other origin
identities are derived.
 </t>
 <t>
intended: represents configuration provided by &lt;intended&gt;.
 </t>
 <t>
dynamic: represents configuration provided by a dynamic
configuration datastore.
 </t>
 <t>
system: represents configuration provided by the system itself.
Examples of system configuration include applied configuration for
an always-existing loopback interface, or interface configuration
that is auto-created due to the hardware currently present in the
device.
 </t>
 <t>
learned: represents configuration that has been learned via protocol
interactions with other systems, including such protocols as
link-layer negotiations, routing protocols, and DHCP.
 </t>
 <t>
default: represents configuration using a default value specified in
the data model, using either values in the &quot;default&quot; statement or
any values described in the &quot;description&quot; statement.  The default
origin is only used when the configuration has not been provided by
any other source.
 </t>
 <t>
unknown: represents configuration for which the system cannot
identify the origin.
 </t>
 </list>
</t>
    <t>
These identities can be further refined, e.g., there could be separate
identities for particular types or instances of dynamic configuration
datastores derived from &quot;dynamic&quot;.
    </t>
    <t>
For all configuration data nodes in &lt;operational&gt;, the device SHOULD
report the origin that most accurately reflects the source of the
configuration that is in use by the system.
    </t>
    <t>
In cases where it could be ambiguous as to which origin should be
used, i.e., where the same data node value has originated from multiple
sources, the "description" statement in the YANG module SHOULD be
used as guidance for choosing the appropriate origin.  For example:
    </t>
    <t>
If, for a particular configuration node, the associated YANG
"description" statement indicates that a protocol-negotiated value
overrides any configured value, then the origin would be reported as
&quot;learned&quot;, even when a learned value is the same as the configured
value.
    </t>
    <t>
Conversely, if, for a particular configuration node, the associated
YANG "description" statement indicates that a protocol-negotiated value
does not override an explicitly configured value, then the origin
would be reported as &quot;intended&quot;, even when a learned value is
the same as the configured value.
    </t>
    <t>
In the case that a device cannot provide an accurate origin for a
particular configuration data node, it SHOULD use the origin
&quot;unknown&quot;.
    </t>
</section>
</section>
</section>

<section title="Implications on YANG" anchor="implications-on-yang">
<section title="XPath Context" anchor="xpath">
    <t>
This section updates Section 6.4.1 of RFC 7950.
    </t>
    <t>
If a server implements the architecture defined in this document, the
accessible trees for some XPath contexts are refined as follows:
    </t>
<t>
 <list style="symbols">
 <t>
If the XPath expression is defined in a substatement to a data node
that represents system state, the accessible tree is all operational
state in the server.  The root node has all top-level data
nodes in all modules as children.
 </t>
 <t>
If the XPath expression is defined in a substatement to a
&quot;notification&quot; statement, the accessible tree is the notification
instance and all operational state in the server.  If the
notification is defined on the top level in a module, then the root
node has the node representing the notification being defined and
all top-level data nodes in all modules as children.  Otherwise, the
root node has all top-level data nodes in all modules as children.
 </t>
 <t>
If the XPath expression is defined in a substatement to an &quot;input&quot;
statement in an &quot;rpc&quot; or &quot;action&quot; statement, the
accessible tree is the RPC or action operation instance and all
operational state in the server. The root node has top-level data nodes in
all modules as children.  Additionally, for an RPC, the root node also has
the node representing the RPC operation being defined as a child.  The
node representing the operation being defined has the operation&apos;s
input parameters as children.
 </t>
 <t>
If the XPath expression is defined in a substatement to an &quot;output&quot;
statement in an &quot;rpc&quot; or &quot;action&quot; statement, the
accessible tree is the RPC or action operation instance and all
operational state in the server.  The root node has top-level data nodes in
all modules as children.  Additionally, for an RPC, the root node also has the
node representing the RPC operation being defined as a child.  The
node representing the operation being defined has the operation&apos;s
output parameters as children.
 </t>
 </list>
</t>
</section>

<section title="Invocation of Actions and RPCs" anchor="invocation">
    <t>
This section updates Section 7.15 of RFC 7950.
    </t>
    <t>
Actions are always invoked in the context of the operational state
datastore.  The node for which the action is invoked MUST exist in
the operational state datastore.
    </t>
    <t>
Note that this document does not constrain the result of invoking an
RPC or action in any way.  For example, an RPC might be defined to
modify the contents of some datastore.
    </t>
</section>
</section>

<section title="YANG Modules" anchor="yang-module">

 <figure> <artwork><![CDATA[
<CODE BEGINS> file "ietf-datastores@2018-02-14.yang"

module ietf-datastores {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-datastores";
  prefix ds;

  organization
    "IETF Network Modeling (NETMOD) Working Group";

  contact
    "WG Web:   <https://datatracker.ietf.org/wg/netmod/>

     WG List:  <mailto:netmod@ietf.org>

     Author:   Martin Bjorklund
               <mailto:mbj@tail-f.com>

     Author:   Juergen Schoenwaelder
               <mailto:j.schoenwaelder@jacobs-university.de>

     Author:   Phil Shafer
               <mailto:phil@juniper.net>

     Author:   Kent Watsen
               <mailto:kwatsen@juniper.net>

     Author:   Rob Wilton
               <rwilton@cisco.com>";

  description
    "This YANG module defines a set of identities for identifying
     datastores.

     Copyright (c) 2018 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 8342
     (https://www.rfc-editor.org/info/rfc8342); see the RFC itself
     for full legal notices.";

  revision 2018-02-14 {
    description
      "Initial revision.";
    reference
      "RFC 8342: Network Management Datastore Architecture (NMDA)";
  }

  /*
   * Identities
   */

  identity datastore {
    description
      "Abstract base identity for datastore identities.";
  }

  identity conventional {
    base datastore;
    description
      "Abstract base identity for conventional configuration
       datastores.";
  }

  identity running {
    base conventional;
    description
      "The running configuration datastore.";
  }

  identity candidate {
    base conventional;
    description
      "The candidate configuration datastore.";
  }

  identity startup {
    base conventional;
    description
      "The startup configuration datastore.";
  }

  identity intended {
    base conventional;
    description
      "The intended configuration datastore.";
  }

  identity dynamic {
    base datastore;
    description
      "Abstract base identity for dynamic configuration datastores.";
  }

  identity operational {
    base datastore;
    description
      "The operational state datastore.";
  }

  /*
   * Type definitions
   */

  typedef datastore-ref {
    type identityref {
      base datastore;
    }
    description
      "A datastore identity reference.";
  }
}

<CODE ENDS> ]]></artwork> </figure>

 <figure> <artwork><![CDATA[
<CODE BEGINS> file "ietf-origin@2018-02-14.yang"

module ietf-origin {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-origin";
  prefix or;

  import ietf-yang-metadata {
    prefix md;
  }

  organization
    "IETF Network Modeling (NETMOD) Working Group";

  contact
    "WG Web:   <https://datatracker.ietf.org/wg/netmod/>

     WG List:  <mailto:netmod@ietf.org>

     Author:   Martin Bjorklund
               <mailto:mbj@tail-f.com>

     Author:   Juergen Schoenwaelder
               <mailto:j.schoenwaelder@jacobs-university.de>

     Author:   Phil Shafer
               <mailto:phil@juniper.net>

     Author:   Kent Watsen
               <mailto:kwatsen@juniper.net>

     Author:   Rob Wilton
               <rwilton@cisco.com>";

  description
    "This YANG module defines an 'origin' metadata annotation and a
     set of identities for the origin value.

     Copyright (c) 2018 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 8342
     (https://www.rfc-editor.org/info/rfc8342); see the RFC itself
     for full legal notices.";

  revision 2018-02-14 {
    description
      "Initial revision.";
    reference
      "RFC 8342: Network Management Datastore Architecture (NMDA)";
  }

  /*
   * Identities
   */

  identity origin {
    description
      "Abstract base identity for the origin annotation.";
  }

  identity intended {
    base origin;
    description
      "Denotes configuration from the intended configuration
       datastore.";
  }

  identity dynamic {
    base origin;
    description
      "Denotes configuration from a dynamic configuration
       datastore.";
  }

  identity system {
    base origin;
    description
      "Denotes configuration originated by the system itself.

       Examples of system configuration include applied configuration
       for an always-existing loopback interface, or interface
       configuration that is auto-created due to the hardware
       currently present in the device.";
  }

  identity learned {
    base origin;
    description
      "Denotes configuration learned from protocol interactions with
       other devices, instead of via either the intended
       configuration datastore or any dynamic configuration
       datastore.

       Examples of protocols that provide learned configuration
       include link-layer negotiations, routing protocols, and
       DHCP.";
  }

  identity default {
    base origin;
    description
      "Denotes configuration that does not have a configured or
       learned value but has a default value in use.  Covers both
       values defined in a 'default' statement and values defined
       via an explanation in a 'description' statement.";
  }

  identity unknown {
    base origin;
    description
      "Denotes configuration for which the system cannot identify the
       origin.";
  }

  /*
   * Type definitions
   */

  typedef origin-ref {
    type identityref {
      base origin;
    }
    description
      "An origin identity reference.";
  }

  /*
   * Metadata annotations
   */

  md:annotation origin {
    type origin-ref;
    description
      "The 'origin' annotation can be present on any configuration
       data node in the operational state datastore.  It specifies
       from where the node originated.  If not specified for a given
       configuration data node, then the origin is the same as the
       origin of its parent node in the data tree.  The origin for
       any top-level configuration data nodes must be specified.";
  }
}

<CODE ENDS> ]]></artwork> </figure>

</section>

<section title="IANA Considerations" anchor="iana-con">
<section title="Updates to the IETF XML Registry" anchor="updates-to-the-ietf-xml-registry">
    <t>
This document registers two URIs in the "IETF XML Registry" <xref
target="RFC3688"/>.  Following the format in <xref target="RFC3688"/>, the
following registrations have been made:
    </t>
        <figure>
            <artwork><![CDATA[
   URI: urn:ietf:params:xml:ns:yang:ietf-datastores
   Registrant Contact: The IESG.
   XML: N/A; the requested URI is an XML namespace.

   URI: urn:ietf:params:xml:ns:yang:ietf-origin
   Registrant Contact: The IESG.
   XML: N/A; the requested URI is an XML namespace.
            ]]></artwork>
        </figure>
</section>
<section title="Updates to the YANG Module Names Registry" anchor="updates-to-the-yang-module-names-registry">
    <t>
This document registers two YANG modules in the "YANG Module Names" registry
<xref target="RFC6020"/>.  Following the format in <xref target="RFC6020"/>,
the following registrations have been made:
    </t>
        <figure>
            <artwork><![CDATA[
   name:         ietf-datastores
   namespace:    urn:ietf:params:xml:ns:yang:ietf-datastores
   prefix:       ds
   reference:    RFC 8342

   name:         ietf-origin
   namespace:    urn:ietf:params:xml:ns:yang:ietf-origin
   prefix:       or
   reference:    RFC 8342
            ]]></artwork>
        </figure>
</section>
</section>

<section title="Security Considerations" anchor="sec-con">
    <t>
This document discusses an architectural model of datastores for network
management using NETCONF/RESTCONF and YANG.  It has no security impact
on the Internet.
    </t>
    <t>
Although this document specifies several YANG modules, these modules
only define identities and a metadata annotation; hence, the &quot;YANG
module security guidelines&quot; <xref target="YANG-SEC"/> do not apply.
    </t>
    <t>
The origin metadata annotation exposes the origin of values in the
applied configuration. Origin information may provide hints that
certain control-plane protocols are active on a device. Since origin
information is tied to applied configuration values, it is only
accessible to clients that have the permissions to read the applied
configuration values. Security administrators should consider the
sensitivity of origin information while defining access control rules.
    </t>
</section>

</middle>

<back>

<references title="Normative References">

<?rfc include="reference.RFC.2119"?>
<?rfc include="reference.RFC.6241"?>
<?rfc include="reference.RFC.7950"?>
<?rfc include="reference.RFC.7952"?>
<?rfc include="reference.RFC.8040"?>
<?rfc include="reference.RFC.8174"?>

<reference anchor='W3C.REC-xml-20081126'
           target='https://www.w3.org/TR/2008/REC-xml-20081126'>
<front>
<title>Extensible Markup Language (XML) 1.0 (Fifth Edition)</title>
<author initials='T.' surname='Bray' fullname='Tim Bray'>
    <organization />
</author>
<author initials='J.' surname='Paoli' fullname='Jean Paoli'>
    <organization />
</author>
<author initials='M.' surname='Sperberg-McQueen' fullname='Michael
        Sperberg-McQueen'>
    <organization />
</author>
<author initials='E.' surname='Maler' fullname='Eve Maler'>
    <organization />
</author>
<author initials='F.' surname='Yergeau' fullname='Francois Yergeau'>
    <organization />
</author>
<date month='November' year='2008' />
</front>
<seriesInfo name='World Wide Web Consortium Recommendation'
     value='REC-xml-20081126' />
</reference>

</references>

<references title="Informative References">

<?rfc include="reference.RFC.3688"?>
<?rfc include="reference.RFC.6020"?>
<?rfc include="reference.RFC.6244"?>

<!-- draft-ietf-netmod-rfc7223bis (RFC 8343 - AUTH48) -->
<reference anchor="RFC8343" target="https://www.rfc-editor.org/info/rfc8343">
  <front>
    <title>A YANG Data Model for Interface Management</title>
    <author initials="M" surname="Bjorklund" fullname="Martin Bjorklund">
      <organization/>
    </author>
  <date month="March" year="2018"/>
  </front>
<seriesInfo name="RFC" value="8343"/>
<seriesInfo name="DOI" value="10.17487/RFC8343"/>
</reference>

<!-- draft-ietf-netmod-rfc7277bis (RFC 8344 - AUTH48) -->
<reference anchor='RFC8344' target="https://www.rfc-editor.org/info/rfc8344">
<front>
<title>A YANG Data Model for IP Management</title>
<author initials='M' surname='Bjorklund' fullname='Martin Bjorklund'>
    <organization />
</author>
<date month='March' year='2018' />
</front>
<seriesInfo name="RFC" value="8344"/>
<seriesInfo name="DOI" value="10.17487/RFC8344"/>
</reference>

<!-- draft-ietf-netmod-opstate-reqs (Expired) -->
<reference anchor="OpState-Reqs">
  <front>
    <title>Terminology and Requirements for Enhanced Handling of Operational State</title>
    <author initials="K" surname="Watsen" fullname="Kent Watsen">
      <organization/>
    </author>
    <author initials="T" surname="Nadeau" fullname="Thomas Nadeau">
      <organization/>
    </author>
    <date month="January" year="2016"/>
  </front>
  <seriesInfo name="Work in Progress," value="draft-ietf-netmod-opstate-reqs-04"/>
</reference>

<!-- draft-bjorklund-netmod-operational (replaced by
     draft-nmdsdt-netmod-revised-datastores, which was in
     turn replaced by this doc). -->
<reference anchor="NETMOD-Operational">
  <front>
    <title>Operational Data in NETCONF and YANG</title>
    <author initials="M" surname="Bjorklund" fullname="Martin Bjorklund">
      <organization/>
    </author>
    <author initials="L" surname="Lhotka" fullname="Ladislav Lhotka">
      <organization/>
    </author>
    <date month="October" year="2012"/>
  </front>
  <seriesInfo name="Work in Progress," value="draft-bjorklund-netmod-operational-00"/>
</reference>

<!-- draft-kwatsen-netmod-opstate (replaced by
     draft-nmdsdt-netmod-revised-datastores, which was in
     turn replaced by this doc). -->
<reference anchor="OpState-Enhance">
  <front>
    <title>Operational State Enhancements for YANG, NETCONF, and RESTCONF</title>
    <author initials="K" surname="Watsen" fullname="Kent Watsen">
      <organization/>
    </author>
    <author initials="A" surname="Bierman" fullname="Andy Bierman">
      <organization/>
    </author>
    <author initials="M" surname="Bjorklund" fullname="Martin Bjorklund">
      <organization/>
    </author>
    <author initials="J" surname="Schoenwaelder" fullname="Juergen Schoenwaelder">
      <organization/>
    </author>
    <date month="February" year="2016"/>
  </front>
  <seriesInfo name="Work in Progress," value="draft-kwatsen-netmod-opstate-02"/>
</reference>

<!-- draft-openconfig-netmod-opstate (Expired) -->
<reference anchor="OpState-Modeling">
  <front>
    <title>Consistent Modeling of Operational State Data in YANG</title>
    <author initials="R" surname="Shakir" fullname="Rob Shakir">
      <organization/>
    </author>
    <author initials="A" surname="Shaikh" fullname="Anees Shaikh">
      <organization/>
    </author>
    <author initials="M" surname="Hines" fullname="Marcus Hines">
      <organization/>
    </author>
    <date month="July" year="2015"/>
  </front>
  <seriesInfo name="Work in Progress," value="draft-openconfig-netmod-opstate-01"/>
</reference>

<!-- draft-wilton-netmod-opstate-yang (replaced by
     draft-nmdsdt-netmod-revised-datastores, which was in
     turn replaced by this doc). -->
<reference anchor="With-config-state">
  <front>
    <title>"With-config-state" Capability for NETCONF/RESTCONF</title>
    <author initials="R" surname="Wilton" fullname="Robert Wilton">
      <organization/>
    </author>
    <date month="December" year="2015"/>
  </front>
  <seriesInfo name="Work in Progress," value="draft-wilton-netmod-opstate-yang-02"/>
</reference>

<reference anchor="YANG-SEC" target="https://trac.ietf.org/trac/ops/wiki/yang-security-guidelines">
 <front>
  <title>YANG Security Guidelines</title>
    <author fullname="IETF">
     <organization>IETF</organization>
    </author>
  <date/>
 </front>
</reference>

</references>

<section title="Guidelines for Defining Datastores" anchor="guidelines">
    <t>
The definition of a new datastore in this architecture should be
provided in a document (e.g., an RFC) purposed for defining the
datastore.  When it makes sense, more than one datastore may be
defined in the same document (e.g., when the datastores are logically
connected).  Each datastore&apos;s definition should address the points
specified in the subsections below.
    </t>

<section title="Define Which YANG Modules Can Be Used in the Datastore" anchor="define-which-yang-modules-can-be-used-in-the-datastore">
    <t>
Not all YANG modules may be used in all datastores.  Some datastores may
constrain which data models can be used in them.  If it is desirable that
a subset of all modules can be targeted to the datastore, then the
documentation defining the datastore must indicate this.
    </t>
</section>

<section title="Define Which Subset of YANG-Modeled Data Applies" anchor="define-which-subset-of-yang-modeled-data-applies">
    <t>
By default, the data in a datastore is modeled by all YANG statements
in the available YANG modules.  However, it is possible to specify
criteria that YANG statements must satisfy in order to be present in a
datastore.  For instance, maybe only &quot;config true&quot; nodes, or &quot;config
false&quot; nodes that also have a specific YANG extension, are present in
the datastore.
    </t>
</section>
<section title="Define How Data Is Actualized" anchor="define-how-data-is-actualized">
    <t>
The new datastore must specify how it interacts with other datastores.
    </t>
    <t>
For example, the diagram in <xref target="datastore-model"/> depicts dynamic
configuration datastores feeding into &lt;operational&gt;.  How this
interaction occurs has to be defined by the particular dynamic
configuration datastores.  In some cases, it may occur implicitly, as
soon as the data is put into the dynamic configuration datastore,
while in other cases an explicit action (e.g., an RPC) may be
required to trigger the application of the datastore&apos;s data.
    </t>
</section>
<section title="Define Which Protocols Can Be Used" anchor="define-which-protocols-can-be-used">
    <t>
By default, it is assumed that both the NETCONF and RESTCONF
protocols can be used to interact with a datastore.
However, it may be that only a specific protocol can be used
(e.g., Forwarding and Control Element Separation (ForCES)) or that a
subset of all protocol operations or capabilities are available (e.g., no
locking or no XPath-based filtering).
    </t>
</section>

<section title="Define YANG Identities for the Datastore" anchor="def-module">
    <t>
The datastore must be defined with a YANG identity that uses the
&quot;ds:datastore&quot; identity, or one of its derived identities, as its
base.  This identity is necessary, so that the datastore can be
referenced in protocol operations (e.g., &lt;get&#8209;data&gt;).
    </t>
    <t>
The datastore may also be defined with an identity that uses the
&quot;or:origin&quot; identity, or one of its derived identities, as its
base.  This identity is needed if the datastore interacts with
&lt;operational&gt;, so that data originating from the datastore can be
identified as such via the &quot;origin&quot; metadata attribute defined in
<xref target="yang-module"/>.
    </t>
    <t>
An example of these guidelines in use is provided in
<xref target="ephemeral-ds-example"/>.
    </t>
</section>
</section>

<section title="Example of an Ephemeral Dynamic Configuration Datastore" anchor="ephemeral-ds-example">
    <t>
This section defines documentation for an example dynamic configuration
datastore using the guidelines provided in <xref target="guidelines"/>.
For brevity, only a terse example is provided; it is expected that a
standalone RFC would be written when this type of scenario is fully
considered.</t>

<t>
This example defines a dynamic configuration datastore called
&quot;ephemeral&quot;, which is loosely modeled after the work done
in the I2RS Working Group.</t>

<texttable title="Properties of the Example &quot;ephemeral&quot; Datastore">
<ttcol align='left'>Name</ttcol>
<ttcol align='left'>Value</ttcol>
<c>Name</c>
<c>ephemeral</c>
<c>YANG modules</c>
<c>all (default)</c>
<c>YANG nodes</c>
<c>all &quot;config true&quot; data nodes</c>
<c>How applied</c>
<c>changes automatically propagated to &lt;operational&gt;</c>
<c>Protocols</c>
<c>NETCONF/RESTCONF (default)</c>
<c>Defining YANG module</c>
<c>&quot;example-ds-ephemeral&quot;</c>
</texttable>

        <figure>
            <artwork><![CDATA[
module example-ds-ephemeral {
  yang-version 1.1;
  namespace "urn:example:ds-ephemeral";
  prefix eph;

  import ietf-datastores {
    prefix ds;
  }
  import ietf-origin {
    prefix or;
  }

  // datastore identity
  identity ds-ephemeral {
    base ds:dynamic;
    description
      "The ephemeral dynamic configuration datastore.";
  }

  // origin identity
  identity or-ephemeral {
    base or:dynamic;
    description
      "Denotes data from the ephemeral dynamic configuration
       datastore.";
  }
}
            ]]></artwork>
        </figure>
</section>

<section title="Example Data" anchor="example-data">
    <t>
The use of datastores is complex, and many of the subtle effects are
more easily presented using examples.  This section presents a series
of example data models with some sample contents of the various
datastores.
    </t>
    <t>
The XML <xref target="W3C.REC-xml-20081126"/> snippets that follow are
provided as examples only.
    </t>

<section title="System Example" anchor="system-example">
    <t>
In this example, the following fictional module is used:
    </t>
        <figure>
            <artwork><![CDATA[
module example-system {
  yang-version 1.1;
  namespace urn:example:system;
  prefix sys;

  import ietf-inet-types {
    prefix inet;
  }

  container system {
    leaf hostname {
      type string;
    }

    list interface {
      key name;

      leaf name {
        type string;
      }

      container auto-negotiation {
        leaf enabled {
          type boolean;
          default true;
        }
        leaf speed {
          type uint32;
          units mbps;
          description
            "The advertised speed, in Mbps.";
        }
      }

      leaf speed {
        type uint32;
        units mbps;
        config false;
        description
          "The speed of the interface, in Mbps.";
      }

      list address {
        key ip;

        leaf ip {
          type inet:ip-address;
        }
        leaf prefix-length {
          type uint8;
        }
      }
    }
  }
}
            ]]></artwork>
        </figure>
    <t>
The operator has configured the hostname and two interfaces, so the
contents of &lt;intended&gt; are:
    </t>
        <figure>
            <artwork><![CDATA[
<system xmlns="urn:example:system">

  <hostname>foo.example.com</hostname>

  <interface>
    <name>eth0</name>
    <auto-negotiation>
      <speed>1000</speed>
    </auto-negotiation>
    <address>
      <ip>2001:db8::10</ip>
      <prefix-length>64</prefix-length>
    </address>
  </interface>

  <interface>
    <name>eth1</name>
    <address>
      <ip>2001:db8::20</ip>
      <prefix-length>64</prefix-length>
    </address>
  </interface>

</system>
            ]]></artwork>
        </figure>
    <t>
The system has detected that the hardware for one of the configured
interfaces (&quot;eth1&quot;) is not yet present, so the configuration for
that interface is not applied.  Further, the system has received a hostname
and an additional IP address for &quot;eth0&quot; over DHCP.  In addition to
filling in the default value for the auto&nbhy;negotiation enabled leaf, a
loopback interface entry is also automatically instantiated by the system.
All of this is reflected in &lt;operational&gt;.  Note how the
&quot;origin&quot; metadata attribute for several &quot;config true&quot; data
nodes is inherited from their parent data nodes.
    </t>
        <figure>
            <artwork><![CDATA[
<system
    xmlns="urn:example:system"
    xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin">

  <hostname or:origin="or:learned">bar.example.com</hostname>

  <interface or:origin="or:intended">
    <name>eth0</name>
    <auto-negotiation>
      <enabled or:origin="or:default">true</enabled>
      <speed>1000</speed>
    </auto-negotiation>
    <speed>100</speed>
    <address>
      <ip>2001:db8::10</ip>
      <prefix-length>64</prefix-length>
    </address>
    <address or:origin="or:learned">
      <ip>2001:db8::1:100</ip>
      <prefix-length>64</prefix-length>
    </address>
  </interface>

  <interface or:origin="or:system">
    <name>lo0</name>
    <address>
      <ip>::1</ip>
      <prefix-length>128</prefix-length>
    </address>
  </interface>

</system>
            ]]></artwork>
        </figure>
</section>
<section title="BGP Example" anchor="bgp-example">
    <t>
Consider the following fragment of a fictional BGP module:
    </t>
        <figure>
            <artwork><![CDATA[
    container bgp {
      leaf local-as {
        type uint32;
      }
      leaf peer-as {
        type uint32;
      }
      list peer {
        key name;
        leaf name {
          type inet:ip-address;
        }
        leaf local-as {
          type uint32;
          description
            "... Defaults to ../local-as.";
        }
        leaf peer-as {
          type uint32;
          description
            "... Defaults to ../peer-as.";
        }
        leaf local-port {
          type inet:port;
        }
        leaf remote-port {
          type inet:port;
          default 179;
        }
        leaf state {
          config false;
          type enumeration {
            enum init;
            enum established;
            enum closing;
          }
        }
      }
    }
            ]]></artwork>
        </figure>
    <t>
In this example model, both bgp/peer/local-as and bgp/peer/peer-as
have complex hierarchical values, allowing the user to specify default
values for all peers in a single location.
    </t>
    <t>
The model also follows the pattern of fully integrating state (&quot;config
false&quot;) nodes with configuration (&quot;config true&quot;) nodes.  There
is no separate &quot;bgp&#8209;state&quot; hierarchy, with the accompanying
repetition of containment and naming nodes.  This makes the model simpler and
more readable.
    </t>

<section title="Datastores" anchor="datastores">
    <t>
Each datastore represents differing views of these nodes.  &lt;running&gt;
will hold the configuration provided by the operator -- for example, a
single BGP peer.  &lt;intended&gt; will conceptually hold the data as
validated, after the removal of data not intended for validation and
after any local template mechanisms are performed.  &lt;operational&gt; will
show data from &lt;intended&gt; as well as any &quot;config false&quot; nodes.
    </t>
</section>

<section title="Adding a Peer" anchor="adding-a-peer">
    <t>
If the user configures a single BGP peer, then that peer will be
visible in both &lt;running&gt; and &lt;intended&gt;.  It may also appear in
&lt;candidate&gt; if the server supports the candidate configuration
datastore.  Retrieving the peer will return only the user-specified
values.
    </t>
    <t>
No time delay should exist between the appearance of the peer in
&lt;running&gt; and &lt;intended&gt;.
    </t>
    <t>
In this scenario, we&apos;ve added the following to &lt;running&gt;:
    </t>
        <figure>
            <artwork><![CDATA[
  <bgp>
    <local-as>64501</local-as>
    <peer-as>64502</peer-as>
    <peer>
      <name>2001:db8::2:3</name>
    </peer>
  </bgp>
            ]]></artwork>
        </figure>
<section title="&lt;operational&gt;" anchor="operational">
    <t>
The operational datastore will contain the fully expanded peer data,
including &quot;config false&quot; nodes.  In our example, this means that
the &quot;state&quot; node will appear.
    </t>
    <t>
In addition, &lt;operational&gt; will contain the &quot;currently in
use&quot; values for all nodes.  This means that local-as and peer-as will
be populated even if they are not given values in &lt;intended&gt;.  The value
of bgp/local-as will be used if bgp/peer/local-as is not provided;
bgp/peer-as and bgp/peer/peer-as will have the same relationship.  In
the operational view, this means that every peer will have values for
their local-as and peer-as, even if those values are not explicitly
configured but are provided by bgp/local-as and bgp/peer-as.
    </t>
    <t>
Each BGP peer has a TCP connection associated with it, using the
values of local-port and remote-port from &lt;intended&gt;.  If
those values are not supplied, the system will select values.  When
the connection is established, &lt;operational&gt; will contain the current
values for the local-port and remote-port nodes regardless of the
origin.  If the system has chosen the values, the &quot;origin&quot; attribute
will be set to &quot;system&quot;.  Before the connection is established,
one or both of the nodes may not appear, since the system may not yet
have their values.
    </t>
        <figure>
            <artwork><![CDATA[
  <bgp xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin"
       or:origin="or:intended">
    <local-as>64501</local-as>
    <peer-as>64502</peer-as>
    <peer>
      <name>2001:db8::2:3</name>
      <local-as or:origin="or:default">64501</local-as>
      <peer-as or:origin="or:default">64502</peer-as>
      <local-port or:origin="or:system">60794</local-port>
      <remote-port or:origin="or:default">179</remote-port>
      <state>established</state>
    </peer>
  </bgp>
            ]]></artwork>
        </figure>
</section>
</section>
<section title="Removing a Peer" anchor="removing-a-peer">
    <t>
Changes to configuration may take time to percolate through the
various software components involved.  During this period, it is
imperative to continue to give an accurate view of the working of the
device.  &lt;operational&gt; will contain nodes for both
the previous and current configuration, as closely as possible
tracking the current operation of the device.
    </t>
    <t>
Consider the scenario where a client removes a BGP peer.  When a peer
is removed, the operational state will continue to reflect the
existence of that peer until the peer&apos;s resources are released,
including closing the peer&apos;s connection.  During this period, the
current data values will continue to be visible in &lt;operational&gt;,
with the &quot;origin&quot; attribute set to indicate the
origin of the original data.
    </t>
        <figure>
            <artwork><![CDATA[
  <bgp xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin"
       or:origin="or:intended">
    <local-as>64501</local-as>
    <peer-as>64502</peer-as>
    <peer>
      <name>2001:db8::2:3</name>
      <local-as or:origin="or:default">64501</local-as>
      <peer-as or:origin="or:default">64502</peer-as>
      <local-port or:origin="or:system">60794</local-port>
      <remote-port or:origin="or:default">179</remote-port>
      <state>closing</state>
    </peer>
  </bgp>
            ]]></artwork>
        </figure>
    <t>
Once resources are released and the connection is closed, the
peer&apos;s data is removed from &lt;operational&gt;.
    </t>
</section>
</section>

<section title="Interface Example" anchor="interface-example">
    <t>
In this section, we will use this simple interface data model:
    </t>
        <figure>
            <artwork><![CDATA[
  container interfaces {
    list interface {
      key name;
      leaf name {
        type string;
      }
      leaf description {
        type string;
      }
      leaf mtu {
        type uint16;
      }
      leaf-list ip-address {
        type inet:ip-address;
      }
    }
  }
            ]]></artwork>
        </figure>

<section title="Pre-provisioned Interfaces" anchor="pre-provisioned-interfaces">
    <t>
One common issue in networking devices is the support of Field
Replaceable Units (FRUs) that can be inserted and removed from the
device without requiring a reboot or interfering with normal
operation.  These FRUs are typically interface cards, and the devices
support pre-provisioning of these interfaces.
    </t>
    <t>
If a client creates an interface &quot;et&#8209;0/0/0&quot; but the interface
does not physically exist at this point, then &lt;intended&gt; might contain
the following:
    </t>
        <figure>
            <artwork><![CDATA[
  <interfaces>
    <interface>
      <name>et-0/0/0</name>
      <description>Test interface</description>
    </interface>
  </interfaces>
            ]]></artwork>
        </figure>
    <t>
Since the interface does not exist, this data does not appear in
&lt;operational&gt;.
    </t>
    <t>
When a FRU containing this interface is inserted, the system will
detect it and process the associated configuration.  &lt;operational&gt;
will contain the data from &lt;intended&gt;, as well as nodes
added by the system, such as the current value of the interface&apos;s
MTU.
    </t>
        <figure>
            <artwork><![CDATA[
  <interfaces xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin"
              or:origin="or:intended">
    <interface>
      <name>et-0/0/0</name>
      <description>Test interface</description>
      <mtu or:origin="or:system">1500</mtu>
    </interface>
  </interfaces>
            ]]></artwork>
        </figure>
    <t>
If the FRU is removed, the interface data is removed from &lt;operational&gt;.
    </t>
</section>

<section title="System-Provided Interface" anchor="system-provided-interface">
    <t>
Imagine that the system provides a loopback interface (named &quot;lo0&quot;)
with a default IPv4 address of &quot;127.0.0.1&quot; and a default
IPv6 address of &quot;::1&quot;. The system will only provide
configuration for this interface if there is no data for it
in &lt;intended&gt;.
    </t>
    <t>
When no configuration for &quot;lo0&quot; appears in &lt;intended&gt;,
&lt;operational&gt; will show the system-provided data:
    </t>
        <figure>
            <artwork><![CDATA[
  <interfaces xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin"
              or:origin="or:intended">
    <interface or:origin="or:system">
      <name>lo0</name>
      <ip-address>127.0.0.1</ip-address>
      <ip-address>::1</ip-address>
    </interface>
  </interfaces>
            ]]></artwork>
        </figure>
    <t>
When configuration for &quot;lo0&quot; does appear in &lt;intended&gt;,
&lt;operational&gt; will show that data with the origin set to
&quot;intended&quot;. If the &quot;ip&#8209;address&quot; is not provided,
then the system-provided value will appear as follows:
    </t>
        <figure>
            <artwork><![CDATA[
  <interfaces xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin"
              or:origin="or:intended">
    <interface>
      <name>lo0</name>
      <description>loopback</description>
      <ip-address or:origin="or:system">127.0.0.1</ip-address>
      <ip-address>::1</ip-address>
    </interface>
  </interfaces>
            ]]></artwork>
        </figure>
</section>
</section>
</section>

<section title="Acknowledgments" anchor="acknowledgments" numbered="no">
    <t>
This document grew out of many discussions that took place since 2010.
Several documents (<xref target="NETMOD-Operational"/>
<xref target="With-config-state"/> <xref target="OpState-Reqs"/>
<xref target="OpState-Enhance"/> <xref target="OpState-Modeling"/>, as well as
<xref target="RFC6244"/>), touched on some of the problems of the original
datastore model.  The following people were authors of these
works in progress or were otherwise actively involved in the discussions
that led to this document:
    </t>
<t>
 <list style="symbols">
 <t>
Lou Berger, LabN Consulting, L.L.C., &lt;lberger@labn.net&gt;
 </t>
 <t>
Andy Bierman, YumaWorks, &lt;andy@yumaworks.com&gt;
 </t>
 <t>
Marcus Hines, Google, &lt;hines@google.com&gt;
 </t>
 <t>
Christian Hopps, Deutsche Telekom, &lt;chopps@chopps.org&gt;
 </t>
 <t>
Balazs Lengyel, Ericsson, &lt;balazs.lengyel@ericsson.com&gt;
 </t>
 <t>
Ladislav Lhotka, CZ.NIC, &lt;lhotka@nic.cz&gt;
 </t>
 <t>
Acee Lindem, Cisco Systems, &lt;acee@cisco.com&gt;
 </t>
 <t>
Thomas Nadeau, Brocade Networks, &lt;tnadeau@lucidvision.com&gt;
 </t>
 <t>
Tom Petch, Engineering Networks Ltd, &lt;ietfc@btconnect.com&gt;
 </t>
 <t>
Anees Shaikh, Google, &lt;aashaikh@google.com&gt;
 </t>
 <t>
Rob Shakir, Google, &lt;robjs@google.com&gt;
 </t>
 <t>
Jason Sterne, Nokia, &lt;jason.sterne@nokia.com&gt;
 </t>
 </list>
</t>
    <t>
Juergen Schoenwaelder was partly funded by Flamingo, a Network of
Excellence project (ICT-318488) supported by the European Commission
under its Seventh Framework Programme.
    </t>
</section>

</back>
</rfc>
