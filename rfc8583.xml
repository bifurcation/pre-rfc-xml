<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY RFC2119 SYSTEM "https://www.rfc-editor.org/refs/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC8174 SYSTEM "https://www.rfc-editor.org/refs/bibxml/reference.RFC.8174.xml">
<!ENTITY RFC2629 SYSTEM "https://www.rfc-editor.org/refs/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC3552 SYSTEM "https://www.rfc-editor.org/refs/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC4006 SYSTEM "https://www.rfc-editor.org/refs/bibxml/reference.RFC.4006.xml">
<!ENTITY RFC6733 SYSTEM "https://www.rfc-editor.org/refs/bibxml/reference.RFC.6733.xml">
<!ENTITY RFC7068 SYSTEM "https://www.rfc-editor.org/refs/bibxml/reference.RFC.7068.xml">
<!ENTITY RFC2782 SYSTEM "https://www.rfc-editor.org/refs/bibxml/reference.RFC.2782.xml">
<!ENTITY RFC7683 SYSTEM "https://www.rfc-editor.org/refs/bibxml/reference.RFC.7683.xml">

]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc number="8583" category="std" submissionType="IETF" consensus="yes" ipr="trust200902">

  <front>

    <title abbrev="Diameter Load">Diameter Load Information Conveyance</title>

    <author fullname="Ben Campbell" initials="B."
     surname="Campbell">
      <organization>Oracle</organization>
      <address>
        <postal>
          <street>7460 Warren Parkway, Suite 300</street>

          <city>Frisco</city>
          <region>Texas</region>
          <code>75034</code>
          <country>United States of America</country>
        </postal>
        <phone></phone>
        <email>ben@nostrum.com</email>

      </address>
    </author>
    <author role="editor" initials="S" surname="Donovan" fullname="Steve Donovan">
      <organization>Oracle</organization>
      <address>
        <postal>
          <street>7460 Warren Parkway # 300</street>
          <city>Frisco</city>
          <region>Texas</region>
          <code>75034</code>
          <country>United States of America</country>
        </postal>
        <email>srdonovan@usdonovans.com</email>
      </address>
    </author>
	<author fullname="Jean-Jacques Trottin" initials="JJ"
		surname="Trottin">
		<organization>Nokia</organization>
		<address>
      <postal>
        <street>Route de Villejust</street>
        <region>91620 Nozay</region>
        <country>France</country>
      </postal>
			<email>jean-jacques.trottin@nokia.com</email>
		</address>
		</author>
    <date month="August" year="2019" />

    <area>General</area>
    <workgroup>Internet Engineering Task Force</workgroup>

    <keyword>Diameter, load</keyword>

    <abstract>
      <t>

        RFC 7068 describes requirements for Overload Control in Diameter. This
 	   includes a requirement to allow Diameter nodes to send "load" information,
	   even when the node is not overloaded. The base solution defined in
	   RFC 7683
 	   (Diameter Overload Information Conveyance (DOIC)) describes
       a mechanism meeting most of the requirements but does
	   not currently include the ability to send load information.
     This document defines
     a mechanism for the conveying of Diameter load information.
      </t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro" title="Introduction">
		<t>
      <xref target="RFC7068"/> describes requirements for Overload Control
  		in <xref target="RFC6733">Diameter</xref>.
      The DIME Working Group has finished the Diameter Overload Information Conveyance
  		(DOIC) mechanism <xref target="RFC7683"/>.
      As currently specified, DOIC fulfills some, but not all, of the
  		requirements.
    </t>
		<t>
      In particular, DOIC does not fulfill Req 23 and Req 24:
    </t>
    <t><list>
      <t>
        REQ 23: The solution MUST provide sufficient information to enable a
        load-balancing node to divert messages that are rejected or otherwise
        throttled by an overloaded upstream node to other upstream nodes that
        are the most likely to have sufficient capacity to process them.
      </t>
      <t>
        REQ 24: The solution MUST provide a mechanism for indicating load levels,
        even when not in an overload condition, to assist nodes in making decisions
        to prevent overload conditions from occurring.
      </t>
    </list></t>
		<t>
      There are several other requirements in <xref target="RFC7068"/> that
      mention both overload and load information that are only partially fulfilled by DOIC.
    </t>
		<t>
      The DIME Working Group explicitly chose not to fulfill these
   requirements when publishing DOIC <xref target="RFC7683"/> due to several reasons.
    A principal reason was that the working group did not agree on a general
    approach for conveying load information. It chose to progress the rest of
    DOIC and deferred load information conveyance to a DOIC extension or a separate mechanism.
    </t>
		<t>
      This document defines a mechanism that addresses the load-related requirements from RFC 7068.
    </t>
  </section>
  <section title="Terminology and Abbreviations" anchor="abbrev">

    <t>
     <list style="hanging">
       <t hangText="AVP">
       <vspace blankLines="1"/>
       Attribute-Value Pair
       </t>
       <t hangText="DOIC">
       <vspace blankLines="1"/>
       Diameter Overload Information Conveyance <xref target="RFC7683"/>
       </t>
       <t hangText="Load">
         <vspace blankLines="1"/>
         The relative usage of the Diameter message processing capacity of
         a Diameter node.  A low load level indicates that the
         Diameter node is underutilized.  A high load level indicates that the node is
         closer to being fully utilized.
       </t>
       <t hangText="Offered Load">
         <vspace blankLines="1"/>
         The actual traffic sent to the reporting node after overload abatement
         and routing decisions are made.
       </t>
       <t hangText="Reporting Node">
         <vspace blankLines="1"/>
         A DOIC node that sends a DOIC Overload report in a Diameter answer message.
       </t>
       <t hangText="Reacting Node">
         <vspace blankLines="1"/>
         A DOIC node that receives and acts on a DOIC Overload report.
       </t>
       <t hangText="Routing Information">
         <vspace blankLines="1"/>
         Routing Information referred to in this document can include
         the Routing and Peer tables defined in RFC  6733.  It can also include other
         implementation-specific tables used to store load information.  This document
         does not define the structure of such tables.
       </t>
     </list>
    </t>
  </section>
  <section title="Conventions Used in This Document">
        <t>
    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
    "MAY", and "OPTIONAL" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/>
    when, and only when, they appear in all capitals, as shown here.
        </t>

  </section>

  <section anchor="background" title="Background">
  	<section anchor="load-overload" title="Differences between Load and Overload Information">
  		<t>
        Previous discussions of how to solve the load-related requirements in
        <xref target="RFC7068"/> have shown that people did not have an agreed-upon concept of
        how "load" information differs from "overload" information. While the two concepts are highly
        interrelated,
        there are two primary differences. First, a
        Diameter node always has a load.  At any given time, that load may be effectively
        zero, effectively fully loaded, or somewhere in between.
  			In contrast, overload is an exceptional condition. A node only has Overload
        information when it is in an overloaded state. Furthermore, the relationship between
        a node's load level and overload state at any given time may be vague.
        For example, a node may normally operate at a "fully loaded" level, but still not
        be considered overloaded. Another node may declare itself to be "overloaded" even though
  			it might not be fully "loaded".
  		</t>

  		<t>
         Second, Overload information, in the form of a <xref target="RFC7683"> DOIC
  	 Overload Report (OLR) </xref> indicates an explicit request for action on the part of the
  	 reacting node; the OLR requests that the reacting
	 node reduce the offered load, the actual traffic sent to the reporting node after overload abatement and routing
         decisions are made, by an indicated amount (by default) or as prescribed by the selected abatement algorithm.
         Effectively, DOIC provides a contract between the reporting node and the reacting node.
      </t>
  		<t>
        In contrast, load is informational; load information can be considered a hint
  			to the recipient node. That node may use the load information for load-balancing purposes,
  			as an input to certain overload abatement techniques, to make inferences about the likelihood
  			that the sending node becomes overloaded in the immediate future, or for other purposes.
  		</t>
  		<t>
        None of this prevents a Diameter node from deciding to reduce the offered load based on
  			load information. The fundamental difference is that an Overload report requires
  			the reduction of the offered load.  It is also reasonable for a Diameter node to decide to increase the
        offered load based on load information.
  		 </t>
  	</section>
  	<section anchor="use" title="How is Load Information Used?">
  	  <t>
        <xref target="RFC7068"/> contemplates two primary uses for load information.
  			Req 23 discusses how load information might be used when performing diversion
  			as an overload abatement technique as described in <xref target="RFC7683"/>.
  			When a reacting node diverts traffic away from an overloaded node, it needs load information
  			for the other candidates for that traffic in order to
			effectively load-balance the diverted load between
			potential candidates. Otherwise, diversion has a greater potential to drive other nodes into overload.
  		</t>
  		<t>
  			Req 24 discusses how Diameter load information might be used when no overload condition currently
  			exists. Diameter nodes can use the load information to make decisions to try to avoid overload
  			conditions in the first place. Normal load-balancing falls into this category, but
        the Diameter node can take other proactive steps as well.
  		</t>
  		<t>
  			If the loaded nodes are Diameter servers (or clients in the case of server-to-client
        transactions),
        both of these uses of load information should
        be accomplished by a Diameter node that performs server selection (selection
        of the Diameter endpoint to which the request is to be routed for processing).
        Typically, server selection is performed
  			by a node (a client or an agent) that is an immediate peer of the server.
        However, there are scenarios (see <xref target="scenarios" />)
        where a client or proxy that is not
        the immediate peer to the selected servers performs server selection.  In this case,
        the client or proxy enforces the server selection by inserting a Destination-Host AVP.
  		</t>
      <t>
        As an example, a Diameter node (e.g., client) can use a redirect agent to get
        candidate destination
        host addresses.  The redirect agent might return several destination host addresses
        from which the Diameter node selects one.  The Diameter node can use load
        information received from these hosts to make the selection.
      </t>
      <t>
        Just as load information can be used as part of server selection, it can also be used
        as input to the selection of the next-hop peer to which a request is to be routed.
      </t>
      <t>
        It should be noted that a Diameter node will need to process both load reports and Overload
        reports from the same Diameter node.   The reacting node for the overload
        report always has the responsibility to reduce the amount of Diameter traffic sent to the
        overloaded node.  If, or how, the reacting node uses load information to achieve this is
        left as an implementation decision.
      </t>
  	</section>
  </section>
  <section anchor="overview" title="Solution Overview">
    <t>
      The mechanism defined here for the conveyance of load information is similar
      in some ways to the mechanism defined for DOIC and is different in other ways.
    </t>
    <t>
      As with DOIC, load information is conveyed by piggybacking the Load AVPs on existing
      Diameter applications.
    </t>
    <t>
      There are two primary differences.  First, there is no capability negotiation
      process for load.  The sender of the load information is sending it with the expectation
      that any supporting nodes will use it when making routing decisions.  If there are
      no nodes that support the Load mechanism, then the load information is ignored.
    </t>
    <t>
      The second big difference between DOIC and Load is visibility of the DOIC or load
      information within a Diameter network.  DOIC information is sent
      end-to-end resulting in the ability of all nodes in the path of the answer message
      that carries the OC-OLR AVP to act on the information,
      although only one node actually consumes and reacts to the report.
      The DOIC Overload reports remain in the message all the way from the
      reporting node to the node that is the target for the answer message.
    </t>
    <t>
      For the Load mechanism, there are two types of load reports and only the
      first one is transmitted end-to-end.
    </t>
    <t>
      The first type of load report is a host-load report, which contains the load of the endpoint
      sending the answer message.  This load report is carried end-to-end
      to enable any nodes that make server selection decisions to use the load status
      of the sending endpoint as part of the server selection decision.
      Unlike with DOIC, more than one node may make use of the load information received.
    </t>
    <t>
      The second type of load report is a peer-load report.  This report is used by Diameter nodes
      as part of the logic to select the next-hop Diameter node and, as such, does not have
      significance beyond the peer node.  load reports of type "PEER" are removed by the first
      supporting Diameter node to receive the report.
    </t>
    <t>
      Because load reports can traverse Diameter nodes that do not support the Load mechanism,
      it is necessary to include the identity of the node to which the load report applies as
      part of the load report. This allows for a Diameter node to verify that a load report
      applies to its peer or that it should be ignored.
    </t>
    <t>
      The load report includes a value indicating the relative load of the sending node,
      specified in a manner consistent with that defined for DNS SRV <xref target="RFC2782"/>.
    </t>
    <t>
      The goal is to make it possible to use both the Load values received as a part of the Diameter Load
      mechanism and weight values received as a result of a DNS SRV query.  As a result, the
      Diameter Load value has a range of 0-65535.  This value and DNS SRV weight values are
      then used in a distribution algorithm similar to that specified in <xref target="RFC2782"/>.
    </t>
    <t>
      The DNS SRV distribution algorithm results in more messages being sent to a node with a
      higher weight value.  As a result, a higher Diameter Load value indicates a LOWER
      load on the sending node.  A node that is heavily loaded sends a lower Diameter
      Load value.  Stated another way, a node that has zero load would have a Load value of 65535.
      A node that is 100% loaded would have a Load value of 0.
    </t>
    <t>
      The distribution algorithm used by Diameter nodes supporting the Diameter Load mechanism is
      an implementation decision, but it needs to result in similar behavior to the algorithm
      described for the use of weight values specified in <xref target="RFC2782"/>.
    </t>
    <t>
      The method for calculating the Load value included in the load report is also left as
      an implementation decision.
    </t>
    <t>
      The frequency for sending of load reports is also left as an implementation decision.
      The sending node might choose to send load reports in all messages or it might
      choose to only send load reports when the Load value has changed by some
      implementation-specific amount. The important consideration is that all
      nodes needing the load information have a sufficiently accurate view of
      the node's load.
    </t>
    <section anchor="theory" title="Theory of Operation">
      <t>
        This section outlines how the Diameter Load mechanism is expected to work.
      </t>
      <t>
        For this discussion, assume the following Diameter network configuration:
      </t>
      <figure title="Example Diameter Network" anchor="example-net">
      <artwork><![CDATA[
        ---A1---A3----S[1], S[2]...S[p]
       /   | \ /
      C    |  x
       \   | / \
        ---A2---A4----S[p+1], S[p+2] ...S[n]
      ]]>
      </artwork>
      </figure>
      <t>
        Note that in this diagram, S[1] and S[2] through S[p] are peers to A3.
        S[p+1] and S[p+2] through S[n] are peers to A4.
      </t>
      <t>
        Also assume that the request for a Diameter transaction takes the following path:
      </t>
      <figure title="Request Message Path" anchor="example-req">
      <artwork><![CDATA[
      C     A1     A4     S[n]
      |      |      |      |
      |----->|----->|----->|
      xxR     xxR    xxR

      ]]>
      </artwork>
      </figure>
      <t>
        When sending the answer message, an endpoint node that supports the Diameter Load
        mechanism includes its own load information in the answer message.  Because it is
        a Diameter endpoint, it includes a host-load report.
      </t>
      <figure title="Answer Message from S[n]" anchor="example-a1">
      <artwork><![CDATA[
      C     A1     A4     S[n]
      |      |      |      |
      |      |      |<-----|
      |      |       xxA(Load type:HOST, source:S[n])
      |      |      |      |
      ]]>
      </artwork>
      </figure>
      <t>
        If Agent A4 supports the Load mechanism, then
        A4's actions depend on whether A4 is responsible for
        doing server selection.  If A4 is not doing server selection,
        then A4 ignores the host-load report.  If
        A4 is responsible for doing server selection, then it stores the load information for
        S[n] in its routing information for the handling of subsequent request messages.  In both
        cases, A4 leaves the host-load report in the message.
      </t>
      <t><list><t>
        Note: If A4 does not support the Load mechanism, then it will relay the answer message
        without doing any processing on the load information.  In this case, the load information
        AVPs will
        be relayed without change.
      </t></list></t>
      <t>
        A4 then calculates its own load information and inserts load information AVPs
        of type "PEER" in the message
        before sending the message to A1.
      </t>
      <figure title="Answer Message from A4" anchor="example-a2">
      <artwork><![CDATA[
      C     A1     A4     S[n]
      |      |      |      |
      |      |<-----|      |
      |       xxA(Load type:PEER, source:A4)
      |       xxA(Load type:HOST, source:S[n])
      |      |      |      |
      ]]>
      </artwork>
      </figure>
      <t>
        If A1 supports the Load mechanism, then it
        processes each of the load reports it receives separately.
      </t>
      <t>
        For the peer-load report, A1 first determines if the source of the report indicated
        in the load report matches the DiameterIdentity of the Diameter node from which the
        request was received.  If the identities do not match, then the peer-load report
        is discarded.  If the identities match, then A1 saves the load information
        in its routing information for routing of subsequent request messages.  In both cases,
        A1 strips the peer-load report from the message.
      </t>
      <t>
        For the host-load report, A1's actions depend on whether A1 is responsible for
        doing server selection.  If A1 is not doing server selection,
        then A1 ignores the host-load report.  If
        A1 is responsible for doing server selection, then it stores the load information for
        S[n] in its routing information for the handling of subsequent request messages.  In both
        cases, A1 leaves the host-load report in the message.
      </t>
      <t>
        A1 then calculates its own load information and inserts load information AVPs of type
        "PEER" in the message
        before sending the message to C:
      </t>
      <figure title="Answer Message from A1" anchor="example-a3">
      <artwork><![CDATA[
      C     A1     A4     S[n]
      |      |      |      |
      |<-----|      |      |
       xxA(Load type:PEER, source:A1)
       xxA(Load type:HOST, source:S[n])
      ]]>
      </artwork>
      </figure>
      <t>
        As with A1, C processes each load report separately.
      </t>
      <t>
        For the peer-load report,
        C follows the same procedure as A1 for determining if the load report was received from the
        peer from which the report was sent.  When finding it does, C stores the load
        information for use when making future routing decisions.
      </t>
      <t>
        For the host-load report, C saves the load information only if it is
        responsible for doing server selection.
      </t>
      <t>
        The load information received by all nodes is then used for routing of subsequent
        request messages.
      </t>
    </section>
  </section>
  <section anchor="procedures" title="Load-Mechanism Procedures">
    <t>
      This section defines the normative behaviors for the Load mechanism.
    </t>
    <section anchor="reporting" title="Reporting-Node Behavior">
      <t>
        This section defines the procedures of Diameter reporting nodes that generate
        load reports.
      </t>

      <section anchor="ep-report" title="Endpoint Reporting-Node Behavior">
        <t>
          A Diameter endpoint that supports the Diameter Load mechanism MUST
          include a load report of type "HOST" in sufficient answer messages
          to ensure that all consumers of the load information receive timely updates.
        </t>
        <t>
          The Diameter endpoint MUST include its own DiameterIdentity in the SourceID
          AVP included in the Load AVP.
        </t>
        <t>
          The Diameter endpoint MUST include a Load-Type AVP of type "HOST" in the Load AVP.
        </t>
        <t>
          The Diameter endpoint MUST include its Load value in the Load-Value AVP in the Load AVP.
        </t>
        <t>
          The Load value should be calculated in a way that reflects the available load
          independently of the weight of each server in order to accurately compare Load
          values from different nodes. Any specific Load value needs to identify the same
          amount of available capacity regardless of the Diameter node that calculates the value.
        </t>
        <t>
          The mechanism used to calculate the Load value that fulfills this  requirement is an
          implementation decision.
        </t>
        <t>
          The frequency of sending load reports is an implementation decision.
        </t>
        <t>
          For instance, if the only consumer of the load reports is the endpoint's peer,
          then the endpoint can choose to only include a load report when the load of
          the endpoint has changed by a meaningful percentage.  If there are
          consumers of the endpoint load report other than the endpoint's peer (this will
          be the case if other nodes are responsible for server selection), then the endpoint
          might choose to include load reports in all answer messages as a way of ensuring that
          all nodes doing server selection get accurate load information.
        </t>
      </section>
      <section anchor="ag-report" title="Agent Reporting-Node Behavior">
        <t>
          A Diameter Agent that supports the Diameter Load mechanism MUST include
          a peer-load report in sufficient answer messages
          to ensure that all users of the load information receive timely updates.
        </t>
        <t>
          The Diameter Agent MUST include its own DiameterIdentity in the SourceID
          AVP included in the Load AVP.
        </t>
        <t>
          The Diameter Agent MUST include a Load-Type AVP of type "PEER" in the Load AVP.
        </t>
        <t>
          The Diameter Agent MUST include its Load value in the Load-Value AVP in the Load AVP.
        </t>
        <t>
          The Load value should be calculated in a way that reflects the available load
          independently of the weight of each agent in order to accurately compare Load
          values from different nodes. Any specific Load value needs to identify the same
          amount of available capacity regardless of the Diameter node that calculates the value.
        </t>
        <t>
          The mechanism used to calculate the Load value that fulfills this  requirement is an
          implementation decision.
        </t>
        <t>
          The frequency of sending load reports is an implementation decision.
        </t>
        <t><list><t>
          Note: In the case of load reports of type "PEER", it is only necessary to include load reports
          when the Load value has changed by some meaningful value, as long as the agent ensures
          that all peers receive the report.  It is also acceptable
          to include the load report in every answer message handled by the Diameter Agent.
        </t></list></t>
      </section>
    </section>
    <section anchor="receiving" title="Reacting-Node Behavior">
      <t>
        This section defines the behavior of Diameter nodes processing load reports.
      </t>
      <t>
          A Diameter node that supports the Diameter Load mechanism MUST be prepared to process load reports of
          type "HOST" and of type "PEER", as indicated in the Load-Type
          AVP included in the Load AVP received in the same answer message or from
          multiple answer messages.
      </t>
        <t><list><t>
Note: The node needs to be able to handle messages with no Load
reports, messages with just a peer-load report, messages with just
a host-load report, and messages with both types of load reports.
        </t></list></t>
      <t>
          If the Diameter node is not responsible for doing server selection, then
          it SHOULD ignore load reports of type "HOST".
      </t>
      <t>
          If the Diameter node is responsible for doing server selection, then
          it SHOULD save the Load value included in the Load-Value AVP included in the Load
          AVP of type "HOST" in its routing information.
      </t>
      <t>
          If the Diameter node receives a load report of type "PEER", then the
          Diameter node MUST determine if the load report was inserted into the
          answer message by the peer from which the message was received.  This is
          achieved by comparing the DiameterIdentity associated with the connection from
          which the message was received with the DiameterIdentity included in the SourceID
          AVP in the load report.
      </t>
      <t>
          If the Diameter node determines that the load report of type "PEER" was
          not received from the peer that sent or relayed the answer message, then the
          node MUST ignore the load report.
      </t>
      <t>
          If the Diameter node determines that the load report of type "PEER" was received
          from the peer that sent or relayed the answer message, then the node SHOULD
          save the load information in its routing information.
      </t>
      <t>
        In all cases, a Diameter Agent MUST strip all load reports of type "PEER"
        received in answer messages.
      </t>
      <t><list><t>
        Note: This ensures that there will be precisely one load report of
        type "PEER", e.g., that of the Diameter node sending the message, in any answer
        messages sent by the Diameter Agent.
      </t></list></t>
      <t>
          How a Diameter node uses load information for making routing decisions is
          an implementation decision.  However, the distribution algorithm MUST result
          in similar behavior as the algorithm described for the use of weight values
          in <xref target="RFC2782"/>.
      </t>
    </section>
    <section anchor="extend" title="Extensibility">
      <t>
        The Load mechanism can be extended to include additional information
        in the load reports.
      </t>
      <t>
        Any extension may define new AVPs for use in load reports.
        These new AVPs SHOULD be defined to be
        extensions to the Load AVPs defined in this document.
      </t>
      <t>
        Grouped AVP extension mechanisms defined by <xref target="RFC6733"/> apply.  This
        allows, for example, defining a new feature that is mandatory to be
        understood even when piggybacked on an existing application.
      </t>
      <t>
        As with any Diameter specification, <xref target="RFC6733"/> requires all new AVPs to
        be registered with IANA.  See <xref target="iana"/> for the required procedures.
      </t>
    </section>
    <section title="Addition and Removal of Nodes">
      <t>
        When a Diameter node is added, the new node will start by advertising its load.
        Downstream nodes will need to factor the new load information into
        load-balancing decisions.  The downstream nodes can attempt to ensure
        a smooth increase of the traffic to the new node, avoiding an immediate spike
        of traffic to that new node.  The method for the handling of such a smooth increase is implementation-specific, but it can rely on the evolution of load information received from the new node
        and from the other nodes.
      </t>
      <t>
        When removing a node in a controlled way (e.g., for maintenance purposes, so
        outside a failure case), it might be appropriate to progressively reduce the traffic
        to this node by routing traffic to other nodes.  Simple load
        information (load percentage) would not be sufficient.  The method for
	the handling of the node
        removal is implementation-specific, but it can rely on the evolution of the load
        information received from the node to be removed.
      </t>
    </section>

  </section>
  <section anchor="avp" title="Attribute-Value Pairs">
    <t>
      The section defines the AVPs required for the Load mechanism.
    </t>
    <section anchor="loadAVP" title="Load AVP">
      <t>
        The Load AVP (AVP code 650) is of type Grouped and is used to convey
        load information between Diameter nodes.
      </t>
      <figure>
<artwork><![CDATA[
 Load ::= < AVP Header: 650 >
          [ Load-Type ]
          [ Load-Value ]
          [ SourceID ]
        * [ AVP ]
]]>
        </artwork>
      </figure>

    </section>
    <section anchor="loadtypeAVP" title="Load-Type AVP">
      <t>
        The Load-Type AVP (AVP code 651) is of type Enumerated.  It is used
        to convey the type of Diameter node that sent the load information.
        The following values are defined:
      </t>
      <t>
        <list style="hanging">
          <t hangText="HOST 0">
            The load report is for a host.
          </t>
          <t hangText="PEER 1">
            The load report is for a peer.
          </t>
        </list>
      </t>
    </section>
    <section anchor="loadvalueAVP" title="Load-Value AVP">
      <t>
        The Load-Value AVP (AVP code 652) is of type Unsigned64.  It is used
        to convey relative load information about the sender of the load report.
      </t>
      <t>
        The Load-Value AVP is specified in a manner similar to the weight value in
        DNS SRV (<xref target="RFC2782"/>).
      </t>
      <t>
        The Load value has a range of 0-65535.
      </t>
      <t>
        A higher value indicates a lower load on the sending node.  A lower value indicates
        that the sending node is heavily loaded.
      </t>
      <t><list><t>
        Stated another way, a node that has zero load would have a Load value of 65535.
        A node that is 100% loaded would have a Load value of 0.
      </t></list></t>
    </section>
    <section anchor="sourceidAVP" title="SourceID AVP">
      <t>
        The SourceID AVP is defined in <xref target="RFC8581"/>.
        It is used to identify the Diameter node that sent the load report.
      </t>
    </section>
    <section title="Attribute-Value Pair Flag Rules">
      <figure>
        <artwork><![CDATA[
                                                          +---------+
                                                          |AVP flag |
                                                          |rules    |
                                                          +----+----+
                         AVP   Section                    |    |MUST|
  Attribute Name         Code  Defined  Value Type        |MUST| NOT|
 +--------------------------------------------------------+----+----+
 |Load                   650   7.1      Grouped           |    | V  |
 +--------------------------------------------------------+----+----+
 |Load-Type              651   7.2      Enumerated        |    | V  |
 +--------------------------------------------------------+----+----+
 |Load-Value             652   7.3      Unsigned64        |    | V  |
 +------------------------------------------------------ -+----+----+
 |SourceID               649   7.4      DiameterIdentity  |    | V  |
 +--------------------------------------------------------+----+----+
]]>
        </artwork>
      </figure>
     <t>
      As described in the Diameter base protocol <xref target="RFC6733"/>,
      the M-bit usage for a given AVP in a given command may be defined
      by the application.
     </t>
    </section>

  </section>

	<section anchor="security" title="Security Considerations">
		<t>
			Load information may be sensitive information in some cases.
      Depending on the mechanism, an unauthorized recipient
			might be able to infer the topology of a Diameter network from load information.
      Load information might be useful in identifying targets for denial-of-service (DoS) attacks, where a node known to be already heavily loaded might
			be a tempting target. Load information might also be useful as feedback about
      the success of an ongoing DoS attack.
		</t>
    <t>
      Given that routing decisions are impacted by load information, there is potential
      for negative impacts on a Diameter network caused by erroneous or
      malicious load reports.  This includes the malicious changing of Load values
      by Diameter Agents.
    </t>
		<t>
      Any load information conveyance mechanism will need to allow operators to avoid
      sending load information to nodes that are not authorized to receive it.
      Since Diameter currently only offers
   authentication of nodes at the transport level and does not support end-to-end
   security mechanisms, any solution that
   sends load information to non-peer nodes requires a transitive-trust
   model.
		</t>
	</section>
	<section anchor="iana" title="IANA Considerations">
      <t>
   IANA has registered three new AVP codes in the "Authentication,
   Authorization, and Accounting (AAA) Parameters" registry; see Sections
<xref target="loadAVP" format="counter"/>,
<xref target="loadtypeAVP" format="counter"/>, and
<xref target="loadvalueAVP" format="counter"/>.
      </t>
	</section>

</middle>

  <back>

<references title="Normative References">
&RFC2782;
&RFC7683;
&RFC2119;
&RFC8174;
&RFC6733;

<!-- draft-ietf-dime-agent-overload-11 -->
<reference anchor="RFC8581" target="https://www.rfc-editor.org/info/rfc8581">
<front>
<title>Diameter Agent Overload and the Peer Overload Report</title>
<author initials='S' surname='Donovan' fullname='Steve Donovan'>
  <organization/>
</author>
<date month='August' year='2019'/>
</front>
<seriesInfo name="RFC" value="8581"/>
<seriesInfo name="DOI" value="10.17487/RFC8581"/>
</reference>


</references>
<references title="Informative References">
&RFC7068;
</references>


    <section anchor="scenarios" title="Topology Scenarios">
      <t>
        This section presents a number of Diameter topology scenarios and discusses
        how load information might be used in each scenario.
      </t>
    <section title="No Agent">
      <t>
        <xref target="simple-CS" /> shows a simple client-server scenario where a client picks
        from a set of candidate servers available for a particular realm and application. The client
        selects the server for a given transaction using the load information received from each server.
      </t>
  <figure title="Basic Client Server Scenario" anchor="simple-CS">
  <artwork><![CDATA[
    ------S1
   /
  C
   \
    ------S2
  ]]>
  </artwork>
  </figure>
      <t>
        <list>
          <t>
             If a node supports dynamic discovery, it will not obtain load information from the nodes
             with which it has no Diameter connection established. Nevertheless, it might take into
             account the load information from the other nodes to decide to add connections to new
             nodes with the dynamic discovery mechanism.
          </t>
        </list>
      </t>
      <t><list><t>
        Note: The use of dynamic connections needs to be considered.
      </t></list></t>
    </section>
    <section title="Single Agent">
          <t>
            <xref target="simple-agent" /> shows a client that sends requests to an agent. The agent selects
        the request destination from a set of candidate servers, using load information received from
        each server. The client does not need to receive load information since it does not select
        between multiple agents.
          </t>
  <figure title="Simple Agent Scenario" anchor="simple-agent">
  <artwork><![CDATA[
         ------S1
        /
  C----A
        \
         ------S2
            ]]>
  </artwork>
  </figure>
    </section>
    <section title="Multiple Agents">
      <t>
        <xref target="multi-agent" /> shows a client selecting between multiple agents and each agent
        selecting from multiple servers. The client selects an agent based on the load information
        received from each agent. Each agent selects a server based on the load information received
        from its servers.
      </t>
      <t>
        This scenario adds a complication that one set of servers may be more loaded than the other set. If,
        for example, S4 was the least loaded server, C would need to know to select agent A2 to reach S4.
        This might require C to receive load information from the servers as well as the agents.
        Alternatively, each agent might use the load of its servers as an input into calculating its
        own load, in effect aggregating upstream load.
      </t>
      <t>
        Similarly, if C sends a <xref target="RFC7683">host-routed request</xref>, it needs
        to know which agent can deliver requests to the selected server. Without
        some special, potentially proprietary, knowledge of the topology upstream of A1 and A2, C
        would select the agent based on the normal peer selection procedures for the realm and application, and
        perhaps consider the load information from A1 and A2. If C sends a request
        to A1 that contains a Destination-Host AVP with a value of S4,
        A1 will not be able to deliver the request.
      </t>
  <figure title="Multiple Agents and Servers" anchor="multi-agent">
  <artwork><![CDATA[
          -----S3
         /
    ---A1------S1
   /
  C
   \
    ---A2------S2
         \
          ---- S4
  ]]>
  </artwork>
  </figure>
    </section>
    <section title="Linked Agents">
      <t>
        <xref target="linked-agents" /> shows a scenario similar to that of
        <xref target="multi-agent" />,
        except that the agents are linked so that A1 can forward a
        request to A2, and vice-versa.
        Each agent could receive load information from the linked agent
        as well as its connected servers.
      </t>
      <t>
        This somewhat simplifies the complication from <xref target="multi-agent" />
        due to the fact
        that C does not necessarily need to choose a particular agent to reach a
        particular server.
        But, it creates a similar question of how, for example, A1 might know
        that S4 was less loaded than
        S1 or S3. Additionally, it creates the opportunity for sub-optimal
        request paths. For example,
        [C,A1,A2,S4] vs. [C,A2,S4].
      </t>
      <t>
        A likely application for linked agents is when each agent prefers to route only to
        directly connected servers and only
        forwards requests to another agent under exceptional circumstances. For example, A1 might
        not forward requests to A2 unless both S1 and S3 are overloaded. In this case, A1 might use the
        load information from S1 and S3 to select between those, and only consider the load information
        from A2 (and other connected agents) if it needs to divert requests to different agents.
      </t>
  <figure title="Linked Agents" anchor="linked-agents">
  <artwork><![CDATA[
           -----S3
          /
     ---A1------S1
   /    |
  C     |
   \    |
     ---A2------S2
          \
           ---- S4
  ]]>
  </artwork>
  </figure>
        <t>
          <xref target="linked-agents2"/> is a variant of <xref target="linked-agents"/>.  In this
          case, C1 sends all traffic through A1, and C2 sends all traffic through A2.  By default,
          A1 will load-balance traffic between S1 and S3, and A2 will load-balance traffic between
          S2 and S4.
        </t>
        <t>
          Now, if S1 and S3 are significantly more loaded than S2 and S4, A1 may route some C1
          traffic to A2. This is a non-optimal path, but it allows better load balancing
          between the servers. To achieve this, A1 needs to receive some load info
          from A2 about the S2/S4 load.
        </t>
  <figure title="Linked Agents" anchor="linked-agents2">
  <artwork><![CDATA[
           -----S3
          /
  C1----A1------S1
        |
        |
        |
  C2----A2------S2
          \
           ---- S4
  ]]>
  </artwork>
  </figure>
    </section>
    <section title="Shared Server Pools">
      <t><xref target="shared-server-pools" /> is similar to <xref target="linked-agents" />, except
      that instead of a link between agents, each agent is linked to all servers (The links to each set of servers
      should be interpreted as a link to each server. The links are not shown separately due to the limitations of
      ASCII art.).</t>
      <t>In this scenario, each agent can select among all of the servers based on the load information from the servers.
        The client need only be concerned with the load information of the agents.</t>
  <figure title="Shared Server Pools" anchor="shared-server-pools">
  <artwork>
    <![CDATA[
    ---A1---S[1], S[2]...S[p]
   /     \ /
  C       x
   \     / \
    ---A2---S[p+1], S[p+2] ...S[n]
  ]]>
  </artwork>
  </figure>
    </section>
    <section title="Agent Chains">
    <t>The scenario in <xref target="agent-chains" /> is similar to that of <xref target="multi-agent" />, except that
    instead of the client possibly needing to select an agent that can route requests to the least loaded server, in
    this case A1 and A2 need to make similar decisions when selecting between A3 or A4. As the former scenario, this
    could be mitigated if A3 and A4 aggregate upstream loads into the load information they report downstream.
    </t>
  <figure title="Agent Chains" anchor="agent-chains">
  <artwork><![CDATA[
    ---A1---A3----S[1], S[2]...S[p]
   /   | \ /
  C    |  x
   \   | / \
    ---A2---A4----S[p+1], S[p+2] ...S[n]
  ]]>
  </artwork>
  </figure>
    </section>
    <section title ="Fully-Meshed Layers">
      <t><xref target="full-mesh" /> extends the scenario in <xref target="shared-server-pools" /> by adding an extra layer of
      agents. But since each layer of nodes can reach any node in the next layer, each node only needs to consider the load
      of its next-hop peer.
      </t>
  <figure title="Full Mesh" anchor="full-mesh">
  <artwork><![CDATA[
    ---A1---A3---S[1], S[2]...S[p]
   /   | \ / |\ /
  C    |  x  | x
   \   | / \ |/ \
    ---A2---A4---S[p+1], S[p+2] ...S[n]
  ]]>
  </artwork>
  </figure>
    </section>
      <section title="Partitions">
      <t>A Diameter network with multiple servers is said to be "partitioned" when only a subset of available servers can serve
        a particular realm-routed request. For example, one group of servers may handle users whose names start with
        "A" through "M", and another group may handle "N" through "Z". </t>
       <t>In such a partitioned network, nodes cannot load balance requests across partitions since not all
        servers can handle the request. A client, or an intermediate agent,
	may still be able to load balance
        between servers inside a partition.</t>
      </section>
      <section title="Active-Standby Nodes">
        <t>The previous scenarios assume that traffic can be load balanced among all peers that are eligible to handle
          a request. That is, the peers operate in an "active-active" configuration. In an "active-standby" configuration,
          traffic would be load balanced among active peers. Requests would only be sent to peers in a "standby" state if the
          active peers became unavailable. For example, requests might be diverted to a stand-by peer if one or more
          active peers becomes overloaded.</t>
      </section>
    </section>
  </back>
</rfc>
