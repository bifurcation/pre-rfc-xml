<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 PUBLIC '' "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2434 PUBLIC '' "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2434.xml">
<!ENTITY RFC2460 PUBLIC '' "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2460.xml">
<!ENTITY RFC2464 PUBLIC '' "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2464.xml">
<!ENTITY RFC4291 PUBLIC '' "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4291.xml">
<!ENTITY RFC3756 PUBLIC '' "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3756.xml">
<!ENTITY RFC3819 PUBLIC '' "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3819.xml">
<!ENTITY RFC0768 PUBLIC '' "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0768.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc rfcedstyle="yes" ?>
<?rfc subcompact="no" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc compact="yes" ?>
<rfc  number="4944" category="std">
  <front>
    <title abbrev="IPv6 over IEEE 802.15.4">Transmission of IPv6 Packets over
    IEEE 802.15.4 Networks</title>

    <author fullname="Gabriel Montenegro" initials="G." surname="Montenegro">
      <organization>Microsoft Corporation</organization>

      <address>
        <email>gabriel.montenegro@microsoft.com</email>
      </address>
    </author>

    <author fullname="Nandakishore Kushalnagar" initials="N." surname="Kushalnagar">
      <organization>Intel Corp</organization>

      <address>
        <email>nandakishore.kushalnagar@intel.com</email>
      </address>
    </author>
    <author fullname="Jonathan W. Hui" initials="J." surname="Hui">
      <organization>Arch Rock Corp</organization>
      <address>
        <email>jhui@archrock.com</email>
      </address>
    </author>

    <author fullname="David E. Culler" initials="D." surname="Culler">
      <organization>Arch Rock Corp</organization>
      <address>
        <email>dculler@archrock.com</email>
      </address>
    </author>

    <date month="August" year="2007" />
<!-- [rfced] Please insert any keywords (beyond those that appear in the title) for use on http://www.rfc-editor.org/rfcsearch.html. -->
<keyword>example</keyword>

    <abstract>

<t>
     This document describes the frame format for transmission of IPv6 packets
     and the method of forming IPv6 link-local addresses and statelessly
     autoconfigured addresses on IEEE 802.15.4 networks.  Additional
     specifications include a simple header compression scheme using shared
     context and provisions for packet delivery in IEEE 802.15.4 meshes.
</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>The IEEE 802.15.4 standard <xref target="ieee802.15.4"></xref>
      targets low-power personal area networks. This document defines the
      frame format for transmission of IPv6 <xref target="RFC2460"></xref>
      packets as well as the formation of IPv6 link-local addresses and
      statelessly autoconfigured addresses on top of IEEE 802.15.4
      networks. Since IPv6 requires support of packet sizes much larger than
      the largest IEEE 802.15.4 frame size, an adaptation layer is defined.
      This document also defines mechanisms for header compression
      required to make IPv6 practical on IEEE 802.15.4 networks, and the
      provisions required for packet delivery in IEEE 802.15.4 meshes.
      However, a full specification of mesh routing (the
      specific protocol used, the interactions with neighbor discovery, etc)
      is out of the scope of this document.
      </t>

      <section title="Requirements Notation">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119"></xref>.</t>
      </section>
      
      <section title="Terms Used">
     <t>
	 <list style="hanging">

		<t hangText="AES:"> Advanced Encryption Scheme</t>
		<t hangText="CSMA/CA:"> Carrier Sense Multiple Access / Collision Avoidance</t>
		<t hangText="FFD:"> Full Function Device</t>
		<t hangText="GTS:"> Guaranteed Time Service</t>
		<t hangText="MTU:"> Maximum Transmission Unit</t>
		<t hangText="MAC:"> Media Access Control</t>
		<t hangText="PAN:"> Personal Area Network</t>
		<t hangText="RFD:"> Reduced Function Device</t>
		
	</list>
	<vspace blankLines='1' />
	</t>	
      </section>
      </section>

<section title="IEEE 802.15.4 Mode for IP">
<t>
	IEEE 802.15.4 defines four types of frames: beacon frames, MAC command
	frames, acknowledgement frames, and data frames.  IPv6 packets MUST be
	carried on data frames. Data frames may optionally request that they be
	acknowledged. In keeping with <xref target="RFC3819" />, it is
	recommended that IPv6 packets be carried in frames for which
	acknowledgements are requested so as to aid link-layer recovery. IEEE
	802.15.4 networks can either be nonbeacon-enabled or beacon-enabled
	<xref target="ieee802.15.4" />.  The latter is an optional mode in
	which devices are synchronized by a so-called coordinator's beacons.
	This allows the use of superframes within which a contention-free
	Guaranteed Time Service (GTS) is possible.  This document does not
	require that IEEE networks run in beacon-enabled mode. In
	nonbeacon-enabled networks, data frames (including those carrying IPv6
	packets) are sent via the contention-based channel access method of
	unslotted CSMA/CA. 
</t>
<t>
	In nonbeacon-enabled networks, beacons are not used for synchronization.
	However, they are still useful for link-layer device discovery to
	aid in association and disassociation events. This document
	recommends that beacons be configured so as to aid these functions.
	A further recommendation is for these events to be available at the
	IPv6 layer to aid in detecting network attachment, a problem being
	worked on at the IETF at the time of this writing.
</t>
<t>
	The specification
	allows for frames in which either the source or destination addresses
	(or both) are elided. The mechanisms defined in this document
	require that both source and destination addresses be included in
	the IEEE 802.15.4 frame header.  The source or destination PAN ID fields 
	may also be included. 
</t>
</section>

<section anchor="addressing-modes" title="Addressing Modes" >
<t>	
	IEEE 802.15.4 defines several addressing modes:
	it allows the use of either IEEE 64-bit extended addresses
	or (after an association event) 16-bit addresses unique within the PAN
	<xref target="ieee802.15.4"></xref>.
	This document supports both 64-bit extended addresses, and 16-bit
	short addresses. For use within 6LoWPANs, this document 
	imposes additional constraints 
	(beyond those imposed by IEEE 802.15.4) on the format
	of the 16-bit short addresses, as
	specified in <xref target="iana" />. 
	Short addresses
	being transient in nature, a word of caution is in order:
	since they are doled out
	by the PAN coordinator function during an association event, their validity
	and uniqueness is limited by the lifetime of that association. This can be cut short
	by the expiration of the association or simply by any mishap occurring to the PAN coordinator.
	Because of the scalability issues posed by such a centralized allocation and single point of 
	failure at the PAN coordinator, deployers should carefully weigh the tradeoffs (and implement 
	the necessary mechanisms) of growing such networks based on short addresses. Of course,
	IEEE 64-bit extended addresses may not suffer from these drawbacks, but still share the
	remaining scalability issues concerning routing, discovery, configuration, etc.
	
</t>
<t>
	This document assumes that a PAN maps to a specific IPv6 link.
	This complies with
	the recommendation that shared networks support link-layer subnet 
	<xref target="RFC3819" /> broadcast.
	Strictly speaking, it is multicast not broadcast that exists in IPv6.
	However, multicast is not supported natively in IEEE 802.15.4. Hence, 
	IPv6 level multicast packets MUST be carried as link-layer broadcast 
	frames in IEEE 802.15.4 networks. This MUST be done such that the
	broadcast frames are only heeded by devices within the specific
	PAN of the link in question. As per Section 7.5.6.2 in
	<xref target="ieee802.15.4"></xref>, this is accomplished
	as follows:
  
	<vspace blankLines='1' />

<list style="numbers">

	<t>
	A destination PAN identifier is included in the frame, and it MUST
	match the PAN ID of the link in question.
  
	<vspace blankLines='1' />
  </t>


          <t>
	  A short destination address is included in the frame, and it
	  MUST match the broadcast address (0xffff).
	  </t>
        </list>
</t>
<t>
	Additionally, support for mapping of IPv6 multicast addresses 
	per <xref target="multicast_mapping" /> MUST only be used
	in a mesh configuration. A full specification of such
	functionality is out of the scope of this document.
</t>
<t>
	As usual, hosts learn IPv6 prefixes via router advertisements as per 
	<xref target="RFC4861"/>. 
</t>
</section>

    <section title="Maximum Transmission Unit">
      <t>The MTU size for IPv6 packets over IEEE 802.15.4 is 1280 octets.
      However, a full IPv6 packet does not fit in an IEEE 802.15.4 frame. 802.15.4
      protocol data units have different sizes depending on how much overhead
      is present <xref target="ieee802.15.4"></xref>. Starting from a maximum
      physical layer packet size of 127 octets (aMaxPHYPacketSize) and a
      maximum frame overhead of 25 (aMaxFrameOverhead), the resultant maximum
      frame size at the media access control layer is 102 octets. Link-layer
      security imposes further overhead, which in the maximum case (21 octets
      of overhead in the AES-CCM-128 case, versus 9 and 13 for AES-CCM-32 and
      AES-CCM-64, respectively) leaves only 81 octets available. This is
      obviously far below the minimum IPv6 packet size of 1280 octets, and in
      keeping with Section 5 of the IPv6 specification <xref
      target="RFC2460"></xref>, a fragmention and reassembly adaptation layer
      must be provided at the layer below IP. Such a layer is defined below in
      <xref target="adaptation"></xref>.</t>

      <t>Furthermore, since the IPv6 header is 40 octets long, this leaves
      only 41 octets for upper-layer protocols, like UDP. The latter uses 8
      octets in the header which leaves only 33 octets for application data.
      Additionally, as pointed out above, there is a need for a fragmentation
      and reassembly layer, which will use even more octets.</t>

      <t>The above considerations lead to the following two observations:
	<vspace blankLines='1' />

<list style="numbers">

	<t>
	  The adaptation layer must be provided to comply with the IPv6
	  requirements of a minimum MTU. However, it is expected that (a) most
	  applications of IEEE 802.15.4 will not use such large packets, and
	  (b) small application payloads in conjunction with the proper header
	  compression will produce packets that fit within a single IEEE
	  802.15.4 frame. The justification for this adaptation layer is not
	  just for IPv6 compliance, as it is quite likely that 
	  the packet sizes produced by certain  application exchanges
	  (e.g., configuration or provisioning) may require a small number of
	  fragments. 
  
	<vspace blankLines='1' />
  </t>


          <t>Even though the above space calculation shows the worst-case
          scenario, it does point out the fact that header compression is
          compelling to the point of almost being unavoidable. Since we expect
          that most (if not all) applications of IP over IEEE 802.15.4 will
          make use of header compression, it is defined below in <xref
          target="hdrcompr"></xref>.</t>
        </list>
	</t>

    </section>

    <section anchor="adaptation" title="LoWPAN Adaptation Layer and Frame Format">
      <t>The encapsulation formats defined in this section
      (subsequently referred to as the "LoWPAN encapsulation") are the
      payload in the IEEE 802.15.4 MAC protocol data unit (PDU).  The
      LoWPAN payload (e.g., an IPv6 packet) follows this encapsulation
      header.</t>

      <t>All LoWPAN encapsulated datagrams transported over IEEE
      802.15.4 are prefixed by an encapsulation header stack.  Each
      header in the header stack contains a header type followed by zero
      or more header fields. Whereas in an IPv6 header the stack
      would contain, in the following order, addressing, hop-by-hop options,
      routing, fragmentation, destination options, and finally payload
      <xref target="RFC2460"></xref>; in a LoWPAN header, the analogous
      header sequence is mesh (L2) addressing, hop-by-hop options
      (including L2 broadcast/multicast), fragmentation, and finally
      payload. These examples show typical header stacks that may be
      used in a LoWPAN network.</t>
      
      <t>A LoWPAN encapsulated IPv6 datagram:</t>

      <figure><artwork>
   +---------------+-------------+---------+
   | IPv6 Dispatch | IPv6 Header | Payload |
   +---------------+-------------+---------+
      </artwork></figure>

      <t>A LoWPAN encapsulated LOWPAN_HC1 compressed IPv6
      datagram:</t>

      <figure><artwork>
   +--------------+------------+---------+
   | HC1 Dispatch | HC1 Header | Payload |
   +--------------+------------+---------+
      </artwork></figure>
      
      <t>A LoWPAN encapsulated LOWPAN_HC1 compressed IPv6 datagram
      that requires mesh addressing:</t>

      <figure><artwork>
   +-----------+-------------+--------------+------------+---------+
   | Mesh Type | Mesh Header | HC1 Dispatch | HC1 Header | Payload |
   +-----------+-------------+--------------+------------+---------+
      </artwork></figure>

      <t>A LoWPAN encapsulated LOWPAN_HC1 compressed IPv6 datagram
      that requires fragmentation:</t>

      <figure><artwork>
   +-----------+-------------+--------------+------------+---------+
   | Frag Type | Frag Header | HC1 Dispatch | HC1 Header | Payload |
   +-----------+-------------+--------------+------------+---------+
      </artwork></figure>

      <t>A LoWPAN encapsulated LOWPAN_HC1 compressed IPv6 datagram
      that requires both mesh addressing and fragmentation:</t>

      <figure><artwork>
   +-------+-------+-------+-------+---------+---------+---------+
   | M Typ | M Hdr | F Typ | F Hdr | HC1 Dsp | HC1 Hdr | Payload |
   +-------+-------+-------+-------+---------+---------+---------+
      </artwork></figure>

      <t>A LoWPAN encapsulated LOWPAN_HC1 compressed IPv6 datagram
      that requires both mesh addressing and a broadcast header to
      support mesh broadcast/multicast:</t>
      
      <figure><artwork>
   +-------+-------+-------+-------+---------+---------+---------+
   | M Typ | M Hdr | B Dsp | B Hdr | HC1 Dsp | HC1 Hdr | Payload |
   +-------+-------+-------+-------+---------+---------+---------+
      </artwork></figure>

      <t>
      When more than one LoWPAN header is used in the same packet,
      they MUST appear in the following order:

      <vspace blankLines='1'/>
      <list>
        <t>Mesh Addressing Header</t>
	<t>Broadcast Header</t>
	<t>Fragmentation Header</t>
      </list>
      </t>
            
      <t>All protocol datagrams (e.g., IPv6, compressed IPv6 headers,
      etc.) SHALL be preceded by one of the valid LoWPAN encapsulation
      headers, examples of which are given above. This permits uniform
      software treatment of datagrams without regard to the mode of
      their transmission.</t>
      
      <t>The definition of LoWPAN headers, other than mesh addressing and
      fragmentation, consists of the dispatch value, the
      definition of the header fields that follow, and their ordering
      constraints relative to all other headers.  Although the header
      stack structure provides a mechanism to address future demands
      on the LoWPAN adaptation layer, it is not intended to provided
      general purpose extensibility.  This format document specifies a
      small set of header types using the header stack for clarity,
      compactness, and orthogonality.</t>
      
      <section anchor="dispatch_hdr" title="Dispatch Type and Header">

      <t>The dispatch type is defined by a zero bit as the first bit
      and a one bit as the second bit. The dispatch type and header are
      shown here:</t>
      
      <figure anchor="dispatch_fig" title="Dispatch Type and Header">
        <artwork>
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 1| Dispatch  |  type-specific header
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


   Dispatch               6-bit selector.  Identifies the type of header
                          immediately following the Dispatch Header.

   type-specific header   A header determined by the Dispatch Header.
	</artwork>
      </figure>

      <t>The dispatch value may be treated as an unstructured
      namespace.  Only a few symbols are required to represent current
      LoWPAN functionality.  Although some additional savings could be
      achieved by encoding additional functionality into the dispatch
      byte, these measures would tend to constrain the ability to
      address future alternatives.</t>

      <figure anchor="dispatch_types" title="Dispatch Value Bit Pattern">
        <artwork>
       Pattern    Header Type
     +------------+-----------------------------------------------+
     | 00  xxxxxx | NALP       - Not a LoWPAN frame               |
     | 01  000001 | IPv6       - Uncompressed IPv6 Addresses      |
     | 01  000010 | LOWPAN_HC1 - LOWPAN_HC1 compressed IPv6       |
     |   ...      | reserved   - Reserved for future use          |
     | 01  010000 | LOWPAN_BC0 - LOWPAN_BC0 broadcast             | 
     |   ...      | reserved   - Reserved for future use          |
     | 01  111111 | ESC        - Additional Dispatch byte follows |
     +------------+-----------------------------------------------+
        </artwork>
      </figure>

      <t><list style="hanging"> 

      <t hangText="NALP:">Specifies that the following bits are not a
      part of the LoWPAN encapsulation, and any LoWPAN node that
      encounters a dispatch value of 00xxxxxx shall discard the
      packet. Other non-LoWPAN protocols that wish to coexist with
      LoWPAN nodes should include a byte matching this pattern
      immediately following the 802.15.4. header.<vspace
      blankLines='1'/> </t>
      
      <t hangText="IPv6:">Specifies that the following header is an
      uncompressed IPv6 header <xref target="RFC2460"></xref>.<vspace
      blankLines='1'/> </t>
      
      <t hangText="LOWPAN_HC1:">Specifies that the following header is
      a LOWPAN_HC1 compressed IPv6 header. This header format is
      defined in <xref target="lowpan_hc1"/>.<vspace blankLines='1'/>
      </t>
      
      <t hangText="LOWPAN_BC0:">Specifies that the following header is
      a LOWPAN_BC0 header for mesh broadcast/multicast support and is
      described in <xref target="lowpan_bc0"/>.<vspace blankLines='1'/></t>
      
      <t hangText="ESC:">Specifies that the following header is a
      single 8-bit field for the Dispatch value. It allows support for
      Dispatch values larger than 127.<vspace blankLines='1'/></t>
      
      </list></t>

      </section>

      <section anchor="mesh_hdr" title="Mesh Addressing Type and Header">

      <t>The mesh type is defined by a one bit and zero bit as the
      first two bits. The mesh type and header are shown here:</t>
      
      <figure anchor="mesh_fig" title="Mesh Addressing Type and Header">
        <artwork>
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 0|V|F|HopsLft| originator address, final address
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	</artwork>
      </figure>

<t>
      Field definitions are as follows:
      <vspace blankLines='1' />

      <list style="hanging">

        <t hangText="V:">This 1-bit field SHALL be zero if the
        Originator (or "Very first") Address is an IEEE extended 64-bit address
        (EUI-64), or 1 if it is a short 16-bit addresses.  <vspace
        blankLines='1' /></t>

	<t hangText="F:">This 1-bit field SHALL be zero if the Final
	Destination Address is an IEEE extended 64-bit address
	(EUI-64), or 1 if it is a short 16-bit addresses.  <vspace
	blankLines='1' /></t>

	<t hangText="Hops Left:">This 4-bit field SHALL be decremented
	by each forwarding node before sending this packet towards its
	next hop. The packet is not forwarded any further if Hops Left
	is decremented to zero.  The value 0xF is reserved and signifies
	an 8-bit Deep Hops Left field immediately following, and
	allows a source node to specify a hop limit greater than 14
	hops.<vspace blankLines='1' /></t>

	<t hangText="Originator Address:">This is the link-layer
	address of the Originator.<vspace blankLines='1' /></t>

	<t hangText="Final Destination Address:">This is the
	link-layer address of the Final Destination.</t>

      </list>
</t>

      <t>Note that the 'V' and 'F' bits allow for a mix of 16 and
      64-bit addresses.  This is useful at least to allow for mesh
      layer "broadcast", as 802.15.4 broadcast addresses are defined
      as 16-bit short addresses.</t>
      
      <t>A further discussion of frame delivery within a mesh is in
      <xref target="mesh"/>.</t>
      
      </section>

      <section anchor="frag_hdr" title="Fragmentation Type and Header">
      
      <t>If an entire payload (e.g., IPv6) datagram fits within a
      single 802.15.4 frame, it is unfragmented and the LoWPAN
      encapsulation should not contain a fragmentation header. If the
      datagram does not fit within a single IEEE 802.15.4 frame, it
      SHALL be broken into link fragments. 
      As the fragment offset can only express multiples of
      eight bytes, all link fragments for a datagram except the last one
      MUST be multiples of eight bytes in length.
      The first link fragment
      SHALL contain the first fragment header as defined below.</t>

      <figure anchor="frag_first_fig" title="First Fragment">
        <artwork>
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 1 0 0 0|    datagram_size    |         datagram_tag          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </artwork>
      </figure>

      <t>The second and subsequent link fragments (up to and including
      the last) SHALL contain a fragmentation header that conforms to
      the format shown below.</t>

      <figure anchor="frag_sub_fig" title="Subsequent Fragments">
        <artwork>
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 1 1 0 0|    datagram_size    |         datagram_tag          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |datagram_offset|
   +-+-+-+-+-+-+-+-+
        </artwork>
      </figure>
      <t>
      <list style="hanging">

	      <t hangText="datagram_size:">This 11-bit field encodes the size of the entire IP
   packet before link-layer fragmentation (but after IP layer fragmentation).
   The value of datagram_size SHALL be the same
   for all link-layer fragments of an IP packet.  For IPv6, this
   SHALL be 40 octets (the size of the uncompressed IPv6 header) more
   than the value of Payload Length in the IPv6 header <xref target="RFC2460"></xref> of the packet.
   Note that this packet may already be fragmented by hosts
   involved in the communication, i.e., this field needs to encode a
   maximum length of 1280 octets
   (the IEEE 802.15.4 link MTU, as defined in this document). 
      
      
      <vspace blankLines='1'/> 

      NOTE: This field does not need to be in every packet, as one
      could send it with the first fragment and elide it
      subsequently. However, including it in every link fragment eases
      the task of reassembly in the event that a second (or
      subsequent) link fragment arrives before the first. In this
      case, the guarantee of learning the datagram_size as soon as any
      of the fragments arrives tells the receiver how much buffer
      space to set aside as it waits for the rest of the
      fragments. The format above trades off simplicity for
      efficiency.<vspace blankLines='1'/></t>

      <t hangText="datagram_tag:">The value of datagram_tag (datagram
      tag) SHALL be the same for all link fragments of a payload
      (e.g., IPv6) datagram. The sender SHALL increment datagram_tag
      for successive, fragmented datagrams.  The incremented value of
      datagram_tag SHALL wrap from 65535 back to zero.  This field is
      16 bits long, and its initial value is not defined.<vspace
      blankLines='1'/></t>

      <t hangText="datagram_offset:">This field is present only in the
      second and subsequent link fragments and SHALL specify the
      offset, in increments of 8 octets, of the fragment from the
      beginning of the payload datagram. The first octet of the
      datagram (e.g., the start of the IPv6 header) has an offset of
      zero; the implicit value of datagram_offset in the first link
      fragment is zero.  This field is 8 bits long.  <vspace
      blankLines='1'/></t>

      </list>
      </t>

      <t>The recipient of link fragments SHALL use (1) the sender's
      802.15.4 source address (or the Originator Address if a Mesh
      Addressing field is present), (2) the destination's 802.15.4
      address (or the Final Destination address if a Mesh Addressing
      field is present), (3) datagram_size, and (4) datagram_tag to
      identify all the link fragments that belong to a given
      datagram.</t>

      <t>Upon receipt of a link fragment, the recipient starts
      constructing the original unfragmented packet whose size is
      datagram_size.  It uses the datagram_offset field to determine
      the location of the individual fragments within the original
      unfragmented packet.  For example, it may place the data payload
      (except the encapsulation header) within a payload datagram
      reassembly buffer at the location specified by
      datagram_offset. The size of the reassembly buffer SHALL be
      determined from datagram_size.</t>

      <t>If a link fragment that overlaps another fragment is received, 
      as identified above, and differs in either the size or
      datagram_offset of the overlapped fragment, the fragment(s)
      already accumulated in the reassembly buffer SHALL be
      discarded. A fresh reassembly may be commenced with the most
      recently received link fragment. Fragment overlap is determined
      by the combination of datagram_offset from the encapsulation
      header and "Frame Length" from the 802.15.4 Physical Layer
      Protocol Data Unit (PPDU) packet
      header.</t>

      <t>Upon detection of a IEEE 802.15.4 Disassociation event,
      fragment recipients MUST discard all link fragments of all
      partially reassembled payload datagrams, and fragment senders
      MUST discard all not yet transmitted link fragments of all
      partially transmitted payload (e.g., IPv6) datagrams. Similarly,
      when a node first receives a fragment with a given datagram_tag,
      it starts a reassembly timer.  When this time expires, if the
      entire packet has not been reassembled, the existing fragments
      MUST be discarded and the reassembly state MUST be
      flushed. The reassembly timeout MUST be set to a maximum of 60
      seconds (this is also the timeout in the IPv6 reassembly
      procedure <xref target="RFC2460"/>).
	</t>
      </section>
    </section>

    <section anchor="autoconf" title="Stateless Address Autoconfiguration">
    <t>
    This section defines how to obtain an IPv6 interface identifier.
    </t>
    <t>
    The Interface Identifier <xref target="RFC4291"></xref> for an IEEE
    802.15.4 interface may be based on the EUI-64 identifier <xref target="EUI64"
	    /> assigned to the IEEE 802.15.4 device. In this case, 
    the Interface Identifier
    is formed from the EUI-64 according to the "IPv6 over Ethernet"
    specification <xref target="RFC2464"></xref>. 
    </t>
    <t>
    All 802.15.4 devices have
    an IEEE EUI-64 address, but 16-bit short addresses 
    (<xref target="addressing-modes" /> and <xref target="iana" />)
    are also possible.
    In these cases, a "pseudo 48-bit address" is formed as follows.
    First, the left-most 32 bits are formed by concatenating 16 zero bits to 
    the 16-bit PAN ID (alternatively, if no PAN ID is known, 16 zero bits may be used). This
    produces a 32-bit field as follows:  

<vspace blankLines='1' />
<list style="empty">
	<t>
		16_bit_PAN:16_zero_bits
	</t>
</list>
<vspace blankLines='1' />

    Then, these 32 bits are concatenated with the 16-bit short address. This produces a 48-bit
    address as follows: 

<vspace blankLines='1' />
<list style="empty">
	<t>
32_bits_as_specified_previously:16_bit_short_address
	</t>
</list>
<vspace blankLines='1' />


    The interface identifier
    is formed from this 48-bit address as per the "IPv6 over Ethernet" specification
     <xref target="RFC2464"></xref>.
    However, in the resultant interface identifier, the "Universal/Local" (U/L) bit 
    SHALL be set to zero in keeping with the fact that this is not a globally unique 
    value. For either address format, all zero addresses MUST NOT be used.
    </t>

      <t>A different MAC address set manually or by software MAY be used to
      derive the Interface Identifier. If such a MAC address is used, its
      global uniqueness property should be reflected in the value of the U/L
      bit.</t>

      <t>An IPv6 address prefix used for stateless autoconfiguration <xref
      target="RFC4862"></xref> of an IEEE 802.15.4 interface
      MUST have a length of 64 bits.</t>
    
    </section>

    <section title="IPv6 Link Local Address">
      <t>The IPv6 link-local address <xref target="RFC4291"></xref> for an
      IEEE 802.15.4 interface is formed by appending the Interface Identifier,
      as defined above, to the prefix FE80::/64.</t>

      <figure anchor="link-local">
        <artwork>

       10 bits            54 bits                  64 bits
    +----------+-----------------------+----------------------------+
    |1111111010|         (zeros)       |    Interface Identifier    |
    +----------+-----------------------+----------------------------+

	 </artwork>
      </figure>
    </section>

<section title="Unicast Address Mapping">
    
<t>

	The address resolution procedure for mapping IPv6 non-multicast addresses 
	into IEEE 802.15.4 link-layer 
	addresses follows the general description in Section 7.2 of 
	<xref target="RFC4861"></xref>,
	unless otherwise specified.  
</t>
<t>
	The Source/Target Link-layer
   Address option has the following forms when the link layer is
   IEEE 802.15.4 and the addresses are EUI-64 or 16-bit short addresses, respectively.
</t>


   <figure anchor="unicast-addr-mapping">
        <artwork>
                    0                   1
                    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |     Type      |    Length=2   |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |                               |
                   +-        IEEE 802.15.4        -+
                   |          EUI-64               |
                   +-                             -+
                   |                               |
                   +-         Address             -+
                   |                               |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |                               |
                   +-         Padding             -+
                   |                               |
                   +-        (all zeros)          -+
                   |                               |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    0                   1
                    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |     Type      |    Length=1   |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |     16-bit short Address      |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |                               |
                   +-         Padding             -+
                   |         (all zeros)           |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	 </artwork>
      </figure>


<t>
   Option fields:
	       <vspace blankLines='1' />

<list style="hanging">
	<t hangText="Type:">
	<list style="hanging">
		<t hangText="1:">for Source Link-layer address.</t>
		<t hangText="2:">for Target Link-layer address.</t>
	</list>
	<vspace blankLines='1' />
       </t>
       <t hangText="Length:">
	       This is the length of this option (including the type and
	          length fields) in units of 8 octets. The value of this
		  field is 2 if using EUI-64 addresses, or 1 if using
		  16-bit short addresses.
	       <vspace blankLines='1' />
       </t>

       <t hangText="IEEE 802.15.4 Address:">
               The 64-bit IEEE 802.15.4 address, or the 16-bit short
	       address (as per the format in <xref target="multicast_mapping" />), 
	       in canonical bit
               order.  This is the address the interface currently
	       responds to. This address may be different from the built-in
	       address used to derive the Interface Identifier, because of 
	       privacy or security (e.g., of neighbor discovery) considerations.
	       <vspace blankLines='1' />
       </t>
</list>
</t>
</section>

<section anchor="multicast_mapping" title="Multicast Address Mapping">
<t>
	The functionality in this section MUST only be used in a mesh-enabled LoWPAN.
	An IPv6 packet with a multicast destination address (DST), consisting	
	of the sixteen octets DST[1] through DST[16], is transmitted to the
	following 802.15.4 16-bit multicast address: 
</t>

   <figure anchor="multicast-addr-mapping">
        <artwork>
                    0                   1
                    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |1 0 0|DST[15]* |   DST[16]     |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	 </artwork>
      </figure>

<t>
	Here, DST[15]* refers to the last 5 bits in octet DST[15], that is, 
	bits 3-7 within DST[15]. The initial 3-bit pattern of "100" follows the
	16-bit address format for multicast addresses (<xref target="iana" />).
</t>
<t>
	This allows for multicast support within 6LoWPAN networks, but the full 
	specification of such
	support is out of the scope of this document. Example mechanisms are: 
	flooding, controlled flooding, unicasting to the PAN coordinator, etc. It is 
	expected that this would be specified by the different mesh routing mechanisms.
</t>
</section>

<section anchor="hdrcompr" title="Header Compression">
<t>

	There is much published and in-progress standardization work on header compression.
	Nevertheless, header compression for IPv6 over IEEE 802.15.4 has differing
	constraints summarized as follows:
<vspace blankLines='1' />

<list style="empty">

<t>
	Existing work assumes that there are many flows between any two devices. 
	Here, we assume a very simple and low-context flavor of header compression.
	Whereas this works independently of flows (potentially several), it does not
	use any context specific to any flow. Thus, it cannot achieve as much compression
	as schemes that build a separate context for each flow to be compressed.
<vspace blankLines='1' />
</t>

<t>
	Given the very limited packet sizes, it is highly desirable to integrate layer 2 with
	layer 3 compression, something traditionally not done (although now 
	changing due to the ROHC (RObust Header Compression) working group).
<vspace blankLines='1' />
</t>
<t>
      It is expected that IEEE 802.15.4 devices will be deployed in multi-hop
      networks. However, header compression in a mesh departs from the usual
      point-to-point link scenario in which the compressor and decompressor are
      in direct and exclusive communication with each other.  In an IEEE
      802.15.4 network, it is highly desirable for a device to be able to send
      header compressed packets via any of its neighbors, with as little
      preliminary context-building as possible.
<vspace blankLines='1' />
</t>
</list>
</t>
<t>
	Any new packet formats required by header compression reuse the basic
	packet formats defined in <xref target="adaptation" /> by using
	different dispatch values. 
</t>
<t>
	Header compression may result in alignment not falling on an octet	 		
	boundary. Since hardware typically cannot transmit data in units			
	less than an octet, padding must be used. Padding is done as			
	follows: First, the entire series of contiguous compressed headers is			
	laid out (this document only defines IPv6 and UDP header compression			
	schemes, but others may be defined elsewhere). Then, zero bits			
	SHOULD be added as appropriate to align to an octet boundary. This			
	counteracts any potential misalignment caused by header compression,			
	so subsequent fields (e.g., non-compressed headers or data payloads)			
	start on an octet boundary and follow as usual.
</t>

<section anchor="encoding" title="Encoding of IPv6 Header Fields">
        <t>
	By virtue of having joined the same 6LoWPAN network, devices
 	share some state. This makes it possible to compress headers
	without explicitly building any compression context state.
	Therefore, 6LoWPAN header
	compression does not keep any flow state; instead, it relies
	on information pertaining to the entire link.  The
	following IPv6 header values are expected to be common on 6LoWPAN networks,
	so the HC1 header has been constructed to efficiently compress them
 	from the onset: Version is IPv6; both IPv6 source
 	and destination addresses are link local; the IPv6 interface identifiers 
    (bottom 64 bits) for the source or destination addresses can be
 	inferred from the layer two source and destination addresses (of course, 
    this is only possible for interface identifiers derived
    from an underlying 802.15.4 MAC address); the packet
 	length can be inferred either from layer two ("Frame Length"
 	in the IEEE 802.15.4 PPDU) or from the "datagram_size" field
 	in the fragment header (if present); both the Traffic Class
 	and the Flow Label are zero; and the Next Header is UDP, ICMP
 	or TCP.  The only field in the IPv6 header that always needs
 	to be carried in full is the Hop Limit (8 bits).  Depending on
 	how closely the packet matches this common case, different
 	fields may not be compressible thus needing to be carried
 	"in-line" as well (<xref target="non-compressed-ipv6"
 	/>). This common IPv6 header (as mentioned above) can be
 	compressed to 2 octets (1 octet for the HC1 encoding and 1
 	octet for the Hop Limit), instead of 40 octets.  Such a packet
 	is compressible via the LOWPAN_HC1 format by using a Dispatch
 	value of LOWPAN_HC1 followed by a LOWPAN_HC1 header "HC1
 	encoding" field (8 bits) to encode the different combinations
 	as shown below.  This header may be preceded by a
 	fragmentation header, which may be preceded by a mesh header.
        </t>

        <figure anchor="lowpan_hc1"
		title="LOWPAN_HC1 (common compressed header encoding)">
          <artwork>
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | HC1 encoding  |     Non-Compressed fields follow...           
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	</artwork>
        </figure>

<t>
	As can be seen below (bit 7), an HC2 encoding may follow an 
	HC1 octet. In this case, the non-compressed fields follow
	the HC2 encoding field (<xref target="non-compressed" />).
</t>

<t>
	The address fields encoded by "HC1 encoding" are interpreted as follows:

<list style="hanging">
	<t hangText="">
		<list style="hanging" >
			<t hangText="PI:">Prefix carried in-line 
				(<xref target="non-compressed-ipv6" />).</t>
			<t hangText="PC:">Prefix compressed (link-local prefix assumed).</t>
			<t hangText="II:">Interface identifier carried in-line 
				(<xref target="non-compressed-ipv6" />).</t>
			<t hangText="IC:">Interface identifier elided (derivable 
				from the corresponding link-layer address).
				If applied to the interface identifier of either the source
				or destination address when
				routing in a mesh (<xref target="mesh" />), the
				corresponding link-layer address is that found in the
				"Mesh Addressing" field 
				(<xref target="mesh_hdr" />).</t>
		</list>
	</t>
</list>
</t>
	
<t>
	The "HC1 encoding" is shown below (starting with bit 0 and ending at bit 7):

<list style="empty">

<t>

<list style="hanging">
	<t hangText="IPv6 source address (bits 0 and 1):">
		<list style="hanging" >
			<t hangText="00:">PI, II</t>
			<t hangText="01:">PI, IC</t>
			<t hangText="10:">PC, II</t>
			<t hangText="11:">PC, IC </t>
		</list>
	</t>
</list>
</t>

<t>
<list style="hanging">
	<t hangText="IPv6 destination address (bits 2 and 3):">
		<list style="hanging" >
			<t hangText="00:">PI, II</t>
			<t hangText="01:">PI, IC</t>
			<t hangText="10:">PC, II</t>
			<t hangText="11:">PC, IC </t>
		</list>
	</t>
</list>
</t>

<t>
<list style="hanging">
	<t hangText="Traffic Class and Flow Label (bit 4):">
		<list style="hanging" >
			<t hangText="0:">not compressed; full 8 bits for Traffic Class
				and 20 bits for Flow Label are sent</t>
			<t hangText="1:">Traffic Class and Flow Label are zero</t>
		</list>
	</t>
</list>
</t>

<t>
<list style="hanging">
	<t hangText="Next Header (bits 5 and 6):">
		<list style="hanging" >
			<t hangText="00:">not compressed; full 8 bits are sent</t>
			<t hangText="01:">UDP</t>
			<t hangText="10:">ICMP</t>
			<t hangText="11:">TCP</t>
		</list>
	</t>
</list>
</t>

<t>
<list style="hanging">
	<t hangText="HC2 encoding(bit 7):">
		<list style="hanging" >
			<t hangText="0:">No more header compression bits</t>
			<t hangText="1:">HC1 encoding immediately followed by more header 
				compression bits per HC2 encoding format. Bits 5 and 6 determine
				which of the possible HC2 encodings apply (e.g., UDP, ICMP, or TCP
				encodings). </t>
		</list>
	</t>
</list>
</t>

 </list>

</t>
</section>

<section anchor="udp-encoding" title="Encoding of UDP Header Fields">
<t>
	Bits 5 and 6 of the LOWPAN_HC1 allows compressing the Next Header field in the IPv6
	header (for UDP, TCP, and ICMP). Further compression of each of these protocol
	headers is also possible. This section explains how the UDP header itself may
	be compressed. The HC2 encoding in this section is the HC_UDP encoding,
	and it only applies if bits 5 and 6 in HC1 indicate that the protocol that follows
	the IPv6 header is UDP. 
	The HC_UDP encoding (<xref target="hc_lowpan_udp" />) allows compressing 
	the following fields in the UDP header: source port, destination port, and
	length.
	The UDP header's checksum field is not compressed and is therefore
	carried in full. The scheme defined below allows compressing the 
	UDP header to 4 octets instead of the original 8 octets.
</t>
<t>
	The only UDP header field whose value may be deduced from information
	available elsewhere is the Length. The other fields must be carried
	in-line either in full or in a partially compressed manner
	(<xref target="non-compressed-udp" />). 
</t>
        <figure anchor="hc_lowpan_udp"
		title="HC_UDP (UDP common compressed header encoding)">
          <artwork>
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |HC_UDP encoding|     Fields carried in-line follow...          
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	</artwork>
        </figure>
<t>
	The "HC_UDP encoding" for UDP is shown below (starting with bit 0 and ending at bit 7):

<list style="empty">

<t>
<list style="hanging">
	<t hangText="UDP source port (bit 0):">
		<list style="hanging" >
			<t hangText="0:">Not compressed, carried "in-line" 
			                (<xref target="non-compressed-udp" />)</t>
			<t hangText="1:">Compressed to 4 bits. The actual 16-bit source port is
			                 obtained by calculating: P + short_port value. 
					 The value of P is the number 61616 (0xF0B0).
					 The short_port is expressed as a 4-bit value
					 which is carried "in-line" 
			                 (<xref target="non-compressed-udp" />)
			                 </t>
		</list>
	</t>
</list>
</t>

<t>
<list style="hanging">
	<t hangText="UDP destination port (bit 1):">
		<list style="hanging" >
			<t hangText="0:">Not compressed, carried "in-line" 
			                 (<xref target="non-compressed-udp" />)</t>
			<t hangText="1:">Compressed to 4 bits. The actual 16-bit destination port is
			                 obtained by calculating: P + short_port value. 
					 The value of P is the number 61616 (0xF0B0).
					 The short_port is expressed as a 4-bit value
					 which is carried "in-line" 
			                 (<xref target="non-compressed-udp" />)
			                 </t>
		</list>
	</t>
</list>
</t>

<t>
<list style="hanging">
	<t hangText="Length (bit 2):">
		<list style="hanging" >
			<t hangText="0:">not compressed, carried "in-line" 
			                 (<xref target="non-compressed-udp" />)</t>
			<t hangText="1:">compressed, length computed from IPv6 
				header length information. The value of the UDP length field is equal
				to the Payload Length from the IPv6 header, minus the length of any extension
				headers present between the IPv6 header and the UDP header.  </t>
		</list>
	</t>
</list>
</t>

<t>
<list style="hanging">
	<t hangText="Reserved (bit 3 through 7)">
	</t>
</list>
</t>

</list>

</t>

</section>

<section anchor="non-compressed" title="Non-Compressed Fields">
<section anchor="non-compressed-ipv6" title="Non-Compressed IPv6 Fields">
<t>
	This scheme allows the IPv6 header to be compressed to different degrees.
	Hence, instead of the entire (standard) IPv6 header, only non-compressed 
	fields need to be sent. The subsequent header (as specified by the Next Header
	field in the original IPv6 header) immediately follows the IPv6 non-compressed
	fields.
</t>
<t>
	Uncompressed IPv6 addressing is described by a dispatch type
	containing an IPv6 dispatch value followed by the uncompressed
	IPv6 header. This dispatch type may be preceded by additional
	LoWPAN headers.
</t>
<t>
	The non-compressed IPv6 field that MUST be always present is
	the Hop Limit (8 bits). This field MUST always follow the
	encoding fields (e.g., "HC1 encoding" as shown in <xref
	target="lowpan_hc1" />), perhaps including other future
	encoding fields).  Other non-compressed fields MUST follow the
	Hop Limit as implied by the "HC1 encoding" in the exact same
	order as shown above (<xref target="encoding" />): source
	address prefix (64 bits) and/or interface identifier (64
	bits), destination address prefix (64 bits) and/or interface
	identifier (64 bits), Traffic Class (8 bits), Flow Label (20
	bits) and Next Header (8 bits). The actual next header (e.g.,
	UDP, TCP, ICMP, etc) follows the non-compressed fields.
</t>
</section>
<section anchor="non-compressed-udp" title="Non-Compressed and Partially Compressed UDP Fields">
<t>
   	This scheme allows the UDP header to be compressed to different degrees.
	Hence, instead of the entire (standard) UDP header, only non-compressed 
	or partially compressed fields need to be sent. 
</t>
<t>
	The non-compressed or partially compressed fields in the UDP header MUST 
	always follow the
	IPv6 header and any of its associated in-line fields. Any
	UDP header in-line fields present MUST appear in the same order
	as the corresponding fields appear in a normal
	UDP header <xref target="RFC0768" />,
	e.g., source port, destination port, length, and checksum. If either the
	source or destination ports are in "short_port" notation (as indicated
	in the compressed UDP header), then instead of taking 16 bits, the inline
	port numbers take 4 bits.
</t>
</section>
</section>
</section>

<section anchor="mesh" title="Frame Delivery in a Link-Layer Mesh">
<t>
	Even though 802.15.4 networks are expected to commonly use mesh routing,
	the IEEE 802.15.4-2003 specification <xref target="ieee802.15.4"/> 
	does not define such capability. 
	In such cases, Full Function Devices (FFDs) run an ad hoc or mesh routing protocol 
	to populate their routing tables (outside the scope of this document). 
	In such mesh scenarios, two devices do not require direct reachability in order to
	communicate. Of these devices, the sender is known as the "Originator", and
	the receiver is known as the "Final Destination".
	An originator device may use other intermediate devices
	as forwarders towards the final destination. In order to achieve such
	frame delivery using unicast, it is necessary to include the link-layer
	addresses of the originator and final 
	destinations, in addition to the hop-by-hop source and destination. 
</t>

<t>
	This section defines how to effect delivery of layer 2 frames in a mesh, given
	a target "Final Destination" link-layer address. 
</t>
<t>
	Mesh delivery is enabled by including a Mesh Addressing header prior to any other
	headers of the LoWPAN encapsulation (<xref target="adaptation"
	/>), an
        unfragmented and fragmented header; 
	a full-blown IPv6 header; or a compressed IPv6 header as per
	<xref target="hdrcompr" /> or any others defined elsewhere.
</t>
<t>
	If a node wishes to use a default mesh forwarder to deliver a packet (i.e., because it does
	not have direct reachability to the destination), 
	it MUST include a Mesh Addressing header 
	with the originator's link-layer address set to its own,
	and the final destination's link-layer address set to the packet's ultimate
	destination. 
	It sets the source address in the 802.15.4 header to its own
	link-layer address, and puts the  
	forwarder's link-layer address in the 
	802.15.4 header's destination address
	field. Finally, it transmits the packet. 
</t>
<t>
	Similarly, if a node receives a frame with a Mesh Addressing header, it must look at the
	Mesh Addressing header's "Final Destination" field to determine the real destination. 
	If the node is itself the final destination, it consumes the packet as per normal
	delivery. 
	If it is not the final destination, the device then 
	reduces the "Hops Left" field, 
	and if the result is zero, discards the packet. 
	Otherwise, the node consults its link-layer routing table, 
	determines what the next hop towards the final destination should be, and puts that
	address in the destination address field of the 802.15.4 header.
	Finally, the node changes the source address in the 802.15.4 header to its own
	link-layer address and transmits the packet. 
</t>

<!-- Commenting out this note, as we now added the originator's source link-layer address.
<t>
	NOTE: The mesh delivery mechanism defined here only allows for a final
	destination link-layer address, but not for an original destination link-layer
	address. This saves space, but then one must decide how to use the only
	existing source link-layer address (that in the 802.15.4 header).
	There are pros and cons to not having the source link-layer address
	change at every hop, as per the current specification. 
	This is a pure layer 2 mesh delivery solution, so
	even middle fragments can be forwarded as soon as they are received.
	Even though which node sent a given frame is not immediately
	obvious, this information can be inferred from the precursor list information
	in its routing table.  If more than one precursor are possible, the node 
	would not necessarily know which of those
	actually sent it the frame in question. In order to send back an RERR, for 
	example, it might have to send it to all possible precursors. Given that such
	error conditions may be rare as compared to data forwarding events, this may
	not be a large cost to pay. However, the acknowledge mode of data delivery
	in 802.15.4 sends back an ACK whenever a frame is received. Typically,  this
	operation is implemented in hardware very efficiently. With the current
	scheme, one would have to turn off this option on the chipset, and instead
	do it in a much less efficient manner in software. Data forwarding 
	in this case incurs the cost of examining the routing table in order to
	infer the link-layer address of the device that is expecting the ACK.
	Unfortunately, a device that does not implement this specification would
	proceed as per the usual 802.15.4 procedures and send back an ACK to the
	address contained in the source link-layer address. Such an ACK would be
	erroneously addressed to the initial originator of the frame, and would most probably 
	remain undelivered. Because of these considerations it may be inevitable to 
	add the original link-layer source address as an explicit field in 
	mesh delivery.
	The alternative, of course, is to have the source link-layer address change
	at every hop. In this case, the original link-layer address is lost. It may 
	be possible to recover it if the IP source address is present and if there
	is a clearly defined way to derive the former from the latter (as per the 
	header compression considerations in this document). This poses the issues
	that this ceases being a mesh delivery solution at layer 2, with the 
	considerations raised in the previous section.
</t>
End of Comment -->

<t>
	Whereas a node must participate in a mesh routing protocol to be a forwarder,
	no such requirement exists for simply using mesh forwarding.
	Only "Full Function Devices" (FFDs) are expected to participate as routers 
	in a mesh. "Reduced Function Devices" (RFDs) limit themselves to discovering 
	FFDs and using them for all their forwarding, in a manner similar to 
	how IP hosts typically use default routers to forward all their off-link
	traffic. For an RFD using mesh delivery, the "forwarder" is always the
	appropriate FFD. 
	
</t>

        <section anchor="lowpan_bc0" title="LoWPAN Broadcast">

        <t>Additional mesh routing functionality is encoded using
        a routing header immediately following the Mesh
        header.  In particular, a broadcast header consists of a
	LOWPAN_BC0 dispatch followed by a sequence number field.
	The sequence number is used to detect duplicate packets 
	(and hopefully suppress them).</t>

        <figure anchor="mesh_broadcast_hdr" title="Broadcast Header">
          <artwork>
                        1           
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|1|LOWPAN_BC0 |Sequence Number| 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          </artwork>
        </figure>

        <t>Field definitions are as follows:

	<vspace blankLines='1' />

	<list style="hanging">

          <t hangText="Sequence Number:">This 8-bit field SHALL be
          incremented by the originator whenever it sends a new mesh
          broadcast or multicast packet. Full specification of how to
          handle this field is out of the scope of this document.<vspace
          blankLines='1' /></t>
	</list>
        </t>

	<t>Further implications of such mesh-layer broadcast, e.g.,
	whether it maps to a controlled flooding mechanism or its role
	in, say, topology discovery, is out of the scope of this
	document.</t>

        <t>Additional mesh routing capabilities, such as specifying
	the mesh routing protocol, source routing, and so on may be
	expressed by defining additional routing headers that precede
	the fragmentation or addressing header in the header stack.
	The full specification of such mesh routing capabilities are
	out of the scope of this document.</t>

	</section>

</section>

<section anchor="iana" title="IANA Considerations">
<t>
	This document creates two new IANA registries, as discussed below.
	Future assignments in these registries
	are to be coordinated via IANA under the policy of
	"Specification Required" <xref target="RFC2434" />. It is expected
	that this policy will allow for other (non-IETF) organizations to more
	easily obtain assignments.
</t>
<!-- OLD FORMAT
<t>
	This document creates a new IANA registry for the prot_type
	(Protocol Type) field shown in the packet formats in 
	<xref target="adaptation" />. This document defines the
	values 1 and 2 hexadecimal for IPv6 and the LOWPAN_HC1 header
	compression format, respectively. 

	This document defines this field to be 8 bits long.  The
	value 0 being reserved and not used, this allows for a total of 254 different
	values, which should be more than enough.
</t>
-->
<t>
	This document creates a new IANA registry for the Dispatch type
	field shown in the header definitions in
	<xref target="adaptation" />. This document defines the
	values IPv6, LOWPAN_HC1 header compression, BC0 broadcast and two escape
	patterns (NALP to indicate not a LOWPAN frame and ESC to allow additional dispatch bytes).

	This document defines this field to be 8 bits long.  The
	values 00xxxxxx being reserved and not used, allows for a total of 192 different
	values, which should be more than enough.  If header compression formats in addition
        to HC1 are defined or if additional TCP, ICMP HC2 formats are defined, it is expected
	that these will use reserved dispatch values following LOWPAN_HC1.  If additional 
	mesh delivery formats are defined these will use reserved values following LOWPAN_BC0.
</t>
<t>
	This document creates a new IANA registry for the 16-bit short address fields as used in
	6LoWPAN packets. 
</t>
   <figure anchor="short-address-format">
        <artwork>
                    0                   1
                    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |     16-bit short Address      |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

	 </artwork>
      </figure>
<t>
	This registry MUST include the addresses 0xffff (16-bit broadcast address accepted by
	all devices currently listening to the channel)
	and 0xfffe as defined 
	in <xref target="ieee802.15.4"></xref>. Additionally, 
	within 6LoWPAN networks, 16-bit short addresses
	MUST follow this format (referring to bit fields in the order
	from 0 to 7), where "x" is a place holder for an unspecified bit value:
	<vspace blankLines='1' />

	<list style="hanging">
		<t hangText="Range 1, Oxxxxxxxxxxxxxxx:">
			The first bit (bit 0) SHALL be zero if the
			16-bit address is a unicast address. 
			This leaves 15 bits for the actual address.
			<vspace blankLines='1' />
		</t>

		<t hangText="Range 2, 100xxxxxxxxxxxxx:">
			Bits 0, 1, and 2 SHALL follow this pattern if the
			16-bit address is a multicast address 
			(see <xref target="multicast_mapping" />). This leaves 13 bits
			for the actual multicast address.
			<vspace blankLines='1' />
		</t>

		<t hangText="Range 3, 101xxxxxxxxxxxxx:">
			This pattern for bits 0, 1, and 2 is reserved.
			Any future assignment shall follow the policy mentioned above.
			<vspace blankLines='1' />
		</t>
		<t hangText="Range 4, 110xxxxxxxxxxxxx:">
			This pattern for bits 0, 1, and 2 is reserved.
			Any future assignment shall follow the policy mentioned above.
			<vspace blankLines='1' />
		</t>
		<t hangText="Range 5, 111xxxxxxxxxxxxx:">
			This pattern for bits 0, 1, and 2 is reserved.
			Any future assignment shall follow the policy mentioned above.
			<vspace blankLines='1' />
		</t>

	</list>
</t>

    </section>

    <section anchor="security" title="Security Considerations">
<t> 
	The method of derivation of Interface Identifiers from EUI-64 MAC addresses is
	intended to preserve global uniqueness when possible.  However, there
	is no protection from duplication through accident or forgery.  
</t>
<t>
	Neighbor Discovery in IEEE 802.15.4 links may be susceptible to threats as detailed in
	<xref target="RFC3756" />. 
	Mesh routing is expected to be common in IEEE 802.15.4 networks. This implies
	additional threats due to ad hoc routing as per <xref target="KW03" />.
	IEEE 802.15.4 provides some capability for link-layer security. Users
	are urged to make use of such provisions if at all possible and practical.
	Doing so will alleviate the threats stated above. 
</t>
<t>
	A sizeable portion of IEEE 802.15.4 devices is expected to always
	communicate within their PAN (i.e., within their link, in IPv6 terms).
	In response to cost and power consumption considerations, and in
	keeping with the IEEE 802.15.4 model of "Reduced Function Devices"
	(RFDs), these devices will typically implement the minimum set of
	features necessary.  Accordingly, security for such devices may rely
	quite strongly on the mechanisms defined at the link layer by IEEE
	802.15.4. The latter, however, only defines the Advanced
	Encryption Standard (AES) modes for
	authentication or encryption of IEEE 802.15.4 frames, and does not, in
	particular, specify key management (presumably group oriented). Other
	issues to address in real deployments relate to secure configuration
	and management. Whereas such a complete picture is out of the scope of this
	document, it is imperative that IEEE 802.15.4 networks be deployed with
	such considerations in mind.  Of course, it is also expected that some
	IEEE 802.15.4 devices (the so-called "Full Function Devices", or
	"FFDs") will implement coordination or integration functions. These may
	communicate regularly with off-link IPv6 peers (in addition to the more
	common on-link exchanges). Such IPv6 devices are expected to secure
	their end-to-end communications with the usual mechanisms (e.g., IPsec,
	TLS, etc).
</t>

    </section>

    <section title="Acknowledgements">
<t>
	Thanks to the authors of RFC 2464 and RFC 2734, as parts of this
	document are patterned after theirs. 
	Thanks to Geoff Mulligan for useful discussions
	which helped shape this document.
	Erik Nordmark's suggestions were instrumental
	for the header compression section. Also thanks to Shoichi Sakane,
	Samita Chakrabarti, Vipul Gupta, Carsten Bormann, Ki-Hyung Kim, Mario Mao,
	Phil Levis, Magnus Westerlund, and Jari Arkko.
</t>

    </section>

  </middle>

  <back>
    <references title="Normative References">
      &RFC2119;

      &RFC2434;

      &RFC2460;

      &RFC2464;

      &RFC4291;

<reference anchor="RFC4861">
	<front>
	<title>
Neighbor Discovery for IP version 6 (IPv6)
</title>
	<author initials="T." surname="Narten" fullname="Thomas Narten">
<organization>IBM </organization>
</author>

        <author initials="E." surname="Nordmark" fullname=" Erik Nordmark">
<organization>Sun Microsystems, Inc. </organization>
</author>
        <author initials="W." surname="Simpson" fullname="William
Allen Simpson">
<organization>Daydreamer </organization>
</author>
        <author initials="H." surname="Soliman" fullname="Hesham Soliman">
<organization>Elevate Technologies </organization>
</author>

<date year="2007" month="August"/>
</front>
<seriesInfo name='RFC' value='4861' />
<format type='TXT' target=' '/>
</reference>

<reference anchor="RFC4862">
	<front>
	<title>
IPv6 Stateless Address Autoconfiguration
</title>
	<author initials="S." surname="Thomson" fullname="Susan Thomson ">
<organization>CISCO</organization>
</author>
        <author initials="T." surname="Narten" fullname="Thomas
Narten">
<organization>IBM </organization>
</author>
        <author initials="T." surname="Jinmei" fullname="Tatuya Jinmei ">
<organization>Corporate Research & Development Center, Toshiba Corporation</organization>
</author>

<date year="2007" month="August"/>
</front>
<seriesInfo name='RFC' value='4862' />
<format type='TXT' target=' '/>
</reference>

    <reference anchor="ieee802.15.4">
        <front>
          <title>IEEE Std. 802.15.4-2003</title>

          <author surname="IEEE Computer Society">
            <organization></organization>
          </author>

          <date month="October" year="2003" />
        </front>
      </reference>
    </references>

    <references title="Informative References">
      <reference anchor="EUI64">
        <front>
		<title>GUIDELINES FOR
			64-BIT GLOBAL IDENTIFIER (EUI-64)
			REGISTRATION AUTHORITY</title>

	  <author> <organization></organization> </author>

        </front>
	<seriesInfo name='IEEE' value='http://standards.ieee.org/regauth/oui/tutorials/EUI64.html'  />
    </reference>

      &RFC3756;

      &RFC3819;
      
      &RFC0768;

      <reference anchor="KW03">
        <front>
		<title>Secure Routing in Sensor Networks: Attacks and Countermeasures</title>
 	<author surname="Karlof, Chris">
            <organization></organization>
          </author>
 	<author surname="Wagner, David">
            <organization></organization>
          </author>
          <date month="September" year="2003" />
        </front>
	<seriesInfo name="Elsevier's AdHoc Networks Journal, Special Issue on Sensor Network Applications and Protocols"
		value='vol 1, issues 2-3'  />
      </reference>


    </references>

<section anchor="mesh-alternatives" title="Alternatives for Delivery of Frames in a Mesh">
<t>
	Before settling on the mechanism finally adopted for delivery in a 
	mesh (<xref target="mesh"/>), 
	several alternatives were considered. In addition to the hop-by-hop source and
	destination link-layer addresses, delivering a packet in a LoWPAN mesh requires
	the end-to-end originator and destination addresses.
	These could be expressed either as layer 2 or as layer 3 (i.e., IP ) addresses. 
	In the latter case, there would be no need to provide any 
	additional header support in this document (i.e., within the LoWPAN header itself). 
	The link-layer destination address would point to the 
	next hop destination address while the IP header destination address would point
	to the final destination (IP) address (possibly multiple hops away
	from the source), and similarly for the source addresses. Thus, while forwarding data, 
	the single-hop source and destination addresses would change at each hop (always pointing to the 
	node doing the forwarding and the "best" next link-layer hop, respectively), 
	while the source and destination IP addresses would remain unchanged.
	Notice that if an IP packet is fragmented, the individual fragments may arrive at any
	node out of order. If the initial fragment (which contains the IP header)
	is delayed for some reason, a node that receives a subsequent fragment would lack
	the required information. It would be forced to wait until it receives the IP header
	(within the first fragment) before being able to forward
	the fragment any further. This imposes some additional buffering requirements on
	intermediate nodes. Additionally, such a specification would only work for one type
	of LoWPAN payload: IPv6. In general, it would have to be adapted for any other payload,
	and would require that payload to provide its own end-to-end addressing information.
</t>
<t>
    On the other hand, the approach finally followed (<xref target="mesh"/>) creates 
    a mesh at the LoWPAN layer (below layer 3). Accordingly,
   the link-layer originator and final destination address 
    are included within the LoWPAN header. 
    This enables mesh delivery for any protocol or application 
    layered on the LoWPAN adaptation layer (<xref target="adaptation" />).

	For IPv6 as supported in this document, 
	another advantage of expressing the originator and final 
	destinations as layer 2 addresses 
	is that the IPv6 addresses can be compressed as per the header compression
	specified in <xref target="hdrcompr" />. Furthermore,
	the number of octets needed to maintain 
	routing tables is reduced due to the smaller size of 802.15.4 addresses
	(either 64 bits or 16 bits) as compared to IPv6 addresses (128 bits). 
	A disadvantage is that applications on top of IP do not
	address packets to link-layer destination addresses, but to IP (layer 3) 
	destination addresses. Thus, given an IP address, there is a need to resolve the
	corresponding link-layer address. Accordingly,
	a mesh routing specification needs to clarify the Neighbor Discovery
	implications, although in some special cases, it may be possible to derive
	a device's address at layer 2 from its address at layer 3 (and
	vice versa). 
	Such complete specification is outside the scope
	of this document.
</t>
</section>
  </back>
</rfc>
