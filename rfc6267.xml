<?xml version="1.0" encoding="US-ASCII"?>


<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
    <!ENTITY rfc3830 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3830.xml'>
    <!ENTITY rfc3711 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3711.xml'>
    <!ENTITY rfc4738 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4738.xml'>
    <!ENTITY rfc4650 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4650.xml'>
    <!ENTITY rfc4120 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4120.xml'>
    <!ENTITY rfc4563 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4563.xml'>
    <!ENTITY rfc5091 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5091.xml'>
    <!ENTITY rfc5226 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml'>
    <!ENTITY rfc5408 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5408.xml'>
    <!ENTITY rfc3261 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml'>
    <!ENTITY rfc5409 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5409.xml'>
    <!ENTITY rfc6043 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6043.xml'>



]>


<rfc submissionType="IETF" consensus="yes" ipr="trust200902" category="info" number="6267">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<?rfc subcompact="no" ?>
<?rfc rfcedstyle="yes" ?>

    <front>
      <title abbrev='MIKEY-IBAKE'>
MIKEY-IBAKE: Identity-Based Authenticated Key Exchange (IBAKE) Mode of Key Distribution in Multimedia Internet KEYing (MIKEY)
      </title>



      <author initials='V.' surname='Cakulev' fullname='Violeta Cakulev'>
	<organization>Alcatel Lucent</organization>

	<address>
	  <postal>
	    <street>600 Mountain Ave.</street>
	    <street>3D-517</street>
	    <city>Murray Hill</city> <region>NJ</region> <code>07974</code>
	    <country>US</country>
	  </postal>

	  <phone>+1 908 582 3207</phone>
	  <email>violeta.cakulev@alcatel-lucent.com</email>
	</address>
      </author>

      <author initials='G.' surname='Sundaram'  fullname='Ganapathy Sundaram'>
	<organization>Alcatel Lucent</organization>

	<address>
	  <postal>
	    <street>600 Mountain Ave.</street>
	    <street>3D-517</street>
	    <city>Murray Hill</city> <region>NJ</region> <code>07974</code>
	    <country>US</country>
	  </postal>

	  <phone>+1 908 582 3209</phone>
	  <email>ganesh.sundaram@alcatel-lucent.com</email>
	</address>
      </author>

        <date month="June" year="2011"/>


        <abstract><t>
	    This document describes a key management protocol variant for the
   Multimedia Internet KEYing (MIKEY) protocol that relies on a
   trusted key management service. In particular, this variant utilizes
   Identity-Based Authenticated Key Exchange (IBAKE) framework that allows the
   participating clients to perform mutual authentication and derive a 
	    session key  in an asymmetric
   Identity-Based Encryption (IBE) framework. This protocol, in addition to
   providing mutual authentication, eliminates the key escrow problem that 
	    is common in standard IBE and provides  
	    perfect forward and backward secrecy.
	</t></abstract>
    </front>

    <middle>

      <section title="Introduction">
        
   <t> The Multimedia Internet Keying (MIKEY) 
     <xref target="RFC3830"/> specification describes
     several modes of key distribution solution that address multimedia
     scenarios using pre-shared keys, Public Keys, and optionally a
     Diffie-Hellman key exchange. Multiple 
     extensions of MIKEY have been specified, such as HMAC-Authenticated (Hashed Message Authentication Code) Diffie-Hellman <xref target="RFC4650"/>
     and MIKEY-RSA-R <xref target="RFC4738"/>.</t>

   <t>To address deployment scenarios in which
     security systems serve a large number of users, a key management service is often preferred. With such a service in place, 
     it would be possible for a user to request credentials for any other 
     user when they are needed. Some proposed solutions <xref target="RFC6043"/> rely on Key Management Services (KMSs) in 
     the network that create, distribute, and manage keys in a real time. Due to this broad 
     functionality, key management services would have to be online, maintain high 
     availability, and be networked across operator boundaries.

</t>

   <t>This document describes a solution in which KMSs are low-availability
     servers that 
     communicate with end-user clients periodically (e.g., once a month). The online 
     transactions between the end-user clients (for media plane security) are 
     based on Identity-Based Encryption (IBE) <xref target="BF"/>. 
     These online transactions between the end-user clients allow them
     to perform mutual authentication 
     and derive a session key not known to any external entity 
     (including KMSs).
     This protocol, in 
     addition to providing keys not known to any external entity and allowing 
     for end-user clients 
     to mutually authenticate each other (at the media plane layer), 
     provides perfect forward and backward secrecy. In this protocol, the KMS-to-client exchange is used sparingly (e.g., once a month); hence, the 
     KMS is no longer required to be a high-availability server, and in 
     particular different KMSs don't have to communicate with each other 
     (across operator boundaries). Moreover, given that an 
     IBE is used, the need for costly Public Key 
     Infrastructure (PKI) and all the operational costs of certificate 
     management and revocation are eliminated. This is achieved by 
     concatenating Public Keys with a date field, thereby ensuring 
     corresponding Private Keys change with the date and, more importantly, 
     limiting the damage due to loss of a Private Key to just that date while not requiring endpoints involved in communication to be time synchronized. 
     The granularity in the date field is a matter of security policy 
     and deployment scenario. For instance, an operator may choose to use 
     one key per day and hence the KMS may issue Private Keys for a whole 
      subscription cycle at the beginning of a 
     subscription cycle. Therefore, unlike in the PKI systems, where issued certificate is typically valid for period of time thereby requiring revocation procedures to limit their validity, the scheme described in this document uses time-bound public identities, which automatically expire at the end of a time span indicated in the identity itself. With the self-expiration of the public identities, the traditional real-time validity verification and revocation is not required. For example, if the public identity is bound to one day, then, at the end of the day, the Public/Private Key pair issued to this peer will simply not be valid anymore. Nevertheless, just like with Public-Key-based certificate systems, if there is a need to revoke keys before the designated expiry time, communication with a third party will be needed.</t>
   <t>Additionally, various call scenarios 
     are securely supported -- this includes secure 
     forking, retargeting, deferred delivery and pre-encoded content.</t>
<t>MIKEY is widely used in the 3GPP community.  This specification
    is intended primarily for use with 3GPP media security, but it may
    also be applicable in Internet applications. 
	    </t>
	    </section>
<section title="Terminology">
        <section title="Requirements Language">
            <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
            "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
            and "OPTIONAL" in this document are to be interpreted as
            described in <xref target="RFC2119"/>.</t>
</section>
	    <section title="Definitions and Notation">



	      <t>IBE Encryption: Identity-Based Encryption (IBE) is a 
		Public-Key encryption technology
   that allows a Public Key to be calculated from an identity, and the
   corresponding Private Key to be calculated from the Public Key. 
	      <xref target="RFC5091"/>, 
		<xref target="RFC5408"/>, and <xref target="RFC5409"/> describe algorithms required to implement the IBE.</t>


		<t>(Media) session: The communication session intended to be 
		  secured by the MIKEY-IBAKE provided key(s).</t>

   
<t>
            <figure>
              <artwork><![CDATA[
   E(k, x)  Encryption of x with the key k
   [x]P     Point multiplication on an elliptic curve, i.e., adding 
            a point P to itself total of x times
   K_PUBx   Public Key of x
   [x]      x is optional
   {x}      Zero or more occurrences of x
   (x)      One or more occurrences of x
   ||       Concatenation
   |        OR (selection operator)
]]></artwork>
            </figure>
</t>
		       </section>

	    <section title="Abbreviations">


	      <t><list hangIndent="10" style="hanging">
		  <t hangText="EC" > Elliptic Curve</t>
		  <t hangText="ESK"> Encrypted Secret Key</t>
                  <t hangText="HMAC">Hashed Message Authentication Code </t>
		  <t hangText="IBE"> Identity-Based Encryption</t>
		  <t hangText="I"> Initiator</t>
		  <t hangText="IBAKE"> Identity-Based Authenticated Key 
		    Exchange</t>
		 <t hangText="IDRi"> Initiator's Identity </t>
		 <t hangText="IDRr"> Responder's Identity </t>
		 <t hangText="KMS"> Key Management Service</t>
		 <t hangText="K_PR"> Private Key</t>
		 <t hangText="K_PUB"> Public Key</t>
		 <t hangText="K_SESSION"> Session Key</t>
		 <t hangText="MAC"> Message Authentication Code</t>
		 <t hangText="MIKEY"> Multimedia Internet KEYing</t>
                 <t hangText="MKI"> Master Key Identifier</t>
		 <t hangText="MPK">MIKEY Protection Key </t>
                 <t hangText="PKI"> Public Key Infrastructure</t> 
                 <t hangText="PRF"> Pseudorandom Function</t>
		 <t hangText="R"> Responder</t>
		 <t hangText="SK"> Secret Key</t>
		 <t hangText="SIP"> Session Initiation Protocol</t>
                 <t hangText="SPI"> Security Parameter Index</t>
                 <t hangText="SRTP"> Secure Realtime Transport Protocol</t>
		 <t hangText="TEK"> Traffic Encryption Key</t>
		 <t hangText="TGK"> TEK Generation Key</t>
	      </list></t>	
	    </section>

        </section>


	<section title="Use Case Scenarios" anchor="usecases">
	  <t>This section describes some of the use case scenarios supported by 
	    MIKEY-IBAKE, in addition to regular two-party communication.</t>

	  <section title="Forking">
	    <t>Forking is the delivery of a request (e.g., SIP INVITE message) 
	      to multiple endpoints. This happens when a single user 
	      is registered more than once.  An example of forking is when a 
	      user has a desk phone, PC client, and mobile handset all 
	      registered with the same public identity.</t>
<t>
            <figure title="Forking" anchor="forking">
              <artwork><![CDATA[
      +---+             +-------+             +---+             +---+
      | A |             | PROXY |             | B |             | C |
      +---+             +-------+             +---+             +---+
            Request
        -------------------->      
                                   Request
			    -------------------->
                                   Request
			    ------------------------------------->
    ]]></artwork>
            </figure>
</t>

	  </section>

	  <section title="Retargeting">
	    <t>Retargeting is a scenario in which a functional element 
	      decides to redirect the session to a different 
	      destination. This decision to redirect a session may be made 
	      for different reasons by a number of different functional 
	      elements and at different points in the establishment of 
	      the session.</t>

	    <t>There are two basic scenarios of session redirection. 
	      In scenario one, a functional element (e.g., Proxy) decides 
	      to redirect the session by passing the new destination 
	      information to the originator. As a result, the originator 
	      initiates a new session to the redirected destination provided 
	      by the Proxy. For the case of MIKEY-IBAKE, this 
	      means that the originator will initiate a new session with the 
	      identity of the redirected destination. This scenario is 
	      depicted in <xref target="retargeting"/> below.</t> 
<t>
            <figure title="Retargeting" anchor="retargeting">
              <artwork><![CDATA[
      +---+             +-------+             +---+             +---+
      | A |             | PROXY |             | B |             | C |
      +---+             +-------+             +---+             +---+
            Request
        -------------------->      
                                   Request
			    -------------------->
                                   Redirect
			    <--------------------
	    Redirect		       
        <-------------------
                                   Request
        ---------------------------------------------------------->
    ]]></artwork>
            </figure>
</t>

	    <t>In the second scenario, a proxy decides to redirect the 
	      session without informing the originator. This is a common 
	      scenario specified in SIP <xref target="RFC3261"/>.
	      </t>

	  </section>
	  
	  <section title="Deferred Delivery">
	    <t>Deferred delivery is a type of service such that the session 
	      content cannot be delivered to the destination at the time that 
	      it is being sent (e.g., the destination user is not currently 
	      online). Nevertheless, the sender expects the network to deliver 
	      the message as soon as the recipient becomes available. A 
	      typical example of deferred delivery is voicemail.</t>
	  </section>

	

  </section>

	<section title="MIKEY-IBAKE Protocol Description">
	  
	  <section title="Overview" anchor="overview">

	    <t>Most of the previously defined MIKEY modes consist of a single 
	      (or half) roundtrip between two peers.
	      MIKEY-IBAKE consists of up to three  
	      roundtrips. In the first roundtrip, users (Initiator and 
	      Responder) obtain their Private Key(s) (K_PR) from the KMS. This 
	      roundtrip can be performed at anytime and, as explained earlier, 
	      takes place, for example, once a month (or once per subscription 
	      cycle). The second and the third 
	      roundtrips are between the Initiator and the Responder. Observe 
	      that the Key Management Service is only involved in the first 
	      roundtrip. In <xref target="example"/>, a conceptual
	      signaling diagram for the MIKEY-IBAKE mode is depicted.</t>
<t>
            <figure title="Example Message Exchange" anchor="example">
              <artwork><![CDATA[
   +---+             +------+         +------+                 +---+
   | I |             | KMS1 |         | KMS2 |                 | R |
   +---+             +------+         +------+                 +---+
       REQUEST_KEY_INIT                       REQUEST_KEY_INIT
     ------------------>                  <---------------------- 
       REQUEST_KEY_RESP                       REQUEST_KEY_RESP
     <------------------                  ---------------------->        
                               I_MESSAGE_1
     ----------------------------------------------------------->
                               R_MESSAGE_1
     <-----------------------------------------------------------
                               I_MESSAGE_2
     ----------------------------------------------------------->
                               R_MESSAGE_2
     <-----------------------------------------------------------

]]></artwork>
            </figure>
</t>

<t>The Initiator (I) wants to establish a secure media session with the
   Responder (R).  The Initiator and the Responder trust a third party, 
  the Key Management
   Service (KMS), with which they both have, or can establish, shared
   credentials.  These pre-established trust relations are used by a 
  user (i.e., Initiator and Responder) to obtain Private Keys. Rather than a single KMS, 
  several different KMSs may be
   involved, e.g., one for the Initiator and one for the Responder as shown 
  in <xref target="example"/>. The Initiator and the Responder 
  do not share any 
 credentials; however, the Initiator knows the Responder's public identity. The 
assumed trust model is illustrated
   in <xref target="trustmodel"/>.
</t> 

<t>
            <figure title="Trust Model" anchor="trustmodel">
              <artwork><![CDATA[
   +---+             +------+         +------+                 +---+
   | I |             | KMS1 |         | KMS2 |                 | R |
   +---+             +------+         +------+                 +---+
       Pre-established                         Pre-established
        trust relation                         trust relation 
     <----------------->                  <--------------------->
        
         Security association based on mutual authentication
                performed during MIKEY-IBAKE exchange 
     <---------------------------------------------------------->
                             

]]></artwork>
            </figure>
</t>

<t>Below, 
  a description of how Private Keys are obtained using MIKEY messages is provided. An alternative way for obtaining Private Keys using HTTP is described in  
  <xref target="RFC5408"/>.</t> 

   <t>The Initiator obtains Private Key(s) 
   from the KMS by sending a REQUEST_KEY_INIT message.  The REQUEST_KEY_INIT
   message includes Initiator's public identity(s) (if the Initiator has 
   more than one public identity, it may request Private Keys for 
  every identity registered) and is protected via a MAC based on a 
  pre-shared key or
   via a signature (similar to the MIKEY-PSK and MIKEY-RSA modes).  If
   the request is authorized, the KMS generates
   the requested keys, encodes them, and returns them 
   in a REQUEST_KEY_RESP message. 

     This exchange takes place periodically and 
     does not need to be performed every time an Initiator needs to 
     establish a secure connection with a Responder.</t>

   <t> The Initiator next chooses a random x and computes [x]P, where P is a point on elliptic curve E known to all users. 
The Initiator uses the Responder's public identity to generate the Responder's 
Public Key (e.g., K_PUBr=H1(IDRr||date)), where Hi is hash function known to all 
     users, and the granularity in date is a matter of security policy and 
     known publicly. 
Then the Initiator uses this generated Public Key to encrypt [x]P, IDRi and IDRr and includes 
this encrypted information in an I_MESSAGE_1 message,
   which is sent to the Responder. The encryption is Identity-Based Encryption 
(IBE) as specified in <xref target="RFC5091"/> and <xref target="RFC5408"/>. 
In turn, the Responder IBE-decrypts the received  message using its Private Key for that date, chooses 
random y and 
computes 
[y]P.&nbsp; Next, the Responder uses Initiator's identity obtained from I_MESSAGE_1 
to generate 
Initiator's Public Key (e.g., K_PUBi=H1(IDRi||date)) and IBE-encrypts (IDRi, IDRr, [x]P, [y]P) 
     using K_PUBi, 
and includes it in R_MESSAGE_1 message sent to the Initiator. At 
this point, the Responder is able to generate the session key as 
[x][y]P.&nbsp; This session key is then used to generate TGK as specified in 
 <xref target="Ksess"/>.</t>

    <t>Upon receiving and IBE-decrypting an R_MESSAGE_1 message, the Initiator 
 verifies the received [x]P. &nbsp; At 
this point, the Initiator is able to generate the same session key  
      as [x][y]P.&nbsp; Upon successful verification, the Initiator sends I_MESSAGE_2 message to the Responder, including IBE-encrypted IDRi, IDRr  
      and previously received [y]P.&nbsp; The Responder sends a R_MESSAGE_2 message 
      to the Initiator as verification. </t>

<t>  The above described is the most typical use case; in
  <xref target="usecases"/>, some alternative use cases are discussed. </t>

<t>MIKEY-IBAKE is based on <xref target="RFC3830"/>; therefore, the same terminology,
   processing, and considerations still apply unless otherwise stated.
   Payloads containing EC Diffie-Hellman values and keys exchanged in I_MESSAGE/R_MESSAGE are IBE 
  encrypted as specified in <xref target="RFC5091"/> and 
  <xref target="RFC5408"/>, while the keys exchanged 
  in KEY_REQUES_INIT/KEY_REQUEST_RESPONSE are encrypted as specified in 
   <xref target="RFC3830"/>. In all exchanges, encryption is only applied to the payloads containing keys and EC Diffie-Hellman values and
   not to the entire messages.</t>


	  </section>
	<section title="Message Exchanges and Processing">
	  <section title="REQUEST_KEY_INIT/REQUEST_KEY_RESP Message Exchange">

   <t>This exchange is used by a user (e.g., Initiator or Responder) to 
     request Private Keys from a trusted Key Management Service, with which the 
     user has pre-shared credentials.  A full roundtrip is
   required for a user to receive keys.  As
   this message must ensure the identity of the user to the KMS, it
   is protected via a MAC based on a pre-shared key or via a signature.
   The initiation message REQUEST_KEY_INIT comes in two variants
   corresponding to the pre-shared key (PSK) and Public-Key encryption
   (PKE) methods of <xref target="RFC3830"/>.  The response message 
     REQUEST_KEY_RESP is the
   same for the two variants and SHALL be protected by using the 
     pre-shared/envelope key indicated in the REQUEST_KEY_INIT message.</t>

<t>
            <figure>
              <artwork><![CDATA[
   Initiator/Responder                    KMS

   REQUEST_KEY_INIT_PSK =          ---->
   HDR, T, RAND, (IDRi/r),
   IDRkms, [IDRpsk], [KEMAC], V    <----  REQUEST_KEY_RESP =
				            HDR, T, [IDRi/r], [IDRkms], 
				            KEMAC, V
                                              

   REQUEST_KEY_INIT_PKE =          ---->
   HDR, T, RAND, (IDRi/r),
      {CERTi/r}, IDRkms,           <----  REQUEST_KEY_RESP =
      [KEMAC], [CHASH],                     HDR, T, [IDRi/r], [IDRkms], 
      PKE, SIGNi/r                          KEMAC, V
]]></artwork>
            </figure>
</t>


   <section title="Components of the REQUEST_KEY_INIT Message">
     <t>The main objective of the REQUEST_KEY_INIT message is for a user to
       request one or more Private Keys (K_PR) from the KMS. The user may 
       request
       a K_PR for each public identity it possesses, as well as for multiple 
       dates. </t>  

     <t>The REQUEST_KEY_INIT message MUST always include the Header (HDR),
       Timestamp (T), and RAND payloads. The CSB ID (Crypto Session Bundle ID) 
       SHALL be assigned as in 
       <xref target="RFC3830"/>. The user SHALL include it in the CSB ID field of the 
       Header. The user SHALL
       set the #CS field to '0' since CS (Crypto Session(s))
       SHALL NOT be handled. The CS ID map
       type SHALL be the "Empty map" as defined in  <xref target="RFC4563"/>.
     </t>

     <t>IDRi/r contains the identity of the user. Since the user may 
       have multiple 
       identities, multiple IDRi/r fields may appear in the message.</t>

     <t>IDRkms SHALL be included.</t>

     <t>The KEMAC payload SHALL be used only when the user needs to use
       specific keys. Otherwise, this payload SHALL NOT be used.</t>

     <section title="Components of the REQUEST_KEY_INIT_PSK Message">
       <t>The IDRpsk payload MAY be used to indicate the pre-shared key used.</t>

       <t>The last payload SHALL be a Verification (V) payload where the
	 authentication key (auth_key) is derived from the pre-shared key (see
	 Section 4.1.4 of <xref target="RFC3830"/> for key derivation 
	       specification).</t>

     </section>

     <section title="Components of the REQUEST_KEY_INIT_PKE Message">
       <t>The certificate (CERT) payload SHOULD be included.  If a certificate chain is to be
   provided, each certificate in the chain MUST be included in a
   separate CERT payload.</t>

   <t>The PKE payload contains the encrypted envelope key: 
     PKE = E(PKkms, env_key).  It
   is encrypted using the KMS's Public Key (PKkms).  If the KMS
   possesses several Public Keys, the user can indicate the key
   used in the CHASH payload.</t>

   <t>SIGNi/r is a signature covering the entire MIKEY message, using the
   Initiator's signature key.</t>


     </section>
</section>
     <section title="Processing of the REQUEST_KEY_INIT Message">
       <t>If the KMS can verify the integrity of the received message and the
   message can be correctly parsed, the KMS MUST check the Initiator's
   authorization.  If the Initiator is authorized to receive the
   requested Private Key(s), the KMS
   MUST send a REQUEST_KEY_RESP message.  Unexpected payloads in the
   REQUEST_KEY_INIT message SHOULD be ignored.  Errors are handled as
   described in <xref target="RFC3830"/>.</t>


     </section>
     <section title="Components of the REQUEST_KEY_RESP Message">
     <t>The version, PRF func and CSB ID, #CS, and CS ID map type fields in
   the HDR payload SHALL be identical to the corresponding fields in the
   REQUEST_KEY_INIT message. The KMS SHALL set the V flag to 0 and the user 
       receiving it SHALL ignore it as it has no meaning
       in this context.</t>

     <t>The Timestamp type and value SHALL be identical to the one used in
       the REQUEST_KEY_INIT message.</t>
<t>
            <figure>
              <artwork><![CDATA[
                   KEMAC = E(encr_key, (ID || K_PR))
]]></artwork>
            </figure>
</t>

    <t>The KEMAC payload SHOULD use the NULL authentication algorithm, as a
      MAC is included in the V payload.  Depending on the type of
      REQUEST_KEY_INIT message, either the pre-shared key or the envelope key
      SHALL be used to derive the encr_key.</t>

   <t>The last payload SHALL be a Verification (V) payload.  Depending on
   the type of REQUEST_KEY_INIT message, either the pre-shared key or the
   envelope key SHALL be used to derive the auth_key.</t>


       </section>

     <section title="Processing of the REQUEST_KEY_RESP Message">

       <t>If the Initiator/Responder can correctly parse the received message, 
	 the received session information SHOULD be stored.  Otherwise,
	 the Initiator/Responder SHOULD silently discard the message and 
	 abort the protocol.</t>

     </section>
</section>
      <section title="I_MESSAGE/R_MESSAGE Message Exchanges">
	<t>This exchange is used for Initiator and Responder to mutually 
	  authenticate each other and to exchange EC Diffie-Hellman values 
	  used to generate TGK. These exchanges are
	  modeled after the pre-shared key mode, with the exception 
	  that the Elliptic Curve Diffie-Hellman values and Secret Keys (SKs) 
	  are encoded 
	  in IBAKE and ESK payloads instead of a KEMAC payload.   
	  Two full roundtrips are required for 
	  this exchange to successfully complete. The messages are preferably 
	  included in the session setup signaling (e.g., SIP INVITE).</t>

<t>
            <figure>
              <artwork><![CDATA[
Initiator                               Responder

   I_MESSAGE_1 =                    ---->
   HDR, T, RAND, IDRi, IDRr,
      IBAKE, [ESK]                  <----  R_MESSAGE_1 =
                                             HDR, T, IDRi,
                                             IDRr, IBAKE

   I_MESSAGE_2 =                    ---->
   HDR, T, RAND, IDRi, IDRr,
      IBAKE, [ESK]                  <----  R_MESSAGE_2 =
                                           HDR, T, [IDRi], [IDRr],
                                           [IBAKE], V

]]></artwork>
            </figure>
</t>
      

      <section title="Components of the I_MESSAGE_1 Message">
	<t>The I_MESSAGE_1 message MUST always include the Header (HDR),
	  Timestamp (T), and RAND payloads.  The CSB ID (Crypto Session 
	  Bundle ID) SHALL be randomly selected by the Initiator.  As the
	  R_MESSAGE_1 message is mandatory, the Initiator indicates with 
	  the V flag that a verification message is expected.</t>

	<t>The IDRi and IDRr payloads SHALL be included.</t>

	<t>The IBAKE payload 
	  contains Initiator's Identity and EC Diffie-Hellman values (ECCPTi), 
	  and 
	  Responder's Identity all encrypted using Responder's 
	  Public Key 
	  (i.e., encr_key = K_PUBr) as follows:</t>
<t>
            <figure>
              <artwork><![CDATA[
                   IBAKE = E(encr_key, IDRi || ECCPTi || IDRr)
]]></artwork>
            </figure>
</t>

	
	<t>Optionally, Encrypted Secret Key (ESK) payload MAY be included.  
	  If included, ESK contains an identity and a Secret Key (SK) 
	  encrypted using intended Responder's Public Key (i.e., encr_key = K_PUBr).</t>
<t>
            <figure>
              <artwork><![CDATA[
                   ESK = E(encr_key, ID || SK)
]]></artwork>
            </figure>
</t>
 

			      
     </section>

      <section title="Processing of the I_MESSAGE_1 Message">
	<t>The parsing of I_MESSAGE_1 message SHALL be done as in 
	  <xref target="RFC3830"/>. If the received message is correctly 
	  parsed, the Responder SHALL use the Private Key (K_PRr) 
	  corresponding to the 
	  received IDRr to decrypt the IBAKE payload. If the message contains 
	  ESK payload, the Responder SHALL decrypt the SK and use it to decrypt 
	  the received IBAKE payload. Otherwise, if the Responder is not able 
	  to 
	  decrypt the IBAKE payload, 
	  the Responder SHALL indicate it to the Initiator 
	  by including only its own EC Diffie-Hellman value (ECCPTr) in the 
	  next message (i.e., R_MESSAGE_1) it sends to the 
	  Initiator.</t>

	  <t>If the received message cannot be 
	  correctly parsed, the Responder SHOULD silently discard the 
	  message and abort the protocol.</t>



	</section>

<section title="Components of the R_MESSAGE_1 Message">
	<t>The version, PRF func, CSB ID, #CS, and CS ID map type fields in
   the HDR payload SHALL be identical to the corresponding fields in the
	  I_MESSAGE_1 message. The V flag SHALL be set
	  to 1 as I_MESSAGE_2 message is mandatory.</t>

	<t>The Timestamp type and value SHALL be identical to the one used in
	  the I_MESSAGE_1 message.</t>



	<t>The IDRi and IDRr payloads SHALL be included. The IDRi payload 
	  SHALL be as received in the I_MESSAGE_1. In the IDRr payload, 
	  the Responder SHALL include its own identity. Note that this 
	  identity might be different from the identity contained in the 
	  IDRr payload received in I_MESSAGE_1 message. The IDRr payloads 
	  of I_MESSAGE_1 and R_MESSAGE_1 will be different in the case of 
	  forking, retargeting, and deferred delivery.</t>

	<t>The Responder's IBAKE payload
	  contains the Initiator's EC Diffie-Hellman value (ECCPTi) 
	  received in I_MESSAGE_1 (if successfully 
	  decrypted), and the Initiator's EC Diffie-Hellman value generated by 
	  the Responder (ECCPTr), as well as corresponding Initiator and 
	  Responder's 
	  identities. If the Responder is unable to decrypt the IBAKE payload received in I_MESSAGE_1 (e.g., the message is received by the intended Responder's mailbox), the Responder SHALL include only its own  EC Diffie-Hellman value (ECCPTr). The IBAKE payload in R_MESSAGE_1 is encrypted using Initiator's Public Key 
	  (i.e., encr_key = P_PUBi) as follows:</t>
<t>
            <figure>
              <artwork><![CDATA[
        IBAKE = E(encr_key, IDRi || {ECCPTi} || IDRr || ECCPTr)
]]></artwork>
            </figure>
</t>

			      
     </section>

      <section title="Processing of the R_MESSAGE_1 Message">
	<t>The parsing of R_MESSAGE_1 message SHALL be done as in 
	  <xref target="RFC3830"/>. If the received message is correctly 
	  parsed, the Initiator shall use the Private Key corresponding to the 
	  received IDRi to decrypt the IBAKE payload. If the ECCPTi sent in 
	  I_MESSAGE_1 is not 
	  present in the received IBAKE payload (e.g., the Responder is 
	  currently 
	  offline and the R_MESSAGE_1 is received from Responder's mailbox), 
	  the Initiator SHALL include ECCPTi again in the next message, 
	  I_MESSAGE_2. 
	  In this case, I_MESSAGE_2  
	  SHALL also contain an ESK payload encrypted using the intended recipient's 
	  K_PUB.</t>

	<t>If the received message cannot be 
	  correctly parsed, the Initiator SHOULD silently discard the 
	  message and abort the protocol.</t>

	</section>

 <section title="Components of the I_MESSAGE_2 Message">
	<t>The I_MESSAGE_2 message MUST always include the Header (HDR),
	  Timestamp (T), and RAND payloads.  The version, PRF func, CSB ID, #CS, and CS ID map type fields in
   the HDR payload SHALL be identical to the corresponding fields in the
	  R_MESSAGE_2 message. 
	  As the R_MESSAGE_2 message is mandatory, the Initiator indicates with 
	  the V flag that a verification message is expected.</t>

	<t>The IDRi and IDRr payloads SHALL be included. The IDRr payload SHALL 
	  be the same as the IDRr payload received in the R_MESSAGE_1.</t>

	<t>The Initiator's IBAKE payload SHALL
	  contain the Initiator's EC Diffie-Hellman value (ECCPTi) if the ECCPTi was not received in R_MESSAGE_1. Otherwise, ECCPTi SHALL NOT be included. The IBAKE payload in I_MESSAGE_2 SHALL contain  
	  the Initiator's and Responder's identities as well as Responder's EC Diffie-Hellman value received in message R_MESSAGE_1. IBAKE payload SHALL be 
	  encrypted using Responder's 
	  Public Key (i.e., encr_key = K_PUBr) as follows:</t>
<t>
            <figure>
              <artwork><![CDATA[
          IBAKE = E(encr_key, IDRi || {ECCPTi} || IDRr || ECCPTr)
]]></artwork>
            </figure>
</t>
 
<t>Optionally, Encrypted Secret Key (ESK) payload can be included. 
  ESK SHALL be included in case R_MESSAGE_1 did not contain Initiator's EC Diffie-Hellman value (ECCPTi) (e.g., in the case of deferred delivery).
	  If included, it contains an Initiator's identity and Initiator-generated Secret Key (SK) 
	  encrypted using intended recipient Public Key 
	  (i.e., encr_key = K_PUB) as follows:</t>
<t>
            <figure>
              <artwork><![CDATA[
                   ESK = E(encr_key, ID || SK)
]]></artwork>
            </figure>
</t>

			      
     </section>

      <section title="Processing of the I_MESSAGE_2 Message">
	<t>The parsing of the I_MESSAGE_2 message SHALL be done as in 
	  <xref target="RFC3830"/>. If the received message is correctly 
	  parsed, the Responder shall use the K_PRr corresponding to the 
	  received IDRr to decrypt the IBAKE payload. If an ESK is received, 
	  the Responder 
	  SHALL store it for future use (e.g., the Responder is a mailbox 
	  and will forward the key to the user once the user is online).</t>
	
	<t>If the received message cannot be 
	  correctly parsed, the Responder SHOULD silently discard the 
	  message and abort the protocol.</t>
	</section>

<section title="Components of the R_MESSAGE_2 Message">
	<t> The version, PRF func, CSB ID, #CS, and CS ID map type fields in
   the HDR payload SHALL be identical to the corresponding fields in the
	  I_MESSAGE_2 message. The V flag SHALL be set
	  to 0 by the Responder and ignored by the Initiator.</t>

	<t>The Timestamp type and value SHALL be identical to the one used in
	  the I_MESSAGE_2 message.</t>

	<t>The IDRi and IDRr payloads SHOULD be included.</t>

	<t>If Initiator's EC Diffie-Hellman value 
	  (ECCPTi) was received in I_MESSAGE_2, the Responder SHALL also include 
	  the IBAKE payload. If included, the IBAKE payload SHALL contain
	  Initiator's EC Diffie-Hellman value (ECCPTi), 
	  and the Initiator's identity previously received in I_MESSAGE_2, 
	  encrypted using Initiator's 
	  Public Key (i.e., encr_key = K_PUBi) as follows:</t>
<t>
            <figure>
              <artwork><![CDATA[
                 IBAKE = E(encr_key, IDRi || ECCPTi)
]]></artwork>
            </figure>
</t>

	<t>The last payload SHALL be a Verification (V) payload where the
	  authentication key (auth_key) is derived as specified in
	  <xref target="Kmikeymes"/>.</t>
			      
     </section>

      <section title="Processing of the R_MESSAGE_2 Message">
	<t>The parsing of R_MESSAGE_2 message SHALL be done as in 
	  <xref target="RFC3830"/>. If the received message is correctly 
	  parsed, and if it contains the IBAKE payload, the Initiator SHALL 
	  use the K_PRi corresponding to the 
	  received IDRi to decrypt the IBAKE payload.</t>

	<t>If the received message cannot be 
	  correctly parsed, the Initiator SHOULD silently discard the 
	  message and abort the protocol.</t>

	</section>
	</section>
	</section>			       
	</section>
	

	<section title="Key Management">
	  <t>The keys used in REQUEST_KEY_INIT/REQUEST_KEY_RESP 
	    exchange are derived from the pre-shared key or the envelope 
	    key as specified in <xref target="RFC3830"/>.  As crypto
   sessions are not handled in this exchange, further keying material (i.e., TEKs)
   for this message exchange SHALL NOT be derived.</t>

	  <section title="Generating Keys from the Session Key" anchor="Ksess">
	    <t>As stated above, the session key [x][y]P is generated using 
	      exchanged EC Diffie-Hellman values, where x and y are randomly 
	      chosen 
	      by the Initiator and Responder. The session key, as a point on an 
	      elliptic curve, is then 
	      converted into octet string  as specified 
	      in <xref target="SEC1"/>. This octet string K_SESSION is then 
	      used to generate MPK and TGK. Finally, 
	      the traffic encryption keys (e.g., TEK) are generated
   from TGK as specified in <xref target="RFC3830"/>.

</t>

	    <t>The MPK and TGK are generated from K_SESSION as follows.</t>

<t>
            <figure>
              <artwork><![CDATA[
   inkey      : K_SESSION
   inkey_len  : bit length of the MPK
   label      : constant || 0xFF || 0xFFFFFFFF || RAND
   outkey_len : desired bit length of the output key (MPK or TGK)
]]></artwork>
            </figure>
</t>

            <t>The constant depends on the derived key type as
   summarized below.</t>

<texttable title='Constants for Key Derivation' anchor='K_Stable'>
<ttcol align='center'>Derived Key</ttcol>
<ttcol align='center'>Constant</ttcol>
<c>MPK</c>
<c>0x220E99A2</c>
<c>TGK</c>
<c>0x1F4D675B</c>
</texttable>

<t>The constants are taken from the decimal digits of e as described in
   <xref target="RFC3830"/>.</t>



 
	    </section>
	  <section title="Generating Keys for MIKEY Messages" anchor="Kmikeymes">
	    
	    <t> The keys for MIKEY messages are used to protect the MIKEY
   messages exchanged between the Initiator and Responder (i.e., I_MESSAGE 
	      and R_MESSAGE).  In the REQUEST_KEY_INIT/REQUEST_KEY_RESP 
	      exchange, the
   key derivation SHALL be done exactly as in <xref target="RFC3830"/>.</t>

	    <t>MIKEY Protection Key (MPK) for I_MESSAGE/R_MESSAGE exchange is generated as described in <xref target="Ksess"/>. This MPK is then used to derive keys to 
	      protect R_MESSAGE_2 message.</t>
<t>
            <figure>
              <artwork><![CDATA[
   inkey      : MPK
   inkey_len  : bit length of the MPK
   label      : constant || 0xFF || csb_id || RAND
   outkey_len : desired bit length of the output key
]]></artwork>
            </figure>
</t>
   <t>where the constants are as defined in <xref target="RFC3830"/>.  
     </t>

	     

	    </section>

	  <section title="CSB Update">
	    <t>Similar to <xref target="RFC3830"/>, MIKEY-IBAKE provides 
	      means for updating the
   CSB (Crypto Session Bundle), e.g., transporting new EC Diffe-Hellman values
	      or adding
   new crypto sessions.  The CSB updating is done by executing the
   exchange of I_MESSAGE_1/R_MESSAGE_1. The CSB updating MAY be started by
   either the Initiator or the Responder.</t>

<t>
            <figure>
              <artwork><![CDATA[
   Initiator                               Responder

   I_MESSAGE_1 =                 ---->
   HDR, T, [IDRi], [IDRr],
      [IBAKE]                    <----     R_MESSAGE_1 =
                                           HDR, T, [IDRi], [IDRr], 
                                           [IBAKE], V


   Responder                               Initiator

   I_MESSAGE_1 =                 ---->
   HDR, T, [IDRr], [IDRi],
      [IBAKE]                    <----     R_MESSAGE_1 =
                                           HDR, T, [IDRi], [IDRr],
                                           [IBAKE], V
]]></artwork>
            </figure>
</t>
<t>The new message exchange MUST use the same CSB ID as the initial
   exchange, but MUST use a new Timestamp. Other 
   payloads that were provided in the initial exchange SHOULD NOT be
   included.  New RANDs MUST NOT be included in the message exchange
   (the RANDs will only have effect in the initial exchange).</t>

   <t>IBAKE payload with new EC Diffie-Hellman values SHOULD be included. 
     If new EC Diffie-Hellman values  are
     being exchanged during CSB updating, messages SHALL be protected 
     with keys
   derived from EC Diffie-Hellman values exchanged as specified in 
     <xref target="Kmikeymes"/>.
     Otherwise, if new EC Diffie-Hellman values are not being exchanged 
     during CSB update 
     exchange, messages
   SHALL be protected with the keys that protected the I_MESSAGE/R_MESSAGE
   messages in the initial exchange.  
</t>  


	    </section>

	  <section title="Generating MAC and Verification Message">
	    <t>The authentication tag in all MIKEY-IBAKE  messages is generated 
	      as described in <xref target="RFC3830"/>. As described 
	      above, the MPK is used to derive the auth_key. The MAC/Signature in the 
	      V/SIGN payloads covers the entire MIKEY
   message, except the MAC/Signature field itself and if there is an ESK 
	      payload in the massage it SHALL be omitted from MAC/Signature 
	      calculation.  
	      The identities (not
   whole payloads) of the involved parties MUST directly follow the
   MIKEY message in the Verification MAC/Signature calculation.  Note
   that in the I_MESSAGE/R_MESSAGE exchange, IDRr in R_MESSAGE_1
   MAY not be the same as that appearing in I_MESSAGE_1.
</t>
	</section>
	</section>



	<section title="Payload Encoding">

	  <t>This section does not describe all the payloads that are used 
	    in the new message types.  It describes in detail the new IBAKE and
	    ESK
	    payloads and in less detail the payloads for which changes has 
	    been made compared to <xref target="RFC3830"/>. For a detailed 
	    description of 
	    the MIKEY payloads (e.g., Timestamp (T) payload, RAND payload, etc.), see <xref target="RFC3830"/>. For the 
	    description of IDR payload as well as for the definition of 
	    additional PRF functions and encryption algorithms not 
	    defined in <xref target="RFC3830"/>, see 
	    <xref target="RFC6043"/>.</t>

	  <section title="Common Header Payload (HDR)">

	    <t>For the Common Header Payload, new values are added to the 
	      data type and the next payload namespaces.</t>
<t>
	    <list style='symbols'>
                <t>Data type (8 bits): describes the type of message.</t>
                
            </list>
</t>
<texttable title='Data Type (Additions)' anchor='DTtable'>
<ttcol align='center'>Data Type</ttcol>
<ttcol align='center'>Value</ttcol>
<ttcol align='center'>Comment</ttcol>
<c>REQUEST_KEY_PSK</c>
<c>19</c>
<c>Request Private Keys message (PSK)</c>
<c>REQUEST_KEY_PKE</c>
<c>20</c>
<c>Request Private Keys message (PKE)</c>
<c>REQUEST_KEY_RESP</c>
<c>21</c>
<c>Response Private Keys message</c>
<c>I_MESSAGE_1</c>
<c>22</c>
<c>First Initiator's message</c>
<c>R_MESSAGE_1</c>
<c>23</c>
<c>First Responder's message</c>
<c>I_MESSAGE_2</c>
<c>24</c>
<c>Second Initiator's message</c>
<c>R_MESSAGE_2</c>
<c>25</c>
<c>Second Responder's message</c>
</texttable>




<t>
	    <list style='symbols'>
                <t>Next payload (8 bits): identifies the payload that is 
		  added after this payload.</t>
                
            </list>
</t>
<texttable title='Next Payload (Additions)' anchor='NPtable'>
<ttcol align='center'>Next Payload</ttcol>
<ttcol align='center'>Value</ttcol>
<ttcol align='center'>Section</ttcol>
<c>IBAKE</c>
<c>22</c>
<c><xref target="IBAKEpld"/></c>
<c>ESK</c>
<c>23</c>
<c><xref target="ESKpld"/></c>
<c>SK</c>
<c>24</c>
<c><xref target="SKpld"/></c>
<c>ECCPT</c>
<c>25</c>
<c><xref target="ECDHpld"/></c>
</texttable>


<t>
	    <list style='symbols'>
                <t>V (1 bits): flag to indicate whether or not a response message is
		  expected (this only has meaning when it is set in an
		  initiation message).  If a response is required, the V flag 
		  SHALL always be set to 1 in the
		  initiation messages and the receiver of the initiation message
		  (Responder or KMS) SHALL ignore it.</t>

		<t>#CS (8 bits): indicates the number of crypto sessions 
		  that will be handled within the CSB.  It SHALL be set to 0 
		  in the Request Key exchange, as crypto sessions SHALL NOT
		  be handled.</t>

		<t>CS ID map type (8 bits): specifies the method of uniquely 
		  mapping crypto sessions to the security protocol sessions.  
		  In the Request Key exchange, the CS ID map type SHALL be
		  the "Empty map" (defined in <xref target="RFC4563"/>) as 
		  crypto sessions SHALL NOT be handled.</t>

</list>
</t>

      <section title="IBAKE Payload" anchor="IBAKEpld">
	<t>The IBAKE payload contains IBE encrypted (see 
	  <xref target="RFC5091"/> and <xref target="RFC5408"/> for details
	  about IBE) Initiator and Responder's Identities and 
	  EC Diffie-Hellman
	  Sub-Payloads (see <xref target="ECDHpld"/> for the definition of 
	  EC Diffie-Hellman
	  Sub-Payload). It may contain one or more EC Diffie-Hellman
	  Sub-Payloads and 
	  their associated identities. The last EC Diffie-Hellman or Identity
	  Sub-Payload has its
	  Next payload field set to Last payload.</t>

  
<t>
            <figure>
              <artwork><![CDATA[
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ! Next payload  ! Encr data len                 !  Encr data    !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !                        Encr data                              ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ]]></artwork>
            </figure>
</t>
<t>
	    <list style='symbols'>
	      <t>Next payload (8 bits): identifies the payload that is added 
		after this payload.</t>

	      <t>Encr data len (16 bits): length of Encr data (in bytes).</t>

	      <t>Encr data (variable length): the IBE encrypted EC Diffie-Hellman Sub-Payloads 
		(see <xref target="ECDHpld"/>) and their associated Identity 
		payloads.</t>

</list>
</t>
      </section>

      <section title="Encrypted Secret Key (ESK) Payload"  anchor="ESKpld">
	<t>The Encrypted Secret Key payload contains IBE encrypted (see 
	  <xref target="RFC5091"/> and <xref target="RFC5408"/> for details
	  about IBE) Secret Key Sub-Payload and its associated 
	  identity (see  <xref target="SKpld"/> for the definition of the 
	  Secret Key Sub-Payload).</t>
<t>
            <figure>
              <artwork><![CDATA[
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ! Next payload  ! Encr data len                 !  Encr data    !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !                        Encr data                              ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ]]></artwork>
            </figure>
</t>
<t>
	    <list style='symbols'>
	      <t>Next payload (8 bits): identifies the payload that is added 
		after this payload.</t>

	      <t>Encr data len (16 bits): length of Encr data (in bytes).</t>

	      <t>Encr data (variable length): the encrypted secret key Sub-Payloads 
		(see <xref target="SKpld"/>).</t>

</list>
</t>
      </section>

      <section title="Key Data Sub-Payload"  anchor="KDpld">

   <t>For the key data Sub-Payload, a new type of key is defined.  The
   Private Key (K_PR) is used to decrypt the content encrypted using the 
     corresponding Public Key (K_PUB). KEMAC in the REQUEST_KEY_RESP SHALL 
     contain one or more Private Keys.</t>
<t>
	    <list style='symbols'>
                <t>Type (4 bits): indicates the type of key included in the 
		  payload.</t>
</list>
</t>

<texttable title='Key Data Type (Additions)' anchor='KDtable'>
<ttcol align='center'>Type</ttcol>
<ttcol align='center'>Value</ttcol>
<ttcol align='center'>Comments</ttcol>
<c>K_PR</c>
<c>7</c>
<c>Private Key</c>
</texttable>

        </section>

<section title="EC Diffie-Hellman Sub-Payload" anchor="ECDHpld">

   <t> The EC Diffie-Hellman (ECCPT) Sub-Payload uses the format defined below. The EC Diffie-Hellman Sub-Payload in MIKEY-IBAKE is never included in clear, but as an encrypted part of the
   IBAKE payload.</t>
<t>
            <figure>
              <artwork><![CDATA[
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ! Next payload  ! ECC Curve     ! ECC Point                     ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ! Auth alg      ! TGK len                       ! Reserv! KV    !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ! KV data (optional)                                            ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
            </figure>
</t>
<t>
	    <list style='symbols'>
	      <t>Next payload (8 bits): identifies the payload that is added 
		after
     this payload.  See Section 6.1 of <xref target="RFC3830"/> for values.</t>

	      <t>ECC curve (8 bits): identifies the ECC curve used.</t>
</list>
</t>


<texttable title='Elliptic Curves' anchor='ECTtable'>
<ttcol align='center'>ECC Curve</ttcol>
<ttcol align='center'>Value</ttcol>
<c>ECPRGF192Random  / P-192 / secp192r1</c>
<c>1</c>
<c>EC2NGF163Random  / B-163 / sect163r2</c>
<c>2</c>
<c>EC2NGF163Koblitz / K-163 / sect163k1</c>
<c>3</c>
<c>EC2NGF163Random2 / none  / sect163r1</c>
<c>4</c>
<c>ECPRGF224Random  / P-224 / secp224r1</c>
<c>5</c>
<c>EC2NGF233Random  / B-233 / sect233r1</c>
<c>6</c>
<c>EC2NGF233Koblitz / K-233 / sect233k1</c>
<c>7</c>
<c>ECPRGF256Random  / P-256 / secp256r1</c>
<c>8</c>
<c>EC2NGF283Random  / B-283 / sect283r1</c>
<c>9</c>
<c>EC2NGF283Koblitz / K-283 / sect283k1</c>
<c>10</c>
<c>ECPRGF384Random  / P-384 / secp384r1</c>
<c>11</c>
<c>EC2NGF409Random  / B-409 / sect409r1</c>
<c>12</c>
<c>EC2NGF409Koblitz / K-409 / sect409k1</c>
<c>13</c>
<c>ECPRGF521Random  / P-521 / secp521r1</c>
<c>14</c>
<c>EC2NGF571Random  / B-571 / sect571r1</c>
<c>15</c>
<c>EC2NGF571Koblitz / K-571 / sect571k1</c>
<c>16</c>
</texttable>
<t>
	    <list style='symbols'>
	      <t>ECC point (variable length): ECC point data, padded to end on a
     32-bit boundary, encoded in octet string representation.</t>

	      <t>Auth alg (8 bits): specifies the MAC algorithm used for the
     verification message. For MIKEY-IBAKE this field is ignored. </t>

	      <t>TGK len (16 bits): the length of the TGK (in bytes).
		 For MIKEY-IBAKE this field is ignored. </t>

	      <t>KV (4 bits): indicates the type of key validity period 
		specified.
     This may be done by using an SPI (alternatively an MKI in SRTP) or
     by providing an interval in which the key is valid (e.g., in the
     latter case, for SRTP this will be the index range where the key
     is valid).  See Section 6.13 of <xref target="RFC3830"/> for pre-defined values.</t>

	      <t>KV data (variable length): This includes either the 
		SPI/MKI or an
     interval (see Section 6.14 of <xref target="RFC3830"/>).  If KV is NULL, this
     field is not included.</t>


</list>
</t>
</section>

<section title="Secret Key Sub-Payload" anchor="SKpld">

  <t>Secret Key payload is included as a Sub-Payload in Encrypted Secret 
    Key payload. Similar to EC Diffie-Hellman Sub-Payload, it is never 
    included in clear, but as an encrypted part of the
   ESK payload.</t>
<t>
            <figure>
              <artwork><![CDATA[
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !  Next Payload ! Type  ! KV    ! Key data len                  !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !                         Key data                              ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !                        KV data (optional)                     ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

]]></artwork>
            </figure>
</t>
<t>
	    <list style='symbols'>
	      <t>Next payload (8 bits): identifies the payload that is added 
		after this payload.</t>

	      <t> Type (4 bits): indicates the type of the key included in the 
		payload.</t>
</list>
</t>
<texttable title='Secret Key Types' anchor='SKtable'>
<ttcol align='center'>Type</ttcol>
<ttcol align='center'>Value</ttcol>
<c>SK</c>
<c>1</c>
</texttable>

<t>
	    <list style='symbols'>
	      <t>KV (4 bits): indicates the type of key validity period 
		specified.
      This may be done by using an SPI (or MKI in the case of 
		<xref target="RFC3711"/>) or
      by providing an interval in which the key is valid (e.g., in the
      latter case, for SRTP this will be the index range where the key
      is valid). KV values are the same as in Section 6.13 of 
		<xref target="RFC3830"/></t>
	      
	      <t>Key data len (16 bits): the length of the Key data field (in
      bytes). </t>

	      <t>Key data (variable length): The SK data.</t>

	      <t>KV data (variable length): This includes either the SPI or an
      interval.  If KV is NULL, this field is not
      included.</t>


</list>
</t>



        </section>
	  </section>
</section>

        <section title="Security Considerations">
        
	  <t>Unless explicitly stated, the security properties of the MIKEY
   protocol as described in [RFC3830] apply to MIKEY-IBAKE as well. In 
	    addition, MIKEY-IBAKE is based on the basic 
	    Identity-Based Encryption 
	    protocol, as specified in <xref target="RFC5091"/>, 
	    <xref target="RFC5408"/>, and <xref target="RFC5409"/>, and as 
	    such inherits some properties of that protocol. For instance, 
	    by concatenating the "date" with the identity (to derive the 
	    Public Key), the need for any key 
	    revocation mechanisms is virtually eliminated. 
	    Moreover, by allowing the participants 
	    to acquire multiple Private Keys (e.g., for duration of contract) 
	    the availability requirements on the KMS are also reduced without 
	    any reduction in security.</t>

	  <section title="General Security Considerations">
	      <t>The MIKEY-IBAKE protocol relies on the use of 
		Identity-Based Encryption. 
		<xref target="RFC5091"/> describes attacks on the cryptographic 
		algorithms used in Identity-Based Encryption.  In addition, <xref target="RFC5091"/> 
		provides recommendations for 
		security parameters for described IBE algorithms.</t>

	      <t>It is assumed that the Key Management Services are secure, 
		not compromised, trusted, 
		and will not engage in launching active attacks independently 
		or in a collaborative environment. However, any malicious 
		insider could potentially launch 
		passive attacks (by decryption of one or more message 
		exchanges offline). While it is in the best interest of 
		administrators to prevent such attacks, it is hard to eliminate 
		this problem. Hence, it is assumed that such problems will 
		persist, 
		and hence the protocols are designed to protect participants 
		from passive adversaries.</t>
	      </section>

	  <section title="IBAKE Protocol Security Considerations">

	      <t>For the basic IBAKE protocol, from a cryptographic perspective, 
		the following security considerations apply.</t>

	    
	      <t>In every step, Identity-Based Encryption (IBE) is used with 
		the recipient's Public Key. This guarantees that only the 
		intended recipient of the message can decrypt the message 
		<xref target="BF"/>.</t>
	      <t>Next, the use of identities within the encrypted payload is 
		intended to eliminate some basic reflection attacks. For 
		instance, suppose identities were not used as part of the 
		encrypted payload, in the first step of the IBAKE protocol 
		(i.e., I_MESSAGE_1 of <xref target="example"/> in  
		<xref target="overview"/>). Furthermore, assume an 
		adversary who has access to 
		the conversation 
		between Initiator and Responder and can actively snoop into 
		packets and drop/modify them before routing them to the 
		destination. For instance, assume that the IP source 
		address and 
		destination address can be modified by the adversary.
	      After the first message is sent by the Initiator (to the 
		Responder), the adversary can take over and trap the 
		packet.
	      Next, the adversary can modify the IP source address to 
		include adversary's IP address, before routing it onto 
		the Responder.
	      The Responder will assume the request for an IBAKE session 
		came from the adversary and will execute step 2 of the IBAKE 
		protocol (i.e., R_MESSAGE_1 of <xref target="example"/> in 
		<xref target="overview"/>) but 
		encrypt it using the adversary's Public Key.
	      The above message can be decrypted by the adversary (and 
		only by the adversary). In particular, since the second 
		message includes the challenge sent by the Initiator to the 
		Responder, the adversary will now learn the challenge sent 
		by the Initiator.
	      Following this, the adversary can carry on a conversation 
		with the Initiator "pretending" to be the Responder.
	      This attack will be eliminated if identities are used as 
		part of the encrypted payload. In summary, at the end of the exchange both Initiator and Responder can 
  mutually authenticate each other and agree on a session key.</t>

<t>Recall that Identity-Based Encryption guarantees that only the recipient 
  of the message can decrypt the message using the Private Key. The caveat 
  being, the KMS that generated the Private Key of recipient of message can 
  decrypt the message as well. However, the KMS cannot learn the session 
  key [x][y]P given [x]P and [y]P based on the Elliptic Curve Diffie-Hellman 
  problem. This property of resistance to passive key escrow from the KMS 
  is not applicable to the basic IBE protocols proposed in 
  <xref target="RFC5091"/>, 
	    <xref target="RFC5408"/>, and <xref target="RFC5409"/>.</t>
<t>Observe that the protocol works even if the Initiator and Responder 
  belong to two different Key Management Services. In particular, the 
  parameters used for encryption to the Responder and parameters used for 
  encryption to the Initiator can be completely different and independent of 
  each other. Moreover, the Elliptic Curve used to generate the session key 
  [x][y]P can be completely different. If such flexibility is desired, then it 
  would be advantageous to add optional extra data to the protocol to 
  exchange the algebraic primitives used in deriving the session key.</t>
<t>In addition to mutual authentication, and resistance to passive escrow, 
  the Diffie-Hellman property of the session key exchange guarantees perfect 
  secrecy of keys. In others, accidental leakage of one session key does not 
  compromise past or future session keys between the same Initiator and 
  Responder.</t>
</section>
	    <section title="Forking">

	    
	      <t>In the Forking feature, given that there are multiple 
		potential Responders, it is important to observe that there 
		is one "common Responder" identity (and corresponding Public 
		and Private Keys) and each Responder has a unique identity 
		(and corresponding Public and Private Keys). Observe that, 
		in this framework, if 
		one Responder responds to the 
		invite from the 
		Initiator, it uses its unique identity such that the protocol guarantees that no other Responder
		learns the session key.</t>
	      </section>
	      <section title="Retargeting">
	      <t>In the Retargeting feature, the forwarding server does not 
		learn the Private Key of the intended Responder since it is 
		encrypted using the retargeted Responder's Public Key. 
		Additionally, the Initiator will learn that the retargeted 
		Responder answered the phone (and not the intended Responder) since the retargeted 
		Responder includes its own identity in the message sent to the Initiator. 
		This will allow the Initiator to decide whether or not to 
		carry on the conversation. Finally, the session key cannot 
		be discovered by the intended Responder since the random number 
		chosen by the retargeted Responder is not known to the intended Responder.</t>
	      </section>
	       <section title="Deferred Delivery">
	      <t>In the Deferred Delivery feature, the Initiator and the 
		Responder's mailbox will mutually authenticate each other 
		thereby preventing server side "phishing" attacks and 
		conversely guarantees to the server (and eventually to the 
		Responder) the identity of the Initiator. Moreover, the key 
		used by Initiator to encrypt the contents of the message is 
		completely independent from the session key derived between 
		the Initiator and the server. Finally, the key used to 
		encrypt the message is encrypted using the Responder's Public 
		Key, which allows the contents of the message 
		to remain unknown to the mailbox server.</t>
	      </section>




        </section>

	<section title="IANA Considerations">

	  <t>This document defines several new values for the namespaces Data
	    Type, Next Payload, and Key Data Type defined in 
	    <xref target="RFC3830"/>.  The
	    following IANA assignments have been added to the MIKEY Payload registry
	    (in bracket is a reference to the table containing the registered
	    values):</t>
<t>
	    <list style='symbols'>
	      <t>Data Type (see <xref target="DTtable"/>)</t>

	      <t>Next Payload (see <xref target="NPtable"/>)</t>

	      <t>Key Data Type (see <xref target="KDtable"/>)</t>
</list>
</t>
             <t>The ECCPT payload defines an 8-bit ECC Curve field for which 
	       IANA has
   created and will maintain a new namespace in the MIKEY Payload registry.
   Assignments consist of an ECC curve and its associated value.
   Values in the range 1-239 SHOULD be approved by the process of
   Specification Required, values in the range 240-254 are for Private
   Use, and the values 0 and 255 are Reserved according to 
   <xref target="RFC5226"/>.
   The initial contents of the registry are as follows:</t>
<t>
            <figure>
              <artwork><![CDATA[
        Value    ECC curve                            
        -------  ------------------------------------
        0        Reserved
        1        ECPRGF192Random  / P-192 / secp192r1 
        2        EC2NGF163Random  / B-163 / sect163r2 
        3        EC2NGF163Koblitz / K-163 / sect163k1 
        4        EC2NGF163Random2 / none  / sect163r1  
        5        ECPRGF224Random  / P-224 / secp224r1  
        6        EC2NGF233Random  / B-233 / sect233r1 
        7        EC2NGF233Koblitz / K-233 / sect233k1  
        8        ECPRGF256Random  / P-256 / secp256r1  
        9        EC2NGF283Random  / B-283 / sect283r1 
        10       EC2NGF283Koblitz / K-283 / sect283k1 
        11       ECPRGF384Random  / P-384 / secp384r1  
        12       EC2NGF409Random  / B-409 / sect409r1  
        13       EC2NGF409Koblitz / K-409 / sect409k1  
        14       ECPRGF521Random  / P-521 / secp521r1  
        15       EC2NGF571Random  / B-571 / sect571r1  
        16       EC2NGF571Koblitz / K-571 / sect571k1 
	17-239   Unassigned
        240-254  Private Use
        255      Reserved
      ]]></artwork>
            </figure>
</t>
   <t>The SK Sub-Payload defines a 4-bit Type field for which IANA has
   created and will maintain a new namespace in the MIKEY Payload registry.
   Assignments consist of a type of key and its associated value.
   Values in the range 2-15 SHOULD be approved by the process of
   Specification Required.
   The initial contents of the registry are as follows:</t>
<t>
            <figure>
              <artwork><![CDATA[
                  Value    Type
                  -------  ---------------
                  0        Reserved
                  1        Secret Key (SK)
                  2-15     Unassigned
                  ]]></artwork>
            </figure>
</t>

</section>
    </middle>

    <back>


        <references title='Normative References'>
	    &rfc2119; &rfc3830; &rfc4563; &rfc5226;  &rfc6043;
	 <reference anchor="SEC1">
	<front>
		<title>Elliptic Curve Cryptography</title>
		<author>
			<organization>Standards for Efficient Cryptography Group</organization>
		</author>
		<date month="September" year="2000"></date>
	</front>
   </reference>
	 <reference anchor="BF">
	<front>
		<title>Identity-Based Encryption from the Weil Pairing</title>
		<author initials='D.' surname='Boneh' fullname='Dan Boneh'>
			<organization></organization>
		</author>
		<author initials='M.' surname='Franklin' fullname='Matthew K. Franklin'>
			<organization></organization>
		</author>
		<date year="2003"></date>
	</front>
	<seriesInfo name='in SIAM J. of Computing, Vol. 32, No.' value='3' />
	<seriesInfo name='pp.' value='586-615' />
   </reference>
	</references>
	<references title="Informative References">
            &rfc4650; &rfc4738; &rfc3711;  &rfc5091; &rfc5408; &rfc5409; &rfc3261;
        </references>
    </back>

</rfc>
