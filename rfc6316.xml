<?xml version="1.0" encoding="US-ASCII" ?>
<?xml-stylesheet type='text/xsl' href='ref2629.xslt' ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3542 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3542.xml">
<!ENTITY RFC4423 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4423.xml">
<!ENTITY RFC5533 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5533.xml">
<!ENTITY RFC5534 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5534.xml">
<!ENTITY RFC2765 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2765.xml">
<!ENTITY RFC2782 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2782.xml">
<!ENTITY RFC4291 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4291.xml">
<!ENTITY RFC5535 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5535.xml">
]
>
<rfc category="info" number="6316"
     ipr="pre5378Trust200902" submissionType="IETF" consensus="yes">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc iprnotified="no" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc rfcedstyle="yes"?>

  <front>
    <title abbrev="Multihoming Shim API">Sockets Application Program
    Interface (API) for Multihoming Shim</title>
    
    <author initials='M' surname='Komu' fullname='Miika Komu'>
      <organization abbrev="Aalto University">Aalto University</organization>
      <address>
        <postal>
          <city>Espoo</city>
          <country>Finland</country>
        </postal>
        <phone>+358505734395</phone>
        <facsimile>+358947025014</facsimile>
        <email>miika@iki.fi</email>
        <uri>http://cse.aalto.fi/research/groups/datacommunications/people/</uri>
      </address>
    </author>
    
    <author initials='M' surname='Bagnulo' fullname='Marcelo Bagnulo'>
      <organization abbrev="UC3M">Universidad Carlos III de
      Madrid</organization>
      <address>
        <postal>
          <street>Av. Universidad 30</street>
          <city>Leganes</city>
          <code>28911</code>
          <country>SPAIN</country>
        </postal>
        <phone>+34 91 6248837</phone>
        <email>marcelo@it.uc3m.es</email>
        <uri>http://it.uc3m.es/marcelo</uri>
      </address>
    </author>

    <author initials='K' surname='Slavov' fullname='Kristian Slavov'>
      <organization abbrev="Ericsson">Ericsson Research
      Nomadiclab</organization>
      <address>
        <postal>
          <street>Hirsalantie 11</street>
          <city>Jorvas</city>
          <code>FI-02420</code>
          <country>Finland</country>
        </postal>
        <phone>+358 9 299 3286</phone>
        <email>kristian.slavov@ericsson.com</email>
      </address>
    </author>

    <author initials='S' surname='Sugimoto' fullname='Shinta Sugimoto'
            role="editor">
      <organization abbrev="Ericsson"> Nippon Ericsson K.K.</organization>
      <address>
        <postal>
          <street>Koraku Mori Building</street>
          <street>1-4-14, Koraku, Bunkyo-ku</street>
          <city>Tokyo</city>
          <code>112-0004</code>
          <country>Japan</country>
        </postal>
        <phone>+81 3 3830 2241</phone>
        <email>shinta.sugimoto@ericsson.com</email>
      </address>
    </author>
    
    <date month="July" year="2011"/>

    <area>Internet</area>
    <workgroup>SHIM6 Working Group</workgroup>
    <keyword>Shim6, HIP, identifier/locator split</keyword>

    <abstract>
      
      <t>This document specifies sockets API extensions for the
      multihoming shim layer.  The API aims to enable interactions
      between applications and the multihoming shim layer for advanced
      locator management, and access to information about failure
      detection and path exploration.</t>

      <t>This document is based on an assumption that a multihomed
      host is equipped with a conceptual sub-layer (hereafter called
      "shim sub-layer")
      inside the IP layer that maintains mappings between identifiers
      and locators. Examples of the shim are Shim6 and the Host
      Identity Protocol (HIP).</t>

    </abstract>
  </front>
  <middle>
    <!--
        ================================================================
        Introduction
        ================================================================
    -->
    <section title="Introduction" toc="include">      

      <t>This document defines sockets API extensions by which
      upper-layer protocols may be informed about and control the way in
      which a multihoming shim sub-layer in the IP layer manages the
      dynamic choice of locators.  Initially, the multihoming shim
      sub-layer refers to Shim6 and/or HIP, but it is defined generically.</t>

      <t>The role of the multihoming shim sub-layer (hereafter called
      "shim sub-layer" in this document) is to avoid impacts to
      upper-layer protocols that may be caused when the endhost changes its
      attachment point to the Internet -- for instance, in the case of a
      rehoming event under the multihomed environment.  There is,
      however, a need for an API in the cases where 1) the upper-layer
      protocol is particularly sensitive to impacts, or 2) the
      upper-layer protocol wants to benefit from better knowledge of what is
      going on underneath.</t>

      <t>There are various kinds of technologies that aim to solve the
      same issue (the multihoming issue).  Note that there will be
      conflict when more than one shim sub-layer is active at the same
      time.  The assumption made in this document is that there is
      only a single shim sub-layer (HIP or Shim6) activated on the
      system.
        </t>

      <t>The target readers of this document are application
      programmers who develop application software that may benefit
      greatly from multihomed environments.  In addition, this
      document aims to provide necessary information for developers of
      shim protocols to implement APIs for enabling advanced locator
      management.</t>

    </section>
    <!--
        ================================================================
        Requirements Language
        ================================================================
    -->
    <section title="Requirements Language" toc="include">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described
      in <xref target="RFC2119"/>.</t>
    </section>

    <!--
        ================================================================
        Terminology
        ================================================================
    -->
    <section title="Terminology and Background" toc="include">

      <t>This section provides terminology used in this document.
      Basically, most of the terms used in this document are taken from
      the following documents:

      <list style="symbols">
        <t>Shim6 Protocol Specification <xref
        target="RFC5533"/></t>
        <t>HIP Architecture <xref target="RFC4423"/></t>
        <t>Reachability Protocol (REAP) <xref
        target="RFC5534"/></t>
      </list>

      In this document, the term "IP" refers to both IPv4 and IPv6,
      unless the protocol version is specifically mentioned.  The
      following are definitions of terms frequently used in this
      document:
 
      <list style="symbols">

        <t>Endpoint Identifier (EID) -- The identifier used by the
        application to specify the endpoint of a given communication.
        Applications may handle EIDs in various ways, such as
        long-lived connections, callbacks, and referrals <xref
        target="SHIM6-APP-REFER"/>.

        <list style="symbols">
          <t>In the case of Shim6, an identifier called a ULID
          (Upper-Layer Identifier) serves as
          an EID.  A ULID is chosen from
          locators available on the host.</t>
          <t>In the case of HIP, an identifier called a Host
          Identifier serves as an EID.  A Host Identifier is derived
          from the public key of a given host.  For the sake of
          backward compatibility with the sockets API, the Host
          Identifier is represented in the form of a hash of a public key.
          </t>

          <t>Note that the EID appears in the standard sockets API as
          an address, and does not appear in the extensions defined in
          this document, which only concern locators.</t>
        </list>
        </t>

        <t>Locator - The IP address actually used to deliver IP
        packets.  Locators are present in the source and destination
        fields of the IP header of a packet on the wire.  A locator as
        discussed in this document could be either an IPv4 address or
        an IPv6 address.  Note that HIP can handle both IPv4 and IPv6
        locators, whereas Shim6 can handle only IPv6 locators.  For
        the HIP case, a locator can be a private IPv4 address when the
        host is behind a NAT.  <xref target="sec-locator-behind-nat"/>
        gives a detailed description about the handling of a locator
        behind a NAT.
          <list style="symbols">
            <t>List of locators - A list of locators associated with
            an EID.  There are two lists of locators stored in a given
            context.  One is associated with the local EID, and the
            other is associated with the remote EID.  As defined in
            <xref target="RFC5533"/>, the list of locators associated
            with an EID 'A' is denoted as Ls(A).</t>
            <t>Preferred locator - The (source/destination) locator
            currently used to send packets within a given context.</t>
            <t>Unknown locator - Any locator that does not appear in
            the locator list of the shim context associated with the
            socket.  When there is no shim context associated with the
            socket, any source and/or destination locator requested by
            the application is considered to be an unknown locator.</t>
            <t>Valid locator - A valid locator means that the locator
            is considered to be valid in the security sense.  More
            specifically, the validity indicates whether the locator
            is part of a Hash-Based Address (HBA) set <xref target="RFC5535"/>.
            </t>
            <t>Verified locator - A verified locator means that the
            locator is considered to be reachable according to the
            result of a REAP return routability check.  Note that the
            verification applies only to the peer's locator.</t>
          </list>
        </t>

        <t>Shim - The conceptual sub-layer inside the IP layer.  This
        sub-layer maintains mappings between EIDs and locators.  An EID can be
        associated with more than one locator at a time when the host
        is multihomed.  The term "shim" does not refer to a specific
        protocol but refers to the conceptual sub-layer inside the IP
        layer.</t>

        <t>Identifier/locator adaptation - The adaptation performed at
        the shim sub-layer.  This adaptation may end up re-writing the source
        and/or destination addresses of an IP packet.  In the outbound
        packet processing, the EID pair is converted to the associated
        locator pair.  In the inbound packet processing, the locator
        pair is converted to the EID pair.</t>

        <t>Context - The state information shared by a given pair of
        peers.  Context stores a binding between the EID and associated
        locators.  Contexts are maintained by the shim sub-layer.
        Deferred context setup is a scenario where a context is
        established after the communication starts.  Deferred context
        setup is possible if the ULID is routable, such as in the case of
        Shim6.</t>

        <t>Reachability detection - The procedure to check
        reachability between a given locator pair.</t>

        <t>Path - The sequence of routers that an IP packet goes
        through to reach the destination.</t>

        <t>Path exploration - The procedure to explore available paths
        for a given set of locator pairs.</t>

        <t>Outage - The incident that prevents IP packets flowing from
        the source locator to the destination locator.  When there is
        an outage, it means that there is no reachability between a
        given locator pair.  The outage may be caused by various
        reasons, such as a shortage of network resources, congestion,
        and human error (faulty operation).</t>

        <t>Working address pair - Considered to be
        "working" if the packet can safely travel from the source to
        the destination, where the packet contains the first address
        from the pair as the source address and the second address
        from the pair as the destination address.  If reachability is
        confirmed in both directions, the address pair is considered
        to be working bi-directionally.</t>

        <t>Reachability Protocol (REAP) - The protocol for detecting
        failure and exploring reachability in a multihomed
        environment.  REAP is defined in <xref
        target="RFC5534"/>.</t>

      </list>
      </t>

      <t>In this document, syntax and semantics of the API are given
      in the same way as in the Portable Operating System Interface
      (POSIX) standard <xref target="POSIX"/>.
      The API specifies how to use ancillary data (aka cmsg) to access
      the locator information with recvmsg() and/or sendmsg() I/O
      calls.  The API is described in C language, and data types are
      defined in the POSIX format; intN_t means a signed integer of
      exactly N bits (e.g., int16_t), and uintN_t means an unsigned
      integer of exactly N bits (e.g., uint32_t).</t>

      <t>The distinction between "connected" sockets and "unconnected"
      sockets is important when discussing the applicability of the
      sockets API defined in this document.  A connected socket is
      bound to a given peer, whereas an unconnected socket is not
      bound to any specific peers.  A TCP socket becomes a connected
      socket when the TCP connection establishment is completed.  UDP
      sockets are unconnected, unless the application uses the
      connect() system call.</t>

    </section>
    <!--
        ================================================================
        System Overview
        ================================================================
    -->
    <section title="System Overview" anchor="sec-system-overview"
             toc="include">
      
      <t><xref target="fig-system-overview"/> illustrates the system
      overview.  The shim sub-layer and REAP component exist inside
      the IP layer.  Applications use the sockets API defined in this
      document to interface with the shim sub-layer and the transport
      layer for locator management, failure detection, and path
      exploration.</t>

      <t>It is also possible that the shim sub-layer interacts with
      the transport layer; however, such an interaction is outside the
      scope of this document.</t>
      
      <figure anchor="fig-system-overview" title="System Overview">
        <artwork><![CDATA[
                     +------------------------+
                     |       Application      |
                     +------------------------+
                        ^                 ^ 
           ~~~~~~~~~~~~~|~Socket Interface|~~~~~~~~~~~~~~
                        |                 v
            +-----------|------------------------------+
            |           |  Transport Layer             |
            +-----------|------------------------------+
                  ^     |
    +-------------|-----|-------------------------------------+
    |             v     v                                     |
    |   +-----------------------------+       +----------+    |  IP 
    |   |            Shim             |<----->|   REAP   |    | Layer
    |   +-----------------------------+       +----------+    |
    |                       ^                      ^          |
    +-----------------------|----------------------|----------+
                            v                      v
            +------------------------------------------+
            |                Link Layer                |
            +------------------------------------------+ 
            ]]></artwork>
      </figure>
      

    </section>
    <!--
        ================================================================
        Requirements
        ================================================================
    -->
    <section title="Requirements" anchor="sec-requirements" toc="include">
      
      <t>The following is a list of requirements from applications:

      <list style="symbols">

        <t>Turn on/off shim.  An application should be able to request
        to turn on or turn off the multihoming support by the shim
        layer:

        <list style="symbols">
          <t>Apply shim.  The application should be able to explicitly
          request that the shim sub-layer apply multihoming support.</t>

          <t>Don't apply shim.  The application should be able to
          request that the shim sub-layer not apply the multihoming
          support but apply normal IP processing at the IP
          layer.</t>

          <t>Note that this function is also required by other types
          of multihoming mechanisms, such as the Stream Control Transmission
          Protocol (SCTP) and multipath TCP, to
          avoid potential conflict with the shim sub-layer.</t>
          </list>
        </t>

        <t>Locator management.
        <list style="symbols">
          <t>It should be possible to set a preferred source and/or
          destination locator within a given context.</t>
          <t>It should be possible to get a preferred source and/or
          destination locator within a given context.</t>
          <t>It should be possible to set a list of source and/or
          destination locators within a given context: Ls(local) and
          Ls(remote).</t>
          <t>It should be possible to get a list of source and/or
          destination locators within a given context: Ls(local) and
          Ls(remote).</t>
        </list>
        </t>

        <t>Notification from applications and upper-layer protocols to
        the shim sub-layer about the status of the communication.  The
        notification occurs in an event-based manner.  Applications
        and/or upper-layer protocols may provide positive feedback or
        negative feedback to the shim sub-layer.  Note that these
        types of feedback are mentioned in <xref target="RFC5534"/>:
        
        <list style="symbols">
          <t>Applications and/or upper-layer protocols (e.g., TCP) may
          provide positive feedback to the shim sub-layer informing
          that the communication is going well.</t>

          <t>Applications and/or upper-layer protocols (e.g., TCP) may
          provide negative feedback to the shim sub-layer informing
          that the communication status is not satisfactory.  TCP may
          detect a problem when it does not receive any expected ACK
          message from the peer.  The REAP module may be triggered by
          the negative feedback and invoke the path exploration
          procedure.</t> </list>

          </t>

        <t>Feedback from applications to the shim sub-layer.
        Applications should be able to inform the shim sub-layer of
        the timeout values for detecting failures, sending keepalives,
        and starting the exploration procedure.  In particular,
        applications should be able to suppress keepalives.
        </t>

        <t>Hot-standby.  Applications may request the shim sub-layer
        for a hot-standby capability.  This means that alternative
        paths are known to be working in advance of a failure
        detection.  In such a case, it is possible for the shim
        sub-layer to immediately replace the current locator pair with
        an alternative locator pair.
        </t>

        <t>Eagerness for locator exploration.  An application should
        be able to inform the shim sub-layer of how aggressively it
        wants the REAP mechanism to perform a path exploration (e.g.,
        by specifying the number of concurrent attempts of discovery
        of working locator pairs) when an outage occurs on the path
        between the locator pair in use.</t>
        
        <t>Providing locator information to applications.  An
        application should be able to obtain information about the
        locator pair that was actually used to send or receive
        packets.<list style="symbols">
          <t>For inbound traffic, the application may be interested in
          the locator pair that was actually used to receive the
          packet.
          </t>
          <t>For outbound traffic, the application may be interested
          in the locator pair that was actually used to transmit the
          packet.</t>
        </list>

        In this way, applications may have additional control of the
        locator management.  For example, an application becomes capable
        of verifying if its preference for a locator is actually applied to
        the flow or not.
        </t>

        <t>Applications should be able to know if the shim sub-layer
        supports deferred context setup or not.</t>

        <t>An application should be able to know if the communication
        is now being served by the shim sub-layer or not.</t>

        <t>An application should be able to use a common interface to
        access an IPv4 locator and an IPv6 locator.</t>

      </list>        
    </t>

    </section>

    <!--
        ===================================================================
        Socket options for multihoming shim sub-layer
        ===================================================================
    -->
    <section title="Socket Options for Multihoming Shim Sub-Layer"
             anchor="sec-shim-socket-options" toc="include">

      <t>In this section, socket options that are specific to the shim
      sub-layer are defined.</t>

      <t><xref target="tab-shim-socket-options"/> shows a list of the
      socket options that are specific to the shim sub-layer.  All of
      these socket options are defined at the level SOL_SHIM.  When an
      application uses one of the socket options by getsockopt() or
      setsockopt(), the second argument MUST be set to SOL_SHIM.</t>

      <t>The first column of <xref target="tab-shim-socket-options"/>
      gives the name of the option.  The second column indicates
      whether the value for the socket option can be read by
      getsockopt(), and the third column indicates whether the value
      for the socket option can be written by setsockopt().  The
      fourth column provides a brief description of the socket option.
      The fifth column shows the type of data structure specified
      along with the socket option.  By default, the data structure
      type is an integer.</t>

      <texttable anchor="tab-shim-socket-options"
                 title="Socket Options for Multihoming Shim Sub-Layer">
 
        <ttcol align='left'>optname</ttcol>
        <ttcol align='left'>get</ttcol>
        <ttcol align='left'>set</ttcol>
        <ttcol align='left'>description</ttcol>
        <ttcol align='left'>dtype</ttcol>

        <c>SHIM_ASSOCIATED</c>
        <c>o</c>
        <c></c>
        <c>Get the parameter that indicates whether the socket is
        associated (1) with any shim context or not (0).</c>
        <c>int</c>

        <c>SHIM_DONTSHIM</c>
        <c>o</c>
        <c>o</c>
        <c>Get or set the parameter that indicates whether or not
          to employ multihoming support by the shim
          sub-layer.</c>
        <c>int</c>

        <c>SHIM_HOT_STANDBY</c>
        <c>o</c>
        <c>o</c>
        <c>Get or set the parameter to request the shim sub-layer to
          prepare a hot-standby connection.</c>
        <c>int</c>

        <c>SHIM_LOC_LOCAL_PREF</c>
        <c>o</c>
        <c>o</c>
        <c>Set the preference value for a source locator for outbound
        traffic. &nbsp;Get the preferred locator for the source locator for
        outbound traffic.</c>
        <c>Note 1</c>

        <c>SHIM_LOC_PEER_PREF</c>
        <c>o</c>
        <c>o</c>
        <c>Set the preference value for a destination locator for
        outbound traffic. &nbsp;Get the preferred locator for the
        destination locator for outbound traffic.</c>
        <c>Note 1</c>

        <c>SHIM_LOC_LOCAL_RECV</c>
        <c>o</c>
        <c>o</c>
        <c>Request the shim sub-layer to store the destination locator
        of the received IP packet in an ancillary data object.</c>
        <c>int</c>

        <c>SHIM_LOC_PEER_RECV</c>
        <c>o</c>
        <c>o</c>
        <c>Request the shim sub-layer to store the source locator of
        the received IP packet in an ancillary data object.</c>
        <c>int</c>

        <c>SHIM_LOC_LOCAL_SEND</c>
        <c>o</c>
        <c>o</c>
        <c>Get or set the source locator of outgoing IP packets.</c>
        <c>Note 1</c>

        <c>SHIM_LOC_PEER_SEND</c>
        <c>o</c>
        <c>o</c>
        <c>Get or set the destination locator of outgoing IP packets.</c>
        <c>Note 1</c>

        <c>SHIM_LOCLIST_LOCAL</c>
        <c>o</c>
        <c>o</c>
        <c>Get or set the list of locators associated with the local
        EID.</c>
        <c>Note 2</c>
        
        <c>SHIM_LOCLIST_PEER</c>
        <c>o</c>
        <c>o</c>
        <c>Get or set the list of locators associated with the peer's
        EID.</c>
        <c>Note 2</c>
        
        <c>SHIM_APP_TIMEOUT</c>
        <c>o</c>
        <c>o</c>
        <c>Get or set the Send Timeout value of REAP.</c>
        <c>int</c>

        <c>SHIM_PATHEXPLORE</c>
        <c>o</c>
        <c>o</c>
        <c>Get or set parameters for path exploration and failure
          detection.</c>
        <c>Note 3</c>

        <c>SHIM_CONTEXT_DEFERRED_SETUP</c>
        <c>o</c>
        <c></c>
        <c>Get the parameter that indicates whether deferred context
          setup is supported or not.</c>
        <c>int</c>

      </texttable>
      
      <t>Note 1: Pointer to a shim_locator as defined in
      <xref target="sec-data-structures"/>.</t>

      <t>Note 2: Pointer to an array of shim_locator data.</t>

      <t>Note 3: Pointer to a shim_pathexplore as defined in
      <xref target="sec-data-structures"/>.</t>

      <t><xref target="fig-socket-api-model"/> illustrates how the
      shim-specific socket options fit into the system model of sockets
      API.  The figure shows that the shim sub-layer and the
      additional protocol components (IPv4 and IPv6) below the shim
      sub-layer are new to the system model.  As previously mentioned,
      all the shim-specific socket options are defined at the SOL_SHIM
      level.  This design choice brings the following
      advantages:

      <list style="numbers">
        <t>The existing sockets APIs continue to work at the layer
        above the shim sub-layer.  That is, those legacy APIs handle IP
        addresses as identifiers.</t>
        <t>With newly defined socket options for the shim sub-layer, the
        application obtains additional control of locator
        management.</t>
        <t>The shim-specific socket options can be kept independent
        from address family (IPPROTO_IP or IPPROTO_IPV6) and transport
        protocol (IPPROTO_TCP or IPPROTO_UDP) settings.</t>
      </list>
</t>
      <figure anchor="fig-socket-api-model"
              title="System Model of Sockets API with Shim Sub-Layer">
        <artwork><![CDATA[
                         s1 s2      s3 s4
                          |  |       |  |
         +----------------|--|-------|--|----------------+
         |             +-------+   +-------+             |
         | IPPROTO_TCP |  TCP  |   |  UDP  |             |
         |             +-------+   +-------+             |
         |                |   \     /   |                |
         |                |    -----    |                | 
         |                |   /     \   |                |
         |              +------+   +------+              |
         |   IPPROTO_IP | IPv4 |   | IPv6 | IPPROTO_IPV6 |
         |              +------+   +------+              |
         |                  \         /             SOL_SOCKET
         |          +--------\-------/--------+          |
         | SOL_SHIM |          shim           |          |
         |          +--------/-------\--------+          |
         |                  /         \                  |
         |              +------+   +------+              |
         |              | IPv4 |   | IPv6 |              |
         |              +------+   +------+              |
         |                  |          |                 |
         +------------------|----------|-----------------+
                            |          |
                          IPv4       IPv6
                        Datagram   Datagram
         ]]></artwork>
      </figure>

      <section title="SHIM_ASSOCIATED"> 

        <t>The SHIM_ASSOCIATED option is used to check whether or not the
        socket is associated with any shim context.</t>

        <t>This option is meaningful when the locator information of
        the received IP packet does not tell whether or not the
        identifier/locator adaptation is performed.  Note that
        the EID pair and the locator pair may be identical in some
        cases.</t>

        <t>Note that the socket option is read-only, and the option
        value can be read by getsockopt().  The result (0/1/2) is set
        in the option value (the fourth argument of getsockopt()).</t>

        <t>When the application specifies the socket option to an
        unconnected socket, error code EOPNOTSUPP is returned to
        the application.</t>

        <t>The data type of the option value is an integer.  The
        option value indicates the presence of shim context.  A return
        value of 1 means that the socket is associated with a shim
        context at the shim sub-layer.  A return value of 0 indicates
        that there is no shim context associated with the socket.  A
        return value of 2 means that it is not known whether or not the socket
        is associated with a shim context, and this MUST be
        returned only when the socket is unconnected.  In other words,
        the returned value MUST be 0 or 1 when the socket is
        connected.</t>

        <t>For example, the option can be used by the application as
        follows:</t>

        <figure>
          <artwork><![CDATA[
    int optval;
    int optlen = sizeof(optval);

    getsockopt(fd, SOL_SHIM, SHIM_ASSOCIATED, &optval, &optlen);
          ]]></artwork>
        </figure>

      </section>

      <section title="SHIM_DONTSHIM">

        <t>The SHIM_DONTSHIM option is used to request that the shim layer
        not provide the multihoming support for the communication
        established over the socket.</t>

        <t>The data type of the option value is an integer, and it
        takes 0 or 1. An option value of 0 means that the shim sub-layer
        is employed if available. An option value of 1 means that the
        application does not want the shim sub-layer to provide the
        multihoming support for the communication established over the
        socket.</t>

        <t>The default value is set to 0, which means that the shim
        sub-layer performs identifier/locator adaptation if
        available.</t>

        <t>Any attempt to disable the multihoming shim support MUST be
        made by the application before the socket is connected.  If an
        application makes such an attempt for a connected socket,
        error code EOPNOTSUPP MUST be returned.</t>

        <t>For example, an application can request that the system not
        apply the multihoming support as follows:</t>

        <figure>
          <artwork><![CDATA[
    int optval;

    optval = 1;

    setsockopt(fd, SOL_SHIM, SHIM_DONTSHIM, &optval, sizeof(optval));
    ]]></artwork>
        </figure>

        <t>For example, the application can check the option value as
        follows:</t>

        <figure>
          <artwork><![CDATA[
    int optval;
    int len;

    len = sizeof(optval);

    getsockopt(fd, SOL_SHIM, SHIM_DONTSHIM, &optval, &len);
    ]]></artwork>
        </figure>

      </section>

      <section title="SHIM_HOT_STANDBY">

        <t>The SHIM_HOT_STANDBY option is used to control whether or not the shim
        sub-layer employs a hot-standby connection for the
        socket.  A hot-standby connection is an alternative
        working locator pair to the current locator pair.  This option
        is effective only when there is a shim context associated with
        the socket.</t>

        <t>The data type of the option value is an integer.</t>

        <t>The option value can be set by setsockopt().</t>

        <t>The option value can be read by getsockopt().</t>

        <t>By default, the value is set to 0, meaning that hot-standby
        connection is disabled.</t>

        <t>When the application specifies the socket option to an
        unconnected socket, error code EOPNOTSUPP is returned to
        the application.</t>

        <t>When there is no shim context associated with the socket,
        error code ENOENT is returned to the application.</t>

        <t>For example, an application can request establishment of a
        hot-standby connection by using the socket option as
        follows:</t>

        <figure>
          <artwork><![CDATA[
    int optval;

    optval = 1;

    setsockopt(fd, SOL_SHIM, SHIM_HOT_STANDBY, &optval,
               sizeof(optval));
    ]]></artwork>
        </figure>

        <t>For example, an application can get the option value by
        using the socket option as follows:</t>

        <figure>
          <artwork><![CDATA[
    int optval;
    int len;

    len = sizeof(optval);

    getsockopt(fd, SOL_SHIM, SHIM_HOT_STANDBY, &optval, &len);
    ]]></artwork>
        </figure>

      </section>

      <section title="SHIM_LOC_LOCAL_PREF">
        
        <t>The SHIM_LOC_LOCAL_PREF option is used to set the
        preference value for a source locator for outbound traffic, or
        to get the preference value of the source locator for outbound
        traffic that has the highest preference value.</t>

        <t>This option is effective only when there is a shim context
          associated with the socket.</t>

        <t>By default, the option value is set to NULL, meaning that
        the option is disabled.</t>

        <t>The preference of a locator is defined by a combination of
        priority and weight as per DNS SRV <xref target="RFC2782"/>.
        Note that the Shim6 base protocol defines the preference of a
        locator in the same way.</t>

        <t>The data type of the option value is a pointer to
        the shim_locator information data structure as defined in
        <xref target="sec-data-struct-loc-info"/>.</t>

        <t>When an application specifies the socket option to an
        unconnected socket, error code EOPNOTSUPP is returned to
        the application.</t>

        <t>When there is no shim context associated with the socket,
        error code ENOENT is returned to the application.</t>

        <t>Error code EINVALIDLOCATOR is returned when the validation of
        the specified locator fails.</t>

        <t>An application can set the preference value for a source
        locator for outbound traffic by setsockopt() with the socket
        option.  Note that lc_ifidx and lc_flags (as defined in
        <xref target="sec-data-struct-loc-info" />) have no effect in a
        set operation.  Below is an example of such a set operation.</t>

        <figure>
          <artwork><![CDATA[
    struct shim_locator lc;
    struct in6_addr ip6;

    /* ...set the locator (ip6)... */

    memset(&lc, 0, sizeof(shim_locator));
    lc.lc_family = AF_INET6;  /* IPv6 */
    lc.lc_ifidx = 0;
    lc.lc_flags = 0;
    lc.lc_prio = 1;
    lc.lc_weight = 10;
    memcpy(&lc.lc_addr, &ip6, sizeof(in6_addr)); 

    setsockopt(fd, SOL_SHIM, SHIM_LOC_LOCAL_PREF, &lc,
               sizeof(optval));
    ]]></artwork>
        </figure>

        <t>An application can get the source locator for outbound
        traffic that has the highest preference value by using the
        socket option.  Below is an example of such a get operation.</t>

        <figure>
          <artwork><![CDATA[
    struct shim_locator lc;
    int len;

    len = sizeof(lc);

    getsockopt(fd, SOL_SHIM, SHIM_LOC_LOCAL_PREF, &lc, &len);
    ]]></artwork>
        </figure>

      </section>

      <section title="SHIM_LOC_PEER_PREF">

        <t>The SHIM_LOC_PEER_PREF option is used to set the preference
        value for a destination locator for outbound traffic, or to
        get the preference value of the destination locator for
        outbound traffic that has the highest preference value.</t>

        <t>This option is effective only when there is a shim context
        associated with the socket.</t>

        <t>By default, the option value is set to NULL, meaning that
        the option is disabled.</t>

        <t>As defined earlier, the preference of a locator is defined
        by a combination of priority and weight as per DNS
        SRV <xref target="RFC2782"/>.  When there is more than one
        candidate destination locator, the shim sub-layer makes a
        selection based on the priority and weight specified for each
        locator.</t>

        <t>The data type of the option value is a pointer to the
        shim_locator information data structure as defined in
        <xref target="sec-data-struct-loc-info"/>.</t>

        <t>When the application specifies the socket option to an
        unconnected socket, error code EOPNOTSUPP is returned to
        the application.</t>

        <t>When there is no shim context associated with the socket,
        error code ENOENT is returned to the application.</t>

        <t>Error code EINVALIDLOCATOR is returned when the validation of
        the requested locator fails.</t>

        <t>Error code EUNREACHABLELOCATOR is returned when the requested
        locator is determined to be unreachable according to a
        reachability check.</t>

        <t>The usage of the option is the same as that of
        SHIM_LOC_LOCAL_PREF.</t>

      </section>

      <section title="SHIM_LOC_LOCAL_RECV">

        <t>The SHIM_LOC_LOCAL_RECV option can be used to request that the
        shim sub-layer store the destination locator of the
        received IP packet in an ancillary data object that can be
        accessed by recvmsg().  This option is effective only when
        there is a shim context associated with the socket.</t>

        <t>The data type of the option value is an integer. The option
        value MUST be binary (0 or 1).  By default, the option value
        is set to 0, meaning that the option is disabled.</t>

        <t>An application can set the option value by
        setsockopt().</t>

        <t>An application can get the option value by
        getsockopt().</t>

        <t>See <xref target="sec-access-to-locinfo"/> for the
        procedure to access locator information stored in the
        ancillary data objects.</t>

        <t>When the application specifies the socket option to an
        unconnected socket, error code EOPNOTSUPP is returned to
        the application.</t>

        <t>When there is no shim context associated with the socket,
        error code ENOENT is returned to the application.</t>
        
        <t>For example, an application can request the shim sub-layer
        to store a destination locator by using the socket option as
        follows:</t>

        <figure>
          <artwork><![CDATA[
    int optval;

    optval = 1;

    setsockopt(fd, SOL_SHIM, SHIM_LOC_LOCAL_RECV, &optval,
               sizeof(optval));
    ]]></artwork>
        </figure>

        <t>For example, an application can get the option value as
        follows:</t>

        <figure>
          <artwork><![CDATA[
    int optval;
    int len;

    len = sizeof(optval);

    getsockopt(fd, SOL_SHIM, SHIM_LOC_LOCAL_RECV, &optval, &len);
    ]]></artwork>
        </figure>

      </section>

      <section title="SHIM_LOC_PEER_RECV">

        <t>The SHIM_LOC_PEER_RECV option is used to request that the shim
        sub-layer store the source locator of the received IP
        packet in an ancillary data object that can be accessed by
        recvmsg().  This option is effective only when there is a shim
        context associated with the socket.</t>

        <t>The data type of the option value is an integer. The option
        value MUST be binary (0 or 1).  By default, the option value
        is set to 0, meaning that the option is disabled.</t>

        <t>The option value can be set by setsockopt().</t>

        <t>The option value can be read by getsockopt().</t>

        <t>See <xref target="sec-access-to-locinfo"/> for the
        procedure to access locator information stored in the
        ancillary data objects.</t>

        <t>When the application specifies the socket option to an
        unconnected socket, error code EOPNOTSUPP is returned to
        the application.</t>

        <t>When there is no shim context associated with the socket,
        error code ENOENT is returned to the application.</t>

        <t>The usage of the option is the same as that of the
        SHIM_LOC_LOCAL_RECV option.</t>

      </section>

      <section title="SHIM_LOC_LOCAL_SEND">

        <t>The SHIM_LOC_LOCAL_SEND option is used to request that the shim
        sub-layer use a specific locator as the source locator for
        the IP packets to be sent from the socket.  This option is
        effective only when there is a shim context associated with
        the socket.</t>

        <t>The data type of the option value is a pointer to the shim_locator
        data structure.</t>

        <t>An application can set the local locator by setsockopt(),
        providing a locator that is stored in a shim_locator data
        structure.  When a zero-filled locator is specified, the
        pre-existing setting of the local locator is inactivated.</t>

        <t>An application can get the local locator by
        getsockopt().</t>

        <t>When the application specifies the socket option to an
        unconnected socket, error code EOPNOTSUPP is returned to
        the application.</t>

        <t>When there is no shim context associated with the socket,
        error code ENOENT is returned to the application.</t>

        <t>Error code EINVALIDLOCATOR is returned when an invalid
        locator is specified.</t>

        <t>For example, an application can request the shim sub-layer
        to use a specific local locator by using the socket option as
        follows:</t>

        <figure>
          <artwork><![CDATA[
    struct shim_locator locator;
    struct in6_addr ia6;

    /* an IPv6 address preferred for the source locator is copied
       to the parameter ia6 */

    memset(&locator, 0, sizeof(locator));

    /* fill shim_locator data structure */
    locator.lc_family = AF_INET6;
    locator.lc_ifidx = 0;
    locator.lc_flags = 0;
    locator.lc_prio = 0;
    locator.lc_weight = 0;
    memcpy(&locator.lc_addr, &ia6, sizeof(ia6));

    setsockopt(fd, SOL_SHIM, SHIM_LOC_LOCAL_SEND, &locator,
               sizeof(locator));
    ]]></artwork>
        </figure>

        <t>For example, an application can get the designated local
        locator by using the socket option as follows:</t>

        <figure>
          <artwork><![CDATA[
    struct shim_locator locator;

    memset(&locator, 0, sizeof(locator));

    getsockopt(fd, SOL_SHIM, SHIM_LOC_LOCAL_SEND, &locator,
               sizeof(locator));

    /* check locator */
    ]]></artwork>
        </figure>

      </section>

      <section title="SHIM_LOC_PEER_SEND">

        <t>The SHIM_LOC_PEER_SEND option is used to request that the shim
        sub-layer use a specific locator for the destination
        locator of IP packets to be sent from the socket.  This option
        is effective only when there is a shim context associated with
        the socket.</t>

        <t>The data type of the option value is a pointer to the
        shim_locator data structure.</t>

        <t>An application can set the remote locator by setsockopt(),
        providing a locator that is stored in a shim_locator data
        structure.  When a zero-filled locator is specified, the
        pre-existing setting of the remote locator is inactivated.</t>

        <t>An application can get the specified remote locator by
        getsockopt().</t>

        <!-- difference from SHIM_LOC_PEER_PREF -->
        <t>The difference between the SHIM_LOC_PEER_SEND option and
        the SHIM_LOC_PEER_PREF option is that the former guarantees the
        use of a requested locator when applicable, whereas the latter
        does not.</t>

        <t>When the application specifies the socket option to an
        unconnected socket, error code EOPNOTSUPP is returned to
        the application.</t>

        <t>When there is no shim context associated with the socket,
        error code ENOENT is returned to the application.</t>

        <t>Error code EINVALIDLOCATOR is returned when the validation of
        the requested locator fails.</t>

        <t>Error code EUNVERIFIEDLOCATOR is returned when reachability
        for the requested locator has not been verified yet.</t>

        <t>Error code EUNREACHABLELOCATOR is returned when the requested
        locator is determined to be unreachable according to a
        reachability check.</t>

        <t>The usage of the option is the same as that of the
        SHIM_LOC_LOCAL_SEND option.</t>

      </section>

      <section title="SHIM_LOCLIST_LOCAL">

        <t>The SHIM_LOCLIST_LOCAL option is used to get or set the
        locator list associated with the local EID of the shim context
        associated with the socket.  This option is effective only
        when there is a shim context associated with the socket.</t>

        <t>The data type of the option value is a pointer to the
        buffer in which a locator list is stored.  See <xref
        target="sec-data-structures"/> for the data structure for
        storing the locator information.  By default, the option value
        is set to NULL, meaning that the option is disabled.</t>

        <t>An application can get the locator list by getsockopt().
        Note that the size of the buffer pointed to by the optval
        argument SHOULD be large enough to store an array of locator
        information.  The number of the locator information is not
        known beforehand.</t>

        <t>The local locator list can be set by setsockopt().  The
        buffer pointed to by the optval argument MUST contain an array
        of locator structures.</t>

        <t>When the application specifies the socket option to an
        unconnected socket, error code EOPNOTSUPP is returned to
        the application.</t>

        <t>When there is no shim context associated with the socket,
        error code ENOENT is returned to the application.</t>

        <t>Error code EINVALIDLOCATOR is returned when the validation of
        any of the specified locators failed.</t>

        <t>Error code ETOOMANYLOCATORS is returned when the number of
        locators specified exceeds the limit (SHIM_MAX_LOCATORS), or
        when the size of the buffer provided by the application is not
        large enough to store the locator list provided by the shim
        sub-layer.</t>

        <t>For example, an application can set a list of locators to
        be associated with the local EID by using the socket option as
        follows.  Note that an IPv4 locator can be handled by HIP and not
        by Shim6.</t>

        <figure>
          <artwork><![CDATA[
    struct shim_locator locators[SHIM_MAX_LOCATORS];
    struct sockaddr_in *sin;
    struct sockaddr_in6 *sin6;

    memset(locators, 0, sizeof(locators));

    ...

    /* obtain local IP addresses from local interfaces */

    ...

    /* first locator (an IPv6 address) */
    locators[0].lc_family = AF_INET6;
    locators[0].lc_ifidx = 0;
    locators[0].lc_flags = 0;
    locators[0].lc_prio = 1;
    locators[0].lc_weight = 0;
    memcpy(&locators[0].lc_addr, &sa6->sin6_addr,
           sizeof(sa6->sin6_addr));

    ...

    /* second locator (an IPv4 address) */
    locators[1].lc_family = AF_INET;
    locators[1].lc_ifidx = 0;
    locators[1].lc_flags = 0;
    locators[1].lc_prio = 0;
    locators[1].lc_weight = 0;
    memcpy(&locators[1].lc_addr, &sa->sin_addr,
           sizeof(sa->sin_addr));

    setsockopt(fd, SOL_SHIM, SHIM_LOCLIST_LOCAL, locators,
               sizeof(locators));
               ]]></artwork>
        </figure>

        <t>For example, an application can get a list of locators that
        are associated with the local EID by using the socket option
        as follows:</t>

        <figure>
          <artwork><![CDATA[
    struct shim_locator locators[SHIM_MAX_LOCATORS];

    memset(locators, 0, sizeof(locators));

    getsockopt(fd, SOL_SHIM, SHIM_LOC_LOCAL_RECV, locators,
               sizeof(locators));

    /* parse locators */
    ...

    ]]></artwork>
        </figure>

      </section>

      <section title="SHIM_LOCLIST_PEER">

        <t>The SHIM_LOCLIST_PEER option is used to get or set the
        locator list associated with the peer EID of the shim context
        associated with the socket.  This option is effective only
        when there is a shim context associated with the socket.</t>

        <t>The data type of the option value is a pointer to the
        buffer where a locator list is stored.  See <xref
        target="sec-data-structures"/> for the data structure for
        storing the locator information.  By default, the option value
        is set to NULL, meaning that the option is disabled.</t>

        <t>An application can get the locator list by getsockopt().
        Note that the size of the buffer pointed to by the optval
        argument SHOULD be large enough to store an array of locator
        information.  The number of the locator information is not
        known beforehand.</t>

        <t>An application can set the locator list by setsockopt().
        The buffer pointed to by the optval argument MUST contain an
        array of locator list items.</t>

        <t>When the application specifies the socket option to an
        unconnected socket, error code EOPNOTSUPP is returned to
        the application.</t>
        
        <t>When there is no shim context associated with the socket,
        error code ENOENT is returned to the application.</t>

        <t>Error code EINVALIDLOCATOR is returned when the validation of
        any of the specified locators failed.</t>

        <t>Error code EUNVERIFIEDLOCATOR is returned when reachability
        for the requested locator has not been verified yet.</t>

        <t>Error code EUNREACHABLELOCATOR is returned when the requested
        locator is determined to be unreachable according to a
        reachability check.</t>

        <t>Error code ETOOMANYLOCATORS is returned when the number of
        locators specified exceeds the limit (SHIM_MAX_LOCATORS), or
        when the size of the buffer provided by the application is not
        large enough to store the locator list provided by the shim
        sub-layer.</t>

        <t>The usage of the option is the same as that of
        SHIM_LOCLIST_LOCAL.</t>

      </section>

      <section title="SHIM_APP_TIMEOUT">

        <t>The SHIM_APP_TIMEOUT option is used to get or set the Send
        Timeout value of REAP <xref target="RFC5534"/>.
        This option is effective only when there is a shim context
        associated with the socket.</t>

        <t>The data type of the option value is an integer.  The value
        indicates the period of timeout in seconds to send a REAP
        Keepalive message since the last outbound traffic.  By
        default, the option value is set to 0, meaning that the option
        is disabled.  When the option is disabled, the REAP mechanism
        follows its default Send Timeout value as specified
        in <xref target="RFC5534"/>.</t>

        <t>When the application specifies the socket option to an
        unconnected socket, error code EOPNOTSUPP is returned to
        the application.</t>

        <t>When there is no shim context associated with the socket,
        error code ENOENT is returned to the application.</t>

        <t>When there is no REAP instance on the system,
        error code EOPNOTSUPP is returned to the application.</t>

        <t>For example, an application can set the timeout value by
        using the socket option as follows:</t>

        <figure>
          <artwork><![CDATA[
    int optval;

    optval = 15; /* 15 seconds */

    setsockopt(fd, SOL_SHIM, SHIM_APP_TIMEOUT, &optval,
               sizeof(optval));
    ]]></artwork>
        </figure>

        <t>For example, an application can get the timeout value by
        using the socket option as follows:</t>

        <figure>
          <artwork><![CDATA[
    int optval;
    int len;

    len = sizeof(optval);

    getsockopt(fd, SOL_SHIM, SHIM_APP_TIMEOUT, &optval, &len);
    ]]></artwork>
        </figure>

      </section>

      <section title="SHIM_PATHEXPLORE">

        <t>The application MAY use this socket option to get or set
        parameters concerning path exploration.  Path exploration is a
        procedure to find an alternative locator pair to the current
        locator pair.  As the REAP specification defines, a peer may
        send Probe messages to find an alternative locator pair.</t>

        <t>This option is effective only when there is a shim context
        associated with the socket.</t>

        <t>The data type of the option value is a pointer to the
        buffer where a set of information for path exploration is
        stored.  The data structure is defined in <xref
        target="sec-data-structures"/>.</t>

        <t>By default, the option value is set to NULL, meaning that
        the option is disabled.</t>

        <t>When the application specifies the socket option to an
        unconnected socket, error code EOPNOTSUPP is returned to
        the application.</t>

        <t>When there is no shim context associated with the socket,
        error code ENOENT is returned to the application.</t>

        <t>For example, an application can set parameters for path
        exploration by using the socket option as follows:</t>

        <figure>
          <artwork><![CDATA[
    struct shim6_pathexplore pe;

    pe.pe_probenum = 4;        /* times */
    pe.pe_keepaliveto = 10;    /* seconds */
    pe.pe_initprobeto = 500;   /* milliseconds */
    pe.pe_reserved = 0;

    setsockopt(fd, SOL_SHIM, SHIM_PATHEXPLORE, &pe, sizeof(pe));
    ]]></artwork>
        </figure>

        <t>For example, an application can get parameters for path
        exploration by using the socket option as follows:</t>

        <figure>
          <artwork><![CDATA[
    struct shim6_pathexplore pe;
    int len;

    len = sizeof(pe);

    getsockopt(fd, SOL_SHIM, SHIM_PATHEXPLORE, &pe, &len);
    ]]></artwork>
        </figure>

      </section>

      <section title="SHIM_DEFERRED_CONTEXT_SETUP">

        <t>The SHIM_DEFERRED_CONTEXT_SETUP option is used to check
        whether or not deferred context setup is possible.  Deferred
        context setup means that the context is established in
        parallel with the data communication.  Note that Shim6
        supports deferred context setup and HIP does not, because EIDs
        in HIP (i.e., Host Identifiers) are non-routable.</t>

        <t>Note that the socket option is read-only, and the option
        value can be read by getsockopt().</t>

        <t>The data type for the option value is an integer.  The
        option value MUST be binary (0 or 1).  The option value of 1
        means that the shim sub-layer supports deferred context setup.
        </t>

        <t>When the application specifies the socket option to an
        unconnected socket, error code EOPNOTSUPP is returned to
        the application.</t>

        <t>For example, an application can check whether deferred
        context setup is possible or not as follows:</t>

        <figure>
          <artwork><![CDATA[
    int optval;
    int len;

    len = sizeof(optval);

    getsockopt(fd, SOL_SHIM, SHIM_DEFERRED_CONTEXT_SETUP,
               &optval, &len);
               ]]></artwork>
        </figure>

      </section>

      <section title="Applicability"
               anchor="sec-socket-options-applicability"
               toc="include">

        <t>All the socket options defined in this section except for
          the SHIM_DONTSHIM option are applicable to applications that
          use connected sockets.</t>

        <t>All the socket options defined in this section except for
          the SHIM_ASSOCIATED, SHIM_DONTSHIM, and
          SHIM_CONTEXT_DEFERRED_SETUP options are effective only when
          there is a shim context associated with the socket.</t>

      </section>

      <section title="Error Handling">

        <t>If successful, getsockopt() and setsockopt() return 0;
        otherwise, the functions return -1 and set errno to indicate
        an error.</t>

        <t>The following are new error values defined for some
        shim-specific socket options indicating that the getsockopt() or
        setsockopt() finished incompletely:

        <list style="hanging">

          <t hangText="EINVALIDLOCATOR"><vspace blankLines="0"/>This
          indicates that the locator is not part of the HBA
          set <xref target="RFC5535"/> within the shim context
          associated with the socket.</t>

          <t hangText="EUNVERIFIEDLOCATOR"><vspace blankLines="0"/>This
          indicates that the reachability of the locator has not been
          confirmed.  This error is applicable to only the peer's
          locator.</t>

          <t hangText="EUNREACHABLELOCATOR"><vspace blankLines="0"/>This
          indicates that the locator is not reachable according to the
          result of the reachability check.  This error is applicable
          to only the peer's locator.</t>

        </list>
        </t>
      </section>

    </section>

    <section title="Ancillary Data for Multihoming Shim Sub-Layer"
             anchor="sec-access-to-locinfo" toc="include">

      <t>This section provides definitions of ancillary data to be
      used for locator management and notification from/to the shim
      sub-layer to/from the application.</t>

      <t>When the application performs locator management by sendmsg()
      or recvmsg(), a member of the msghdr structure (given in
      <xref target="fig-msghdr" />) called msg_control holds a pointer
      to the buffer in which one or more shim-specific ancillary data
      objects may be stored.  An ancillary data object can store a
      single locator.  It should be possible to process the
      shim-specific ancillary data object by the existing macros defined in
      the POSIX standard and <xref target='RFC3542'/>.</t>
      
      <figure anchor="fig-msghdr" title="msghdr Structure">
        <artwork><![CDATA[
     struct msghdr {
             caddr_t msg_name;       /* optional address */
             u_int   msg_namelen;    /* size of address */
             struct  iovec *msg_iov; /* scatter/gather array */
             u_int   msg_iovlen;     /* # elements in msg_iov */
             caddr_t msg_control;    /* ancillary data, see below */
             u_int   msg_controllen; /* ancillary data buffer len */
             int     msg_flags;      /* flags on received message */
     };
    ]]></artwork>
      </figure>

      <t>In the case of an unconnected socket, msg_name stores the socket
      address of the peer.  Note that the address is not a locator of
      the peer but the identifier of the peer.  SHIM_LOC_PEER_RECV can
      be used to get the locator of the peer node.</t>

      <t><xref target="tab-shim-ancillary-data"/> is a list of the
      shim-specific ancillary data that can be used for locator
      management by recvmsg() or sendmsg().  In any case, the value of
      cmsg_level MUST be set to SOL_SHIM.</t>
      
      <texttable anchor="tab-shim-ancillary-data"
                 title="Shim-Specific Ancillary Data">

        <ttcol align='left'>cmsg_type</ttcol>
        <ttcol align='center'>sendmsg()</ttcol>
        <ttcol align='center'>recvmsg()</ttcol>
        <ttcol align='center'>cmsg_data[]</ttcol>

        <c>SHIM_LOC_LOCAL_RECV</c>
        <c></c>
        <c>o</c>
        <c>Note 1</c>

        <c>SHIM_LOC_PEER_RECV</c>
        <c></c>
        <c>o</c>
        <c>Note 1</c>

        <c>SHIM_LOC_LOCAL_SEND</c>
        <c>o</c>
        <c></c>
        <c>Note 1</c>

        <c>SHIM_LOC_PEER_SEND</c>
        <c>o</c>
        <c></c>
        <c>Note 1</c>

        <c>SHIM_FEEDBACK</c>
        <c>o</c>
        <c></c>
        <c>shim_feedback{}</c>
        
      </texttable>

      <t>Note 1: cmsg_data[] within msg_control includes a single
      sockaddr_in{} or sockaddr_in6{} and padding if necessary</t>

      <section title="Get Locator from Incoming Packet">

        <t>An application can get locator information from the
        received IP packet by specifying the shim-specific socket
        options for the socket.  When SHIM_LOC_LOCAL_RECV and/or
        SHIM_LOC_PEER_RECV socket options are set, the application can
        retrieve a local and/or remote locator from the ancillary
        data.</t>

        <t>When there is no shim context associated with the socket,
        the shim sub-layer MUST return zero-filled locator information
        to the application.</t>

      </section>
      
      <section title="Set Locator for Outgoing Packet">

        <t>An application can specify the locators to be used for
        transmitting an IP packet by sendmsg().  When the ancillary
        data of cmsg_type SHIM_LOC_LOCAL_SEND and/or
        SHIM_LOC_PEER_SEND are specified, the application can
        explicitly specify the source and/or the destination locators
        to be used for the communication over the socket.  If the
        specified locator pair is verified, the shim sub-layer
        overrides the locator(s) of the outgoing IP packet.  Note that
        the effect is limited to the datagram transmitted by the
        sendmsg().</t>

        <t>When there is no shim context associated with the socket,
        error code ENOENT is returned to the application.</t>

        <t>Error code EINVALIDLOCATOR is returned when validation
        of the specified locator fails.</t>

        <t>Error code EUNVERIFIEDLOCATOR is returned when reachability
        for the requested locator has not been verified yet.  The
        application is recommended to use another destination locator
        until the reachability check for the requested locator is
        done.</t>

        <t>Error code EUNREACHABLELOCATOR is returned when the requested
        locator is determined to be unreachable according to a
        reachability check.  The application is recommended to use
        another destination locator when receiving the error.</t>

      </section>

      <section title="Notification from Application to Multihoming Shim Sub-Layer"
               anchor="sec-feedback" toc="include">

        <t>An application MAY provide feedback to the shim sub-layer
        about the communication status.  Such feedback is useful for
        the shim sub-layer to monitor the reachability status of the
        currently used locator pair in a given shim context.</t>

        <t>The notification can be made by sendmsg() specifying a new
        ancillary data called SHIM_FEEDBACK.  The ancillary data can
        be handled by specifying the SHIM_FEEDBACK option in
        cmsg_type.</t>

        <t>When there is no shim context associated with the socket,
        error code ENOENT is returned to the application.</t>

        <t>See <xref target="sec-feedback-info"/> for details of the
        data structure to be used.</t>

        <t>It is outside the scope of this document to describe how the shim
        sub-layer would react when feedback is provided by an
        application.</t>
          
      </section>

      <section title="Applicability" 
               anchor="sec-ancillary-data-applicability"
               toc="include">

        <t>All the ancillary data for the shim sub-layer is applicable
        to connected sockets.</t>

        <t>Care is needed when the SHIM_LOC_*_RECV socket option is
        used for stream-oriented sockets (e.g., TCP sockets) because
        there is no one-to-one mapping between a single send or
        receive operation and the data (e.g., a TCP segment) being
        received.  In other words, there is no guarantee that the
        locator(s) set in the SHIM_LOC_*_RECV ancillary data is
        identical to the locator(s) that appears in the IP packets
        received.  The shim sub-layer SHOULD provide the latest
        locator information to the application in response to the
        SHIM_LOC_*_RECV socket option.
        </t>

      </section>

    </section>
      
    <section title="Data Structures"
             anchor="sec-data-structures" toc="include">

      <t>This section gives data structures for the shim sub-layer.
      These data structures are either used as a parameter for
      setsockopt() or getsockopt() (as mentioned in
      <xref target="sec-shim-socket-options"/>), or as a parameter for
      ancillary data to be processed by sendmsg() or recvmsg() (as
      mentioned in <xref target="sec-access-to-locinfo"/>).</t>

      <section title="Data Structure for Locator Information" anchor="sec-data-struct-loc-info">
        
        <t>As defined in <xref target="sec-shim-socket-options"/>, the
        SHIM_LOC_*_PREF, SHIM_LOC_*_SEND, and SHIM_LOCLIST_* socket
        options need to handle one or more locator information points.
        Locator information includes not only the locator itself but
        also additional information about the locator that is useful
        for locator management.  A new data structure is defined to
        serve as a placeholder for the locator information.</t>

        <t><xref target="fig-shim-locator"/> illustrates the data
        structure called shim_locator, which stores locator
        information.

        <figure anchor="fig-shim-locator" title="Shim Locator Structure">
          <artwork><![CDATA[
     struct shim_locator {
             uint8_t    lc_family;       /* address family */
             uint8_t    lc_proto;        /* protocol */
             uint16_t   lc_port;         /* port number */ 
             uint16_t   lc_prio;         /* preference value */
             uint16_t   lc_weight;       /* weight */
             uint32_t   lc_ifidx;        /* interface index */
             struct in6_addr lc_addr;    /* address */ 
             uint16_t   lc_flags;        /* flags */
     };
     ]]></artwork>
        </figure>

        <list style="hanging">

          <t hangText="lc_family"><vspace blankLines="0"/> Address
          family of the locator (e.g., AF_INET, AF_INET6).  It is
          required that the parameter contains a non-zero value
          indicating the exact address family of the locator.</t>

          <t hangText="lc_proto"><vspace blankLines="0"/>Internet
          Protocol number for the protocol that is used to handle a
          locator behind a NAT.  The value MUST be set to zero when
          there is no NAT involved.  When the locator is behind a NAT,
          the value MUST be set to IPPROTO_UDP.</t>

          <t hangText="lc_port"><vspace blankLines="0"/>Port number
          that is used for handling a locator behind a NAT.</t>

          <t hangText="lc_prio"><vspace blankLines="0"/>Priority
          of the locator.  The range is 0-65535.  The lowest priority
          value means the highest priority.</t>

          <t hangText="lc_weight"><vspace blankLines="0"/>Weight
          value indicates a relative weight for locators with the same
          priority value.  The range is 0-65535.  A locator with
          higher weight value is prioritized over the other locators
          with lower weight values.</t>

          <t hangText="lc_ifidx"><vspace blankLines="0"/>Interface
          index of the network interface to which the locator is
          assigned.  This field is applicable only to local locators,
          and has no effect in set operations.</t>

          <t hangText="lc_addr"><vspace blankLines="0"/>Contains the
          locator.  In the case of IPv4, the locator MUST be formatted in
          the IPv4-mapped IPv6 address as defined in
          <xref target='RFC4291'/>.  The locator MUST be stored in
          network byte order.</t>

          <t hangText="lc_flags"><vspace blankLines="0"/>Each bit of
          the flags represents a specific characteristic of the
          locator.  The Hash-Based Address (HBA) is defined as 0x01.  The
          Cryptographically Generated Address (CGA) is defined as
          0x02.  This field has no effect in set operations.</t>

        </list>
        </t>

        <section title="Handling Locator behind NAT"
                 anchor="sec-locator-behind-nat">
          <t>Note that the locator information MAY contain a locator
          behind a Network Address Translator (NAT).  Such a situation
          may arise when the host is behind the NAT and uses a local
          address as a source locator to communicate with the peer.
          Note that a NAT traversal mechanism for HIP is defined,
          which allows a HIP host to tunnel control and data traffic
          over UDP <xref target='RFC5770'/>.  Note also that the
          locator behind a NAT is not necessarily an IPv4 address and
          can be an IPv6 address.  Below is an example where the
          application sets a UDP encapsulation interface as a source
          locator when sending IP packets.

        <figure anchor="fig-nat-locator-handling" title="Handling
        Locator behind NAT"><artwork><![CDATA[
       struct shim_locator locator;
       struct in6_addr ia6;

       /* copy the private IPv4 address to the ia6 as an IPv4-mapped
          IPv6 address */

       memset(&locator, 0, sizeof(locator));

       /* fill shim_locator data structure */
       locator.lc_family = AF_INET;
       locator.lc_proto = IPPROTO_UDP;
       locator.lc_port = 50500;
       locator.lc_ifidx = 0;
       locator.lc_flags = 0;
       locator.lc_prio = 0;
       locator.lc_weight = 0;

       memcpy(&locator.lc_addr, &ia6, sizeof(ia6));

       setsockopt(fd, SOL_SHIM, SHIM_LOC_LOCAL_SEND, &locator,
                  sizeof(locator));
       ]]></artwork>
        </figure>
          </t>
        </section>
      </section>

      <section title="Path Exploration Parameter">

        <t>As defined in <xref target="sec-shim-socket-options"/>,
        SHIM_PATHEXPLORE allows an application to set or read the
        parameters for path exploration and failure detection.  A new
        data structure called shim_pathexplore is defined to store the
        necessary parameters.  <xref target="fig-path-explore"/>
        illustrates the data structure.  The data structure can be
        passed to getsockopt() or setsockopt() as an argument.

        <figure anchor="fig-path-explore" title="Path Explore Structure">
          <artwork><![CDATA[
     struct shim_pathexplore {
             uint16_t  pe_probenum;      /* # of initial probes */
             uint16_t  pe_keepaliveto;   /* Keepalive Timeout */
             uint16_t  pe_keepaliveint   /* Keepalive Interval */
             uint16_t  pe_initprobeto;   /* Initial Probe Timeout */
             uint32_t  pe_reserved;      /* reserved */
     };
     ]]></artwork>
        </figure>

        <list style="hanging">
          <t hangText="pe_probenum">
            <vspace blankLines="0"/> Indicates the number of initial
            Probe messages to be sent.  The value MUST be set as per
            <xref target="RFC5534"/>.
          </t>
          <t hangText="pe_keepaliveto">
            <vspace blankLines="0"/> Indicates the timeout value in
            seconds for detecting a failure when the host does not
            receive any packets for a certain period of time while
            there is outbound traffic.  When the timer expires, the path
            exploration procedure will be carried out by sending a
            REAP Probe message.  The value MUST be set as per
            <xref target="RFC5534"/>.
          </t>
          <t hangText="pe_keepaliveint">
            <vspace blankLines="0"/> Indicates the interval of REAP
            Keepalive messages in seconds to be sent by the host when
            there is no outbound traffic to the peer host.  The value
            MUST be set as per <xref target="RFC5534"/>.
          </t>
          <t hangText="pe_initprobeto">
            <vspace blankLines="0"/> Indicates the retransmission timer of
            the REAP Probe message in milliseconds.  Note that this timer
            is applied before exponential back-off is started.  A REAP
            Probe message for the same locator pair may be
            retransmitted.  The value MUST be set as per
            <xref target="RFC5534"/>.
          </t>
          <t hangText="pe_reserved">
            <vspace blankLines="0"/> A reserved field for future
            extension.  By default, the field MUST be initialized to
            zero.
          </t>
        </list>
        </t>
        
      </section>

      <section title="Feedback Information" anchor="sec-feedback-info">
        
        <t>As mentioned in <xref target="sec-feedback"/>, applications
        can inform the shim sub-layer about the status of unicast
        reachability of the locator pair currently in use.  The
        feedback information can be handled by using ancillary data
        called SHIM_FEEDBACK.  A new data structure named
        shim_feedback is illustrated in <xref
        target="fig-feedback-info"/>.

        <figure anchor="fig-feedback-info"
                title="Feedback Information Structure">
          <artwork><![CDATA[
     struct shim_feedback {
             uint8_t   fb_direction;    /* direction of traffic */
             uint8_t   fb_indicator;    /* indicator (1-3) */
             uint16_t  fb_reserved;     /* reserved */
     };
     ]]></artwork>
        </figure>

        <list style="hanging">
          <t hangText="fb_direction">
            <vspace blankLines="0"/>
            Indicates the direction of reachability between the locator pair
            in question.  A value of 0 indicates outbound direction, and a
            value of 1 indicates inbound direction.
          </t>
          <t hangText="fb_indicator">
            <vspace blankLines="0"/>
            A value indicating the degree of satisfaction of a
            unidirectional reachability for a given locator pair.
          
            <list style="symbols">
              <t>0: Default value.  Whenever this value is specified,
              the feedback information MUST NOT be processed by the
              shim sub-layer.</t>

              <t>1: Unable to connect.  There is no unidirectional
              reachability between the locator pair in question.</t>
              
              <t>2: Unsatisfactory.  The application is not satisfied
              with the unidirectional reachability between the locator
              pair in question.</t>
              
              <t>3: Satisfactory.  There is satisfactory
              unidirectional reachability between the locator pair in
              question.</t>
            </list>
          </t>
          
          <t hangText="fb_reserved">
            <vspace blankLines="0"/>
            Reserved field.  MUST be ignored by the receiver.
          </t>
        </list>

        </t>

      </section>

    </section>

    <section title="System Requirements"
             anchor="sec-system-requirements"
             toc="include">

      <t>As addressed in <xref target="sec-shim-socket-options"/>,
      most of the socket options and ancillary data defined in this
      document are applicable to connected sockets.  It is assumed
      that the kernel is capable of maintaining the association
      between a connected socket and a shim context.  This requirement
      is considered to be reasonable because a pair of source and
      destination IP addresses is bound to a connected socket.</t>

    </section>
    
    <section title="Relation to Existing Sockets API Extensions"
             anchor="sec-implications-for-legacyapi" toc="include">

      <t>This section explains the relation between the sockets API
      defined in this document and the existing sockets API
      extensions.</t>

      <t>As mentioned in <xref target="sec-shim-socket-options"/>, the
      basic assumption is that the existing sockets API continues to
      work above the shim sub-layer.  This means that the existing
      sockets API deals with identifiers, and the sockets API defined
      in this document deals with locators.</t>

      <t>SHIM_LOC_LOCAL_SEND and SHIM_LOC_PEER_SEND socket options are
      semantically similar to the IPV6_PKTINFO sockets API in the sense
      that both provide a means for an application to set the source IP
      address of outbound IP packets.</t>

      <t>SHIM_LOC_LOCAL_RECV and SHIM_LOC_PEER_RECV socket options are
      semantically similar to the IP_RECVDSTADDR and IPV6_PKTINFO
      sockets APIs in the sense that both provide a means for an
      application to get the source and/or destination IP address of
      inbound IP packets.</t>

      <t>getsockname() and getpeername() enable an application to get the
      "name" of the communication endpoints, which is represented by a
      pair of IP addresses and port numbers assigned to the
      socket.  getsockname() gives the IP address and port number
      assigned to the socket on the local side, and getpeername() gives
      the IP address and port number of the peer side.</t>

    </section>

    <section title="Operational Considerations">

      <t>This section gives operational considerations of the sockets
      API defined in this document.</t>

      <section title="Conflict Resolution">

        <t>There can be a conflicting situation when different
        applications specify different preferences for the same shim
        context.  For instance, suppose that applications A and B
        establish communication with the same EID pair while both
        applications have different preferences in their choice of
        local locator.  The notion of context forking in Shim6 can
        resolve the conflicting situation.</t>

        <!-- conflict among different applications -->
        <t>It is possible that socket options defined in
        <xref target="sec-shim-socket-options"/> cause a conflicting
        situation when the target context is shared by multiple
        applications.  In such a case, the socket handler should
        inform the shim sub-layer that context forking is required.
        In Shim6, when a context is forked, a unique identifier
        called the Forked Instance Identifier (FII) is assigned to the
        newly forked context.  The forked context is then exclusively
        associated with the socket through which a non-default
        preference value was specified.  The forked context is
        maintained by the shim sub-layer during the lifetime of the
        associated socket instance.  When the socket is closed, the
        shim sub-layer SHOULD delete the associated context.</t>

        <!-- conflict among SHIM_LOC_*_SEND and SHIM_LOC_*_PREF -->
        <t>When the application specifies SHIM_LOC_*_SEND specifying a
        different source or destination locator that does not have
        the highest priority and weight specified by the
        SHIM_LOC_*_PREF, the shim sub-layer SHOULD supersede the
        request made by SHIM_LOC_*_SEND over the preference specified
        by SHIM_LOC_*_PREF.</t>

        <!-- conflict among local and remote -->
        <t>When the peer provides preferences of the locators (e.g., a
        Shim6 peer sends a locator with a Locator Preferences Option)
        that conflict with preferences specified by the applications
        either by SHIM_LOC_PEER_SEND or SHIM_LOC_PEER_PREF, the shim
        sub-layer SHOULD supersede the preferences made by the
        applications over the preferences specified by the peer.
        </t>

      </section>
      
      <section title="Incompatibility between IPv4 and IPv6">
        
        <t>The shim sub-layer performs identifier/locator adaptation.
        Therefore, in some cases, the whole IP header can be replaced
        with a new IP header of a different address family
        (e.g., conversion from IPv4 to IPv6 or vice versa).  Hence,
        there is an issue regarding how to make the conversion with minimum
        impact.  Note that this issue is common in other protocol
        conversion techniques
        <xref target="RFC2765"/> <xref target="RFC6145"/>.</t>

        <t>As studied in the previous works on protocol
        conversion <xref target="RFC2765"/>, <xref target="RFC6145"/>
        some of the features (IPv6 routing headers, hop-by-hop
        extension headers, and destination headers) from IPv6 are not
        convertible to IPv4.  In addition, the notion of source routing is
        not exactly the same in IPv4 and IPv6.  This means that an
        error may occur during the conversion of the identifier and
        locator.  It is outside the scope of this document to describe
        how the shim sub-layer should behave in such erroneous
        cases.</t>

      </section>

    </section>

    <!--
        ================================================================
        IANA Consideration
        ================================================================
    -->
    <section title="IANA Considerations" toc="default">
      <t>There are no IANA considerations for the socket options
        (SHIM_*), the ancillary data, and the socket level (SOL_SHIM)
        that are defined in this document.  All the numbers concerned
        are not under the control of the IETF or IANA, but they are
        platform-specific.</t>
    </section>

    <section title="Protocol Constant" toc="default">
      <t>This section defines a protocol constant.
        <list style="hanging">
          <t hangText="SHIM_MAX_LOCATORS">The maximum number of 
            locators to be included in a locator list.  The value is
            set to 32.</t>
        </list>
      </t>

    </section>

    <!--
        ================================================================
        Security Consideration
        ================================================================
    -->
    <section title="Security Considerations" toc="default">

      <t>This section gives security considerations of the API defined
        in this document.</t>

      <section title="Treatment of Unknown Locator">
        
        <t>When sending IP packets, there is a possibility that an
        application will request the use of an unknown locator for the source
        and/or destination locators.  Note that the treatment of an unknown
        locator can be a subject of security considerations, because the
        use of an invalid source and/or destination locator may cause a
        redirection attack.</t>

        <section title="Treatment of Unknown Source Locator">
          
          <t>The shim sub-layer checks to determine if the requested locator is
          available on any local interface.  If not, the shim
          sub-layer MUST reject the request and return an error
          message with the EINVALIDLOCATOR code to the application.
          If the locator is confirmed to be available, the shim
          sub-layer SHOULD initiate the procedure to update the
          locator list.</t>

          <t>Use of the following socket options and ancillary data
          requires treatment of an unknown source locator:

            <list style="symbols">
              <t>SHIM_LOC_LOCAL_SEND</t>
              <t>SHIM_LOC_LOCAL_PREF</t>
              <t>SHIM_LOCLIST_LOCAL</t>
            </list>

          </t>

        </section>

        <section title="Treatment of Unknown Destination Locator">

          <t>If the shim sub-layer turns out to be Shim6, the Shim6
          layer MUST reject the request for using an unknown
          destination locator.</t>
          
          <t>If the shim sub-layer turns out to be HIP, the HIP layer
          MUST reject the request for using an unknown destination
          locator.  There is, however, an exceptional case where the
          HIP layer SHOULD accept the request, provided that the HIP
          association is in the UNASSOCIATED state.
  Details of locator
          handling in HIP are described in Section&nbsp;4.6
          of <xref target="RFC6317"/>.</t>

          <t>Use of the following socket options and ancillary data
          requires treatment of an unknown destination locator:

            <list style="symbols">
              <t>SHIM_LOC_PEER_SEND</t>
              <t>SHIM_LOC_PEER_PREF</t>
              <t>SHIM_LOCLIST_PEER</t>
            </list>

          </t>

        </section>

      </section>

    </section>

    <!--
        ================================================================
        Acknowledgment
        ================================================================
    -->
    <section title ="Acknowledgments" toc="include">

      <t>The authors would like to thank Jari Arkko, who participated in
      the discussion that led to the first version of this document,
      and Tatuya Jinmei, who thoroughly reviewed the early draft version of
      this document and provided detailed comments on sockets API-related
      issues.  Thomas Henderson provided valuable comments, especially
      from the HIP perspective.</t>

      <t>The authors sincerely thank the following people for their
      helpful comments regarding the document: Samu Varjonen, Dmitriy
      Kuptsov, Brian Carpenter, Michael Scharf, Sebastien
      Barre, and Roni Even.</t>

    </section>
  </middle>

  <back>
    <!--
        ================================================================
        References
        ================================================================
    -->

    <references title="Normative References">
      &RFC2119;
      &RFC3542;
      &RFC4423;
      &RFC5533;
      &RFC5534;
      <reference anchor='POSIX' target="http://www.opengroup.org/austin">
        <front>
          <title>IEEE Std. 1003.1-2008 Standard for Information
          Technology -- Portable Operating System Interface
          (POSIX).  Open group Technical Standard: Base Specifications,
          Issue 7</title>
          <author initials='' surname=''
                  fullname='IEEE Standard'>
            <organization />
          </author>
          <date month='September' year='2008' />
        </front>
      </reference>
    </references>

    <references title="Informative References">

<reference anchor="RFC6145">
<front>
<title>IP/ICMP Translation Algorithm</title>
<author initials="X" surname="Li" fullname="Xing Li"/>
<author initials="C" surname="Bao" fullname="Congxiao Bao"/>
<author initials="F" surname="Baker" fullname="Fred Baker"/>
<date month="April" year="2011"/>
</front>
<seriesInfo name="RFC" value="6145"/>
</reference>

<reference anchor='SHIM6-APP-REFER'>
<front>
<title>Shim6 Application Referral Issues</title>
<author initials='E' surname='Nordmark' fullname='Erik Nordmark'>
    <organization />
</author>
<date month='July' year='2005' />
</front>
<seriesInfo name='Work in' value='Progress' />
</reference>

      &RFC2765;
      &RFC2782;
      <!-- &RFC3972; -->
      &RFC4291;
      &RFC5535;

<reference anchor='RFC5770'>
<front>
<title>Basic Host Identity Protocol (HIP) Extensions for Traversal of Network Address Translators</title>
<author initials='M.' surname='Komu' fullname='M. Komu'>
<organization /></author>
<author initials='T.' surname='Henderson' fullname='T. Henderson'>
<organization /></author>
<author initials='H.' surname='Tschofenig' fullname='H. Tschofenig'>
<organization /></author>
<author initials='J.' surname='Melen' fullname='J. Melen'>
<organization /></author>
<author initials='A.' surname='Keranen' fullname='A. Keranen' role="editor">
<organization /></author>
<date year='2010' month='April' />
</front>
<seriesInfo name='RFC' value='5770' />
</reference>

<!-- draft-ietf-shim6-multihome-shim-api -->
<reference anchor='RFC6317'>
<front>
<title>Basic Socket Interface Extensions for the Host Identity Protocol (HIP)</title>
<author initials='M' surname='Komu' fullname='Miika Komu'>
    <organization />
</author>
<author initials='T' surname='Henderson' fullname='Tom Henderson'>
    <organization />
</author>
<date month='July' year='2011' />
</front>
<seriesInfo name='RFC' value='6317' />
</reference>

    </references>

      <section title="Context Forking">

        <t>In this section, an issue concerning context forking and
        its relation to the multihoming shim API are discussed.</t>
      
        <t>Shim6 supports the notion of context forking.  A peer may
        decide to fork a context for a certain reason (e.g., an upper-layer
        protocol prefers to use a different locator pair than the one
        defined in an available context).  The procedure of context forking
        is done similarly to the normal context establishment,
        performing the 4-way message exchange.  A peer who has decided
        to fork a context initiates the context establishment.
        Hereafter, we call this peer the "initiator".  The peer of the
        initiator is called the "responder".</t>

        <t>Once the forked context is established between the peers,
        on the initiator side, it is possible to apply forked context
        to the packet flow, since the system maintains an association
        between the forked context and the socket owned by the
        application that has requested the context forking.  How this
        association is maintained is an implementation-specific issue.
        However, on the responder side, there is a question of how the
        outbound packet can be multiplexed by the shim sub-layer,
        because there is more than one Shim6 context that matches with
        the ULID pair of the packet flow.  There is a need to
        differentiate packet flows not only by the ULID pairs but by
        some other information and associate a given packet flow with
        a specific context.</t>
      
        <t><xref target="fig-context-forking"/> gives an example of a
        scenario where two communicating peers fork a context.
        Initially, there has been a single transaction between the
        peers, by the application 1 (App1).  Accordingly, another
        transaction is started, by application 2 (App2).  Both of the
        transactions are made based on the same ULID pair.  The first
        context pair (Ctx1) is established for the transaction of
        App1.  Given the requests from App2, the shim sub-layer on
        Peer 1 decides to fork a context.  Accordingly, a forked
        context (Ctx2) is established between the peers, which should
        be exclusively applied to the transaction of App2.  Ideally,
        multiplexing and demultiplexing of packet flows that relate to
        App1 and App2 should be done as illustrated in
        <xref target="fig-context-forking"/>.  However, as mentioned
        earlier, the responder needs to multiplex outbound flows of
        App1 and App2 somehow.  Note that if a context forking occurs
        on the initiator side, a context forking needs to also occur
        on the responder side.

        <figure anchor="fig-context-forking" title="Context Forking">
          <artwork><![CDATA[
           Peer 1                                 Peer 2   
         (initiator)                            (responder)

    +----+         +----+                  +----+         +----+
    |App1|         |App2|                  |App1|         |App2|
    +----+         +----+                  +----+         +----+
      |^             |^                      ^|             ^|
      v|             v|                      |v             |v
 -----S1-------------S2-----            -----S1-------------S2-----
      ||             ||                      ||             ||
      ||             ||                      ||             ||

     Ctx1           Ctx2                    Ctx1           Ctx2
 ULID:<A1,B1>   ULID:<A1,B1>            ULID:<B1,A1>    ULID:<B1,A1>
 Loc: <A1,B2>   Loc: <A1,B3>            Loc: <B2,A1>    Loc: <B3,A1> 
 FII: 0         FII: 100                FII: 0          FII: 100
 
      |^             |^                      ^|             ^|
      ||             ||                      ||             ||
      ||             ||                      ||             ||
      \..............||....................../|             ||
       \.............||......................./             ||
                     ||                                     ||
                     \|...................................../|
                      \....................................../
       ]]></artwork>
        </figure>
        </t>

        <t>How to solve the issue described above is a topic for further study.</t>

      </section>
  </back>
</rfc>
