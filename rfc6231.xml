<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
	<!ENTITY rfc2119 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
	<!ENTITY rfc3261 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml'>
	<!ENTITY rfc3263 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3263.xml'>
	<!ENTITY rfc3264 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3264.xml'>
    <!ENTITY rfc4240 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4240.xml'>
    <!ENTITY rfc3986 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml'>
    <!ENTITY rfc2897 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2897.xml'>
    <!ENTITY rfc4574 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4574.xml'>
    <!ENTITY rfc4730 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4730.xml'>
    <!ENTITY rfc5022 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5022.xml'>
    <!ENTITY rfc5707 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5707.xml'>
    <!ENTITY rfc4281 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4281.xml'>
    <!ENTITY rfc3023 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3023.xml'>
    <!ENTITY rfc5646 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5646.xml'>
    <!ENTITY rfc4647 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4647.xml'>
    <!ENTITY rfc4733 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4733.xml'>
	<!ENTITY rfc5167 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5167.xml'>
	<!ENTITY rfc4855 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4855.xml'>
	<!ENTITY rfc4267 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4267.xml'>
	<!ENTITY rfc4244 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4244.xml'>
	<!ENTITY rfc4627 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml'>
    <!ENTITY smil2 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml4/reference.W3C.REC-SMIL2-20051213.xml'>	
	<!ENTITY rfc3688 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3688.xml'>
	<!ENTITY rfc2616 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml'>
	<!ENTITY rfc2818 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml'>
	<!ENTITY rfc4288 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4288.xml'>
	<!ENTITY rfc5234 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml'>
	<!ENTITY rfc5226 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml'>
	<!ENTITY rfc2045 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml'>
	<!ENTITY rfc2277 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2277.xml'>
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc number="6231" category="std" ipr="pre5378Trust200902">
	<front>

		<title abbrev="IVR Control Package">An Interactive Voice
		Response (IVR) Control Package for&nbsp;the&nbsp;Media&nbsp;Control&nbsp;Channel&nbsp;Framework</title>

		<author fullname="Scott McGlashan" initials="S." surname="McGlashan">
			<organization>Hewlett-Packard</organization>
			<address>
				<email>smcg.stds01@mcglashan.org</email>
			</address>
		</author>

		<author fullname="Tim Melanchuk" initials="T." surname="Melanchuk">
			<organization>Rainwillow</organization>
			<address>
				<email>timm@rainwillow.com</email>
			</address>
		</author>
		
		<author fullname="Chris Boulton" initials="C." surname="Boulton">
			<organization>NS-Technologies</organization>
			<address>
				<email>chris@ns-technologies.com</email>
			</address>
		</author>

		<date month="May" year="2011"/>

		<abstract>
			<t>This document defines a Media Control Channel Framework
			Package for Interactive Voice Response (IVR) dialog
			interaction on media connections and conferences.  The
			package defines dialog management request elements for
			preparing, starting, and terminating dialog interactions, as
			well as associated responses and notifications. Dialog
			interactions are specified in a dialog language.  This
			package defines a lightweight IVR dialog language
			(supporting prompt playback, runtime controls, Dual-Tone
			Multi-Frequency (DTMF) collection, and media recording) and
			allows other dialog languages to be used.  The package also
			defines elements for auditing package capabilities and IVR
			dialogs.
            </t>
		</abstract>
	</front>

	<middle>

<section title="Introduction">

<t>The Media Control Channel Framework <xref
target="RFC6230"/> provides a generic
approach for establishment and reporting capabilities of remotely
initiated commands.  The Channel Framework -- an equivalent term for the
Media Control Channel Framework -- utilizes many functions provided by
the Session Initiation Protocol (SIP) <xref target="RFC3261"/> for the
rendezvous and establishment of a reliable channel for control
interactions.  The Control Framework also introduces the concept of a
Control Package.  A Control Package is an explicit usage of the Control
Framework for a particular interaction set.  This document defines a
Control Package for Interactive Voice Response (IVR) dialogs on media
connections and conferences. The term 'dialog' in this document refers
to an IVR dialog and is completely unrelated to the notion of a SIP
dialog. The term 'IVR' is used in its inclusive sense, allowing media
other than voice for dialog interaction.
</t>

<t>The package defines dialog management request elements for preparing,
starting, and terminating dialog interactions, as well as associated
responses and notifications. Dialog interactions are specified using a
dialog language where the language specifies a well-defined syntax and
semantics for permitted operations (play a prompt, record input from the
user, etc.).  This package defines a lightweight IVR dialog language
(supporting prompt playback, runtime controls, DTMF collection, and media
recording) and allows other dialog languages to be used. These dialog
languages are specified inside dialog management elements for preparing
and starting dialog interactions. The package also defines elements for
auditing package capabilities and IVR dialogs.
</t>

<t>This package has been designed to satisfy IVR requirements documented
in "Media Server Control Protocol Requirements" <xref
target="RFC5167"/> -- more specifically, REQ-MCP-28, REQ-MCP-29, and
REQ-MCP-30. It achieves this by building upon two major approaches to
IVR dialog design. These approaches address a wide range of IVR use
cases and are used in many applications that are extensively deployed
today.
</t>

<t>First, the package is designed to provide the major IVR functionality
of SIP media server languages such as netann <xref target="RFC4240"/>,
Media Server Control Markup Language (MSCML) <xref target="RFC5022"/>, and Media Server Markup Language (MSML) <xref target="RFC5707"/>,
which themselves build upon more traditional non-SIP languages (<xref
target="H.248.9"/>, <xref target="RFC2897"/>). A key differentiator is
that this package provides IVR functionality using the Channel
Framework.
</t>

<t>Second, its design is aligned with key concepts of the web model as
defined in W3C Voice Browser languages. The key dialog management
mechanism is closely aligned with Call Control XML (CCXML) <xref target="CCXML10"/>. The
dialog functionality defined in this package can be largely seen as a
subset of VoiceXML (<xref target="VXML20"/>, <xref target="VXML21"/>):
where possible, basic prompting, DTMF collection, and media recording
features are incorporated, but not any advanced VoiceXML constructs
(such as &lt;form>, its interpretation algorithm, or a dynamic data
model). As W3C develops VoiceXML 3.0 <xref target="VXML30"/>, we
expect to see further alignment, especially in providing a set of basic
independent primitive elements (such as prompt, collect, record, and
runtime controls) that can be reused in different dialog languages.
</t>

<t>By reusing and building upon design patterns from these approaches to
IVR languages, this package is intended to provide a foundation that is
familiar to current IVR developers and sufficient for most IVR
applications, as well as a path to other languages that address more
advanced applications.
</t>

<t>This Control Package defines a lightweight IVR dialog language. The
scope of this dialog language is the following IVR functionality:

<list style="symbols">

<t>playing one or more media resources as a prompt to the user</t>

<t>runtime controls (including VCR controls like speed and volume) </t>

<t>collecting DTMF input from the user according to a grammar</t>

<t>recording user media input</t>

</list>
Out of scope for this dialog language are more advanced functions
including ASR (Automatic Speech Recognition), TTS (Text-to-Speech), fax,
automatic prompt recovery ('media fallback'), and media
transformation. Such functionality can be addressed by other dialog
languages (such as VoiceXML) used with this package, extensions to this
package (addition of foreign elements or attributes from another
namespace), or other Control Packages. 
</t>

<t>The functionality of this package is defined by messages, containing
XML <xref target="XML"/> elements, transported using the Media Control
Channel Framework. The XML elements can be divided into three types:
dialog management elements; a dialog element that defines a lightweight
IVR dialog language used with dialog management elements; and finally,
elements for auditing package capabilities as well as dialogs managed by
the package.
</t>

<t>Dialog management elements are designed to manage the general
lifecycle of a dialog. Elements are provided for preparing a dialog,
starting the dialog on a conference or connection, and terminating
execution of a dialog. Each of these elements is contained in a Media
Control Channel Framework CONTROL message sent to the media server. When
the appropriate action has been executed, the media server sends a
REPORT message (or a 200 response to the CONTROL message if it can execute in time) with a response element indicating whether or not the operation was
successful (e.g., if the dialog cannot be started, then the error
is reported in this response). Once a dialog has been successfully
started, the media server can send further event notifications in a
framework CONTROL message. This package defines two event notifications:
a DTMF event indicating the DTMF activity, and a dialogexit event
indicating that the dialog has exited. If the dialog has executed
successfully, the dialogexit event includes information collected during
the dialog. If an error occurs during execution (e.g., a media resource
failed to play, no recording resource available, etc.), then error
information is reported in the dialogexit event. Once a dialogexit event
is sent, the dialog lifecycle is terminated. </t>

<t>The dialog management elements for preparing and starting a dialog
specify the dialog using a dialog language. A dialog language has
well-defined syntax and semantics for defined dialog
operations. Typically, dialog languages are written in XML where the root
element has a designated XML namespace and, when used as standalone
documents, have an associated MIME media type. For example, VoiceXML is
an XML dialog language with the root element &lt;vxml> with the
designated namespace 'http://www.w3.org/2001/vxml' and standalone
documents are associated with the MIME media type
'application/voicexml+xml' <xref target="RFC4267"/>.</t>

<t>This Control Package defines its own lightweight IVR dialog language.
The language has a root element (&lt;dialog>) with the same designated
namespace as used for other elements defined in this package (see <xref
target="sec:URN_Reg"/>). The root element contains child elements for
playing prompts to the user, specifying runtime controls, collecting
DTMF input from the user, and recording media input from the user. The
child elements can co-occur so as to provide 'play announcement',
'prompt and collect', as well as 'prompt and record' functionality.
</t>

<t>The dialog management elements for preparing and starting a dialog
can specify the dialog language either by including inline a fragment
with the root element or by referencing an external dialog document. The
dialog language defined in this package is specified inline. Other
dialog languages, such as VoiceXML, can be used by referencing an
external dialog document.
</t>


<t>The document is organized as follows.  

<xref target="sec:Control_Package_Definition"/> describes how this
Control Package fulfills the requirements for a Media Control Channel
Framework Control Package.


<xref target="defn.elements"/> describes the syntax and semantics of
defined elements, including dialog management (<xref
target="defn.dialogmgt"/>), the IVR dialog element (<xref
target="defn.ivrdialog"/>), and audit elements (<xref
target="defn.auditmgt"/>).

<xref target="schema"/> describes an XML schema for these elements and
provides extensibility by allowing attributes and elements from other
namespaces.

<xref target="examples"/> provides examples of package usage.

<xref target="security"/> describes important security considerations
for use of this Control Package. <xref
target="sec:IANA_Considerations"/> provides information on IANA
registration of this Control Package, including its name, XML namespace,
and MIME media type. It also establishes a registry for prompt
variables. Finally, <xref target="voicexml"/> provides additional
information on using VoiceXML when supported as an external dialog
language.
</t>

</section>
		


<section anchor="terminology" title="Conventions and Terminology">
			
<t>In this document, <xref target="RFC2119">BCP 14</xref>
defines the key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY",
and "OPTIONAL".  In addition, BCP 15 indicates requirement levels for
compliant implementations.  </t>
			
<t>The following additional terms are defined for use in this document:
			
<list style="hanging">

<t hangText="Dialog:">A dialog performs media interaction with a user
following the concept of an IVR (Interactive Voice Response) dialog
(this sense of 'dialog' is completely unrelated to a SIP dialog).  A
dialog is specified as inline XML or via a URI reference to an external
dialog document.  Traditional IVR dialogs typically feature capabilities
such as playing audio prompts, collecting DTMF input, and recording audio
input from the user. More inclusive definitions include support for
other media types, runtime controls, synthesized speech, recording and
playback of video, recognition of spoken input, and mixed initiative
conversations.</t>

<t hangText="Application Server:">A SIP <xref target="RFC3261"/>
application server (AS) hosts and executes services such as interactive
media and conferencing in an operator's network. An AS influences and
impacts the SIP session, in particular by terminating SIP sessions on a
media server, which is under its control.</t>

<t hangText="Media Server:">A media server (MS) processes media streams
on behalf of an AS by offering functionality such as interactive media,
conferencing, and transcoding to the end user. Interactive media
functionality is realized by way of dialogs that are initiated by the
application server.  </t>
</list>
</t>

</section>


<section anchor="sec:Control_Package_Definition" title="Control Package
Definition">

<t>This section fulfills the mandatory requirement for information that
MUST be specified during the definition of a Control Framework Package,
as detailed in Section 7 of <xref
target="RFC6230"/>.</t>
		  
<section anchor="sec:Control_Package_Name" title="Control Package Name">

<t>The Control Framework requires a Control Package to specify and
register a unique name.</t>

<t>The name of this Control Package is "msc-ivr/1.0" (Media Server
Control - Interactive Voice Response - version 1.0). Its IANA
registration is specified in <xref
target="sec:Control_Package_Reg"/>. </t>

<t>
Since this is the initial ("1.0") version of the Control Package, there
are no backwards-compatibility issues to address.
</t>


		     
</section>



<section anchor="sec:Message_Usage" title="Framework Message Usage">

<t>The Control Framework requires a Control Package to explicitly detail
the CONTROL messages that can be used as well as provide an indication
of directionality between entities. This will include which role type is
allowed to initiate a request type. </t>

<t>This package specifies Control and response messages in terms of XML
elements defined in <xref target="defn.elements"/>, where the message
bodies have the MIME media type defined in <xref
target="sec:MIME_Reg"/>. These elements describe requests, responses, and
notifications and all are contained within a root &lt;mscivr> element
(<xref target="defn.mscivr"/>).</t>

<t>In this package, the MS operates as a Control Server in
receiving requests from, and sending responses to, the AS (operating as
 Control Client). Dialog management requests and responses are
defined in <xref target="defn.dialogmgt"/>.  Audit requests and
responses are defined in <xref target="defn.auditmgt"/>. Dialog
management and audit responses are carried in a framework 200 response
or REPORT message bodies. This package's response codes are defined in
<xref target="defn.statuscodes"/>. </t>

<t>Note that package responses are different from framework response
codes. Framework error response codes (see Section 7 of <xref
target="RFC6230"/>) are used when the
request or event notification is invalid; for example, a request is
invalid XML (400), or not understood (500). 

</t>


<t>The MS also operates as a Control Client in sending event
notification to the AS (Control Server). Event notifications
(<xref target="defn.event"/>) are carried in CONTROL message bodies. The
AS MUST respond with a Control Framework 200 response.
</t>


</section>


<section anchor="sec:Common_XML" title="Common XML Support">

<t>The Control Framework requires a Control Package definition to
specify if the attributes for media dialog or conference references are
required.</t>

<t>This package requires that the XML schema in Section A.1 of <xref
target="RFC6230"/> MUST be supported
for media dialogs and conferences. </t>

<t>The package uses "connectionid" and "conferenceid" attributes for
various element definitions (<xref target="defn.elements"/>). The XML
schema (<xref target="schema"/>) imports the definitions of these
attributes from the framework schema.
</t>

</section>


<section anchor="sec:Control_Body" title="CONTROL Message Body">

<t>The Control Framework requires a Control Package to define the
control body that can be contained within a CONTROL command request and
to indicate the location of detailed syntax definitions and semantics
for the appropriate body types.
</t>

<t>When operating as Control Server, the MS receives Control
message bodies with the MIME media type defined in <xref
target="sec:MIME_Reg"/> and containing an &lt;mscivr> element (<xref
target="defn.mscivr"/>) with either a dialog management or audit request
child element.
</t>

<t>The following dialog management request elements are carried in
CONTROL message bodies to the MS: &lt;dialogprepare> (<xref
target="defn.dialogprepare"/>), &lt;dialogstart> (<xref
target="defn.dialogstart"/>), and &lt;dialogterminate> (<xref
target="defn.dialogterminate"/>) elements.
</t>

<t> The &lt;audit> request element (<xref target="defn.audit"/>) is also
carried in CONTROL message bodies.
</t>


<t>When operating as Control Client, the MS sends CONTROL messages with
the MIME media type defined in <xref target="sec:MIME_Reg"/> and a body
containing an &lt;mscivr> element (<xref target="defn.mscivr"/>) with a
notification &lt;event> child element (<xref target="defn.event"/>).
</t>

</section>



<section anchor="sec:REPORT_Body" title="REPORT Message Body">

<t>The Control Framework requires a Control Package definition to define
the REPORT body that can be contained within a REPORT command request,
or that no report package body is required. This section indicates
the location of detailed syntax definitions and semantics for the
appropriate body types.
</t>

<t>When operating as Control Server, the MS sends REPORT
bodies with the MIME media type defined in <xref target="sec:MIME_Reg"/>
and containing a &lt;mscivr> element (<xref target="defn.mscivr"/>) with
a response child element.  The response element for dialog management
requests is a &lt;response> element (<xref
target="defn.response"/>). The response element for an audit request is
an &lt;auditresponse> element (<xref target="defn.auditresponse"/>).
</t>

</section>


<section anchor="audit" title="Audit">

<t>The Control Framework encourages Control Packages to specify whether
auditing is available, how it is triggered, as well as the query/response
formats. </t> 

<t>This Control Package supports auditing of package capabilities and
dialogs on the MS. An audit request is carried in a CONTROL message (see
<xref target="sec:Control_Body"/>) and an audit response in a REPORT
message (or a 200 response to the CONTROL if it can execute the audit in
time) (see <xref target="sec:REPORT_Body"/>).
</t>

<t>The syntax and semantics of audit request and response elements are
defined in <xref target="defn.auditmgt"/>.</t>

</section>


<section anchor="cfw_examples" title="Examples">

<t>The Control Framework recommends Control Packages to provide a range
of message flows that represent common flows using the package and this
framework document. </t>

<t>This Control Package provides examples of such message flows in 
<xref target="examples"/>.</t>


</section>


</section>

<section anchor="defn.elements" title="Element Definitions">

<t>This section defines the XML elements for this package.  The elements
are defined in the XML namespace specified in <xref
target="sec:URN_Reg"/>.
</t>

<t>The root element is &lt;mscivr> (<xref target="defn.mscivr"/>).  All
other XML elements (requests, responses, and notification elements) are
contained within it.  Child elements describe dialog management (<xref
target="defn.dialogmgt"/>) and audit (<xref target="defn.auditmgt"/>)
functionality. The IVR dialog element (contained within dialog
management elements) is defined in <xref
target="defn.ivrdialog"/>. Response status codes are defined in <xref
target="defn.statuscodes"/> and type definitions in <xref
target="defn.types"/>.
</t>

<t>Implementation of this Control Package MUST address the Security
Considerations described in <xref target="security"/>. </t>

<t>Implementation of this Control Package MUST adhere to the syntax and
semantics of XML elements defined in this section and the schema (<xref
target="schema"/>).  Since XML schema is unable to support some types of
syntactic constraints (such as attribute and element co-occurrence),
some elements in this package specify additional syntactic constraints
in their textual definition. If there is a difference in constraints
between the XML schema and the textual description of elements in this
section, the textual definition takes priority.
</t>

<t>The XML schema supports extensibility by allowing attributes and
elements from other namespaces. Implementations MAY support additional
capabilities by means of attributes and elements from other (foreign)
namespaces. Attributes and elements from foreign namespaces are not
described in this section.
</t>

<t>Some elements in this Control Package contain attributes whose value
is a URI. These elements include: &lt;dialogprepare> (<xref
target="defn.dialogprepare"/>), &lt;dialogstart> (<xref
target="defn.dialogstart"/>), &lt;media> (<xref target="defn.media"/>),
&lt;grammar> (<xref target="defn.grammar"/>), and &lt;record> (<xref
target="defn.record"/>).  The MS MUST support both HTTP <xref
target="RFC2616"/> and HTTPS <xref target="RFC2818"/> protocol
schemes for fetching and uploading resources, and the MS MAY support
other schemes. The implementation SHOULD support storage of
authentication information as part of its configuration, including
security certificates for use with HTTPS. If the implementation wants to
support user authentication, user certifications and passwords can also
be stored as part of its configuration or the implementation can extend
the schema (adding, for example, an http-password attribute in its own
namespace) and then map user authentication information onto the
appropriate headers following the HTTP authentication model <xref
target="RFC2616"/>.
</t>

<t>Some elements in this Control Package contain attributes whose value
is descriptive text primarily for diagnostic use. The implementation can
indicate the language used in the descriptive text by means of a
'desclang' attribute (<xref target="RFC2277"/>, <xref target="RFC5646"/>). The desclang attribute
can appear on the root element as well as selected subordinate elements
(see <xref target="defn.mscivr"/>). The desclang attribute value on the
root element applies to all desclang attributes in subordinate elements
unless the subordinate element has an explicit desclang attribute that
overrides it. 
</t>


<t>Usage examples are provided in <xref target="examples"/>. </t>


<section anchor="defn.mscivr" title="&lt;mscivr>">

<t>The &lt;mscivr> element has the following attributes (in addition to
standard XML namespace attributes such as xmlns):

<list style="hanging">

<t hangText="version:">a string specifying the mscivr package
version. The value is fixed as '1.0' for this version of the
package. The attribute is mandatory.
</t>

<t hangText="desclang:">specifies the language used in descriptive text
attributes of subordinate elements (unless the subordinate element
provides a desclang attribute that overrides the value for its
descriptive text attributes). The descriptive text attributes on
subordinate elements include: the reason attribute on &lt;response>
(<xref target="defn.response"/>), &lt;dialogexit> (<xref
target="defn.dialogexit"/>), and &lt;auditresponse> (<xref
target="defn.auditresponse"/>); desc attribute on &lt;variabletype> and
&lt;format> (<xref target="defn.variabletype"/>). A valid value is a
language identifier (<xref target="defn.langid"/>).  The attribute is
optional.  The default value is i-default (<xref
target="RFC5646">BCP 47</xref>).
</t>

</list>
</t>

<t>The &lt;mscivr> element has the following defined child elements,
only one of which can occur:

<list style="numbers">

<t>dialog management elements defined in <xref target="defn.dialogmgt"/>:

<list style="hanging">
<t hangText="&lt;dialogprepare>">prepare a dialog. See <xref
target="defn.dialogprepare"/>.</t>

<t hangText="&lt;dialogstart>">start a dialog. See <xref
target="defn.dialogstart"/>.</t>

<t hangText="&lt;dialogterminate>">terminate a dialog. See <xref
target="defn.dialogterminate"/>.</t>

<t hangText="&lt;response>">response to a dialog request. See <xref
target="defn.response"/>.</t>

<t hangText="&lt;event>">dialog or subscription notification. See <xref
target="defn.event"/>.</t>

</list>

</t>

<t>audit elements defined in <xref target="defn.auditmgt"/>:

<list style="hanging">

<t hangText="&lt;audit>">audit package capabilities and managed
dialogs. See <xref target="defn.audit"/>.</t>

<t hangText="&lt;auditresponse>">response to an audit request. See <xref
target="defn.auditresponse"/>.</t>

</list>

</t>

</list>

</t>


<t>For example, a request to the MS to start an IVR dialog playing a
prompt:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <dialogstart connectionid="ssd3r3:sds345b">
  <dialog>
   <prompt>
    <media loc="http://www.example.com/welcome.wav"/>
   </prompt>
  </dialog>
 </dialogstart>
</mscivr>
]]></artwork></figure>
</t>

<t>and a response from the MS that the dialog started successfully:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <response status="200" dialogid="d1"/>
</mscivr>
]]></artwork></figure>
</t>

<t>and finally a notification from the MS indicating that the dialog
exited upon completion of playing the prompt:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr" 
        desclang="en">
 <event dialogid="d1">
  <dialogexit status="1" reason="successful completion of the dialog">
   <promptinfo termmode="completed"/>
  </dialogexit>
 </event>
</mscivr>
]]></artwork></figure>
</t>

<t>The language of the descriptive text in the reason attribute of
&lt;dialogexit> is explicitly indicated by the desclang attribute of the
&lt;mscivr> root element.</t>


</section>


<section anchor="defn.dialogmgt" title="Dialog Management Elements">

<t>This section defines the dialog management XML elements for this
Control Package. These elements are divided into requests, responses, and
notifications.
</t>

<t>Request elements are sent to the MS to request a specific dialog
operation to be executed. The following request elements are defined:

<list style="hanging">
            
 <t hangText="&lt;dialogprepare>:"> prepare a dialog for later
 execution </t>

 <t hangText="&lt;dialogstart>:"> start a (prepared) dialog on a connection or
 conference</t>

  <t hangText="&lt;dialogterminate>:">terminate a dialog</t>

</list>
</t>

<t>Responses from the MS describe the status of the requested operation.
Responses are specified in a &lt;response> element (<xref
target="defn.response"/>) that includes a mandatory attribute
describing the status in terms of a numeric code. Response status codes
are defined in <xref target="defn.statuscodes"/>. The MS MUST respond to
a request message with a response message.  If the MS is not able to
process the request and carry out the dialog operation, the request has
failed and the MS MUST indicate the class of failure using an
appropriate 4xx response code. Unless an error response code is
specified for a class of error within this section, implementations
follow <xref target="defn.statuscodes"/> in determining the appropriate
status code for the response.
</t>

<t>Notifications are sent from the MS to provide updates on the status
of a dialog or operations defined within the dialog.  Notifications are
specified in an &lt;event> element (<xref target="defn.event"/>). </t>

<figure anchor="fig:dialog_lifecycle" title="Dialog Lifecycle">
<artwork><![CDATA[
                            +---------+ 
                            |  IDLE   |            
                            +---------+
                              |     |
                              |     | 
              <dialogprepare>/|     |<dialogstart>/
                              |     | 
          +---------+         |     |             +---------+
 +-----<--|         |<--------+     +------------>|         |+------>-+
 | +-<----|PREPARING|                             |STARTING |         |
 | |      |         |                 ----------->|         |---->--+ |
 | |      +---------+                /            +---------+       | |
 | |           |                    /                  |            | |
 | |           |/200 response      /      /200 response|            | |
 | |           |                  /                    |            | |
 | |           |                 /                     |            | |
 | |           |                /                      |            | |
 V V           v               /<dialogstart>/         v            | |
 | |      +---------+         /                   +---------+       | |
 | |      |         |--------+               +----|         |       | |
 | |      |PREPARED |---------+              |    | STARTED |       | |
 | |      |         |         |              +--->|         |       | |
 | |      |         |--------+| <dialogterminate>/|         |       | |
 | |      +---------+        ||  200 response     +---------+       | |
 | |                         ||                    |                | |        
 | | /dialogexit notification||                    |                | |
 | |           (timeout)     ||                    |                | |
 | |                         ||                    |                | | 
 | |                         ||                    |                | |  
 | |                         ||                    |                | |        
 | |                         ||<dialogterminate>/  |                | | 
 | |                         ||  200 response      |                | | 
 | |                         ||       +            |/dialogexit     | |
 | |                         || /dialogexit        | notification   | |
 | |                         || notification       |                | |  
 | |                         ||                    |                | |
 | |                         vv                    |                | |
 | |      /ERROR response  +-----------+           |                | |
 | +---------------------->|           |<----------+ /ERROR response| |
 +------------------------>|TERMINATED |<---------------------------+ |
      <dialogterminate>/   |           |<-----------------------------+
          410 response     +-----------+ <dialogterminate>/410 response   

]]></artwork>
</figure>


<t>The MS implementation MUST adhere to the dialog lifecycle shown in
<xref target="fig:dialog_lifecycle"/>, where each dialog has the
following states:

<list style="hanging">

 <t hangText="IDLE:">the dialog is uninitialized. </t>
            
 <t hangText="PREPARING:">the dialog is being prepared. The dialog is
 assigned a valid dialog identifier (see below).  If an error occurs, the
 dialog transitions to the TERMINATED state and the MS MUST send a
 response indicating the error.  If the dialog is terminated before
 preparation is complete, the dialog transitions to the TERMINATED state
 and the MS MUST send a 410 response (<xref target="defn.statuscodes"/>)
 for the prepare request.
</t>

 <t hangText="PREPARED:">the dialog has been successfully prepared and
 the MS MUST send a 200 response indicating the prepare operation was
 successful.  If the dialog is terminated, then the MS MUST send a 200
 response, the dialog transitions to the TERMINATED state and the MS
 MUST send a dialogexit notification event (see <xref
 target="defn.dialogexit"/>). If the duration the dialog remains in the
 PREPARED state exceeds the maximum preparation duration, the dialog
 transitions to the TERMINATED state and the MS MUST send a dialogexit
 notification with the appropriate error status code (see <xref
 target="defn.dialogexit"/>). A maximum preparation duration of 300s is
 RECOMMENDED.
</t>

 <t hangText="STARTING:">the dialog is being started. If the dialog has
 not already been prepared, it is first prepared and assigned a valid
 dialog identifier (see below).  If an error occurs the dialog
 transitions to the TERMINATED state and the MS MUST send a response
 indicating the error.  If the dialog is terminated, the dialog
 transitions to the TERMINATED state and the MS MUST send a 410 response
 (<xref target="defn.statuscodes"/>) for the start request.</t>

 <t hangText="STARTED:">the dialog has been successfully started and is
 now active. The MS MUST send a 200 response indicating the start
   operation was successful.  If any dialog events occur that were
 subscribed to, the MS MUST send a notifications when the dialog event
 occurs.  When the dialog exits (due to normal termination, an error, or
 a terminate request), the MS MUST send a dialogexit notification event
 (see <xref target="defn.dialogexit"/>) and the dialog transitions to
 the TERMINATED state.
</t>

 <t hangText="TERMINATED:">the dialog is terminated and its dialog
 identifier is no longer valid.  Dialog notifications MUST NOT be sent
 for this dialog.
 </t>

</list>
</t>

<t>Each dialog has a valid identifier until it transitions to a
TERMINATED state.  The dialog identifier is assigned by the MS unless
the &lt;dialogprepare> or &lt;dialogstart> request already specifies a
identifier (dialogid) that is not associated with any other dialog on
the MS.  Once a dialog is in a TERMINATED state, its dialog identifier
is no longer valid and can be reused for another dialog.
</t>

<t>The identifier is used to reference the dialog in subsequent
requests, responses, and notifications. In a &lt;dialogstart> request,
the dialog identifier can be specified in the prepareddialogid attribute
indicating the prepared dialog to start. In &lt;dialogterminate> and
&lt;audit> requests, the dialog identifier is specified in the dialogid
attribute, indicating which dialog is to be terminated or audited,
respectively. If these requests specify a dialog identifier already
associated with another dialog on the MS, the MS sends a response with a
405 status code (see <xref target="defn.statuscodes"/>) and the same
dialogid as in the request.  The MS MUST specify a dialog identifier in
notifications associated with the dialog. The MS MUST specify a dialog
identifier in responses unless it is a response to a syntactically
invalid request.
</t>

<t>For a given dialog, the &lt;dialogprepare> or &lt;dialogstart>
request elements specify the dialog content to execute either by
including inline a &lt;dialog> element (the dialog language defined in
this package; see <xref target="defn.ivrdialog"/>) or by referencing an
external dialog document (a dialog language defined outside this
package). When referencing an external dialog document, the request
element contains a URI reference to the remote document (specifying the
dialog definition) and, optionally, a type attribute indicating the MIME
media type associated with the dialog document. Consequently, the dialog
language associated with a dialog on the MS is identified either inline
by a &lt;dialog> child element or by a src attribute referencing a
document containing the dialog language. The MS MUST support inline the
IVR dialog language defined in <xref target="defn.ivrdialog"/>. The MS
MAY support other dialog languages by reference. 
</t>


<section anchor="defn.dialogprepare" title="&lt;dialogprepare>">

<t>The &lt;dialogprepare> request is sent to the MS to request
preparation of a dialog. Dialog preparation consists of (a) retrieving
an external dialog document and/or external resources referenced within
an inline &lt;dialog> element and (b) validating the dialog document
syntactically and semantically.</t>

<t>A prepared dialog is executed when the MS receives a &lt;dialogstart>
request referencing the prepared dialog identifier (see <xref
target="defn.dialogstart"/>).
</t>

<t>The &lt;dialogprepare> element has the following attributes:

<list style="hanging">

<t hangText="src:">specifies the location of an external dialog document
to prepare. A valid value is a URI (see <xref target="defn.uri"/>). The
MS MUST support both HTTP <xref target="RFC2616"/> and HTTPS <xref
target="RFC2818"/> schemes and the MS MAY support other schemes. If the
URI scheme is unsupported, the MS sends a &lt;response> with a 420
status code (<xref target="defn.statuscodes"/>). If the document cannot
be retrieved within the timeout interval, the MS sends a &lt;response>
with a 409 status code.  If the document contains a type of dialog
language that the MS does not support, the MS sends a &lt;response>
with a 421 status code.  The attribute is optional. There is no default
value.
</t>

<t hangText="type:">specifies the type of the external dialog document
indicated in the 'src' attribute. A valid value is a MIME media type
(see <xref target="defn.mimetype"/>). If the URI scheme used in the src
attribute defines a mechanism for establishing the authoritative MIME
media type of the media resource, the value returned by that mechanism
takes precedence over this attribute. The attribute is optional. There
is no default value.
</t>

<t hangText="maxage:">Used to set the max-age value of the 'Cache-Control'
header in conjunction with an external dialog document fetched using
HTTP, as per <xref target="RFC2616"/>.  A valid value is a non-negative
integer (see <xref target="defn.nonneginteger"/>). The attribute is
optional. There is no default value. </t>

<t hangText="maxstale:">Used to set the max-stale value of the
'Cache-Control' header in conjunction with an external dialog document
fetched using HTTP, as per <xref target="RFC2616"/>. A valid value is a
non-negative integer (see <xref target="defn.nonneginteger"/>). The
attribute is optional. There is no default value. </t>

<t hangText="fetchtimeout:">the maximum timeout interval to wait when
fetching an external dialog document. A valid value is a Time
Designation (see <xref target="defn.timedesignation"/>).  The attribute
is optional. The default value is 30s. </t>

<t hangText="dialogid:">string indicating a unique name for the
dialog. If a dialog with the same name already exists on the MS, the MS
sends a &lt;response> with a 405 status code (<xref
target="defn.statuscodes"/>). If this attribute is not specified, the MS
MUST create a unique name for the dialog (see <xref
target="defn.dialogmgt"/> for dialog identifier assignment). The
attribute is optional. There is no default value. </t>

</list>

</t>

<t>The &lt;dialogprepare> element has the following sequence of child
elements:

<list style="hanging">
<t hangText="&lt;dialog>">an IVR dialog (<xref target="defn.ivrdialog"/>)
to prepare. The element is optional. 
</t>

<t hangText="&lt;params>:">specifies input parameters (<xref
target="defn.params"/>) for dialog languages defined outside this
specification. The element is optional. If a parameter is not supported
by the MS for the external dialog language, the MS sends a &lt;response>
with a 427 status code (<xref target="defn.statuscodes"/>).
</t>

</list>
</t>

<t>The dialog to prepare can be specified either inline with a
&lt;dialog> child element or externally (for dialog languages defined
outside this specification) using the src attribute.  It is a syntax
error if both an inline &lt;dialog> element and a src attribute
are specified and the MS sends a &lt;response> with a 400 status code
(see <xref target="defn.statuscodes"/>). The type, maxage, maxstale, and
fetchtimeout attributes are only relevant when a dialog is specified as
an external document.
</t>

<t>For example, a &lt;dialogprepare> request to prepare an inline IVR
dialog with a single prompt:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <dialogprepare>
  <dialog>
   <prompt>
    <media loc="http://www.example.com/welcome.wav"/>
   </prompt>
  </dialog>
 </dialogprepare>
</mscivr>
]]></artwork></figure>
</t>

<t>In this example, a request with a specified dialogid to prepare a
VoiceXML dialog document located externally:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <dialogprepare dialogid="d2" type="application/voicexml+xml" 
                src="http://www.example.com/mydialog.vxml"
                fetchtimeout="15s"/>
</mscivr>
]]></artwork></figure>

Since MS support for dialog languages other than the IVR dialog language
defined in this package is optional, if the MS does not support the
dialog language, it would send a response with the status code 421 (<xref
target="defn.statuscodes"/>). Further information on using VoiceXML can
be found in <xref target="voicexml"/>.
</t>

</section>


<section anchor="defn.dialogstart" title="&lt;dialogstart>">

<t>The &lt;dialogstart> element is sent to the MS to start a dialog.  If
the dialog has not been prepared, the dialog is prepared (retrieving
external document and/or external resources referenced within
&lt;dialog> element and the dialog document validated syntactically and
semantically).  Media processors (e.g., DTMF and prompt queue) are
activated and associated with the specified connection or conference.
</t>


<t>The &lt;dialogstart> element has the following attributes:

<list style="hanging">

<t hangText="src:">specifies the location of an external dialog document
to start. A valid value is a URI (see <xref target="defn.uri"/>). The
MS MUST support both HTTP <xref target="RFC2616"/> and HTTPS <xref
target="RFC2818"/> schemes and the MS MAY support other schemes. If the
URI scheme is unsupported, the MS sends a &lt;response> with a 420
status code (<xref target="defn.statuscodes"/>). If the document cannot
be retrieved with the timeout interval, the MS sends a &lt;response>
with a 409 status code.  If the document contains a type of dialog
language that the MS does not support, the MS sends a &lt;response>
with a 421 status code.  The attribute is optional. There is no default
value.
</t>

<t hangText="type:">specifies the type of the external dialog document
indicated in the 'src' attribute. A valid value is a MIME media type
(see <xref target="defn.mimetype"/>). If the URI scheme used in the src
attribute defines a mechanism for establishing the authoritative MIME
media type of the media resource, the value returned by that mechanism
takes precedence over this attribute. The attribute is optional. There
is no default value.
</t>

<t hangText="maxage:">Used to set the max-age value of the 'Cache-Control'
header in conjunction with an external dialog document fetched using
HTTP, as per <xref target="RFC2616"/>.  A valid value is a non-negative
integer (see <xref target="defn.nonneginteger"/>). The attribute is
optional. There is no default value. </t>

<t hangText="maxstale:">Used to set the max-stale value of the
'Cache-Control' header in conjunction with an external dialog document
fetched using HTTP, as per <xref target="RFC2616"/>. A valid value is a
non-negative integer (see <xref target="defn.nonneginteger"/>). The
attribute is optional. There is no default value. </t>

<t hangText="fetchtimeout:">the maximum timeout interval to wait when
fetching an external dialog document. A valid value is a Time
Designation (see <xref target="defn.timedesignation"/>). The attribute
is optional. The default value is 30s. </t>


<t hangText="dialogid:">string indicating a unique name for the
dialog. If a dialog with the same name already exists on the MS, the MS
sends a &lt;response> with a 405 status code (<xref
target="defn.statuscodes"/>).  If neither the dialogid attribute nor the
prepareddialogid attribute is specified, the MS MUST create a unique
name for the dialog (see <xref target="defn.dialogmgt"/> for dialog
identifier assignment). The attribute is optional. There is no default
value.
</t> 

<t hangText="prepareddialogid:">string identifying a dialog previously
prepared using a dialogprepare (<xref target="defn.dialogprepare"/>)
request. If neither the dialogid attribute nor the prepareddialogid
attribute is specified, the MS MUST create a unique name for the dialog
(see <xref target="defn.dialogmgt"/> for dialog identifier assignment).
The attribute is optional. There is no default value.</t>
  

<t hangText="connectionid:">string identifying the SIP dialog connection
on which this dialog is to be started (see Appendix A.1 of <xref
target="RFC6230"/>).  The attribute is
optional. There is no default value.</t>


<t hangText="conferenceid:">string identifying the conference on which
this dialog is to be started (see Appendix A.1 of <xref
target="RFC6230"/>). The attribute is
optional. There is no default value.</t>

</list>
</t>

<t>Exactly one of the connectionid or conferenceid attributes MUST be
specified. If both the connectionid and conferenceid attributes are
specified or neither is specified, it is a syntax error and the MS
sends a &lt;response> with a 400 status code (<xref
target="defn.statuscodes"/>).
</t>

<t>It is an error if the connection or conference referenced by a
specific connectionid or conferenceid attribute is not available on the
MS at the time the &lt;dialogstart> request is executed. If an invalid
connectionid is specified, the MS sends a &lt;response> with a 407
status code (<xref target="defn.statuscodes"/>).  If an invalid
conferenceid is specified, the MS sends a &lt;response> with a 408
status code.
</t>


<t>The &lt;dialogstart> element has the following sequence of child
elements:

<list style="hanging">

<t hangText="&lt;dialog>:">specifies an IVR dialog (<xref
target="defn.ivrdialog"/>) to execute. The element is optional.
</t>

<t hangText="&lt;subscribe>:">specifies subscriptions to dialog events
(<xref target="defn.subscribe"/>). The element is optional. </t>

<t hangText="&lt;params>:">specifies input parameters (<xref
target="defn.params"/>) for dialog languages defined outside this
specification. The element is optional. If a parameter is not supported
by the MS for the external dialog language, the MS sends a &lt;response>
with a 427 status code (<xref target="defn.statuscodes"/>).

</t>

<t hangText="&lt;stream>:">determines the media stream(s) associated
with the connection or conference on which the dialog is executed (<xref
target="defn.stream"/>). The &lt;stream> element is optional.  Multiple
&lt;stream> elements can be specified.
</t>

</list>

</t>

<t>The dialog to start can be specified either (a) inline with a
&lt;dialog> child element, (b) externally using the src attribute
(for dialog languages defined outside this specification), or (c)
by referencing a previously prepared dialog using the prepareddialogid
attribute.  If exactly one of the src attribute, the prepareddialogid, or
a &lt;dialog> child element is not specified, it is a syntax error and
the MS sends a &lt;response> with a 400 status code (<xref
target="defn.statuscodes"/>). If the prepareddialogid and dialogid
attributes are specified, it is also a syntax error and the MS sends a
&lt;response> with a 400 status code. The type, maxage, maxstale, and
fetchtimeout attributes are only relevant when a dialog is specified as
an external document.
</t>

<t>The &lt;stream> element provides explicit control over which media
streams on the connection or conference are used during dialog
execution.  For example, if a connection supports both audio and video
streams, a &lt;stream> element could be used to indicate that only the
audio stream is used in receive mode. In cases where there are multiple
media streams of the same type for a dialog, the AS MUST use &lt;stream>
elements to explicitly specify the configuration.  If no &lt;stream>
elements are specified, then the default media configuration is that
defined for the connection or conference. </t>

<t> If a &lt;stream> element is in conflict (a) with another &lt;stream>
element, (b) with specified connection or conference media
  capabilities, or
(c) with a Session Description Protocol (SDP) label value as part of the connectionid (see Appendix A.1
of <xref target="RFC6230"/>), then the
MS sends a &lt;response> with a 411 status code (<xref
target="defn.statuscodes"/>). If the media stream configuration is not
supported by the MS, then the MS sends a &lt;response> with a 428 status
code (<xref target="defn.statuscodes"/>).
</t>

<t>The MS MAY support multiple, simultaneous dialogs being started on
the same connection or conference. For example, the same connection can
receive different media streams (e.g., audio and video) from different
dialogs, or receive (and implicitly mix where appropriate) the same type
of media streams from different dialogs. If the MS does not support
starting another dialog on the same connection or conference, it sends a
&lt;response> with a 432 status code (<xref target="defn.statuscodes"/>)
when it receives the second (or subsequent) dialog request.
</t>


<t>For example, a request to start an ivr dialog on a connection
subscribing to DTMF notifications:


<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <dialogstart connectionid="connection1">
  <dialog>
   <prompt>
    <media loc="http://www.example.com/getpin.wav"/>
   </prompt>
   <collect maxdigits="2"/> 
  </dialog>
 <subscribe>
  <dtmfsub matchmode="all"/>
 </subscribe>
 </dialogstart>
</mscivr>
]]></artwork></figure>
</t>

<t>In this example, the dialog is started on a conference where the
conference only receives an audio media stream from the dialog:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <dialogstart conferenceid="conference1">
  <dialog>
   <record maxtime="384000s"/>
  </dialog>
  <stream media="audio" direction="recvonly"/>
 </dialogstart>
</mscivr>
]]></artwork></figure>
</t>

<section toc="include"  anchor="defn.subscribe" title="&lt;subscribe>">

<t> The &lt;subscribe> element allows the AS to subscribe to, and be
notified of, specific events that occur during execution of the
dialog. Notifications of dialog events are delivered using the
&lt;event> element (see <xref target="defn.event"/>).
</t>

<t>The &lt;subscribe> element has no attributes. </t>

<t>The &lt;subscribe> element has the following sequence of child
elements (0 or more occurrences):

<list style="hanging">

<t hangText="&lt;dtmfsub>:">Subscription to DTMF input during the dialog
(<xref target="defn.dtmfsub"/>). The element is optional.  
</t>

</list>
</t>

<t>
If a request has a &lt;subscribe> with no child elements, the MS treats
the request as if no &lt;subscribe> element were specified.
</t>

<t>The MS MUST support &lt;dtmfsub> subscription for the IVR dialog
language defined in this specification (<xref
target="defn.ivrdialog"/>). It MAY support other dialog subscriptions
(specified using attributes and child elements from a foreign
namespace). If the MS does not support a subscription specified in a
foreign namespace, the MS sends a response with a 431 status code (see
<xref target="defn.statuscodes"/>). </t>


<section toc="include"  anchor="defn.dtmfsub" title="&lt;dtmfsub>">

<t>The &lt;dtmfsub> element has the following attributes:

<list style="hanging">

<t hangText="matchmode:">controls which DTMF input is subscribed
to. Valid values are "all" - notify all DTMF key presses received during
the dialog; "collect" - notify only DTMF input matched by the collect
operation (<xref target="defn.collect"/>); and "control" - notify only
DTMF input matched by the runtime control operation (<xref
target="defn.control"/>).  The attribute is optional. The default value
is "all".
</t>

</list>
</t>

<t>The &lt;dtmfsub> element has no child elements.</t>

<t>DTMF notifications are delivered in the &lt;dtmfnotify> element
(<xref target="defn.dtmfnotify"/>).
</t>

<t>For example, the AS wishes to subscribe to DTMF key press matching
a runtime control:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <dialogstart dialogid="d3" connectionid="connection1">
  <dialog>
   <prompt>
    <media loc="http://www.example.com/getpin.wav"/>
   </prompt>
   <control ffkey="2" rwkey="3"/> 
  </dialog>
 <subscribe>
  <dtmfsub matchmode="control"/>
 </subscribe>
 </dialogstart>
</mscivr>
]]></artwork></figure>
</t>

<t>
Each time a '2' or '3' DTMF input is received, the MS sends a
notification event:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <event dialogid="d3">
   <dtmfnotify matchmode="collect" dtmf="2" 
       timestamp="2008-05-12T12:13:14Z"/>
 </event>
</mscivr>
]]></artwork></figure>
</t>

</section>

</section>

<section toc="include" anchor="defn.stream" title="&lt;stream>">

<t>The &lt;stream> element has the following attributes:

<list style="hanging"> 

        <t hangText="media:">a string indicating the type of media
        associated with the stream. A valid value is a MIME type-name as
        defined in Section 4.2 of <xref target="RFC4288"/>. The
        following values MUST be used for common types of media: "audio"
        for audio media, and "video" for video media. See <xref
        target="IANA"/> for registered MIME type names.  The attribute
        is mandatory. </t>

        <t hangText="label:">a string indicating the SDP label
        associated with a media stream <xref target="RFC4574"/>.  The
        attribute is optional.  </t>

        <t hangText="direction:">a string indicating the direction of
        the media flow relative to the endpoint conference or
        connection. Defined values are "sendrecv" (the endpoint can
        send media to, and receive media from, the dialog), "sendonly"
        (the endpoint can only send media to the dialog), "recvonly"
        (the endpoint can only receive media from the dialog), and
        "inactive" (stream is not to be used). The default value is
        "sendrecv". The attribute is optional. </t>

</list> 

</t>

<t>The &lt;stream> element has the following sequence of child elements:

    <list style="hanging">

		<t hangText="&lt;region>:">an element to specify the area
		within a mixer video layout where a media stream is displayed
		(<xref target="defn.region"/>). The element is optional. </t>


		<t hangText="&lt;priority>:">an element to configure priority
		associated with the stream in the conference mix (<xref
		target="defn.priority"/>). The element is optional.</t>

	</list>
	If conferenceid is not specified or if the "media" attribute does
	not have the value of "video", then the MS ignores the
	&lt;region> and &lt;priority> elements.
</t>

<t>For example, assume a User Agent connection with multiple audio and
video streams associated with the user and a separate web camera. In
this case, the dialog could be started to record only the audio and
video streams associated with the user: 

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <dialogstart connectionid="connection1">
  <dialog>
   <record maxtime="384000s"/>
  </dialog>
  <stream media="audio" label="camaudio" direction="inactive"/>
  <stream media="video" label="camvideo" direction="inactive"/>
  <stream media="audio" label="useraudio" direction="sendonly"/>
  <stream media="video" label="uservideo" direction="sendonly"/>
 </dialogstart>
</mscivr>
]]></artwork></figure>
</t>

<t>Using the &lt;region> element, the dialog can be started on a
conference mixer so that the video output from the dialog is directed to
a specific area within a video layout. For example:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <dialogstart conferenceid="conference1">
  <dialog>
   <prompt>
     <media loc="http://www.example.com/presentation.3gp"/>
   </prompt>
  </dialog>
  <stream media="video" direction="recvonly">
    <region>1</region>
  </stream>
 </dialogstart>
</mscivr>
]]></artwork></figure>

</t>

<section toc="include" anchor="defn.region" title="&lt;region>">

	<t>The &lt;region> element is used to specify a named area within a
	presentation layout where a video media stream is displayed. The MS
	could, for example, play video media into an area of a video layout
	where the layout and its named regions are specified using the Mixer
	Control Package <xref
	target="MIXER-CP"/>.</t>
	
	<t>The &lt;region> element has no attributes and its content model
	specifies the name of the region.
	</t>

    <t>If the region name is invalid, then the MS reports a 416
    status code (<xref target="defn.statuscodes"/>) in the response to
    the request element containing the &lt;region> element. </t>
	
</section>   <!-- region -->


<section toc="include" anchor="defn.priority" title="&lt;priority>">

	<t>The &lt;priority> element is used to explicitly specify the
	priority of the dialog for presentation in a conference mix. </t>
	
	<t>The &lt;priority> element has no attributes and its content model
	specifies a positive integer (see <xref
	target="defn.posinteger"/>). The lower the value, the higher the
	priority.
	</t>
	
</section>   <!-- defn.priority -->


</section>


</section>

<section anchor="defn.dialogterminate" title="&lt;dialogterminate>">

<t>A dialog can be terminated by sending a &lt;dialogterminate> request
element to the MS. </t>

<t>The &lt;dialogterminate> element has the following attributes:

<list style="hanging"> 

  <t hangText="dialogid:">string identifying the dialog to terminate.
  If the specified dialog identifier is invalid, the MS sends a
  response with a 405 status code (<xref target="defn.statuscodes"/>).
  The attribute is mandatory. </t>


  <t hangText="immediate:">indicates whether or not a dialog in the STARTED
  state is to be terminated immediately (in other states,
  termination is always immediate). A valid value is a boolean (see
  <xref target="defn.boolean"/>).  A value of true indicates that the
  dialog is terminated immediately and the MS MUST send a dialogexit
  notification (<xref target="defn.dialogexit"/>) without report
  information. A value of false indicates that the dialog terminates
  after the current iteration and the MS MUST send a dialogexit
  notification with report information. The attribute is optional. The
  default value is false. </t>

</list>
</t>

<t>The MS MUST reply to the &lt;dialogterminate> request with a
&lt;response> element (<xref target="defn.response"/>), reporting
whether or not the dialog was terminated successfully.
</t>

<t>For example, immediately terminating a STARTED dialog with dialogid
"d4":

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <dialogterminate dialogid="d4" immediate="true"/>
</mscivr>
]]></artwork></figure>
</t>

<t>If the dialog is terminated successfully, then the response to the
dialogterminate request would be:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <response status="200" dialogid="d4"/>
</mscivr>
]]></artwork></figure>
</t>

</section>


<section anchor="defn.response" title="&lt;response>">

<t>Responses to dialog management requests are specified with a
&lt;response> element. </t>

<t>The &lt;response> element has following attributes:

<list style="hanging">

<t hangText="status:">numeric code indicating the response status.
Valid values are defined in <xref target="defn.statuscodes"/>. The
attribute is mandatory.</t>

<t hangText="reason:">string specifying a reason for the response
status. The attribute is optional. There is no default value. </t>

<t hangText="desclang:">specifies the language used in the value of
the reason attribute. A valid value is a language identifier (<xref
target="defn.langid"/>).  The attribute is optional.  If not specified,
the value of the desclang attribute on &lt;mscivr> (<xref
target="defn.mscivr"/>) applies.
</t>

<t hangText="dialogid:">string identifying the dialog. If the request
specifies a dialogid, then that value is used. Otherwise, with
&lt;dialogprepare> and &lt;dialogstart> requests, the dialogid generated
by the MS is used. If there is no available dialogid because the request
is syntactically invalid (e.g., a &lt;dialogterminate> request with no
dialogid attribute specified), then the value is the empty string.  The
attribute is mandatory.</t>

<t hangText="connectionid:">string identifying the SIP dialog connection
associated with the dialog (see Appendix A.1 of <xref
target="RFC6230"/>). The attribute is
optional. There is no default value.</t>

<t hangText="conferenceid:">string identifying the conference associated
with the dialog (see Appendix A.1 of <xref
target="RFC6230"/>). The attribute is
optional. There is no default value.</t>

</list>
</t>


<t>For example, a response when a dialog was prepared successfully:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <response status="200" dialogid="d5"/>
</mscivr>
]]></artwork></figure>
</t>


<t>The response if dialog preparation failed due to an unsupported
dialog language:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <response status="421" dialogid="d5" 
    reason="Unsupported dialog language: application/voicexml+xml"/>
</mscivr>
]]></artwork></figure>
</t>


<t>In this example, a &lt;dialogterminate> request does not
specify a dialogid:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <dialogterminate/>
</mscivr>
]]></artwork></figure>
</t>


<t>The response status indicates a 400 (Syntax error) status
code and the dialogid attribute has an empty string value:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <response status="400" dialogid=" " 
    reason="Attribute required: dialogid"/>
</mscivr>
]]></artwork></figure>
</t>




</section>


<section anchor="defn.event" title="&lt;event>">

<t> When a dialog generates a notification event, the MS sends the event
using an &lt;event> element. </t>


<t>The &lt;event> element has the following attributes:

<list style="hanging">

<t hangText="dialogid:">string identifying the dialog that generated
the event. The attribute is mandatory. </t>

</list>
</t>

<t>The &lt;event> element has the following child elements, only one of
which can occur:

<list style="hanging">

<t hangText="&lt;dialogexit>:">indicates that the dialog has exited
(<xref target="defn.dialogexit"/>).
</t>

<t hangText="&lt;dtmfnotify>:">indicates that a DTMF key press occurred
(<xref target="defn.dtmfnotify"/>).
</t>

</list>

</t>


<section toc="include" anchor="defn.dialogexit" title="&lt;dialogexit>">

<t>The &lt;dialogexit> event indicates that a prepared or active dialog
has exited because it is complete, it has been terminated, or an
error occurred during execution (for example, a media resource cannot be
played). This event MUST be sent by the MS when the dialog exits. 
</t>

<t>The &lt;dialogexit> element has the following attributes:

<list style="hanging">

<t hangText="status:">a status code indicating the status of the dialog
when it exits. A valid value is a non-negative integer (see <xref
target="defn.nonneginteger"/>). The MS MUST support the following
values:

<list style="hanging">

<t hangText="0">indicates the dialog has been terminated by a
&lt;dialogterminate> request.
</t>

<t hangText="1">indicates successful completion of the dialog. 
</t>

<t hangText="2">indicates the dialog terminated because the connection
or conference associated with the dialog has terminated.
</t>

<t hangText="3">indicates the dialog terminated due to
exceeding its maximum duration.
</t>

<t hangText="4">indicates the dialog terminated due to an execution
error.
</t>

</list>

All other valid but undefined values are reserved for future use, where
new status codes are assigned using the Standards Action process defined
in <xref target="RFC5226"/>. The AS MUST treat any status code it does
not recognize as being equivalent to 4 (dialog execution error). The
attribute is mandatory.
</t>

<t hangText="reason:">a textual description that the MS SHOULD use to
provide a reason for the status code, e.g., details about an error. A
valid value is a string (see <xref target="defn.string"/>).  The
attribute is optional. There is no default value.
</t>

<t hangText="desclang:">specifies the language used in the value of 
the reason attribute. A valid value is a language identifier (<xref
target="defn.langid"/>).  The attribute is optional.  If not specified,
the value of the desclang attribute on &lt;mscivr> (<xref
target="defn.mscivr"/>) applies.
</t>

</list>
</t>

<t>The &lt;dialogexit> element has the following sequence of child
elements:

<list style="hanging">

<t hangText="&lt;promptinfo>:">report information (<xref
target="defn.dialog.promptinfo"/>) about the prompt execution in an IVR
&lt;dialog>. The element is optional. </t>

<t hangText="&lt;controlinfo>:">reports information (<xref
target="defn.dialog.controlinfo"/>) about the control execution in an
IVR &lt;dialog>. The element is optional. </t>

<t hangText="&lt;collectinfo>:">reports information (<xref
target="defn.dialog.collectinfo"/>) about the collect execution in an
IVR &lt;dialog>. The element is optional. </t>

<t hangText="&lt;recordinfo>:">reports information (<xref
target="defn.dialog.recordinfo"/>) about the record execution in an IVR
&lt;dialog>. The element is optional. </t>

<t hangText="&lt;params>:">reports exit parameters (<xref
target="defn.params"/>) for a dialog language defined outside this
specification. The element is optional. </t>

</list>

</t>


<t>For example, when an active &lt;dialog> exits normally, the MS sends
a dialogexit &lt;event> reporting information:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <event dialogid="d6">
  <dialogexit status="1">
   <collectinfo dtmf="1234"  termmode="match"/>  
  </dialogexit>
 </event>
</mscivr>
]]></artwork></figure>
</t>


</section>

<section toc="include" anchor="defn.dtmfnotify" title="&lt;dtmfnotify>">

<t>The &lt;dtmfnotify> element provides a notification of DTMF input
received during the active dialog as requested by a &lt;dtmfsub>
subscription (<xref target="defn.subscribe"/>). </t>


<t>The &lt;dtmfnotify> element has the following attributes:

<list style="hanging">

<t hangText="matchmode:">indicates the matching mode specified in the
subscription request. Valid values are as follows: 
<list style="empty">
  <t>"all" - all DTMF key presses notified individually; 
  </t><t>
    "collect" - only DTMF input matched by the collect operation notified; and
  </t><t>
    "control" - only DTMF input matched by the control operation
    notified.</t>
</list>
The attribute is optional. The default value is "all".
</t>

<t hangText="dtmf:">DTMF key presses received according to the matchmode.
A valid value is a DTMF string (see <xref target="defn.dtmfstring"/>)
with no space between characters. The attribute is mandatory.
</t>

<t hangText="timestamp:">indicates the time (on the MS) at which the
last key press occurred according to the matchmode.  A valid value is a
dateTime expression (<xref target="defn.dateTime"/>). The attribute is
mandatory.
</t>

</list>
</t>

<t>For example, a notification of DTMF input matched during the collect
operation:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <event dialogid="d3">
   <dtmfnotify matchmode="collect" dtmf="3123" 
     timestamp="2008-05-12T12:13:14Z"/>
 </event>
</mscivr>
]]></artwork></figure>
</t>

</section>

</section>

<section anchor="defn.params" title="&lt;params>">

<t>The &lt;params> element is a container for &lt;param> elements (<xref
target="defn.param"/>). </t>

<t>The &lt;params> element has no attributes, but the following child
elements are defined (0 or more):

<list style="hanging">

<t hangText="&lt;param>:">specifies a parameter name and value (<xref
target="defn.param"/>).

</t>

</list>
</t>

<t>For example, usage with a dialog language defined outside this
specification to send additional parameters into the dialog:

<figure><artwork><![CDATA[ 
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr"> 
<dialogstart type="application/x-dialog" 
             src="nfs://nas01/dialog4" connectionid="c1">
  <params>
   <param name="mode">playannouncement</param>
   <param name="prompt1">nfs://nas01/media1.3gp</param>
   <param name="prompt2">nfs://nas01/media2.3gp</param>
  </params>
 </dialogstart>
</mscivr>
]]></artwork></figure>
</t>

<section toc="include" anchor="defn.param" title="&lt;param>">

<t>The &lt;param> element describes a parameter name and value.</t>

<t>The &lt;param> element has the following attributes:

<list style="hanging"> 

<t hangText="name:">a string indicating the name of the parameter.  The
attribute is mandatory. </t>

<t hangText="type:">specifies a type indicating how the inline value of
the parameter is to be interpreted.  A valid value is a MIME media type
(see <xref target="defn.mimetype"/>). The attribute is optional. The
default value is "text/plain".
</t>

<t hangText="encoding:">specifies a content-transfer-encoding schema
applied to the inline value of the parameter on top of the MIME media
type specified with the type attribute. A valid value is a
content-transfer-encoding schema as defined by the "mechanism" token in
Section 6.1 of <xref target="RFC2045"/>. The attribute is
optional. There is no default value.
</t>

</list>
</t>

<t>The &lt;param> element content model is the value of the
parameter. Note that a value that contains XML characters (e.g., "&lt;")
needs to be escaped following standard XML conventions.
</t>

<t>For example, usage with a dialog language defined outside this
specification to receive parameters from the dialog when it exits:

<figure><artwork><![CDATA[ 
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <event dialogid="d6">
  <dialogexit status="1">
  <params>
   <param name="mode">recording</param>
   <param name="recording1" type="audio/x-wav" encoding="base64">
    ]]>&lt;![CDATA[
     R0lGODlhZABqALMAAFrMYr/BvlKOVJKOg2xZUKmenMfDw8tgWJpV
    <![CDATA[]]]]><![CDATA[>]]>
<![CDATA[   </param>
  </params>
  </dialogexit>
 </event>
</mscivr>
]]></artwork></figure>
</t>


</section>

</section> <!-- end of params -->


</section>





<section anchor="defn.ivrdialog" title="IVR Dialog Elements">

<t>This section describes the IVR dialog language defined as part of
this specification. The MS MUST support this dialog language. </t>

<t>The &lt;dialog> element is an execution container for operations of
playing prompts (<xref target="defn.prompt"/>), runtime controls (<xref
target="defn.control"/>), collecting DTMF (<xref
target="defn.collect"/>), and recording user input (<xref
target="defn.record"/>).  Results of the dialog execution (<xref
target="defn.dialog.exit"/>) are reported in a dialogexit notification
event. </t>

<t>Using these elements, three common dialog models are supported:

<list style="hanging">

<t hangText="playannouncements:">only a &lt;prompt> element is specified
in the container. The prompt media resources are played in sequence.
</t>

<t hangText="promptandcollect:">a &lt;collect> element is specified and,
optionally, a &lt;prompt> element. If a &lt;prompt> element is specified
and bargein is enabled, playing of the prompt is terminated when bargein
occurs, and DTMF collection is initiated; otherwise, the prompt is
played to completion before DTMF collection is initiated. If no prompt
element is specified, DTMF collection is initiated immediately.
</t>

<t hangText="promptandrecord:">a &lt;record> element is specified and,
optionally, a &lt;prompt> element. If a &lt;prompt> element is specified
and bargein is enabled, playing of the prompt is terminated when bargein
occurs, and recording is initiated; otherwise, the prompt is played to
completion before recording is initiated. If no prompt element is
specified, recording is initiated immediately.
</t>

</list>
In addition, this dialog language supports runtime ('VCR') controls
enabling a user to control prompt playback using DTMF.
</t>

<t>
Each of the core elements -- &lt;prompt>, &lt;control>, &lt;collect>, and
&lt;record> -- are specified so that their execution and reporting is
largely self-contained. This facilitates their reuse in other dialog
container elements. Note that DTMF and bargein behavior affects multiple
elements and is addressed in the relevant element definitions.
</t>

<t>Execution results are reported in the &lt;dialogexit> notification
event with child elements defined in <xref target="defn.dialog.exit"/>.
If the dialog terminated normally (i.e., not due to an error or to a
&lt;dialogterminate> request), then the MS MUST report the results for
the operations specified in the dialog:

<list style="hanging">

<t hangText="&lt;prompt>:"> &lt;promptinfo> (see <xref
target="defn.dialog.promptinfo"/>) with at least the termmode attribute
specified. </t>

<t hangText="&lt;control>:"> &lt;controlinfo> (see <xref
target="defn.dialog.controlinfo"/>) if any runtime controls are
matched. </t>

<t hangText="&lt;collect>:"> &lt;collectinfo> (see <xref
target="defn.dialog.collectinfo"/>) with the dtmf and termmode attributes
specified. </t>

<t hangText="&lt;record>:"> &lt;recordinfo> (see <xref
target="defn.dialog.recordinfo"/>) with at least the termmode attribute
and one &lt;mediainfo> element specified. </t>

</list>
</t>

<t>The media format requirements for IVR dialogs are undefined. This
package is agnostic to the media types and codecs for media resources
and recording that need to be supported by an implementation. For
example, an MS implementation might only support audio and in particular
the 'audio/basic' codec for media playback and recording. However, when
executing a dialog, if an MS encounters a media type or codec that it
cannot process, the MS MUST stop further processing and report the error
using the dialogexit notification.</t>


<section anchor="defn.dialog" title="&lt;dialog>">

 <t>An IVR dialog to play prompts to the user, allow runtime controls,
 collect DTMF, or record input. The dialog is specified using a
 &lt;dialog> element.</t>
        
<t>A &lt;dialog> element has the following attributes:

<list style="hanging">

<t hangText="repeatCount:"> number of times the dialog is to be
executed. A valid value is a non-negative integer (see <xref
target="defn.nonneginteger"/>). A value of 0 indicates that the dialog
is repeated until halted by other means. The attribute is optional. The
default value is 1.
</t>

<t hangText="repeatDur:">maximum duration for dialog execution.  A valid
value is a time designation (see <xref target="defn.timedesignation"/>).
If no value is specified, then there is no limit on the duration of the
dialog.  The attribute is optional. There is no default value.
</t>

<t hangText="repeatUntilComplete:">indicates whether the MS terminates
dialog execution when an input operation is completed successfully. A
valid value is a boolean (see <xref target="defn.boolean"/>). A value of
true indicates that dialog execution is terminated when an input
operation associated with its child elements is completed successfully
(see execution model below for precise conditions). A value of false
indicates that dialog execution is terminated by other means. The
attribute is optional. The default value is false.
</t>

</list>

The repeatDur attribute takes priority over the repeatCount attribute in
determining maximum duration of the dialog. See 'repeatCount' and
'repeatDur' in the Synchronized Multimedia Integration Language (SMIL) <xref target="W3C.REC-SMIL2-20051213"/> for
further information. In the situation where a dialog is repeated more
than once, only the results of operations in the last dialog iteration
are reported.

</t>

<t>The &lt;dialog> element has the following sequence of child elements
(at least one, any order):

<list style="hanging">

<t hangText="&lt;prompt>:">defines media resources to play in sequence
(see <xref target="defn.prompt"/>). The element is optional. </t>

<t hangText="&lt;control>:">defines how DTMF is used for runtime
controls (see <xref target="defn.control"/>). The element is
optional. </t>

<t hangText="&lt;collect>:">defines how DTMF is collected (see <xref
target="defn.collect"/>). The element is optional. </t>

<t hangText="&lt;record>:">defines how recording takes place (see <xref
target="defn.record"/>). The element is optional. </t>

</list>
</t>

<t>Although the behavior when both &lt;collect> and &lt;record> elements
are specified in a request is not defined in this Control Package, the
MS MAY support this configuration. If the MS does not support this
configuration, the MS sends a &lt;response> with a 433 status code.
</t>

<t>The MS has the following execution model for the IVR dialog after
initialization (initialization errors are reported by the MS in the
response):

<list style="numbers">

<t>If an error occurs during execution, then the MS terminates the
dialog and reports the error in the &lt;dialogexit> event by setting the
status attribute (see <xref target="defn.dialog.exit"/>). Details about
the error are specified in the reason attribute.
</t>

<t>The MS initializes a counter to 0.  </t>

<t>The MS starts a duration timer for the value of the repeatDur
attribute. If the timer expires before the dialog is complete, then the
MS terminates the dialog and sends a dialogexit whose status attribute
is set to 3 (see <xref target="defn.dialogexit"/>). The MS MAY report
information in the dialogexit gathered in the last execution cycle (if
any).</t>

<t>The MS initiates a dialog execution cycle. Each cycle executes the
operations associated with the child elements of the dialog.  If a
&lt;prompt> element is specified, then execute the element's prompt
playing operation and activate any controls (if the &lt;control> element
is specified). If no &lt;prompt> is specified or when a specified
&lt;prompt> terminates, then start the collect operation or the record
operation if the &lt;collect> or &lt;record> elements, respectively, are
specified. If subscriptions are specified for the dialog, then the MS
sends a notification event when the specified event occurs. If execution
of a child element results in an error, the MS terminates dialog
execution (and stops other child element operations) and the MS sends a
dialogexit status event, reporting any information gathered.  </t>

<t>If the dialog execution cycle completes successfully, then the MS
increments the counter by one.  The MS terminates dialog execution if
either of the following conditions is true:

<list style="symbols">

<t>the value of the repeatCount attribute is greater than zero, and the
counter is equal to the value of the repeatCount attribute. </t>

<t>the value of the repeatUntilComplete attribute is true and one of the
following conditions is true:

<list style="symbols">

<t>&lt;collect> reports termination status of 'match' or 'stopped'.</t>

<t>&lt;record> reports termination status of 'stopped', 'dtmf',
'maxtime', or 'finalsilence'.</t>

</list>

</t>
</list>

When the MS terminates dialog execution, it sends a dialogexit (with a
status of 1) reporting operation information collected in the last
dialog execution cycle only.  Otherwise, another dialog execution cycle
is initiated.
</t>

</list>
</t>


<section toc="include" anchor="defn.prompt" title="&lt;prompt>">

<t>
The &lt;prompt> element specifies a sequence of media resources to play
back in document order.
</t>

<t>A &lt;prompt> element has the following attributes:

<list style="hanging">

<t hangText="xml:base:">A string declaring the base URI from which
relative URIs in child elements are resolved prior to fetching. A valid
value is a URI (see <xref target="defn.uri"/>).  The attribute is
optional. There is no default value.
</t>

<t hangText="bargein:">Indicates whether user input stops prompt
playback unless the input is associated with a specified runtime
&lt;control> operation (input matching control operations never
interrupts prompt playback).  A valid value is a boolean (see <xref
target="defn.boolean"/>). A value of true indicates that bargein is
permitted and prompt playback is stopped. A value of false indicates
that bargein is not permitted: user input does not terminate prompt
playback. The attribute is optional. The default value is true.
</t>

</list>

</t>

<t>The &lt;prompt> element has the following child elements (at least
one, any order, multiple occurrences of elements permitted):

<list style="hanging">

<t hangText="&lt;media>:">specifies a media resource (see <xref
target="defn.media"/>) to play. The element is optional. </t>

<t hangText="&lt;variable>:"> specifies a variable media announcement
(see <xref target="defn.variable"/>) to play.  The element is
optional. </t>

<t hangText="&lt;dtmf>:"> generates one or more DTMF tones (see <xref
target="defn.dtmf"/>) to play. The element is optional. </t>

<t hangText="&lt;par>:"> specifies media resources to play in parallel
(see <xref target="defn.par"/>). The element is optional. </t>

</list>
</t>


<t>If the MS does not support the configuration required for prompt
playback to the output media streams and a more specific error code is
not defined for its child elements, the MS sends a &lt;response>
with a 429 status code (<xref target="defn.statuscodes"/>). The MS MAY
support transcoding between the media resource format and the output
stream format.
</t>

<t>The MS has the following execution model for prompt playing after
initialization:

<list style="numbers">

<t>The MS initiates prompt playback playing its child elements
(&lt;media>, &lt;variable>, &lt;dtmf>, and &lt;par>) one after another in
document order.
</t>

<t>If any error (including fetching and rendering errors) occurs during
prompt execution, then the MS terminates playback and reports its error
status to the dialog container (see <xref target="defn.ivrdialog"/>)
with a &lt;promptinfo> (see <xref target="defn.dialog.promptinfo"/>)
where the termmode attribute is set to stopped and any additional
information is set.</t>

<t>If DTMF input is received and the value of the bargein attribute is
true, then the MS terminates prompt playback and reports its execution
status to the dialog container (see <xref target="defn.ivrdialog"/>)
with a &lt;promptinfo> (see <xref target="defn.dialog.promptinfo"/>)
where the termmode attribute is set to bargein and any additional
information is set. </t>

<t>If prompt playback is stopped by the dialog container, then the MS
reports its execution status to the dialog container (see <xref
target="defn.ivrdialog"/>) with a &lt;promptinfo> (see <xref
target="defn.dialog.promptinfo"/>) where the termmode attribute is set
to stopped and any additional information is set. </t>

<t>If prompt playback completes successfully, then the MS reports its
execution status to the dialog container (see <xref
target="defn.ivrdialog"/>) with a &lt;promptinfo> (see <xref
target="defn.dialog.promptinfo"/>) where the termmode attribute is set
to completed and any additional information is set.
</t>

</list>
</t>



<section toc="include" anchor="defn.variable" title="&lt;variable>">

<t>
The &lt;variable> element specifies variable announcements using
predefined media resources. Each variable has at least a type
(e.g., date) and a value (e.g., 2008-02-25). The value is rendered
according to the prompt variable type (e.g., 2008-02-25 is rendered as
the date 25th February 2008). The precise mechanism for generating
variable announcements (including the location of associated media
resources) is implementation specific.
</t>

<t>A &lt;variable> element has the following attributes:

<list style="hanging">

<t hangText="type:">specifies the type of prompt variable to
render. This specification defines three values -- date (<xref
target="defn.variable.date"/>), time (<xref
target="defn.variable.time"/>), and digits (<xref
target="defn.variable.digits"/>). All other valid but undefined values
are reserved for future use, where new values are assigned as described
in <xref target="sec:Prompt_Variable_Type_Reg"/>. A valid value is a
string (see <xref target="defn.string"/>).  The attribute is mandatory.
</t>

<t hangText="value:">specifies a string to be rendered according to the
prompt variable type. A valid value is a string (see <xref
target="defn.string"/>). The attribute is mandatory.
</t>

<t hangText="format:">specifies format information that the prompt
variable type uses to render the value attribute. A valid value is a
string (see <xref target="defn.string"/>).  The attribute is
optional. There is no default value.
</t>

<t hangText="gender:">specifies the gender that the prompt variable
type uses to render the value attribute. Valid values are "male" or
"female".  The attribute is optional. There is no default value.
</t>

<t hangText="xml:lang:">specifies the language that the prompt variable
type uses to render the value attribute.  A valid value is a language
identifier (see <xref target="defn.langid"/>).  The attribute is
optional. There is no default value.
</t>

</list>

</t>

<t>The &lt;variable> element has no children.</t>

<t>This specification is agnostic to the type and codec of media
resources into which variables are rendered as well as the rendering
mechanism itself. For example, an MS implementation supporting audio
rendering could map the &lt;variable> into one or more audio media
resources. </t>

<t>This package is agnostic to which &lt;variable> types are supported
by an implementation.  If a &lt;variable> element configuration
specified in a request is not supported by the MS, the MS sends a
&lt;response> with a 425 status code (<xref
target="defn.statuscodes"/>).
</t>

<section toc="include" anchor="defn.variable.date" title="Date Type">

<t>The date variable type provides a mechanism for dynamically rendering
a date prompt.</t>

<t>The &lt;variable> type attribute MUST have the value "date".</t>

<t>The &lt;variable> format attribute MUST be one of the following
values and comply with its rendering of the value attribute:

<list style="hanging" hangIndent="5">

<t hangText="mdy">indicating that the &lt;variable> value attribute is
to be rendered as sequence composed of month, then day, then year.
</t>


<t hangText="ymd">indicating that the &lt;variable> value attribute is
to be rendered as sequence composed of year, then month, then day.
</t>

<t hangText="dym">indicating that the &lt;variable> value attribute is
to be rendered as sequence composed of day, then year, then month.
</t>

<t hangText="dm">indicating that the &lt;variable> value attribute is
to be rendered as sequence composed of day then month.
</t>

</list>
</t>

<t>The &lt;variable> value attribute MUST comply with a lexical
representation of date where
<figure>
<artwork><![CDATA[
yyyy '-' mm '-' dd
]]></artwork>
</figure>
as defined in Section 3.2.9 of <xref target="XMLSchema:Part2"/>. 
</t>

<t>For example,

<figure>
<artwork><![CDATA[
  <variable type="date" format="dmy" value="2010-11-25" 
  xml:lang="en" gender="male"/>
]]></artwork>
</figure>

describes a variable date prompt where the date can be rendered in audio
as "twenty-fifth of November two thousand and ten" using a list of
&lt;media> resources:

<figure>
<artwork><![CDATA[
<media loc="nfs://voicebase/en/male/25th.wav"/>
<media loc="nfs://voicebase/en/male/of.wav"/>
<media loc="nfs://voicebase/en/male/november.wav"/>
<media loc="nfs://voicebase/en/male/2000.wav"/>
<media loc="nfs://voicebase/en/male/and.wav"/>
<media loc="nfs://voicebase/en/male/10.wav"/>
]]></artwork>
</figure>

</t>

</section>


<section toc="include" anchor="defn.variable.time" title="Time Type">

<t>The time variable type provides a mechanism for dynamically rendering
a time prompt.</t>

<t>The &lt;variable> type attribute MUST have the value "time".</t>

<t>The &lt;variable> format attribute MUST be one of the following
values and comply with its rendering of the value attribute:

<list style="hanging">

<t hangText="t12">indicating that the &lt;variable> value attribute is
to be rendered as a time in traditional 12-hour format using am or pm
(for example, "twenty-five minutes past 2 pm" for "14:25").
</t>


<t hangText="t24">indicating that the &lt;variable> value attribute is
to be rendered as a time in 24-hour format (for example, "fourteen
twenty-five" for "14:25").
</t>

</list>
</t>

<t>The &lt;variable> value attribute MUST comply with a lexical
representation of time where
<figure>
<artwork><![CDATA[
hh ':' mm ( ':' ss )?
]]></artwork>
</figure>
as defined in Section 3.2.8 of <xref target="XMLSchema:Part2"/>. 
</t>


</section>

<section toc="include" anchor="defn.variable.digits" title="Digits Type">

<t>The digits variable type provides a mechanism for dynamically
rendering a digit sequence.</t>

<t>The &lt;variable> type attribute MUST have the value "digits".</t>

<t>The &lt;variable> format attribute MUST be one of the following
values and comply with its rendering of the value attribute:

<list style="hanging" hangIndent="5">

<t hangText="gen">indicating that the &lt;variable> value attribute is
to be rendered as a general digit string (for example, "one two three"
for "123").
</t>


<t hangText="crn">indicating that the &lt;variable> value attribute is
to be rendered as a cardinal number (for example, "one hundred and
twenty-three" for "123").
</t>

<t hangText="ord">indicating that the &lt;variable> value attribute is
to be rendered as an ordinal number (for example, "one hundred and
twenty-third" for "123").
</t>

</list>
</t>

<t>The &lt;variable> value attribute MUST comply with the lexical
representation
<figure>
<artwork><![CDATA[
   d+
]]></artwork>
</figure>
i.e., one or more digits.
</t>


</section>


</section>



<section toc="include" anchor="defn.dtmf" title="&lt;dtmf>">

<t> The &lt;dtmf> element specifies a sequence of DTMF tones for
output. </t>

<t>DTMF tones could be generated using &lt;media> resources where the
output is transported as RTP audio packets. However, &lt;media>
resources are not sufficient for cases where DTMF tones are to be
transported as DTMF RTP <xref target="RFC4733"/> or in event
packages. </t>

<t>A &lt;dtmf> element has the following attributes:

<list style="hanging">

<t hangText="digits:">specifies the DTMF sequence to output. A valid
value is a DTMF string (see <xref target="defn.dtmfstring"/>). The
attribute is mandatory.
</t>

<t hangText="level:">used to define the power level for which the DTMF
tones will be generated. Values are expressed in dBm0. A valid value is
an integer in the range of 0 to -96 (dBm0). Larger negative values
express lower power levels. Note that values lower than -55 dBm0 will be
rejected by most receivers (TR-TSY-000181, ITU-T Q.24A).  The attribute
is optional. The default value is -6 (dBm0).
</t>

<t hangText="duration:">specifies the duration for which each DTMF tone
is generated. A valid value is a time designation (see <xref
target="defn.timedesignation"/>). The MS MAY round the value if
it only supports discrete durations.  The attribute is optional. The
default value is 100 ms.
</t>

<t hangText="interval:">specifies the duration of a silence interval
following each generated DTMF tone. A valid value is a time designation
(see <xref target="defn.timedesignation"/>). The MS MAY round the value
if it only supports discrete durations.  The attribute is optional. The
default value is 100 ms.
</t>

</list>

</t>

<t>The &lt;dtmf> element has no children.</t>

<t>If a &lt;dtmf> element configuration is not supported, the MS 
sends a &lt;response> with a 426 status code (<xref
target="defn.statuscodes"/>).
</t>

</section> <!-- end of dtmf element -->


<section toc="include" anchor="defn.par" title="&lt;par>">

<t>The &lt;par> element allows media resources to be played in
parallel. Each of its child elements specifies a media resource (or a
sequence of media resources using the &lt;seq> element). When playback
of the &lt;par> element is initiated, the MS begins playback of all its
child elements at the same time. This element is modeled after the
&lt;par> element in SMIL <xref target="W3C.REC-SMIL2-20051213"/>.</t>


<t>The &lt;par> element has the following attributes:

<list style="hanging">

<t hangText="endsync:">indicates when playback of the element is
complete. Valid values are "first" (indicates that the element is
complete when any child element reports that it is complete) and "last" 
(indicates it is complete when every child elements are complete). The
attribute is optional. The default value is "last".
</t>
</list>
If the value is "first", then playback of other child elements is stopped
when one child element reports it is complete.
</t>

<t>The &lt;par> element has the following child elements (at least one,
any order, multiple occurrences of each element permitted):

<list style="hanging">

<t hangText="&lt;seq>:">specifies a sequence of media resources to play
in parallel with other &lt;par> child elements (see <xref
target="defn.seq"/>). The element is optional. </t>

<t hangText="&lt;media>:"> specifies a media resource (see <xref
target="defn.media"/>) to play.  The MS is responsible for assigning the
appropriate media stream(s) when more than one is available. The element
is optional. </t>

<t hangText="&lt;variable>:"> specifies a variable media announcement
(see <xref target="defn.variable"/>) to play.  The element is
optional. </t>

<t hangText="&lt;dtmf>:"> generates one or more DTMF tones (see <xref
target="defn.dtmf"/>) to play. The element is optional. </t>

</list>
</t>

<t>It is RECOMMENDED that a &lt;par> element contains only one
&lt;media> element of the same media type (i.e., same type-name as
defined in <xref target="defn.mimetype"/>). If a &lt;par> element
configuration is not supported, the MS sends a &lt;response> with a 435
status code (<xref target="defn.statuscodes"/>).
</t>

<t>Runtime &lt;control>s (<xref target="defn.control"/>) apply to each
child element playing in parallel. For example, pause and resume controls
cause all child elements to be paused and resumed, respectively. </t>

<t>If the &lt;par> element is stopped by the prompt container
(e.g., bargein or dialog termination), then playback of all child
elements is stopped. The playback duration (<xref
target="defn.dialog.promptinfo"/>) reported for the &lt;par> element is
the duration of parallel playback, not the cumulative duration of each
child element played in parallel.
</t>

<t>For example, a request to playback audio and video media in parallel:

<figure><artwork><![CDATA[ 
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr"> 
<dialogstart connectionid="c1">
  <dialog>
   <prompt>
    <par>
     <media type="audio/x-wav" 
            loc="http://www.example.com/media/comments.wav"/>
     <media type="video/3gpp;codecs='s263'" 
            loc="http://www.example.com/media/camera.3gp"/>
    </par>
   </prompt>
  </dialog>
 </dialogstart>
</mscivr>
]]></artwork></figure>

When the &lt;prompt> element is executed, it begins playback of its
child element in document-order sequence. In this case, there is only
one child element, a &lt;par> element itself containing audio and video
&lt;media> child elements. Consequently, playback of both audio and video
media resources is initiated at the same time. Since the endsync
attribute is not specified, the default value "last" applies. The
&lt;par> element playback is complete when the media resource with the
longest duration is complete.
</t>


<section toc="include" anchor="defn.seq" title="&lt;seq>">

<t>The &lt;seq> element specifies media resources to be played back in
sequence. This allows a sequence of media resources to be played at the
same time as other children of a &lt;par> element are played in
parallel, for example, a sequence of audio resources while a video
resource is played in parallel.  This element is modeled after the
&lt;seq> element in SMIL <xref target="W3C.REC-SMIL2-20051213"/>.</t>

<t>The &lt;seq> element has no attributes. </t>

<t>The &lt;seq> element has the following child elements (at least one,
any order, multiple occurrences of each element permitted):

<list style="hanging">

<t hangText="&lt;media>:"> specifies a media resource (see <xref
target="defn.media"/>) to play.  The element is optional. </t>

<t hangText="&lt;variable>:"> specifies a variable media announcement
(see <xref target="defn.variable"/>) to play.  The element is
optional. </t>

<t hangText="&lt;dtmf>:"> generates one or more DTMF tones (see <xref
target="defn.dtmf"/>) to play. The element is optional. </t>

</list>
</t>

<t>Playback of a &lt;seq> element is complete when all child elements in
the sequence are complete. If the &lt;seq> element is stopped by the
&lt;par> container, then playback of the current child element is
stopped (remaining child elements in the sequence are not played).
</t>


<t>For example, a request to play a sequence of audio resources in
parallel with a video media:

<figure><artwork><![CDATA[ 
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr"> 
<dialogstart connectionid="c1">
  <dialog>
   <prompt>
    <par endsync="first">
     <seq> 
       <media type="audio/x-wav" 
            loc="http://www.example.com/media/date.wav"/>
       <media type="audio/x-wav" 
            loc="http://www.example.com/media/intro.wav"/>
       <media type="audio/x-wav" 
            loc="http://www.example.com/media/main.wav"/>
       <media type="audio/x-wav" 
            loc="http://www.example.com/media/end.wav"/>
     </seq>
     <media type="video/3gpp;codecs='s263'" 
            loc="rtsp://www.example.com/media/camera.3gp"/>
    </par>
   </prompt>
  </dialog>
 </dialogstart>
</mscivr>
]]></artwork></figure>

When the &lt;prompt> element is executed, it begins playback of the
&lt;par> element containing a &lt;seq> element and a video &lt;media>
element.  The &lt;seq> element itself contains a sequence of audio
&lt;media> elements. Consequently, playback of the video media resource
is initiated at the same time as playback of the sequence of the audio
media resources is initiated. Each audio resource is played back after
the previous one completes. Since the endsync attribute is set to
"first", the &lt;par> element playback is complete when either all the
audio resources in &lt;seq> have been played to completion or the video
&lt;media> is complete, whichever occurs first.
</t>



</section> <!-- end of seq element -->

</section> <!-- end of par element -->



</section>

<section toc="include" anchor="defn.control" title="&lt;control>">


<t>The &lt;control> element defines how DTMF input is mapped to runtime
controls, including prompt playback controls. </t>

<t>DTMF input matching these controls MUST NOT cause prompt playback
  to be
interrupted (i.e., no prompt bargein), but causes the appropriate
operation to be applied, for example, speeding up prompt playback. </t>

<t>DTMF input matching these controls has priority over &lt;collect>
input for the duration of prompt playback. If an incoming DTMF character
matches a specified runtime control, then the DTMF character is
consumed: it is not added to the digit buffer and so is not available to
the &lt;collect> operation. Once prompt playback is complete, runtime
controls are no longer active. </t>

<t>The &lt;control> element has the following attributes:

<list style="hanging">

<t hangText="gotostartkey:">maps a DTMF key to skip directly to the
start of the prompt. A valid value is a DTMF character (see <xref
target="defn.dtmfchar"/>).  The attribute is optional. There is no
default value.</t>

<t hangText="gotoendkey:">maps a DTMF key to skip directly to the end of
the prompt. A valid value is a DTMF character (see <xref
target="defn.dtmfchar"/>).  The attribute is optional. There is no
default value.</t>

<t hangText="skipinterval:">indicates how far an MS skips backwards or
forwards through prompt playback when the rewind (rwkey) of fast forward
key (ffkey) is pressed.  A valid value is a Time Designation (see <xref
target="defn.timedesignation"/>).  The attribute is optional. The
default value is 6s.</t>

<t hangText="ffkey:">maps a DTMF key to a fast forward operation equal
to the value of 'skipinterval'. A valid value is a DTMF character (see
<xref target="defn.dtmfchar"/>).  The attribute is optional. There is no
default value.</t>

<t hangText="rwkey:">maps a DTMF key to a rewind operation equal
to the value of 'skipinterval'. A valid value is a DTMF character (see
<xref target="defn.dtmfchar"/>).  The attribute is optional. There is no
default value.</t>

<t hangText="pauseinterval:">indicates how long an MS pauses prompt
playback when the pausekey is pressed.  A valid value is a Time
Designation (see <xref target="defn.timedesignation"/>).  The attribute
is optional. The default value is 10s.</t>

<t hangText="pausekey:">maps a DTMF key to a pause operation equal to
the value of 'pauseinterval'.  A valid value is a DTMF character (see
<xref target="defn.dtmfchar"/>).  The attribute is optional. There is no
default value.</t>

<t hangText="resumekey:">maps a DTMF key to a resume operation.  A valid
value is a DTMF character (see <xref target="defn.dtmfchar"/>).  The
attribute is optional. There is no default value.</t>

<t hangText="volumeinterval:">indicates the increase or decrease in
playback volume (relative to the current volume) when the volupkey or
voldnkey is pressed.  A valid value is a percentage (see <xref
target="defn.percentage"/>).  The attribute is optional. The default
value is 10%.</t>

<t hangText="volupkey:">maps a DTMF key to a volume increase operation
equal to the value of 'volumeinterval'.  A valid value is a DTMF
character (see <xref target="defn.dtmfchar"/>).  The attribute is
optional. There is no default value.</t>

<t hangText="voldnkey:">maps a DTMF key to a volume decrease operation
equal to the value of 'volumeinterval'. A valid value is a DTMF
character (see <xref target="defn.dtmfchar"/>).  The attribute is
optional. There is no default value.</t>

<t hangText="speedinterval:">indicates the increase or decrease in
playback speed (relative to the current speed) when the speedupkey or
speeddnkey is pressed.  A valid value is a percentage (see <xref
target="defn.percentage"/>).  The attribute is optional. The default
value is 10%.</t>

<t hangText="speedupkey:">maps a DTMF key to a speed increase operation
equal to the value of the speedinterval attribute.  A valid value is a
DTMF character (see <xref target="defn.dtmfchar"/>).  The attribute is
optional. There is no default value.</t>

<t hangText="speeddnkey:">maps a DTMF key to a speed decrease operation
equal to the value of the speedinterval attribute. A valid value is a
DTMF character (see <xref target="defn.dtmfchar"/>).  The attribute is
optional. There is no default value.</t>

<t hangText="external:">allows one or more DTMF keys to be declared as
external controls (for example, video camera controls); the MS can send
notifications when a matching key is activated using &lt;dtmfnotify>
(<xref target="defn.dtmfnotify"/>). A valid value is a DTMF string (see
<xref target="defn.dtmfstring"/>). The attribute is optional. There is
no default value.</t>

</list>

If the same DTMF is specified in more than one DTMF key control
attribute -- except the pausekey and resumekey attributes -- the MS sends
a &lt;response> with a 413 status code (<xref
target="defn.statuscodes"/>).
</t>

<t>The MS has the following execution model for runtime control after
initialization:

<list style="numbers">

<t>If an error occurs during execution, then the MS terminates runtime
control and the error is reported to the dialog container.  The MS MAY
report controls executed successfully before the error in
&lt;controlinfo> (see <xref target="defn.dialog.controlinfo"/>).</t>

<t>Runtime controls are active only during prompt playback (if no
&lt;prompt> element is specified, then runtime controls are ignored). If
DTMF input matches any specified keys (for example, the ffkey), then the
MS applies the appropriate operation immediately.

If a seek operation (ffkey, rwkey) attempts to go beyond the beginning
or end of the prompt queue, then the MS automatically truncates it to
the prompt queue beginning or end, respectively.

If a volume operation (voldnkey, volupkey) attempts to go beyond the
minimum or maximum volume supported by the platform, then the MS
automatically limits the operation to minimum or maximum supported
volume, respectively.

If a speed operation (speeddnkey, speedupkey) attempts to go beyond the
minimum or maximum playback speed supported by the platform, then the MS
automatically limits the operation to minimum or maximum supported
speed, respectively.

If the pause operation attempts to pause output when it is already
paused, then the operation is ignored. If the resume operation attempts
to resume when the prompts are not paused, then the operation is
ignored. 

If a seek, volume, or speed operation is applied when output is paused,
then the MS also resumes output automatically.

</t>

<t>If DTMF control subscription has been specified for the dialog, then
each DTMF match of a control operation is reported in a &lt;dtmfnotify>
notification event (<xref target="defn.dtmfnotify"/>). </t>

<t>When the dialog exits, all control matches are reported in a
&lt;controlinfo> element (<xref
target="defn.dialog.controlinfo"/>). </t>


</list>
</t>


</section>


<section toc="include" anchor="defn.collect" title="&lt;collect>">

<t>The &lt;collect> element defines how DTMF input is collected.</t>

<t>The &lt;collect> element has the following attributes:

<list style="hanging">

<t hangText="cleardigitbuffer:">indicates whether the digit buffer is to
be cleared.  A valid value is a boolean (see <xref
target="defn.boolean"/>).  A value of true indicates that the digit
buffer is to be cleared. A value of false indicates that the digit
buffer is not to be cleared. The attribute is optional. The default
value is true.
</t>

<t hangText="timeout:">indicates the maximum time to wait for user input
to begin.  A valid value is a Time Designation (see <xref
target="defn.timedesignation"/>).  The attribute is optional. The
default value is 5s.</t>

<t hangText="interdigittimeout:">indicates the maximum time to wait for
another DTMF when the collected input is incomplete with respect to the
grammar. A valid value is a Time Designation (see <xref
target="defn.timedesignation"/>).  The attribute is optional. The
default value is 2s.</t>

<t hangText="termtimeout:">indicates the maximum time to wait for the
termchar character when the collected input is complete with respect to
the grammar. A valid value is a Time Designation (see <xref
target="defn.timedesignation"/>).  The attribute is optional. The
default value is 0s (no delay).</t>

<t hangText="escapekey:">specifies a DTMF key that indicates collected
grammar matches are discarded and the DTMF collection is to be
re-initiated.  A valid value is a DTMF character (see <xref
target="defn.dtmfchar"/>).  The attribute is optional. There is no
default value.</t>

<t hangText="termchar:">specifies a DTMF character for terminating DTMF
input collection using the internal grammar. It is ignored when a custom
grammar is specified.  A valid value is a DTMF character (see <xref
target="defn.dtmfchar"/>).  To disable termination by a conventional
DTMF character, set the parameter to an unconventional character like
'A'. The attribute is optional. The default value is '#'.</t>

<t hangText="maxdigits:">The maximum number of digits to collect using
an internal digits (0-9 only) grammar. It is ignored when a custom
grammar is specified. A valid value is a positive integer (see <xref
target="defn.posinteger"/>).  The attribute is optional. The default
value is 5.</t>

</list>

</t>


<t>The following matching priority is defined for incoming DTMF:
termchar attribute, escapekey attribute, and then as part of a
grammar. For example, if "1" is defined as the escapekey attribute and
as part of a grammar, then its interpretation as an escapekey takes
priority.
</t>

<t>The &lt;collect> element has the following child element:

<list style="hanging">

<t hangText="&lt;grammar>:">indicates a custom grammar format (see <xref
target="defn.grammar"/>).  The element is optional.
</t>

</list>

</t>

<t>The custom grammar takes priority over the internal grammar. If a
&lt;grammar> element is specified, the MS MUST use it for DTMF
collection.</t>

<t>The MS has the following execution model for DTMF collection after 
initialization:

<list style="numbers">

<t>The DTMF collection buffer MUST NOT receive DTMF input matching
&lt;control> operations (see <xref target="defn.control"/>). </t>

<t>If an error occurs during execution, then the MS terminates
collection and reports the error to the dialog container (see <xref
target="defn.ivrdialog"/>).  The MS MAY report DTMF collected before the
error in &lt;collectinfo> (see <xref
target="defn.dialog.collectinfo"/>).</t>

<t>The MS clears the digit buffer if the value of the cleardigitbuffer
attribute is true.</t>

<t>The MS activates an initial timer with the duration of the value of
the timeout attribute.  If the initial timer expires before any DTMF
input is received, then collection execution terminates, the
&lt;collectinfo> (see <xref target="defn.dialog.collectinfo"/>) has the
termmode attribute set to noinput and the execution status is reported
to the dialog container. 
</t>

<t>When the first DTMF collect input is received, the initial timer is
canceled and DTMF collection begins. Each DTMF input is collected
unless it matches the value of the escapekey attribute or the termchar
attribute when the internal grammar is used. Collected input is matched
against the grammar to determine if it is valid and, if valid, whether
collection is complete. Valid DTMF patterns are either a simple digit
string where the maximum length is determined by the maxdigits attribute
and that can be optionally terminated by the character in the termchar
attribute, or a custom DTMF grammar specified with the &lt;grammar>
element. </t>


<t>After escapekey input, or a valid input that does not complete the
grammar, the MS activates a timer for the value of the interdigittimeout
attribute or the termtimeout attribute.  The MS only uses the
termtimeout value when the grammar does not allow any additional input;
otherwise, the MS uses the interdigittimeout.
</t>

<t>If DTMF collect input matches the value of the escapekey attribute,
then the MS re-initializes DTMF collection: i.e., the MS discards
collected DTMFs already matched against the grammar, and the MS attempts
to match incoming DTMF (including any pending in the digit buffer) as
described in Step 5 above.</t>

<t>If the collect input is not valid with respect to the grammar or an
interdigittimeout timer expires, the MS terminates collection execution
and reports execution status to the dialog container with a
&lt;collectinfo> (see <xref target="defn.dialog.collectinfo"/>) where
the termmode attribute is set to nomatch. </t>

<t>If the collect input completes the grammar or if a termtimeout timer
expires, then the MS terminates collection execution and reports
execution status to the dialog container with &lt;collectinfo> (see
<xref target="defn.dialog.collectinfo"/>) where the termmode attribute
is set to match. </t>

</list>
</t>

<section toc="include" anchor="defn.grammar" title="&lt;grammar>">

<t>The &lt;grammar> element allows a custom grammar, inline or external,
to be specified. Custom grammars permit the full range of DTMF
characters including '*' and '#' to be specified for DTMF pattern
matching.
</t>

<t>The &lt;grammar> element has the following attributes:

<list style="hanging">

<t hangText="src:">specifies the location of an external grammar
document. A valid value is a URI (see <xref target="defn.uri"/>).  The
MS MUST support both HTTP <xref target="RFC2616"/> and HTTPS <xref
target="RFC2818"/> schemes and the MS MAY support other schemes.  If
the URI scheme is unsupported, the MS sends a &lt;response> with a 420
status code (<xref target="defn.statuscodes"/>). If the resource cannot
be retrieved within the timeout interval, the MS sends a &lt;response>
with a 409 status code.  If the grammar format is not supported, the MS
sends a &lt;response> with a 424 status code. The attribute is
optional. There is no default value.
</t>

<t hangText="type:">identifies the preferred type of the grammar
document identified by the src attribute. A valid value is a MIME media type
(see <xref target="defn.mimetype"/>). If the URI scheme used in the src
attribute defines a mechanism for establishing the authoritative MIME
media type of the media resource, the value returned by that mechanism
takes precedence over this attribute. The attribute is optional. There
is no default value.
</t>

<t hangText="fetchtimeout:">the maximum interval to wait when fetching a
grammar resource. A valid value is a Time Designation (see <xref
target="defn.timedesignation"/>).  The attribute is optional. The
default value is 30s. </t>

</list>
</t>

<t>The &lt;grammar> element allows inline grammars to be specified. XML
grammar formats MUST use a namespace other than the one used in this
specification. Non-XML grammar formats MAY use a CDATA section.
</t>

<t>The MS MUST support the Speech Recognition Grammar Specification <xref target="SRGS"/> XML grammar format
("application/srgs+xml") and MS MAY support the Key Press Markup Language (KPML) <xref
target="RFC4730"/> or other grammar formats.  If the grammar format is
not supported by the MS, then the MS sends a &lt;response> with a 424
status code (<xref target="defn.statuscodes"/>).
</t>

<t>For example, the following fragment shows DTMF collection with an
inline SRGS grammar:

<figure><artwork><![CDATA[
<collect cleardigitbuffer="false" timeout="20s"
	interdigittimeout="1s">
	<grammar>
		<grammar xmlns="http://www.w3.org/2001/06/grammar"
				version="1.0" mode="dtmf">
   		  <rule id="digit">
		   <one-of>
			<item>0</item>
			<item>1</item>
			<item>2</item>
			<item>3</item>
 			<item>4</item>
 			<item>5</item>
			<item>6</item>
			<item>7</item>
			<item>8</item>
			<item>9</item>
		   </one-of>
		</rule>

		<rule id="pin" scope="public">
 		 <one-of>
			<item>
			 <item repeat="4">
			  <ruleref uri="#digit"/>
				</item>#</item>
				<item>* 9</item>
		 </one-of>
		</rule>
	
       </grammar>
	 </grammar>
	</collect>
]]></artwork></figure>
</t>


<t>The same grammar could also be referenced externally (and take
advantage of HTTP caching):

<figure><artwork><![CDATA[
<collect cleardigitbuffer="false" timeout="20s">
   <grammar type="application/srgs+xml" 
            src="http://example.org/pin.grxml"/>
</collect>
]]></artwork></figure>
</t>

</section>


</section>


<section toc="include" anchor="defn.record" title="&lt;record>">


<t>The &lt;record> element specifies how media input is recorded.</t>

<t>The &lt;record> element has the following attributes:

<list style="hanging">

<t hangText="timeout:">indicates the time to wait for user input to
begin.  A valid value is a Time Designation (see <xref
target="defn.timedesignation"/>).  The attribute is optional. The
default value is 5s.</t>

<t hangText="vadinitial:">controls whether Voice Activity Detection (VAD)
is used to initiate the recording operation.  A valid value is a boolean
(see <xref target="defn.boolean"/>). A value of true indicates the MS
MUST initiate recording if the VAD detects voice on the configured
inbound audio streams.  A value of false indicates that the MS MUST NOT
initiate recording using VAD. The attribute is optional. The default
value is false.
</t>

<t hangText="vadfinal:">controls whether VAD
is used to terminate the recording operation.  A valid value is a
boolean (see <xref target="defn.boolean"/>). A value of true indicates
the MS MUST terminate recording if the VAD detects a period of silence
(whose duration is specified by the finalsilence attribute) on
configured inbound audio streams.  A value of false indicates that the
MS MUST NOT terminate recording using VAD. The attribute is
optional. The default value is false.
</t>

<t hangText="dtmfterm:">indicates whether the recording operation is
terminated by DTMF input.  A valid value is a boolean (see <xref
target="defn.boolean"/>).  A value of true indicates that recording is
terminated by DTMF input. A value of false indicates that recording is
not terminated by DTMF input. The attribute is optional. The default
value is true.
</t>

<t hangText="maxtime:">indicates the maximum duration of the
recording. A valid value is a Time Designation (see <xref
target="defn.timedesignation"/>).  The attribute is optional. The
default value is 15s.
</t>

<t hangText="beep:">indicates whether a 'beep' is to be played
immediately prior to initiation of the recording operation.  A valid
value is a boolean (see <xref target="defn.boolean"/>). The attribute is
optional. The default value is false.
</t>

<t hangText="finalsilence:">indicates the interval of silence that
indicates the end of voice input. This interval is not part of the
recording itself. This parameter is ignored if the vadfinal attribute
has the value false. A valid value is a Time Designation (see <xref
target="defn.timedesignation"/>).  The attribute is optional. The
default value is 5s.</t>

<t hangText="append:">indicates whether recorded data is appended or not
to a recording location if a resource already exists. A valid value is a
boolean (see <xref target="defn.boolean"/>). A value of true indicates
that recorded data is appended to the existing resource at a recording
location. A value of false indicates that recorded data is to overwrite
the existing resource. The attribute is optional. The default value is false.
</t>

<t>When a recording location is specified using the HTTP or HTTPS
protocol, the recording operation SHOULD be performed using the HTTP GET
and PUT methods, unless the HTTP server provides a special interface for
recording uploads and appends (e.g., using POST). When the append
attribute has the value false, the recording data is uploaded to the
specified location using HTTP PUT and replaces any data at that location
on the HTTP origin server.  When append has the value true, the existing
data (if any) is first downloaded from the specified location using HTTP
GET, then the recording data is appended to the existing recording (note
that this might require codec conversion and modification to the
existing data), then the combined recording is uploaded to the specified
location using HTTP PUT. HTTP errors are handled as described in <xref
target="RFC2616"/>.
</t>
<t>
When the recording location is specified using protocols other than HTTP
or HTTPS, the mapping of the append operation onto the upload protocol
scheme is implementation specific.
</t>

</list>
If either the vadinitial or vadfinal attribute is set to true and the MS
does not support VAD, the MS sends a &lt;response> with a 434 status
code (<xref target="defn.statuscodes"/>).

</t>

<t>The &lt;record> element has the following child element (0 or more
occurrences):

<list style="hanging">

<t hangText="&lt;media>:">specifies the location and type of the media
resource for uploading recorded data (see <xref
target="defn.media"/>). The MS MUST support both HTTP <xref
target="RFC2616"/> and HTTPS <xref target="RFC2818"/> schemes for
uploading recorded data and the MS MAY support other schemes.  The MS
uploads recorded data to this resource as soon as possible after
recording is complete.  The element is optional.
</t>

</list>
If multiple &lt;media> elements are specified, then media input is to be
recorded in parallel to multiple resource locations.
</t>

<t>If no &lt;media> child element is specified, the MS MUST record media
input but the recording location and the recording format are
implementation specific (e.g., the MS records audio in the WAV format to
a local disk accessible by HTTP). The recording location and format are
reported in &lt;recordinfo> (<xref target="defn.dialog.recordinfo"/>)
when the dialog terminates.  The recording MUST be available from this
location until the connection or conference associated with the dialog
on the MS terminates.
</t>

<t>If the MS does not support the configuration required for recording
from the input media streams to one or more &lt;media> elements and a
more specific error code is not defined for its child elements, the MS
sends a &lt;response> with a 423 status code (<xref
target="defn.statuscodes"/>).
</t>

<t>Note that an MS MAY support uploading recorded data to recording
locations at the same time the recording operation takes place. Such
implementations need to be aware of the requirements of certain
recording formats (e.g., WAV) for metadata at the beginning of the
uploaded file, that the finalsilence interval is not part of the
recording and how these requirements interact with the URI scheme.
</t>



<t>The MS has the following execution model for recording after
initialization:

<list style="numbers">

<t>If an error occurs during execution (e.g., authentication or
communication error when trying to upload to a recording location), then
the MS terminates record execution and reports the error to the dialog
container (see <xref target="defn.ivrdialog"/>). The MS MAY report data
recorded before the error in &lt;recordinfo> (see <xref
target="defn.dialog.recordinfo"/>).
</t>

<t>If DTMF input (not matching a &lt;control> operation) is received
during prompt playback and the prompt bargein attribute is set to true,
then the MS activates the record execution. Otherwise, the MS activates it
after the completion of prompt playback. </t>

<t>If a beep attribute with the value of true is specified, then the MS
plays a beep tone. </t>

<t>The MS activates a timer with the duration of the value of the
timeout attribute. If the timer expires before the recording operation
begins, then the MS terminates the recording execution and reports the
status to dialog container with &lt;recordinfo> (see <xref
target="defn.dialog.recordinfo"/>) where the termmode attribute is set
to noinput. </t>

<t>Initiation of the recording operation depends on the value of the
vadinitial attribute. If vadinitial has the value false, then the
recording operation is initiated immediately. Otherwise, the recording
operation is initiated when voice activity is detected.</t>

<t>When the recording operation is initiated, a timer is started for the
value of the maxtime attribute (maximum duration of the recording). If
the timer expires before the recording operation is complete, then the
MS terminates recording execution and reports the execution status to
the dialog container with &lt;recordinfo> (see <xref
target="defn.dialog.recordinfo"/>) where the termmode attribute set to
maxtime. </t>

<t>During the record operation input, media streams are recording to a
location and format specified in one or more &lt;media> child
elements. If no &lt;media> child element is specified, the MS records
input to an implementation-specific location and format. </t>

<t>If the dtmfterm attribute has the value true and DTMF input is
detected during the record operation, then the MS terminates recording
and its status is reported to the dialog container with a
&lt;recordinfo> (see <xref target="defn.dialog.recordinfo"/>) where the
termmode attribute is set to dtmf. </t>

<t>If vadfinal attribute has the value true, then the MS terminates the
recording operation when a period of silence, with the duration
specified by the value of the finalsilence attribute, is detected. This
period of silence is not part of the final recording. The status is
reported to the dialog container with a &lt;recordinfo> (see <xref
target="defn.dialog.recordinfo"/>) where the termmode attribute is set
to finalsilence. </t>

</list>
</t>


<t>For example, a request to record audio and video input to separate
locations:

<figure><artwork><![CDATA[ 
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr"> 
<dialogstart connectionid="c1">
  <dialog>
   <record maxtime="30s" vadinitial="false" vadfinal="false">
    <media type="audio/x-wav" 
        loc="http://www.example.com/upload/audio.wav"/>
    <media type="video/3gpp;codecs='s263'"  
        loc="http://www.example.com/upload/video.3gp"/>
   </record>
  </dialog>
 </dialogstart>
</mscivr>
]]></artwork></figure>

When the &lt;record> element is executed, it immediately begins
recording of the audio and video (since vadinitial is false) where the
destination locations are specified in the &lt;media> child elements.
Recording is completed when the duration reaches 30s or the connection
is terminated.
</t>


</section>  <!-- end of record -->

<section toc="include" anchor="defn.media" title="&lt;media>">

<t>
The &lt;media> element specifies a media resource to playback from (see
<xref target="defn.prompt"/>) or record to (see <xref
target="defn.record"/>). In the playback case, the resource is retrieved
and in the recording case, recording data is uploaded to the resource
location.
</t>

<t>A &lt;media> element has the following attributes:

<list style="hanging">

<t hangText="loc:">specifies the location of the media resource. A valid
value is a URI (see <xref target="defn.uri"/>). The MS MUST support both
HTTP <xref target="RFC2616"/> and HTTPS <xref target="RFC2818"/>
schemes and the MS MAY support other schemes. If the URI scheme is not
supported by the MS, the MS sends a &lt;response> with a 420 status code
(<xref target="defn.statuscodes"/>). If the resource is to be retrieved
but the MS cannot retrieve it within the timeout interval, the MS sends
a &lt;response> with a 409 status code. If the format of the media
resource is not supported, the MS sends a &lt;response> with a 429
status code. The attribute is mandatory.
</t>

<t hangText="type:">specifies the type of the media resource indicated
in the loc attribute. A valid value is a MIME media type (see <xref
target="defn.mimetype"/>) that, depending on its definition, can
include additional parameters (e.g., <xref target="RFC4281"/>). If the
URI scheme used in the loc attribute defines a mechanism for
establishing the authoratitive MIME media type of the media resource,
the value returned by that mechanism takes precedence over this
attribute. If additional media parameters are specified, the MS MUST use
them to determine media processing. For example, <xref
target="RFC4281"/> defines a 'codec' parameter for media types like
video/3gpp that would determine which media streams are played or
recorded. The attribute is optional. There is no default value.
</t>

<t hangText="fetchtimeout:">the maximum interval to wait when fetching a
media resource. A valid value is a Time Designation (see <xref
target="defn.timedesignation"/>).  The attribute is optional. The
default value is 30s. </t>

<t hangText="soundLevel:">playback soundLevel (volume) for the media
resource. A valid value is a percentage (see <xref
target="defn.percentage"/>). The value indicates increase or decrease
relative to the original recorded volume of the media. A value of 100%
(the default) plays the media at its recorded volume, a value of 200%
will play the media twice recorded volume, 50% at half its recorded
volume, a value of 0% will play the media silently, and so on.  See
'soundLevel' in SMIL <xref target="W3C.REC-SMIL2-20051213"/> for
further information.

The attribute is optional. The default value is 100%.
</t>

<t hangText="clipBegin:">offset from start of media resource to begin
playback.  A valid value is a Time Designation (see <xref
target="defn.timedesignation"/>).  The offset is measured in normal
media playback time from the beginning of the media resource.  If the
clipBegin offset is after the end of media (or the clipEnd offset), no
media is played.  See 'clipBegin' in SMIL <xref
target="W3C.REC-SMIL2-20051213"/> for further information.  The
attribute is optional. The default value is 0s.</t>

<t hangText="clipEnd:">offset from start of media resource to end
playback.  A valid value is a Time Designation (see <xref
target="defn.timedesignation"/>).  The offset is measured in normal
media playback time from the beginning of the media resource.  If the
clipEnd offset is after the end of media, then the media is played to
the end. If clipBegin is after clipEnd, then no media is played. See
'clipEnd' in SMIL <xref target="W3C.REC-SMIL2-20051213"/> for further
information.  The attribute is optional. There is no default value.</t>

</list>
The fetchtimeout, soundLevel, clipBegin, and clipEnd attributes are only
relevant in the playback use case. The MS ignores these attributes when
using the &lt;media> for recording.
</t>

<t>The &lt;media> element has no children.</t>


</section> <!-- end of media -->



</section>

<section anchor="defn.dialog.exit" title="Exit Information">

<t>When the dialog exits, information about the specified operations is
reported in a &lt;dialogexit> notification event (<xref
target="defn.dialogexit"/>). </t>

<section toc="include" anchor="defn.dialog.promptinfo" title="&lt;promptinfo>">

<t>The &lt;promptinfo> element reports the information about prompt
execution. It has the following attributes:

<list style="hanging">

<t hangText="duration:">indicates the duration of prompt playback in
milliseconds.  A valid value is a non-negative integer (see <xref
target="defn.nonneginteger"/>).  The attribute is optional. There is no
default value.
</t>

<t hangText="termmode:">indicates how playback was terminated.  Valid
values are 'stopped', 'completed', or 'bargein'. The attribute is
mandatory.
</t>


</list>
</t>

<t>The &lt;promptinfo> element has no child elements.</t>

</section>


<section toc="include" anchor="defn.dialog.controlinfo" title="&lt;controlinfo>">

<t>The &lt;controlinfo> element reports information about control
execution. </t>


<t>The &lt;controlinfo> element has no attributes and has 0 or more
&lt;controlmatch> child elements each describing an individual runtime
control match.
</t>


<section toc="include" anchor="defn.dialog.controlmatch" title="&lt;controlmatch>">

<t>The &lt;controlmatch> element has the following attributes:

<list style="hanging">

<t hangText="dtmf:">DTMF input triggering the runtime control.  A valid
value is a DTMF string (see <xref target="defn.dtmfstring"/>) with no
space between characters. The attribute is mandatory.
</t>

<t hangText="timestamp:">indicates the time (on the MS) at which the
control was triggered.  A valid value is a dateTime expression (<xref
target="defn.dateTime"/>). The attribute is mandatory.
</t>

</list>
</t>

<t>The &lt;controlmatch> element has no child elements.</t>

</section>

</section>

<section toc="include" anchor="defn.dialog.collectinfo" title="&lt;collectinfo>">

<t>The &lt;collectinfo> element reports the information about collect
execution.  </t>


<t>The &lt;collectinfo> element has the following attributes:

<list style="hanging">

<t hangText="dtmf:">DTMF input collected from the user.  A valid value
is a DTMF string (see <xref target="defn.dtmfstring"/>) with no space
between characters. The attribute is optional. There is no default
value.
</t>

<t hangText="termmode:">indicates how collection was terminated.  Valid
values are 'stopped', 'match', 'noinput', or 'nomatch'.  The attribute
is mandatory.
</t>

</list>
</t>

<t>The &lt;collectinfo> element has no child elements.</t>


</section>

<section toc="include" anchor="defn.dialog.recordinfo" title="&lt;recordinfo>">

<t>The &lt;recordinfo> element reports information about record
execution (<xref target="defn.record"/>). </t>

<t>The &lt;recordinfo> element has the following attributes:

<list style="hanging">

<t hangText="termmode:">indicates how recording was terminated.  Valid
values are 'stopped', 'noinput', 'dtmf', 'maxtime', and 'finalsilence'.
The attribute is mandatory.
</t>

<t hangText="duration:">indicates the duration of the recording in
milliseconds.  A valid value is a non-negative integer (see <xref
target="defn.nonneginteger"/>).  The attribute is optional. There is no
default value.
</t>

</list>
</t>

<t>The &lt;recordinfo> element has the following child element (0 or
more occurrences):

<list style="hanging">

<t hangText="&lt;mediainfo>:">indicates information about a recorded
media resource (see <xref target="defn.dialog.mediainfo"/>). The element
is optional.
</t>

</list>

</t>

<t>When the record operation is successful, the MS MUST specify a
&lt;mediainfo> element for each recording location. For example, if the
&lt;record> element contained three &lt;media> child elements, then the
&lt;recordinfo> would contain three &lt;mediainfo> child elements.</t>


<section toc="include" anchor="defn.dialog.mediainfo" title="&lt;mediainfo>">

<t>The &lt;mediainfo> element reports information about a recorded media
resource.
</t>


<t>The &lt;mediainfo> element has the following attributes:

<list style="hanging">

<t hangText="loc:">indicates the location of the media resource. A valid
value is a URI (see <xref target="defn.uri"/>).  The attribute is
mandatory.
</t>

<t hangText="type:">indicates the format of the media resource. A valid
value is a MIME media type (see <xref target="defn.mimetype"/>). The
attribute is mandatory.
</t>

<t hangText="size:">indicates the size of the media resource in bytes.
A valid value is a non-negative integer (see <xref
target="defn.nonneginteger"/>).  The attribute is optional. There is no
default value.
</t>

</list>
</t>

</section> <!-- end of mediainfo -->

</section> <!-- end of recordinfo -->


</section>


</section>



<section anchor="defn.auditmgt" title="Audit Elements">

<t>The audit elements defined in this section allow the MS to be audited
for package capabilities as well as dialogs managed by the package.

Auditing is particularly important for two use cases. First, it enables
discovery of package capabilities supported on an MS before an AS starts
a dialog on connection or conference. The AS can then use this
information to create request elements using supported capabilities and,
in the case of codecs, to negotiate an appropriate SDP for a User
Agent's connection.  Second, auditing enables discovery of the existence
and status of dialogs currently managed by the package on the MS. This
could be used when one AS takes over management of the dialogs if the
AS that initiated the dialogs fails or is no longer available (see
Security Considerations described in <xref target="security"/>). </t>

<section anchor="defn.audit" title="&lt;audit>">

<t>The &lt;audit> request element is sent to the MS to request
information about the capabilities of, and dialogs currently managed
with, this Control Package. Capabilities include supported dialog
languages, grammar formats, record and media types, as well as
codecs. Dialog information includes the status of managed dialogs as
well as codecs.

</t>

<t>The &lt;audit> element has the following attributes: 


<list style="hanging">

<t hangText="capabilities:">indicates whether package capabilities are
to be audited. A valid value is a boolean (see <xref
target="defn.boolean"/>). A value of true indicates that capability
information is to be reported. A value of false indicates that
capability information is not to be reported. The attribute is
optional. The default value is true.
</t>


<t hangText="dialogs:">indicates whether dialogs currently managed by
the package are to be audited. A valid value is a boolean (see <xref
target="defn.boolean"/>). A value of true indicates that dialog
information is to be reported. A value of false indicates that dialog
information is not to be reported. The attribute is optional. The
default value is true.
</t>

<t hangText="dialogid:">string identifying a specific dialog to audit.
The MS sends a response with a 406 status code (<xref
target="defn.statuscodes"/>) if the specified dialog identifier is
invalid. The attribute is optional. There is no default value.
</t> 

</list>

If the dialogs attribute has the value true and dialogid attribute is
specified, then only audit information about the specified dialog is
reported. If the dialogs attribute has the value false, then no dialog
audit information is reported even if a dialogid attribute is specified.
</t>

<t>
The &lt;audit> element has no child elements.
</t>

<t>When the MS receives an &lt;audit> request, it MUST reply with an
&lt;auditresponse> element (<xref target="defn.auditresponse"/>), which
includes a mandatory attribute describing the status in terms of a
numeric code. Response status codes are defined in <xref
target="defn.statuscodes"/>.  If the request is successful, the
&lt;auditresponse> contains (depending on attribute values) a
&lt;capabilities> element (<xref target="defn.capabilities"/>) reporting
package capabilities and a &lt;dialogs> element (<xref
target="defn.dialogs"/>) reporting managed dialog information. If the MS
is not able to process the request and carry out the audit operation,
the audit request has failed and the MS MUST indicate the class of
failure using an appropriate 4xx response code. Unless an error response
code is specified for a class of error within this section,
implementations follow <xref target="defn.statuscodes"/> in determining
the appropriate status code for the response.
</t>


<t>For example, a request to audit capabilities and dialogs managed by
the package:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
  <audit/>
</mscivr>
]]></artwork></figure>
</t>

<t>In this example, only capabilities are to be audited:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
  <audit dialogs="false"/>
</mscivr>
]]></artwork></figure>
</t>

<t>With this example, only a specific dialog is to be audited:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
  <audit capabilities="false" dialogid="d4"/>
</mscivr>
]]></artwork></figure>
</t>


</section>




<section anchor="defn.auditresponse" title="&lt;auditresponse>">

<t>The &lt;auditresponse> element describes a response to an &lt;audit>
request.
</t>

<t>The &lt;auditresponse> element has the following attributes:

<list style="hanging">

<t hangText="status:">numeric code indicating the audit response
status. The attribute is mandatory. Valid values are defined in <xref
target="defn.statuscodes"/>. </t>

<t hangText="reason:">string specifying a reason for the status. The
attribute is optional. </t>

<t hangText="desclang:">specifies the language used in the value of 
the reason attribute. A valid value is a language identifier (<xref
target="defn.langid"/>).  The attribute is optional.  If not specified,
the value of the desclang attribute on &lt;mscivr> (<xref
target="defn.mscivr"/>) applies.
</t>

</list>
</t>


<t>The &lt;auditresponse> element has the following sequence of child
elements:

<list style="hanging">

<t hangText="&lt;capabilities>">element (<xref
target="defn.capabilities"/>) describing capabilities of the
package. The element is optional. </t>

<t hangText="&lt;dialogs>">element (<xref target="defn.dialogs"/>)
describing information about managed dialogs.  The element is
optional. </t>

</list>
</t>


<t>For example, a successful response to an &lt;audit> request requesting
capabilities and dialogs information:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <auditresponse status="200">
  <capabilities>
   <dialoglanguages>
    <mimetype>application/voicexml+xml</mimetype>
   </dialoglanguages>
   <grammartypes/>
   <recordtypes>
    <mimetype>audio/x-wav</mimetype>
    <mimetype>video/3gpp</mimetype>
   </recordtypes>
   <prompttypes>
    <mimetype>audio/x-wav</mimetype>
    <mimetype>video/3gpp</mimetype>
   </prompttypes>
   <variables>
    <variabletype type="date" desc="value formatted as YYYYMMDD"> 
     <format desc="month year day">mdy</format>
     <format desc="year month day">ymd</format>
     <format desc="day month year">dmy</format>
     <format desc="day month">dm</format>
    </variabletype> 
   </variables>
   <maxpreparedduration>600s</maxpreparedduration>
   <maxrecordduration>1800s</maxrecordduration>
   <codecs>
    <codec name="video">
     <subtype>H263</subtype>
    </codec>
    <codec name="video">
     <subtype>H264</subtype>
    </codec>
    <codec name="audio">
     <subtype>PCMU</subtype>
    </codec>
    <codec name="audio">
     <subtype>PCMA</subtype>
    </codec>
    <codec name="audio">
     <subtype>telephone-event</subtype>
    </codec>
   </codecs>
  </capabilities>
  <dialogs>
   <dialogaudit dialogid="4532" state="preparing"/>
   <dialogaudit dialogid="4599" state="prepared"/>
   <dialogaudit dialogid="1234" state="started" conferenceid="conf1">
    <codecs>
     <codec name="audio">
      <subtype>PCMA</subtype>
     </codec>
     <codec name="audio">
      <subtype>telephone-event</subtype>
     </codec>
    </codecs>
   </dialogaudit>
  </dialogs>
 </auditresponse>
</mscivr>
]]></artwork></figure>
</t>


<section toc="include" anchor="defn.codecs" title="&lt;codecs>">

<t> The &lt;codecs> provides audit information about codecs. </t>

<t>The &lt;codecs> element has no attributes. </t>

<t>The &lt;codecs> element has the following sequence of child
elements (0 or more occurrences):

<list style="hanging">

<t hangText="&lt;codec>:">audit information for a codec (<xref
target="defn.codec"/>). The element is optional.
</t>

</list>
</t>

<t>For example, a fragment describing two codecs: 

<figure><artwork><![CDATA[
<codecs>
  <codec name="audio">
   <subtype>PCMA</subtype>
  </codec>
  <codec name="audio">
   <subtype>telephone-event</subtype>
  </codec>
</codecs>
]]></artwork></figure>
</t>

<section toc="include" anchor="defn.codec" title="&lt;codec>">

<t>The &lt;codec> element describes a codec on the MS. The element is
modeled on the &lt;codec> element in the XCON conference information
data model <xref target="XCON-DATA-MODEL"/> but allows
addition information (e.g., rate, speed, etc.) to be specified.
</t>


<t>The &lt;codec> element has the following attributes:

<list style="hanging">

<t hangText="name:">indicates the type name of the codec's media format
as defined in <xref target="IANA"/>. A valid value is a
"type-name" as defined in Section 4.2 of <xref target="RFC4288"/>.  The
attribute is mandatory.
</t>
</list>

</t>

<t>The &lt;codec> element has the following sequence of child
elements:

<list style="hanging">

<t hangText="&lt;subtype>:">element whose content model describes the
subtype of the codec's media format as defined in <xref
target="IANA"/>. A valid value is a "subtype-name" as defined in
Section 4.2 of <xref target="RFC4288"/>. The element is mandatory.
</t>

<t hangText="&lt;params>:">element (<xref target="defn.params"/>)
describing additional information about the codec. This package is
agnostic to the names and values of the codec parameters supported by an
implementation. The element is optional.
</t>

</list>
</t>

<t>For example, a fragment with a &lt;codec> element describing the
H263 video codec:

<figure><artwork><![CDATA[
<codec name="video">
 <subtype>H263</subtype>
</codec>
]]></artwork></figure>
</t>

</section>

</section>


<section toc="include" anchor="defn.capabilities" 
title="&lt;capabilities>">

<t> The &lt;capabilities> element provides audit information about
package capabilities. </t>

<t>The &lt;capabilities> element has no attributes. </t>

<t>The &lt;capabilities> element has the following sequence of child
elements:

<list style="hanging">

<t hangText="&lt;dialoglanguages>:">element (<xref
target="defn.dialoglanguages"/>) describing additional dialog languages
supported by the MS. The element is mandatory.
</t>

<t hangText="&lt;grammartypes>:">element (<xref
target="defn.grammartypes"/>) describing supported &lt;grammar>
(<xref target="defn.grammar"/>) format types. The element is mandatory.
</t>

<t hangText="&lt;recordtypes>:">element (<xref
target="defn.recordtypes"/>) describing &lt;media> (<xref
target="defn.media"/>) format types supported for &lt;record> (<xref
target="defn.record"/>).  The element is mandatory.
</t>

<t hangText="&lt;prompttypes>:">element (<xref
target="defn.prompttypes"/>) describing supported &lt;media> (<xref
target="defn.media"/>) format types for playback within a &lt;prompt>
(<xref target="defn.prompt"/>). The element is mandatory.
</t>

<t hangText="&lt;variables>:">element (<xref target="defn.variables"/>)
describing supported types and formats for the &lt;variable> element
(<xref target="defn.variable"/>). The element is mandatory.
</t>

<t hangText="&lt;maxpreparedduration>:"> element (<xref
target="defn.maxpreparedduration"/>) describing the supported maximum
duration for a prepared dialog following a &lt;dialogprepare> (<xref
target="defn.dialogprepare"/>) request. The element is mandatory.
</t>

<t hangText="&lt;maxrecordduration>:"> element (<xref
target="defn.maxrecordduration"/>) describing the supported maximum
duration for a recording &lt;record> (<xref target="defn.record"/>)
request. The element is mandatory.
</t>

<t hangText="&lt;codecs>:">element (<xref target="defn.codecs"/>)
describing codecs available to the package. The element is mandatory.
</t>

</list>
</t>

<t>For example, a fragment describing capabilities:

<figure><artwork><![CDATA[
  <capabilities>
   <dialoglanguages>
    <mimetype>application/voicexml+xml</mimetype>
   </dialoglanguages>
   <grammartypes/>
   <recordtypes>
    <mimetype>audio/x-wav</mimetype>
    <mimetype>video/3gpp</mimetype>
   </recordtypes>
   <prompttypes>
    <mimetype>audio/x-wav</mimetype>
    <mimetype>video/3gpp</mimetype>
   </prompttypes>
   <variables/>
   <maxpreparedduration>30s</maxpreparedduration>
   <maxrecordduration>60s</maxrecordduration>
   <codecs>
    <codec name="video">
     <subtype>H263</subtype>
    </codec>
    <codec name="video">
     <subtype>H264</subtype>
    </codec>
    <codec name="audio">
     <subtype>PCMU</subtype>
    </codec>
    <codec name="audio">
     <subtype>PCMA</subtype>
    </codec>
    <codec name="audio">
     <subtype>telephone-event</subtype>
    </codec>
   </codecs>
  </capabilities>
]]></artwork></figure>
</t>



<section toc="include" anchor="defn.dialoglanguages" 
title="&lt;dialoglanguages>">

<t> The &lt;dialoglanguages> element provides information about additional
dialog languages supported by the package. Dialog languages are identified by
their associated MIME media types. The MS MUST NOT include the mandatory
dialog language for this package (<xref target="defn.ivrdialog"/>).

</t>

<t>The &lt;dialoglanguages> element has no attributes. </t>

<t>The &lt;dialoglanguages> element has the following sequence of child
elements (0 or more occurrences):

<list style="hanging">

<t hangText="&lt;mimetype>:">element whose content model describes a
MIME media type (<xref target="defn.mimetype"/>) associated with a
supported dialog language. The element is optional.
</t>

</list>
</t>


</section>

<section toc="include" anchor="defn.grammartypes" title="&lt;grammartypes>">

<t> The &lt;grammartypes> element provides information about
&lt;grammar> format types supported by the package. The MS MUST NOT
include the mandatory SRGS format type, "application/srgs+xml" (<xref
target="defn.grammar"/>).

</t>

<t>The &lt;grammartypes> element has no attributes. </t>

<t>The &lt;grammartypes> element has the following sequence of child
elements (0 or more occurrences):

<list style="hanging">

<t hangText="&lt;mimetype>:">element whose content model describes a
mime type (<xref target="defn.mimetype"/>). The element is optional.
</t>

</list>
</t>



</section>

<section toc="include" anchor="defn.recordtypes" title="&lt;recordtypes>">

<t> The &lt;recordtypes> element provides information about media
resource format types of &lt;record> supported by the package (<xref
target="defn.record"/>).
</t>

<t>The &lt;recordtypes> element has no attributes. </t>

<t>The &lt;recordtypes> element has the following sequence of child
elements (0 or more occurrences):

<list style="hanging">

<t hangText="&lt;mimetype>:">element whose content model describes a
mime type (<xref target="defn.mimetype"/>). The element is optional.
</t>

</list>
</t>

</section>

<section toc="include" anchor="defn.prompttypes" title="&lt;prompttypes>">

<t> The &lt;prompttypes> element provides information about media
resource format types of &lt;prompt> supported by the package (<xref
target="defn.prompt"/>).
</t>

<t>The &lt;prompttypes> element has no attributes. </t>

<t>The &lt;prompttypes> element has the following sequence of child
elements (0 or more occurrences):

<list style="hanging">

<t hangText="&lt;mimetype>:">element whose content model describes a
mime type (<xref target="defn.mimetype"/>). The element is optional.
</t>

</list>
</t>

</section>


<section toc="include" anchor="defn.variables" title="&lt;variables>">

<t> The &lt;variables> element provides information about types and
formats for the &lt;variable> element (<xref target="defn.variable"/>)
supported by the package.
</t>


<t>The &lt;variables> element has no attributes. </t>

<t>The &lt;variables> element has the following sequence of child
elements (0 or more occurrences):

<list style="hanging">

<t hangText="&lt;variabletype>:">element describing the formats support
for a given type (<xref target="defn.variabletype"/>). The element is
optional.
</t>

</list>
</t>


<t>For example, a fragment describing support for &lt;variable> with a
"date" type according to the formats specified in <xref
target="defn.variable.date"/>.

<figure><artwork><![CDATA[
<variables>
 <variabletype type="date" desc="value formatted as YYYYMMDD"> 
   <format desc="month year day">mdy</format>
   <format desc="year month day">ymd</format>
   <format desc="day month year">dmy</format>
   <format desc="day month">dm</format>
 </variabletype> 
</variables>
]]></artwork></figure>

</t>

<section toc="include" anchor="defn.variabletype" title="&lt;variabletype>">

<t> The &lt;variabletype> element describes the formats supported for
&lt;variable> supported type.
</t>

<t>The &lt;variabletype> element has the following attributes: 


<list style="hanging">

<t hangText="type:">indicates a supported value associated with the type
attribute of the &lt;variable> element. The attribute is
mandatory. 
</t>

<t hangText="desc:">a string providing some textual description of the
type and format. The attribute is optional.
</t>

<t hangText="desclang:">specifies the language used in the value of 
the desc attribute. A valid value is a language identifier (<xref
target="defn.langid"/>).  The attribute is optional.  If not specified,
the value of the desclang attribute on &lt;mscivr> (<xref
target="defn.mscivr"/>) applies.</t>
</list>
</t>

<t>The &lt;variabletype> element has the following sequence of child
elements (0 or more occurrences):

<list style="hanging">

<t hangText="&lt;format>:">element with a desc attribute (optional
description), desclang (optional language identifier for the
description), and a content model describing a supported format in the
&lt;variable> format attribute. The element is optional.
</t>

</list>
</t>

</section>

</section>

<section toc="include" anchor="defn.maxpreparedduration" title="&lt;maxpreparedduration>">

<t> The &lt;maxpreparedduration> element describes the maximum duration
for a dialog to remain in the prepared state (<xref
target="defn.dialogmgt"/>) following a &lt;dialogprepare> (<xref
target="defn.dialogprepare"/>) request.
</t>


<t>The &lt;maxpreparedduration> element has no attributes. </t>

<t>The &lt;maxpreparedduration> element has a content model describing
the maximum prepared dialog duration as a time designation (<xref
target="defn.timedesignation"/>).
</t>


</section>


<section toc="include" anchor="defn.maxrecordduration" title="&lt;maxrecordduration>">
<t> The &lt;maxrecordduration> element describes the maximum recording
duration for &lt;record> <xref target="defn.record"/>) request supported
by the MS.
</t>



<t>The &lt;maxrecordduration> element has no attributes. </t>

<t>The &lt;maxrecordduration> element has a content model describing the
maximum duration of recording as a time designation (<xref
target="defn.timedesignation"/>).
</t>

</section>

</section>

<section toc="include" anchor="defn.dialogs" title="&lt;dialogs>">

<t> The &lt;dialogs> element provides audit information about
dialogs. </t>

<t>The &lt;dialogs> element has no attributes. </t>

<t>The &lt;dialogs> element has the following sequence of child
elements (0 or more occurrences):

<list style="hanging">

<t hangText="&lt;dialogaudit>:">audit information for a dialog (<xref
target="defn.dialogaudit"/>). The element is optional.
</t>

</list>
</t>


<section toc="include" anchor="defn.dialogaudit" title="&lt;dialogaudit>">

<t>The &lt;dialogaudit> element has the following attributes:

<list style="hanging">

<t hangText="dialogid:">string identifying the dialog. 
The attribute is mandatory. </t>

<t hangText="state:">string indicating the state of the dialog. Valid
values are preparing, prepared, starting, and started.  The attribute is
mandatory. </t>

<t hangText="connectionid:">string identifying the SIP dialog connection
associated with the dialog (see Appendix A.1 of <xref
target="RFC6230"/>). The attribute is
optional. There is no default value.</t>

<t hangText="conferenceid:">string identifying the conference associated
with the dialog (see Appendix A.1 of <xref
target="RFC6230"/>). The attribute is
optional. There is no default value.</t>


</list>
</t>

<t>The &lt;dialogaudit> element has the following child element:

<list style="hanging">

<t hangText="&lt;codecs>">element describing codecs used in the
dialog. See <xref target="defn.codecs"/>. The element is optional.</t>

</list>
</t>


<t>For example, a fragment describing a started dialog that is using
PCMU and telephony-event audio codecs:

<figure><artwork><![CDATA[
<dialogaudit dialogid="1234" state="started" conferenceid="conf1">
 <codecs> 
  <codec name="audio">
   <subtype>PCMU</subtype>
  </codec>
  <codec name="audio">
   <subtype>telephone-event</subtype>
  </codec>
 </codecs>
</dialogaudit>
]]></artwork></figure>
</t>

</section>

</section>

</section>



</section> <!-- end audit -->



 <section anchor="defn.statuscodes" title="Response Status Codes">

<t>This section describes the response codes in <xref
target="defn.table.statuscodes"/> for the status attribute of dialog
management &lt;response> (<xref target="defn.response"/>) and audit
&lt;auditresponse> (<xref target="defn.auditresponse"/>) responses. The
MS MUST support the status response codes defined here. All other valid
but undefined values are reserved for future use, where new status codes
are assigned using the Standards Action process defined in <xref
target="RFC5226"/>. The AS MUST treat any responses it does not
recognize as being equivalent to the x00 response code for all
classes. For example, if an AS receives an unrecognized response code of
499, it can safely assume that there was something wrong with its
request and treat the response as if it had received a 400 (Syntax
error) response code. </t>

<t>4xx responses are definite failure responses from a particular MS.
The reason attribute in the response SHOULD identify the failure in more
detail, for example, "Mandatory attribute missing: src in media element"
for a 400 (Syntax error) response code.
</t>

<t>The AS SHOULD NOT retry the same request without modification (for
example, correcting a syntax error or changing the connectionid to use
one available on the MS).  However, the same request to a different MS
might be successful, for example, if another MS supports a capability
required in the request.
</t>

<t>4xx failure responses can be grouped into three classes: failure due
to a syntax error in the request (400); failure due to an error
executing the request on the MS (405-419); and failure due to the
request requiring a capability not supported by the MS (420-439).
</t>

<t>In cases where more than one request code could be reported for a
failure, the MS SHOULD use the most specific error code of the failure
class for the detected error. For example, if the MS detects that the
dialogid in the request is invalid, then it uses a 406 status code.
However, if the MS merely detects that an execution error occurred, then
419 is used.
</t>

<texttable anchor="defn.table.statuscodes"  title="Status Codes" >
  <ttcol align="left" width="10%">Code</ttcol>
  <ttcol align="left" width="15%">Summary</ttcol>
  <ttcol align="left" width="40%">Description</ttcol>
  <ttcol align="left" width="35%">Informational: AS Possible Recovery
  Action</ttcol>

   <c>200</c>
   <c>OK</c>
   <c>request has succeeded.</c>
   <c></c>

   <c>400</c>
   <c>Syntax error</c>

   <c>request is syntactically invalid: it is not valid with respect to
   the XML schema specified in <xref target="schema"/> or it violates a
   co-occurrence constraint for a request element defined in <xref
   target="defn.elements"/>. </c>
   <c>Change the request so that it is syntactically valid.</c>

   <c>405</c>
   <c>dialogid already exists</c>

   <c>request uses a dialogid identifier for a new dialog that is
   already used by another dialog on the MS (see <xref
   target="defn.dialogmgt"/>).</c>

   <c>Send a request for a new dialog without specifying the dialogid
   and let the MS generate a unique dialogid in the response.</c>


   <c>406</c>
   <c>dialogid does not exist</c>

   <c>request uses a dialogid identifier for an dialog that does not
   exist on the MS (see <xref target="defn.dialogmgt"/>).</c>

   <c>Send an &lt;audit> request (<xref target="defn.audit"/>)
   requesting the list of dialog identifiers already used by the MS and
   then use one of the listed dialog identifiers.</c>


   <c>407</c>
   <c>connectionid does not exist</c>

   <c>request uses a connectionid identifier for a connection that does
   not exist on the MS. </c>
   <c>Use another method to determine which connections are available on
   the MS.</c>

   <c>408</c>
   <c>conferenceid does not exist</c>

   <c>request uses a conferenceid identifier for a conference that does
   not exist on the MS.</c>
   <c>Use another method to determine which conferences are available on
   the MS.</c>


   <c>409</c>
   <c>Resource cannot be retrieved</c>
   <c>request uses a URI to reference an external resource (e.g., dialog,
   media, or grammar) that cannot be retrieved within the timeout
   interval.</c>
   <c>Check that the resource URI is valid, can be reached from the MS,
   and that the appropriate authentication is used.</c>

   <c>410</c>
   <c>Dialog execution canceled</c>
   <c>request to prepare or start a dialog that has been terminated by
   a &lt;dialogterminate/> request (see <xref target="defn.dialogmgt"/>).
   </c>
   <c></c>

   <c>411</c>
   <c>Incompatible stream configuration</c>
   <c>request specifies a media stream configuration that is in
   conflict with itself, or the connection or conference capabilities
   (see <xref target="defn.dialogstart"/>).
   </c>
   <c>Change the media stream configuration to match the capabilities of
   the connection or conference. </c>

   <c>412</c>
   <c>Media stream not available </c>
   <c>request specifies an operation for which a media stream is not
   available. For example, playing a video media resource on an
   connection or conference without video streams.
   </c>
   <c>Check the media stream capability of the connection or conference
   and use an operation that only uses these capabilities.</c>

   <c>413</c>
   <c>Control keys with same value</c>
   <c>request contains a &lt;control> element (<xref
   target="defn.control"/>) where some keys have the same value.</c>
   <c>Use different keys for the different control operations.</c>


   <c>419</c>
   <c>Other execution error</c>
   <c>requested operation cannot be executed by the MS.</c>
   <c></c>


   <c>420</c>
   <c>Unsupported URI scheme</c>
   <c>request specifies a URI whose scheme is not supported by the
   MS.</c>
   <c>Use a URI scheme that is supported.</c>

   <c>421</c>
   <c>Unsupported dialog language</c>
   <c>request references an external dialog language not supported by the MS.</c>
   <c>Send an &lt;audit> request (<xref target="defn.audit"/>)
   requesting the MS capabilities and then use one of the listed
   dialog languages.
   </c>

   <c>422</c>
   <c>Unsupported playback format</c>
   <c>request references a media resource for playback whose format is
   not supported by the MS.</c>
   <c>Send an &lt;audit> request (<xref target="defn.audit"/>)
   requesting the MS capabilities and then use one of the listed
   playback media formats.</c>

   <c>423</c>
   <c>Unsupported record format</c>
   <c>request references a media resource for recording whose format is
   not supported by the MS.</c>
   <c>Send an &lt;audit> request (<xref target="defn.audit"/>)
   requesting the MS capabilities and then use one of the listed
   record media formats.</c>

   <c>424</c>
   <c>Unsupported grammar format</c>
   <c>request references a grammar whose format is not supported by the
   MS.</c>
   <c>Send an &lt;audit> request (<xref target="defn.audit"/>)
   requesting the MS capabilities and then use one of the listed grammar
   types.</c>

   <c>425</c>
   <c>Unsupported variable configuration</c>
   <c>request contains a prompt &lt;variable> element (<xref
   target="defn.variable"/>) not supported by the MS.</c>
   <c>Send an &lt;audit> request (<xref target="defn.audit"/>)
   requesting the MS capabilities and then use one of the listed
   variable types.</c>

   <c>426</c>
   <c>Unsupported DTMF configuration</c>
   <c>request contains a prompt &lt;dtmf> element (<xref
   target="defn.dtmf"/>) not supported by the MS.</c>
   <c></c>

   <c>427</c>
   <c>Unsupported parameter</c>
   <c>request contains a &lt;param> element (<xref
   target="defn.param"/>) not supported by the MS.</c>
   <c></c>

   <c>428</c>
   <c>Unsupported media stream configuration</c>
   <c>request contains a &lt;stream> element (<xref
   target="defn.stream"/>) whose configuration is not supported by the
   MS. </c>
   <c></c>

   <c>429</c>
   <c>Unsupported playback configuration</c>
   <c>request contains a &lt;prompt> element (<xref
   target="defn.prompt"/>) that the MS is unable to play on the
   available output media streams. </c>
   <c></c>

   <c>430</c>
   <c>Unsupported record configuration</c>
   <c>request contains a &lt;record> element (<xref
   target="defn.record"/>) that the MS is unable to record with on the
   available input media streams.</c>
   <c></c>

   <c>431</c>
   <c>Unsupported foreign namespace attribute or element</c>

   <c>request contains attributes or elements from another namespace
   that the MS does not support.</c>
   <c></c>


   <c>432</c>
   <c>Unsupported multiple dialog capability</c>
   <c>request tries to start another dialog on the same conference
   or connection where a dialog is already running.</c>
   <c></c>

   <c>433</c> 
   <c>Unsupported collect and record capability</c> 
   <c>request contains &lt;collect> and &lt;record> elements and the MS
   does support these operations simultaneously.</c>
   <c></c>

   <c>434</c>
   <c>Unsupported VAD capability</c>

   <c>request contains a &lt;record> element where Voice Activity
   Detection (VAD) is required, but the MS does not support VAD. </c>
   <c></c>


   <c>435</c>
   <c>Unsupported parallel playback</c> 
   <c>request contains a prompt &lt;par> element 
   whose configuration is not supported by the MS. </c>
   <c></c>

   <c>439</c>
   <c>Other unsupported capability</c>
   <c>request requires another capability not supported by the MS.</c>
   <c></c>

</texttable>

</section>

<section anchor="defn.types" title="Type Definitions">


<t>This section defines types referenced in attribute and element
definitions. </t>

    <section toc="include" anchor="defn.boolean" title="Boolean">

        <t>The value space of boolean is the set {true, false, 1, 0} as
        defined in Section 3.2.2 of <xref target="XMLSchema:Part2"/>.
        In accordance with this definition, the concept of false can be
        lexically represented by the strings "0" and "false" and the
        concept of true by the strings "1" and "true"; implementations
        MUST support both styles of lexical representation. </t>


      </section>


      <section toc="include" anchor="defn.dtmfchar" title="DTMFChar">

        <t>A DTMF character. The value space is the set
            {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, #, *, A, B, C, D}. 
        </t>
      </section>

      <section toc="include" anchor="defn.dtmfstring" title="DTMFString">

<t>A string composed of one or more <xref format="title"
target="defn.dtmfchar"/>s. </t>

      </section>


  <section toc="include" anchor="defn.nonneginteger" title="Non-Negative Integer">

        <t>The value space of non-negative integer is the infinite set
        {0,1,2,...} as defined in Section 3.3.20 of <xref
        target="XMLSchema:Part2"/>. </t>

<t>Implementation Note: It is RECOMMENDED that implementations at least
support a maximum value of a 32-bit integer (2,147,483,647). </t>

      </section>

      <section toc="include" anchor="defn.posinteger" title="Positive Integer">
        <t>The value space of positive integer is the infinite
        set {1,2,...} as defined in Section 3.3.25 of <xref
        target="XMLSchema:Part2"/>.</t>


<t>Implementation Note: It is RECOMMENDED that implementations at least
support a maximum value of a 32-bit integer (2,147,483,647). </t>

      </section>


      <section toc="include" anchor="defn.string" title="String">
        <t>A string in the character encoding associated with the XML
        element as defined in Section 3.2.1 of <xref
        target="XMLSchema:Part2"/>.
        </t>
      </section>


      <section toc="include" anchor="defn.timedesignation" title="Time Designation">

        <t>A time designation consists of a non-negative real number
        followed by a time unit identifier. </t>

        <t>The time unit identifiers are "ms" (milliseconds) and "s"
            (seconds). </t>

        <t>Examples include: "3s", "850ms", "0.7s", ".5s", and "+1.5s". </t>

      </section>

      <section toc="include" anchor="defn.percentage" title="Percentage">

        <t>A percentage consists of a positive integer followed by "%". </t>

        <t>Examples include: "100%", "500%", and "10%". </t>

      </section>




      <section toc="include" anchor="defn.uri" title="URI">
        <t>Uniform Resource Indicator as defined in <xref
        target="RFC3986"/>. 
        </t>
      </section>


      <section toc="include" anchor="defn.mimetype" title="MIME Media Type">

          <t>A string formatted as an IANA MIME media type <xref
          target="MIME.mediatypes"/>. The ABNF <xref
          target="RFC5234"/> production for the string is: 
<figure>
<artwork type="abnf"><![CDATA[
type = type-name "/" subtype-name *(";" parameter)

parameter = parameter-name "=" value
]]></artwork>
</figure>

          where "type-name" and "subtype-name" are defined in Section
          4.2 of <xref target="RFC4288"/>, "parameter-name" is defined
          in Section 4.3 of <xref target="RFC4288"/>, and "value" is
          defined in Section 5.1 of <xref target="RFC2045"/>.

          </t>

      </section>


      <section toc="include" anchor="defn.langid" title="Language Identifier">

          <t>A language identifier labels information content as being
          of a particular human language variant. Following the XML
          specification for language identification <xref
          target="XML"/>, a legal language identifier is identified by a
          <xref target="RFC5646"/> code and matched according
          to <xref target="RFC4647"/>.
          </t>

      </section>

      <section toc="include" anchor="defn.dateTime" title="DateTime">

        <t>A string formatted according to the XML schema definition of a
        dateTime type <xref target="XMLSchema:Part2"/>.
        </t>

      </section>





    </section>

</section>


<section anchor="schema" title="Formal Syntax">

<t>This section defines the XML schema for IVR Control Package. The
schema is normative.</t>

<t>The schema defines datatypes, attributes, dialog management, and IVR
dialog elements in the urn:ietf:params:xml:ns:msc-ivr namespace. In most
elements the order of child elements is significant. The schema is
extensible: elements allow attributes and child elements from other
namespaces.  Elements from outside this package's namespace can occur
after elements defined in this package.
</t>

<t>
The schema is dependent upon the schema (framework.xsd) defined in
Appendix A.1 of the Control Framework <xref
target="RFC6230"/>. It is also
dependent upon the W3C (xml.xsd) schema for definitions of XML
attributes (e.g., xml:base).
</t>

<figure>
<artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema targetNamespace="urn:ietf:params:xml:ns:msc-ivr"
 elementFormDefault="qualified" blockDefault="#all"
 xmlns="urn:ietf:params:xml:ns:msc-ivr"
 xmlns:fw="urn:ietf:params:xml:ns:control:framework-attributes"
 xmlns:xsd="http://www.w3.org/2001/XMLSchema">

 <xsd:annotation>
  <xsd:documentation>
   IETF MediaCtrl IVR 1.0 (20110104)

   This is the schema of the IETF MediaCtrl IVR Control
   Package.

   The schema namespace is urn:ietf:params:xml:ns:msc-ivr
    
  </xsd:documentation>
 </xsd:annotation>


 <!-- 
  #############################################################
  
  SCHEMA IMPORTS 
  
  ############################################################# 
 -->

 <xsd:import namespace="http://www.w3.org/XML/1998/namespace"
  schemaLocation="http://www.w3.org/2001/xml.xsd">
  <xsd:annotation>
   <xsd:documentation>
    This import brings in the XML attributes for
    xml:base, xml:lang, etc
    
    See http://www.w3.org/2001/xml.xsd for latest version    
   </xsd:documentation>
  </xsd:annotation>
 </xsd:import>

 <xsd:import
  namespace="urn:ietf:params:xml:ns:control:framework-attributes"
  schemaLocation="framework.xsd">
  <xsd:annotation>
   <xsd:documentation>
    This import brings in the framework attributes for
    conferenceid and connectionid.
   </xsd:documentation>
  </xsd:annotation>
 </xsd:import>


 <!-- 
  #####################################################
  
  Extensible core type 
  
  #####################################################
 -->


 <xsd:complexType name="Tcore">
  <xsd:annotation>
   <xsd:documentation>
    This type is extended by other (non-mixed) component types to
    allow attributes from other namespaces.
   </xsd:documentation>
  </xsd:annotation>
  <xsd:sequence/>
  <xsd:anyAttribute namespace="##other" processContents="lax" />
 </xsd:complexType>


 <!-- 
  #####################################################
  
  TOP LEVEL ELEMENT: mscivr 
  
  #####################################################
 -->

 <xsd:complexType name="mscivrType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:choice>
      <xsd:element ref="dialogprepare" />
      <xsd:element ref="dialogstart" />
      <xsd:element ref="dialogterminate" />
      <xsd:element ref="response" />
      <xsd:element ref="event" />
      <xsd:element ref="audit" />
      <xsd:element ref="auditresponse" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
     </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="version" type="version.datatype"
     use="required" />
    <xsd:attribute name="desclang" type="xsd:language"
     default="i-default" />     
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="mscivr" type="mscivrType" />


 <!-- 
  #####################################################
  
  DIALOG MANAGEMENT TYPES 
  
  #####################################################
 -->

 <!--  dialogprepare -->

 <xsd:complexType name="dialogprepareType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="dialog" minOccurs="0"
      maxOccurs="1" />
     <xsd:element ref="params" minOccurs="0"
      maxOccurs="1" />      
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="src" type="xsd:anyURI" />
    <xsd:attribute name="type" type="mime.datatype"/>
    <xsd:attribute name="maxage" type="xsd:nonNegativeInteger"/>    
    <xsd:attribute name="maxstale" type="xsd:nonNegativeInteger"/>        
    <xsd:attribute name="fetchtimeout"
     type="timedesignation.datatype" default="30s" />
    <xsd:attribute name="dialogid"
     type="dialogid.datatype" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="dialogprepare" type="dialogprepareType" />

 <!--  dialogstart -->

 <xsd:complexType name="dialogstartType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="dialog" minOccurs="0"
      maxOccurs="1" />
     <xsd:element ref="subscribe" minOccurs="0"
      maxOccurs="1" />
     <xsd:element ref="params" minOccurs="0"
      maxOccurs="1" />
     <xsd:element ref="stream" minOccurs="0"
      maxOccurs="unbounded" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="src" type="xsd:anyURI" />
    <xsd:attribute name="type" type="mime.datatype"/>
    <xsd:attribute name="maxage" type="xsd:nonNegativeInteger"/>    
    <xsd:attribute name="maxstale" type="xsd:nonNegativeInteger"/>    
    <xsd:attribute name="fetchtimeout"
     type="timedesignation.datatype" default="30s" />
    <xsd:attribute name="dialogid"
     type="dialogid.datatype" />
    <xsd:attribute name="prepareddialogid"
     type="dialogid.datatype" />
    <xsd:attributeGroup ref="fw:framework-attributes" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="dialogstart" type="dialogstartType" />

 <!--  dialogterminate -->

 <xsd:complexType name="dialogterminateType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
   <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>   
    <xsd:attribute name="dialogid"
     type="dialogid.datatype" use="required" />
    <xsd:attribute name="immediate"
     type="xsd:boolean" default="false" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="dialogterminate" type="dialogterminateType" />

 <!--  response -->

 <xsd:complexType name="responseType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>  
    <xsd:attribute name="status" type="status.datatype"
     use="required" />
    <xsd:attribute name="reason" type="xsd:string" />
    <xsd:attribute name="desclang" type="xsd:language"/>    
    <xsd:attribute name="dialogid"
     type="dialogid.datatype" use="required" />
    <xsd:attributeGroup ref="fw:framework-attributes" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="response" type="responseType" />

 <!--  event -->

 <xsd:complexType name="eventType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:choice>
      <xsd:element ref="dialogexit" minOccurs="0"
       maxOccurs="1" />
      <xsd:element ref="dtmfnotify" minOccurs="0"
       maxOccurs="1" />
      <xsd:any namespace="##other" minOccurs="0"
       maxOccurs="unbounded" processContents="lax" />
     </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="dialogid"
     type="dialogid.datatype" use="required" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="event" type="eventType" />

 <!--  dialogexit-->

 <xsd:complexType name="dialogexitType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="promptinfo" minOccurs="0"
      maxOccurs="1" />
     <xsd:element ref="controlinfo" minOccurs="0"
      maxOccurs="1" />
     <xsd:element ref="collectinfo" minOccurs="0"
      maxOccurs="1" />
     <xsd:element ref="recordinfo" minOccurs="0"
      maxOccurs="1" />
     <xsd:element ref="params" minOccurs="0"
      maxOccurs="1" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="status"
     type="xsd:nonNegativeInteger" use="required" />
    <xsd:attribute name="reason" type="xsd:string" />
    <xsd:attribute name="desclang" type="xsd:language"/>     
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="dialogexit" type="dialogexitType" />


 <!--  dtmfnotify-->

 <xsd:complexType name="dtmfnotifyType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
   <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>     
    <xsd:attribute name="matchmode"
     type="matchmode.datatype" default="all" />
    <xsd:attribute name="dtmf" type="dtmfstring.datatype"
     use="required" />
    <xsd:attribute name="timestamp" type="xsd:dateTime"
     use="required" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="dtmfnotify" type="dtmfnotifyType" />


 <!-- promptinfo -->

 <xsd:complexType name="promptinfoType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>     
    <xsd:attribute name="duration"
     type="xsd:nonNegativeInteger" />
    <xsd:attribute name="termmode"
     type="prompt_termmode.datatype" use="required" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="promptinfo" type="promptinfoType" />



 <!-- controlinfo -->

 <xsd:complexType name="controlinfoType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="controlmatch" minOccurs="0"
      maxOccurs="unbounded" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="controlinfo" type="controlinfoType" />


 <!-- controlmatch -->

 <xsd:complexType name="controlmatchType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>     
    <xsd:attribute name="dtmf"
     type="dtmfstring.datatype" />
    <xsd:attribute name="timestamp" type="xsd:dateTime" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="controlmatch" type="controlmatchType" />


 <!--  collectinfo -->

 <xsd:complexType name="collectinfoType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>     
    <xsd:attribute name="dtmf"
     type="dtmfstring.datatype" />
    <xsd:attribute name="termmode"
     type="collect_termmode.datatype" use="required" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="collectinfo" type="collectinfoType" />


 <!-- recordinfo -->

 <xsd:complexType name="recordinfoType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="mediainfo" minOccurs="0"
      maxOccurs="unbounded" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>      
    <xsd:attribute name="duration"
     type="xsd:nonNegativeInteger" />
    <xsd:attribute name="termmode"
     type="record_termmode.datatype" use="required" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="recordinfo" type="recordinfoType" />

 <!--  mediainfo -->

 <xsd:complexType name="mediainfoType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>     
    <xsd:attribute name="loc" type="xsd:anyURI"
     use="required" />
    <xsd:attribute name="type" type="mime.datatype" 
    use="required"/>
    <xsd:attribute name="size"
     type="xsd:nonNegativeInteger" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="mediainfo" type="mediainfoType" />


 <!--  subscribe -->

 <xsd:complexType name="subscribeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="dtmfsub" minOccurs="0"
      maxOccurs="unbounded" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="subscribe" type="subscribeType" />


 <!--  dtmfsub -->

 <xsd:complexType name="dtmfsubType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>     
    <xsd:attribute name="matchmode"
     type="matchmode.datatype" default="all" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="dtmfsub" type="dtmfsubType" />


 <!-- params -->
 <xsd:complexType name="paramsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="param" minOccurs="0"
      maxOccurs="unbounded" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="params" type="paramsType" />


 <!--  param -->
 <!--  doesn't extend tCore since its content model is mixed -->
 <xsd:complexType name="paramType" mixed="true">
  <xsd:sequence/>
  <xsd:attribute name="name" type="xsd:string" use="required" />
  <xsd:attribute name="type" type="mime.datatype" default="text/plain"/>
     <xsd:attribute name="encoding" type="xsd:string"/>
  <xsd:anyAttribute namespace="##other" processContents="lax" />
 </xsd:complexType>

 <xsd:element name="param" type="paramType" />

 <!--  stream -->

 <xsd:complexType name="streamType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="region" minOccurs="0"
      maxOccurs="1" />
    <xsd:element ref="priority" minOccurs="0"
      maxOccurs="1" />      
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>   
    <xsd:attribute name="media" type="media.datatype"
     use="required" />
    <xsd:attribute name="label" type="label.datatype" />
    <xsd:attribute name="direction"
     type="direction.datatype" default="sendrecv" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="stream" type="streamType" />

<!--  region  -->
<xsd:simpleType name="regionType">
 <xsd:restriction base="xsd:NMTOKEN"/>
</xsd:simpleType>

 <xsd:element name="region" type="regionType" />


 <!--  priority  -->
 <xsd:simpleType name="priorityType">
  <xsd:restriction base="xsd:positiveInteger" />
 </xsd:simpleType>

 <xsd:element name="priority" type="priorityType" />


<!-- dialog -->

 <xsd:complexType name="dialogType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="prompt" minOccurs="0"
      maxOccurs="1" />
     <xsd:element ref="control" minOccurs="0"
      maxOccurs="1" />
     <xsd:element ref="collect" minOccurs="0"
      maxOccurs="1" />
     <xsd:element ref="record" minOccurs="0"
      maxOccurs="1" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="repeatCount"
     type="xsd:nonNegativeInteger" default="1" />
    <xsd:attribute name="repeatDur"
     type="timedesignation.datatype" />
    <xsd:attribute name="repeatUntilComplete"
     type="xsd:boolean" default="false"/>     
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="dialog" type="dialogType" />


 <!--  prompt  -->

 <xsd:complexType name="promptType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:choice minOccurs="1" maxOccurs="unbounded">
     <xsd:element ref="media" />
     <xsd:element ref="variable" />
     <xsd:element ref="dtmf" />
     <xsd:element ref="par" />     
     <xsd:any namespace="##other"
      processContents="lax" />
    </xsd:choice>
    <xsd:attribute ref="xml:base" />
    <xsd:attribute name="bargein" type="xsd:boolean"
     default="true" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="prompt" type="promptType" />


 <!--  media -->

 <xsd:complexType name="mediaType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>     
    <xsd:attribute name="loc" type="xsd:anyURI"
     use="required" />
    <xsd:attribute name="type" type="mime.datatype" />
    <xsd:attribute name="fetchtimeout"
     type="timedesignation.datatype" default="30s" />
    <xsd:attribute name="soundLevel"
     type="percentage.datatype" default="100%" />
    <xsd:attribute name="clipBegin"
     type="timedesignation.datatype" default="0s" />
     <xsd:attribute name="clipEnd"
     type="timedesignation.datatype"/>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="media" type="mediaType" />

 <!--  variable -->

 <xsd:complexType name="variableT">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>     
    <xsd:attribute name="value" type="xsd:string"
     use="required" />
    <xsd:attribute name="type" type="xsd:string"
     use="required" />
    <xsd:attribute name="format" type="xsd:string" />
    <xsd:attribute name="gender" type="gender.datatype" />
    <xsd:attribute ref="xml:lang" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="variable" type="variableT" />

 <!-- dtmf -->

 <xsd:complexType name="dtmfType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>     
    <xsd:attribute name="digits"
     type="dtmfstring.datatype" use="required" />
    <xsd:attribute name="level" type="xsd:integer"
     default="-6" />
    <xsd:attribute name="duration"
     type="timedesignation.datatype" default="100ms" />
    <xsd:attribute name="interval"
     type="timedesignation.datatype" default="100ms" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="dtmf" type="dtmfType" />


 <!--  par  -->

 <xsd:complexType name="parType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:choice minOccurs="1" maxOccurs="unbounded">
     <xsd:element ref="media" />
     <xsd:element ref="variable" />
     <xsd:element ref="dtmf" />
           <xsd:element ref="seq" />     
     <xsd:any namespace="##other"
      processContents="lax" />
    </xsd:choice>
    <xsd:attribute name="endsync" type="endsync.datatype"
    default="last"/>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="par" type="parType" />

 <!--  seq  -->

 <xsd:complexType name="seqType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:choice minOccurs="1" maxOccurs="unbounded">
     <xsd:element ref="media" />
     <xsd:element ref="variable" />
     <xsd:element ref="dtmf" />
     <xsd:any namespace="##other"
      processContents="lax" />
    </xsd:choice>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="seq" type="seqType" />

 <!-- control -->

 <xsd:complexType name="controlType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>     
    <xsd:attribute name="skipinterval"
     type="timedesignation.datatype" default="6s" />
    <xsd:attribute name="ffkey" type="dtmfchar.datatype" />
    <xsd:attribute name="rwkey" type="dtmfchar.datatype" />
    <xsd:attribute name="pauseinterval"
     type="timedesignation.datatype" default="10s" />
    <xsd:attribute name="pausekey"
     type="dtmfchar.datatype" />
    <xsd:attribute name="resumekey"
     type="dtmfchar.datatype" />
    <xsd:attribute name="volumeinterval"
     type="percentage.datatype" default="10%" />
    <xsd:attribute name="volupkey"
     type="dtmfchar.datatype" />
    <xsd:attribute name="voldnkey"
     type="dtmfchar.datatype" />
    <xsd:attribute name="speedinterval"
     type="percentage.datatype" default="10%" />
    <xsd:attribute name="speedupkey"
     type="dtmfchar.datatype" />
    <xsd:attribute name="speeddnkey"
     type="dtmfchar.datatype" />
    <xsd:attribute name="gotostartkey"
     type="dtmfchar.datatype" />
    <xsd:attribute name="gotoendkey"
     type="dtmfchar.datatype" />
    <xsd:attribute name="external"
     type="dtmfstring.datatype" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="control" type="controlType" />


 <!-- collect -->

 <xsd:complexType name="collectType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="grammar" minOccurs="0"
      maxOccurs="1" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="cleardigitbuffer"
     type="xsd:boolean" default="true" />
    <xsd:attribute name="timeout"
     type="timedesignation.datatype" default="5s" />
    <xsd:attribute name="interdigittimeout"
     type="timedesignation.datatype" default="2s" />
    <xsd:attribute name="termtimeout"
     type="timedesignation.datatype" default="0s" />
    <xsd:attribute name="escapekey"
     type="dtmfchar.datatype" />
    <xsd:attribute name="termchar"
     type="dtmfchar.datatype" default="#" />
    <xsd:attribute name="maxdigits"
     type="xsd:positiveInteger" default="5" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="collect" type="collectType" />

 <!--  grammar -->
 <!--  doesn't extend tCore since its content model is mixed -->
 <xsd:complexType name="grammarType" mixed="true">
  <xsd:sequence>
   <xsd:any namespace="##other" minOccurs="0"
    maxOccurs="unbounded" processContents="lax" />
  </xsd:sequence>
  <xsd:attribute name="src" type="xsd:anyURI" />
  <xsd:attribute name="type" type="mime.datatype" />
  <xsd:attribute name="fetchtimeout"
   type="timedesignation.datatype" default="30s" />
  <xsd:anyAttribute namespace="##other" processContents="lax" />
 </xsd:complexType>

 <xsd:element name="grammar" type="grammarType" />

 <!-- record -->

 <xsd:complexType name="recordType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
   <xsd:sequence>
     <xsd:element ref="media" minOccurs="0"
      maxOccurs="unbounded" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>   
    <xsd:attribute name="timeout"
     type="timedesignation.datatype" default="5s" />
    <xsd:attribute name="beep" type="xsd:boolean"
     default="false" />
    <xsd:attribute name="vadinitial"
     type="xsd:boolean" default="false" />
    <xsd:attribute name="vadfinal"
     type="xsd:boolean" default="false" />
    <xsd:attribute name="dtmfterm"
     type="xsd:boolean" default="true" />
    <xsd:attribute name="maxtime"
     type="timedesignation.datatype" default="15s" />
    <xsd:attribute name="finalsilence"
     type="timedesignation.datatype" default="5s" />
    <xsd:attribute name="append" type="xsd:boolean"
     default="false" />     
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="record" type="recordType" />

 <!-- 
  #####################################################
  
  AUDIT TYPES 
  
  #####################################################
 -->


 <!-- audit -->

 <xsd:complexType name="auditType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
 <xsd:sequence>
    <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>     
   <xsd:attribute name="capabilities"
     type="xsd:boolean" default="true" />
   <xsd:attribute name="dialogs"
     type="xsd:boolean" default="true" />     
      <xsd:attribute name="dialogid"
     type="dialogid.datatype"/>     
   </xsd:extension>  
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="audit" type="auditType" />

 <!-- auditresponse -->

 <xsd:complexType name="auditresponseType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="capabilities" minOccurs="0"
      maxOccurs="1" />
     <xsd:element ref="dialogs" minOccurs="0"
      maxOccurs="1" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="status" type="status.datatype"
     use="required" />
    <xsd:attribute name="reason" type="xsd:string" />
    <xsd:attribute name="desclang" type="xsd:language"/>        
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="auditresponse" type="auditresponseType" />

 <!-- codec -->

 <xsd:complexType name="codecType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="subtype" minOccurs="1"
      maxOccurs="1" />
     <xsd:element ref="params" minOccurs="0"
      maxOccurs="1" />      
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
      <xsd:attribute name="name" type="xsd:string"
     use="required" />    
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="codec" type="codecType" />

 <!-- subtype -->

 <xsd:simpleType name="subtypeType">
  <xsd:restriction base="xsd:string" />
 </xsd:simpleType>

 <xsd:element name="subtype" type="subtypeType" />

 
 <!-- codecs -->

 <xsd:complexType name="codecsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="codec" minOccurs="0"
      maxOccurs="unbounded" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="codecs" type="codecsType" /> 


 <!-- capabilities -->

 <xsd:complexType name="capabilitiesType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="dialoglanguages" minOccurs="1"
      maxOccurs="1" />
     <xsd:element ref="grammartypes" minOccurs="1"
      maxOccurs="1" />
     <xsd:element ref="recordtypes" minOccurs="1"
      maxOccurs="1" />
     <xsd:element ref="prompttypes" minOccurs="1"
      maxOccurs="1" />
     <xsd:element ref="variables" minOccurs="1"
      maxOccurs="1" />
      <xsd:element ref="maxpreparedduration" minOccurs="1"
      maxOccurs="1" />
      <xsd:element ref="maxrecordduration" minOccurs="1"
      maxOccurs="1" />      
     <xsd:element ref="codecs" minOccurs="1"
      maxOccurs="1" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="capabilities" type="capabilitiesType" />


 <!-- mimetype -->

 <xsd:element name="mimetype" type="mime.datatype" />


 <!-- dialoglanguages -->

 <xsd:complexType name="dialoglanguagesType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="mimetype" minOccurs="0"
      maxOccurs="unbounded" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="dialoglanguages" type="dialoglanguagesType" />

 <!-- grammartypes -->

 <xsd:complexType name="grammartypesType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="mimetype" minOccurs="0"
      maxOccurs="unbounded" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="grammartypes" type="grammartypesType" />
 

 <!-- recordtypes -->

 <xsd:complexType name="recordtypesType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="mimetype" minOccurs="0"
      maxOccurs="unbounded" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="recordtypes" type="recordtypesType" />


    <!-- prompttypes -->

 <xsd:complexType name="prompttypesType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="mimetype" minOccurs="0"
      maxOccurs="unbounded" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="prompttypes" type="prompttypesType" />

<!--  variables -->

 <xsd:complexType name="variablesType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="variabletype" minOccurs="0"
      maxOccurs="unbounded" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="variables" type="variablesType" />


 <xsd:complexType name="variabletypeType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="format" minOccurs="0"
      maxOccurs="unbounded" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="type" type="xsd:string" use="required" />
    <xsd:attribute name="desc" type="xsd:string"/>
    <xsd:attribute name="desclang" type="xsd:language"/>        
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="variabletype" type="variabletypeType" />

<!--  format  -->
<!--  doesn't extend tCore since its content model is mixed -->
 <xsd:complexType name="formatType" mixed="true">
  <xsd:sequence>
   <xsd:any namespace="##other" minOccurs="0"
    maxOccurs="unbounded" processContents="lax" />
  </xsd:sequence>
  <xsd:attribute name="desc" type="xsd:string" />
  <xsd:attribute name="desclang" type="xsd:language"/>      
  <xsd:anyAttribute namespace="##other" processContents="lax" />
 </xsd:complexType>

 <xsd:element name="format" type="formatType" />

<!--  maxpreparedduration -->

 <xsd:element name="maxpreparedduration" 
type="timedesignation.datatype"/>

      
<!--  maxrecordduration -->      
      
 <xsd:element name="maxrecordduration" 
type="timedesignation.datatype"/>      


 <!-- dialogs -->

 <xsd:complexType name="dialogsType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="dialogaudit" minOccurs="0"
      maxOccurs="unbounded" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="dialogs" type="dialogsType" />


 <!-- dialogaudit -->

 <xsd:complexType name="dialogauditType">
  <xsd:complexContent>
   <xsd:extension base="Tcore">
    <xsd:sequence>
     <xsd:element ref="codecs" minOccurs="0"
      maxOccurs="1" />
     <xsd:any namespace="##other" minOccurs="0"
      maxOccurs="unbounded" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="dialogid"
     type="dialogid.datatype" use="required" />
    <xsd:attribute name="state" type="state.datatype"
     use="required" />
    <xsd:attributeGroup ref="fw:framework-attributes" />
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="dialogaudit" type="dialogauditType" />


 <!-- 
  ####################################################
  
  DATATYPES 
  
  ####################################################
 -->


 <xsd:simpleType name="version.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="1.0" />
  </xsd:restriction>
 </xsd:simpleType>
 <xsd:simpleType name="mime.datatype">
  <xsd:restriction base="xsd:string" />
 </xsd:simpleType>
 <xsd:simpleType name="dialogid.datatype">
  <xsd:restriction base="xsd:string" />
 </xsd:simpleType>
 <xsd:simpleType name="gender.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="female" />
   <xsd:enumeration value="male" />
  </xsd:restriction>
 </xsd:simpleType>
 <xsd:simpleType name="state.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="preparing" />
   <xsd:enumeration value="prepared" />
   <xsd:enumeration value="starting" />
   <xsd:enumeration value="started" />
  </xsd:restriction>
 </xsd:simpleType>
 <xsd:simpleType name="status.datatype">
  <xsd:restriction base="xsd:positiveInteger">
   <xsd:pattern value="[0-9][0-9][0-9]" />
  </xsd:restriction>
 </xsd:simpleType>
 <xsd:simpleType name="media.datatype">
  <xsd:restriction base="xsd:string" />
 </xsd:simpleType>
 <xsd:simpleType name="label.datatype">
  <xsd:restriction base="xsd:string" />
 </xsd:simpleType>
 <xsd:simpleType name="direction.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="sendrecv" />
   <xsd:enumeration value="sendonly" />
   <xsd:enumeration value="recvonly" />
   <xsd:enumeration value="inactive" />
  </xsd:restriction>
 </xsd:simpleType>
 <xsd:simpleType name="timedesignation.datatype">
  <xsd:annotation>
   <xsd:documentation>
    Time designation following Time in CSS2
   </xsd:documentation>
  </xsd:annotation>
  <xsd:restriction base="xsd:string">
   <xsd:pattern value="(\+)?([0-9]*\.)?[0-9]+(ms|s)" />
  </xsd:restriction>
 </xsd:simpleType>
 <xsd:simpleType name="dtmfchar.datatype">
  <xsd:annotation>
   <xsd:documentation>
    DTMF character [0-9#*A-D]
   </xsd:documentation>
  </xsd:annotation>
  <xsd:restriction base="xsd:string">
   <xsd:pattern value="[0-9#*A-D]" />
  </xsd:restriction>
 </xsd:simpleType>
 <xsd:simpleType name="dtmfstring.datatype">
  <xsd:annotation>
   <xsd:documentation>
    DTMF sequence [0-9#*A-D]
   </xsd:documentation>
  </xsd:annotation>
  <xsd:restriction base="xsd:string">
   <xsd:pattern value="([0-9#*A-D])+" />
  </xsd:restriction>
 </xsd:simpleType>
 <xsd:simpleType name="percentage.datatype">
  <xsd:annotation>
   <xsd:documentation>
    whole integer followed by '%'
   </xsd:documentation>
  </xsd:annotation>
  <xsd:restriction base="xsd:string">
   <xsd:pattern value="([0-9])+%" />
  </xsd:restriction>
 </xsd:simpleType>

 <xsd:simpleType name="prompt_termmode.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="completed" />
   <xsd:enumeration value="bargein" />
   <xsd:enumeration value="stopped" />
  </xsd:restriction>
 </xsd:simpleType>

 <xsd:simpleType name="collect_termmode.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="match" />
   <xsd:enumeration value="noinput" />
   <xsd:enumeration value="nomatch" />
   <xsd:enumeration value="stopped" />
  </xsd:restriction>
 </xsd:simpleType>

 <xsd:simpleType name="record_termmode.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="noinput" />
   <xsd:enumeration value="dtmf" />
   <xsd:enumeration value="maxtime" />
   <xsd:enumeration value="finalsilence" />
   <xsd:enumeration value="stopped" />
  </xsd:restriction>
 </xsd:simpleType>

 <xsd:simpleType name="matchmode.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="all" />
   <xsd:enumeration value="collect" />
   <xsd:enumeration value="control" />
  </xsd:restriction>
 </xsd:simpleType>
 
 <xsd:simpleType name="endsync.datatype">
  <xsd:restriction base="xsd:NMTOKEN">
   <xsd:enumeration value="first" />
   <xsd:enumeration value="last" />
  </xsd:restriction>
 </xsd:simpleType> 

</xsd:schema>
]]></artwork>
</figure>



</section> <!-- Formal Syntax: XML Schema  -->

<section anchor="examples" title="Examples">

<t>This section provides examples of the IVR Control Package. </t>


<section anchor="examples.protocol" title="AS-MS Dialog Interaction Examples">

<t>The following example assume a Control Channel has been established
and synced as described in the Media Control Channel Framework <xref
target="RFC6230"/>. </t>

<t>The XML messages are in angled brackets (with the root &lt;mscivr>
omitted); the REPORT status is in round brackets. Other aspects of the
protocol are omitted for readability.
</t>

<section title="Starting an IVR Dialog">

<t>An IVR dialog is started successfully, and dialogexit notification
    &lt;event> is sent from the MS to the AS when the dialog exits
    normally.  </t>

<figure>
<artwork><![CDATA[
          Application Server (AS)                   Media Server (MS)
             |                                             |
             |       (1) CONTROL: <dialogstart>            |
             |  ---------------------------------------->  |
             |                                             |
             |       (2) 202                               |
             |  <---------------------------------------   |
             |                                             |
             |                                             |
             |       (3) REPORT: <response status="200"/>  |
             |                   (terminate)               |
             |  <----------------------------------------  |
             |                                             |
             |       (4) 200                               |
             |  ---------------------------------------->  |
             |                                             |
             |       (5) CONTROL: <event ... />            |
             |                                             |
             |  <----------------------------------------  |
             |                                             |
             |       (6) 200                               |
             |  ---------------------------------------->  |
             |                                             |
]]></artwork>
</figure>

</section>


<section title="IVR Dialog Fails to Start">

<t>An IVR dialog fails to start due to an unknown dialog language. The
&lt;response> is reported in a framework 200 message.
</t>

<figure>
<artwork><![CDATA[
          Application Server (AS)                   Media Server (MS)
             |                                             |
             |       (1) CONTROL: <dialogstart>            |
             |  ---------------------------------------->  |
             |                                             |
             |       (2) 200: <response status="421"/>     |
             |  <----------------------------------------  |
             |                                             |
]]></artwork>
</figure>

</section>


<section title="Preparing and Starting an IVR Dialog">

<t>An IVR dialog is prepared and started successfully, and then the
    dialog exits normally.  </t>

<figure>
<artwork><![CDATA[
          Application Server (AS)                   Media Server (MS)
             |                                             |
             |       (1) CONTROL: <dialogprepare>          |
             |  ---------------------------------------->  |
             |                                             |
             |       (2) 202                               |
             |  <---------------------------------------   |
             |                                             |
             |       (3) REPORT: <response status="200"/>  |
             |                   (terminate)               |
             |  <----------------------------------------  |
             |                                             |
             |       (4) 200                               |
             |  ---------------------------------------->  |
             |                                             |
             |       (5) CONTROL: <dialogstart>            |
             |  ---------------------------------------->  |
             |                                             |
             |       (6) 202                               |
             |  <---------------------------------------   |
             |                                             |
             |       (7) REPORT: <response status="200"/>  |
             |                   (terminate)               |
             |  <----------------------------------------  |
             |                                             |
             |       (8) 200                               |
             |  ---------------------------------------->  |
             |                                             |
             |       (9) CONTROL: <event .../>             |
             |  <----------------------------------------  |
             |                                             |
             |       (10) 200                              |
             |  ---------------------------------------->  |
             |                                             |
]]></artwork>
</figure>

</section>

<section title="Terminating a Dialog">

<t>An IVR dialog is started successfully, and then terminated by the
AS. The dialogexit event is sent to the AS when the dialog exits.
</t>

<figure>
<artwork><![CDATA[

          Application Server (AS)                   Media Server (MS)
             |                                             |
             |       (1) CONTROL: <dialogstart>            |
             |  ---------------------------------------->  |
             |                                             |
             |       (2) 202                               |
             |  <---------------------------------------   |
             |                                             |
             |       (3) REPORT: <response status="200"/>  |
             |                   (terminate)               |
             |  <----------------------------------------  |
             |                                             |
             |       (4) 200                               |
             |  ---------------------------------------->  |
             |                                             |
             |       (5) CONTROL: <dialogterminate>        |
             |  ---------------------------------------->  |
             |                                             |
             |       (6) 200: <response status="200"/>     |
             |  <----------------------------------------  |
             |                                             |
             |       (7) CONTROL: <event .../>             |
             |  <----------------------------------------  |
             |                                             |
             |       (8) 200                               |
             |  ---------------------------------------->  |
             |                                             |


]]></artwork>
</figure>

<t>Note that in (6) the &lt;response> payload to the
&lt;dialogterminate/> request is carried on a framework 200 response
since it could complete the requested operation before the transaction
timeout.
</t>

</section>


</section>


<section anchor="examples.templates" title="IVR Dialog Examples">

<t>The following examples show how &lt;dialog> is used with
&lt;dialogprepare>, &lt;dialogstart>, and &lt;event> elements to play
prompts, set runtime controls, collect DTMF input, and record user
input. </t>

<t>The examples do not specify all messages between the AS and MS. </t>

<section title="Playing Announcements">

<t>This example prepares an announcement composed of two prompts where
the dialog repeatCount is set to 2. </t>

<figure>
<artwork><![CDATA[
  
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
<dialogprepare>
   <dialog repeatCount="2">
    <prompt>
      <media loc="http://www.example.com/media/Number_09.wav"/>
      <media loc="http://www.example.com/media/Number_11.wav"/>
    </prompt>
   </dialog>
</dialogprepare>
</mscivr>
    
]]></artwork>
</figure>

<t>If the dialog is prepared successfully, a &lt;response> is returned
with status 200 and a dialog identifier assigned by the MS:</t>

<figure>
<artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">  
  <response status="200" dialogid="vxi78"/>
</mscivr>    
]]></artwork>
</figure>

<t>The prepared dialog is then started on a conference playing the
prompts twice:</t>

<figure>
<artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">    
 <dialogstart prepareddialogid="vxi78" conferenceid="conference11"/>
</mscivr>   
]]></artwork>
</figure>



<t>In the case of a successful dialog, the output is provided in
&lt;event&gt;; for example:</t>

<figure>
<artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">  
 <event dialogid="vxi78">
    <dialogexit status="1">
       <promptinfo termmode="completed" duration="24000"/>
    </dialogexit>
 </event>
</mscivr>
]]></artwork>
</figure>


</section>

<section title="Prompt and Collect">

<t>In this example, a prompt is played and then the MS waits for 30s for
a two digit sequence:</t>


<figure>
<artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">      
 <dialogstart connectionid="7HDY839:HJKSkyHS~HUwkuh7ns">
 <dialog>
  <prompt>
   <media loc="http://www.example.com/prompt1.wav"/>
  </prompt>
  <collect timeout="30s" maxdigits="2"/>
 </dialog>
 </dialogstart>
</mscivr>    
]]></artwork>
</figure>

<t>If no user input is collected within 30s, then the following notification
event would be returned:</t>

<figure>
<artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">      
 <event dialogid="vxi81">
    <dialogexit status="1" >
       <promptinfo termmode="completed" duration="4000"/>
       <collectinfo termmode="noinput"/>
    </dialogexit>
 </event>    
</mscivr>
]]></artwork>
</figure>


<t>The collect operation can be specified without a prompt. Here the MS
just waits for DTMF input from the user (the maxdigits attribute of
&lt;collect> defaults to 5):
</t>
        
<figure>
<artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">    
 <dialogstart connectionid="7HDY839:HJKSkyHS~HUwkuh7ns">
  <dialog>
   <collect/>
  </dialog>
 </dialogstart>
</mscivr>
]]></artwork>
</figure>
        

<t>If the dialog is successful, then dialogexit &lt;event&gt; contains
the dtmf collected in its result parameter: </t>

<figure>
<artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">      
 <event dialogid="vxi80">
    <dialogexit status="1">
       <collectinfo dtmf="12345" termmode="match"/>
    </dialogexit>
 </event>
</mscivr>
]]></artwork>
</figure>



<t>And finally, in this example, one of the input parameters is invalid:
</t>

<figure>
<artwork><![CDATA[
  
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">      
<dialogstart connectionid="7HDY839:HJKSkyHS~HUwkuh7ns">
 <dialog repeatCount="two">
   <prompt>
     <media loc="http://www.example.com/prompt1.wav"/>
   </prompt>
   <collect cleardigitbuffer="true"
   timeout="4s" interdigittimeout="2s"
   termtimeout="0s" maxdigits="2"/>              
 </dialog>
</dialogstart>
</mscivr>
    
]]></artwork>
</figure>

<t>The error is reported in the response:</t>

<figure>
<artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">        
 <response status="400" dialogid="vxi82" 
  reason="repeatCount attribute value invalid: two"/>
</mscivr>
]]></artwork>
        </figure>
 </section>

<section title="Prompt and Record">

<t>In this example, the user is prompted, then their input is recorded
for a maximum of 30 seconds.</t>


<figure>
<artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">        
<dialogstart connectionid="7HDY839:HJKSkyHS~HUwkuh7ns">
    <dialog>
      <prompt>
       <media loc="http://www.example.com/media/sayname.wav"/>
      </prompt>
      <record dtmfterm="false" maxtime="30s" beep="true"/>
    </dialog>
</dialogstart>
</mscivr>
]]></artwork>
</figure>

<t>If successful and the recording is terminated by DTMF, the following
is returned in a dialogexit &lt;event&gt;:</t>

<figure>
<artwork><![CDATA[
  
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">        
 <event dialogid="vxi83">
  <dialogexit status="1">
   <recordinfo termmode="dtmf">
    <mediainfo type="audio/x-wav" 
      loc="http://www.example.com/recording1.wav"/>
   </recordinfo>
  </dialogexit>
 </event>
</mscivr>    
]]></artwork>
</figure>

</section>

<section title="Runtime Controls">

<t>In this example, a prompt is played with the collect operation and
  runtime controls activated.

<figure>
<artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">      
 <dialogstart connectionid="7HDY839:HJKSkyHS~HUwkuh7ns">
 <dialog>
  <prompt bargein="true">
   <media loc="http://www.example.com/prompt1.wav"/>
  </prompt>
  <control ffkey="5" rwkey="6" speedupkey="3" 
           speeddnkey="4"/>
  <collect maxdigits="2"/>
 </dialog>
 </dialogstart>
</mscivr>    
]]></artwork>
</figure>
</t>

<t>Once the dialog is active, the user can press keys 3, 4, 5, and 6 to
execute runtime controls on the prompt queue. The keys do not cause
bargein to occur. If the user presses any other key, then the prompt is
interrupted and DTMF collect begins. Note that runtime controls are not
active during the collect operation. </t>

<t>When the dialog is completed successfully, then both control and
collect information is reported.

<figure>
<artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">      
 <event dialogid="vxi81">
    <dialogexit status="1">
       <promptinfo termmode="bargein"/>
       <controlinfo>
        <controlmatch dtmf="4" timestamp="2008-05-12T12:13:14Z"/>
        <controlmatch dtmf="3" timestamp="2008-05-12T12:13:15Z"/>
        <controlmatch dtmf="5" timestamp="2008-05-12T12:13:16Z"/>
       </controlinfo>
       <collectinfo termmode="match" dtmf="14"/>
    </dialogexit>
 </event>    
</mscivr>
]]></artwork>
</figure>
</t>

</section>

<section title="Subscriptions and Notifications">

<t>In this example, a looped dialog is started with subscription for
notifications each time the user input matches the collect grammar:

<figure>
<artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">      
 <dialogstart connectionid="7HDY839:HJKSkyHS">
  <dialog repeatCount="0">
   <collect maxdigits="2"/>
  </dialog>
  <subscribe>
   <dtmfsub matchmode="collect"/>
  </subscribe>
 </dialogstart>
</mscivr>    
]]></artwork>
</figure>
</t>

<t>Each time the user input the DTMF matching the grammar, the following
notification event would be sent:

<figure>
<artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">      
 <event dialogid="vxi81">
    <dtmfnotify matchmode="collect" dtmf="12" 
     timestamp="2008-05-12T12:13:14Z"/>
 </event>    
</mscivr>
]]></artwork>
</figure>
If no user input was provided, or the input did not match the grammar,
the dialog would continue to loop until terminated (or an error
occurred).
</t>


</section>


<section title="Dialog Repetition until DTMF Collection Complete">

<t> This example is a prompt and collect dialog to collect the PIN from
the user. The repeatUntilComplete attribute in the &lt;dialog> is set to
true in this case so that when the grammar collection is complete, the
MS automatically terminates the dialog repeat cycle and reports the
results in a &lt;dialogexit> event.
 
<figure>
<artwork><![CDATA[
   <mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
    <dialogstart connectionid="7HDY839:HJKSkyHS">
     <dialog repeatCount="3" repeatUntilComplete="true">
      <prompt bargein="true">
        <media loc="http://example.com/please_enter_your_pin.vox"/>
      </prompt>
      <collect maxdigits="4"/>
     </dialog>
    </dialogstart>
   </mscivr>
]]></artwork>
</figure>
</t> 

<t>If the user barges in on the prompt and &lt;collect> receives DTMF
input matching the grammar, the dialog cycle is considered complete and
the MS returns the following:
 
<figure>
<artwork><![CDATA[
   <mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
    <event dialogid="vxi81">
      <dialogexit status="1">
        <promptinfo duration="3654" termmode="bargein"/>
        <collectinfo dtmf="1234" termmode="match"/>
      </dialogexit>
    </event>
   </mscivr>
]]></artwork>
</figure>
</t> 

<t>If no user input was provided, or the input did not match the
grammar, the dialog would loop for a maximum of 3 times.
</t>


</section>

</section>

<section anchor="examples.otherdialoglanguages" title="Other Dialog Languages">

<t>The following example requests that a VoiceXML dialog is started:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <dialogstart dialogid="d2" 
              connectionid="7HDY839:HJKSkyHS"
              type="application/voicexml+xml" 
              src="http://www.example.com/mydialog.vxml"
              fetchtimeout="15s">
  <params>
   <param name="prompt1">nfs://nas01/media1.3gp</param>
   <param name="prompt2">nfs://nas01/media2.3gp</param>
  </params>
 </dialogstart>
</mscivr>
]]></artwork></figure>
</t>

<t>If the MS does not support this dialog language, then the response
would have the status code 421 (<xref
target="defn.statuscodes"/>). However, if it does support the VoiceXML
dialog language, it would respond with a 200 status, activate the
VoiceXML dialog, and make the &lt;params> available to the VoiceXML
script as described in <xref target="voicexml"/>.
</t>

<t>When the VoiceXML dialog exits, exit namelist parameters are
specified using &lt;params> in the dialogexit event:

<figure>
<artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">      
 <event dialogid="d2">
   <dialogexit status="1">
    <params>
     <param name="username">peter</param>
     <param name="pin">1234</param>
    </params>
   </dialogexit>
  </event>    
</mscivr>
]]></artwork>
</figure>
</t>

</section>


<section anchor="examples.foreignnamespaces" 
title="Foreign Namespace Attributes and Elements">

<t>An MS can support attributes and elements from foreign namespaces
within the &lt;mscivr> element. For example, the MS could support a
&lt;listen> element (in a foreign namespace) for speech recognition by
analogy to how &lt;collect> supports DTMF collection. </t>

<t>In the following example, a prompt and collect request is extended
with a &lt;listen> element:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr"
 xmlns:ex="http://www.example.com/mediactrl/extensions/1">
 <dialogstart connectionid="7HDY839:HJKSkyHS~HUwkuh7ns">
 <dialog>
  <prompt>
   <media loc="http://www.example.com/prompt1.wav"/>
  </prompt>
  <collect timeout="30s" maxdigits="4"/>
  <ex:listen maxtimeout="30s" >
    <ex:grammar src="http://example.org/pin.grxml"/>
  </ex:listen>
 </dialog>
 </dialogstart>
</mscivr>
]]></artwork></figure>
</t>

<t> In the &lt;mscivr> root element, the xmlns:ex attribute declares
that "ex" is associated with the foreign namespace URI
"http://www.example.com/mediactrl/extensions/1". The &lt;ex:listen>, its
attributes, and child elements are associated with this namespace. This
&lt;listen> could be defined so that it activates an SRGS grammar and
listens for user input matching the grammar in a similar manner to DTMF
collection. </t>

<t>If an MS receives this request but does not support the &lt;listen>
element, then it would send a 431 response:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">        
 <response status="431" dialogid="d560" 
  reason="unsupported foreign listen element"/>
</mscivr>
]]></artwork></figure>
</t>

<t>If the MS does support this foreign element, it would send a 200
response and start the dialog with speech recognition. When the dialog
exits, it provides information about the &lt;listen> execution within
&lt;dialogexit>, again using elements in a foreign namespace such as
&lt;listeninfo> below:

<figure>
<artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr"
 xmlns:ex="http://www.example.com/mediactrl/extensions/1">      
 <event dialogid="d560">
   <dialogexit status="1">
    <ex:listeninfo speech="1 2 3 4" termmode="match"/>
   </dialogexit>
  </event>    
</mscivr>
]]></artwork>
</figure>

Note that in reply the AS sends a Control Framework 200 response even
though the notification event contains an element in a foreign namespace
that it might not understand.
</t>

</section>



</section>
		


<section anchor="security" title="Security Considerations">
			

<t>As this Control Package processes XML markup, implementations MUST
address the security considerations of <xref target="RFC3023"/>.
  </t>

<t>Implementations of this Control Package MUST address security,
confidentiality, and integrity of messages transported over the Control
Channel as described in Section 12 of "Media Control Channel
Framework" <xref target="RFC6230"/>,
including Transport Level Protection, Control Channel Policy Management,
and Session Establishment. 

In addition, implementations MUST address security, confidentiality, and
integrity of User Agent sessions with the MS, both in terms of SIP
signaling and associated RTP media flow; see <xref
target="RFC6230"/> for further details
on this topic.

Finally, implementations MUST address security, confidentiality, and
integrity of sessions where, following a URI scheme, an MS uploads
recordings or retrieves documents and resources (e.g., fetching a grammar
document from a web server using HTTPS).

</t>

 
<t>Adequate transport protection and authentication are critical,
especially when the implementation is deployed in open networks.  If the
implementation fails to correctly address these issues, it risks
exposure to malicious attacks, including (but not limited to):

  <list style="hanging">

  <t hangText="Denial of Service:">An attacker could insert a request
  message into the transport stream causing specific dialogs on the MS
  to be terminated immediately. For example, &lt;dialogterminate
  dialogid="XXXX" immediate="true">, where the value of "XXXX" could be
  guessed or discovered by auditing active dialogs on the MS using an
  &lt;audit> request. Likewise, an attacker could impersonate the MS and
  insert error responses into the transport stream so denying the AS
  access to package capabilities.
  </t>

  <t hangText="Resource Exhaustion:">An attacker could insert into the
  Control Channel new request messages (or modify existing ones) with,
  for instance, &lt;dialogprepare> elements with a very long
  fetchtimeout attribute and a bogus source URL. At some point, this will
  exhaust the number of connections that the MS is able to make.
  </t>

  <t hangText="Phishing:">An attacker with access to the Control Channel
  could modify the "loc" attribute of the &lt;media> element in a dialog
  to point to some other audio file that had different information from
  the original. This modified file could include a different phone
  number for people to call if they want more information or need to
  provide additional information (such as governmental, corporate, or
  financial information).
  </t>

  <t hangText="Data Theft:">An attacker could modify a &lt;record>
  element in the Control Channel so as to add a new recording location:

<figure>
<artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <dialogstart>
  <dialog>
   <record>
      <media type="audio/x-wav" loc="(Good URI)"/>
      <media type="audio/x-wav" loc="(Attacker's URI)"/>
   </record>
  </dialog>
 </dialogstart>
</mscivr>
]]></artwork>
</figure>
The recorded data would be uploaded to two locations indicated by the
"{Good URI}" and the "{Attacker's URI}".  This allows the attacker to steal
the recorded audio (which could include sensitive or confidential
information) without the originator of the request necessarily being
aware of the theft.
</t>

</list>
</t>


<t>The Media Control Channel Framework permits additional security
policy management, including resource access and Control Channel usage,
to be specified at the Control Package level beyond that specified for
the Media Control Channel Framework (see Section 12.3 of <xref
target="RFC6230"/>). </t>

<t>Since creation of IVR dialogs is associated with media processing
resources (e.g., DTMF detectors, media playback and recording, etc.) on
the MS, the security policy for this Control Package needs to address
how such dialogs are securely managed across more than one Control
Channel. Such a security policy is only useful for secure, confidential,
and integrity-protected channels. The identity of Control Channels is
determined by the channel identifier, i.e., the value of the cfw-id
attribute in the SDP and 'Dialog-ID' header in the channel protocol (see
<xref target="RFC6230"/>). Channels are
the same if they have the same identifier; otherwise, they are
different. This Control Package imposes the following additional
security policies:

<list style="hanging">

<t hangText="Responses:">The MS MUST only send a response to a dialog
management or audit request using the same Control Channel as the one
used to send the request. </t>

<t hangText="Notifications:">The MS MUST only send notification events
for a dialog using the same Control Channel as it received the request
creating the dialog. </t>

<t hangText="Auditing:">The MS MUST only provide audit information about
dialogs that have been created on the same Control Channel as the one
upon the &lt;audit> request is sent. </t>

<t hangText="Rejection:">The MS SHOULD reject requests to audit or
manipulate an existing dialog on the MS if the channel is not the same
as the one used when the dialog was created. The MS rejects a request by
sending a Control Framework 403 response (see Section 7.4 and Section
12.3 of <xref target="RFC6230"/>). 


For example, if a channel with identifier 'cfw1234' has been used to send a
request to create a particular dialog and the MS receives on channel
'cfw98969' a request to audit or terminate the dialog, then the MS sends
a 403 framework response.
</t>

</list>
 </t>

<t>There can be valid reasons why an implementation does not reject an
audit or dialog manipulation request on a different channel from the one
that created the dialog. For example, a system administrator might
require a separate channel to audit dialog resources created by system
users and to terminate dialogs consuming excessive system
resources. Alternatively, a system monitor or resource broker might
require a separate channel to audit dialogs managed by this package on an
MS. However, the full implications need to be understood by the
implementation and carefully weighted before accepting these reasons as
valid. If the reasons are not valid in their particular circumstances,
the MS rejects such requests.
</t>


<t>There can also be valid reasons for 'channel handover' including high
availability support or where one AS needs to take over management of
dialogs after the AS that created them has failed. This could be
achieved by the Control Channels using the same channel identifier, one
after another. For example, assume a channel is created with the
identifier 'cfw1234' and the channel is used to create dialogs on the
MS. This channel (and associated SIP dialog) then terminates due to a
failure on the AS. As permitted by the Control Framework, the channel
identifier 'cfw1234' could then be reused so that another channel is
created with the same identifier 'cfw1234', allowing it to 'take over'
management of the dialogs on the MS. Again, the implementation needs to
understand the full implications and carefully weight them before
accepting these reasons as valid. If the reasons are not valid for their
particular circumstances, the MS uses the appropriate SIP mechanisms to
prevent session establishment when the same channel identifier is used
in setting up another Control Channel (see Section 4 of <xref
target="RFC6230"/>). </t>


</section>


<section anchor="sec:IANA_Considerations" title="IANA Considerations">

<t>IANA has registered a new Media Control
Channel Framework Package, a new XML namespace, a new XML schema, and a
new MIME type.</t>

<t>IANA has further created a new registry for IVR
prompt variable types. </t>

<section anchor="sec:Control_Package_Reg" title="Control Package Registration">

<t>This section registers a new Media Control Channel Framework package,
per the instructions in Section 13.1 of <xref
target="RFC6230"/>.
</t>

<t>
<figure>
<artwork><![CDATA[
   Package Name: msc-ivr/1.0
   Published Specification(s): RFC 6231
   Person & email address to contact for further information:
      IETF MEDIACTRL working group (mediactrl@ietf.org), 
      Scott McGlashan (smcg.stds01@mcglashan.org).
]]></artwork>
</figure>
</t>
		     
</section>


<section anchor="sec:URN_Reg" title="URN Sub-Namespace Registration">

<t>This section registers a new XML namespace,
"urn:ietf:params:xml:ns:msc-ivr", per the guidelines in <xref
target="RFC3688">RFC 3688</xref>.</t>

	<figure>
<artwork><![CDATA[
URI: urn:ietf:params:xml:ns:msc-ivr
Registrant Contact: IETF MEDIACTRL working group (mediactrl@ietf.org),
   Scott McGlashan (smcg.stds01@mcglashan.org).
XML:
   BEGIN
   <?xml version="1.0"?>
   <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
     <head>
      <title>Media Control Channel Framework IVR 
             Package attributes</title>
     </head>
     <body>
      <h1>Namespace for Media Control Channel 
          Framework IVR Package attributes</h1>
      <h2>urn:ietf:params:xml:ns:msc-ivr</h2>
        <p>See <a href="http://www.rfc-editor.org/rfc/rfc6231.txt">
        RFC 6231</a>.</p>
     </body>
    </html>
   END
]]></artwork>
</figure>

</section>

<section anchor="sec:XML_SCHEMA_IANA" title="XML Schema Registration">

<t>This section registers an XML schema as per the guidelines in <xref
target="RFC3688">RFC 3688</xref>.</t>

<figure>
<artwork><![CDATA[
URI:  urn:ietf:params:xml:ns:msc-ivr
Registrant Contact: IETF MEDIACTRL working group (mediactrl@ietf.org),
   Scott McGlashan (smcg.stds01@mcglashan.org).
Schema:  The XML for this schema can be found in Section 5 of this
   document.
]]></artwork>
</figure>

</section>

<section anchor="sec:MIME_Reg" title="MIME Media Type Registration for application/msc-ivr+xml">

  
<t>This section registers the application/msc-ivr+xml MIME type.</t>


<figure>
<artwork><![CDATA[
   Type name:  application

   Subtype name:  msc-ivr+xml

   Required parameters:  (none)

   Optional parameters:  charset
      Indicates the character encoding of enclosed XML.  Default is
      UTF-8.

   Encoding considerations:  Uses XML, which can employ 8-bit
      characters, depending on the character encoding used.  See RFC
      3023 [RFC3023], Section 3.2.

   Security considerations:  No known security considerations outside
      of those provided by the Media Control Channel Framework IVR 
      Package.

   Interoperability considerations:  This content type provides 
      constructs for the Media Control Channel Framework IVR package.

   Published specification:  RFC 6231 

   Applications that use this media type:  Implementations of 
      the Media Control Channel Framework IVR package.

   Additional information:  
      Magic number(s):  (none)
      File extension(s):  (none)
      Macintosh file type code(s):  (none)

   Person & email address to contact for further information:  
      Scott McGlashan <smcg.stds01@mcglashan.org>

   Intended usage:  LIMITED USE

   Author/Change controller:  The IETF

   Other information:  None.
]]></artwork>
</figure>

</section>

<section anchor="sec:Prompt_Variable_Type_Reg" title="IVR Prompt Variable Type Registration Information">

<t>This specification establishes an IVR Prompt Variable Type registry
for Control Packages and initiates its population as follows.  New
entries in this registry must be published in an RFC (either as an IETF
submission or RFC Editor submission), using the IANA policy <xref
target="RFC5226"/> "RFC Required".

<figure>
<artwork><![CDATA[
Variable Type      Control Package  Reference      
-------------      ---------------  ---------
    date            msc-ivr/1.0     [RFC6231]        
    time            msc-ivr/1.0     [RFC6231]        
    digits          msc-ivr/1.0     [RFC6231]        
]]></artwork>
</figure>
</t>

<t>The following information MUST be provided in an RFC in
order to register a new prompt variable type: 

<list style="hanging">

<t hangText="Variable Type:">The value for the &lt;variable> type
attribute (<xref target="defn.variable"/>). The RFC MUST specify
permitted values (if any) for the format attribute of &lt;variable> and
how the value attribute is rendered for different values of the format
attribute. The RFC MUST NOT weaken but MAY strengthen the valid values
of &lt;variable> attributes defined in <xref target="defn.variable"/> of
this specification.
</t>

<t hangText="Reference:">The RFC number in which the variable type is
registered.</t>

<t hangText="Control Package:">The Control Package associated with the
IVR variable type.</t>

<t hangText="Person & address to contact for further information:">
</t>

</list>

</t>


</section> <!-- end of prompt variable registration -->

</section>


<section anchor="voicexml" title="Using VoiceXML as a Dialog Language">

<t>The IVR Control Package allows, but does not require, the MS to
support other dialog languages by referencing an external dialog
document. This section provides MS implementations that support the
VoiceXML dialog language (<xref target="VXML20"/>, <xref
target="VXML21"/>, <xref target="VXML30"/>) with additional details
about using these dialogs in this package. This section is normative for
an MS that supports the VoiceXML dialog language.  </t>

<t>This section covers preparing (<xref target="vxml.dialogprepare"/>),
starting (<xref target="vxml.dialogstart"/>), terminating (<xref
target="vxml.dialogterminate"/>), and exiting (<xref
target="vxml.dialogexit"/>) VoiceXML dialogs as well as handling
VoiceXML call transfer (<xref target="vxml.transfer"/>). </t>


<section toc="include" anchor="vxml.dialogprepare" title="Preparing a VoiceXML Dialog">

<t>A VoiceXML dialog is prepared by sending the MS a request containing
a &lt;dialogprepare> element (<xref target="defn.dialogprepare"/>).  The
type attribute is set to "application/voicexml+xml" and the src
attribute to the URI of the VoiceXML document that is to be prepared by
the MS. For example:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <dialogprepare type="application/voicexml+xml" 
                src="http://www.example.com/mydialog.vxml"
                fetchtimeout="15s"/>
</mscivr>
]]></artwork></figure>
</t>


<t>The VoiceXML dialog environment uses the &lt;dialogprepare> request
as an opportunity to fetch and validate the initial document indicated
by the src attribute along with any resources referenced in the VoiceXML
document marked as prefetchable. The maxage and maxstale attributes, if
specified, control how the initial VoiceXML document is fetched using
HTTP (see <xref target="RFC2616"/>).  Note that the fetchtimeout
attribute is not defined in VoiceXML for an initial document, but the MS
MUST support this attribute in its VoiceXML environment.</t>

<t> If a &lt;params> child element of &lt;dialogprepare> is specified,
then the MS MUST map the parameter information into a VoiceXML session
variable object as described in <xref target="vxml.params"/>.</t>

<t>The success or failure of the VoiceXML document preparation is
reported in the MS response. For example, if the VoiceXML document
cannot be retrieved, then a 409 error response is returned. If the
document is syntactically invalid according to VoiceXML, then a 400
response is returned. If successful, the response includes a dialogid
attribute whose value the AS can use in &lt;dialogstart> element to
start the prepared dialog. </t>

</section>


<section toc="include" anchor="vxml.dialogstart" title="Starting a VoiceXML Dialog">

<t>A VoiceXML dialog is started by sending the MS a request containing a
&lt;dialogstart> element (<xref target="defn.dialogstart"/>). If a
VoiceXML dialog has already been prepared using &lt;dialogprepare>, then
the MS starts the dialog indicated by the prepareddialogid
attribute. Otherwise, a new VoiceXML dialog can be started by setting
the type attribute to "application/voicexml+xml" and the src attribute
to the URI of the VoiceXML document. For example:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <dialogstart connectionid="ssd3r3:sds345b" 
              type="application/voicexml+xml" 
              src="http://www.example.com/mydialog.vxml"
              fetchtimeout="15s"/>
</mscivr>
]]></artwork></figure>
</t>

<t>The maxage and maxstale attributes, if specified, control how the
initial VoiceXML document is fetched using HTTP (see <xref
target="RFC2616"/>). Note that the fetchtimeout attribute is not defined
in VoiceXML for an initial document, but the MS MUST support this
attribute in its VoiceXML environment. Note also that support for
&lt;dtmfsub> subscriptions (<xref target="defn.dtmfsub"/>) and their
associated dialog notification events is not defined in VoiceXML. If
such a subscription is specified in a &lt;dialogstart> request, then the
MS sends a 439 error response (see <xref
target="defn.statuscodes"/>). </t>

<t>The success or failure of starting a VoiceXML dialog is reported in
the MS response as described in <xref target="defn.dialogstart"/>.</t>

<t>When the MS starts a VoiceXML dialog, the MS MUST map session
information into a VoiceXML session variable object. There are 3 types
of session information: protocol information (<xref
target="vxml.protocol"/>), media stream information (<xref
target="vxml.streams"/>), and parameter information (<xref
target="vxml.params"/>). </t>

<section toc="include" anchor="vxml.protocol" title="Session Protocol Information">

<t>If the connectionid attribute is specified, the MS assigns protocol
information from the SIP dialog associated with the connection to the
following session variables in VoiceXML:

<list style="hanging">

<t hangText="session.connection.local.uri">Evaluates to the SIP URI
specified in the 'To:' header of the initial INVITE. </t>

<t hangText="session.connection.remote.uri">Evaluates to the SIP URI
specified in the 'From:' header of the initial INVITE.</t>

<t hangText="session.connection.originator">Evaluates to the value of
session.connection.remote (MS receives inbound connections but does not
create outbound connections).</t>

<t hangText="session.connection.protocol.name">Evaluates to "sip".  Note
that this is intended to reflect the use of SIP in general, and does not
distinguish between whether the connection accesses the MS via SIP or
SIP Secure (SIPS) procedures. </t>

<t hangText="session.connection.protocol.version">Evaluates to
"2.0".</t>

<t hangText="session.connection.redirect"> This array is populated by
information contained in the 'History-Info' 
header <xref target="RFC4244"/> in the initial INVITE or is otherwise undefined.  Each entry
(hi&nbhy;entry) in the 'History-Info' header is mapped, in the order it
appeared in the 'History-Info' header, into an element of the
session.connection.redirect array.  Properties of each element of the
array are determined as follows:

   <list style="hanging" hangIndent="7">

     <t hangText="uri">Set to the hi-targeted-to-uri value of the
     History-Info entry</t>

     <t hangText="pi">Set to 'true' if hi-targeted-to-uri contains a
     'Privacy=history' parameter, or if the INVITE 'Privacy' header
     includes 'history'; 'false' otherwise</t>

     <t hangText="si">Set to the value of the 'si' parameter if it exists;
         undefined otherwise</t>

     <t hangText="reason">Set verbatim to the value of the 'Reason' parameter of
         hi-targeted-to-uri</t>
   </list>
</t>

<t hangText="session.connection.aai"> Evaluates to the value of a SIP
header with the name "aai" if present; undefined otherwise.
</t>

<t hangText="session.connection.protocol.sip.requesturi">This is an
associative array where the array keys and values are formed from the
URI parameters on the SIP Request-URI of the initial INVITE.  The array
key is the URI parameter name.  The corresponding array value is
obtained by evaluating the URI parameter value as a string.  In
addition, the array's toString() function returns the full SIP
Request-URI. 
</t>

<t hangText="session.connection.protocol.sip.headers">This is an
associative array where each key in the array is the non-compact name of
a SIP header in the initial INVITE converted to lowercase (note the
case conversion does not apply to the header value).  If multiple header
fields of the same field name are present, the values are combined into
a single comma-separated value.  Implementations MUST at a minimum
include the 'Call-ID' header and MAY include other headers.  For example,
session.connection.protocol.sip.headers["call-id"] evaluates to the
Call-ID of the SIP dialog.
</t>

</list>
</t>

<t>If a conferenceid attribute is specified, then the MS populates the following
session variables in VoiceXML:

<list style="hanging">

<t hangText="session.conference.name">Evaluates to the value of the
conferenceid attribute. </t>

</list>
</t>

</section>

<section toc="include"  anchor="vxml.streams" title="Session Media Stream Information">

<t>The media streams of the connection or conference to use for the
dialog are described in <xref target="defn.dialogstart"/>, including use
of &lt;stream> elements (<xref target="defn.stream"/>) if specified.


The MS maps media stream information into the VoiceXML session variable
session.connection.protocol.sip.media for a connection, and
session.conference.media for a conference. In both variables, the value
of the variable is an array where each array element is an object with
the following properties:

<list style="hanging">

      <t hangText="type">This required property indicates the type of
      the media associated with the stream (see <xref
      target="defn.stream"/> &lt;stream> type attribute definition).
      </t>

      <t hangText="direction">This required property indicates the
      directionality of the media relative to the endpoint of the dialog
      (see <xref target="defn.stream"/> &lt;stream> direction attribute
      definition).
      </t>

      <t hangText="format">This property is optional.  If defined, the
      value of the property is an array.  Each array element is an
      object that specifies information about one format of the media
      stream.  The object contains at least one property called name
      whose value is the subtype name of the media format <xref
      target="RFC4855"/>.  Other properties may be defined with string
      values; these correspond to required and, if defined, optional
      parameters of the format.
      </t>
</list>
</t>


<t>As a consequence of this definition, when a connectionid is specified
there is an array entry in session.connection.protocol.sip.media for
each media stream used by the VoiceXML dialog. For an example, consider
a connection with bidirectional G.711 mu-law audio sampled at 8kHz
where the dialog is started with

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <dialogstart connectionid="ssd3r3:sds345b" 
              type="application/voicexml+xml" 
              src="http://www.example.com/mydialog.vxml"
              fetchtimeout="15s">
  <stream media="audio" direction="recvonly"/>
 </dialogstart>
</mscivr>
]]></artwork></figure>
</t>

<t>In this case, session.connection.protocol.sip.media[0].type evaluates
to "audio", session.connection.protocol.sip.media[0].direction evaluates to
"recvonly" (i.e., the endpoint only receives media from the dialog -- the
endpoint does not send media to the dialog), 
session.connection.protocol.sip.media[0].format[0].name evaluates to
"PCMU", and session.connection.protocol.sip.media[0].format[0].rate
evaluates to "8000".
</t>

<t>Note that the session variable is updated if the connection or
conference media session characteristics for the VoiceXML dialog change
(e.g., due to a SIP re-INVITE).
</t>

</section>

<section toc="include"  anchor="vxml.params" title="Session Parameter Information">

<t>Parameter information is specified in the &lt;params> child element
of &lt;dialogprepare> and &lt;dialogstart> elements, where each
parameter is specified using a &lt;param> element. The MS maps parameter
information into VoiceXML session variables as follows:

<list style="hanging">

<t hangText="session.values">This is an associative array mapped to the
&lt;params> element. It is undefined if no &lt;params> element is
specified. If a &lt;params> element is specified in both
&lt;dialogprepare> and &lt;dialogstart> elements for the same dialog,
then the array is first initialized with the &lt;params> specified in
the &lt;dialogprepare> element and then updated with the &lt;params>
specified in the &lt;dialogstart> element; in cases of conflict, the
&lt;dialogstart> parameter value take priority. Array keys and values
are formed from &lt;param> children of the &lt;params> element.  Each
array key is the value of the name attribute of a &lt;param> element. If
the same name is used in more than one &lt;param> element, then the
array key is associated with the last &lt;param> in document order. The
corresponding value for each key is an object with two required
properties: a "type" property evaluating to the value of the type
attribute, and a "content" property evaluating to the content of the
&lt;param>. In addition, this object's toString() function returns the
value of the "content" property as a string.
</t>
</list>
</t>

<t>For example, a VoiceXML dialog started with one parameter:

<figure><artwork><![CDATA[
<mscivr version="1.0" xmlns="urn:ietf:params:xml:ns:msc-ivr">
 <dialogstart connectionid="ssd3r3:sds345b" 
              type="application/voicexml+xml" 
              src="http://www.example.com/mydialog.vxml"
              fetchtimeout="15s">
  <params>
   <param name="mode">playannouncement</param>
  </params>
 </dialogstart>
</mscivr>
]]></artwork></figure>
</t>

<t>In this case, session.values would be defined with one item in the
array where session.values['mode'].type evaluates to "text/plain" (the
default value), session.values['mode'].content evaluates to
"playannouncement", and session.values['mode'].toString() also evaluates
to "playannouncement".
</t>

<t>The MS sends an error response (see <xref
target="defn.dialogstart"/>) if a &lt;param> is not supported by the MS
(e.g., the parameter type is not supported).
</t>



</section>


</section>

<section toc="include" anchor="vxml.dialogterminate" title="Terminating a VoiceXML Dialog">

<t>
When the MS receives a request with a &lt;dialogterminate> element
(<xref target="defn.dialogterminate"/>), the MS throws a
'connection.disconnect.hangup' event into the specified VoiceXML dialog.
Note that if the immediate attribute has the value true, then the MS
MUST NOT return &lt;params> information when the VoiceXML dialog exits
(even if the VoiceXML dialog provides such information) -- see <xref
target="vxml.dialogexit"/>.
</t>

<t>If the connection or conference associated with the VoiceXML dialog
terminates, then the MS throws a 'connection.disconnect.hangup' event
into the specified VoiceXML dialog. </t>


</section>

<section toc="include" anchor="vxml.dialogexit" title="Exiting a VoiceXML Dialog">

<t>The MS sends a &lt;dialogexit> notification event (<xref
target="defn.dialogexit"/>) when the VoiceXML dialog is complete, has
been terminated, or exits due to an error. The &lt;dialogexit>
status attribute specifies the status of the VoiceXML dialog when it
exits and its &lt;params> child element specifies information, if any,
returned from the VoiceXML dialog.</t>

<t>A VoiceXML dialog exits when it processes a &lt;disconnect> element,
an &lt;exit> element, or an implicit exit according to the VoiceXML
  form interpretation algorithm (FIA).
If the VoiceXML dialog executes a &lt;disconnect> and then subsequently
executes an &lt;exit> with namelist information, the namelist
information from the &lt;exit> element is discarded.
</t>

<t>The MS reports namelist variables in the &lt;params> element of the
&lt;dialogexit>. Each &lt;param> reports on a namelist variable. The MS
set the &lt;param> name attribute to the name of the VoiceXML variable.
The MS sets the &lt;param> type attribute according to the type of the
VoiceXML variable. 

The MS sets the &lt;param> type to 'text/plain' when the VoiceXML
variable is a simple ECMAScript value.

If the VoiceXML variable is a recording, the MS sets the &lt;param> type
to the MIME media type of the recording and encodes the recorded content
as CDATA in the &lt;param> (see <xref target="defn.param"/> for an
example).

If the VoiceXML variable is a complex ECMAScript value (e.g., object,
array, etc.), the MS sets the &lt;param> type to 'application/json' and
converts the variable value to its JSON value equivalent <xref
target="RFC4627"/>. The behavior resulting from specifying an
ECMAScript object with circular references is not defined.
</t>

<t>If the expr attribute is specified on the VoiceXML &lt;exit> element
instead of the namelist attribute, the MS creates a &lt;param> element
with the reserved name '__exit'.  If the value is an ECMAScript literal,
the &lt;param> type is 'text/plain' and the content is the literal
value. If the value is a variable, the &lt;param> type and content are
set in the same way as a namelist variable; for example, an expr
attribute referencing a variable with a simple ECMAScript value has the
type 'text/plain' and the content is set to the ECMAScript value. To
allow the AS to differentiate between a &lt;dialogexit> notification
event resulting from a VoiceXML &lt;disconnect> from one resulting from
an &lt;exit>, the MS creates a &lt;param> with the reserved name
'__reason', the type 'text/plain', and a value of "disconnect" (without
brackets) to reflect the use of VoiceXML's &lt;disconnect> element, and
the value of "exit" (without brackets) to an explicit &lt;exit> in the
VoiceXML dialog.  If the VoiceXML session terminates for other reasons
(such as encountering an error), this parameter MAY be omitted or take
on platform-specific values prefixed with an underscore.
</t>


<t><xref target="vxml.table.exit"/> provides some examples of VoiceXML
&lt;exit> usage and the corresponding &lt;params> element in the
&lt;dialogexit> notification event. It assumes the following VoiceXML
variable names and values: userAuthorized=true, pin=1234, and errors=0.
The &lt;param> type attributes ('text/plain') are omitted for clarity.
</t>

<texttable anchor="vxml.table.exit"  title="VoiceXML &lt;exit> Mapping Examples" >
  <ttcol align="left" width="25%">&lt;exit> Usage</ttcol>
  <ttcol align="left" width="75%">&lt;params> Result</ttcol>

<c>&lt;exit></c>
<c>
&lt;params>
 &lt;param name="__reason">exit&lt;/param>
&lt;/params>
</c>

<c>&lt;exit expr="5"></c>
<c>
&lt;params>
 &lt;param name="__reason">exit&lt;/param>
 &lt;param name="__exit">5&lt;/param>
&lt;/params>
</c>

<c>&lt;exit expr="'done'"></c>
<c>
&lt;params>
 &lt;param name="__reason">exit&lt;/param>
 &lt;param name="__exit">'done'&lt;/param>
&lt;/params>
</c>

<c>&lt;exit expr="userAuthorized"></c>
<c>
&lt;params>
 &lt;param name="__reason">exit&lt;/param>
 &lt;param name="__exit">true&lt;/param>
&lt;/params>
</c>

<c>&lt;exit namelist="pin errors"></c>
<c>
&lt;params>
 &lt;param name="__reason">exit&lt;/param>
 &lt;param name="pin">1234&lt;/param>
 &lt;param name="errors">0&lt;/param>
&lt;/params>
</c>

</texttable>


</section>


<section toc="include" anchor="vxml.transfer" title="Call Transfer">

<t>While VoiceXML is at its core a dialog language, it also provides
optional call transfer capability. It is NOT RECOMMENDED to use
VoiceXML's call transfer capability in networks involving application
servers.  Rather, the AS itself can provide call routing functionality
by taking signaling actions based on the data returned to it, either
through VoiceXML's own data submission mechanisms or through the
mechanism described in <xref target="vxml.dialogexit"/>.  


If the MS encounters a VoiceXML dialog requesting call transfer
capability, the MS SHOULD raise an error event in the VoiceXML dialog
execution context: an error.unsupported.transfer.blind event if blind
transfer is requested, error.unsupported.transfer.bridge if bridge
transfer is requested, or error.unsupported.transfer.consultation if
consultation transfer is requested. </t>
</section>


</section> <!-- end of voicexml section  -->

<section title="Contributors">

<t> Asher Shiratzky provided valuable support and contributions to the
early versions of this document. </t>

<t>The authors would like to thank the IVR design team consisting of
Roni Even, Lorenzo Miniero, Adnan Saleem, Diego Besprosvan, Mary Barnes,
and Steve Buko, who provided valuable feedback, input, and text to this
document. </t>

</section>


<section title="Acknowledgments">

<t>The authors would like to thank Adnan Saleem, Gene Shtirmer, Dave
Burke, Dan York, Steve Buko, Jean-Francois Bertrand, Henry Lum, and
Lorenzo Miniero for expert reviews of this work.
</t>

<t>Ben Campbell carried out the RAI expert review on this specification
and provided a great deal of invaluable input.  Donald Eastlake carried
out a thorough security review.
</t>


</section> <!-- end of acknowledgements -->

</middle>

	<back>

<?rfc rfcedstyle="no"?>
		
		<references title="Normative References">
  		 &rfc2119;    

<reference anchor='RFC6230'>
<front>
<title>Media Control Channel Framework</title>

<author initials='C' surname='Boulton' fullname='Chris Boulton'>
    <organization />
</author>

<author initials='T' surname='Melanchuk' fullname='Tim Melanchuk'>
    <organization />
</author>

<author initials='S' surname='McGlashan' fullname='Scott McGlashan'>
    <organization />
</author>

<date month='May' year='2011' />

</front>

<seriesInfo name='RFC' value='6230'/>

</reference>


         &rfc3023;
         &rfc4574;
         &rfc3986;
         &rfc5646;
         &rfc4647;
         &smil2;
         &rfc3688;
         &rfc2616;
         &rfc2818;
         &rfc4288;
         &rfc5234;
         &rfc5226;
         &rfc2045;
         &rfc4627;
         &rfc2277;

   <reference anchor="XML">
        <front>
          <title>Extensible Markup Language (XML) 1.0 (Third Edition)
          </title>
            <author initials="T" surname="Bray">
        <organization> </organization>
        </author>
            <author initials="J" surname="Paoli">
        <organization> </organization>
        </author>
            <author initials="C M" surname="Sperberg-McQueen">
        <organization> </organization>
        </author>
            <author initials="E" surname="Maler">
        <organization> </organization>
        </author>
            <author initials="F" surname="Yergeau">
        <organization> </organization>
        </author>
            <date month="February" year="2004" />
        </front>
        <seriesInfo name="W3C" value="Recommendation" />
    </reference>


   <reference anchor="XMLSchema:Part2">
        <front>
          <title>XML Schema Part 2: Datatypes Second Edition
          </title>
            <author initials="P" surname="Biron">
        <organization> </organization>
        </author>
            <author initials="A" surname="Malhotra">
        <organization> </organization>
            </author>
            <date month="October" year="2004" />
        </front>
        <seriesInfo name="W3C" value="Recommendation" />
    </reference>


      <reference anchor="SRGS">
        <front>
          <title>Speech Recognition Grammar Specification Version
        1.0</title>
		<author initials="A." surname="Hunt">
			<organization>ScanSoft</organization>
		</author>
		<author initials="S." surname="McGlashan">
			<organization>Hewlett-Packard</organization>
		</author>
        <date month="March" year="2004" />
        </front>
        <seriesInfo name="W3C" value="Recommendation" />
      </reference>

   <reference anchor="VXML20">
        <front>
            <title>Voice Extensible Markup Language (VoiceXML) Version 2.0</title>
            <author initials="S" surname="McGlashan">
        <organization> </organization>
        </author>
            <author initials="D" surname="Burnett">
        <organization> </organization>
        </author>
            <author initials="J" surname="Carter">
        <organization> </organization>
        </author>
            <author initials="P" surname="Danielsen">
        <organization> </organization>
        </author>
            <author initials="J" surname="Ferrans">
        <organization> </organization>
        </author>
            <author initials="A" surname="Hunt">
        <organization> </organization>
        </author>
            <author initials="B" surname="Lucas">
        <organization> </organization>
        </author>
            <author initials="B" surname="Porter">
        <organization> </organization>
        </author>
            <author initials="K" surname="Rehor">
        <organization> </organization>
        </author>
            <author initials="S" surname="Tryphonas">
        <organization> </organization>
        </author>
            <date month="March" year="2004" />
        </front>
        <seriesInfo name="W3C" value="Recommendation" />
    </reference>

   <reference anchor="VXML21">
        <front>
            <title>Voice Extensible Markup Language (VoiceXML) Version 2.1</title>

         <author initials="M" surname="Oshry">
          <organization> </organization>
        </author>
            <author initials="RJ" surname="Auburn">
        <organization> </organization>
        </author>
            <author initials="P" surname="Baggia">
        <organization> </organization>
        </author>
            <author initials="M" surname="Bodell">
        <organization> </organization>
        </author>
            <author initials="D" surname="Burke">
        <organization> </organization>
        </author>
            <author initials="D" surname="Burnett">
        <organization> </organization>
        </author>
            <author initials="E" surname="Candell">
        <organization> </organization>
        </author>
            <author initials="J" surname="Carter">
        <organization> </organization>
        </author>
            <author initials="S" surname="McGlashan">
        <organization> </organization>
        </author>
            <author initials="A" surname="Lee">
        <organization> </organization>
        </author>
            <author initials="B" surname="Porter">
        <organization> </organization>
        </author>
            <author initials="K" surname="Rehor">
        <organization> </organization>
            </author>
            <date month="June" year="2007" />
        </front>
        <seriesInfo name="W3C" value="Recommendation" />
    </reference>

    	</references>
		
		<references title="Informative References">

		&rfc3261;
        &rfc4240;
        &rfc2897;
        &rfc4730;
        &rfc5022;
        &rfc4281;
        &rfc4733;
		&rfc5167;
		&rfc4855;
        &rfc4267;
        &rfc4244;
        &rfc5707;

<!-- draft-ietf-xcon-common-data-model -->
<reference anchor='XCON-DATA-MODEL'>
<front>
<title>Conference Information Data Model for Centralized Conferencing (XCON)</title>

<author initials='O' surname='Novo' fullname='Oscar Novo'>
    <organization />
</author>

<author initials='G' surname='Camarillo' fullname='Gonzalo Camarillo'>
    <organization />
</author>

<author initials='D' surname='Morgan' fullname='David Morgan'>
    <organization />
</author>

<author initials='J' surname='Urpalainen' fullname='Jari Urpalainen'>
    <organization />
</author>

<date month='April' day='14' year='2011' />

</front>
<seriesInfo name='Work in' value='Progress'/>
</reference>


<!-- draft-ietf-mediactrl-mixer-control-package in Queue in MISSREF -->
<reference anchor='MIXER-CP'>
<front>
<title>A Mixer Control Package for the Media Control Channel Framework</title>

<author initials='S' surname='McGlashan' fullname='Scott McGlashan'>
    <organization />
</author>

<author initials='T' surname='Melanchuk' fullname='Tim Melanchuk'>
    <organization />
</author>

<author initials='C' surname='Boulton' fullname='Chris Boulton'>
    <organization />
</author>
<date month="January" day="6" year="2011"/>

</front>

<seriesInfo name='Work in' value='Progress'/>
</reference>



      <reference anchor="H.248.9">
        <front>
        <title>Gateway control protocol: Advanced media server packages</title>
        <author>
          <organization/>
        </author>
        </front>
        <seriesInfo name="ITU-T Recommendation" 
                    value="H.248.9"/>
      </reference>



   <reference anchor="CCXML10">
        <front>
            <title>Voice Browser Call Control: CCXML Version 1.0</title>
            <author initials="R J" surname="Auburn">
        <organization> </organization>
        </author>
            <date month="April" year="2010" />
        </front>
        <seriesInfo name="W3C" value="Candidate Recommendation (work in progress)" />
    </reference>




   <reference anchor="VXML30">
        <front>
            <title>Voice Extensible Markup Language (VoiceXML) Version 3.0</title>

        <author initials="S" surname="McGlashan">
         <organization> </organization>
        </author>
        <author initials="D" surname="Burnett">
        <organization> </organization>
        </author>
         <author initials="R" surname="Akolkar">
          <organization> </organization>
        </author>
         <author initials="RJ" surname="Auburn">
          <organization> </organization>
        </author>
        <author initials="P" surname="Baggia">
        <organization> </organization>
        </author>
        <author initials="J" surname="Barnett">
        <organization> </organization>
        </author>
         <author initials="M" surname="Bodell">
        <organization> </organization>
        </author>
        <author initials="J" surname="Carter">
        <organization> </organization>
        </author>
        <author initials="M" surname="Oshry">
        <organization> </organization>
        </author>
        <author initials="K" surname="Rehor">
        <organization> </organization>
        </author>
        <author initials="M" surname="Young">
        <organization> </organization>
        </author>        
        <author initials="R" surname="Hosn">
        <organization> </organization>
        </author>        
        <date month="August" year="2010" />
        </front>
        <seriesInfo name="W3C" value="Working Draft" />
    </reference>

   <reference anchor="IANA" >
        <front>
          <title>RTP Payload Types
          </title>
          <author>
                <organization>IANA</organization>
            </author>
        </front>
<seriesInfo name="available from" value="http://www.iana.org"/>
    </reference>

   <reference anchor="MIME.mediatypes">
        <front>
          <title>MIME Media Types
          </title>
          <author>
                <organization>IANA</organization>
            </author>
        </front>
<seriesInfo name="available from" value="http://www.iana.org"/>
    </reference>

	
 		</references>
<?rfc rfcedstyle="yes"?>
	</back>
</rfc>
