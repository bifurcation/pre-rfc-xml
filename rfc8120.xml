<?xml version="1.0" encoding="US-ASCII" ?>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC1939 SYSTEM "reference.RFC.1939.xml">
<!ENTITY RFC2104 SYSTEM "reference.RFC.2104.xml">
<!ENTITY RFC2119 SYSTEM "reference.RFC.2119.xml">
<!ENTITY RFC2818 SYSTEM "reference.RFC.2818.xml">
<!ENTITY RFC3629 SYSTEM "reference.RFC.3629.xml">
<!ENTITY RFC4013 SYSTEM "reference.RFC.4013.xml">
<!ENTITY RFC4648 SYSTEM "reference.RFC.4648.xml">
<!ENTITY RFC5226 SYSTEM "reference.RFC.5226.xml">
<!ENTITY RFC5234 SYSTEM "reference.RFC.5234.xml">
<!ENTITY RFC5246 SYSTEM "reference.RFC.5246.xml">
<!ENTITY RFC5890 SYSTEM "reference.RFC.5890.xml">
<!ENTITY RFC5929 SYSTEM "reference.RFC.5929.xml">
<!ENTITY RFC5987 SYSTEM "reference.RFC.5987.xml">
<!ENTITY RFC6265 SYSTEM "reference.RFC.6265.xml">
<!ENTITY RFC6454 SYSTEM "reference.RFC.6454.xml">
<!ENTITY RFC7230 SYSTEM "reference.RFC.7230.xml">
<!ENTITY RFC7231 SYSTEM "reference.RFC.7231.xml">
<!ENTITY RFC7235 SYSTEM "reference.RFC.7235.xml">
<!ENTITY RFC7486 SYSTEM "reference.RFC.7486.xml">
<!ENTITY RFC7525 SYSTEM "reference.RFC.7525.xml">
<!ENTITY RFC7613 SYSTEM "reference.RFC.7613.xml">
<!ENTITY RFC7615 SYSTEM "reference.RFC.7615.xml">
<!ENTITY RFC7616 SYSTEM "reference.RFC.7616.xml">
<!ENTITY RFC7627 SYSTEM "reference.RFC.7627.xml">
<!ENTITY RFC8018 SYSTEM "reference.RFC.8018.xml">
<!ENTITY RFC8053 SYSTEM "reference.RFC.8053.xml">

<!ENTITY _Protocol_version_token "1">

<!ENTITY _401-INIT "401&nbhy;INIT">
<!ENTITY _401-STALE "401&nbhy;STALE">
<!ENTITY _req-KEX-C1 "req&nbhy;KEX&nbhy;C1">
<!ENTITY _401-KEX-S1 "401&nbhy;KEX&nbhy;S1">
<!ENTITY _req-VFY-C "req&nbhy;VFY&nbhy;C">
<!ENTITY _200-VFY-S "200&nbhy;VFY&nbhy;S">
<!ENTITY _Authentication-Info "Authentication&nbhy;Info">
<!ENTITY _WWW-Authenticate "WWW&nbhy;Authenticate">
<!ENTITY _Optional-WWW-Authenticate "Optional&nbhy;&_WWW-Authenticate;">
<!ENTITY _Authentication-Control "Authentication&nbhy;Control">
<!ENTITY _Authorization "Authorization">
<!ENTITY _tls-unique "tls&nbhy;unique">
<!ENTITY _tls-server-end-point "tls&nbhy;server&nbhy;end&nbhy;point">
<!ENTITY _auth-scope "auth&nbhy;domain">
<!ENTITY _auth-scheme "auth&nbhy;scheme">
<!ENTITY _nc-max "nc&nbhy;max">
<!ENTITY _nc-window "nc&nbhy;window">
<!ENTITY _logout-timeout "logout&nbhy;timeout">
<!ENTITY _100-continue "100&nbhy;continue">

<!ENTITY _S_c1 "S_c1">
<!ENTITY _S_s1 "S_s1">
<!ENTITY _K_c1 "K_c1">
<!ENTITY _K_s1 "K_s1">
<!ENTITY _kc1 "kc1">
<!ENTITY _ks1 "ks1">
<!ENTITY _VK_c "VK_c">
<!ENTITY _VK_s "VK_s">
<!ENTITY _vkc "vkc">
<!ENTITY _vks "vks">
]>

<rfc category="exp" number="8120" ipr="trust200902" submissionType="IETF" consensus="yes">

  <front>
    <title abbrev="Mutual Authentication Protocol for HTTP">Mutual Authentication Protocol for HTTP</title>

    <author fullname="Yutaka Oiwa" initials="Y." surname="Oiwa">
      <organization abbrev="ITRI, AIST">National Institute of Advanced Industrial Science and Technology</organization>
      <address>
        <postal>
          <street>Information Technology Research Institute</street>
          <street>Tsukuba Central 1</street>
          <street>1-1-1 Umezono</street>
          <city>Tsukuba-shi</city><region>Ibaraki</region>
          <country>Japan</country>
        </postal>
        <email>y.oiwa@aist.go.jp</email>
      </address>
    </author>

    <author fullname="Hajime Watanabe" initials="H." surname="Watanabe">
      <organization abbrev="ITRI, AIST">National Institute of Advanced Industrial Science and Technology</organization>
      <address>
        <postal>
          <street>Information Technology Research Institute</street>
          <street>Tsukuba Central 1</street>
          <street>1-1-1 Umezono</street>
          <city>Tsukuba-shi</city><region>Ibaraki</region>
          <country>Japan</country>
        </postal>
        <email>h-watanabe@aist.go.jp</email>
      </address>
    </author>

    <author fullname="Hiromitsu Takagi" initials="H." surname="Takagi">
      <organization abbrev="ITRI, AIST">National Institute of Advanced Industrial Science and Technology</organization>
      <address>
        <postal>
          <street>Information Technology Research Institute</street>
          <street>Tsukuba Central 1</street>
          <street>1-1-1 Umezono</street>
          <city>Tsukuba-shi</city><region>Ibaraki</region>
          <country>Japan</country>
        </postal>
        <email>takagi.hiromitsu@aist.go.jp</email>
      </address>
    </author>

    <author fullname="Kaoru Maeda" initials="K." surname="Maeda">
      <organization abbrev="Individual Contributor">Individual Contributor</organization>
      <address>
        <email>kaorumaeda.ml@gmail.com</email>
      </address>
    </author>

    <author fullname="Tatsuya Hayashi" initials="T." surname="Hayashi">
      <organization abbrev="Lepidum">Lepidum Co. Ltd.</organization>
      <address>
        <postal>
          <street>Village Sasazuka 3, Suite #602</street>
          <street>1-30-3 Sasazuka</street>
          <city>Shibuya-ku</city><region>Tokyo</region>
          <country>Japan</country>
        </postal>
        <email>hayashi@lepidum.co.jp</email>
      </address>
    </author>

    <author fullname="Yuichi Ioku" initials="Y." surname="Ioku">
      <organization abbrev="Individual Contributor">Individual Contributor</organization>
      <address>
        <email>mutual-work@ioku.org</email>
      </address>
    </author>

    <date month="April" year="2017"/>

    <keyword>HTTP, authentication</keyword>

    <abstract>
      <t>
   This document specifies an authentication scheme for the
   Hypertext Transfer Protocol (HTTP) that is referred to as either
   the Mutual authentication scheme or the Mutual authentication protocol.
   This scheme provides true mutual authentication between an HTTP client
   and an HTTP server using password-based authentication.  Unlike
   the Basic and Digest authentication schemes, the
   Mutual authentication scheme specified in this document assures the
   user that the server truly knows the user's encrypted password.
      </t>
    </abstract>
  </front>

<middle>

<section title="Introduction">

     <t>
     This document specifies an authentication scheme for the
     Hypertext Transfer Protocol (HTTP) that is referred to as either
     the Mutual authentication scheme or the Mutual authentication protocol.
     This scheme provides true mutual authentication between an
     HTTP client and an HTTP server using just a simple password as a
     credential.
     </t>

     <t>
     Password-stealing attacks are one of the most critical threats
     for Web systems.  Plain&nbhy;text password authentication
     techniques (Basic authentication and Web-form-based
     authentication) have been widely used for a long time.
     When these techniques are used with plain HTTP protocols,
     it is trivially easy for attackers to sniff the password
     credentials on the wire.
     </t>

     <t>
     <xref target="RFC7616">The Digest authentication scheme</xref>
     uses SHA-256 and SHA&nbhy;512&wj;/256 (formerly SHA-1 and MD5)
     hash algorithms to hide the raw user password from network sniffers.
     However, if the number of possible candidate users' passwords
     is not enough, newer and more powerful computers can compute possible
     hash values for billions of password candidates and compare these
     with the sniffed values to find out the correct password.
     This kind of attack is called an offline password dictionary attack;
     the search capacity of these newer computers reduces the effectiveness
     of users' memorable passwords, thereby threatening the effectiveness
     of such hash-based password protections.
     </t>

     <t>
     <xref target="RFC5246">Transport Layer Security (TLS)</xref> provides
     strong cryptographic protection against the network-based sniffing
     of passwords and other communication contents.  If TLS is correctly
     used by both server operators and client users, passwords and other
     credentials will not be available to any outside attackers. However,
     there is a pitfall related to TLS deployment on Web systems: if the
     users are fraudulently routed to a "wrong Website" via some kind of
     social engineering attack (e.g., phishing) and tricked into
     performing authentication on that site, the credentials will be
     sent to the attacker's server and trivially leaked. Attacks such as
     phishing have become a serious threat. In current Web system
     deployments, TLS certificates will be issued to almost any users
     of the Internet (including malicious attackers). Although those
     certificates include several levels of the "validation results"
     (such as corporate names) of the issued entities, the task of
     "checking" those validation results is left to the users
     of Web browsers, still leaving open the possibility of such
     social engineering attacks.
     </t>

     <t>
     Another way to avoid such threats is to avoid password-based 
     authentication and use some kinds of pre-deployed strong secret keys
     (on either the client side or the server side) for authentications.
     Several federated authentication frameworks, as well as
     <xref target="RFC7486">HTTP Origin&nbhy;Bound Authentication
     (HOBA)</xref>, are proposed and deployed on real Web systems to
     satisfy those needs. However, a type of authentication based on
     "human&nbhy;memorable secrets" (i.e., passwords) is still required
     in several scenarios, such as initialization, key deployment to new
     clients, or recovery of secret accounts with lost cryptographic keys.
     </t>

     <t>
     The Mutual authentication protocol, as proposed in this document,
     is a strong cryptographic solution for password authentications.
     It mainly provides the following two key features:
     <list style="symbols">
          <t>No password information at all is exchanged in the
          communications. When the server and the user fail to authenticate
          with each other, the protocol will not reveal even the
          tiniest bit of information about the user's password.
          This prevents any kind of offline password dictionary attacks,
          even with the existence of phishing attacks.</t>

          <t>To successfully authenticate, the server, as well as client
          users, must own the valid registered credentials
          (authentication secret). This means that a phishing attacker
          cannot trick users into thinking that it is an "authentic"
          server. (It should be pointed out that this is not true for
          Basic and Digest authentication; for example, servers using
          Basic authentication can answer "YES" to any clients
          without actually checking authentication at all.) Client users
          can ascertain whether or not the communicating peer is truly
          "the server" that registered their account beforehand.
          In other words, it provides "true" mutual authentication
          between servers and clients.</t>
     </list>
     Given the information above, the proposed protocol can serve as a
     strong alternative to the Basic, Digest, and Web-form-based
     authentication schemes and also as a strong companion to the
     non&nbhy;password-based authentication frameworks.
     </t>

     <t>
     The proposed protocol will serve in the same way as does existing
     Basic or Digest authentication: it meets the requirements for new
     authentication schemes for HTTP, as described in
     Section&nbsp;5.1.2 of <xref target="RFC7235" />. Additionally,
     to communicate authentication results more reliably between
     the server and the client user, it suggests that Web browsers
     have some "secure" way of displaying the authentication results.
     Having such a user interface in future browsers will greatly reduce
     the risk of impersonation by various kinds of
     social engineering attacks, in a manner similar to that of the
     "green&nbsp;padlock" for Extended Validation TLS certificates.
     </t>

     <t>
     Technically, the authentication scheme proposed in this document 
     is a general framework for using password-based authenticated key
     exchange (PAKE) and similar stronger cryptographic primitives with HTTP.
     The two key features shown above correspond to the nature of PAKE.
     </t>

  <section title="Terminology">

    <t>The key words "MUST", "MUST&nbsp;NOT", "REQUIRED", "SHALL",
    "SHALL&nbsp;NOT", "SHOULD", "SHOULD&nbsp;NOT", "RECOMMENDED",
    "NOT&nbsp;RECOMMENDED", "MAY", and "OPTIONAL" in this document
    are to be interpreted as described in <xref target="RFC2119" />.</t>

    <t>This document distinguishes the terms "client" and "user" in the
    following way: a "client" is an entity that understands and
    implements HTTP and the specified authentication protocol --
    usually computer software; a "user" is typically a human being who
    wants to access data resources using a "client".</t>

    <t>The term "natural numbers" refers to the non-negative integers
    (including zero) throughout this document.</t>

    <t>This document treats both the input (domain) and the output (codomain)
    of hash functions as octet strings. When a natural number output for
    a hash function is required, it will be written as INT(H(s)).</t>

  </section>

  <section title="Document Structure and Related Documents">
    <t>
       The entire document is organized as follows:

       <list style="symbols">
         <t><xref target="protocol-overview" /> presents an overview of the
         protocol design.</t>

         <t>Sections <xref target="syntax" format="counter" /> through
         <xref target="srv-decision" format="counter" /> define a general
         framework of the Mutual authentication protocol. This framework is
         independent of specific cryptographic primitives.</t>

         <t><xref target="algorithms" /> describes properties needed for
         cryptographic algorithms used with this protocol framework and
         defines a few functions that will be shared among such cryptographic
         algorithms.</t>

         <t>Sections <xref target="key-provision" format="counter"/> through
         <xref target="methods-to-extend" format="counter"/> contain
         general normative and informative information about the protocol.</t>

         <t>Sections <xref target="IANA" format="counter"/> and
         <xref target="Security" format="counter"/> describe IANA
         considerations and security considerations, respectively.</t>
        </list>
     </t>

     <t>In addition, we will refer to the following two companion documents,
     as they are related to this specification:

       <list style="symbols">
            <t><xref target="RFC8121" /> defines
            cryptographic primitives that can be used with this
            protocol framework.</t>

            <t><xref target="RFC8053" /> defines small but useful
            extensions to the current HTTP authentication framework so
            that it can support application-level semantics of existing
            Web systems.</t>
       </list>
     </t>
  </section>
        
</section>

<section anchor="protocol-overview" title="Protocol Overview">

<t>
The protocol, as a whole, is designed as a natural extension to
<xref target="RFC7230">HTTP</xref> and uses the framework defined
in <xref target="RFC7235" />.  Internally, the server and the client
will first perform a cryptographic key exchange, using the secret
password as a "tweak" to the exchange.  The key exchange will only
succeed when the secrets used by both peers are correctly related
(i.e., generated from the same password). Then, both peers will verify
the authentication results by confirming the sharing of the
exchanged key.  This section provides a brief outline of the protocol
and the exchanged messages.
</t>

<section anchor="messages-sec2-1" title="Messages">

<t>The authentication protocol uses six kinds of messages to
perform mutual authentication.
These messages have specific names within this specification.

<list style="symbols">
          <t>Authentication request messages: used by the servers to
          request that clients start mutual authentication.
              <list style="symbols">
              <t>&_401-INIT; message: a general message to start the
              authentication protocol.  It is also used as a message
              indicating an authentication failure.</t>
              <t>&_401-STALE; message: a message indicating that
              the client has to start a new key exchange.</t>
              </list>
          </t>
          <t>Authenticated key exchange messages: used by both peers to
          perform authentication and the sharing of a cryptographic secret.
              <list style="symbols">
              <t>&_req-KEX-C1; message: a message sent from the client.</t>
              <t>&_401-KEX-S1; message: an intermediate response to a
              &_req-KEX-C1; message from the server.</t>
              </list>
          </t>
          <t>Authentication verification messages: used by both peers to
          verify the authentication results.
              <list style="symbols">
              <t>&_req-VFY-C; message: a message used by the client to
              request that the server authenticate and authorize the
              client.</t>
              <t>&_200-VFY-S; message: a response used by the server to
              indicate that client authentication succeeded.
              It also contains information necessary for the client to check
              the authenticity of the server.</t>
              </list>
          </t>
</list>
</t>

<t>
In addition to the above six kinds of messages, a request or response
without any HTTP headers related to this specification will be
hereafter called a "normal&nbsp;request" or "normal&nbsp;response",
respectively.
</t>
</section>

<section title="Typical Flows of the Protocol">

<t>In typical cases, client access to a resource protected by the
Mutual&nbsp;authentication scheme will use the following
protocol sequence:</t>

<figure anchor="figure-flows-1" title="Typical Communication Flow for First Access to Resource">
<artwork><![CDATA[
       Client                                 Server
         |                                      |
         |  ---- (1) normal request --------->  |
     GET / HTTP/1.1                             |
         |                                      |
         |  <---------------- (2) 401-INIT ---  |
         |            401 Unauthorized          |
         |            WWW-Authenticate: Mutual realm="a realm"
         |                                      |
[user,   |                                      |
 pass]-->|                                      |
         |  ---- (3) req-KEX-C1 ------------->  |
     GET / HTTP/1.1                             |
     Authorization: Mutual user="john",         |--> [user DB]
                    kc1="...", ...              |<-- [user info]
         |                                      |
         |  <-------------- (4) 401-KEX-S1 ---  |
         |           401 Unauthorized           |
         |           WWW-Authenticate: Mutual sid=..., ks1="...", ...
         |                                      |
     [compute] (5) compute session secret   [compute]
         |                                      |
         |                                      |
         |  ---- (6) req-VFY-C -------------->  |
     GET / HTTP/1.1                             |--> [verify (6)]
     Authorization: Mutual sid=...,             |<-- OK
                    vkc="...", ...              |
         |                                      |
         |  <--------------- (7) 200-VFY-S ---  |
[verify  |           200 OK                     |
  (7)]<--|           Authentication-Info: Mutual vks="..."
         |                                      |
         v                                      v
]]></artwork>
</figure>

<t>
<list style="symbols">
   <t>As is typical in general HTTP protocol designs, a client will
   at first request a resource without any authentication attempt (1).
   If the requested resource is protected by the Mutual authentication
   protocol, the server will respond with a message requesting
   authentication (&_401-INIT;) (2).
   </t>
   <t> 
   The client processes the body of the message and waits for
   the user to input the username and password. If the username
   and password are available, the client will send a message with
   the authenticated key exchange (&_req-KEX-C1;) to start the
   authentication (3).
   </t>

   <t>If the server has received a &_req-KEX-C1; message, the server
   looks&nbsp;up the user's authentication information within its user
   database. Then, the server creates a new session identifier (sid)
   that will be used to identify sets of the messages that follow it
   and responds with a message containing a server&nbhy;side
   authenticated key exchange value (&_401-KEX-S1;) (4).
   </t>

   <t>
   At this point (5), both peers calculate a shared "session secret"
   using the exchanged values in the key exchange messages. Only when
   both the server and the client have used secret credentials
   generated from the same password will the session secret values match.
   This session secret will be used for access authentication of
   every individual request/response pair after this point.
   </t>

   <t>The client will send a request with a client-side authentication
   verification value (&_req-VFY-C;) (6), calculated from the
   client-generated session secret. The server will check the
   validity of the verification value using its own version of the
   session&nbsp;secret.</t>

   <t>If the authentication verification value from the client was correct,
   then the client definitely owns the credential based on the expected
   password (i.e., the client authentication succeeded). The server will
   respond with a successful message (&_200-VFY-S;) (7). Unlike the
   usual one-way authentication (e.g., HTTP Basic authentication
   or <xref target="RFC1939">POP APOP authentication</xref>), this
   message also contains a server-side authentication verification value.
   <vspace blankLines="1" />
   When the client's verification value is incorrect (e.g.,&nbsp;because
   the user-supplied password was incorrect), the server will respond
   with a &_401-INIT; message (the same message as the message used
   in&nbsp;(2)) instead.
   </t>

   <t>The client MUST first check the validity of the server-side
   authentication verification value contained in the message (7).
   If the value was equal to the expected value, server authentication
   succeeded.
       <vspace blankLines="1" />
       If it is not the expected value or the message does not contain
       the authentication verification value, then the mutual authentication
       has been broken for some unexpected reason. The client
       MUST&nbsp;NOT process any body or header values contained in the
       HTTP response in this case. (Note: This case should not happen
       between a correctly implemented server and client without any
       active attacks; such a scenario could be caused by either a
       man&nbhy;in&nbhy;the&nbhy;middle attack or incorrect implementation.)
   </t>
</list>
</t>

</section>
<section title="Alternative Flows">

<t>
As shown above, the typical flow for a first authentication request
requires three request-response pairs. To reduce protocol overhead,
the protocol enables several shortcut flows that require fewer messages.

<list style="symbols">  
<t>
Case A: If the client knows that the resource is likely to
require authentication, the client MAY omit the first
unauthenticated request (1) and immediately send a key exchange
(&_req-KEX-C1;) message. This will reduce the number of
round&nbsp;trips by one.
</t>
<t>
Case B: If both the client and the server previously shared a
session secret associated with a valid sid, the client MAY directly
send a &_req-VFY-C; message using the existing sid and corresponding
session secret. This will further reduce the number of round&nbsp;trips
by one.
<vspace blankLines="1" />
The server MAY have thrown out the corresponding session from
the session table. If so, the server will respond with
a &_401-STALE; message, indicating that a new key exchange is required.
The client SHOULD try again to construct a &_req-KEX-C1; message in
this&nbsp;case.
</t>
</list>
</t>

<t>
<xref target="figure-flows-2" /> depicts the shortcut flows described
above. When using appropriate settings and implementations, most of the
requests to resources are expected to meet both criteria; thus,
only one round&nbsp;trip of request/response will be required.
</t>

<figure anchor="figure-flows-2" title="Several Alternative Protocol Flows">
<artwork><![CDATA[
  Case A: Omit first request
          (2 round trips)
   
     Client            Server 
     |                      |
     | --- req-KEX-C1 ----> |
     |                      |
     | <---- 401-KEX-S1 --- |
     |                      |
     | ---- req-VFY-C ----> |
     |                      |
     | <----- 200-VFY-S --- |
     |                      |
   
  Case B: Reuse session secret (re-authentication)

      (B-1) key available        (B-2) key expired
            (1 round trip)             (3 round trips)
                                                      
     Client            Server   Client              Server
     |                      |   |                        |
     | ---- req-VFY-C ----> |   | --- req-VFY-C -------> |
     |                      |   |                        |
     | <----- 200-VFY-S --- |   | <------- 401-STALE --- |
     |                      |   |                        |
                                | --- req-KEX-C1 ------> |
                                |                        |
                                | <------ 401-KEX-S1 --- |
                                |                        |
                                | --- req-VFY-C -------> |
                                |                        |
                                | <------- 200-VFY-S --- |
                                |                        |
]]></artwork>
</figure>

<t>
For more details, see Sections <xref target="cli-decision" format="counter"/>
and <xref target="srv-decision" format="counter" />.
</t>
</section>
</section>

<section anchor="syntax" title="Message Syntax">

<t>Throughout this specification, the syntax is denoted in the
   extended augmented BNF syntax as defined in <xref target="RFC7230"/>
   and <xref target="RFC5234"/>. The following elements are used in
   this document per <xref target="RFC5234"/>, <xref target="RFC7230"/>,
   and <xref target="RFC7235" />: DIGIT, ALPHA, SP, auth&nbhy;scheme,
   quoted&nbhy;string, auth&nbhy;param, header&nbhy;field, token,
   challenge, and credentials.
</t>

<t>
The Mutual authentication protocol uses three headers: &_WWW-Authenticate;
(usually in responses with a 401 status code), Authorization (in requests),
and &_Authentication-Info; (in responses other than a 401 status code).
These headers follow the frameworks described
in <xref target="RFC7235" /> and <xref target="RFC7615" />. See
<xref target="messages"/> for more details regarding these headers.
</t>

<t>
The framework in <xref target="RFC7235" /> defines the syntax for
the headers &_WWW-Authenticate; and Authorization as the syntax elements
"challenge" and "credentials", respectively. The auth&nbhy;scheme
element contained in those headers MUST be set to "Mutual" when using the
protocol specified in this document. The syntax for "challenge" and
"credentials" to be used with the "Mutual" auth&nbhy;scheme SHALL be
name&nbhy;value pairs (#auth&nbhy;param), not the "token68" parameter
defined in <xref target="RFC7235" />.
</t>

<t>
The Authentication-Info header used in this protocol SHALL follow
the syntax defined in <xref target="RFC7615" />.
</t>

<t>
In HTTP, the &_WWW-Authenticate; header may contain two or more challenges.
Client implementations SHOULD be aware of, and be capable of correctly
handling, those cases.
</t>

<section title="Non-ASCII Extended Header Parameters">
<t>
All of the parameters contained in the above three headers, except for
the "realm" field, MAY be extended to ISO 10646&nbhy;1 values using the
framework described in <xref target="RFC5987" />. All servers and
clients MUST be capable of receiving and sending values encoded per
the syntax specified in <xref target="RFC5987" />.
</t>
<t>
If a value to be sent contains only ASCII characters, the field MUST be sent
using plain syntax as defined in RFC&nbsp;7235. The syntax as extended by
RFC&nbsp;5987 MUST&nbsp;NOT be used in this case.
</t>
<t>
If a value (except for the "realm" header) contains one or more
non&nbhy;ASCII characters, the parameter SHOULD be sent using the
syntax defined in Section&nbsp;3.2 of <xref target="RFC5987"/> as
"ext&nbhy;parameter". Such a parameter MUST have a charset value of
"UTF&nbhy;8", and the language value MUST always be omitted (have
an empty value). The same parameter MUST&nbsp;NOT be sent more than
once, regardless of the syntax used.
</t>
<t>
For example, a parameter "user" with the value "Renee of France" SHOULD be
sent as &lt; user="Renee of France" &gt;.  If the value is
"Ren&lt;e&nbsp;acute&gt;e of France", it SHOULD be
sent as &lt;&nbsp;user*=UTF&nbhy;8''Ren%C3%89e%20of%20France &gt; instead.
</t>
<t>
<xref target="RFC7235" /> requires that the "realm" parameter be in its
plain form (not as an extended "realm*" parameter), so the syntax
specified in RFC&nbsp;5987 MUST&nbsp;NOT be used for this parameter.
</t>

</section>

<section title="Values">

<t>
The parameter values contained in challenges or credentials MUST be
parsed in strict conformance with HTTP semantics (especially the
unquoting of string parameter values).  In this protocol, those
values are further categorized into the following value types:
tokens&nbsp;(bare&nbhy;token and extensive&nbhy;token), string, integer,
hex&nbhy;fixed&nbhy;number, and base64&nbhy;fixed&nbhy;number.
</t>

<t>
For clarity, it is RECOMMENDED that implementations use the canonical
representations specified in the following subsections for sending
values.  However, recipients MUST accept both quoted and unquoted
representations interchangeably, as specified in HTTP.
</t>

<section title="Tokens">
<t>
For sustaining both security and extensibility at the same time, this
protocol defines a stricter sub-syntax for the "token" to be used.
Extensive-token values SHOULD use the following syntax (after the
parsing of HTTP values):
</t>

<figure anchor="figure-syntax" title="BNF Syntax for Token Values">
<artwork type="abnf">
   bare-token           = bare-token-lead-char *bare-token-char
   bare-token-lead-char = %x30-39 / %x41-5A / %x61-7A
   bare-token-char      = %x30-39 / %x41-5A / %x61-7A / "-" / "_"
   extension-token      = "-" bare-token 1*("." bare-token)
   extensive-token      = bare-token / extension-token
</artwork>
</figure>

<t>
The tokens (bare-token and extension-token) are case insensitive.
Senders SHOULD send these in lower case, and receivers MUST accept
both upper and lower cases. When tokens are used as (partial) inputs
to any hash functions or other mathematical functions, they MUST
always be used in lower case.
</t>

<t>
Extensive-tokens are used in this protocol where the set of acceptable
tokens may include non&nbhy;standard extensions.  Any extension of
this protocol MAY use either the bare&nbhy;tokens allocated by
IANA (see the procedure described in <xref target="IANA" />) or
extension&nbhy;tokens with the format
"-&lt;bare-token&gt;.&lt;domain&nbhy;name&gt;", where &lt;domain-name&gt;
is a valid (sub)domain name on the Internet owned by the party
who defines the extension.
</t>

<t>Bare-tokens and extensive-tokens are also used for parameter names, in the
unquoted form. Requirements for using the extension-token for the parameter
names are the same as those described in the previous paragraph.</t>

<t>The canonical format for bare-tokens and extensive-tokens is the unquoted
representation.</t>

</section>

<section anchor="syntax-string" title="Strings">

<t>
All character strings MUST be encoded to octet strings
using <xref target="RFC3629">UTF-8 encoding</xref> for
the <xref target="Unicode">Unicode character set</xref>.
Such strings MUST&nbsp;NOT contain any leading Byte Order Marks (BOMs)
(also known as ZERO WIDTH NO-BREAK SPACE, U+FEFF, or EF BB BF).
It is RECOMMENDED that both peers reject any invalid UTF-8 sequences that
might cause decoding ambiguities (e.g., containing &lt;&quot;&gt; in the
second or subsequent bytes of the UTF&nbhy;8 encoded characters).
</t>

<t>
If strings represent a domain name or URI that contains non&nbhy;ASCII
characters, the host parts SHOULD be encoded as they (the parts) are
used in the HTTP protocol layer (e.g.,&nbsp;in a Host: header);
per current standards, the A&nbhy;label as defined
in <xref target="RFC5890"/> will be used. Lowercase ASCII characters
SHOULD be used.
</t>

<t>The canonical format for strings is quoted-string (as it may 
contain equals signs ("="), plus signs ("+"), and slashes ("/")),
unless the parameter containing the string value will use
extended syntax as defined in <xref target="RFC5987" />. (Per
<xref target="RFC5987" />, an extended parameter will have an
unquoted encoded value.)
</t>

</section>

<section anchor="sec-numbers" title="Numbers">

<t>The following syntax definitions provide a syntax for numeric values:</t>

<figure anchor="figure-syntax-numbers" title="BNF Syntax for Numbers">
<artwork type="abnf">
 integer             = "0" / (%x31-39 *DIGIT)     ; no leading zeros
 hex-fixed-number    = 1*(2(DIGIT / %x41-46 / %x61-66))
 base64-fixed-number = 1*( ALPHA / DIGIT / "+" / "/" ) 0*2"="
</artwork>
</figure>

<t>
The syntax definition of the integers only allows representations
that do not contain leading zeros.
</t>

<t>
A number represented as a hex-fixed-number MUST include an even number of
hexadecimal digits (i.e., multiples of eight bits). Those values are
case&nbsp;insensitive and SHOULD be sent in lower case. When these
values are generated from any cryptographic values, they MUST have
their "natural length"; if they are generated from a hash function,
their lengths correspond to the hash size; if they represent elements
of a mathematical set (or group), their lengths SHALL be the
shortest lengths that represent all the elements in the set.
For example, the results of the SHA&nbhy;256 hash function will be
represented by 64&nbsp;digits, and any elements in a
2048&nbhy;bit prime field (modulo a 2048&nbhy;bit integer) will be
represented by 512&nbsp;digits, regardless of how many zeros appear
in front of such representations. Session identifiers and other
non&nbhy;cryptographically generated values are represented in any
(even) length determined by the side that generates it first, and the
same length MUST be used in all communications by both peers.
</t>

<t>
The numbers represented as base64-fixed-number SHALL be generated as
follows: first, the number is converted to a big&nbhy;endian radix&nbhy;256
binary representation as an octet string.  The length of the
representation is determined in the same way as the technique
mentioned above. Then, the string is encoded using base64 encoding
(described in Section&nbsp;4 of <xref target="RFC4648"/>)
without any spaces and newlines. Implementations decoding
base64&nbhy;fixed&nbhy;number SHOULD reject any input data with
invalid characters, excess or insufficient padding, or
non&nbhy;canonical pad bits (see Sections&nbsp;3.1 through
3.5 of <xref target="RFC4648" />).
</t>

<t>The canonical format for integer and hex-fixed-number is
unquoted tokens, and the canonical format for
base64&nbhy;fixed&nbhy;number is quoted&nbhy;string.</t>

</section>

</section>

</section>

<section title="Messages" anchor="messages">

<t>
In this section, we define the six kinds of messages in the
authentication protocol, along with the formats and requirements
of the headers for each type of message.
</t>

<t>
To determine under what circumstances each message is expected to be sent,
see Sections&nbsp;<xref target="cli-decision" format="counter" /> and
<xref target="srv-decision" format="counter" />.</t>

<t>
In the descriptions below, the types of allowable values for each header
parameter are shown in parentheses after each parameter name.  The
"algorithm&nbhy;determined" type means that the acceptable value for the
parameter is one of the types defined in <xref target="syntax" /> and is
determined by the value of the "algorithm" parameter. The parameters
marked "mandatory" SHALL be contained in the message. The parameters
marked "non&nbhy;mandatory" MAY be either contained in the message or
omitted from it. Each parameter SHALL appear in each header exactly once
at&nbsp;most.
</t>

<t>
All credentials and challenges MAY contain any parameters not
explicitly specified in the following sections. Recipients that do not
understand such parameters MUST silently ignore them. However, all
credentials and challenges MUST meet the following criteria:
<list style="symbols" hangIndent="3">
<t>
For responses, the parameters "reason", any "ks#" (where "#" stands for any
decimal integer), and "vks" are mutually exclusive; any challenges
MUST&nbsp;NOT contain two or more parameters among them.  They MUST&nbsp;NOT
contain any "kc#" or "vkc" parameters.
</t>
<t>
For requests, the parameters "kc#" (where "#" stands for any decimal
integer) and "vkc" are mutually exclusive; any challenges MUST&nbsp;NOT
contain two or more parameters among them.  They MUST&nbsp;NOT contain
any "ks#" or "vks" parameters.
</t>
</list>
</t>

<t>
Every message defined in this section contains a "version" field to 
detect any future revisions of the protocol that are incompatible.
Implementations of the protocol described in this specification
MUST always send a token "&_Protocol_version_token;" to represent
the version number. Recipients MUST reject messages that contain
any other value for the version, unless another specification defines
specific behavior for that version.
</t>

<section title="401-INIT and 401-STALE" anchor='_401-INIT'>

<t>
Every &_401-INIT; or &_401-STALE; message SHALL be a valid
HTTP&nbsp;401 (Unauthorized) status message (or some other
4xx status message, if appropriate) containing one and only one
(hereafter not explicitly noted) &_WWW-Authenticate; header
containing a "reason" parameter in the challenge. The challenge
SHALL contain all of the parameters marked "mandatory" below and
MAY contain those marked "non&nbhy;mandatory".</t>

<t><list style="hanging" hangIndent="3">

<t hangText="version:"><vspace blankLines="0"/>
   (mandatory extensive-token) should be the token
   "&_Protocol_version_token;".</t>

<t hangText="algorithm:"><vspace blankLines="0"/>
   (mandatory extensive-token) specifies the authentication algorithm
   to be used. The value MUST be one of the tokens specified
   in <xref target="RFC8121" /> or another supplemental specification.</t>

<t hangText="validation:"><vspace blankLines="0"/>
   (mandatory extensive-token) specifies the method of host validation.
   The value MUST be one of the tokens described in
   <xref target="validation" /> or the tokens specified in
   another supplemental specification.</t>

<t hangText="auth-scope:"><vspace blankLines="0"/>
   (non-mandatory string) specifies the authentication scope, i.e.,
   the set of hosts for which the authentication credentials are valid.
   It MUST be one of the strings described in <xref target="authrealm"/>.
   If the value is omitted, it is assumed to be the
   "single&nbhy;server type" domain as described
   in <xref target="authrealm"/>.</t>

<t hangText="realm:"><vspace blankLines="0"/>
   (mandatory string) is a string representing the name of
   the authentication realm inside the authentication scope.  As
   specified in <xref target="RFC7235" />, this value MUST always be sent
   in the quoted-string form, and an encoding as specified in
   <xref target="RFC5987" /> MUST&nbsp;NOT be used.
   <vspace blankLines="1" />
    The realm value sent from the server SHOULD be an ASCII string.
    Clients MAY treat any non&nbhy;ASCII value received in this field
    as a binary blob, an NFC&nbhy;normalized UTF-8 string ("NFC" stands
    for "Normalization Form C"), or an error.</t>

<t hangText="reason:"><vspace blankLines="0"/>
   (mandatory extensive-token) SHALL be an extensive&nbhy;token that
   describes the possible reason for the failed authentication or
   authorization. Both servers and clients SHALL understand and
   support the following three tokens:
            <list style="symbols" hangIndent="3">
                <t>initial: Authentication was not attempted because
                there was no &_Authorization; header in the corresponding
                request.</t>

                <t>stale-session: The provided sid in the request was either
                unknown to the server or expired in the server.</t>

                <t>auth-failed: The authentication trial failed for some
                reason, possibly because of a bad authentication
                credential.</t>

            </list>
            Implementations MAY support the following tokens or any
            extensive&nbhy;tokens defined outside of this specification.
            If clients receive any unknown tokens, they SHOULD treat
            them as if they were "auth&nbhy;failed" or "initial".

            <list style="symbols" hangIndent="3">
                <t>reauth-needed: The server-side application requires a new
                authentication trial, regardless of the current status.</t>

                <t>invalid-parameters: The server did not attempt
                authentication because some parameters were not
                acceptable.</t>

                <t>internal-error: The server did not attempt authentication
                because there are some problems on the server side.</t>

                <t>user-unknown: This is a special case of auth&nbhy;failed;
                it suggests that the provided username is invalid. Due to
                security implications, the use of this parameter
                is NOT&nbsp;RECOMMENDED, except for special-purpose
                applications where it would make sense to do so.</t>

                <t>invalid-credential: This is another special case of
                auth&nbhy;failed; it suggests that the provided username
                was valid but authentication still failed. For security
                reasons, the use of this parameter is NOT&nbsp;RECOMMENDED.</t>

                <t>authz-failed: Authentication was successful, but access to
                the specified resource is not authorized to the specific
                authenticated user.  (It might be used along with either a
                401&nbsp;(Unauthorized) or 403&nbsp;(Forbidden) status code
                to indicate that the authentication result is one of the
                existing reasons for the failed authorization.)</t>

            </list>
   It is RECOMMENDED that the reason for failure be recorded to some type of
   diagnostic log, shown to the client user immediately, or both. It will
   be helpful to find out later whether the reason for the failure is
   technical or caused by user error.
</t>
</list></t>

<t>
The algorithm specified in this header will determine the types (among those
defined in <xref target="syntax" />) and the values for &_K_c1;, &_K_s1;,
&_VK_c;, and &_VK_s;.
</t>

<t>
Among these messages, any messages with the "reason" parameter value
"stale&nbhy;session" will be called "&_401-STALE;" messages hereafter,
because these messages have a special meaning in the protocol flow.
Messages with any other "reason" parameters will be called
"&_401-INIT;" messages.
</t>

</section>

<section title="req-KEX-C1">

<t>
Every &_req-KEX-C1; message SHALL be a valid HTTP request message containing
an Authorization header with a credential containing a "kc1" parameter.
</t>

<t>
The credential SHALL contain the parameters with the following names:
</t>

<t>
<list style="hanging" hangIndent="3">

<t hangText="version:"><vspace blankLines="0"/>
 (mandatory, extensive-token) should be the token "&_Protocol_version_token;".
</t>

<t hangText="algorithm, validation, auth-scope, realm:"><vspace blankLines="0"/>
 MUST be the same values as those received from the server.
</t>

<t hangText="user:"><vspace blankLines="0"/>
  (mandatory, string) is the UTF-8 encoded name of the user.  The
  string SHOULD be prepared according to the method presented
  in <xref target="sec-normalize" />.
</t>

<t hangText="kc1:"><vspace blankLines="0"/>
  (mandatory, algorithm-determined) is the client-side key exchange
  value &_K_c1;, which is specified by the algorithm that is used.
</t>
</list>
</t>

</section>

<section title="401-KEX-S1">

<t>
Every &_401-KEX-S1; message SHALL be a valid HTTP 401 (Unauthorized)
status response message containing a &_WWW-Authenticate; header with a
challenge containing a "ks1" parameter.
</t>

<t>
The challenge SHALL contain the parameters with the following names:
</t>

<t>
<list style="hanging" hangIndent="3">
<t hangText="version:"><vspace blankLines="0"/>
  (mandatory, extensive-token) should be the token
  "&_Protocol_version_token;".
</t>

<t hangText="algorithm, validation, auth-scope, realm:"><vspace blankLines="0"/>
  MUST be the same values as those received from the client.
</t>

<t hangText="sid:"><vspace blankLines="0"/>
  (mandatory, hex-fixed-number) MUST be a session identifier,
  which is a random integer.  The sid SHOULD have uniqueness of at
  least 80&nbsp;bits or the square of the maximum estimated transactions
  concurrently available in the session table, whichever is
  larger.  See <xref target="session" /> for more details.
</t>

<t hangText="ks1:"><vspace blankLines="0"/>
  (mandatory, algorithm-determined) is the server-side key
  exchange value &_K_s1;, which is specified by the algorithm.
</t>

<t hangText="nc-max:"><vspace blankLines="0"/>
  (mandatory, integer) is the maximum value of nonce numbers
  that the server accepts.

</t>

<t hangText="nc-window:"><vspace blankLines="0"/>
  (mandatory, integer) is the number of available nonce number slots
  that the server will accept. It is RECOMMENDED that the value of
  the "&_nc-window;" parameter be 128 or more.
</t>

<t hangText="time:"><vspace blankLines="0"/>
  (mandatory, integer) represents the suggested time (in&nbsp;seconds)
  that the client can reuse the session represented by the sid. It
  is RECOMMENDED that the time be set to at least 60&nbsp;(seconds).
  However, the server is not required to guarantee that the session
  represented by the sid will be available (e.g., alive, usable) for
  the time specified in this parameter.
</t>

<t hangText="path:"><vspace blankLines="0"/>
  (non-mandatory, string) specifies to which path in the URI space
  the same authentication is expected to be applied.  The value is a
  space-separated list of URIs, in the same format as that specified in
  the "domain" parameter <xref target="RFC7616" /> for
  Digest authentications.  All path elements contained in the
  "path" parameter MUST be inside the specified auth-scope; if not,
  clients SHOULD ignore such elements. For better performance, it is
  important that clients recognize and use this parameter.
</t>
</list>
</t>

</section>

<section title="req-VFY-C">

<t>
Every &_req-VFY-C; message SHALL be a valid HTTP request message
containing an &_Authorization; header with a credential containing a
"vkc" parameter.
</t>

<t>
The parameters contained in the header are as follows:

<list style="hanging" hangIndent="3">
<t hangText="version:"><vspace blankLines="0"/>
  (mandatory, extensive-token) should be the
  token "&_Protocol_version_token;".
</t>

<t hangText="algorithm, validation, auth-scope, realm:"><vspace
blankLines="0"/>
  MUST be the same values as those received from the server for the session.
</t>

<t hangText="sid:"><vspace blankLines="0"/>
  (mandatory, hex-fixed-number) MUST be one of the sid values that was
  received from the server for the same authentication realm.
</t>

<t hangText="nc:"><vspace blankLines="0"/>
  (mandatory, integer) is a nonce request number that is unique among
  the requests sharing the same sid.  The values of the nonce numbers
  SHOULD satisfy the properties outlined in <xref target="session" />.
</t>

<t hangText="vkc:"><vspace blankLines="0"/>
  (mandatory, algorithm-determined) is the client-side authentication
  verification value &_VK_c;, which is specified by the algorithm.
</t>
</list>
</t>

</section>

<section title="200-VFY-S">

<t>
Every &_200-VFY-S; message SHALL be a valid HTTP message that
does not have a 401 (Unauthorized) status code and SHALL contain
an &_Authentication-Info; header with a "vks" parameter.
</t>

<t>
The parameters contained in the header are as follows:
</t>

<t>
<list style="hanging" hangIndent="3">

<t hangText="version:"><vspace blankLines="0"/>
  (mandatory, extensive-token) should be the token
  "&_Protocol_version_token;".
</t>

<t hangText="sid:"><vspace blankLines="0"/>
  (mandatory, hex-fixed-number) MUST be the value received from the client.
</t>

<t hangText="vks:"><vspace blankLines="0"/>
  (mandatory, algorithm-determined) is the server-side authentication
  verification value &_VK_s;, which is specified by the algorithm.
</t>
</list>
</t>

<t>
The header MUST be sent before the content body; it MUST&nbsp;NOT be
sent in the trailer of a chunked-encoded response. If a
"100&nbsp;(Continue)" <xref target="RFC7231"/> response
is sent from the server, the &_Authentication-Info; header
SHOULD be included in that response instead of the final response.  
</t>

</section>

</section>

<section title="Authentication Realms" anchor="authrealm">

<t>
In this protocol, an authentication realm is defined as a set of
resources (URIs) for which the same set of usernames and passwords is valid.
If the server requests authentication for an authentication realm
for which the client is already authenticated, the client will
automatically perform the authentication using the already&nbhy;known
credentials. However, for different authentication realms, clients
MUST&nbsp;NOT automatically reuse usernames and passwords for another realm.
</t>

<t>
As is the case for the Basic and Digest access authentication protocols,
the Mutual authentication protocol supports multiple, separate
protection spaces to be set up inside each host.  Furthermore, the
protocol allows a single authentication realm to span several hosts
within the same Internet domain.
</t>

<t>
Each authentication realm is defined and distinguished by the triple of an
authentication&nbsp;algorithm, an authentication&nbsp;scope, and a
"realm"&nbsp;parameter.
However, it is NOT&nbsp;RECOMMENDED that
server operators use the same pair of an authentication&nbsp;scope and a
realm with different authentication algorithms.
</t>

<t>
The "realm" parameter is a string as defined in <xref target="messages" />.
Authentication scopes are described in the remainder of this section.
</t>

<t>
An authentication scope specifies the range of hosts spanned by the
authentication realm. In this protocol, it MUST be one of the
following kinds of strings:

<list style="symbols" hangIndent="3">
  <t>Single-server type: A string in the format
  "&lt;scheme&gt;://&lt;host&gt;" or
  "&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;",
     where &lt;scheme&gt;, &lt;host&gt;, and &lt;port&gt; are
     the corresponding URI parts of the request&nbsp;URI. If the
     default port (i.e., 80 for HTTP and 443 for HTTPS) is
     used for the underlying HTTP communications, the port part
     MUST be omitted, regardless of whether it was present in the
     request&nbsp;URI. In all other cases, the port part MUST be present,
     and it MUST&nbsp;NOT contain leading zeros. Use this format when
     authentication is only valid for a specific protocol
     (such as HTTPS). This format is equivalent to the ASCII
     serialization of a Web origin, as presented in
     Section&nbsp;6.2 of <xref target="RFC6454" />.
  </t>
  <t>Single-host type: The "host" part of the requested URI. This is the
  default value. Authentication realms within this kind of authentication
  scope will span several protocols (e.g., HTTP and HTTPS) and ports but
  will not span different hosts.

  </t>
  <t>Wildcard-domain type: 
     A string in the format "*.&lt;domain&nbhy;postfix&gt;", where
     &lt;domain&nbhy;postfix&gt; is either the host part of the
     requested URI or any domain in which the requested host is
     included (this means that the specification "*.example.com" is
     valid for all of hosts "www.example.com", "web.example.com",
     "www.sales.example.com", and "example.com"). The domain-postfix
     sent by the servers MUST be equal to or included in a valid
     Internet domain assigned to a specific organization; if clients
     know, via some means such as a blacklist for
     <xref target="RFC6265">HTTP cookies</xref>, that the specified
     domain is not to be assigned to any specific organization
     (e.g., "*.com" or "*.jp"), it is RECOMMENDED that clients reject the
     authentication request.
  </t>
</list>
</t>

<t>
In the above specifications, every "scheme", "host", and "domain" MUST
be in lower case, and any internationalized domain names beyond the ASCII
character set SHALL be represented in the way they are sent in the
underlying HTTP protocol, represented in lowercase characters,
i.e.,&nbsp;these domain names SHALL be in the form of LDH ("letters, digits,
hyphen") labels as defined in <xref target="RFC5890">the Internationalized
Domain Names for Applications (IDNA) specification</xref>. A "port" MUST
be given in shortest unsigned decimal number notation. Not obeying
these requirements will cause valid authentication attempts to fail.
</t>

<section title="Resolving Ambiguities">
<t>
In the above definitions of authentication scopes, several scopes may overlap
each other. If a client has already been authenticated to several realms
applicable to the same server, the client may have multiple lists of the
"path" parameters received with the "&_401-KEX-S1;" message (see <xref
target="messages" />). If these path lists have any overlap, a single URI may
belong to multiple possible candidate realms to which the client can be
authenticated. In such cases, clients face an ambiguous choice regarding
which credentials to send for a new request (see Steps&nbsp;3 and 4 of the
decision procedure presented in <xref target="cli-decision" />).
</t>

<t>
In such cases, a client MAY freely send requests that belong to any of
these candidate realms, or it MAY simply send an unauthenticated request
and see for which realm the server requests an authentication. It is
RECOMMENDED that server operators provide properly configured
"path" parameters (more precisely, disjoint path sets for each realm)
for clients so that such ambiguities will not occur.
</t>

<t>
The following procedure is one possible tactic for resolving ambiguities
in such cases:
<list style="symbols" hangIndent="3">
  <t>If the client has previously sent a request to the same URI and
      it remembers the authentication realm requested by the
      &_401-INIT; message at that time, use that realm.
  </t>
  <t>In other cases, use one of the authentication realms representing
      the most-specific authentication scopes.
      The list of possible domain specifications shown above is
      given from most specific to least specific.
      <vspace blankLines="1" />
      If there are several choices with different wildcard-domain
      specifications, the one that has the longest domain-postfix has priority
      over those with shorter domain-postfixes.
  </t>
  <t>If there are realms with the same authentication scope,
      there is no defined priority; the client MAY choose any one of the
      possible choices.
  </t>
</list>
</t>
</section>

</section>

<section title="Session Management" anchor="session">

<t>
In the Mutual authentication protocol, a session represented by
an&nbsp;sid is set up using four messages (first request,
&_401-INIT;, &_req-KEX-C1;, and &_401-KEX-S1;), after which a
session&nbsp;secret (z) associated with the session is established.
After mutually establishing a session secret, this session, along with
the secret, can be used for one or more requests for resources
protected by the same realm on the same server.  Note that
session management is only an inside detail of the protocol and
usually not visible to normal users.  If a session expires, the client
and server SHOULD automatically re&nbhy;establish another session
without informing the user.
</t>

<t>
Sessions and session identifiers are local to each server (defined by
scheme, host, and port), even if an authentication scope covers
multiple servers; clients MUST establish separate sessions for each port of a
host to be accessed.  Furthermore, sessions and identifiers are also local to
each authentication realm, even if they are provided by the same server.
The same session identifiers provided either from different servers or
for different realms MUST be treated as being independent of each other.
</t>

<t>
The server SHOULD accept at least one &_req-VFY-C; request for each session
if the request reaches the server in a time window specified by the
"timeout" parameter in the &_401-KEX-S1; message and if there are no
emergent reasons (such as flooding attacks) to forget the session. After
that, the server MAY discard any session at any time and MAY send
&_401-STALE; messages for any further &_req-VFY-C; requests received
for that session.
</t>

<t>
The client MAY send two or more requests using a single session
specified by the sid.  However, for all such requests, each value of the
nonce number (in the "nc" parameter) MUST satisfy the following conditions:

<list style="symbols" hangIndent="3">
  <t>It is a natural number.</t>
  <t>The same nonce number was not sent within the same session.</t>
  <t>It is not larger than the nc-max value that was
     sent from the server in the session represented by the sid.</t>
  <t>It is larger than (largest-nc &minus; nc-window),
     where largest-nc is the largest value of nc that was
     previously sent in the session and nc-window is the value of the
     "nc-window" parameter that was received from the server for
     the session.</t>
</list>
</t>

<t>
The last condition allows servers to reject any nonce numbers that are
"significantly" smaller than the "current" value (defined by the value
of nc-window) of the nonce number used in the session involved.  In other
words, servers MAY treat such nonce numbers as "already received".
This restriction enables servers to implement duplicate&nbhy;nonce
detection in a constant amount of memory for each session.
</t>

<t>
Servers MUST check for duplication of the received nonce numbers, and if any
duplication is detected, the server MUST discard the session and respond
with a &_401-STALE; message, as outlined in <xref target="srv-decision" />.
The server MAY also reject other invalid nonce numbers (such as those
above the nc-max limit) by sending a &_401-STALE; message.
</t>

<t>
For example, assume that the nc-window value of the current session
is 128 and nc-max is 400, and that the client has already used the
following nonce numbers: {1-120, 122, 124, 130-238, 255-360,
363-372}.  The nonce number that can then be used for the next request
is a number from the following set: {245-254, 361, 362, 373-400}.
The values {0, 121, 123, 125-129, 239-244} MAY be rejected by the
server because they are not above the current "window limit"
(244&nbsp;=&nbsp;372&nbsp;-&nbsp;128).
</t>

<t>
Typically, clients can ensure the above property by using a 
monotonically increasing integer counter that counts from zero up to the
value of nc&nbhy;max.
</t>

<t>
The values of the nonce numbers and any nonce-related values MUST always
be treated as natural numbers within an infinite range. Implementations
that use fixed-width integer representations, fixed&nbhy;precision
floating-point numbers, or similar representations SHOULD&nbsp;NOT
reject any larger values that overflow such representative limits
and MUST&nbsp;NOT silently truncate them using any modulus-like
rounding operation (e.g., by mod&nbsp;2^32). Instead, the whole
protocol is carefully designed so that recipients MAY replace any such
overflowing values (e.g., 2^80) with some reasonably large maximum
representative integer (e.g., 2^31&nbsp;-&nbsp;1 or others).
</t>

</section>

<section title="Host Validation Methods" anchor="validation">

<t>
The "validation method" specifies a method to "relate" (or "bind") the mutual
authentication processed by this protocol with other authentications
already performed in the underlying layers and to prevent man-in-the-middle attacks.
It determines the value vh that is an input to the authentication protocols.
</t>

<t>
When HTTPS or another possible secure transport is used, this corresponds
to the idea of "channel binding" as described in <xref target="RFC5929" />. 
Even when HTTP is used, similar, but somewhat limited, "binding" is
performed to prevent a malicious server from trying to authenticate
itself to another server as a valid user by forwarding the received
credentials.
</t>

<t>
The valid tokens for the "validation" parameter and corresponding values
of vh are as follows:
</t>

<t>
<list style="hanging" hangIndent="3">
 <t hangText="host:"><vspace blankLines="0"/>
       hostname validation. The value vh will be the ASCII string in the
       following format: "&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;",
       where &lt;scheme&gt;, &lt;host&gt;, and &lt;port&gt; are the
       URI components corresponding to the server-side resource
       currently being accessed. The scheme and host are in lower case,
       and the port is listed in shortest&nbsp;decimal notation. Even if the
       request&nbsp;URI does not have a port part, vh will include
       the default port number.</t>
 <t hangText="tls-server-end-point:"><vspace blankLines="0"/>
   TLS endpoint (certificate) validation. The value vh will be the octet
   string of the hash value of the server's public key certificate used
   in the underlying <xref target="RFC5246">TLS</xref> connection, processed
   as specified in Section&nbsp;4.1 of <xref target="RFC5929" />.
 </t>
 <t hangText="tls-unique:"><vspace blankLines="0"/>
 TLS shared-key validation. The value vh will be the
 channel-binding material derived from the Finished messages,
 as defined in Section&nbsp;3.1 of <xref target="RFC5929" />.
 (Note: See <xref target="sec-security-tls-unique" /> for some
 security-related notes regarding this validation method.)
</t>
</list>
</t>

<t>
If HTTP is used on a non&nbhy;encrypted channel (TCP and the
Stream Control Transmission Protocol (SCTP), for example), the
validation type MUST be "host".  If
<xref target="RFC2818">HTTP/TLS</xref> (HTTPS) is
used with a server certificate, the validation type MUST be
"&_tls-server-end-point;". If HTTP/TLS is used with an anonymous
Diffie-Hellman key exchange, the validation type MUST be
"&_tls-unique;" (see the note below).
</t>

<t>
If the validation type "&_tls-server-end-point;" is used, the
server certificate provided in the TLS connection MUST be verified at least
to make sure that the server actually owns the corresponding private key.
(Note: This verification is automatic in some RSA-based key exchanges but
is NOT automatic in Diffie-Hellman-based key exchanges with separate
exchanges for server verification.)
</t>

<t>
Clients MUST validate this parameter upon receipt of &_401-INIT; messages.
</t>

<t>
Note: The protocol defines two variants of validation on the TLS connections.
The "&_tls-unique;" method is technically more secure.
However, there are some situations where "&_tls-server-end-point;" is
preferable:
<list style="symbols">
<t>When TLS accelerating proxies are used. In this case, it is
difficult for the authenticating server to acquire the TLS key
information that is used between the client and the proxy. This is not
the case for client&nbhy;side "tunneling" proxies using the
HTTP CONNECT method.
</t>
<t>When a black-box implementation of the TLS protocol is used on
either peer.
</t>
</list>
</t>

<section title="Applicability Notes">

<t>
When the client is a Web browser with any scripting capabilities
(support of dynamic contents), the underlying TLS channel used with
HTTP/TLS MUST provide server identity verification. This means that
(1)&nbsp;anonymous Diffie&nbhy;Hellman key exchange cipher suites
MUST&nbsp;NOT be used and (2)&nbsp;verification of the server
certificate provided by the server MUST be performed. This is to
prevent loading identity-unauthenticated scripts or dynamic contents,
which are referenced from the authenticated page.
</t>

<t>
For other systems, when the underlying TLS channel used with HTTP/TLS does
not perform server identity verification, the client SHOULD ensure that
all responses are validated using the Mutual authentication protocol,
regardless of the existence of &_401-INIT; responses.
</t>
</section>

<section title="Notes on &quot;tls-unique&quot;" anchor="sec-security-tls-unique">
  <t>
    As described in the interoperability note in Section&nbsp;3.1 of
    <xref target="RFC5929"/>, the "tls&nbhy;unique" verification value
    will be changed by possible TLS renegotiation, causing an
    interoperability problem.
    TLS renegotiations are used in several HTTPS server implementations
    for enforcing some security properties (such as cryptographic strength)
    for some specific responses.
  </t>
  <t>
    If an implementation supports the "tls-unique" verification method,
    the following precautions SHOULD be taken:
    <list style="symbols" hangIndent="3">
      <t>Both peers must be aware that the vh values used for vkc
      (in &_req-VFY-C; messages) and vks (in &_200-VFY-S; messages)
      may be different.  These values MUST be retrieved from underlying
      TLS libraries each time they are used.</t>

      <t>After calculating the values vh and &_vkc; to send
      a &_req-VFY-C; request, clients SHOULD&nbsp;NOT initiate
      TLS renegotiation until the end of the corresponding response header
      is received.  An exception is that clients can and SHOULD perform
      TLS renegotiation as a response to the server's request for
      TLS renegotiation, before receipt of the beginning of the
      response header.</t>
    </list>
  </t>
  <t>
    Also, implementers MUST take care of session resumption attacks
    regarding "tls-unique" channel-binding mechanisms and master secrets.
    As a mitigation, the TLS extension defined in <xref target="RFC7627"/>
    SHOULD be used when "tls-unique" host verification is to be used.
  </t>
</section>

</section>

<section title="Authentication Extensions" anchor="auth-extensions">

<t>
It is RECOMMENDED that interactive clients (e.g., Web browsers) supporting
this protocol support non&nbhy;mandatory authentication and
the &_Authentication-Control; header defined in <xref target="RFC8053" />,
except for the "auth-style" parameter. This specification also proposes
(but does not mandate) that the default "auth-style" be "non&nbhy;modal".
Web applications SHOULD, however, consider the security impacts of the
behavior of clients that do not support these headers.
</t>

<t>
Authentication-initializing messages with the
&_Optional-WWW-Authenticate; header are used only where the &_401-INIT;
response is valid.  It will not replace other 401-type messages
such as &_401-STALE; and &_401-KEX-S1;. That is, the "reason" field
of such a message MUST be "initial" (or any extensive&nbhy;tokens
NOT defined in <xref target="_401-INIT" />).
</t>

</section>

<section anchor="sec-normalize" title="String Preparation">
<t>
For interoperability reasons, it is important that
usernames and passwords used in this protocol be binary&nbhy;comparable,
regardless of the user's input methods and/or environments.  To
ensure this, the following preparation SHOULD be performed:
<list style="symbols">
<t>
Usernames received from users SHOULD be prepared using the
"UsernameCasePreserved" profile defined in Section&nbsp;3.3 of
<xref target="RFC7613" />.
</t>
<t>
Passwords received from users SHOULD be prepared using the
"OpaqueString" profile defined in Section 4.2 of
<xref target="RFC7613" />.
</t>
</list>
</t>

<t>
In both cases, it is the sender's duty to correctly prepare the character strings.
If any non&nbhy;prepared character string is received from the other peer of the communication,
the behavior of its recipient is not defined;
the recipient MAY either accept or reject such input.
</t>

<t>
Server applications SHOULD also prepare usernames and passwords
accordingly upon registration of user credentials.
</t>

<t>
In addition, binary-based "interfaces" of implementations MAY require
and assume that the string is already prepared accordingly; 
when a string is already stored as a binary Unicode string form,
implementations MAY omit preparation and Unicode normalization (performing
UTF-8 encoding only) before using it.
When a string is already stored as an octet blob, implementations MAY
send it as is.
</t>
</section>

<section title="Decision Procedure for Clients" anchor="cli-decision">

<section title="General Principles and Requirements">
<t>
To securely implement the protocol, the client must be careful
about accepting the authenticated responses from the server.  This
also holds true for the reception of a "normal response" (a response
that does not contain mutual-authentication-related headers) from
HTTP servers.
</t>

<t>
Per typical HTTP authentication, a single user-level request may result in
the exchange of two or more HTTP requests and responses in sequence.
The following normative rules MUST be followed by the clients
implementing this protocol:
<list style="symbols">
<t>
Any kind of "normal response" MUST only be accepted for the very first
request in the sequence. Any "normal response" returned for the
second or subsequent requests in the sequence SHALL be considered invalid.
</t>
<t>
By the same principle, if any response is related to an authentication realm
that is different from that of the client's request (for example, a
&_401-INIT; message requesting authentication on another realm),
it MUST only be accepted for the very first request in the sequence.
Such a response returned for a second or subsequent request in the
sequence SHALL be considered invalid.
</t>
<t>
A &_req-KEX-C1; message MAY be sent as either an initial request or a
response to a &_401-INIT; or &_401-STALE; message.  However, to
avoid infinite loops of messages, the req-KEX-C1 message
SHOULD&nbsp;NOT be sent more than once in the sequence for a single
authentication realm. A &_401-KEX-S1; response MUST be accepted only
when the corresponding request is &_req-KEX-C1;.
</t>
<t>
A &_req-VFY-C; message MAY be sent if there is a valid session secret
shared between the client and the server, as established by &_req-KEX-C1;
and &_401-KEX-S1; messages.  If any response with a 401&nbsp;status code is
returned for such a message, the corresponding session secret SHOULD be
discarded as unusable.<vspace blankLines="1" />
In particular, upon the reception of a &_401-STALE; response, the
client SHOULD try to establish a new session by sending a
&_req-KEX-C1; message, but only once within the request/response sequence.
</t>
<t>
A &_200-VFY-S; message MUST be accepted only as a response to a
&_req-VFY-C; message and nothing else.  The &_VK_s; values of such
response messages MUST always be checked against the correct value, and
if it is incorrect, the whole response SHOULD be considered invalid.
</t>
</list>
</t>

<t>
The final status of the client request following the message exchange sequence
shall be determined as follows:
<list style="symbols">
<t>AUTH-SUCCEED: A &_200-VFY-S; message with the correct &_VK_s; value was
returned in response to the &_req-VFY-C; request in the sequence.</t>
<t>AUTH-REQUIRED: Two cases exist:
<list style="symbols">
<t>
  A &_401-INIT; message was returned from the server, and the client
  does not know how to authenticate to the given authentication realm.</t>
<t>
  A &_401-INIT; response was returned for a &_req-VFY-C; (or &_req-KEX-C1;)
  message, which means that the user&nbhy;supplied authentication
  credentials were not accepted.</t>
</list>
</t>
<t>
 UNAUTHENTICATED: A "normal response" is returned for an initial request
 of any kind in the sequence.
</t>
</list>
</t>

<t>
Any kind of response (including a "normal response") other than those
explicitly allowed in the above rules SHOULD be interpreted as a fatal
communication error.  In such cases, the clients MUST&nbsp;NOT process
any data (the response body and other content-related headers) sent from
the server.  However, to handle exceptional error cases, clients MAY
accept a message without an &_Authentication-Info; header if it has a
Server&nbsp;Error (5xx) status code.  In such cases, they SHOULD be
careful about processing the body of the content (ignoring it is still
RECOMMENDED, as it may possibly be forged by intermediate attackers),
and the client will then have a status of "UNAUTHENTICATED".
</t>

<t>
If a request is a sub-request for a resource included in another resource
(e.g., embedded images, style sheets, frames), clients MAY treat an
AUTH-REQUESTED status the same way they would treat an
UNAUTHENTICATED status.  In other words, the client MAY ignore the
server's request to start authentication with new credentials via
sub&nbhy;requests.
</t>

</section>

<section title="State Machine for the Client (Informative)">

<t>
The following state machine describes the possible request-response
sequences derived from the above normative rules. If implementers
are not quite sure of the security consequences of the above rules,
we strongly advise that the decision procedure below be followed.
In particular, clients SHOULD&nbsp;NOT accept "normal responses" unless
explicitly allowed in the rules. The labels in the steps below are
for informational purposes only.  Action entries within each step are
checked in top-to-bottom order, and the first clause satisfied is
to be followed.

<list style="hanging" hangIndent="4">
  <t hangText="Step 1 (step_new_request):"><vspace blankLines="0" />
  If the client software needs to access a new Web resource, check to
  see whether the resource is expected to be inside some
  authentication realm for which the user has already been authenticated
  via the Mutual&nbsp;authentication scheme. If yes, go to Step&nbsp;2.
  Otherwise, go to Step&nbsp;5.
  </t>

  <t hangText="Step 2:"><vspace blankLines="0" />
  Check to see whether there is an available sid for the expected
  authentication realm. If there is one, go to Step&nbsp;3. Otherwise,
  go to Step&nbsp;4.
  </t>

  <t hangText="Step 3 (step_send_vfy_1):"><vspace blankLines="0" />
  Send a &_req-VFY-C; request.
  <list style="symbols" hangIndent="3">
   <t>If a &_401-INIT; message is received with a different
   authentication realm than expected, go to Step&nbsp;6.</t>
   <t>If a &_401-STALE; message is received, go to Step 9.</t>
   <t>If a &_401-INIT; message is received, go to Step 13.</t>
   <t>If a &_200-VFY-S; message is received, go to Step 14.</t>
   <t>If a "normal response" is received, go to Step 11.</t>
  </list>
  </t>

  <t hangText="Step 4 (step_send_kex1_1):"><vspace blankLines="0" />
  Send a &_req-KEX-C1; request.
  <list style="symbols" hangIndent="3">
   <t>If a &_401-INIT; message is received with a different
   authentication realm than expected, go to Step&nbsp;6.</t>
   <t>If a &_401-KEX-S1; message is received, go to Step 10.</t>
   <t>If a &_401-INIT; message is received with the same
   authentication realm, go to Step&nbsp;13 (see Note&nbsp;1).</t>
   <t>If a "normal response" is received, go to Step 11.</t>
  </list>
  </t>

  <t hangText="Step 5 (step_send_normal_1):"><vspace blankLines="0" />
  Send a request without any mutual-authentication headers.
  <list style="symbols" hangIndent="3">
   <t>If a &_401-INIT; message is received, go to Step 6.</t>
   <t>If a "normal response" is received, go to Step 11.</t>
  </list>
  </t>

  <t hangText="Step 6 (step_rcvd_init):"><vspace blankLines="0" />
  Check to see whether the user's password for the requested
  authentication realm is known. If yes, go to Step&nbsp;7.
  Otherwise, go to Step&nbsp;12.</t>

  <t hangText="Step 7:"><vspace blankLines="0" />
  Check to see whether there is an available sid for the expected
  authentication realm. If there is one, go to Step&nbsp;8.
  Otherwise, go to Step&nbsp;9.
  </t>

  <t hangText="Step 8 (step_send_vfy):"><vspace blankLines="0" />
  Send a &_req-VFY-C; request.
  <list style="symbols" hangIndent="3">
   <t>If a &_401-STALE; message is received, go to Step 9.</t>
   <t>If a &_401-INIT; message is received, go to Step 13.</t>
   <t>If a &_200-VFY-S; message is received, go to Step 14.</t>
  </list>
  </t>

  <t hangText="Step 9 (step_send_kex1):"><vspace blankLines="0" />
  Send a &_req-KEX-C1; request.
  <list style="symbols" hangIndent="3">
   <t>If a &_401-KEX-S1; message is received, go to Step 10.</t>
   <t>If a &_401-INIT; message is received, go to Step 13 (see Note 1).</t>
  </list>
  </t>

  <t hangText="Step 10 (step_rcvd_kex1):"><vspace blankLines="0" />
  Send a &_req-VFY-C; request.
  <list style="symbols" hangIndent="3">
   <t>If a &_401-INIT; message is received, go to Step 13.</t>
   <t>If a &_200-VFY-S; message is received, go to Step 14.</t>
  </list>
  </t>

  <t hangText="Step 11 (step_rcvd_normal):"><vspace blankLines="0" />
  The requested resource is out of the authenticated area.
  The client will be in the "UNAUTHENTICATED" status.  If the
  response contains a request for authentication other than
  Mutual authentication, it MAY be handled normally.
  </t>

  <t hangText="Step 12 (step_rcvd_init_unknown):"><vspace blankLines="0" />
  The requested resource requires Mutual authentication, and the user
  is not yet authenticated.  The client will be in the "AUTH&nbhy;REQUESTED"
  status; it is RECOMMENDED that the client process the content sent from
  the server and ask the user for a username and password. When those
  are supplied by the user, go to Step&nbsp;9.
  </t>

  <t hangText="Step 13 (step_rcvd_init_failed):"><vspace blankLines="0" />
  The authentication failed for some reason, possibly because the
  password or username is invalid for the authenticated resource.
  Forget the user-provided credentials for the authentication realm,
  and go to Step&nbsp;12.
  </t>

  <t hangText="Step 14 (step_rcvd_vfy):"><vspace blankLines="0" />
  The received message is the &_200-VFY-S; message, which always
  contains a "&_vks;" field. Check the validity of the received &_VK_s; value.
  If it is equal to the expected value, then the mutual authentication
  succeeded. The client will be in the "AUTH&nbhy;SUCCEED" status.
  <vspace blankLines="1" />
  An unexpected value is interpreted as a fatal communication error.
  </t>

  <t>
  If a user explicitly asks to log out (via the user interface), the
  client MUST forget the user's password, go to Step&nbsp;5, and reload the
  current resource without an authentication header.
  </t>

  <t hangText="Note 1:">These transitions MAY be accepted by clients,
  but it is NOT&nbsp;RECOMMENDED that servers initiate them.</t>

</list>
</t>

<t>
<xref target="figure-client-dia" /> shows an informative diagram of the client state.
</t>

<figure anchor="figure-client-dia" title="State Diagram for Clients"  src="mutual-client-dia.png" alt="">
<artwork><![CDATA[      ===========                                  -(11)------------
      NEW REQUEST                                 ( UNAUTHENTICATED )
      ===========                                  -----------------
           |                                              ^ normal
           v                                              | response
+(1)-------------------+ NO                         +(5)----------+
| The requested URI    |--------------------------->| send normal |
| known to be auth'ed? |                            |   request   |
+----------------------+                            +-------------+
       YES |   401-INIT                            401-INIT|
           |   with a different realm                      |
           |          -----------------------------------. |
           |         /                                   v v
           |        |       -(12)------------    NO  +(6)--------+
           |        |      ( AUTH-REQUESTED  )<------| user/pass |
           |        |       -----------------        |   known?  |
           |        |                                +-----------+
           |        |                                      |YES
           v        |                                      v
     +(2)--------+  |                                +(7)--------+
     | session   |  |                                | session   | NO
 NO /| available?|  |                                | available?|\
   / +-----------+  |                                +-----------+ |
  /        |YES     |                                      |YES    |
 |         |       /|                                      |       |
 |         v      / |  401-                   401-         v       |
 |   +(3)--------+  |  INIT --(13)----------  INIT   +(8)--------+ |
 |   |   send    |--+----->/ AUTH-REQUESTED \<-------|   send    | |
 |  /| req-VFY-C |  |      \forget password /        | req-VFY-C | |
  \/ +-----------+ /        ----------------        /+-----------+ |
  /\           \ \/                 ^ 401-INIT     |     |401-     |
 |  ------      \/\  401-STALE      |              |     | STALE  /
 |        \     /\ -----------------+--------------+---. |       /
 |         |   /  \                 |              |   | |      /
 |         v  /    | 401-           |       401-   |   v v     v
 |   +(4)--------+ | KEX-S1   +(10)-------+ KEX-S1 | +(9)--------+
 |   |   send    |-|--------->|   send    |<-------+-|   send    |
 | --| req-KEX-C1| |          | req-VFY-C |        | | req-KEX-C1|
 |/  +-----------+ |          +-----------+        | +-----------+
 |                 |200-VFY-S      |      200-VFY-S|       ^
 |normal           |               |200-VFY-S     /        |
 |response         |               v             / ==================
 v                  \         -(14)---------    /  USER/PASS INPUTTED
 -(11)------------   ------->( AUTH-SUCCEED )<--   ==================
( UNAUTHENTICATED )           --------------
 -----------------]]>
</artwork>
</figure>

</section>
</section>

<section title="Decision Procedure for Servers" anchor="srv-decision">

<t>
Each server SHOULD have a table of session states.
This table need not be persistent over the long term; it MAY be cleared
upon server restart, reboot, or for other reasons.
Each entry in the table SHOULD contain at least the following information:

<list style="symbols">
  <t>The session identifier, which is the value of the "sid" parameter.</t>
  <t>The algorithm used.</t>
  <t>The authentication realm.</t>
  <t>The state of the protocol: one of "key exchanging",
  "authenticated", "rejected", or "inactive".</t>
  <t>The username received from the client.</t>
  <t>A boolean flag indicating whether or not the session is fake.</t>
  <t>When the state is "key exchanging", the values of &_K_c1; and &_S_s1;.</t>
  <t>When the state is "authenticated", the following information:
  <list style="symbols">
    <t>The value of the session secret (z).</t>
    <t>The largest nc received from the client (largest-nc).</t>
    <t>For each possible nc value between
    (largest-nc&nbsp;-&nbsp;nc&nbhy;window&nbsp;+&nbsp;1) and max_nc,
    a boolean flag indicating whether or not a request with the
    corresponding nc has been received.
    </t>
  </list>
  </t>
</list>

The table MAY contain other information.
</t>

<t>
Servers SHOULD respond to the client requests according to the
following procedure (see Note 1 below regarding &_401-INIT; messages
with a plus sign):

<list style="symbols">
  <t>When the server receives a "normal request":
     <list style="symbols">
       <t>If the requested resource is not protected by the
       Mutual authentication, send a "normal response".</t>
       <t>If the resource is protected by the Mutual authentication,
       send a &_401-INIT; response.</t>
     </list>
  </t>
  <t>When the server receives a &_req-KEX-C1; request:
     <list style="symbols">
       <t>If the requested resource is not protected by the Mutual
       authentication, send a "normal response".</t>
       <t>If the authentication realm specified in the &_req-KEX-C1; request
       is not the expected realm, send a &_401-INIT; response.</t>
       <t>If the server cannot validate the parameter "&_kc1;", send a
       &_401-INIT; (+) response.</t>
       <t>If the received username is either invalid, unknown, or
       unacceptable, create a new session, mark it as a
       "fake" session, compute a random value as &_K_s1;, and
       send a fake &_401-KEX-S1; response (see Note&nbsp;2).
       </t>
       <t>Otherwise, create a new session, compute &_K_s1;, and send a
       &_401-KEX-S1; response. The created session is marked as
       not fake, and its largest&nbhy;nc value is initialized to zero.
</t>
     </list>
     The created session is in the "key exchanging" state.
  </t>
  <t>When the server receives a &_req-VFY-C; request:
     <list style="symbols">
       <t>If the requested resource is not protected by the
       Mutual authentication, send a "normal response".</t>
       <t>If the authentication realm specified in the &_req-VFY-C; request
       is not the expected realm, send a &_401-INIT; response.</t>
     </list>

     If none of the above holds true, the server will look up the session
     corresponding to the received sid and the authentication realm.

     <list style="symbols">
       <t>If the session corresponding to the received sid could not
          be found or it is in the "inactive" state, send a
          &_401-STALE; response.</t>

       <t>If the session is in the "rejected" state,
          send either a &_401-INIT; (+) response or
          a &_401-STALE; message.</t>

       <t>
          If the nc value in the request is larger than the
          "nc-max" parameter sent from the server or it is not larger than
          (largest-nc - nc-window) (when in the "authenticated" state),
          the server MAY (but is not REQUIRED to; see Note 3) send
          a &_401-STALE; message. The session is changed to the
          "inactive" state if the &_401-STALE; message was sent.
       </t>

       <t>If the session is in the "authenticated" state and the
          request has an nc value that was previously received from
          the client, send a &_401-STALE; message.  The session is
          changed to the "inactive" state.
       </t>

       <t>If the session is a "fake" session or the received &_vkc;
          is incorrect, then send a &_401-INIT; (+) response.  If the
          session is in the "key exchanging" state, it MUST be
          changed to the "rejected" state; otherwise, it MAY be either
          changed to the "rejected" state or kept in the previous
          state.
       </t>

       <t>Otherwise, send a &_200-VFY-S; response.  If the session was
          in the "key exchanging" state, the session SHOULD be
          changed to the "authenticated" state.  The maximum nc and
          nc flags of the state MUST be updated appropriately.
       </t>
     </list>
  </t>
</list>
</t>

<t>
At any time, the server MAY change any state entries with both the
"rejected" and "authenticated" states to the "inactive" state
and MAY discard any "inactive" states from the table.  Entries with
the "key exchanging" state SHOULD be kept unless there is an
emergency situation such as a server reboot or a table capacity
overflow.
</t>

<t>
Note 1: In relation to, and following the specification of, the
optional authentication defined in <xref target="RFC8053" />,
the &_401-INIT; messages marked with plus signs cannot be 
replaced with a successful response with an
&_Optional-WWW-Authenticate; header. Every other &_401-INIT; can be a
response with an &_Optional-WWW-Authenticate; header.
</t>

<t>
Note 2: The server SHOULD&nbsp;NOT send a &_401-INIT; response in this case,
because it will leak the information to the client that the specified
username will not be accepted. Instead, postpone it until the response
to the next req&nbhy;VFY&nbhy;C request.
</t>

<t>
Note 3: If the request is not rejected in this clause, the server
will be required, in the next step, to determine whether the same
nc value was previously received from the client. If that is
impossible, the server MUST send a &_401-STALE; response in this step.
If the server does not remember the whole history of the nc values
received from the client, the server MUST send a &_401-STALE; message
in this clause.
</t>

</section>

<section title="Authentication Algorithms" anchor="algorithms">

<t>
Cryptographic authentication algorithms that are used with this
protocol will be defined separately. The algorithm definition MUST
at least provide definitions for the following functions:
<list style="symbols">
<t>The server-side authentication credential J, derived from the
client-side authentication credential pi.</t>
<t>Key exchange values &_K_c1;, &_K_s1; (exchanged on the wire)
and &_S_c1;,&nbsp;&_S_s1; (kept secret in each peer).</t>
<t>Shared session secret (z), to be computed by both server and client.</t>
<t>A hash function H to be used with the protocol, along with its
output size hSize.</t>
<t>The value nIterPi, the number of iterations for the key derivation
operation.
</t>
</list>
</t>

<t>
Specifications for cryptographic algorithms used with this framework
MUST specify whether those algorithms will (1)&nbsp;use the
default functions defined below for values pi, &_VK_c;, and &_VK_s;
or (2)&nbsp;define their own comparable functions.
</t>

<t>
All algorithms used with this protocol SHOULD provide secure
mutual authentication between clients and servers and generate a
cryptographically strong shared secret value (z) that is equally
strong or stronger than the hash function H. &nbsp;If any passwords
(or passphrases or any equivalents, i.e., weak secrets) are involved,
these SHOULD&nbsp;NOT be guessable from any data transmitted in the
protocol, even if an attacker (either an eavesdropper or an active
server) knows the possible thoroughly searchable candidate list of
passwords.  Furthermore, it is RECOMMENDED that the function&nbsp;J
for deriving the server&nbhy;side authentication credential J(pi)
be one&nbhy;way, if possible, so that pi cannot be easily computed
from J(pi).</t>

<section title="Support Functions and Notations">

<t>In this section, we define several support functions and notations
to be shared by several algorithm definitions.</t>

<t>The integers in the specification are in decimal, or in hexadecimal when
prefixed with "0x".</t>

<t>The function octet(i) generates an octet string containing a single octet
of value i. The operator "|", when applied to octet strings, denotes
the concatenation of two operands.</t>

<t>The function VI encodes natural numbers into octet strings in the
following manner: numbers are represented as
big&nbhy;endian radix&nbhy;128 strings, where each digit is
represented by an octet within the range 0x80&ndash;0xff,
except for the last digit, which is represented by an octet
within the range 0x00&ndash;0x7f. The first octet MUST&nbsp;NOT be
0x80. For example, VI(i) = octet(i) for i &lt; 128, and
VI(i)&nbsp;=&nbsp;octet(0x80&nbsp;+&nbsp;(i&nbsp;&gt;&gt;&nbsp;7)) |
octet(i &amp; 127)
for 128 &lt;= i &lt; 16384. This encoding is the same as the encoding
used for the subcomponents of object identifiers
in <xref target="ITU.X690.2015">ASN.1&nbsp;encoding</xref> and
is available as a "w" conversion in the "pack" function of several
scripting languages.
</t>
<t>
The function VS encodes a variable-length octet string into a
uniquely decoded, self-delimited octet string in the following manner:
</t>

<t>
 VS(s) = VI(length(s)) | s
</t>

<t>
where length(s) is a number of octets (not characters) in s.
</t>

<t>
Some examples:
<list>
<t>VI(0) = "\000" (in C string notation)</t>
<t>VI(100) = "d"</t>
<t>VI(10000) = "\316\020"</t>
<t>VI(1000000) = "\275\204@"</t>
</list>
<list>
<t>VS("") = "\000"</t>
<t>VS("Tea") = "\003Tea"</t>
<t>VS("Caf&lt;e acute&gt;" [in UTF-8]) = "\005Caf\303\251"</t>
<t>VS([10000 "a"s]) = "\316\020aaaaa..." (10002 octets)</t>
</list>
</t>

<t>
(Note: Unlike the colon-separated format used in the Basic and
Digest HTTP authentication schemes, the string generated by a
concatenation of the VS&nbhy;encoded strings will be unique,
regardless of the characters included in the strings to be encoded.)
</t>

<t>The function OCTETS converts an integer into the corresponding
radix&nbhy;256 big&nbhy;endian octet string having its natural length.
See <xref target="sec-numbers" /> for the definition of "natural length".
</t>

<t>The function INT converts an octet string into a natural number,
where the input string is treated as being in
radix&nbhy;256 big&nbhy;endian notation. The identity
INT(OCTETS(n))&nbsp;=&nbsp;n always holds for any natural number n.
</t>

</section>

<section title="Default Functions for Algorithms">

<t>The functions defined in this section are common default functions
among authentication algorithms.
</t>

<t>
The client-side password-based (credential) pi used by this authentication
is a natural number derived in the following manner:
</t>

<figure><artwork><![CDATA[
   pi = INT(PBKDF2(HMAC_H, password, VS(algorithm) | VS(auth-scope) |
   VS(realm) | VS(username), nIterPi, hSize / 8))
]]></artwork></figure>

<t>
where
<list style="symbols">
<t>PBKDF2 is the password-based key derivation function defined
in <xref target="RFC8018" />,
</t>

<t>HMAC_H is the Hashed Message Authentication Code (HMAC) function,
defined in <xref target="RFC2104" />, composed from the hash function H,
and</t> <t>hSize is the output size of hash H in bits.</t>
</list>
</t>

<t>
The values of algorithm, realm, and auth-scope are taken
from the values contained in the &_401-INIT; message.
If the password comes from user input, it SHOULD first be
prepared according to the method presented
in <xref target="sec-normalize" />. Then, the password SHALL be
encoded as a UTF-8 string.
</t>

<t>
The values &_VK_c; and &_VK_s; are derived via the following equations:
</t>

<figure><artwork><![CDATA[
   VK_c = INT(H(octet(4) | OCTETS(K_c1) | OCTETS(K_s1) | OCTETS(z) |
   VI(nc) | VS(vh)))

   VK_s = INT(H(octet(3) | OCTETS(K_c1) | OCTETS(K_s1) | OCTETS(z) |
   VI(nc) | VS(vh)))
]]></artwork></figure>

</section>

</section>

<section title="Application Channel Binding" anchor="key-provision">

<t>
Applications and upper-layer communication protocols may need authentication
binding to the HTTP-layer authenticated user.  Such applications MAY use
the following values as a standard shared secret.
</t>
<t>
These values are parameterized with an optional octet string (t),
which may be arbitrarily chosen by each application or protocol.
If there is no appropriate value to be specified, use an empty string for t.
</t>
<t>
For applications requiring binding to either an authenticated user or
a shared-key session (to ensure that the requesting client is
authenticated), the following value b_1 MAY be used:
</t>

<figure><artwork><![CDATA[
   b_1 = H(H(octet(6) | OCTETS(K_c1) | OCTETS(K_s1) | OCTETS(z) |
   VI(0) | VS(vh)) | VS(t))
]]></artwork></figure>

<t>
For applications requiring binding to a specific request (to ensure that
the payload data is generated for the exact HTTP request), the
following value b_2 MAY be used:
</t>

<figure><artwork><![CDATA[
   b_2 = H(H(octet(7) | OCTETS(K_c1) | OCTETS(K_s1) | OCTETS(z) |
   VI(nc) | VS(vh)) | VS(t))
]]></artwork></figure>

<t>
Note: Channel bindings to lower-layer transports (TCP and TLS) are
defined in <xref target="validation" />.
</t>
</section>

<section title="Application for Proxy Authentication">

<t>
The authentication scheme defined in the previous sections can be
applied (with modifications) to proxy authentication.

In such cases, the following alterations MUST be applied:
<list style="symbols">
<t>The 407 (Proxy Authentication Required) status code is to be sent
and recognized in places where the 401 status code is used,</t>

<t>The Proxy-Authenticate header is to be used in places where the
WWW&nbhy;Authenticate header is used,</t>

<t>The Proxy-Authorization header is to be used in places where the
Authorization header is used,</t>

<t>The Proxy-Authentication-Info header is to be used in places
where the Authentication&nbhy;Info header is used,</t>

<t>The "auth-scope" parameter is fixed to the hostname of the proxy, which
means that it covers all requests processed by the specific proxy,</t>

<t>The limitation for the paths contained in the "path" parameter of
&_401-KEX-S1; messages is disregarded,</t>

<t>The omission of the "path" parameter of &_401-KEX-S1; messages means that
the authentication realm will potentially cover all requests processed by
the proxy,</t>

<t>The scheme, hostname, and port of the proxy are used for host
validation tokens, and</t>

<t>Authentication extensions defined in <xref target="RFC8053" />
are not applicable.</t>
</list>
</t>

</section>

<section title="Methods to Extend This Protocol" anchor="methods-to-extend">

<t>
If a private extension to this protocol is implemented, it MUST use
the extension-tokens defined in <xref target="syntax" /> to avoid
conflicts with this protocol and other extensions.
(Standardized extensions, as well as extensions that are in the
process of being standardized, MAY use either bare&nbhy;tokens or
extension&nbhy;tokens.)
</t>

<t>
Specifications defining authentication algorithms MAY use other
representations for the parameters "&_kc1;", "&_ks1;", "&_vkc;", and
"&_vks;"; replace those parameter names; and/or add parameters to the
messages containing those parameters in supplemental specifications,
provided that syntactic and semantic requirements in
<xref target="syntax" /> of this document, <xref target="RFC7230"/>,
and <xref target="RFC7235" /> are satisfied. Any parameters starting
with "kc", "ks", "vkc", or "vks" and followed by decimal natural
numbers (e.g.,&nbsp;kc2, ks0, vkc1, vks3) are reserved for this
purpose.  If those specifications use names other than those mentioned
above, it is RECOMMENDED that extension&nbhy;tokens be used to avoid
any parameter-name conflicts with future extensions to this protocol.
</t>

<t>
Extension-tokens MAY be freely used for any non&nbhy;standard,
private, and/or experimental uses for those parameters provided that the
domain part in the token is used in the manner defined
in <xref target="syntax" />.
</t>

</section>

<section anchor="IANA" title="IANA Considerations">

<section title="Addition to HTTP Authentication Schemes Registry ">
<t>
IANA has added the following entry to the "HTTP Authentication
Schemes" registry:

<list style="symbols">
<t>Authentication Scheme Name: Mutual</t>
<t>Reference: RFC 8120</t>
</list>
</t>

</section>

<section title="Registry for Authentication Algorithms">
<t>
This document establishes the "HTTP Mutual Authentication Algorithms"
registry. The registry manages case&nbhy;insensitive ASCII strings.
The strings MUST follow the extensive-token syntax defined in
<xref target="syntax" />.
</t>

<t>When bare-tokens are used for the authentication-algorithm parameter,
they MUST be allocated by IANA. To acquire registered tokens, the usage
of such tokens MUST be reviewed by a Designated Expert, as outlined
in <xref target="RFC5226" />.
</t>

<t>
Registrations for an authentication algorithm are required to include
descriptions of the authentication algorithms.  Reviewers assigned by
the IESG are advised to examine minimum security requirements and
consistency of the key exchange algorithm descriptions.
</t>

<t>
It is advised that new registrations provide the following information:
<list style="symbols">
<t>Token: A token used in HTTP headers for identifying the algorithm.</t>
<t>Description: A brief description of the algorithm.</t>
<t>Specification: A reference for a specification defining the algorithm.</t>
</list>
</t>

<t>
<xref target="RFC8121" /> defines the initial contents of this registry.
</t>

</section>

<section title="Registry for Validation Methods">
<t>
This document establishes the "HTTP Mutual Authentication Host
Validation Methods" registry. The registry manages case-insensitive
ASCII strings.  The strings MUST follow the extensive-token syntax
defined in <xref target="syntax" />.
</t>

<t>When bare-tokens are used for the validation parameter, they
MUST be allocated by IANA. To acquire registered tokens, the usage
of such tokens MUST be reviewed by a Designated Expert, as
outlined in <xref target="RFC5226" />.
</t>

<t>
Registrations for a validation method are required to include a
description of the validation method.  Reviewers assigned by
the IESG are advised to examine its use-case requirements and
any security consequences related to its introduction.
</t>

<t>
It is advised that new registrations provide the following information:
<list style="symbols">
<t>Token: A token used in HTTP headers for identifying the method.</t>
<t>Description: A brief description of the method.</t>
<t>Specification: A reference for a specification defining the method.</t>
</list>
</t>

<t>
The initial contents of this registry are as follows:
</t>

<figure><artwork><![CDATA[
+----------------------+------------------------+----------------+
| Token                | Description            | Reference      |
+----------------------+------------------------+----------------+
| host                 | Hostname verification  | RFC 8120,      |
|                      | only                   | Section 7      |
|                      |                        |                |
| tls-server-end-point | TLS certificate-based  | RFC 8120,      |
|                      |                        | Section 7      |
|                      |                        |                |
| tls-unique           | TLS unique key-based   | RFC 8120,      |
|                      |                        | Section 7      |
+----------------------+------------------------+----------------+
]]></artwork></figure>
</section>


</section>

<section anchor="Security" title="Security Considerations">

<section title="Security Properties">

<t>
<list style="symbols">
 <t>
  The protocol is secure against passive eavesdropping and replay attacks.
  However, the protocol relies on transport security (including
  DNS integrity) for data secrecy and integrity. HTTP&wj;/TLS SHOULD be used
  where transport security is not assured and/or data confidentiality
  is important.
 </t>

 <t>
  When used with HTTP/TLS, if TLS server certificates are reliably
  verified, the protocol provides true protection against active
  man-in-the-middle attacks.
 </t>

 <t>
  Even if the server certificate is not used or is unreliable, the
  protocol provides protection against active man-in-the-middle attacks
  for each HTTP request/response pair.  However, in such cases,
  JavaScript or similar scripts that are not authenticated by this
  authentication mechanism can affect mutually authenticated contents
  to circumvent the protection. This is why this protocol stipulates that
  valid TLS server certificates MUST be shown from the server to the client
  (<xref target="validation" />).
 </t>
</list>
</t>
</section>

<section title="Secrecy of Credentials">
<t>
The client-side password credential MUST always be kept secret and
SHOULD&nbsp;NOT be used for any other (possibly insecure) authentication
purposes. Loss of control of the credential will directly affect the
control of the corresponding server-side account.
</t>

<t>
The use of a client-side credential with THIS authentication scheme is
always safe, even if the connected server peer is not trustworthy (e.g.,
a phishing scenario). However, if it is used with other authentication
schemes (such as Web forms) and the recipient is rogue, the result
will be obvious.
</t>

<t>
It is also important that the server-side password credential (J) be kept
secret. If it is stolen and the client's choice of password is not strong,
anyone who is aware of the server-side password credential can employ an
offline dictionary attack to search for the client's password. However,
if the client has chosen a strong password so that an attacker cannot
guess the client's password from dictionary candidates, the client
is still well protected from any attacks.
</t>

<t>
The shared session secret (z) MUST be kept secret inside the
server&wj;/client software; if it is lost and the session is still
active, session hijacking will result.  After the session expires,
the key is of no&nbsp;value to attackers.
</t>
</section>


<section title="Denial-of-Service Attacks on Servers">

<t>
 The protocol requires a server-side table of active sessions, which
 may become a critical point for server resource consumption.
 For proper operation, the protocol requires that at least one 
 key verification request be processed for each session identifier.
 After that, servers MAY discard sessions internally at any time
 without causing any operational problems for clients.  Clients will
 then silently re&nbhy;establish a new session.
</t>

<t>
 However, if a malicious client sends too many requests for key
 exchanges (&_req-KEX-C1; messages) only, resource starvation might occur.
 In such critical situations, servers MAY discard any kind of
 existing sessions, regardless of their statuses.  One way to mitigate
 such attacks is that servers MAY set number and time limits for
 unverified, pending key exchange requests (in the "key exchanging" state).
</t>

<t>
This is a common weakness of authentication protocols with almost any
kind of negotiations or states, including the Digest authentication scheme
and most cookie-based authentication implementations.  However,
regarding resource consumption, the situation for the
Mutual&nbsp;authentication scheme is slightly better than that for
Digest, because HTTP requests without any kind of authentication requests
will not generate any kind of sessions.  Session identifiers are
only generated after a client starts a key negotiation, so that simple
clients such as Web crawlers will not accidentally consume server-side
resources for session management.
</t>

<section title="Online Active Password Attacks">

<t>
Although the protocol provides very strong protection against
offline dictionary attacks from eavesdropped traffic, the protocol,
by its nature, cannot prevent active password attacks in which an
attacker sends so many authentication trial requests for every
possible password.
</t>
<t>
Possible countermeasures for preventing such attacks may be the
rate&nbhy;limiting of password authentication trials,
statistics-based intrusion-detection measures, or similar
protection schemes.  If the server operators assume that the
passwords of users are not strong enough, it may be desirable to
introduce such ad&nbsp;hoc countermeasures.
</t>
</section>

</section>

<section title="Communicating the Status of Mutual Authentication with Users">

<t>
  This protocol is designed with two goals in mind. The first goal is
  simply to provide a secure alternative to existing Basic and Digest
  authentication schemes. The second goal is to provide users with a
  way to detect forged rogue servers imitating (e.g., via a phishing
  attack) a user's registered account on a server.
</t>

<t>
  For this protocol to effectively work as a countermeasure against
  such attacks, it is very important that end users of clients be
  notified of the result of mutual authentication performed by this
  protocol, especially the three states "AUTH&nbhy;SUCCEED",
  "AUTH&nbhy;REQUIRED", and "UNAUTHENTICATED" as defined in
  <xref target="cli-decision" />. The design of secure user interfaces
  for HTTP interactive clients is out of scope for this document, but
  if possible, having some kind of UI indication for the three states
  above will be desirable from the standpoint of providing user security.
</t>

<t>
  Of course, in such cases, the user interfaces for requesting
  passwords for this authentication shall be protected against
  imitation (for example, by other insecure password input fields,
  such as forms). If the passwords are known to malicious attackers
  outside of the protocol, the protocol cannot work as an effective
  security measure.
</t>

</section>

<section title="Implementation Considerations">

<t>
<list style="symbols">
 <t>To securely implement the protocol, the &_Authentication-Info;
    headers in the &_200-VFY-S; messages MUST always be validated by the
    client. If the validation fails, the client MUST&nbsp;NOT process
    any content sent with the message, including other headers and the
    body part. Non&nbhy;compliance with this requirement will allow
    phishing attacks.
</t>

<t>For HTTP/TLS communications, when a Web form is submitted from
   mutually authenticated pages via the "&_tls-server-end-point;"
   validation method to a URI that is protected by the same realm
   (so&nbsp;indicated by the "path" parameter), if the server certificate
   has been changed since the pages were received, it is
   RECOMMENDED that the peer be revalidated using
   a &_req-KEX-C1; message with an "Expect:&nbsp;&_100-continue;" header.
   The same applies when the page is received via the "&_tls-unique;"
   validation method and when the TLS session has expired.
</t>

<t>For better protection against possible password database stealing,
   server-side storage of user passwords should contain the values
   encrypted by the one-way function J(pi) instead of the real
   passwords or those hashed by pi.
</t>

<t>If TLS 1.2 <xref target="RFC5246"/> is used for
   underlying HTTP/TLS communications, follow the best practices
   specified in <xref target="RFC7525"/>.
</t>
</list>
</t>
</section>

<section title="Usage Considerations" anchor="sec-usage">

<t>
<list style="symbols">
 <t>
  The usernames inputted by a user may be sent automatically to any servers
  sharing the same auth-scope.  This means that when a host&nbhy;type
  auth-scope is used for authentication on an HTTPS site and an HTTP
  server on the same host requests the Mutual authentication scheme
  within the same realm, the client will send the username in clear text.
  If usernames have to be kept secret (protected from eavesdroppers), the
  server must use the full&nbhy;scheme&nbhy;type
  "auth&nbhy;scope" parameter and HTTPS. Passwords, on the other hand,
  are not exposed to eavesdroppers, even in HTTP requests.
 </t>
<t>
  If the server provides several ways to store server-side
  password secrets in the password database, it is desirable, for
  purposes of better security, to store the values encrypted by
  using the one&nbhy;way function J(pi) instead of the real passwords
  or those hashed by pi.
</t>
</list>
</t>

</section>

</section>

</middle>

  <back>
    <references title="Normative References">
      &RFC2104;
      &RFC2119;
      &RFC3629;
      &RFC4648;
      &RFC5234;
      &RFC5246;
      &RFC5987;
      &RFC7230;
      &RFC7235;
      &RFC7613;
      &RFC7615;
      &RFC8018;

<!-- draft-ietf-httpauth-extension-09 (PUB; RFC 8053) -->
      &RFC8053;

      <reference anchor="Unicode" target="http://www.unicode.org/versions/latest/">
        <front>
          <title>The Unicode Standard</title>
          <author>
            <organization>The Unicode Consortium</organization>
          </author>
          <date />
        </front>
      </reference>
    </references>

    <references title="Informative References">

<!-- draft-ietf-httpauth-mutual-algo (RFC 8121) -->
      <reference anchor="RFC8121" target="http://www.rfc-editor.org/info/rfc8121">
      <front>
      <title>Mutual Authentication Protocol for HTTP: Cryptographic Algorithms
 Based on the Key Agreement Mechanism 3 (KAM3)</title>
      <author initials="Y" surname="Oiwa" fullname="Yutaka Oiwa">
          <organization />
      </author>
      <author initials="H" surname="Watanabe" fullname="Hajime Watanabe">
          <organization />
      </author>
      <author initials="H" surname="Takagi" fullname="Hiromitsu Takagi">
          <organization />
      </author>
      <author initials='K' surname='Maeda' fullname='Kaoru Maeda'>
            <organization />
      </author>
      <author initials="T" surname="Hayashi" fullname="Tatsuya Hayashi">
          <organization />
      </author>
      <author initials="Y" surname="Ioku" fullname="Yuichi Ioku">
          <organization />
      </author>
      <date month="April" year="2017" />
      </front>
      <seriesInfo name="RFC" value="8121"/>
      <seriesInfo name="DOI" value="10.17487/RFC8121"/>
      </reference>
      
      &RFC1939;
      &RFC2818;
      &RFC5226;
      &RFC5890;
      &RFC5929;
      &RFC6265;
      &RFC6454;
      &RFC7231;
      &RFC7486;
      &RFC7525;
      &RFC7616;
      &RFC7627;

<reference anchor="ITU.X690.2015" target="https://www.itu.int/rec/T-REC-X.690/">
 <front>
 <title>Information Technology - ASN.1 encoding rules: Specification of Basic
 Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished
 Encoding Rules (DER)</title>
 <author>
 <organization>International Telecommunication Union</organization>
 </author>
 <date month="August" year="2015" />
 </front>
 <seriesInfo name="ITU-T Recommendation X.690," value="ISO/IEC 8825-1" />
 </reference>

    </references>

  </back>
</rfc>
