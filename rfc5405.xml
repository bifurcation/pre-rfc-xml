<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc strict="yes"?>
<?rfc tocompact="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc subcompact="no"?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>

<rfc number="5405" category="bcp" seriesNo="145">
<front>
<title abbrev="Unicast UDP Usage Guidelines">
	Unicast UDP Usage Guidelines for Application Designers 
</title>

<author initials="L." surname="Eggert" fullname="Lars Eggert">
	<organization abbrev="Nokia">
		Nokia Research Center
	</organization>
	<address>
		<postal>
			<street>P.O. Box 407</street>
			<code>00045</code> <city>Nokia Group</city>
			<country>Finland</country>
		</postal>
		<phone>+358 50 48 24461</phone>
		<email>lars.eggert@nokia.com</email>
		<uri>
			http://people.nokia.net/~lars/
		</uri>
	</address>
</author>

<author initials="G." surname="Fairhurst" fullname="Godred Fairhurst">
       <organization>University of Aberdeen</organization>
       <address>
		<postal>
		<street>Department of Engineering</street>
		<street>Fraser Noble Building</street>
		<city>Aberdeen</city>
		<code>AB24 3UE</code>
		<country>Scotland</country>
		</postal>
		<email>gorry@erg.abdn.ac.uk</email>
		<uri>http://www.erg.abdn.ac.uk/</uri>
	</address>
</author>

<date month="November" year="2008"/>
<area>Transport Area</area>
<workgroup>Transport Area Working Group</workgroup>
<keyword>UDP</keyword>
<keyword>guidelines</keyword>

<abstract>
	<t>
The User Datagram Protocol (UDP) provides a minimal message-passing
transport that has no inherent congestion control mechanisms. Because
congestion control is critical to the stable operation of the
Internet, applications and upper-layer protocols that choose to use
UDP as an Internet transport must employ mechanisms to prevent
congestion collapse and to establish some degree of fairness with
concurrent traffic. This document provides guidelines on the use of
UDP for the designers of unicast applications and upper-layer
protocols. Congestion control guidelines are a primary focus, but the
document also provides guidance on other topics, including message
sizes, reliability, checksums, and middlebox traversal.
	</t>
</abstract>
</front>

<middle>
<section title="Introduction" anchor="intro">
	<t>
The User Datagram Protocol (UDP) <xref target="RFC0768"/> provides a minimal, unreliable, best-effort, message-passing transport to applications and upper-layer protocols (both simply called "applications" in the remainder of this document). Compared to other transport protocols, UDP and its UDP-Lite variant <xref target="RFC3828"/> are unique in that they do not establish end-to-end connections between communicating end systems. UDP communication consequently does not incur connection establishment and teardown overheads, and there is minimal associated end system state. Because of these characteristics, UDP can offer a very efficient communication transport to some applications.
	</t>
	<t>
A second unique characteristic of UDP is that it provides no inherent congestion control mechanisms. On many platforms, applications can send UDP datagrams at the line rate of the link interface, which is often much greater than the available path capacity, and doing so contributes to congestion along the path. <xref target="RFC2914"/> describes the best current practice for congestion control in the Internet. It identifies two major reasons why congestion control mechanisms are critical for the stable operation of the Internet:

	<list style="numbers">
		<t>
The prevention of congestion collapse, i.e., a state where an increase in network load results in a decrease in useful work done by the network. 
		</t>
		<t>
The establishment of a degree of fairness, i.e., allowing multiple flows to share the capacity of a path reasonably equitably. 
		</t>
	</list>
	</t>
	<t>
Because UDP itself provides no congestion control mechanisms, it is up to the applications that use UDP for Internet communication to employ suitable mechanisms to prevent congestion collapse and establish a degree of fairness. <xref target="RFC2309"/> discusses the dangers of congestion-unresponsive flows and states that "all UDP-based streaming applications should incorporate effective congestion avoidance mechanisms". This is an important requirement, even for applications that do not use UDP for streaming. In addition, congestion-controlled transmission is of benefit to an application itself, because it can reduce self-induced packet loss, minimize retransmissions, and hence reduce delays. Congestion control is essential even at relatively slow transmission rates. For example, an application that generates five 1500-byte UDP datagrams in one second can already exceed the capacity of a 56 Kb/s path. For applications that can operate at higher, potentially unbounded data rates, congestion control becomes vital to prevent congestion collapse and establish some degree of fairness. <xref target="udpguide"/> describes a number of simple guidelines for the designers of such applications.
	</t>
	<t>
A UDP datagram is carried in a single IP packet and is hence limited to a maximum payload of 65,507 bytes for IPv4 and 65,527 bytes for IPv6. The transmission of large IP packets usually requires IP fragmentation. Fragmentation decreases communication reliability and efficiency and should be avoided. IPv6 allows the option of transmitting large packets ("jumbograms") without fragmentation when all link layers along the path support this <xref target="RFC2675"/>. Some of the guidelines in <xref target="udpguide"/> describe how applications should determine appropriate message sizes. Other sections of this document provide guidance on reliability, checksums, and middlebox traversal.
	</t>
	<t>
This document provides guidelines and recommendations. Although most unicast UDP applications are expected to follow these guidelines, there do exist valid reasons why a specific application may decide not to follow a given guideline. In such cases, it is RECOMMENDED that the application designers document the rationale for their design choice in the technical specification of their application or protocol.
	</t>
	<t>
This document provides guidelines to designers of applications that use UDP for unicast transmission, which is the most common case. Specialized classes of applications use UDP for IP multicast <xref target="RFC1112"/>, broadcast <xref target="RFC0919"/>, or anycast <xref target="RFC1546"/> transmissions. The design of such specialized applications requires expertise that goes beyond the simple, unicast-specific guidelines given in this document. Multicast and broadcast senders may transmit to multiple receivers across potentially very heterogeneous paths at the same time, which significantly complicates congestion control, flow control, and reliability mechanisms. The IETF has defined a reliable multicast framework <xref target="RFC3048"/> and several building blocks to aid the designers of multicast applications, such as <xref target="RFC3738"/> or <xref target="RFC4654"/>. Anycast senders must be aware that successive messages sent to the same anycast IP address may be delivered to different anycast nodes, i.e., arrive at different locations in the topology. It is not intended that the guidelines in this document apply to multicast, broadcast, or anycast applications that use UDP.
	</t>
	<t>
Finally, although this document specifically refers to unicast applications that use UDP, the spirit of some of its guidelines also applies to other message-passing applications and protocols (specifically on the topics of congestion control, message sizes, and reliability). Examples include signaling or control applications that choose to run directly over IP by registering their own IP protocol number with IANA. This document may provide useful background reading to the designers of such applications and protocols.
	</t>
</section>

<section title="Terminology" anchor="term">
	<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14, RFC 2119 <xref target="RFC2119"/>.
	</t>
</section>

<section title="UDP Usage Guidelines" anchor="udpguide">
	<t>
Internet paths can have widely varying characteristics, including transmission delays, available bandwidths, congestion levels, reordering probabilities, supported message sizes, or loss rates. Furthermore, the same Internet path can have very different conditions over time. Consequently, applications that may be used on the Internet MUST NOT make assumptions about specific path characteristics. They MUST instead use mechanisms that let them operate safely under very different path conditions. Typically, this requires conservatively probing the current conditions of the Internet path they communicate over to establish a transmission behavior that it can sustain and that is reasonably fair to other traffic sharing the path. 
	</t>
	<t>
These mechanisms are difficult to implement correctly. For most
applications, the use of one of the existing IETF transport protocols
is the simplest method of acquiring the required
mechanisms. Consequently, the RECOMMENDED alternative to the UDP usage
described in the remainder of this section is the use of an IETF
transport protocol such as TCP <xref target="RFC0793"/>, Stream
Control Transmission Protocol (SCTP) <xref target="RFC4960"/>, and
SCTP Partial Reliability Extension (SCTP-PR) <xref target="RFC3758"/>, or Datagram Congestion Control Protocol (DCCP) <xref target="RFC4340"/> with its different congestion control types <xref target="RFC4341"/><xref target="RFC4342"/><xref target="CCID4"/>. 
	</t>
	<t>
If used correctly, these more fully-featured transport protocols are
not as "heavyweight" as often claimed. For example, the TCP algorithms
have been continuously improved over decades, and have reached a level
of efficiency and correctness that custom application-layer mechanisms
will struggle to easily duplicate. In addition, many TCP
implementations allow connections to be tuned by an application to its
purposes. For example, TCP's "Nagle" algorithm
<xref target="RFC0896"/> can be disabled, improving communication
latency at the expense of more frequent -- but still congestion-controlled -- packet
transmissions. Another example is the TCP SYN cookie mechanism
<xref target="RFC4987"/>, which is available on many platforms. TCP
with SYN cookies does not require a server to maintain per-connection
state until the connection is established. TCP also requires the end
that closes a connection to maintain the TIME-WAIT state that prevents
delayed segments from one connection instance from interfering with a
later one. Applications that are aware of and designed for this
behavior can shift maintenance of the TIME-WAIT state to conserve
resources by controlling which end closes a TCP connection
<xref target="FABER"/>. Finally, TCP's built-in capacity-probing and
awareness of the maximum transmission unit supported by the path
(PMTU) results in efficient data transmission that quickly compensates
for the initial connection setup delay, in the case of transfers that exchange more than a few segments. 
	</t>

	<section title="Congestion Control Guidelines" anchor="ccguide">
		<t>
If an application or upper-layer protocol chooses not to use a congestion-controlled transport protocol, it SHOULD control the rate at which it sends UDP datagrams to a destination host, in order to fulfill the requirements of <xref target="RFC2914"/>. It is important to stress that an application SHOULD perform congestion control over all UDP traffic it sends to a destination, independently from how it generates this traffic. For example, an application that forks multiple worker processes or otherwise uses multiple sockets to generate UDP datagrams SHOULD perform congestion control over the aggregate traffic.
		</t>
		<t>
Several approaches to perform congestion control are discussed in the remainder of this section. Not all approaches discussed below are appropriate for all UDP-transmitting applications. <xref target="btguide"/> discusses congestion control options for applications that perform bulk transfers over UDP. Such applications can employ schemes that sample the path over several subsequent RTTs during which data is exchanged, in order to determine a sending rate that the path at its current load can support. Other applications only exchange a few UDP datagrams with a destination. <xref target="ldrguide"/> discusses congestion control options for such "low data-volume" applications. Because they typically do not transmit enough data to iteratively sample the path to determine a safe sending rate, they need to employ different kinds of congestion control mechanisms. <xref target="tunguide"/> discusses congestion control considerations when UDP is used as a tunneling protocol.
		</t>
		<t>
It is important to note that congestion control should not be viewed as an add-on to a finished application. Many of the mechanisms discussed in the guidelines below require application support to operate correctly. Application designers need to consider congestion control throughout the design of their application, similar to how they consider security aspects throughout the design process.
		</t>
		<t>
In the past, the IETF has also investigated integrated congestion control mechanisms that act on the traffic aggregate between two hosts, 

i.e., a framework such as the Congestion Manager <xref target="RFC3124"/>, where
active sessions may share current congestion information in a way that
is independent of the transport protocol. Such mechanisms have
currently failed to see deployment, but would otherwise simplify the design of congestion control mechanisms for UDP sessions, so that they fulfill the requirements in <xref target="RFC2914"/>.
		</t>

	<section title="Bulk Transfer Applications" anchor="btguide">
		<t>
Applications that perform bulk transmission of data to a peer over UDP, i.e., applications that exchange more than a small number of UDP datagrams per RTT, SHOULD implement TCP-Friendly Rate Control (TFRC) <xref target="RFC5348"/>, window-based, TCP-like congestion control, or otherwise ensure that the application complies with the congestion control principles.
		</t>
		<t>
TFRC has been designed to provide both congestion control and fairness in a way that is compatible with the IETF's other transport protocols. If an application implements TFRC, it need not follow the remaining guidelines in <xref target="btguide"/>, because TFRC already addresses them, but SHOULD still follow the remaining guidelines in the subsequent subsections of <xref target="udpguide"/>. 
		</t>
		<t>
Bulk transfer applications that choose not to implement TFRC or TCP-like windowing SHOULD implement a congestion control scheme that results in bandwidth use that competes fairly with TCP within an order of magnitude. Section 2 of <xref target="RFC3551"/> suggests that applications SHOULD monitor the packet loss rate to ensure that it is within acceptable parameters. Packet loss is considered acceptable if a TCP flow across the same network path under the same network conditions would achieve an average throughput, measured on a reasonable timescale, that is not less than that of the UDP flow. The comparison to TCP cannot be specified exactly, but is intended as an "order-of-magnitude" comparison in timescale and throughput.  
		</t>
		<t>
Finally, some bulk transfer applications may choose not to implement any congestion control mechanism and instead rely on transmitting across reserved path capacity. This might be an acceptable choice for a subset of restricted networking environments, but is by no means a safe practice for operation in the Internet. When the UDP traffic of such applications leaks out on unprovisioned Internet paths, it can significantly degrade the performance of other traffic sharing the path and even result in congestion collapse. Applications that support an uncontrolled or unadaptive transmission behavior SHOULD NOT do so by default and SHOULD instead require users to explicitly enable this mode of operation.
		</t>
	</section>
	
	<section title="Low Data-Volume Applications" anchor="ldrguide">
		<t>
When applications that at any time exchange only a small number of UDP datagrams with a destination implement TFRC or one of the other congestion control schemes in <xref target="btguide"/>, the network sees little benefit, because those mechanisms perform congestion control in a way that is only effective for longer transmissions. 
		</t>
		<t>
Applications that at any time exchange only a small number of UDP datagrams with a destination SHOULD still control their transmission behavior by not sending on average more than one UDP datagram per round-trip time (RTT) to a destination. Similar to the recommendation in <xref target="RFC1536"/>, an application SHOULD maintain an estimate of the RTT for any destination with which it communicates. Applications SHOULD implement the algorithm specified in <xref target="RFC2988"/> to compute a smoothed RTT (SRTT) estimate. They SHOULD also detect packet loss and exponentially back-off their retransmission timer when a loss event occurs. When implementing this scheme, applications need to choose a sensible initial value for the RTT. This value SHOULD generally be as conservative as possible for the given application. TCP uses an initial value of 3 seconds <xref target="RFC2988"/>, which is also RECOMMENDED as an initial value for UDP applications. SIP <xref target="RFC3261"/> and GIST <xref target="GIST"/> use an initial value of 500 ms, and initial timeouts that are shorter than this are likely problematic in many cases. It is also important to note that the initial timeout is not the maximum possible timeout -- the RECOMMENDED algorithm in <xref target="RFC2988"/> yields timeout values after a series of losses that are much longer than the initial value.
		</t>
		<t>
Some applications cannot maintain a reliable RTT estimate for a destination. The first case is that of applications that exchange too few UDP datagrams with a peer to establish a statistically accurate RTT estimate. Such applications MAY use a predetermined transmission interval that is exponentially backed-off when packets are lost. TCP uses an initial value of 3 seconds <xref target="RFC2988"/>, which is also RECOMMENDED as an initial value for UDP applications. SIP <xref target="RFC3261"/> and GIST <xref target="GIST"/> use an interval of 500 ms, and shorter values are likely problematic in many cases. As in the previous case, note that the initial timeout is not the maximum possible timeout.		
		</t>
		<t>
A second class of applications cannot maintain an RTT estimate for a destination, because the destination does not send return traffic. Such applications SHOULD NOT send more than one UDP datagram every 3 seconds, and SHOULD use an even less aggressive rate when possible. The 3-second interval was chosen based on TCP's retransmission timeout when the RTT is unknown <xref target="RFC2988"/>, and shorter values are likely problematic in many cases. Note that the sending rate in this case must be more conservative than in the two previous cases, because the lack of return traffic prevents the detection of packet loss, i.e., congestion events, and the application therefore cannot perform exponential back-off to reduce load.
		</t>
		<t>
Applications that communicate bidirectionally SHOULD employ congestion
control for both directions of the communication. For example, for a
client-server, request-response-style application, clients SHOULD
congestion-control their request transmission to a server, and the
server SHOULD congestion-control its responses to the
clients. Congestion in the forward and reverse direction is
uncorrelated, and an application SHOULD either independently detect
and respond to congestion along both directions, or limit new and
retransmitted requests based on acknowledged responses across the
entire round-trip path.
		</t>	
	</section>
	
	<section title="UDP Tunnels" anchor="tunguide">
		<t>
One increasingly popular use of UDP is as a tunneling protocol, where
a tunnel endpoint encapsulates the packets of another protocol inside
UDP datagrams and transmits them to another tunnel endpoint, which
decapsulates the UDP datagrams and forwards the original packets
contained in the payload. Tunnels establish virtual links that appear
to directly connect locations that are distant in the physical
Internet topology and can be used to create virtual (private)
networks. Using UDP as a tunneling protocol is attractive when the
payload protocol is not supported by middleboxes that may exist along
the path, because many middleboxes support transmission using UDP.
		</t>	
		<t>
Well-implemented tunnels are generally invisible to the endpoints that happen to transmit over a path that includes tunneled links. On the other hand, to the routers along the path of a UDP tunnel, i.e., the routers between the two tunnel endpoints, the traffic that a UDP tunnel generates is a regular UDP flow, and the encapsulator and decapsulator appear as regular UDP-sending and -receiving applications. Because other flows can share the path with one or more UDP tunnels, congestion control needs to be considered.
		</t>	
		<t>
Two factors determine whether a UDP tunnel needs to employ specific
congestion control mechanisms -- first, whether the payload traffic is
IP-based; second, whether the tunneling scheme generates UDP traffic at a volume that corresponds to the volume of payload traffic carried within the tunnel.
		</t>	
		<t>
IP-based traffic is generally assumed to be congestion-controlled, i.e., it is assumed that the transport protocols generating IP-based traffic at the sender already employ mechanisms that are sufficient to address congestion on the path. Consequently, a tunnel carrying IP-based traffic should already interact appropriately with other traffic sharing the path, and specific congestion control mechanisms for the tunnel are not necessary.
		</t>	
		<t>
However, if the IP traffic in the tunnel is known to not be congestion-controlled, additional measures are RECOMMENDED in order to limit the impact of the tunneled traffic on other traffic sharing the path. 
		</t>	
		<t>
The following guidelines define these possible cases in more detail:
		</t>
		<t>
	<list style="numbers">
		<t>A tunnel generates UDP traffic at a volume that corresponds to the volume of payload traffic, and the payload traffic is IP-based and congestion-controlled.<vspace blankLines="1" />This is arguably the most common case for Internet tunnels. In this case, the UDP tunnel SHOULD NOT employ its own congestion control mechanism, because congestion losses of tunneled traffic will already trigger an appropriate congestion response at the original senders of the tunneled traffic.<vspace blankLines="1" />Note that this guideline is built on the assumption that most IP-based communication is congestion-controlled. If a UDP tunnel is used for IP-based traffic that is known to not be congestion-controlled, the next set of guidelines applies.
		</t>	
		<t>A tunnel generates UDP traffic at a volume that corresponds to the volume of payload traffic, and the payload traffic is not known to be IP-based, or is known to be IP-based but not congestion-controlled.<vspace blankLines="1" />This can be the case, for example, when some link-layer protocols are encapsulated within UDP (but not all link-layer protocols; some are congestion-controlled). Because it is not known that congestion losses of tunneled non-IP traffic will trigger an appropriate congestion response at the senders, the UDP tunnel SHOULD employ an appropriate congestion control mechanism. Because tunnels are usually bulk-transfer applications as far as the intermediate routers are concerned, the guidelines in <xref target="btguide"/> apply.
		</t>
		<t>A tunnel generates UDP traffic at a volume that
		does not correspond to the volume of payload traffic,
		independent of whether the payload traffic is IP-based
		or congestion-controlled.<vspace blankLines="1"
		/>Examples of this class include UDP tunnels that send
		at a constant rate, increase their transmission rates
		under loss, for example, due to increasing redundancy
		when Forward Error Correction is used, or are otherwise constrained in their transmission behavior. These specialized uses of UDP for tunneling go beyond the scope of the general guidelines given in this document. The implementer of such specialized tunnels SHOULD carefully consider congestion control in the design of their tunneling mechanism.
		</t> 
	</list>
		</t>
		<t>
Designing a tunneling mechanism requires significantly more expertise than needed for many other UDP applications, because tunnels virtualize lower-layer components of the Internet, and the virtualized components need to correctly interact with the infrastructure at that layer. This document only touches upon the congestion control considerations for implementing UDP tunnels; a discussion of other required tunneling behavior is out of scope. 
		</t> 
	</section>
	
	</section>

	<section title="Message Size Guidelines" anchor="msguide">
		<t>
IP fragmentation lowers the efficiency and reliability of Internet
communication. The loss of a single fragment results in the loss of an
entire fragmented packet, because even if all other fragments are
received correctly, the original packet cannot be reassembled and
delivered. This fundamental issue with fragmentation exists for both
IPv4 and IPv6. In addition, some network address translators (NATs) and firewalls drop IP fragments. The network address translation performed by a NAT only operates on complete IP packets, and some firewall policies also require inspection of complete IP packets. Even with these being the case, some NATs and firewalls simply do not implement the necessary reassembly functionality, and instead choose to drop all fragments. Finally, <xref target="RFC4963"/> documents other issues specific to IPv4 fragmentation.
		</t>
		<t>
Due to these issues, an application SHOULD NOT send UDP datagrams that result in IP packets that exceed the MTU of the path to the destination. Consequently, an application SHOULD either use the path MTU information provided by the IP layer or implement path MTU discovery itself <xref target="RFC1191"/><xref target="RFC1981"/><xref target="RFC4821"/> to determine whether the path to a destination will support its desired message size without fragmentation.
		</t>
		<t>
Applications that do not follow this recommendation to do PMTU
discovery SHOULD still avoid sending UDP datagrams that would result
in IP packets that exceed the path MTU. Because the actual path MTU is
unknown, such applications SHOULD fall back to sending messages that
are shorter than the default effective MTU for sending (EMTU_S in <xref target="RFC1122"/>). For IPv4, EMTU_S is the smaller of 576 bytes and the first-hop MTU <xref target="RFC1122"/>. For IPv6, EMTU_S is 1280 bytes <xref target="RFC2460"/>. The effective PMTU for a directly connected destination (with no routers on the path) is the configured interface MTU, which could be less than the maximum link payload size. Transmission of minimum-sized UDP datagrams is inefficient over paths that support a larger PMTU, which is a second reason to implement PMTU discovery.
		</t>
		<t>
To determine an appropriate UDP payload size, applications MUST subtract the size of the IP header (which includes any IPv4 optional headers or IPv6 extension headers) as well as the length of the UDP header (8 bytes) from the PMTU size. This size, known as the MMS_S, can be obtained from the TCP/IP stack <xref target="RFC1122"/>. 
		</t>
		<t>
Applications that do not send messages that exceed the effective PMTU of IPv4 or IPv6 need not implement any of the above mechanisms. Note that the presence of tunnels can cause an additional reduction of the effective PMTU, so implementing PMTU discovery may be beneficial.
		</t>
		<t>
Applications that fragment an application-layer	message into multiple UDP datagrams SHOULD perform this fragmentation so that each datagram can be received independently, and be independently retransmitted in the case where an application implements its own reliability mechanisms.	
		</t>	
	</section>

	<section title="Reliability Guidelines" anchor="reguide">
		<t>
Application designers are generally aware that UDP does not provide any reliability, e.g., it does not retransmit any lost packets. Often, this is a main reason to consider UDP as a transport. Applications that do require reliable message delivery MUST implement an appropriate mechanism themselves. 
		</t>
		<t>
UDP also does not protect against datagram duplication, i.e., an application may receive multiple copies of the same UDP datagram. Application designers SHOULD verify that their application handles datagram duplication gracefully, and may consequently need to implement mechanisms to detect duplicates. Even if UDP datagram reception triggers idempotent operations, applications may want to suppress duplicate datagrams to reduce load.
		</t>
		<t>
In addition, the Internet can significantly delay some packets with respect to others, e.g., due to routing transients, intermittent connectivity, or mobility. This can cause reordering, where UDP datagrams arrive at the receiver in an order different from the transmission order. Applications that require ordered delivery MUST reestablish datagram ordering themselves. 		</t>
		<t>
Finally, it is important to note that delay spikes can be very large. This can cause reordered packets to arrive many seconds after they were sent. <xref target="RFC0793"/> defines the maximum delay a TCP segment should experience -- the Maximum Segment Lifetime (MSL) -- as 2 minutes. No other RFC defines an MSL for other transport protocols or IP itself. This document clarifies that the MSL value to be used for UDP SHOULD be the same 2 minutes as for TCP. Applications SHOULD be robust to the reception of delayed or duplicate packets that are received within this 2-minute interval.
		</t>
		<t>
An application that requires reliable and ordered message delivery SHOULD choose an IETF standard transport protocol that provides these features. If this is not possible, it will need to implement a set of appropriate mechanisms itself.
		</t>
	</section>

	<section title="Checksum Guidelines" anchor="chkguide">
		<t>
The UDP header includes an optional, 16-bit one's complement checksum
that provides an integrity check. This results in a relatively weak
protection in terms of coding theory <xref target="RFC3819"/>, and
application developers SHOULD implement additional checks where data
integrity is important, e.g., through a Cyclic Redundancy Check (CRC)
included with the data to verify the integrity of an entire
object/file sent over the UDP service.
		</t>
		<t>
The UDP checksum provides a statistical guarantee that the payload was not corrupted in transit. It also allows the receiver to verify that it was the intended destination of the packet, because it covers the IP addresses, port numbers, and protocol number, and it verifies that the packet is not truncated or padded, because it covers the size field. It therefore protects an application against receiving corrupted payload data in place of, or in addition to, the data that was sent. This check is not strong from a coding or cryptographic perspective, and is not designed to detect physical-layer errors or malicious modification of the datagram <xref target="RFC3819"/>.
		</t>
		<t>
Applications SHOULD enable UDP checksums, although <xref target="RFC0768"/> permits the option to disable their use. Applications that choose to disable UDP checksums when transmitting over IPv4 therefore MUST NOT make assumptions regarding the correctness of received data and MUST behave correctly when a UDP datagram is received that was originally sent to a different destination or is otherwise corrupted. The use of the UDP checksum is REQUIRED when applications transmit UDP over IPv6 <xref target="RFC2460"/>.
		</t>

		<section title="UDP-Lite" anchor="udplite">
		<t>
A special class of applications can derive benefit from having partially-damaged payloads delivered, rather than discarded, when using paths that include error-prone links. Such applications can tolerate payload corruption and MAY choose to use the Lightweight User Datagram Protocol (UDP-Lite) <xref target="RFC3828"/> variant of UDP instead of basic UDP. Applications that choose to use UDP-Lite instead of UDP should still follow the congestion control and other guidelines described for use with UDP in <xref target="udpguide"/>. 
		</t>
		<t>
UDP-Lite changes the semantics of the UDP "payload length" field to that of a "checksum coverage length" field. Otherwise, UDP-Lite is semantically identical to UDP. The interface of UDP-Lite differs from that of UDP by the addition of a single (socket) option that communicates a checksum coverage length value: at the sender, this specifies the intended checksum coverage, with the remaining unprotected part of the payload called the "error-insensitive part". By default, the UDP-Lite checksum coverage extends across the entire datagram. If required, an application may dynamically modify this length value, e.g., to offer greater protection to some messages. UDP-Lite always verifies that a packet was delivered to the intended destination, i.e., always verifies the header fields. Errors in the insensitive part will not cause a UDP datagram to be discarded by the destination. Applications using UDP-Lite therefore MUST NOT make assumptions regarding the correctness of the data received in the insensitive part of the UDP-Lite payload.
		</t>
		<t>
The sending application SHOULD select the minimum checksum coverage to include all sensitive protocol headers. For example, applications that use the Real-Time Protocol (RTP) <xref target="RFC3550"/> will likely want to protect the RTP header against corruption. Applications, where appropriate, MUST also introduce their own appropriate validity checks for protocol information carried in the insensitive part of the UDP-Lite payload (e.g., internal CRCs).
		</t>
		<t>
The receiver must set a minimum coverage threshold for incoming packets
that is not smaller than the smallest coverage used by the sender <xref target="RFC3828"/>. The receiver SHOULD select a threshold that is sufficiently large to block packets with an inappropriately short coverage field. This may
be a fixed value, or may be negotiated by an application. UDP-Lite does not
provide mechanisms to negotiate the checksum coverage between the sender and
receiver. 
		</t>
		<t>
Applications may still experience packet loss, rather than corruption, when
using UDP-Lite. The enhancements offered by UDP-Lite rely upon a link being
able to intercept the UDP-Lite header to correctly identify the
partial coverage required. When tunnels and/or encryption are used, this can
result in UDP-Lite datagrams being treated the same as UDP datagrams,
i.e., result in packet loss. Use of IP fragmentation can also prevent
special treatment for UDP-Lite datagrams, and this is another reason why applications SHOULD avoid IP fragmentation (<xref target="msguide"/>). 

		</t>
		</section>
		
	</section>

	<section title="Middlebox Traversal Guidelines" anchor="natguide">
	<t>
Network address translators (NATs) and firewalls are examples of intermediary devices ("middleboxes") that can exist along an end-to-end path. A middlebox typically performs a function that requires it to maintain per-flow state. For connection-oriented protocols, such as TCP, middleboxes snoop and parse the connection-management traffic and create and destroy per-flow state accordingly. For a connectionless protocol such as UDP, this approach is not possible. Consequently, middleboxes may create per-flow state when they see a packet that indicates a new flow, and destroy the state after some period of time during which no packets belonging to the same flow have arrived.
	</t>
	<t>
Depending on the specific function that the middlebox performs, this
behavior can introduce a time-dependency that restricts the kinds of
UDP traffic exchanges that will be successful across the
middlebox. For example, NATs and firewalls typically define the
partial path on one side of them to be interior to the domain they
serve, whereas the partial path on their other side is defined to be
exterior to that domain. Per-flow state is typically created when the
first packet crosses from the interior to the exterior, and while the
state is present, NATs and firewalls will forward return
traffic. Return traffic that arrives after the per-flow state has
timed out is dropped, as is other traffic that arrives from the exterior.
	</t>
	<t>
Many applications that use UDP for communication operate across middleboxes without needing to employ additional mechanisms. One example is the Domain Name System (DNS), which has a strict request-response communication pattern that typically completes within seconds.
	</t>
	<t>
Other applications may experience communication failures when middleboxes destroy the per-flow state associated with an application session during periods when the application does not exchange any UDP traffic. Applications SHOULD be able to gracefully handle such communication failures and implement mechanisms to re-establish application-layer sessions and state.
	</t>
	<t>
For some applications, such as media transmissions, this re-synchronization is highly undesirable, because it can cause user-perceivable playback artifacts. Such specialized applications MAY send periodic keep-alive messages to attempt to refresh middlebox state. It is important to note that keep-alive messages are NOT RECOMMENDED for general use -- they are unnecessary for many applications and  can consume significant amounts of system and network resources.
	</t>


	<t>
An application that needs to employ keep-alives to deliver useful
service over UDP in the presence of middleboxes SHOULD NOT transmit
them more frequently than once every 15 seconds and SHOULD use longer
intervals when possible. No common timeout has been specified for
per-flow UDP state for arbitrary middleboxes. NATs require a state timeout of 2 minutes or
longer <xref target="RFC4787"/>. However, empirical evidence suggests that a significant
fraction of currently deployed middleboxes unfortunately use shorter
timeouts. The timeout of 15 seconds originates with the Interactive
Connectivity Establishment (ICE) protocol <xref target="ICE"/>. When
applications are deployed in more controlled network environments, the
deployers SHOULD investigate whether the target environment allows
applications to use longer intervals, or whether it offers mechanisms
to explicitly control middlebox state timeout durations, for example,
using Middlebox Communications (MIDCOM) <xref target="RFC3303"/>, Next
Steps in Signaling (NSIS) <xref target="NSLP"/>, or Universal Plug
and Play (UPnP) <xref target="UPnP"/>. It is RECOMMENDED that applications apply slight random variations ("jitter") to the timing of keep-alive transmissions, to reduce the potential for persistent synchronization between keep-alive transmissions from different hosts.
	</t>
	<t>
Sending keep-alives is not a substitute for implementing robust connection handling. Like all UDP datagrams, keep-alives can be delayed or dropped, causing middlebox state to time out. In addition, the congestion control guidelines in <xref target="ccguide"/> cover all UDP transmissions by an application, including the transmission of middlebox keep-alives. Congestion control may thus lead to delays or temporary suspension of keep-alive transmission.
	</t>
	<t>
Keep-alive messages are NOT RECOMMENDED for general use. They are
unnecessary for many applications and may consume significant
resources.  For example, on battery-powered devices, if an application needs to maintain connectivity for long periods with little traffic, the frequency at which keep-alives are sent can become the determining factor that governs power consumption, depending on the underlying network technology. Because many middleboxes are designed to require keep-alives for TCP connections at a frequency that is much lower than that needed for UDP, this difference alone can often be sufficient to prefer TCP over UDP for these deployments. On the other hand, there is anecdotal evidence that suggests that direct communication through middleboxes, e.g., by using ICE <xref target="ICE"/>, does succeed less often with TCP than with UDP. The tradeoffs between different transport protocols -- especially when it comes to middlebox traversal -- deserve careful analysis.
	</t>		
	</section>

	<section title="Programming Guidelines" anchor="progguide">
	<t>
The de facto standard application programming interface (API) for TCP/IP applications is the "sockets" interface <xref target="POSIX"/>. Some platforms also offer applications the ability to directly assemble and transmit IP packets through "raw sockets" or similar facilities. This is a second, more cumbersome method of using UDP. The guidelines in this document cover all such methods through which an application may use UDP. Because the sockets API is by far the most common method, the remainder of this section discusses it in more detail.
	</t>
	<t>
Although the sockets API was developed for UNIX in the early 1980s, a wide variety of non-UNIX operating systems also implement this. The sockets API supports both IPv4 and IPv6 <xref target="RFC3493"/>. The UDP sockets API differs from that for TCP in several key ways. Because application programmers are typically more familiar with the TCP sockets API, the remainder of this section discusses these differences. <xref target="STEVENS"/> provides usage examples of the UDP sockets API.  
	</t>
	<t>
UDP datagrams may be directly sent and received, without any
connection setup. Using the sockets API, applications can receive
packets from more than one IP source address on a single UDP
socket. Some servers use this to exchange data with more than one
remote host through a single UDP socket at the same time. Many
applications need to ensure that they receive packets from a
particular source address; these applications MUST implement corresponding checks at the application layer or explicitly request that the operating system filter the received packets.
	</t>
	<t>
If a client/server application executes on a host with more than one IP interface, the application SHOULD send any UDP responses with an IP source address that matches the IP destination address of the UDP datagram that carried the request (see <xref target="RFC1122"/>, Section 4.1.3.5). Many middleboxes expect this transmission behavior and drop replies that are sent from a different IP address, as explained in <xref target="natguide"/>. 
	</t>
	<t>
A UDP receiver can receive a valid UDP datagram with a zero-length payload. Note that this is different from a return value of zero from a read() socket call, which for TCP indicates the end of the connection. 
	</t>
	<t>
Many operating systems also allow a UDP socket to be connected, i.e., to bind a UDP socket to a specific pair of addresses and ports. This is similar to the corresponding TCP sockets API functionality. However, for UDP, this is only a local operation that serves to simplify the local send/receive functions and to filter the traffic for the specified addresses and ports. Binding a UDP socket does not establish a connection -- UDP does not notify the remote end when a local UDP socket is bound. Binding a socket also allows configuring options that affect the UDP or IP layers, for example, use of the UDP checksum or the IP Timestamp option. On some stacks, a bound socket also allows an application to be notified when ICMP error messages are received for its transmissions <xref target="RFC1122"/>.
	</t>
	<t>
UDP provides no flow-control. This is another reason why UDP-based applications need to be robust in the presence of packet loss. This loss can also occur within the sending host, when an application sends data faster than the line rate of the outbound network interface. It can also occur on the destination, where receive calls fail to return all the data that was sent when the application issues them too infrequently (i.e., such that the receive buffer overflows). Robust flow control mechanisms are difficult to implement, which is why applications that need this functionality SHOULD consider using a full-featured transport protocol.
	</t>
	<t>
When an application closes a TCP, SCTP or DCCP socket, the transport protocol on the receiving host is required to maintain TIME-WAIT state. This prevents delayed packets from the closed connection instance from being mistakenly associated with a later connection instance that happens to reuse the same IP address and port pairs. The UDP protocol does not implement such a mechanism. Therefore, UDP-based applications need to be robust in this case. One application may close a socket or terminate, followed in time by another application receiving on the same port. This later application may then receive packets intended for the first application that were delayed in the network.
	</t>
	<t>
The Internet can provide service differentiation to applications based on IP-layer packet markings <xref target="RFC2475"/>. This facility can be used for UDP traffic. Different operating systems provide different interfaces for marking packets to applications. Differentiated services require support from the network, and application deployers need to discuss the provisioning of this functionality with their network operator.
	</t>

	</section>
	
	<section title="ICMP Guidelines" anchor="icmpguide">
	<t>
Applications can utilize information about ICMP error messages that the UDP layer passes up for a variety of purposes [RFC1122]. Applications SHOULD validate that the information in the ICMP message payload, e.g., a reported error condition, corresponds to a UDP datagram that the application actually sent. Note that not all APIs have the necessary functions to support this validation, and some APIs already perform this validation internally before passing ICMP information to the application.
	</t>
	<t>
Any application response to ICMP error messages SHOULD be robust to temporary routing failures, i.e., transient ICMP "unreachable" messages should not normally cause a communication abort. Applications SHOULD appropriately process ICMP messages generated in response to transmitted traffic. A correct response often requires context, such as local state about communication instances to each destination, that although readily available in connection-oriented transport protocols is not always maintained by UDP-based applications. 
	</t>
	</section>

</section>

<section title="Security Considerations" anchor="seccons">
	<t>
UDP does not provide communications security. Applications that need to protect their communications against eavesdropping, tampering, or message forgery SHOULD employ end-to-end security services provided by other IETF protocols. Applications that respond to short requests with potentially large responses are vulnerable to amplification attacks, and SHOULD authenticate the sender before responding. The source IP address of a request is not a useful authenticator, because it can be spoofed.
	</t>
	<t>
One option of securing UDP communications is with IPsec <xref
target="RFC4301"/>, which can provide authentication for flows of IP
packets through the Authentication Header (AH) <xref
target="RFC4302"/> and encryption and/or authentication through the
Encapsulating Security Payload (ESP) <xref
target="RFC4303"/>. Applications use the Internet Key Exchange (IKE)
<xref target="RFC4306"/> to configure IPsec for their
sessions. Depending on how IPsec is configured for a flow, it can
authenticate or encrypt the UDP headers as well as UDP payloads. If an
application only requires authentication, ESP with no encryption but
with authentication is often a better option than AH, because ESP can
operate across middleboxes. An application that uses IPsec requires
the support of an operating system that implements the IPsec protocol suite.
	</t>
	<t>
Although it is possible to use IPsec to secure UDP communications, not all operating systems support IPsec or allow applications to easily configure it for their flows. A second option of securing UDP communications is through Datagram Transport Layer Security (DTLS) <xref target="RFC4347"/>. DTLS provides communication privacy by encrypting UDP payloads. It does not protect the UDP headers. Applications can implement DTLS without relying on support from the operating system.
	</t>
	<t>
Many other options for authenticating or encrypting UDP payloads
exist.  For example, the GSS-API security framework
<xref target="RFC2743"/> or Cryptographic Message Syntax (CMS)
<xref target="RFC3852"/> could be used to protect UDP payloads. The
IETF standard for securing RTP <xref target="RFC3550"/> 
communication sessions over UDP is the Secure Real-time Transport Protocol (SRTP) <xref target="RFC3711"/>.  In some applications, a better solution is to protect larger stand-alone objects, such as files or messages, instead of individual UDP payloads. In these situations, CMS <xref target="RFC3852"/>, S/MIME <xref target="RFC3851"/> or OpenPGP <xref target="RFC4880"/> could be used. In addition, there are many non-IETF protocols in this area.
	</t>
	<t>
Like congestion control mechanisms, security mechanisms are difficult to design and implement correctly. It is hence RECOMMENDED that applications employ well-known standard security mechanisms such as DTLS or IPsec, rather than inventing their own.
	</t>
	<t>
The Generalized TTL Security Mechanism (GTSM) <xref target="RFC5082"/> may be used with UDP applications (especially when the intended endpoint is on the same link as the sender). This is a lightweight mechanism that allows a receiver to filter unwanted packets.	
	</t>
	<t>
In terms of congestion control, <xref target="RFC2309"/> and <xref target="RFC2914"/> discuss the dangers of congestion-unresponsive flows to the Internet. This document provides guidelines to designers of UDP-based applications to congestion-control their transmissions, and does not raise any additional security concerns.
	</t>
</section>

<section title="Summary">
	<t>
This section summarizes the guidelines made in Sections
<xref target="udpguide" format="counter"/> and <xref target="seccons" format="counter"/> in a tabular format (<xref target="sumtable"/>) for easy referencing.
	</t>

<texttable anchor="sumtable" title="Summary of recommendations">
<ttcol>Recommendation</ttcol>
<ttcol>Section</ttcol>

<c>MUST tolerate a wide range of Internet path conditions</c>
<c><xref target="udpguide" format="counter"/></c>
<c>SHOULD use a full-featured transport (TCP, SCTP, DCCP)</c>
<c/>
<c>&nbsp;</c><c>&nbsp;</c>

<c>SHOULD control rate of transmission</c>
<c><xref target="ccguide" format="counter"/></c>
<c>SHOULD perform congestion control over all traffic</c>
<c/>
<c>&nbsp;</c><c>&nbsp;</c>

<c>for bulk transfers,</c>
<c><xref target="btguide" format="counter"/></c>
<c>SHOULD consider implementing TFRC</c>
<c/>
<c>else, SHOULD in other ways use bandwidth similar to TCP</c>
<c/>

<c>&nbsp;</c><c>&nbsp;</c>

<c>for non-bulk transfers,</c>
<c><xref target="ldrguide" format="counter"/></c>
<c>SHOULD measure RTT and transmit max. 1 datagram/RTT</c>
<c/>
<c>else, SHOULD send at most 1 datagram every 3 seconds</c>
<c/>
<c>SHOULD back-off retransmission timers following loss</c>
<c/>
<c>&nbsp;</c><c>&nbsp;</c>

<c>for tunnels carrying IP Traffic,</c>
<c><xref target="tunguide" format="counter"/></c>
<c>SHOULD NOT perform congestion control</c>
<c/>
<c>&nbsp;</c><c>&nbsp;</c>

<c>for non-IP tunnels or rate not determined by traffic,</c>
<c><xref target="tunguide" format="counter"/></c>
<c>SHOULD perform congestion control</c>
<c/>
<c>&nbsp;</c><c>&nbsp;</c>

<c>SHOULD NOT send datagrams that exceed the PMTU, i.e.,</c>
<c><xref target="msguide" format="counter"/></c>
<c>SHOULD discover PMTU or send datagrams &lt; minimum PMTU</c>
<c/>
<c>&nbsp;</c><c>&nbsp;</c>


<c>SHOULD handle datagram loss, duplication, reordering</c>
<c><xref target="reguide" format="counter"/></c>
<c>SHOULD be robust to delivery delays up to 2 minutes</c>
<c/>
<c>&nbsp;</c><c>&nbsp;</c>

<c>SHOULD enable IPv4 UDP checksum</c>
<c><xref target="chkguide" format="counter"/></c>
<c>MUST enable IPv6 UDP checksum</c>
<c/>
<c>else, MAY use UDP-Lite with suitable checksum coverage</c>
<c><xref target="udplite" format="counter"/></c>
<c>&nbsp;</c><c>&nbsp;</c>

<c>SHOULD NOT always send middlebox keep-alives</c>
<c><xref target="natguide" format="counter"/></c>
<c>MAY use keep-alives when needed (min. interval 15 sec)</c>
<c/>
<c>&nbsp;</c><c>&nbsp;</c>

<c>MUST check IP source address</c>
<c><xref target="progguide" format="counter"/></c>
<c>and, for client/server applications</c>
<c/>
<c>SHOULD send responses from src address matching request</c>
<c/>


<c>&nbsp;</c><c>&nbsp;</c>

<c>SHOULD use standard IETF security protocols when needed</c>
<c><xref target="seccons" format="counter"/></c>

</texttable>
</section>

<section title="Acknowledgments" anchor="ack">
	<t>
Thanks to Paul Aitken, Mark Allman, Francois Audet, Iljitsch van Beijnum, Stewart Bryant, Remi Denis-Courmont, Lisa Dusseault, Wesley Eddy, Pasi Eronen, Sally Floyd, Robert Hancock, Jeffrey Hutzelman, Cullen Jennings, Tero Kivinen, Peter Koch, Jukka Manner, Philip Matthews, Joerg Ott, Colin Perkins, Tom Petch, Carlos Pignataro, Pasi Sarolahti, Pascal Thubert, Joe Touch, Dave Ward, and Magnus Westerlund for their comments on this document.
	</t>
	<t>
The middlebox traversal guidelines in <xref target="natguide"/> incorporate ideas from Section 5 of <xref target="BEHAVE-APP"/> by Bryan Ford, Pyda Srisuresh, and Dan Kegel.
	</t>
	<t>
Lars Eggert is partly funded by <xref target="TRILOGY"/>, a research
project supported by the European Commission under its Seventh
Framework Program. Gorry Fairhurst was partly funded by the EC SatNEx project.
	</t>
</section>
</middle>


<back>
<references title='Normative References'>
	<?rfc include="reference.RFC.0768" ?>
	<?rfc include="reference.RFC.0793" ?>
	<?rfc include="reference.RFC.1122" ?>
	<?rfc include="reference.RFC.1191" ?>	
	<?rfc include="reference.RFC.1981" ?>	
	<?rfc include="reference.RFC.2119" ?>
	<?rfc include="reference.RFC.2460" ?>
	<?rfc include="reference.RFC.2914" ?>
	<?rfc include="reference.RFC.2988" ?>	
	<?rfc include="reference.RFC.3828" ?>	
	<?rfc include="reference.RFC.4787" ?>
	<?rfc include="reference.RFC.4821" ?>	
	<?rfc include="reference.RFC.5348" ?>
</references>

<references title='Informative References'>
	<?rfc include="reference.RFC.0896" ?>
	<?rfc include="reference.RFC.0919" ?>
	<?rfc include="reference.RFC.1112" ?>
	<?rfc include="reference.RFC.1536" ?>
	<?rfc include="reference.RFC.1546" ?>
	<?rfc include="reference.RFC.2309" ?>	
	<?rfc include="reference.RFC.2475" ?>	
	<?rfc include="reference.RFC.2675" ?>	
	<?rfc include="reference.RFC.2743" ?>	
	<?rfc include="reference.RFC.3048" ?>
	<?rfc include="reference.RFC.3124" ?>
	<?rfc include="reference.RFC.3261" ?>
	<?rfc include="reference.RFC.3303" ?>
	<?rfc include="reference.RFC.3493" ?>
	<?rfc include="reference.RFC.3550" ?>
	<?rfc include="reference.RFC.3551" ?>
	<?rfc include="reference.RFC.5082" ?>
	<?rfc include="reference.RFC.3711" ?>
	<?rfc include="reference.RFC.3738" ?>
	<?rfc include="reference.RFC.3758" ?>
	<?rfc include="reference.RFC.3819" ?>	
	<?rfc include="reference.RFC.3851" ?>
	<?rfc include="reference.RFC.3852" ?>
	<?rfc include="reference.RFC.4301" ?>
	<?rfc include="reference.RFC.4302" ?>
	<?rfc include="reference.RFC.4303" ?>
	<?rfc include="reference.RFC.4306" ?>
	<?rfc include="reference.RFC.4340" ?>
	<?rfc include="reference.RFC.4341" ?>
	<?rfc include="reference.RFC.4342" ?>
	<?rfc include="reference.RFC.4347" ?>
	<?rfc include="reference.RFC.4654" ?>
	<?rfc include="reference.RFC.4880" ?>
	<?rfc include="reference.RFC.4960" ?>
	<?rfc include="reference.RFC.4963" ?>
	<?rfc include="reference.RFC.4987" ?>

<!--	<?rfc include="reference.I-D.ietf-dccp-ccid4" ?>     -->

<reference anchor='CCID4'>
<front>
<title>Profile for Datagram Congestion Control Protocol (DCCP) Congestion ID 4: TCP-Friendly Rate Control for Small Packets (TFRC-SP)</title>

<author initials='S' surname='Floyd' fullname='Sally Floyd'>
    <organization />
</author>

<author initials='E' surname='Kohler' fullname='Eddie Kohler'>
    <organization />
</author>

<date month='February' day='9' year='2008' />

<abstract><t>This document specifies an experimental profile for Congestion Control Identifier 4, the Small-Packet variant of TCP-Friendly Rate Control (TFRC), in the Datagram Congestion Control Protocol (DCCP). CCID 4 is for experimental use, and uses TFRC-SP [RFC4828], a variant of TFRC designed for applications that send small packets.  CCID 4 is considered experimental because TFRC-SP is itself experimental, and is not proposed for widespread deployment in the global Internet at this time.  The goal for TFRC-SP is to achieve roughly the same bandwidth in bits per second (bps) as a TCP flow using packets of up to 1500 bytes but experiencing the same level of congestion.  CCID 4 is for experimental use for senders that send small packets and would like a TCP-friendly sending rate, possibly with Explicit Congestion Notification (ECN), while minimizing abrupt rate changes.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress'/>

</reference>


<!--	<?rfc include="reference.I-D.ietf-mmusic-ice" ?>     -->

<reference anchor='ICE'>
<front>
<title>Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</title>

<author initials='J' surname='Rosenberg' fullname='Jonathan Rosenberg'>
    <organization />
</author>

<date month='October' day='29' year='2007' />

<abstract><t>This document describes a protocol for Network Address Translator (NAT) traversal for UDP-based multimedia sessions established with the offer/answer model.  This protocol is called Interactive Connectivity Establishment (ICE).  ICE makes use of the Session Traversal Utilities for NAT (STUN) protocol and its extension, Traversal Using Relay NAT (TURN).  ICE can be used by any protocol utilizing the offer/answer model, such as the Session Initiation Protocol (SIP).</t></abstract>

</front>
<seriesInfo name='Work in' value='Progress'/>

</reference>

<!--	<?rfc include="reference.I-D.ietf-nsis-nslp-natfw" ?>-->

<reference anchor='NSLP'>
<front>
<title>NAT/Firewall NSIS Signaling Layer Protocol (NSLP)</title>

<author initials='M' surname='Stiemerling' fullname='Martin Stiemerling'>
    <organization />
</author>

<author initials='H' surname='Tschofenig' fullname='Hannes Tschofenig'>
    <organization />
</author>

<author initials='C' surname='Aoun' fullname='Cedric Aoun'>
    <organization />
</author>

<author initials='E' surname='Davies' fullname='Elwyn Davies'>
    <organization />
</author>

<date month='September' day='30' year='2008' />

<abstract><t>This memo defines the NSIS Signaling Layer Protocol (NSLP) for Network Address Translators (NATs) and firewalls.  This NSLP allows hosts to signal on the data path for NATs and firewalls to be configured according to the needs of the application data flows.  For instance, it enables hosts behind NATs to obtain a public reachable address and hosts behind firewalls to receive data traffic.  The overall architecture is given by the framework and requirements defined by the Next Steps in Signaling (NSIS) working group.  The network scenarios, the protocol itself, and examples for path-coupled signaling are given in this memo.</t></abstract>

</front>
<seriesInfo name='Work in' value='Progress'/>
</reference>


<!--	<?rfc include="reference.I-D.ford-behave-app" ?>     -->
<reference anchor='BEHAVE-APP'>
<front>
<title>Application Design Guidelines for Traversal through Network Address Translators</title>

<author initials='B' surname='Ford' fullname='Bryan Ford'>
    <organization />
</author>

<date month='March' day='7' year='2007' />

<abstract><t>This document defines guidelines by which application designers can create applications that communicate reliably and efficiently in the presence of Network Address Translators (NATs), particularly when the application has a need for "peer-to-peer" (P2P) type of communication. The guidelines allow a P2P application to work reliably across a majority of existing NATs, as well as all future NATs that conform to the behave requirements specified in companion documents. The NAT traversal techniques described in the document do not require the use of special proxy or relay protocols, do not require specific knowledge about the network topology or the number and type of NATs in the path, and do not require any modifications to IP or transport-layer protocols on the end hosts.</t></abstract>

</front>
<seriesInfo name='Work in' value='Progress'/>
</reference>

<!--	<?rfc include="reference.I-D.ietf-nsis-ntlp" ?>	     -->

<reference anchor='GIST'>
<front>
<title>GIST: General Internet Signalling Transport</title>

<author initials='H' surname='Schulzrinne' fullname='Henning Schulzrinne'>
    <organization />
</author>

<author initials='R' surname='Hancock' fullname='Robert  Hancock'>
    <organization />
</author>

<date month='July' day='14' year='2008' />

<abstract><t>This document specifies protocol stacks for the routing and transport of per-flow signalling messages along the path taken by that flow through the network.  The design uses existing transport and security protocols under a common messaging layer, the General Internet Signalling Transport (GIST), which provides a common service for diverse signalling applications.  GIST does not handle signalling application state itself, but manages its own internal state and the configuration of the underlying transport and security protocols to enable the transfer of messages in both directions along the flow path.  The combination of GIST and the lower layer transport and security protocols provides a solution for the base protocol component of the "Next Steps in Signalling" framework.</t></abstract>

</front>
<seriesInfo name='Work in' value='Progress'/>
</reference>



        <reference anchor="POSIX">
                <front>
                        <title>Standard for Information Technology - Portable Operating System Interface (POSIX)</title>
                        <author initials="" surname="IEEE Std. 1003.1-2001">
                                <organization />
                        </author>
                        <date month="December" year="2001"/>
                </front>
                <seriesInfo name="Open Group Technical Standard: Base Specifications" value="Issue 6, ISO/IEC 9945:2002"/>
        </reference>

        <reference anchor="STEVENS">
                <front>
                        <title>UNIX Network Programming, The sockets Networking API</title>
                        <author initials="W. R." surname="Stevens">
                                <organization />
                        </author>
                        <author initials="B." surname="Fenner">
                                <organization />
                        </author>
                        <author initials="A. M." surname="Rudoff">
                                <organization />
                        </author>
                        <date month="Addison-Wesley," year="2004"/>
                </front>
        </reference>

      <reference anchor="UPnP">
        <front>
          <title>Internet Gateway Device (IGD) Standardized Device Control Protocol V 1.0</title>

          <author surname="UPnP Forum">
            <organization/>
          </author>

          <date month="November" year="2001"/>
        </front>
      </reference>
      
        <reference anchor="FABER">
                <front>
                        <title>The TIME-WAIT State in TCP and Its Effect on Busy Servers</title>
                        <author initials="T." surname="Faber">
                                <organization />
                        </author>
                        <author initials="J." surname="Touch">
                                <organization />
                        </author>
                        <author initials="W." surname="Yue">
                                <organization />
                        </author>
                        <date month="March" year="1999"/>
                </front>
                <seriesInfo name="Proc." value="IEEE Infocom"/>
        </reference>

        <reference anchor="TRILOGY" target="http://www.trilogy-project.org">
                <front>
                        <title>Trilogy Project</title>
                        <author><organization /></author>
                </front>

        </reference>


</references>
</back>
</rfc>
