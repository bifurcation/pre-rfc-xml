<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="exp" ipr="trust200902" number="8459" submissionType="IETF" consensus="yes" >

  <front>
    <title abbrev="hSFC">Hierarchical Service Function Chaining (hSFC)</title>

    <author fullname="David Dolson" initials="D." surname="Dolson">
      <organization>Sandvine</organization>

      <address>
        <postal>
          <street></street>


          <city>Waterloo</city>

          <region>ON</region>

          <code></code>

          <country>Canada</country>
        </postal>

        <phone></phone>

        <email>ddolson@acm.org</email>

      </address>
    </author>

    <author fullname="Shunsuke Homma" initials="S." surname="Homma">
      <organization abbrev="NTT">NTT</organization>

      <address>
        <postal>
          <street>3-9-11, Midori-cho</street>

          <city>Musashino-shi</city>

          <region>Tokyo</region>

          <code>180-8585</code>

          <country>Japan</country>
        </postal>

        <email>homma.shunsuke@lab.ntt.co.jp</email>
      </address>
    </author>

    <author fullname="Diego R. Lopez" initials="D. R." surname="Lopez">
      <organization>Telefonica I+D</organization>

      <address>
        <postal>
          <street>Don Ramon de la Cruz, 82</street>

          <city>Madrid</city>

          <region></region>

          <code>28006</code>

          <country>Spain</country>
        </postal>

        <phone>+34 913 129 041</phone>

        <email>diego.r.lopez@telefonica.com</email>


      </address>
    </author>

    <author fullname="Mohamed Boucadair" initials="M." surname="Boucadair">
      <organization>Orange</organization>

      <address>
        <postal>
          <street></street>

          <city>Rennes</city>

          <code>35000</code>

          <country>France</country>
        </postal>

        <email>mohamed.boucadair@orange.com</email>
      </address>
    </author>

    <date month="September" year="2018" />


    <area>Routing Area</area>

    <workgroup>Service Function Chaining</workgroup>

    <keyword>Scalability</keyword>

    <keyword>SFC-enabled domain</keyword>

    <keyword>multiple control domains</keyword>

    <keyword>SFC complexity</keyword>

    <keyword>Hierarchy</keyword>

    <keyword>service delivery</keyword>

    <keyword>service complications</keyword>

    <keyword>service offering</keyword>

    <keyword>differentiated services</keyword>

    <keyword>large scale network</keyword>

    <abstract>
      <t>Hierarchical Service Function Chaining (hSFC) is a network
      architecture allowing an organization to decompose a large-scale network
      into multiple domains of administration.</t>

      <t>The goals of hSFC are to make a large-scale network easier to design,
   simpler to control, and supportive of independent functional
   groups within large network operators.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>Service Function Chaining (SFC) is a technique for prescribing
      differentiated traffic-forwarding policies within an SFC-enabled domain.
      The SFC architecture is described in detail in <xref
      target="RFC7665"></xref> and is not repeated here.</t>

      <t>This document focuses on the difficult problem of implementing SFC
      across a large, geographically dispersed network, potentially comprised
      of millions of hosts and thousands of network-forwarding elements and
      which may involve multiple operational teams (with varying functional
      responsibilities). We recognize that some stateful Service Functions
      (SFs) require bidirectional traffic for transport-layer sessions (e.g.,
      NATs, firewalls). We assume that some Service Function Paths (SFPs) need
      to be selected on the basis of transport-layer coordinate (typically,
      the 5-tuple of source IP address, source port number, destination IP
      address, destination port number, and transport protocol) stickiness to
      specific stateful SF instances.</t>


      <t>Difficult problems are often made easier by decomposing them in a
      hierarchical (nested) manner. So, instead of considering a single SFC
      control plane that can manage (create, withdraw, supervise, etc.)
      complete SFPs from one end of the network to the other, we decompose the
      network into smaller domains operated by as many SFC control plane
      components (under the same administrative entity). Coordination between
      such components is further discussed in this document.</t>

      <t>Each subdomain may support a subset of the network applications or a
      subset of the users. Decomposing a network should be done with care to
      ease monitoring and troubleshooting of the network and services as a
      whole. The criteria for decomposing a domain into multiple SFC-enabled
      subdomains are beyond the scope of this document. These criteria are
      deployment specific.</t>

      <t>An example of simplifying a network by using multiple SFC-enabled
      domains is further discussed in <xref
      target="USE-CASES"></xref>.</t>

      <t>We assume the SFC-aware nodes use the Network Service Header (NSH) <xref
      target="RFC8300"></xref> or a similar labeling mechanism. Examples are described in <xref target="app1"></xref>.</t>

      <t>The SFC-enabled domains discussed in this document are assumed to be
      under the control of a single organization (an operator, typically),
      such that there is a strong trust relationship between the domains. The
      intention of creating multiple domains is to improve the ability to
      operate a network. It is outside of the scope of this document to
      consider domains operated by different organizations or dwell on
      interoperator considerations.</t>

      <t>We introduce the concept of an Internal Boundary Node (IBN) that acts
      as a gateway between the levels of the hierarchy. We also discuss
      options for realizing this function.</t>

      <section title="Experiment Goals">
        <t>This document defines an architecture that aims to solve
        complications that may be encountered when deploying SFC in large
        networks. A single network is therefore decomposed into multiple
        subdomains, each treated as an SFC-enabled domain. Levels of
        hierarchy are defined, together with SFC operations that are specific
        to each level. In order to ensure consistent SFC operations when
        multiple subdomains are involved, this document identifies and
        analyzes various options for IBNs to glue the layers together (<xref
        target="section_strategies"></xref>).</t>

        <t>Because it does not make any assumptions about (1) how
        subdomains are defined, (2) whether one or multiple IBNs are enabled
        per subdomain, (3) whether the same IBN is solicited at both the
        ingress and egress of a subdomain for the same flow, (4) the nature
        of the internal paths to reach SFs within a subdomain, or (5) the
        lack of deployment feedback, this document does not call for a
        recommended option to glue the SFC layers together.</t>

        <t>Further experiments are required to test and evaluate the different
        options. A recommendation for hSFC might be documented in a future
        specification when the results of implementation and deployment of the
        aforementioned options are available.</t>

        <t>It is not expected that all the options discussed in this document
        will be implemented and deployed. The lack of an implementation might
        be seen as a signal to recommend against a given option.</t>
      </section>
    </section>

    <section title="Terminology">
      <t>This document makes use of the terms defined in Section 1.4 of <xref
      target="RFC7665"></xref> and Section 1.3 of <xref
      target="RFC8300"></xref>.</t>



      <t>The following terms are defined:<list style="symbols">
          <t>Upper-level domain: the entire network domain to be
          managed.</t>



          <t>Lower-level domain: a portion of the network (called a
          subdomain).</t>

          <t>Internal Boundary Node (IBN): is responsible for bridging packets
          between upper and lower levels of SFC-enabled domains.</t>
        </list></t>

     
    </section>

    <section title="Hierarchical Service Function Chaining (hSFC)">
      <t>A hierarchy has multiple levels: the topmost level encompasses the
      entire network domain to be managed, and lower levels encompass portions
      of the network. These levels are discussed in the following
      subsections.</t>

      <section anchor="hl" title="Upper Level">
        <t>Considering the example depicted in <xref
        target="fig_hierarchical_top"></xref>, a top-level network domain
        includes SFC data plane components distributed over a wide area,
        including: <list style="symbols">
            <t>Classifiers (CFs)</t>

            <t>Service Function Forwarders (SFFs)</t>

            <t>Subdomains</t>
          </list></t>

        <figure anchor="fig_hierarchical_top"
                title="Network-Wide View of Upper Level of Hierarchy">
          <artwork><![CDATA[
                 +------------+
                 |Subdomain#1 |
                 |  in DC1    | 
                 +----+-------+
                      |
              .---- SFF1 ------.   +----+
    +----+   /     /  |         \--|CF#4|
--->|CF#1|--/---->'   |          \ +----+
    +----+ /  SC#1    |           \
           |          |            |
           |          V    .------>|--->
           |         /    /        |
            \         |   /        /
     +----+  \        |  /        /  +----+
     |CF#2|---\       | /        /---|CF#3|
     +----+    '---- SFF2 ------'    +----+
                      |
                 +----+-------+
                 |Subdomain#2 |
                 |   in DC2   |
                 +------------+

   Legend:
      SC#1: Service Chain 1
        DC: Data Center
         ]]></artwork>
        </figure>

        <t>One path is shown from edge classifier (CF#1) to SFF1 to
        Subdomain#1 (residing in Data Center 1) to SFF1 to SFF2 (residing in
        Data Center 2) to Subdomain#2 to SFF2 to network egress.</t>

        <t>For the sake of clarity, components of the underlay network are not
        shown; an underlay network is assumed to provide connectivity between
        SFC data plane components.</t>

        <t>Top-level SFPs carry packets from classifiers through a set of SFFs
        and subdomains, with the operations within subdomains being opaque
        to the upper levels.</t>

        <t>We expect the system to include a top-level control plane having
        responsibility for configuring forwarding policies and traffic-classification rules.</t>

        <t>The top-level Service Chaining control plane manages end-to-end
        service chains and associated service function paths from network edge
        points to subdomains. It also configures top-level classifiers at a coarse
        level (e.g., based on source or destination host) to forward traffic
        along paths that will transit across appropriate subdomains.</t>

        <t><xref target="fig_hierarchical_top"></xref> shows one possible
        service chain passing from the edge through two subdomains to network
        egress. The top-level control plane does not configure traffic-classification rules or forwarding policies within the
        subdomains.</t>

        <t>At this network-wide level, the number of SFPs required is a linear
        function of the number of ways in which a packet is required to
        traverse different subdomains and egress the network. Note that the
        various paths that may be followed within a subdomain are not
        represented by distinct network-wide SFPs; specific policies at the
        ingress nodes of each subdomain bind flows to subdomain paths.</t>

        <t>Packets are classified at the edge of the network to select the
        paths by which subdomains are to be traversed. At the ingress of each
        subdomain, packets are reclassified to paths directing them to the
        required SFs of the subdomain. At the egress of each subdomain,
        packets are returned to the top-level paths. Contrast this with an
        approach requiring the top-level classifier to select paths to specify
        all of the SFs in each subdomain.</t>

        <t>It should be assumed that some SFs require bidirectional symmetry
        of paths (see more in <xref target="section_classifier"></xref>).
        Therefore, the classifiers at the top level must be configured with
        policies ensuring outgoing packets take the reverse path of incoming
        packets through subdomains.</t>
      </section>

      <section anchor="ll" title="Lower Levels">
        <t>Each of the subdomains in <xref
        target="fig_hierarchical_top"></xref> is an SFC-enabled domain.</t>

        <t><xref target="fig_hierarchical_lower"></xref> shows a subdomain
        interfaced with an upper-level domain by means of an Internal Boundary
        Node (IBN). An IBN acts as an SFC-aware SF in the upper-level domain
        and as a classifier in the lower-level domain. As such, data packets
        entering the subdomain are already SFC encapsulated. Also, it is the
        purpose of the IBN to apply classification rules and direct the
        packets to the selected local SFPs terminating at an egress
	IBN. Finally, the
        egress IBN restores packets to the original SFC shim and hands
        them off to SFFs.</t>

        <t>Each subdomain intersects a subset of the total paths that are
        possible in the upper-level domain. An IBN is concerned with
        upper-level paths, but only those traversing its subdomain.</t>

        <t>Each subdomain is likely to have a control plane that can operate
        independently of the top-level control plane, managing classification,
        forwarding paths, etc., within the level of the subdomain, with the
        details being opaque to the upper-level control elements. <xref
        target="ibn"></xref> provides more details about the behavior of an
        IBN.</t>

        <t>The subdomain control plane configures the classification rules in
        the IBN, where SFC encapsulation of the top-level domain is converted
        to/from SFC encapsulation of the lower-level domain. The subdomain
        control plane also configures the forwarding rules in the SFFs of the
        subdomain.</t>

        <figure anchor="fig_hierarchical_lower"
                title="Example of a Subdomain within an Upper-Level Domain">
          <artwork><![CDATA[
  +----+    +-----+  +----------------------+   +-----+
  |    |    | SFF |  |   IBN 1  (in DC 1)   |   | SFF |
  |    |SC#1|     |  |  +----------------+  |   |     |
->|    |===============>|      SFF       |================>
  |    |    +-----+  |  +----------------+  |   +-----+
  | CF |             |   |              ^   |
  |    |             |   v              |   |
  |    |             |+--------------------+|   Upper domain
  |    |             ||CF, fwd/rev mapping ||
  |    |    * * * * *||  and "glue"        || * * * * *
  |    |    *        |+--------------------+|         *
  +----+    *        | | |              | | |    Sub  *
            *        +-o-o--------------o-o-+   domain*
            *     SC#2 | |SC#1          ^ ^       #1  *
            *    +-----+ |              | |           *
            *    |       V              | |           *
            *    |     +---+  +------+  | |           *
            *    |     |SFF|->|SF#1.1|--+ |           *
            *    |     +---+  +------+    |           *
            *    V                        |           *
            *  +---+  +------+  +---+  +------+       *
            *  |SFF|->|SF#2.1|->|SFF|->|SF#2.2|       *
            *  +---+  +------+  +---+  +------+       *
            * * * * * * * * * * * * * * * * * * * * * *
Legend:
     *** Subdomain boundary
     === upper-level chain
     --- lower-level chain
        ]]></artwork>
        </figure>

        <t>If desired, the pattern can be applied recursively. For example,
        SF#1.1 in <xref target="fig_hierarchical_lower"></xref> could be a
        subdomain of the subdomain.</t>
      </section>
    </section>

    <section anchor="ibn" title="Internal Boundary Node (IBN)">
      <t>As mentioned in the previous section, a network element termed an "Internal Boundary Node" (or IBN) is responsible for bridging packets
      between upper and lower layers of SFC-enabled domains. It behaves as an
      SF to the upper level (<xref target="hl"></xref>) and looks like a
      classifier and end of chain to the lower level (<xref
      target="ll"></xref>).</t>

      <t>To achieve the benefits of hierarchy, the IBN should be applying
      fine-grained traffic-classification rules at a lower level than the
      traffic passed to it. This means that the number of SFPs within the
      lower level is greater than the number of SFPs arriving to the IBN.</t>

      <t>The IBN is also the termination of lower-level SFPs. This is because
      the packets exiting lower-level SFPs must be returned to the
      upper-level SFPs and forwarded to the next hop in the upper-level
      domain.</t>

      <t>When different metadata schemes are used at different levels, the IBN
      has further responsibilities: when packets enter the subdomain, the IBN
      translates upper-level metadata into lower-level metadata; and when
      packets leave the subdomain at the termination of lower-level SFPs, the
      IBN translates lower-level metadata into upper-level metadata.</t>

      <t>Appropriately configuring IBNs is key to ensuring the consistency of
      the overall SFC operation within a given domain that enables hSFC.
      Classification rules (or lack thereof) in the IBN classifier can, of
      course, impact upper levels.</t>

      <section anchor="section_strategies" title="IBN Path Configuration">
        <t>The lower-level domain may be provisioned with valid upper-level
        paths or allow any upper-level paths.</t>

        <t>When packets enter the subdomain, the Service Path Identifier
        (SPI) and Service Index (SI) are re-marked according to the path
        selected by the (subdomain) classifier.</t>

        <t>At the termination of an SFP in the subdomain, packets can be
        restored to an original upper-level SFP by implementing one of these
        methods: <list style="numbers">
            <t>Saving the SPI and SI in transport-layer flow state (<xref
            target="section_flow_stateful"></xref>).</t>

            <t>Pushing the SPI and SI into a metadata header (<xref
            target="enco_meta"></xref>).</t>

            <t>Using unique lower-level paths per upper-level path coordinates
            (<xref target="section_unique_paths"></xref>).</t>

            <t>Nesting NSH headers, encapsulating the upper-level NSH headers
            within the lower-level NSH headers (<xref
            target="nest"></xref>).</t>

            <t>Saving the upper level with a flow identifier (ID) and placing an
            hSFC Flow ID into a metadata header (<xref
            target="hybrid"></xref>).</t>
          </list></t>

        <section anchor="section_flow_stateful" title="Flow-Stateful IBN">
          <t>An IBN can be flow aware, returning packets to the correct
          upper-level SFP on the basis, for example, of the transport-layer
          coordinates (typically, a 5-tuple) of packets exiting the
          lower-level SFPs.</t>

          <t>When packets are received by the IBN on an upper-level path, the
          classifier parses encapsulated packets for IP and transport-layer
          (TCP, UDP, etc.) coordinates. State is created, indexed by some or
          all transport coordinates (typically, {source-IP, destination-IP, source-port,
          destination-port, and transport protocol}). The state
          contains, at minimum, the critical fields of the encapsulating SFC
          header (SPI, SI, MD Type, flags); additional information carried in
          the packet (metadata, TTL) may also be extracted and saved as state.
          Note that some fields of a packet may be altered by an SF of
          the subdomain (e.g., source IP address).</t>

          <t>Note that this state is only accessed by the classifier and
          terminator functions of the subdomain. Neither the SFFs nor SFs
          have knowledge of this state; in fact they may be agnostic about
          being in a subdomain.</t>

          <t>One approach is to ensure that packets are terminated at the end of the chain at the same
          IBN that classified the packet at the start
          of the chain. If the packet is returned to a different egress IBN,
          state must be synchronized between the IBNs.</t>


          <t>When a packet returns to the IBN at the end of a chain (which is the
SFP-terminating node of the lower-level chain), the SFC header is
removed, the packet is parsed for flow-identifying information, and
state is retrieved from within the IBN using the flow-identifying
information as index.</t>

          <t>State cannot be created by packets arriving from the lower-level
          chain; when state cannot be found for such packets, they must be
          dropped.</t>

          <t>This stateful approach is limited to use with SFs that retain the
          transport coordinates of the packet. This approach cannot be used
          with SFs that modify those coordinates (e.g., NATs) or otherwise
          create packets for new coordinates other than those received (e.g.,
          as an HTTP cache might do to retrieve content on behalf of the
          original flow). In both cases, the fundamental problem is the
          inability to forward packets when state cannot be found for the
          packet transport-layer coordinates.</t>

          <t>In the stateful approach, there are issues caused by having
          state, such as how long the state should be maintained as well as
          whether the state needs to be replicated to other devices to create
          a highly available network.</t>

          <t>It is valid to consider the state to be disposable after failure,
          since it can be recreated by each new packet arriving from the
          upper-level domain. For example, if an IBN loses all flow state,
          the state is recreated by an endpoint retransmitting a TCP
          packet.</t>

          <t>If an SFC domain handles multiple network regions (e.g., multiple
          private networks), the coordinates may be augmented with additional
          parameters, perhaps using some metadata to identify the network
          region.</t>

          <t>In this stateful approach, it is not necessary for the
          subdomain's control plane to modify paths when upper-level paths
          are changed. The complexity of the upper-level domain does not
          cause complexity in the lower-level domain.</t>

          <t>Since it doesn't depend on NSH in the lower-level domain, this
          flow-stateful approach can be applied to translation methods of
          converting NSH to other forwarding techniques (refer to <xref
          target="section_other_forwarding"></xref>).</t>
        </section>

        <section anchor="enco_meta"
                 title="Encoding Upper-Level Paths in Metadata">
          <t>An IBN can push the upper-level SPI and SI (or encoding thereof)
          into a metadata field of the lower-level encapsulation (e.g.,
          placing upper-level path information into a metadata field of the NSH).
          When packets exit the lower-level path, the upper-level SPI and SI
          can be restored from the metadata retrieved from the packet.</t>

          <t>This approach requires the SFs in the path to be capable of
          forwarding the metadata and appropriately attaching metadata to any
          packets injected for a flow.</t>

          <t>Using a new metadata header may inflate packet size when
          variable-length metadata (NSH MD Type 0x2) is used.</t>

          <t>It is conceivable that the MD Type 0x1 Fixed-Length Context
          Header field of the NSH is not all relevant to the lower-level domain.
          In this case, 32 bits of the Fixed-Length Context Header field could be
          repurposed within the lower-level domain and restored when
          leaving.</t>

          <t>If flags or TTL (see <xref target="section_ttl"></xref>) from the
          original header also need to be saved, more metadata space will be
          consumed.</t>

          <t>In this metadata approach, it is not necessary for the
          subdomain's control element to modify paths when upper-level paths
          are changed. The complexity of the upper-level domain does not
          increase complexity in the lower-level domain.</t>
        </section>

        <section anchor="section_unique_paths"
                 title="Using Unique Paths per Upper-Level Path">
          <t>This approach assumes that paths within the subdomain are
          constrained so that an SPI (of the subdomain) unambiguously
          indicates the egress SPI and SI (of the upper domain). This allows
          the original path information to be restored at subdomain egress
          from a look-up table using the subdomain SPI.</t>

          <t>Whenever the upper-level domain provisions a path via the
          lower-level domain, the lower-level domain control plane must
          provision corresponding paths to traverse the lower-level
          domain.</t>

          <t>A downside of this approach is that the number of paths in the
          lower-level domain is multiplied by the number of paths in the
          upper-level domain that traverse the lower-level domain. That is, a
          subpath must be created for each combination of upper SPI/SI and
          lower chain. The number of paths required for lower-level domains
          will increase exponentially as hierarchy becomes deep.</t>

          <t>A further downside of this approach is that it requires upper
          and lower levels to utilize the same metadata configuration.</t>

          <t>Furthermore, this approach does not allow any information to be
          stashed away in state or embedded in metadata. For example, the TTL
          modifications by the lower level cannot be hidden from the upper
          level.</t>
        </section>

        <section anchor="nest"
                 title="Nesting Upper-Level NSH within Lower-Level NSH">
          <t>When packets arrive at an IBN in the top-level domain, the
          classifier in the IBN determines the path for the lower-level domain
          and pushes the new NSH header in front of the original NSH
          header.</t>

          <t>As shown in <xref target="fig_NSH_in_NSH"></xref>, the Lower-NSH
          header used to forward packets in the lower-level domain precedes
          the Upper-NSH header from the top-level domain.</t>

          <figure anchor="fig_NSH_in_NSH"
                  title="Encapsulation of NSH within NSH">
            <artwork align="center"><![CDATA[
+---------------------------------+
|  Outer-Transport Encapsulation  |
+---------------------------------+
|        Lower-NSH Header         |
+---------------------------------+
|        Upper-NSH Header         |
+---------------------------------+
|          Original Packet        |
+---------------------------------+
            ]]></artwork>
          </figure>

          <t>The traffic with this stack of two NSH headers is to be
          forwarded according to the Lower-NSH header in the lower-level SFC
          domain. The Upper-NSH header is preserved in the packets but not
          used for forwarding. At the last SFF of the chain of the lower-level
          domain (which resides in the IBN), the Lower-NSH header is removed
          from the packet, and then the packet is forwarded by the IBN to an
          SFF of the upper-level domain. The packet will be forwarded in the
          top-level domain according to the Upper-NSH header.</t>

          <t>With such encapsulation, Upper-NSH information is carried along
          the extent of the lower-level chain without modification.</t>

          <t>A benefit of this approach is that it does not require state in
          the IBN or configuration to encode fields in metadata. All header
          fields, including flags and TTL, are easily restored when the chains
          of the subdomain terminate.</t>

          <t>However, the downside is that it does require SFC-aware SFs in the
          lower-level domain to be able to parse multiple NSH layers. If an
          SFC-aware SF injects packets, it must also be able to deal with
          adding appropriate multiple layers of headers to injected
          packets.</t>

          <t>By increasing packet overhead, nesting may lead to fragmentation
          or decreased MTU in some networks.</t>
        </section>

        <section anchor="hybrid" title="Stateful/Metadata Hybrid">
          <t>The basic idea of this approach is for the IBN to save upper
          domain encapsulation information such that it can be retrieved by a
          unique identifier, termed an "hSFC Flow ID".</t>

          <t>The hSFC Flow ID is placed, for example, in the NSH Fixed-Length
          Context Header field of the packet in the lower-level domain, as shown in <xref
          target="fig_hybrid"></xref>. Likewise, hSFC Flow ID may be encoded
          as a Variable-Length Context Header field when MD Type 0x2 is used.</t>

          <t>When packets exit the lower-level domain, the IBN uses the hSFC Flow ID
          to retrieve the appropriate NSH encapsulation for returning the
          packet to the upper domain. The hSFC Flow ID Context Header is then
          stripped by the IBN.</t>

          <figure anchor="fig_hybrid"
                  title="Storing hSFC Flow ID in Lower-Level NSH Fixed-Length Context Header Field ([RFC8300], Section 2.4)">
            <artwork align="center"><![CDATA[
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Service Path Identifier              | Service Index |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      hSFC Flow ID                             |
|              Zero Padding or other fields                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]></artwork>
          </figure>

          <t>Advantages of this approach include: <list style="symbols">
              <t>It does not require state to be based on a 5-tuple, so it works with SFs
              that change the IP addresses or port numbers of a packet, such as
              NATs.</t>

              <t>It does not require all domains to have the same metadata
              scheme.</t>

              <t>It can be used to restore any upper-domain information,
              including metadata, flags, and TTL, not just the service path.</t>

              <t>The lower-level domain only requires a single item of metadata
              regardless of the number of items of metadata used in the upper
              domain.</t>

              <t>The SFC-related functionality required by this approach in an
              SFC-aware SF is able to preserve and apply metadata, which
              is a requirement that was already present in <xref
              target="RFC8300"></xref>. </t>
            </list></t>

          <t>Disadvantages include those of other stateful approaches,
          including state timeout and synchronization, mentioned in <xref
          target="section_flow_stateful"></xref>.</t>

          <t>There may be a large number of unique NSH encapsulations to be
          stored, given that the hSFC Flow ID must represent all of the bits
          in the upper-level encapsulation. This might consume a lot of memory
          or create out-of-memory situations in which hSFC Flow IDs cannot be
          created or old hSFC Flow IDs are discarded while still in use.</t>
        </section>
      </section>

      <section title="Gluing Levels Together">
        <t>The SPI or metadata included in a packet received by the IBN may be
        used as input to reclassification and path selection within a
        lower-level domain.</t>

        <t>In some cases, the meanings of the various path IDs and metadata
        must be coordinated between domains for the sake of proper end-to-end
        SFC operation.</t>

        <t>One approach is to use well-known identifier values in metadata,
        maintained in a global registry.</t>

        <t>Another approach is to use well-known labels for chain identifiers
        or metadata, as an indirection to the actual identifiers. The actual
        identifiers can be assigned by control-plane systems. For example, a
        subdomain classifier could have a policy, "if pathID = classA then
        chain packet to path 1234"; the upper-level controller would be
        expected to configure the concrete upper-level "pathID" for
        "classA".</t>
      </section>

      <section anchor="section_deSI" title="Decrementing Service Index">
        <t>Because the IBN acts as an SFC-aware SF to the upper-level domain,
        it must decrement the Service Index in the NSH headers of the
        upper-level path. This operation should be undertaken when the packet
        is first received by the IBN, before applying any of the strategies of
        <xref target="section_strategies"></xref>, immediately prior to
        classification.</t>
      </section>

      <section anchor="section_ttl" title="Managing TTL">
        <t>The NSH base header contains a TTL field <xref
        target="RFC8300"></xref>. There is a choice: <list>
            <t>a subdomain may appear as a pure service function, which
            should not decrement the TTL from the perspective of the
            upper-level domain, or</t>

            <t>all of the TTL changes within the subdomain may be visible to
            the upper-level domain.</t>
          </list></t>

        <t>Some readers may recognize this as a choice between "pipe" and
        "uniform" models, respectively <xref target="RFC3443"></xref>.</t>

        <t>The network operator should be given control of this behavior,
        choosing whether to expose the lower-level topology to the upper
        layer. An implementation may support per-packet policy, allowing some
        users to perform a layer-transcending trace route, for example.</t>

        <t>The choice affects whether the methods of restoring the paths in
        <xref target="section_strategies"></xref> restore a saved version of
        the TTL or propagate it with the packet. The method of <xref
        target="section_unique_paths"></xref> does not permit topology hiding.
        The other methods of Sections <xref target="section_flow_stateful" format="counter"></xref>,
        <xref target="enco_meta" format="counter"></xref>, <xref target="nest" format="counter"></xref>, and
        <xref target="hybrid" format="counter"></xref> have unique methods for restoring saved
        versions of the TTL.</t>
      </section>
    </section>

    <section anchor="section_classifier" title="Subdomain Classifier">
      <t>Within the subdomain (referring to <xref
      target="fig_hierarchical_lower"></xref>), as the classifier receives
      incoming packets, the upper-level encapsulation is treated according to
      one of the methods described in <xref
      target="section_strategies"></xref> to either statefully store, encode,
      or nest header information. The classifier then selects the path and
      metadata for the packet within the subdomain.</t>

      <t>One of the goals of the hierarchical approach is to make it easy to
      have transport-flow-aware service chaining with bidirectional paths. For
      example, it is desired that for each TCP flow, the client-to-server
      packets traverse the same SF instances as the server-to-client packets,
      but in the opposite sequence. We call this "bidirectional symmetry". If
      bidirectional symmetry is required, it is the responsibility of the
      control plane to be aware of symmetric paths and configure the
      classifier to chain the traffic in a symmetric manner.</t>

      <t>Another goal of the hierarchical approach is to simplify the
      mechanisms of scaling SFs in and out. All of the complexities of
      load-balancing among multiple SFs can be handled within a subdomain,
      under control of the classifier, allowing the upper-level domain to be
      oblivious to the existence of multiple SF instances.</t>

      <t>Considering the requirements of bidirectional symmetry and
      load-balancing, it is useful to have all packets entering a subdomain be received by the same classifier or a coordinated cluster of
      classifiers. There are both stateful and stateless approaches to
      ensuring bidirectional symmetry.</t>
    </section>

    <section title="Control Plane Elements">
      <t>Although SFC control protocols have not yet been standardized (as of 2018),
      from the point of view of hierarchical service function chaining, we have
      these expectations: <list style="symbols">
          <t>Each control-plane instance manages a single level of the hierarchy
          of a single domain.</t>

          <t>Each control plane is agnostic about other levels of the hierarchy.
          This aspect allows humans to reason about the system within a single
          domain and control-plane algorithms to use only domain-local
          inputs. Top-level control does not need visibility to subdomain
          policies, nor does subdomain control need visibility to
          upper-level policies. (Top-level control considers a subdomain as
          though it were an SF.)</t>

          <t>Subdomain control planes are agnostic about the control planes of
          other subdomains. This allows both humans and machines to
          manipulate subdomain policy without considering policies of other
          domains.</t>
        </list></t>

      <t>Recall that the IBN acts as an SFC-aware SF in the upper-level
      domain (receiving SF instructions from the upper-level control plane)
      and as a classifier in the lower-level domain (receiving classification
      rules from the subdomain control plane). In this view, it is the IBN
      that glues the layers together.</t>

      <t>These expectations are not intended to prohibit network-wide
      control. A control hierarchy can be envisaged to distribute information
      and instructions to multiple domains and subdomains. Control hierarchy
      is outside the scope of this document.</t>
    </section>

    <section anchor="section_other_forwarding"
             title="Extension for Adapting to NSH-Unaware Service Functions">
      <t>The hierarchical approach can be used for dividing networks into
      NSH-aware and NSH-unaware domains by converting NSH encapsulation to
      other forwarding techniques (e.g., 5-tuple-based forwarding with
      OpenFlow), as shown in <xref
      target="fig_dividing_chain_domains"></xref>.</t>

      <figure anchor="fig_dividing_chain_domains"
              title="Dividing NSH-Aware and NSH-Unaware Domains">
        <artwork align="center"><![CDATA[
    * * * * * * * * * * * * * * * * * *
  *   NSH-aware domain                 *
  *       +-------+       +-------+    *
  *       | SF#1  |       | SF#5  |    *
  *       +-o---o-+       +-o---o-+    *
  *         ^   |           ^   |      *
  *       +-|---|-+       +-|---|-+    *
  *       | |SFF| |       | |SFF| |    *
  *       +-|---|-+       +-|---|-+    *
  *         .   |           |   .      *
  * +--+   /    |           |    \     *
 -->|CF|--'     |           |     '-------> 
  * +--+        v           |          *
  *         +---o-----------o---+      *
   .*.*.*.*.|  / |   IBN   | \  |*.*.*. 
  .         +-o--o---------o--o-+      .
  .           |  |         ^  ^        .
  .           |  +-+     +-+  |        .
  .       +---+    v     |    +---+    .
  .       |      +-o-----o-+      |    .
  .       |      |  SF#2   |      |    .
  .       |      +---------+      |    .
  .       +--+                 +--+    .
  .          |   +---------+   |       .
  .          v   |         v   |       .
  .        +-o---o-+     +-o---o-+     .
  .        | SF#3  |     | SF#4  |     .
  .        +-------+     +-------+     .
  .   NSH-unaware domain               .
   . . . . . . . . . . . . . . . . . . 

            ]]></artwork>

        <postamble>SF#1 and SF#5 are NSH aware; SF#2, SF#3, and SF#4 are
        NSH unaware. In the NSH-unaware domain, packets are conveyed in a
        format supported by SFs that are deployed there.</postamble>
      </figure>

      <section title="Purpose">
        <t>This approach is expected to facilitate service chaining in
        networks in which NSH-aware and NSH-unaware SFs coexist. Some examples
        of such situations are: <list style="symbols">
            <t>In a period of transition from legacy SFs to NSH-aware SFs</t>

            <t>Supporting multitenancy</t>
          </list></t>
      </section>

      <section anchor="ibnreq" title="Requirements for an IBN">
        <t>In this usage, an IBN classifier is required to have an NSH
        conversion table for applying packets to appropriate lower-level paths
        and returning packets to the correct upper-level paths. For example,
        the following methods would be used for saving/restoring upper-level
        path information: <list style="symbols">
            <t>Saving SPI and SI in transport-layer flow state (refer to <xref
            target="section_flow_stateful"></xref>)</t>

            <t>Using unique lower-level paths per upper-level NSH coordinates
            (refer to <xref target="section_unique_paths"></xref>)</t>
          </list></t>

        <t>Using the unique paths approach would be especially good for
        translating NSH to a different forwarding technique in the lower
        level. A single path in the upper level may be branched to multiple
        paths in the lower level such that any lower-level path is only used
        by one upper-level path. This allows unambiguous restoration to the
        upper-level path.</t>

        <t>In addition, an IBN might be required to convert metadata contained
        in the NSH to the format appropriate to the packet in the lower-level
        path. For example, some legacy SFs identify subscribers based on
        information about the network topology, such as the VLAN ID (VID), and
	the IBN would
        be required to create a VLAN to packets from metadata if the subscriber
        identifier is conveyed as metadata in upper-level domains.</t>

        <t>Other fundamental functions required for an IBN (e.g., maintaining
        metadata of upper level or decrementing Service Index) are the same as
        in normal usage.</t>

        <t>It is useful to permit metadata to be transferred between levels of
        a hierarchy. Metadata from an upper level may be useful within a
        subdomain, and a subdomain may augment metadata for consumption in an
        upper domain. However, allowing uncontrolled metadata between domains
        may lead to forwarding failures. <list>
            <t>In order to prevent SFs of lower-level SFC-enabled domains from
            supplying (illegitimate) metadata, IBNs may be instructed to only
            permit specific metadata types to exit the subdomain. Such
            control over the metadata in the upper level is the responsibility
            of the upper-level control plane.</t>

            <t>To limit unintentional metadata reaching SFs of lower-level
            SFC-enabled subdomains, IBNs may be instructed to only permit
            specific metadata types into the subdomain. Such control of
            metadata in the lower-level domain is the responsibility of the
            lower-level control plane.</t>
          </list></t>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This document has no IANA actions.</t>
    </section>

    <section anchor="Security" title="Security Considerations">

      <t>hSFC makes use of service chaining
      architecture; hence, it inherits the security considerations described
      in the architecture document <xref target="RFC7665"></xref>.</t>

      <t>Furthermore, hSFC inherits the security
      considerations of the data-plane protocols (e.g., NSH) and control-plane
      protocols used to realize the solution.</t>

      <t>This document describes systems that may be managed by distinct
      teams that all belong to the same administrative entity. Subdomains
      must have consistent configurations in order to properly forward
      traffic. Any protocol designed to distribute the configurations must be
      secure from tampering. The means of preventing attacks from within a network
      must be enforced. For example, continuously monitoring the network may
      allow detecting such misbehaviors. hSFC adheres to the same security
      considerations as <xref target="RFC8300"></xref>. Those considerations
      must be taken into account.</t>

      <t>The options in Sections <xref target="enco_meta" format="counter"></xref> and <xref
      target="hybrid" format="counter"></xref> assume the use of a dedicated context header to
      store information to bind a flow to its upper-level SFP. Such a context
      header is stripped by the IBN of a subdomain before exiting a
      subdomain. Additional guards to prevent leaking unwanted context
      information when entering/exiting a subdomain are discussed in <xref
      target="ibnreq"></xref>.</t>

      <t>All of the systems and protocols must be secure from modification by
      untrusted agents.</t>

      <section title="Control Plane">
        <t>Security considerations related to the control plane are discussed
        in the corresponding control specification documents (e.g., <xref
        target="BGP-CONTROL"></xref>, <xref
        target="PCEP-EXTENSIONS"></xref>, or <xref
        target="RADIUS"></xref>).</t>
      </section>

      <section title="Infinite Forwarding Loops">

        <t>Distributing policies among multiple domains may lead to forwarding
        loops. NSH supports the ability to detect loops (as described in Sections 4.3 and 4.4 of <xref target="RFC8300"/>),
        but the means of ensuring the consistency of the policies should be enabled
        at all levels of a domain. Within the context of hSFC, it is the
        responsibility of the Control Elements at all levels to prevent such
        (unwanted) loops.</t>
      </section>
    </section>


  </middle>


  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.7665'?>

      <?rfc include='reference.RFC.8300'?>
    </references>

    <references title="Informative References">


<!-- I-D.ietf-bess-nsh-bgp-control-plane exists  -->
<reference anchor='BGP-CONTROL'>
<front>
<title>BGP Control Plane for NSH SFC</title>

<author initials='A' surname='Farrel' fullname='Adrian Farrel'>
    <organization />
</author>

<author initials='J' surname='Drake' fullname='John Drake'>
    <organization />
</author>

<author initials='E' surname='Rosen' fullname='Eric Rosen'>
    <organization />
</author>

<author initials='J' surname='Uttaro' fullname='Jim Uttaro'>
    <organization />
</author>

<author initials='L' surname='Jalil' fullname='Luay Jalil'>
    <organization />
</author>

<date month='July' day='1' year='2018' />

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-bess-nsh-bgp-control-plane-04' />

</reference>


<!-- draft-ietf-sfc-dc-use-cases-06 is expired  -->
<reference anchor='USE-CASES'>
<front>
<title>Service Function Chaining Use Cases In Data Centers</title>

<author initials='S' surname='Kumar' fullname='Surendra Kumar'>
    <organization />
</author>

<author initials='M' surname='Tufail' fullname='Mudassir Tufail'>
    <organization />
</author>

<author initials='S' surname='Majee' fullname='Sumandra Majee'>
    <organization />
</author>

<author initials='C' surname='Captari' fullname='Claudiu Captari'>
    <organization />
</author>

<author initials='S' surname='Homma' fullname='Shunsuke Homma'>
    <organization />
</author>

<date month='February' day='22' year='2017' />

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-sfc-dc-use-cases-06' />

</reference>


<!-- draft-maglione-sfc-nsh-radius-01 is expired  -->
<reference anchor='RADIUS'>
<front>
<title>RADIUS Attributes for NSH</title>

<author initials='R' surname='Maglione' fullname='Roberta Maglione'>
    <organization />
</author>

<author initials='G' surname='Trueba' fullname='Guillermo Trueba'>
    <organization />
</author>

<author initials='C' surname='Pignataro' fullname='Carlos Pignataro'>
    <organization />
</author>

<date month='October' day='31' year='2016' />

</front>

<seriesInfo name='Work in Progress,' value='draft-maglione-sfc-nsh-radius-01' />

</reference>



<!-- draft-wu-pce-traffic-steering-sfc-12 is expired  -->
<reference anchor='PCEP-EXTENSIONS'>
<front>
<title>PCEP Extensions for Service Function Chaining (SFC)</title>

<author initials='Q' surname='Wu' fullname='Qin Wu'>
    <organization />
</author>

<author initials='D' surname='Dhody' fullname='Dhruv Dhody'>
    <organization />
</author>

<author initials='M' surname='Boucadair' fullname='Mohamed Boucadair'>
    <organization />
</author>

<author initials='C' surname='Jacquenet' fullname='Christian Jacquenet'>
    <organization />
</author>

<author initials='J' surname='Tantsura' fullname='Jeff Tantsura'>
    <organization />
</author>

<date month='June' day='30' year='2017' />


</front>

<seriesInfo name='Work in Progress,' value='draft-wu-pce-traffic-steering-sfc-12' />

</reference>


      <?rfc include='reference.RFC.3443'?>
    </references>


    <section anchor="app1"
             title="Examples of Hierarchical Service Function Chaining">
      <t>The advantage of hSFC compared with
      normal or flat service function chaining is that it can reduce the
      management complexity significantly. This section discusses examples
      that show those advantages.</t>

      <section title="Reducing the Number of Service Function Paths">
        <t>In this case, hSFC is used to
        simplify service function chaining management by reducing the number
        of SFPs.</t>

        <t>As shown in <xref target="fig_example_flat"></xref>, there are two
        domains, each with different concerns: a Security Domain that selects
        SFs based on network conditions and an Optimization Domain that
        selects SFs based on traffic protocol.</t>

        <t>In this example, there are five security functions deployed in the
        Security Domain. The Security Domain operator wants to enforce the
        five different security policies, and the Optimization Domain operator
        wants to apply different optimizations (either cache or video
        optimization) to each of these two types of traffic. If we use flat
        SFC (normal branching), 10 SFPs are needed in each domain. In
        contrast, if we use hSFC, only five SFPs in Security Domain
        and two SFPs in Optimization Domain will be required, as shown in <xref
        target="fig_example_hsfc"></xref>.</t>

        <t>In the flat model, the number of SFPs is the product of the number
        of SFs in all of the domains. In the hSFC model, the number of SFPs is
        the sum of the number of SFs. For example, adding a "bypass" path in
        the Optimization Domain would cause the flat model to require 15 paths
        (five more) but cause the hSFC model to require one more path in the
        Optimization Domain.</t>

        <figure anchor="fig_example_flat" title="Flat SFC (Normal Branching)">
          <artwork><![CDATA[
           . . . . . . . . . . . .   . . . . . . . . . . . . .
           . Security Domain     .   .  Optimization Domain  .
           .                     .   .                       .
           .    +-1---[     ]----------------->[Cache  ]------->
           .    |     [ WAF ]    .   .                       .
           .    +-2-->[     ]----------------->[Video Opt.]---->
           .    |                .   .                       .    
           .    +-3---[Anti ]----------------->[Cache  ]------->
           .    |     [Virus]    .   .                       .
           .    +-4-->[     ]----------------->[Video Opt.]---->
           .    |                .   .                       .
           .    +-5-->[     ]----------------->[Cache  ]------->
[DPI]--->[CF]---|     [ IPS ]    .   .                       .
           .    +-6-->[     ]----------------->[Video Opt.]---->
           .    |                .   .                       .
           .    +-7-->[     ]----------------->[Cache  ]------->
           .    |     [ IDS ]    .   .                       .
           .    +-8-->[     ]----------------->[Video Opt.]---->
           .    |                .   .                       .
           .    +-9-->[Traffic]--------------->[Cache  ]------->
           .    |     [Monitor]  .   .                       .
           .    +-10->[       ]--------------->[Video Opt.]---->
           . . . . . . . . . . . .   . . . . . . . . . . . . .


Legend: 
   IDS: Intrusion Detection System
   IPS: Intrusion Prevention System
   WAF: Web Application Firewall
   DPI: Deep Packet Inspection
]]></artwork>

          <postamble>The classifier must select paths that determine the
          combination of Security and Optimization concerns. 1:WAF+Cache,
          2:WAF+VideoOpt, 3:AntiVirus+Cache, 4:AntiVirus+VideoOpt, 5:
          IPS+Cache, 6:IPS+VideoOpt, 7:IDS+Cache, 8:IDS+VideoOpt,
          9:TrafficMonitor+Cache, 10:TrafficMonitor+VideoOpt</postamble>
        </figure>

        <figure anchor="fig_example_hsfc"
                title="Simplified Path Management with hSFC">
          <artwork><![CDATA[
     . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .
     .     Security Domain       .    .   Optimization Domain     .
     .                           .    .                           .
[CF]---->[  [CF]    IBN      ]---------->[  [CF]   IBN         ]---->
     .    |                  ^   .    .  |                     ^  .
     .    +----->[ WAF ]-----+   .    .  +-->[ Cache ]---------+  .
     .    |                  |   .    .  |                     |  .
     .    +-->[Anti-Virus]---+   .    .  +-->[Video Opt]-------+  .
     .    |                  |   .    .                           .
     .    +----->[ IPS ]-----+   .    . . . . . . . . . . . . . . .
     .    |                  |   .
     .    +----->[ IDS ]-----+   .
     .    |                  |   .
     .    +-->[ Traffic ]----+   .
     .        [ Monitor ]        .
     . . . . . . . . . . . . . . .
        ]]></artwork>
        </figure>
      </section>

      <section title="Managing a Distributed DC Network">
        <t>Hierarchical service function chaining can be used to simplify
        inter-DC SFC management. In the example of <xref
        target="fig_example_hsfc_inter_dc"></xref>, there is a
        central data center (Central DC) and multiple local data centers
        (Local DC#1, #2, #3) that are deployed in a geographically distributed
        manner. All of the data centers are under a single administrative
        domain.</t>

        <t>The central DC may have some service functions that the local DC
        needs, such that the local DC needs to chain traffic via the central
        DC. This could be because: <list style="symbols">
            <t>Some SFs are deployed as dedicated hardware appliances, and
            there is a desire to lower the cost (both CAPEX and OPEX) of
            deploying such SFs in all data centers.</t>

            <t>Some SFs are being trialed or introduced, or they otherwise handle a
            relatively small amount of traffic. It may be cheaper to manage
            these SFs in a single central data center and steer packets to the
            central data center than to manage these SFs in all data
            centers.</t>
          </list></t>

        <figure anchor="fig_example_hsfc_inter_dc"
                title="Simplify Inter-DC SFC Management">
          <artwork><![CDATA[
                +-----------+
                |Central DC |
                +-----------+
                   ^  ^   ^
                   |  |   |
               .---|--|---|----.    
              /   /   |   |      \
             /   /    |    \      \ 
  +-----+   /   /     |     \      \    +-----+
  |Local|  |   /      |      \     |    |Local|
  |DC#1 |--|--.       |       .----|----|DC#3 |
  +-----+  |          |            |    +-----+
            \         |            /
             \        |           /  
              \       |          /   
               '----------------'    
                      |      
                   +-----+
                   |Local|
                   |DC#2 |
                   +-----+                          
                    
          ]]></artwork>
        </figure>

        <t>For large DC operators, one local DC may have tens of
        thousands of servers and hundreds of thousands of virtual machines.
        SFC can be used to manage user traffic. For example, SFC can be used
        to classify user traffic based on service type, DDoS state, etc.</t>

        <t>In such a large-scale DC, using flat SFC is very complex,
        requiring a super controller to configure all DCs. For
        example, any changes to SFs or SFPs in the central DC (e.g., deploying
        a new SF) would require updates to all of the SFPs in the local DCs
        accordingly. Furthermore, requirements for symmetric paths add
        additional complexity when flat SFC is used in this scenario.</t>

        <t>Conversely, if using hierarchical SFC, each DC can be
        managed independently to significantly reduce management complexity.
        SFPs between DCs can represent abstract notions without
        regard to details within DCs. Independent controllers can be
        used for the top level (getting packets to pass the correct DCs)
        and local levels (getting packets to specific SF
        instances).</t>
      </section>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements" numbered="no">
      <t>The concept of Hierarchical Service Path Domains was introduced in
      "Analysis on Forwarding Methods for Service Chaining" (August 2016) as a
      means of improving scalability of service chaining in large networks.</t>

      <t>The concept of nesting NSH headers within lower-level NSH was
      contributed by Ting Ao. The concept originally appeared in "Hierarchical
      SFC for DC Interconnection" (April 2016) as a means of creating
      hierarchical SFC in a data center.</t>

      <t>We thank Dapeng Liu for contributing the DC examples in the
      Appendix.</t>

      <t>The Stateful/Metadata Hybrid section was contributed by Victor
      Wu.</t>

      <t>The authors would also like to thank the following individuals for
      providing valuable feedback:</t>
<?rfc subcompact="yes"?>
      <t><list style="hanging">
          <t>Ron Parker</t>

          <t>Christian Jacquenet</t>

          <t>Jie Cao</t>

          <t>Kyle Larose</t>
      </list></t>
<?rfc subcompact="no"?>

      <t>Thanks to Ines Robles, Sean Turner, Vijay Gurbani, Ben Campbell, and
      Benjamin Kaduk for their review.</t>
    </section>

  </back>
</rfc>
