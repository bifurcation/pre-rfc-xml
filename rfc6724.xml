<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc1794 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1794.xml'>
    <!ENTITY rfc1812 PUBLIC ''                                                         'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1812.xml'>
    <!ENTITY rfc1918 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1918.xml'>
    <!ENTITY rfc2119 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
    <!ENTITY rfc2827 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2827.xml'>
    <!ENTITY rfc3056 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3056.xml'>
    <!ENTITY rfc3484 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3484.xml'>
    <!ENTITY rfc3493 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3493.xml'>
    <!ENTITY rfc3701 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3701.xml'>
    <!ENTITY rfc3879 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3879.xml'>
    <!ENTITY rfc3927 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3927.xml'>
    <!ENTITY rfc4007 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4007.xml'>
    <!ENTITY rfc4191 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4191.xml'>
    <!ENTITY rfc4193 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4193.xml'>
    <!ENTITY rfc4213 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4213.xml'>
    <!ENTITY rfc4291 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4291.xml'>
    <!ENTITY rfc4380 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4380.xml'>
    <!ENTITY rfc4861 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4861.xml'>
    <!ENTITY rfc4862 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4862.xml'>
    <!ENTITY rfc4941 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4941.xml'>
    <!ENTITY rfc5014 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5014.xml'>
    <!ENTITY rfc5214 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5214.xml'>
    <!ENTITY rfc5220 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5220.xml'>
    <!ENTITY rfc5969 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5969.xml'>
    <!ENTITY rfc6145 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6145.xml'>
    <!ENTITY rfc6275 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6275.xml'>
    <!ENTITY rfc6598 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6598.xml'>
    <!ENTITY ADDRSELOPT PUBLIC 'ADDRSELOPT'
      'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-6man-addr-select-opt.xml'>
]> 
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?> 
<?rfc autobreaks="yes" ?>
<?rfc toc="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc symrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes" ?>
<?rfc subcompact="no"?>
<?rfc rfcedstyle="yes"?>

<rfc number="6724" category="std" ipr="trust200902" obsoletes="3484"
submissionType="IETF" consensus="yes">


<front>
    <title abbrev='Default Address Selection for IPv6'>
    Default Address Selection for Internet Protocol Version 6 (IPv6)
    </title>
    <author initials='D.' surname="Thaler" fullname='Dave Thaler' role="editor">
        <organization>Microsoft</organization>
        <address>
            <postal>
                <street>One Microsoft Way</street>
                <city>Redmond</city>
                <region>WA</region>
                <code>98052</code>
<country>USA</country>
            </postal>
            <phone>+1 425 703 8835</phone>
            <email>dthaler@microsoft.com</email>
        </address>
    </author>
    <author initials='R.' surname="Draves" fullname='Richard Draves'>
        <organization>Microsoft Research</organization>
        <address>
            <postal>
                <street>One Microsoft Way</street>
                <city>Redmond</city>
                <region>WA</region>
                <code>98052</code>
<country>USA</country>
            </postal>
            <phone>+1 425 706 2268</phone>
            <email>richdr@microsoft.com</email>
        </address>
    </author>
    <author initials='A.' surname="Matsumoto" fullname='Arifumi Matsumoto'>
        <organization abbrev='NTT'>NTT SI Lab</organization>
        <address>
            <postal>
                <street>Midori-Cho 3-9-11</street>
                <city>Musashino-shi</city>
                <region>Tokyo</region>
                <code>180-8585</code>
                <country>Japan</country>
            </postal>
            <phone>+81 422 59 3334</phone>
            <email>arifumi@nttv6.net</email>
        </address>
    </author>
    <author initials='T.' surname="Chown" fullname='Tim Chown'>
        <organization abbrev='University of Southampton'>University of Southampt
on</organization>
        <address>
            <postal>
                <street>Southampton, Hampshire  SO17 1BJ</street>
                <country>United Kingdom</country>
            </postal>
            <email>tjc@ecs.soton.ac.uk</email>
        </address>
    </author>

    <date month="September" year="2012"/>



    <abstract>
    <t> This document describes two algorithms, one for source address 
        selection and one for destination address selection.  The algorithms 
        specify
        default behavior for all Internet Protocol version 6 (IPv6)
        implementations.  They do not override choices made by applications
        or upper-layer protocols, nor do they preclude the development of
        more advanced mechanisms for address selection.  The two algorithms
        share a common context, including an optional mechanism for allowing
        administrators to provide policy that can override the default
        behavior.  In dual-stack implementations, the destination address
        selection algorithm can consider both IPv4 and IPv6 addresses --
        depending on the available source addresses, the algorithm might
        prefer IPv6 addresses over IPv4 addresses, or vice versa.
    </t>
    <t>
        Default address selection as defined in this specification applies
        to all IPv6 nodes, including both hosts and routers.
        This document obsoletes RFC 3484.
    </t>
    </abstract>
</front>

<middle>
<section title="Introduction">
    <t> The IPv6 addressing architecture <xref target="RFC4291"/> allows 
        multiple unicast
        addresses to be assigned to interfaces.  These addresses might have
        different reachability scopes (link-local, site-local, or global).
        These addresses might also be "preferred" or "deprecated" 
        <xref target="RFC4862"/>.  Privacy
        considerations have introduced the concepts of "public addresses" and
        "temporary addresses" <xref target="RFC4941"/>.  The mobility 
        architecture introduces "home addresses" and "care-of addresses" 
        <xref target="RFC6275"/>.  In addition, multi-homing situations 
        will result in more addresses per node.  For
        example, a node might have multiple interfaces, some of them tunnels or
        virtual interfaces, or a site might have multiple ISP attachments with
        a global prefix per ISP.
    </t>
    <t> The end result is that IPv6 implementations will very often be faced
        with multiple possible source and destination addresses when
        initiating communication.  It is desirable to have default
        algorithms, common across all implementations, for selecting source
        and destination addresses so that developers and administrators can
        reason about and predict the behavior of their systems.
    </t>
    <t> Furthermore, dual- or hybrid-stack implementations, which support both
        IPv6 and IPv4, will very often need to choose between IPv6 and IPv4
        when initiating communication, for example, when DNS name resolution
        yields both IPv6 and IPv4 addresses and the network protocol stack
        has available both IPv6 and IPv4 source addresses.  In such cases, a
        simple policy to always prefer IPv6 or always prefer IPv4 can produce
        poor behavior.  As one example, suppose a DNS name resolves to a
        global IPv6 address and a global IPv4 address.  If the node has
        assigned a global IPv6 address and a 169.254/16 auto-configured IPv4
        address <xref target="RFC3927"/>, then IPv6 is the best choice for 
        communication.  But if
        the node has assigned only a link-local IPv6 address and a global
        IPv4 address, then IPv4 is the best choice for communication.  The
        destination address selection algorithm solves this with a unified
        procedure for choosing among both IPv6 and IPv4 addresses.
    </t>
    <t> The algorithms in this document are specified as a set of rules that
        define a partial ordering on the set of addresses that are available
        for use.  In the case of source address selection, a node typically
        has multiple addresses assigned to its interfaces, and the source
        address ordering rules in <xref target="srcaddrsel"/> define which
address is the
        "best" one to use.  In the case of destination address selection, the
        DNS might return a set of addresses for a given name, and an
        application needs to decide which one to use first and in what order
        to try others if the first one is not reachable.  The destination
        address ordering rules in <xref target="desaddrsel"/>, when applied to
the set of
        addresses returned by the DNS, provide such a recommended ordering.
    </t>
    <t> This document specifies source address selection and destination
        address selection separately but uses a common context so that
        together the two algorithms yield useful results.  The algorithms
        attempt to choose source and destination addresses of appropriate
        scope and configuration status ("preferred" or "deprecated" in the RFC
        4862 sense).  Furthermore, this document suggests a preferred method,
        longest matching prefix, for choosing among otherwise equivalent
        addresses in the absence of better information.
    </t>
    <t> This document also specifies policy hooks to allow administrative
        override of the default behavior.  For example, using these hooks, an
        administrator can specify a preferred source prefix for use with a
        destination prefix or prefer destination addresses with one prefix
        over addresses with another prefix.  These hooks give an
        administrator flexibility in dealing with some multi-homing and
        transition scenarios, but they are certainly not a panacea.
    </t>
    <t> The selection rules specified in this document MUST NOT be construed
        to override an application or upper layer's explicit choice of a
        legal destination or source address.
    </t>

    <section title="Conventions Used in This Document">
        <t> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
            "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
            document are to be interpreted as described in 
            <xref target="RFC2119">BCP 14, RFC 2119</xref>.
        </t>
    </section>
</section>

<section title="Context in Which the Algorithms Operate">
    <t> Our context for address selection derives from the most common
        implementation architecture, which separates the choice of
        destination address from the choice of source address.  Consequently,
        we have two separate algorithms for these tasks.  The algorithms are
        designed to work well together, and they share a mechanism for
        administrative policy override.
    </t>
    <t> In this implementation architecture, applications use 
        APIs such as <xref target="RFC3493">getaddrinfo()</xref> that 
        return a list of addresses to the application.
        This list might contain both IPv6 and IPv4 addresses (sometimes
        represented as IPv4-mapped addresses).  The application then passes a
        destination address to the network stack with connect() or sendto().
        The application would then typically try the first address in the
        list, looping over the list of addresses until it finds a working
        address.  In any case, the network layer is never in a situation
        where it needs to choose a destination address from several
        alternatives.  The application might also specify a source address
        with bind(), but often the source address is left unspecified.
        Therefore, the network layer does often choose a source address from
        several alternatives.
    </t>
    <t> As a consequence, we intend that implementations of APIs such as 
        getaddrinfo()
        will use the destination address selection algorithm specified here
        to sort the list of IPv6 and IPv4 addresses that they return.
        Separately, the IPv6 network layer will use the source address
        selection algorithm when an application or upper layer has not
        specified a source address.  Application of this specification to
        source address selection in an IPv4 network layer might be possible, but
        this is not explored further here.
    </t>
    <t> Well-behaved applications SHOULD NOT simply use the first address
        returned from an API such as getaddrinfo() and then give up if it 
        fails.  For
        many applications, it is appropriate to iterate through the list of
        addresses returned from getaddrinfo() until a working address is
        found.  For other applications, it might be appropriate to try 
        multiple addresses in parallel (e.g., with some small delay in between)
        and use the first one to succeed.

    </t>
    <t> Although source and destination address selection is most typically
        done when initiating communication, a responder also must deal
        with address selection.  In many cases, this is trivially dealt
        with by an application using the source address of a received
        packet as the response destination and the destination address
        of the received packet as the response source.  Other cases, however,
        are handled like an initiator, such as when the request
        is multicast and hence source address selection must still occur
        when generating a response or when the request includes a list
        of the initiator's addresses from which to choose a destination.
        Finally, a third application scenario is that of a listening
        application choosing on what local addresses to listen.  This
        third scenario is out of the scope of this document.
    </t>
    <t> The algorithms use several criteria in making their decisions.  The
        combined effect is to prefer destination/source address pairs for
        which the two addresses are of equal scope or type, prefer smaller
        scopes over larger scopes for the destination address, prefer non-
        deprecated source addresses, avoid the use of transitional addresses
        when native addresses are available, and all else being equal, prefer
        address pairs having the longest possible common prefix.  For source
        address selection, temporary addresses <xref target="RFC4941"/> are 
        preferred over public
        addresses.  In mobile situations <xref target="RFC6275"/>, 
        home addresses are preferred
        over care-of addresses.  If an address is simultaneously a home
        address and a care-of address (indicating the mobile node is "at
        home" for that address), then the home/care-of address is preferred
        over addresses that are solely a home address or solely a care-of
        address.
    </t>
    <t> This specification optionally allows for the possibility of
        administrative configuration of policy (e.g., via manual configuration
        or a DHCP option such as that proposed in 
        <xref target="ADDR-SEL-OPT"/>) that can override 
        the default
        behavior of the algorithms.  The policy override consists of the
        following set of state, which SHOULD be configurable:

    </t>
    <t> <list style="symbols">
        <t> Policy Table (<xref target="policytable"/>): a table that
            specifies precedence values and preferred source prefixes for
            destination prefixes.
        </t>
        <t> Automatic Row Additions flag (<xref target="policytable"/>): 
            a flag that specifies whether the implementation is permitted to
            automatically add site-specific rows for certain types of addresses.
        </t>
        <t> Privacy Preference flag (<xref target="srcaddrsel"/>): a flag that
            specifies whether temporary source addresses or stable source
            addresses are preferred by default when both types exist.
        </t>
        </list>
    </t>

    <section title="Policy Table" anchor="policytable">
        <t> The policy table is a longest-matching-prefix lookup table, much
            like a routing table.  Given an address A, a lookup in the policy
            table produces two values:  a precedence value denoted Precedence(A) and
            a classification or label denoted Label(A).
        </t>
        <t> The precedence value Precedence(A) is used for sorting destination
            addresses.  If Precedence(A) &gt; Precedence(B), we say that address A
            has higher precedence than address B, meaning that our algorithm
            will prefer to sort destination address A before destination
            address B.
        </t>
        <t> The label value Label(A) allows for policies that prefer a
            particular source address prefix for use with a destination
            address prefix.  The algorithms prefer to use a source address
            S with a destination address D if Label(S) = Label(D).
        </t>
        <t> IPv6 implementations SHOULD support configurable address selection
            via a mechanism at least as powerful as the policy tables defined
            here.  
            It is
            important that implementations provide a way to change the default
            policies as more experience is gained.  Sections <xref
target="pref6or4" format="counter" /> through <xref target="example6to4"
format="counter" />
            provide examples of the kind of changes that might be needed.
        </t>
        <t> If an implementation is not configurable or has not been
            configured, then it SHOULD operate according to the algorithms
            specified here in conjunction with the following default policy
            table:
        </t>
        <figure>
            <artwork>
   Prefix        Precedence Label
   ::1/128               50     0
   ::/0                  40     1
   ::ffff:0:0/96         35     4
   2002::/16             30     2
   2001::/32              5     5
   fc00::/7               3    13
   ::/96                  1     3
   fec0::/10              1    11
   3ffe::/16              1    12
            </artwork>
        </figure>
        <t> An implementation MAY automatically add additional site-specific
            rows to the default table based on its configured addresses, such
            as for <xref target="RFC4193">Unique Local Addresses (ULAs)</xref>
            and <xref target="RFC3056">6to4</xref> addresses, for 
            instance (see Sections 
            <xref target="ulaexample" format="counter"/> and <xref
target="example6to4" format="counter"/>
            for examples).  Any such rows automatically added by the 
            implementation as a result of address acquisition MUST NOT
            override a row for the same prefix configured via other 
            means.  That is, rows can be added but never updated 
            automatically.  An implementation SHOULD provide a means 
            (the Automatic Row Additions flag)
            for an administrator to disable automatic row additions. 
        </t>
        <t> As will become apparent later, one effect of the default 
            policy table is to prefer using native
            source addresses with native destination addresses, 6to4 
            source addresses with 6to4 destination addresses, 
            etc.
            Another effect of the default policy table is to prefer communication using
            IPv6 addresses to communication using IPv4 addresses, if matching
            source addresses are available.
        </t>
        <t> Policy table entries for address prefixes that are not of
            global scope MAY be qualified
            with an optional zone index.  If so, a prefix table entry only
            matches against an address during a lookup if the zone index also
            matches the address's zone index.
        </t>
    </section>
    <section title="Common Prefix Length">   
        <t> We define the common prefix length CommonPrefixLen(S, D) of a
            source address S and a destination address D as the length
            of the longest prefix (looking at the most significant, or 
            leftmost, bits) that the two addresses have in common, up
            to the length of S's prefix (i.e., the portion of the address
            not including the interface ID).  For example, 
            CommonPrefixLen(fe80::1, fe80::2) is 64.
        </t>
    </section>
</section>

<section title="Address Properties">   
    <t> In the rules given in later sections, addresses of different types
        (e.g., IPv4, IPv6, multicast, and unicast) are compared against each
        other.  Some of these address types have properties that aren't
        directly comparable to each other.  For example, IPv6 unicast
        addresses can be "preferred" or "deprecated" <xref target="RFC4862"/>,
        while IPv4
        addresses have no such notion.  To compare such addresses using the
        ordering rules (e.g., to use "preferred" addresses in preference to
        "deprecated" addresses), the following mappings are defined.
    </t>

    <section title="Scope Comparisons"> 
        <t> Multicast destination addresses have a 4-bit scope field that
            controls the propagation of the multicast packet.  The IPv6
            addressing architecture defines scope field values for interface-
            local (0x1), link-local (0x2), admin-local
            (0x4), site-local (0x5), organization-local (0x8), and global (0xE)
            scopes (Section 2.7 of <xref target="RFC4291"/>).
        </t>
        <t> Use of the source address selection algorithm in the presence of
            multicast destination addresses requires the comparison of a
            unicast address scope with a multicast address scope.  We map
            unicast link-local to multicast link-local, unicast site-local 
            to multicast site-local, and unicast global scope to multicast 
            global scope.  For example, unicast site-local is equal to 
            multicast site-local, which is smaller than multicast 
            organization-local, which is smaller than unicast global, 
            which is equal to multicast global.
            (Note that IPv6 site-local unicast addresses are deprecated 
            <xref target="RFC4291"/>.  However, some existing implementations
            and deployments may still use these addresses;  
            they are therefore included in the procedures in this specification.
            Also, note that ULAs are considered as global, not site-local,
            scope but are handled via the prefix policy table as discussed in
            <xref target="ulaexample"/>.)
        </t>
        <t> We write Scope(A) to mean the scope of address A.&nbsp; For example,
            if A is a link-local unicast address and B is a site-local 
            multicast address, then Scope(A) &lt; Scope(B).
        </t>
        <t> This mapping implicitly conflates unicast site boundaries and
            multicast site boundaries <xref target="RFC4007"/>.
        </t>
    </section>

    <section title="IPv4 Addresses and IPv4-Mapped Addresses" anchor="v4scope">

        <t> The destination address selection algorithm operates on both IPv6
            and IPv4 addresses.  For this purpose, IPv4 addresses MUST be
            represented as IPv4-mapped addresses <xref target="RFC4291"/>.  For
            example, to look up
            the precedence or other attributes of an IPv4 address in the policy
            table, look up the corresponding IPv4-mapped IPv6 address.
        </t>



        <t> IPv4 addresses are assigned scopes as follows.  IPv4 
            auto-configuration addresses <xref target="RFC3927"/>, 
            which have the prefix 169.254/16,
            are assigned link-local scope.
            IPv4 loopback addresses (Section 4.2.2.11 of <xref
            target="RFC1812"/>), which have the prefix 127/8, are assigned 
            link-local scope (analogously to the treatment of the IPv6 
            loopback address (Section 4 of <xref target="RFC4007"/>)).  Other 
            IPv4 addresses (including IPv4 private addresses 
            <xref target="RFC1918"/> and Shared Address Space addresses
            <xref target="RFC6598"/>) are assigned global scope.
        </t>
        <t> IPv4 addresses MUST be treated as having "preferred" (in the
            RFC 4862 sense) configuration status.
        </t>
    </section>

    <section title="Other IPv6 Addresses with Embedded IPv4 Addresses">

        <t> IPv4-compatible addresses <xref target="RFC4291"/>, 
            IPv4-mapped <xref target="RFC4291"/>, 
            IPv4-converted <xref target="RFC6145"/>,
            IPv4-translatable <xref target="RFC6145"/>, and 
            6to4 addresses <xref target="RFC3056"/> contain an embedded
            IPv4 address.  For the purposes of this document, these addresses
            MUST be treated as having global scope.
        </t>
        <t> IPv4-compatible, IPv4-mapped, and IPv4-converted
            addresses
            MUST be treated as having "preferred" (in the RFC 4862 sense)
            configuration status.
        </t>
    </section>

    <section title="IPv6 Loopback Address and Other Format Prefixes">

        <t> The loopback address MUST be treated as having link-local scope
            (Section 4 of <xref target="RFC4007"/>) and "preferred" (in the 
            RFC 4862 sense) configuration status.
        </t>
        <t> NSAP addresses and other addresses with as-yet-undefined format
            prefixes MUST be treated as having global scope and "preferred"
            (in the RFC 4862) configuration status.  Later standards might 
            supersede this treatment.
        </t>
    </section>

    <section title="Mobility Addresses">
        <t> Some nodes might support mobility using the concepts of home
            address and care-of address (for example, see 
            <xref target="RFC6275"/>). Conceptually,
            a home address is an IP address assigned to a mobile node and
            used as the permanent address of the mobile node. A care-of
            address is an IP address associated with a mobile node while
            visiting a foreign link.  When a mobile node is on its home 
            link, it might have an address that is simultaneously a home 
            address and a care-of address.
        </t>
        <t> For the purposes of this document, it is sufficient to know
            whether one's own addresses are designated as home
            addresses or care-of addresses.  Whether an address 
            ought to be designated a home address or care-of address 
            is outside the scope of this document.
        </t>
    </section>
</section>

<section title="Candidate Source Addresses"> 
    <t> The source address selection algorithm uses the concept of a
        "candidate set" of potential source addresses for a given destination
        address.  The candidate set is the set of all addresses that could be
        used as a source address; the source address selection algorithm will
        pick an address out of that set.  We write CandidateSource(A) to
        denote the candidate set for the address A.
    </t>
    <t> It is RECOMMENDED that the candidate source addresses be the set of
        unicast addresses assigned to the interface that will be used to send
        to the destination (the "outgoing" interface).  On routers, the
        candidate set MAY include unicast addresses assigned to any interface
        that forwards packets, subject to the restrictions described below.
        Implementations that wish to support the use of global source 
        addresses assigned to a loopback interface MUST behave as if the 
        loopback interface originates and forwards the packet.
    </t>
    <t> <list>
        <t> Discussion:  The Neighbor Discovery Redirect mechanism 
            <xref target="RFC4861"/>
            requires that routers verify that the source address of a packet
            identifies a neighbor before generating a Redirect, so it is
            advantageous for hosts to choose source addresses assigned to the
            outgoing interface.  
        </t>
        </list>
    </t>
    <t> In some cases, the destination address might be qualified with a zone
        index or other information that will constrain the candidate set.
    </t>
    <t> For all multicast and link-local destination addresses, the set of
        candidate source addresses MUST only include addresses assigned to
        interfaces belonging to the same link as the outgoing interface.
    </t>
    <t> <list>
        <t> Discussion:  The restriction for multicast destination addresses
            is necessary because currently deployed multicast forwarding
            algorithms use Reverse Path Forwarding (RPF) checks.
        </t>
        </list>
    </t>
    <t> For site-local unicast destination addresses, the set of candidate 
        source
        addresses MUST only include addresses assigned to interfaces
        belonging to the same site as the outgoing interface.
    </t>
    <t> In any case, 
        multicast addresses and the unspecified address 
        MUST NOT be included in a candidate set.
    </t>
    <t> On IPv6-only nodes that support Stateless IP/ICMP Translation (SIIT)
        <xref target="RFC6145"/>, if
        the destination address is an IPv4-converted address, then the candidate
        set MUST contain only IPv4-translatable addresses.  
    </t>
    <t> If an application or upper layer specifies a source address,
        it may affect the choice of outgoing 
        interface.  
        Regardless, if the application or upper layer specifies a source 
        address that is 
        not in the candidate set for the destination, then the network layer 
        MUST treat this as an error.
        If the application or upper layer specifies a source 
        address that is in the candidate set for the destination, then the 
        network layer MUST respect that choice.
        If the application or
        upper layer does not specify a source address, then the network layer
        uses the source address selection algorithm specified in the next
        section.
    </t>
</section>

<section title="Source Address Selection" anchor="srcaddrsel">   
    <t> The source address selection algorithm produces as output a single
        source address for use with a given destination address.  This
        algorithm only applies to IPv6 destination addresses, not IPv4
        addresses.
    </t>
    <t> The algorithm is specified here in terms of a list of pair-wise
        comparison rules that (for a given destination address D) imposes a
        "greater than" ordering on the addresses in the candidate set
        CandidateSource(D).  The address at the front of the list after the
        algorithm completes is the one the algorithm selects.
    </t>
    <t> Note that conceptually, a sort of the candidate set is being
        performed, where a set of rules define the ordering among addresses.
        But because the output of the algorithm is a single source address,
        an implementation need not actually sort the set; it need only
        identify the "maximum" value that ends up at the front of the sorted
        list.
    </t>
    <t> The ordering of the addresses in the candidate set is defined by a
        list of eight pair-wise comparison rules, with each rule placing a
        "greater than", "less than", or "equal to" ordering on two source
        addresses with respect to each other (and that rule).  In the case
        that a given rule produces a tie, i.e., provides an "equal to" result
        for the two addresses, the remaining rules MUST be applied (in order) 
        to just those addresses that are tied to break the tie.  Note that if a
        rule produces a single clear "winner" (or set of "winners" in the
        case of ties), those addresses not in the winning set can be
        discarded from further consideration, with subsequent rules applied
        only to the remaining addresses.  If the eight rules fail to choose a
        single address, the tiebreaker is implementation-specific.
    </t>
    <t> When comparing two addresses SA and SB from the candidate set, we say
        "prefer SA" to mean that SA is "greater than" SB, and similarly, we
        say "prefer SB" to mean that SA is "less than" SB.  If neither is
        stated to be preferred, this means that SA is "equal to" SB, and
        the remaining rules apply as noted above.
    </t>
    <t> Rule 1:  Prefer same address.
        <vspace blankLines='0'/>
        If SA = D, then prefer SA.  Similarly, if SB = D, then prefer SB.
    </t>
    <t> Rule 2:  Prefer appropriate scope.
        <vspace blankLines='0'/>
        If Scope(SA) &lt; Scope(SB): If Scope(SA) &lt; Scope(D), then 
        prefer SB and otherwise prefer SA.  Similarly, if 
        Scope(SB) &lt; Scope(SA): If Scope(SB) &lt; Scope(D), then 
        prefer SA and otherwise prefer SB.
    </t>
    <t> <list>
        <t> Discussion: This rule must be given high
            priority because it can affect interoperability.
        </t>
        </list>
    </t>
    <t> Rule 3:  Avoid deprecated addresses.
        <vspace blankLines='0'/>
        If one of the two
        source addresses is "preferred" and one of them is "deprecated" (in
        the RFC 4862 sense), then prefer the one that is "preferred".
    </t>
    <t> Rule 4:  Prefer home addresses.
        <vspace blankLines='0'/>
        If SA is simultaneously a home address and care-of address and SB is
        not, then prefer SA.  Similarly, if SB is simultaneously a home
        address and care-of address and SA is not, then prefer SB.
        If SA is just a home address and SB is just a care-of address, then
        prefer SA.  Similarly, if SB is just a home address and SA is just a
        care-of address, then prefer SB.
    </t>
    <t> Implementations supporting home addresses MUST provide a mechanism 
        allowing an application to
        reverse the sense of this preference and prefer care-of addresses
        over home addresses (e.g., via appropriate API extensions such as
        <xref target="RFC5014"/>).  Use of
        the mechanism MUST only affect the selection rules for the invoking
        application.
    </t>
    <t> Rule 5:  Prefer outgoing interface.
        <vspace blankLines='0'/>
        If SA is assigned to the interface that will be used to send to D
        and SB is assigned to a different interface, then prefer SA.
        Similarly, if SB is assigned to the interface that will be used to
        send to D and SA is assigned to a different interface, then prefer
        SB.
    </t>
    <t> Rule 5.5: Prefer addresses in a prefix advertised by the next-hop.
        <vspace blankLines='0'/>
        If SA or SA's prefix is assigned by the selected next-hop
        that will be used to send to D and SB or SB's prefix is
        assigned by a different next-hop, then prefer SA.
        Similarly, if SB or SB's prefix is assigned by the next-hop
        that will be used to send to D and SA or SA's prefix is
        assigned by a different next-hop, then prefer SB.
    </t>
    <t> <list>
        <t> Discussion:  An IPv6 implementation is not required to remember
            which next-hops advertised which prefixes.  The conceptual
            models of IPv6 hosts in Section 5 of <xref target="RFC4861"/> and 
            Section 3 of <xref target="RFC4191"/> have no such requirement.
            Hence, Rule 5.5 is only applicable to implementations that track 
            this information.
        </t>
        </list>
    </t>
    <t> Rule 6:  Prefer matching label.
        <vspace blankLines='0'/>
        If Label(SA) = Label(D) and Label(SB) &lt;&gt; Label(D), then prefer SA.
        Similarly, if Label(SB) = Label(D) and Label(SA) &lt;&gt; Label(D), then
        prefer SB.
    </t>
    <t> Rule 7:  Prefer temporary addresses.
        <vspace blankLines='0'/>
        If SA is a temporary address and SB is a public address, then prefer
        SA.  Similarly, if SB is a temporary address and SA is a public
        address, then prefer SB.
    </t>
    <t> Implementations MUST provide a mechanism allowing an application to
        reverse the sense of this preference and prefer public addresses
        over temporary addresses (e.g., via appropriate API extensions such as
        <xref target="RFC5014"/>).  Use of
        the mechanism MUST only affect the selection rules for the invoking
        application.  This default is intended to address privacy concerns
        as discussed in <xref target="RFC4941"/> but introduces a risk of
        applications potentially failing due to the relatively short lifetime 
        of temporary addresses or due to the possibility of the reverse lookup 
        of a temporary address either failing or returning a randomized name.  
        Implementations for which
        application compatibility considerations outweigh these privacy
        concerns MAY reverse the sense of this rule and by default prefer
        public addresses over temporary addresses.
        There SHOULD be an administrative option (the Privacy Preference flag)
        to change this preference,
        if the implementation supports temporary addresses.  If there is 
        no such option, there MUST be an administrative option to disable 
        temporary addresses.
    </t>
    <t> Rule 8:  Use longest matching prefix.
        <vspace blankLines='0'/>
        If CommonPrefixLen(SA, D) &gt; CommonPrefixLen(SB, D), then prefer SA.
        Similarly, if CommonPrefixLen(SB, D) &gt; CommonPrefixLen(SA, D), then
        prefer SB.
    </t>
    <t> Rule 8 MAY be superseded if the implementation has other means of
        choosing among source addresses.  For example, if the implementation
        somehow knows which source address will result in the "best"
        communications performance.
    </t>
</section>

<section title="Destination Address Selection" anchor="desaddrsel">   
    <t> The destination address selection algorithm takes a list of
        destination addresses and sorts the addresses to produce a new list.
        It is specified here in terms of the pair-wise comparison of
        addresses DA and DB, where DA appears before DB in the original list.
    </t>
    <t> The algorithm sorts together both IPv6 and IPv4 addresses.  To find
        the attributes of an IPv4 address in the policy table, the IPv4
        address MUST be represented as an IPv4-mapped address.
    </t>
    <t> We write Source(D) to indicate the selected source address for a
        destination D.&nbsp; For IPv6 addresses, the previous section specifies
        the source address selection algorithm.  Source address selection for
        IPv4 addresses is not specified in this document.
    </t>
    <t> We say that Source(D) is undefined if there is no source address
        available for destination D.&nbsp; For IPv6 addresses, this is only the
        case if CandidateSource(D) is the empty set.
    </t>
    <t> The pair-wise comparison of destination addresses consists of ten
        rules, which MUST be applied in order.  If a rule determines a
        result, then the remaining rules are not relevant and MUST be
        ignored.  Subsequent rules act as tiebreakers for earlier rules.
        See the previous section for a lengthier description of how pair-wise
        comparison tiebreaker rules can be used to sort a list.
    </t>
    <t> Rule 1:  Avoid unusable destinations.
        <vspace blankLines='0'/>
        If DB is known to be unreachable or if Source(DB) is undefined, then
        prefer DA.  Similarly, if DA is known to be unreachable or if
        Source(DA) is undefined, then prefer DB.
    </t>
    <t> <list>
        <t> Discussion:  An implementation might know that a particular
            destination is unreachable in several ways.  For example, the
            destination might be reached through a network interface that is
            currently unplugged.  For example, the implementation might retain
            information from Neighbor Unreachability
            Detection <xref target="RFC4861"/> for some period of time.  In any
            case, the 
            determination of unreachability
            for the purposes of this rule is implementation-dependent.
        </t>
        </list>
    </t>
    <t> Rule 2:  Prefer matching scope.
        <vspace blankLines='0'/>
        If Scope(DA) = Scope(Source(DA)) and Scope(DB) &lt;&gt; 
        Scope(Source(DB)), then prefer DA.  Similarly, if Scope(DA) &lt;&gt; 
        Scope(Source(DA)) and Scope(DB) = Scope(Source(DB)), then prefer DB.
    </t>
    <t> Rule 3:  Avoid deprecated addresses.
        <vspace blankLines='0'/>
        If Source(DA) is deprecated and Source(DB) is not, then prefer DB.
        Similarly, if Source(DA) is not deprecated and Source(DB) is
        deprecated, then prefer DA.
    </t>
    <t> Rule 4:  Prefer home addresses.
        <vspace blankLines='0'/>
        If Source(DA) is simultaneously a home address and care-of address
        and Source(DB) is not, then prefer DA.  Similarly, if Source(DB) is
        simultaneously a home address and care-of address and Source(DA) is
        not, then prefer DB.
    </t>
    <t> If Source(DA) is just a home address and Source(DB) is just a care-of
        address, then prefer DA.  Similarly, if Source(DA) is just a care-of
        address and Source(DB) is just a home address, then prefer DB.
    </t>
    <t> Rule 5:  Prefer matching label.
        <vspace blankLines='0'/>
        If Label(Source(DA)) = Label(DA) and Label(Source(DB)) &lt;&gt; 
        Label(DB), then prefer DA.  Similarly, if Label(Source(DA)) &lt;&gt; 
        Label(DA) and Label(Source(DB)) = Label(DB), then prefer DB.
    </t>
    <t> Rule 6:  Prefer higher precedence.
        <vspace blankLines='0'/>
        If Precedence(DA) &gt; Precedence(DB), then prefer DA.  Similarly, if
        Precedence(DA) &lt; Precedence(DB), then prefer DB.
    </t>
    <t> Rule 7:  Prefer native transport.
        <vspace blankLines='0'/>
        If DA is reached via an encapsulating transition mechanism (e.g.,
        IPv6 in IPv4) and DB is not, then prefer DB.  Similarly, if DB
        is reached via encapsulation and DA is not, then prefer DA.
    </t>
    <t> <list>
        <t> Discussion:  The IPv6 Rapid Deployment on IPv4 Infrastructures
            (6rd) Protocol 
            <xref target="RFC5969"/>, the 
            Intra-Site Automatic Tunnel Addressing Protocol (ISATAP)
            <xref target="RFC5214"/>, 
            and configured tunnels <xref target="RFC4213"/> are 
            examples of encapsulating transition mechanisms for which
            the destination address does not have a specific prefix and hence
            can not be assigned a lower precedence in the policy table.  An
            implementation MAY generalize this rule by using a concept of
            interface preference and giving virtual interfaces (like the
            IPv6-in-IPv4 encapsulating interfaces) a lower preference than
            native interfaces (like ethernet interfaces).
        </t>
        </list>
    </t>
    <t> Rule 8:  Prefer smaller scope.
        <vspace blankLines='0'/>
        If Scope(DA) &lt; Scope(DB), then prefer DA.  Similarly, if 
        Scope(DA) &gt; Scope(DB), then prefer DB.
    </t>
    <t> Rule 9:  Use longest matching prefix.
        <vspace blankLines='0'/>
        When DA and DB belong to the same address family (both are IPv6 or
        both are IPv4): If 
        CommonPrefixLen(Source(DA), DA) &gt; CommonPrefixLen(Source(DB), DB),
        then prefer DA.  Similarly, if
        CommonPrefixLen(Source(DA), DA) &lt; CommonPrefixLen(Source(DB), DB),
        then prefer DB.
    </t>
    <t> Rule 10:  Otherwise, leave the order unchanged.
        <vspace blankLines='0'/>
        If DA preceded DB in the original list, prefer DA.  Otherwise, prefer
        DB.
    </t>
    <t> Rules 9 and 10 MAY be superseded if the implementation has other
        means of sorting destination addresses.  For example, if the
        implementation somehow knows which destination addresses will result
        in the "best" communications performance.
    </t>
</section>

<section title="Interactions with Routing">   
    <t> This specification of source address selection assumes that routing
        (more precisely, selecting an outgoing interface on a node with
        multiple interfaces) is done before source address selection.
        However, implementations MAY use source address considerations as a
        tiebreaker when choosing among otherwise equivalent routes.
    </t>
    <t> For example, suppose a node has interfaces on two different links,
        with both links having a working default router.  Both of the
        interfaces have preferred (in the RFC 4862 sense) global addresses.
        When sending to a global destination address, if there's no routing
        reason to prefer one interface over the other, then an implementation
        MAY preferentially choose the outgoing interface that will allow it
        to use the source address that shares a longer common prefix with the
        destination.
    </t>
    <t> Implementations that support Rule 5.5 of source address selection 
        (<xref target="srcaddrsel"/>) also use the choice of router 
        to influence the
        choice of source address.  For example, suppose a host is on a link
        with two routers.  One router is advertising a global prefix A and
        the other router is advertising global prefix B.&nbsp; Then, when sending
        via the first router, the host might prefer source addresses with
        prefix A and when sending via the second router, prefer source
        addresses with prefix B.
    </t>
</section>

<section title="Implementation Considerations">
    <t> The destination address selection algorithm needs information about
        potential source addresses.  One possible implementation strategy is
        for getaddrinfo() to call down to the network layer with a list of
        destination addresses, sort the list in the network layer with full
        current knowledge of available source addresses, and return the
        sorted list to getaddrinfo().  This is simple and gives the best
        results, but it introduces the overhead of another system call.  One
        way to reduce this overhead is to cache the sorted address list in
        the resolver, so that subsequent calls for the same name do not need
        to re-sort the list.
    </t>
    <t> Another implementation strategy is to call down to the network layer
        to retrieve source address information and then sort the list of
        addresses directly in the context of getaddrinfo().  To reduce
        overhead in this approach, the source address information can be
        cached, amortizing the overhead of retrieving it across multiple
        calls to getaddrinfo().  In this approach, the implementation might not
        have knowledge of the outgoing interface for each destination, so it
        MAY use a looser definition of the candidate set during destination
        address ordering.
    </t>
    <t> In any case, if the implementation uses cached and possibly stale
        information in its implementation of destination address selection
        or if the ordering of a cached list of destination addresses is
        possibly stale, then it MUST ensure that the destination address
        ordering returned to the application is no more than one second out
        of date.  For example, an implementation might make a system call to
        check if any routing table entries, source address assignments, or
        prefix policy table entries that
        might affect these algorithms have changed.  Another strategy is to
        use an invalidation counter that is incremented whenever any
        underlying state is changed.  By caching the current invalidation
        counter value with derived state and then later comparing against the
        current value, the implementation could detect if the derived state
        is potentially stale.
    </t>
</section>

<section title="Security Considerations">
    <t> This document has no direct impact on Internet infrastructure
        security.
    </t>
    <t> Note that most source address selection algorithms, including the one
        specified in this document, expose a potential privacy concern.  An
        unfriendly node can infer correlations among a target node's
        addresses by probing the target node with request packets that force
        the target host to choose its source address for the reply packets
        (perhaps because the request packets are sent to an anycast or
        multicast address or perhaps because the upper-layer protocol chosen for the
        attack does not specify a particular source address for its reply
        packets).  By using different addresses for itself, the unfriendly
        node can cause the target node to expose the target's own addresses.
        The source address selection default preference for temporary addresses
        helps mitigate this concern.
    </t>
    <t> Similarly, most source and destination address selection algorithms,
        including the one specified in this document, influence the choice 
        of network path taken (as do routing algorithms that are orthogonal
        to, but used together with, such algorithms) and hence whether data
        might be sent over a path or network that might be more or less 
        trusted than other paths or networks.  Administrators should consider
        the security impact of the rows they configure in the prefix policy
        table, just as they should consider the security impact of the 
        interface metrics used in the routing algorithms.
    </t>
    <t> In addition, some address selection rules might be administratively
        configurable.  Care must be taken to make sure that all administrative
        options are secured against illicit modification, or else an 
        attacker could redirect and/or block traffic.
    </t>
</section>

<section title="Examples">
    <t> This section contains a number of examples, first showing default behavior
        and then demonstrating the utility of policy table configuration.
        These examples are provided for illustrative purposes; they are not
        to be construed as normative.
    </t>

    <section title="Default Source Address Selection">
    <t> The source address selection rules, in conjunction with the default
        policy table, produce the following behavior:
    </t>
    <t> Destination: 2001:db8:1::1
        <vspace blankLines='0'/>
        Candidate Source Addresses: 2001:db8:3::1 or fe80::1
        <vspace blankLines='0'/>
        Result: 2001:db8::1 (prefer appropriate scope)
    </t>
    <t> Destination: ff05::1
        <vspace blankLines='0'/>
        Candidate Source Addresses: 2001:db8:3::1 or fe80::1
        <vspace blankLines='0'/>
        Result: 2001:db8:3::1 (prefer appropriate scope)
    </t>
    <t> Destination: 2001:db8:1::1
        <vspace blankLines='0'/>
        Candidate Source Addresses: 2001:db8:1::1 (deprecated) or 2001:db8:2::1
        <vspace blankLines='0'/>
        Result: 2001:db8:1::1 (prefer same address)
    </t>
    <t> Destination: fe80::1
        <vspace blankLines='0'/>
        Candidate Source Addresses: fe80::2 (deprecated) or 2001:db8:1::1
        <vspace blankLines='0'/>
        Result: fe80::2 (prefer appropriate scope)
    </t>
    <t> Destination: 2001:db8:1::1
        <vspace blankLines='0'/>
        Candidate Source Addresses: 2001:db8:1::2 or 2001:db8:3::2
        <vspace blankLines='0'/>
        Result: 2001:db8:1:::2 (longest matching prefix)
    </t>
    <t> Destination: 2001:db8:1::1
        <vspace blankLines='0'/>
        Candidate Source Addresses: 2001:db8:1::2 (care-of address) or 2001:db8:3::2
        (home address)
        <vspace blankLines='0'/>
        Result: 2001:db8:3::2 (prefer home address)
    </t>
    <t> Destination: 2002:c633:6401::1
        <vspace blankLines='0'/>
        Candidate Source Addresses: 2002:c633:6401::d5e3:7953:13eb:22e8
        (temporary) or 2001:db8:1::2
        <vspace blankLines='0'/>
        Result: 2002:c633:6401::d5e3:7953:13eb:22e8 (prefer matching label)
    </t>


    <t> Destination: 2001:db8:1::d5e3:0:0:1
        <vspace blankLines='0'/>
        Candidate Source Addresses: 2001:db8:1::2 (public) or 
        <vspace blankLines='0'/>
        2001:db8:1::d5e3:7953:13eb:22e8 (temporary)
        <vspace blankLines='0'/>
        Result: 2001:db8:1::d5e3:7953:13eb:22e8 (prefer temporary address)
    </t>
    </section>

    <section title="Default Destination Address Selection">
    <t> The destination address selection rules, in conjunction with the
        default policy table and the source address selection rules, produce
        the following behavior:
    </t>
    <t> Candidate Source Addresses: 2001:db8:1::2 or fe80::1 or 169.254.13.78
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8:1::1 or 198.51.100.121
        <vspace blankLines='0'/>
        Result: 2001:db8:1::1 (src 2001:db8:1::2) then 198.51.100.121 (src
        169.254.13.78) (prefer matching scope)
    </t>
    <t> Candidate Source Addresses: fe80::1 or 198.51.100.117
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8:1::1 or 198.51.100.121
        <vspace blankLines='0'/>
        Result: 198.51.100.121 (src 198.51.100.117) then 2001:db8:1::1 (src
        fe80::1) (prefer matching scope)
    </t>
    <t> Candidate Source Addresses: 2001:db8:1::2 or fe80::1 or 10.1.2.4
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8:1::1 or 10.1.2.3
        <vspace blankLines='0'/>
        Result: 2001:db8:1::1 (src 2001:db8:1::2) then 10.1.2.3 (src 10.1.2.4) (prefer
        higher precedence)
    </t>
    <t> Candidate Source Addresses: 2001:db8:1::2 or fe80::2
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8:1::1 or fe80::1
        <vspace blankLines='0'/>
        Result: fe80::1 (src fe80::2) then 
        2001:db8:1::1 (src 2001:db8:1::2) (prefer smaller scope)
    </t>
    <t> Candidate Source Addresses: 2001:db8:1::2 (care-of address) or 2001:db8:3::1
        (home address) or fe80::2 (care-of address)
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8:1::1 or fe80::1
        <vspace blankLines='0'/>
        Result: 2001:db8:1::1 (src 2001:db8:3::1) then fe80::1 (src fe80::2) (prefer home
        address)
    </t>
    <t> Candidate Source Addresses: 2001:db8:1::2 or fe80::2 (deprecated)
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8:1::1 or fe80::1
        <vspace blankLines='0'/>
        Result: 2001:db8:1::1 (src 2001:db8:1::2) then fe80::1 (src fe80::2) (avoid
        deprecated addresses)
    </t>
    <t> Candidate Source Addresses: 2001:db8:1::2 or 2001:db8:3f44::2 or fe80::2
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8:1::1 or 2001:db8:3ffe::1
        <vspace blankLines='0'/>
        Result: 2001:db8:1::1 (src 2001:db8:1::2) then 2001:db8:3ffe::1 (src 
        2001:db8:3f44::2) (longest matching prefix)
    </t>
    <t> Candidate Source Addresses: 2002:c633:6401::2 or fe80::2
        <vspace blankLines='0'/>
        Destination Address List: 2002:c633:6401::1 or 2001:db8:1::1
        <vspace blankLines='0'/>
        Result: 2002:c633:6401::1 (src 2002:c633:6401::2) then 2001:db8:1::1 (src
        2002:c633:6401::2) (prefer matching label)
    </t>
    <t> Candidate Source Addresses: 2002:c633:6401::2 or 2001:db8:1::2 or fe80::2
        <vspace blankLines='0'/>
        Destination Address List: 2002:c633:6401::1 or 2001:db8:1::1
        <vspace blankLines='0'/>
        Result: 2001:db8:1::1 (src 2001:db8:1::2) then 2002:c633:6401::1 (src
        2002:c633:6401::2) (prefer higher precedence)
    </t>
    </section>

    <section title="Configuring Preference for IPv6 or IPv4" anchor="pref6or4">
    <t> The default policy table gives IPv6 addresses higher precedence than
        IPv4 addresses.  This means that applications will use IPv6 in
        preference to IPv4 when the two are equally suitable.  An
        administrator can change the policy table to prefer IPv4 addresses by
        giving the ::ffff:0.0.0.0/96 prefix a higher precedence:
    </t>
    <figure>
        <artwork>
   Prefix        Precedence Label
   ::1/128               50     0
   ::/0                  40     1
   ::ffff:0:0/96        100     4
   2002::/16             30     2
   2001::/32              5     5
   fc00::/7               3    13
   ::/96                  1     3
   fec0::/10              1    11
   3ffe::/16              1    12
        </artwork>
    </figure>
    <t> This change to the default policy table produces the following
        behavior:
    </t>
    <t> Candidate Source Addresses: 2001:db8::2 or fe80::1 or 169.254.13.78
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8::1 or 198.51.100.121
        <vspace blankLines='0'/>
        Unchanged Result: 2001:db8::1 (src 2001:db8::2) then 198.51.100.121 (src
        169.254.13.78) (prefer matching scope)
    </t>
    <t> Candidate Source Addresses: fe80::1 or 198.51.100.117
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8::1 or 198.51.100.121
        <vspace blankLines='0'/>
        Unchanged Result: 198.51.100.121 (src 198.51.100.117) then 2001:db8::1
        (src fe80::1) (prefer matching scope)
    </t>
    <t> Candidate Source Addresses: 2001:db8::2 or fe80::1 or 10.1.2.4
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8::1 or 10.1.2.3
        <vspace blankLines='0'/>
        New Result: 10.1.2.3 (src 10.1.2.4) then 2001:db8::1 (src 2001:db8::2)
        (prefer higher precedence)
    </t>

        <section title="Handling Broken IPv6" anchor="happy">
        <t> One problem in practice that has been recently observed occurs 
            when a host has IPv4 connectivity to the Internet but has 
            "broken" IPv6 connectivity to the Internet in that it has
            a global IPv6 address but is disconnected from the IPv6
            Internet.   Since the default policy table prefers IPv6,
            this can result in unwanted timeouts.
        </t>
        <t> This can be solved by configuring the table to prefer IPv4 as 
            shown above.  An implementation that has some means to detect 
            that it is not connected to the IPv6 Internet MAY do this 
            automatically.  An implementation could instead treat it as
            part of its implementation of Rule 1 (avoid unusable destinations).
        </t>
        </section>
    </section>

    <section title="Configuring Preference for Link-Local Addresses">
    <t> The destination address selection rules give preference to
        destinations of smaller scope.  For example, a link-local destination
        will be sorted before a global scope destination when the two are
        otherwise equally suitable.  An administrator can change the policy
        table to reverse this preference and sort global destinations before
        link-local destinations:
    </t>
    <figure>
        <artwork>
   Prefix        Precedence Label
   ::1/128               50     0
   ::/0                  40     1
   ::ffff:0:0/96         35     4
   fe80::/10             33     1
   2002::/16             30     2
   2001::/32              5     5
   fc00::/7               3    13
   ::/96                  1     3
   fec0::/10              1    11
   3ffe::/16              1    12
        </artwork>
    </figure>
    <t> This change to the default policy table produces the following
        behavior:
    </t>
    <t> Candidate Source Addresses: 2001:db8::2 or fe80::2
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8::1 or fe80::1
        <vspace blankLines='0'/>
        New Result: 2001:db8::1 (src 2001:db8::2) then fe80::1 (src fe80::2)
        (prefer higher precedence)
    </t>
    <t> Candidate Source Addresses: 2001:db8::2 (deprecated) or fe80::2
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8::1 or fe80::1
        <vspace blankLines='0'/>
        Unchanged Result: fe80::1 (src fe80::2) then 2001:db8::1 (src 2001:db8::2)
        (avoid deprecated addresses)
    </t>
    </section>

    <section title="Configuring a Multi-Homed Site">
    <t> Consider a site A that has a business-critical relationship with
        another site B.&nbsp; To support their business needs, the two sites have
        contracted for service with a special high-performance ISP.  This is
        in addition to the normal Internet connection that both sites have
        with different ISPs.  The high-performance ISP is expensive, and the
        two sites wish to use it only for their business-critical traffic
        with each other.
    </t>
    <t> Each site has two global prefixes, one from the high-performance ISP
        and one from their normal ISP.  Site A has prefix 2001:db8:1aaa::/48
        from the high-performance ISP and prefix 2001:db8:70aa::/48 from its
        normal ISP.  Site B has prefix 2001:db8:1bbb::/48 from the high-
        performance ISP and prefix 2001:db8:70bb::/48 from its normal ISP.  All
        hosts in both sites register two addresses in the DNS.
    </t>
    <t> The routing within both sites directs most traffic to the egress to
        the normal ISP, but the routing directs traffic sent to the other
        site's 2001 prefix to the egress to the high-performance ISP.  To
        prevent unintended use of their high-performance ISP connection, the
        two sites implement ingress filtering to discard traffic entering
        from the high-performance ISP that is not from the other site.
    </t>
    <t> The default policy table and address selection rules produce the
        following behavior:
    </t>
    <t> Candidate Source Addresses: 2001:db8:1aaa::a or 2001:db8:70aa::a or
        fe80::a
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8:1bbb::b or 2001:db8:70bb::b
        <vspace blankLines='0'/>
        Result: 2001:db8:70bb::b (src 2001:db8:70aa::a) then 2001:db8:1bbb::b
        (src 2001:db8:1aaa::a) (longest matching prefix)
    </t>
    <t> In other words, when a host in site A initiates a connection to a
        host in site B, the traffic does not take advantage of their
        connections to the high-performance ISP.  This is not their desired
        behavior.
    </t>
    <t> Candidate Source Addresses: 2001:db8:1aaa::a or 2001:db8:70aa::a or
        fe80::a
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8:1ccc::c or 2001:db8:6ccc::c
        <vspace blankLines='0'/>
        Result: 2001:db8:1ccc::c (src 2001:db8:1aaa::a) then
        2001:db8:6ccc::c (src 2001:db8:70aa::a) (longest matching prefix)
    </t>
    <t> In other words, when a host in site A initiates a connection to a
        host in some other site C, the reverse traffic might come back through
        the high-performance ISP.  Again, this is not their desired behavior.
    </t>
    <t> This predicament demonstrates the limitations of the longest-
        matching-prefix heuristic in multi-homed situations.
    </t>
    <t> However, the administrators of sites A and B can achieve their
        desired behavior via policy table configuration.  For example, they
        can use the following policy table:
    </t>
    <figure>
        <artwork>
   Prefix        Precedence Label
   ::1/128               50     0
   2001:db8:1aaa::/48    43     6
   2001:db8:1bbb::/48    43     6
   ::/0                  40     1
   ::ffff:0:0/96         35     4
   2002::/16             30     2
   2001::/32              5     5
   fc00::/7               3    13
   ::/96                  1     3
   fec0::/10              1    11
   3ffe::/16              1    12
     </artwork>
    </figure>
    <t> This policy table produces the following behavior:
    </t>
    <t> Candidate Source Addresses: 2001:db8:1aaa::a or 2001:db8:70aa::a or
        fe80::a
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8:1bbb::b or 2001:db8:70bb::b
        <vspace blankLines='0'/>
        New Result: 2001:db8:1bbb::b (src 2001:db8:1aaa::a) then
        2001:db8:70bb::b (src 2001:db8:70aa::a) (prefer higher precedence)
    </t>
    <t> In other words, when a host in site A initiates a connection to a
        host in site B, the traffic uses the high-performance ISP as desired.
    </t>
    <t> Candidate Source Addresses: 2001:db8:1aaa::a or 2001:db8:70aa::a or
        fe80::a
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8:1ccc::c or 2001:db8:6ccc::c
        <vspace blankLines='0'/>
        New Result: 2001:db8:6ccc::c (src 2001:db8:70aa::a) then
        2001:db8:1ccc::c (src 2001:db8:70aa::a) (longest matching prefix)
    </t>
    <t> In other words, when a host in site A initiates a connection to a
        host in some other site C, the traffic uses the normal ISP as
        desired.
    </t>
    </section>

    <section title="Configuring ULA Preference" anchor="ulaexample">
    <t>Sections 2.1.4, 2.2.2, and 2.2.3 of  <xref target="RFC5220">RFC 5220</xref> 
        describe address selection problems related to <xref target="RFC4193">Unique Local Addresses (ULAs)</xref>.
        By default, global IPv6 destinations are preferred over ULA destinations,
        since an arbitrary ULA is not necessarily reachable:
    </t>
    <t> Candidate Source Addresses: 2001:db8:1::1 or fd11:1111:1111:1::1
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8:2::2 or fd22:2222:2222:2::2
        <vspace blankLines='0'/>
        Result: 2001:db8:2::2 (src 2001:db8:1::1) then
        fd22:2222:2222:2::2 (src fd11:1111:1111:1::1) (prefer higher precedence)
    </t>
    <t> However, a site-specific policy entry can be used to cause ULAs within
        a site to be preferred over global addresses as follows.
    </t>
        <figure>
            <artwork>
   Prefix        Precedence Label
   ::1/128               50     0
   fd11:1111:1111::/48   45    14
   ::/0                  40     1
   ::ffff:0:0/96         35     4
   2002::/16             30     2
   2001::/32              5     5
   fc00::/7               3    13
   ::/96                  1     3
   fec0::/10              1    11
   3ffe::/16              1    12
            </artwork>
        </figure>
    <t> Such a configuration would have the following effect:
    </t>
    <t> Candidate Source Addresses: 2001:db8:1::1 or fd11:1111:1111:1::1
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8:2::2 or fd22:2222:2222:2::2
        <vspace blankLines='0'/>
        Unchanged Result: 2001:db8:2::2 (src 2001:db8:1::1) then
        fd22:2222:2222:2::2 (src fd11:1111:1111:1::1) (prefer higher precedence)
    </t>
    <t> Candidate Source Addresses: 2001:db8:1::1 or fd11:1111:1111:1::1
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8:2::2 or fd11:1111:1111:2::2
        <vspace blankLines='0'/>
        New Result: fd11:1111:1111:2::2 (src fd11:1111:1111:1::1) then
        2001:db8:2::2 (src 2001:db8:1::1) (prefer higher precedence)
    </t>
    <t> Since ULAs are defined to have a /48 site prefix, an implementation 
        might choose to add such a row automatically on a machine with a ULA.
    </t>
    <t> It is also worth noting that ULAs are assigned global scope.
        As such, the existence of one or more rows in the prefix policy
        table is important so that source address selection does not choose
        a ULA purely based on longest match:
    </t>
    <t> Candidate Source Addresses: 2001:db8:1::1 or fd11:1111:1111:1::1
        <vspace blankLines='0'/>
        Destination Address List: ff00:1
        <vspace blankLines='0'/>
        Result: 2001:db8:1::1 (prefer matching label)
    </t>
    </section>

    <section title="Configuring 6to4 Preference" anchor="example6to4">
    <t> By default, NATed IPv4 is preferred over 6to4-relayed connectivity:
    </t>
    <t> Candidate Source Addresses: 2002:c633:6401::2 or 10.1.2.3
        <vspace blankLines='0'/>
        Destination Address List: 2001:db8:1::1 or 203.0.113.1
        <vspace blankLines='0'/>
        Result: 203.0.113.1 (src 10.1.2.3) then 2001:db8:1::1 (src 
        2002:c633:6401::2) (prefer matching label)
    </t>
    <t> However, NATed IPv4 is now also preferred over 6to4-to-6to4 connectivity
        by default.  Since a 6to4 prefix might be used natively within an
        organization, a site-specific policy entry can be used to cause
        native IPv6 communication (using a 6to4 prefix) to be preferred
        over NATed IPv4 as follows.
    </t>
        <figure>
            <artwork>
   Prefix        Precedence Label
   ::1/128               50     0
   2002:c633:6401::/48   45    14
   ::/0                  40     1
   ::ffff:0:0/96         35     4
   2002::/16             30     2
   2001::/32              5     5
   fc00::/7               3    13
   ::/96                  1     3
   fec0::/10              1    11
   3ffe::/16              1    12
            </artwork>
        </figure>
    <t> Such a configuration would have the following effect:
    </t>
    <t> Candidate Source Addresses: 2002:c633:6401:1::1 or 10.1.2.3
        <vspace blankLines='0'/>
        Destination Address List: 2002:c633:6401:2::2 or 203.0.113.1
        <vspace blankLines='0'/>
        New Result: 2002:c633:6401:2::2 (src 2002:c633:6401:1::1) then
        203.0.113.1 (sec 10.1.2.3) (prefer higher precedence)
    </t>
    <t> Since 6to4 addresses are defined to have a /48 site prefix,
        an implementation might choose to add such a row automatically
        on a machine with a native IPv6 address with a 6to4 prefix.
    </t>
    </section>
</section>

</middle>

<back>

    <references title="Normative References">
        &rfc2119;
        &rfc3056;
        &rfc3879;
        &rfc4193;
        &rfc4291;
        &rfc4380;
        &rfc4862;
        &rfc4941;
        &rfc6145;
    </references>


    <references title="Informative References">
        &rfc1794;
        &rfc1812;
        &rfc1918;
        &rfc2827;
        &rfc3484;
        &rfc3493;
        &rfc3701;
        &rfc3927;
        &rfc4007;
        &rfc4191;
        &rfc4213;
        &rfc4861;
        &rfc5014;
        &rfc5214;
        &rfc5220;
        &rfc5969;
        &rfc6275;
        &rfc6598;


<reference anchor='ADDR-SEL-OPT'>
<front>
<title>Distributing Address Selection Policy using DHCPv6</title>

<author initials='A' surname='Matsumoto' fullname='Arifumi Matsumoto'>
    <organization />
</author>

<author initials='T' surname='Fujisaki' fullname='Tomohiro Fujisaki'>
    <organization />
</author>

<author initials='J' surname='Kato' fullname='Jun-ya Kato'>
    <organization />
</author>

<author initials='T' surname='Chown' fullname='Tim Chown'>
    <organization />
</author>

<date month='August' day='16' year='2012' />

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>


    </references>

    <section title="Acknowledgements">
    <t> <xref target="RFC3484">RFC 3484</xref> acknowledged the contributions of the IPng
        Working Group, particularly Marc Blanchet, Brian Carpenter, Matt
        Crawford, Alain Durand, Steve Deering, Robert Elz, Jun-ichiro itojun
        Hagino, Tony Hain, M.T. Hollinger, JINMEI Tatuya, Thomas Narten, Erik
        Nordmark, Ken Powell, Markku Savela, Pekka Savola, Hesham Soliman,
        Dave Thaler, Mauro Tortonesi, Ole Troan, and Stig Venaas.  In
        addition, the anonymous IESG reviewers had many great comments and
        suggestions for clarification.
    </t>
    <t> This revision was heavily influenced by the work by Arifumi Matsumoto,
        Jun-ya Kato, and Tomohiro Fujisaki in a working document that made
        proposals for this revision to adopt, with input from Pekka Savola,
        Remi Denis-Courmont, Francois-Xavier Le Bail, and the 6man Working Group.
        Dmitry Anipko, Mark Andrews, Ray Hunter, and Wes George also provided
        valuable feedback on this revision.
    </t>
    </section>

<section title="Changes since RFC 3484">
    <t> Some changes were made to the default policy table that were deemed
        to be universally useful and cause no harm in every reasonable 
        network environment.  In doing so, care was taken to use
        the same preference and label values as in RFC 3484 whenever possible
        and for new rows to use label values less likely to collide with 
        values that might already be in use in additional rows on some hosts.
        These changes are:
    </t>
    <t> <list style="numbers">
        <t> Added the <xref target="RFC4380">Teredo</xref> prefix (2001::/32), 
            with the preference and label values already widely used in popular 
            implementations.
        </t>
        <t> Added a row for ULAs (fc00::/7) below native IPv6 since they are
            not globally reachable, as discussed in <xref target="ulaexample"/>.
        </t>
        <t> Added a row for site-local addresses (fec0::/10) in order to
            depreference them, for consistency with the example in
            <xref target="pref6or4"/>, since they are deprecated
            <xref target="RFC3879"/>.
        </t>
        <t> Depreferenced 6to4 (2002::/32) below native IPv4 since 6to4
            connectivity is less reliable today (and is expected to be phased
            out over time, rather than becoming more reliable).  It remains 
            above Teredo since 6to4 is more efficient in terms of connection 
            establishment time, bandwidth, and server load.
        </t>
        <t> Depreferenced IPv4-Compatible addresses (::/96) since they are now
            <xref target="RFC4291">deprecated</xref> and not in common use.
        </t>
        <t> Added a row for 6bone testing addresses (3ffe::/16) in order to 
            depreference them as they have also been phased out
            <xref target="RFC3701"/>.
        </t>
        <t> Added optional ability for an implementation to add automatic
            rows to the table for site-specific ULA prefixes and site-specific
            native 6to4 prefixes.
        </t>
        </list>
    </t>
    <t> Similarly, some changes were made to the rules, as follows:
    </t>
    <t> <list style="numbers">
        <t> Changed the definition of CommonPrefixLen() to only compare
            bits up to the source address's prefix length.  The previous
            definition used the entire source address, rather than only
            its prefix.  As a result, when a source and destination addresses
            had the same prefix, common bits in the interface ID would
            previously result in overriding DNS load balancing
            <xref target="RFC1794"/> by forcing the destination address with 
            the most bits in common to be always chosen.  The updated
            definition allows DNS load balancing to continue to be used
            as a tie breaker.
        </t>
        <t> Added Rule 5.5 to allow choosing a source address from
            a prefix advertised by the chosen next-hop for a given
            destination.  This allows better connectivity in the
            presence of <xref target="RFC2827">BCP 38</xref> ingress 
            filtering and egress filtering.  Previously, RFC 3484 had
            issues with multiple egress networks reached via the
            same interface, as discussed in <xref target="RFC5220"/>.
        </t>    
        <t> Removed restriction against anycast addresses in the candidate
            set of source addresses, since the restriction against using
            IPv6 anycast addresses as source addresses was removed in
            Section 2.6 of <xref target="RFC4291">RFC 4291</xref>.
        </t>
        <t> Changed mapping of <xref target="RFC1918">RFC 1918</xref>
            addresses to global scope in <xref target="v4scope"/>.
            Previously, they were mapped to site-local scope.  However, 
            experience has resulted in current implementations already 
            using global scope instead.  When they were mapped to
            site-local, Destination Address Selection Rule 2 (Prefer
            matching scope) would cause IPv6 to be preferred in 
            scenarios such as that described in <xref target="example6to4"/>. 
            The change to global scope allows configurability via
            the prefix policy table.
        </t>
        <t> Changed the default recommendation for Source Address Selection
            Rule 7 to prefer temporary addresses rather than public
            addresses, while providing an administrative override (in
            addition to the application-specific override that was already
            specified).  This change was made because of the increasing
            importance of privacy considerations, as well as the fact
            that widely deployed implementations have preferred temporary
            addresses for many years without major application issues.
        </t>
        </list>
    </t>
    <t> Finally, some editorial changes were made, including:
    </t>
    <t> <list style="numbers">
        <t> Changed global IP addresses in examples to use ranges
            reserved for documentation.
        </t>
        <t> Added additional examples in Sections <xref target="ulaexample" format="counter"/> 
            and <xref target="example6to4" format="counter"/>.
        </t>
        <t> Added <xref target="happy"/> on "broken" IPv6.
        </t>
        <t> Updated references.
        </t>
        </list>
    </t>
</section>
</back>
</rfc>
