<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="std" number="7880" ipr="trust200902" updates="5880"
 submissionType="IETF" consensus="yes">

  <front>
    <title abbrev="Seamless BFD Base">
        Seamless Bidirectional Forwarding Detection (S-BFD)
    </title>

    <author fullname="Carlos Pignataro" initials="C."
            surname="Pignataro">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <email>cpignata@cisco.com</email>
      </address>
    </author>

    <author fullname="Dave Ward" initials="D."
            surname="Ward">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <email>wardd@cisco.com</email>
      </address>
    </author>

    <author fullname="Nobo Akiya" initials="N."
            surname="Akiya">
      <organization>Big Switch Networks</organization>
      <address>
        <email>nobo.akiya.dev@gmail.com</email>
      </address>
    </author>

    <author fullname="Manav Bhatia" initials="M."
            surname="Bhatia">
      <organization>Ionos Networks</organization>
      <address>
        <email>manav@ionosnetworks.com</email>
      </address>
    </author>

    <author fullname="Santosh Pallagatti" initials="S."
            surname="Pallagatti">
      <organization></organization>
      <address>
        <email>santosh.pallagatti@gmail.com</email>
      </address>
    </author>

    <date month="July" year="2016"/>

    <keyword>BFD</keyword>
    <keyword>seamless BFD</keyword>
    <keyword>negotiation free</keyword>
    <keyword>segment routing</keyword>
    <keyword>IP</keyword>

    <abstract>
        <t>This document defines Seamless Bidirectional Forwarding
        Detection (S-BFD), a simplified mechanism for using BFD with a
        large proportion of negotiation aspects eliminated, thus
        providing benefits such as quick provisioning, as well as
        improved control and flexibility for network nodes initiating
        path monitoring.</t>

       <t>This document updates RFC 5880.</t>
    </abstract>

  </front>

  <middle>
    <section title="Introduction" anchor="Intro">

<t>Bidirectional Forwarding Detection (BFD), as described in <xref
target="RFC5880" /> and related documents, has efficiently generalized the
failure detection mechanism for multiple protocols and applications. There are
some improvements that can be made to better fit existing technologies. There
is a possibility of evolving BFD to better fit new technologies. This document
focuses on several aspects of BFD in order to further improve efficiency,
expand failure detection coverage, and allow BFD usage for wider scenarios.
Additional use cases are listed in <xref target="RFC7882" />.
</t>

<t>
Specifically, this document defines Seamless Bidirectional Forwarding
Detection (S-BFD), a simplified mechanism for using BFD with a large
proportion of negotiation aspects eliminated, thus providing benefits such as
quick provisioning, as well as improved control and flexibility for network
nodes initiating path monitoring. S-BFD enables cases benefiting from the use
of core BFD technologies in a fashion that leverages existing implementations
and protocol machinery while providing a rather simplified and largely
stateless infrastructure for continuity testing.
</t>

<t>One key aspect of the mechanism described in this document eliminates the
time between a network node wanting to perform a continuity test and
completing the continuity test. In traditional BFD terms, the initial state
changes from DOWN to UP are virtually nonexistent. Removal of this "seam"
(i.e., time delay) in BFD provides a smooth and continuous operational
experience for applications.  Therefore, &quot;Seamless BFD&quot; (S-BFD)
has been chosen as the name for this mechanism.</t>
</section>

<section title="Terminology">

 <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
 "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
 document are to be interpreted as described in <xref
 target="RFC2119">RFC 2119</xref>.</t>

<t>The reader is expected to be familiar with the BFD <xref target="RFC5880"
/>, IP <xref target="RFC791" /> <xref target="RFC2460" />, and MPLS <xref
target="RFC3031" /> terms and protocol constructs. The remainder of this section
describes several new terms introduced by S-BFD.

<list style="symbols">

<t>Classical BFD - BFD session types based on <xref target="RFC5880" />.</t>

<t>S-BFD - Seamless BFD.</t>

<t>S-BFD Control packet - a BFD Control packet for the S-BFD mechanism.</t>

<t>S-BFD Echo packet - a BFD Echo packet for the S-BFD mechanism.</t>

<t>S-BFD packet - a BFD Control packet or a BFD Echo packet.</t>

<t>Entity - a function on a network node to which the S-BFD mechanism
allows remote network nodes to perform continuity tests. An entity can
be abstract (e.g., reachability) or specific (e.g., IP addresses,
Router-IDs, functions).</t>

<t>SBFDInitiator - an S-BFD session on a network node that performs a
continuity test to a remote entity by sending S-BFD packets.</t>

<t>SBFDReflector - an S-BFD session on a network node that listens for
incoming S-BFD Control packets to local entities and generates response S-BFD
Control packets.</t>

<t>Reflector BFD session - synonymous with SBFDReflector.</t>

<t>S-BFD Discriminator - a BFD Discriminator allocated for a local entity.
An SBFDReflector listens for S-BFD Discriminators.</t>

<t>BFD Discriminator - a BFD Discriminator allocated for an SBFDInitiator.</t>

<t>Initiator - a network node hosting an SBFDInitiator.</t>

<t>Responder - a network node hosting an SBFDReflector.</t>

</list>

<xref target="sbfd-fig" /> describes the relationship between S-BFD
terms.

<figure title="S-BFD Terminology Relationship" align="left" anchor="sbfd-fig"><preamble></preamble><artwork align="left"><![CDATA[
 +---------------------+                +------------------------+
 |      Initiator      |                |         Responder      |
 | +-----------------+ |                |    +-----------------+ |
 | |  SBFDInitiator  |---S-BFD Ctrl pkt----->|  SBFDReflector  | |
 | | +-------------+ |<--S-BFD Ctrl pkt------| +-------------+ | |
 | | | BFD Discrim | | |                |    | |S-BFD Discrim| | |
 | | |             | |---S-BFD Echo pkt---+  | |             | | |
 | | +-------------+ | |                | |  | +----------^--+ | |
 | +-----------------+<-------------------+  +------------|----+ |
 |                     |                |                 |      |
 |                     |                |             +---v----+ |
 |                     |                |             | Entity | |
 |                     |                |             +--------+ |
 +---------------------+                +------------------------+
]]></artwork></figure>
</t>

    </section>

    <section title="Seamless BFD Overview" anchor="Overview">
 
<t>An S-BFD module on each network node allocates one or more S-BFD
Discriminators for local entities and creates a Reflector BFD
session. Allocated S-BFD Discriminators may be advertised by applications
(e.g., OSPF/IS-IS). The required result is that applications on other network
nodes will know about the S-BFD Discriminators allocated by a remote
node to remote entities. The Reflector BFD session, upon receiving an
S-BFD Control packet targeted to one of the local S-BFD Discriminator values,
is to transmit a response S-BFD Control packet back to the initiator.</t>

<t>Once the above setup is complete, any network node that knows about the
S-BFD Discriminator allocated by a remote node to a remote entity or entities
can quickly perform a continuity test to the remote entity by simply sending
S-BFD Control packets with a corresponding S-BFD Discriminator value in the
Your&nbsp;Discriminator field.
</t>

<t>
This is exemplified in <xref target="fig2" />.
</t>

<figure anchor="fig2" title="S-BFD for IS-IS Network" align="left"><preamble></preamble><artwork align="left">
                  &lt;------- IS-IS Network -------&gt;

                            +---------+
                            |         |
                  A---------B---------C---------D
                  ^                             ^
                  |                             |
              System-ID                      System-ID
                 xxx                            yyy
             BFD Discrim                    BFD Discrim
                 123                            456
</artwork></figure>
<t>

An S-BFD module in a system with IS-IS System-ID xxx (Node&nbsp;A) allocates an
S-BFD Discriminator 123, and IS-IS advertises the S-BFD Discriminator&nbsp;123
in an IS-IS TLV. An S-BFD module in a system with IS-IS System-ID&nbsp;yyy
(Node&nbsp;D) allocates an S-BFD Discriminator 456, and IS-IS advertises the
S-BFD Discriminator 456 in an IS-IS TLV. A Reflector BFD session is created
on both network nodes (Node&nbsp;A and Node&nbsp;D). When Node&nbsp;A wants
to check the reachability of Node&nbsp;D, Node&nbsp;A can send an S-BFD
Control packet destined to Node&nbsp;D with the Your&nbsp;Discriminator
field set to 456. When the Reflector BFD session on Node&nbsp;D receives
this S-BFD Control packet, then a response S-BFD Control packet is sent
back to Node&nbsp;A, which allows Node&nbsp;A to complete the continuity
test.</t>

<t>
When a node allocates multiple S-BFD Discriminators, how remote nodes
determine which of the discriminators is associated with a specific entity is
currently unspecified. The use of multiple S-BFD Discriminators by a single
network node is therefore discouraged until a means of learning the mapping is
defined.
</t>

</section>

    <section title="S-BFD Discriminators" anchor="Res_BFD_Dis">

<section title="S-BFD Discriminator Uniqueness" anchor="_SBFD_DISC_UNIQ">

<t>One important characteristic of an S-BFD Discriminator is that it MUST be
unique within an administrative domain. If multiple network nodes allocate
the same S-BFD Discriminator value, then S-BFD Control packets falsely
terminating on a wrong network node can result in a Reflector BFD session
generating a response back because of a matching Your&nbsp;Discriminator
value. This is clearly not desirable.</t>

</section>

<section title="Discriminator Pools">

<t>This subsection describes a discriminator pool implementation technique
to minimize S-BFD Discriminator collisions. This technique will allow an
implementation to better satisfy the S-BFD Discriminator uniqueness
requirement defined in <xref target="_SBFD_DISC_UNIQ" />.

<list style="symbols">
<t>An SBFDInitiator is to allocate a discriminator from the BFD Discriminator
pool. If the system also supports classical BFD (i.e., implements <xref
target="RFC5880"/>), then the BFD Discriminator pool SHOULD be shared by
SBFDInitiator sessions and classical BFD sessions.</t>

<t>An SBFDReflector is to allocate a discriminator from the S-BFD Discriminator
pool. The S-BFD Discriminator pool SHOULD be a separate pool from the BFD
Discriminator pool.</t>
</list>

The remainder of this subsection describes the reasons for the suggestions
above.</t>

<t>Locally allocated S-BFD Discriminator values for entities that
SBFDReflector sessions are listening for may be arbitrarily allocated or
derived from values provided by applications. These values may be
protocol IDs (e.g., System-ID, Router-ID) or network targets (e.g.,
IP address). To avoid derived S-BFD Discriminator values already being
assigned to other BFD sessions (i.e., SBFDInitiator sessions and
classical BFD sessions), it is RECOMMENDED that the discriminator pool
for SBFDReflector sessions be separate from other BFD sessions.</t>

<t>Even when following the "separate discriminator pool" approach, a
collision is still possible between different S-BFD applications that
may be using different values and algorithms to derive S-BFD
Discriminator values. If two applications are using S-BFD for the
same purpose (e.g., network reachability), then the colliding S-BFD
Discriminator value can be shared. If the two applications are using S-BFD for
a different purpose, then the collision must be addressed. The use of multiple
S-BFD Discriminators by a single network node, however, is discouraged (see
<xref target="Overview" />).
</t>

</section>

    </section>

    <section title="Reflector BFD Session" anchor="_REF_SESSION">

<t>Each network node creates one or more Reflector BFD sessions. This
Reflector BFD session is a session that transmits S-BFD Control packets in
response to received S-BFD Control packets with the Your&nbsp;Discriminator
field having S-BFD Discriminators allocated for local entities. Specifically,
this Reflector BFD session has the following characteristics:

<list style="symbols">
<t>MUST NOT transmit any S-BFD packets based on local timer expiry.</t>

<t>MUST transmit an S-BFD Control packet in response to a received S-BFD
Control packet having a valid S-BFD Discriminator in the
Your&nbsp;Discriminator field, unless prohibited by local policies (e.g.,
administrative, security, rate-limiter).</t>

<t>MUST be capable of sending only two states: UP and AdminDown.</t>
</list>
One Reflector BFD session may be responsible for handling received S-BFD
Control packets targeted to all locally allocated S-BFD Discriminators, or
a few Reflector BFD sessions may each be responsible for a subset of
locally allocated S-BFD Discriminators. This policy is a local matter
and is outside the scope of this document.
</t>

<t>Note that incoming S-BFD Control packets may be based on IPv4, IPv6,
or MPLS <xref target="RFC7881" />. Note also that other options
are possible and may be defined in future documents.  How such S-BFD
Control packets reach an appropriate Reflector BFD session is also a local
matter and is outside the scope of this document.</t>

    </section>

<section title="State Variables">

<t>S-BFD introduces new state variables and modifies the usage of existing
ones.</t>

<section title="New State Variables">

   <t>A new state variable is added to the base specification in support of
   S-BFD.

   <list style="symbols">
   <t>bfd.SessionType: This is a new state variable that describes
   the&nbsp;type of a particular session. Allowable values for S-BFD
   sessions are:
            <list>
            <t>SBFDInitiator - an S-BFD session on a network node that
            performs a continuity test to a target entity by sending S-BFD
            packets.</t>

            <t>SBFDReflector - an S-BFD session on a network node that listens
            for incoming S-BFD Control packets to local entities and generates
            response S-BFD Control packets.</t>
          </list> 
      </t>    
      </list>
      </t>
<t>The bfd.SessionType variable MUST be initialized to the appropriate type
when an S-BFD session is created.</t>

</section>

<section title="State Variable Initialization and Maintenance">

   <t>State variables (defined in Section 6.8.1 of <xref target="RFC5880"/>)
   need to be initialized or manipulated differently, depending on the
   session type.

<list style="symbols">
<t>bfd.DemandMode: 
       This variable MUST be initialized to 1 for session type
       SBFDInitiator and MUST be initialized to 0 for session type
       SBFDReflector. This is done to prevent loops (see
       <xref target="loop" />).
</t>
</list>
</t>
</section>
</section>

    <section title="S-BFD Procedures">

<section title="Demultiplexing of S-BFD Control Packet" anchor="_PRE_DEMUX">

        <t>An S-BFD packet MUST be demultiplexed with lower-layer information
        (e.g., dedicated destination UDP port <xref target="RFC7881"/>,
        associated Channel Type <xref target="RFC7885"/>). The following
        procedure SHOULD be executed on both initiator and reflector:

        <list style="empty">
                <t>If the packet is an S-BFD packet
                        <list style="empty">
                 <t>If the S-BFD packet is for an SBFDReflector
                    <list style="empty">
                            <t>The packet MUST be looked up to locate a
                corresponding SBFDReflector session based on
                the value from the Your&nbsp;Discriminator field
                in the table describing S-BFD Discriminators.
                            </t>
                    </list>
                 </t>
                        
                 <t>Else
                    <list style="empty">
                <t>The packet MUST be looked up to locate a corresponding
                SBFDInitiator session or classical BFD session based on
                the value from the Your Discriminator field in the table
                describing BFD Discriminators. If no match, then the
                received packet MUST be discarded.
                </t>
                            
                    <t>If the session is an SBFDInitiator session
                     <list style="empty">
                       <t>The destination of the packet (i.e., the destination
                       IP address) SHOULD be verified as being for itself.
                             </t>
                     </list>
                            </t>
                            
                            <t>Else
                     <list style="empty">
                             <t>The packet MUST be discarded.</t>
                     </list>
                            </t>
                    </list>
                 </t>
                        </list>
                </t>
                <t> Else
                        <list style="empty">
                 <t>The procedure described in 
                 Section&nbsp;6.8.6 of <xref target="RFC5880"/>
                 MUST be applied.</t>
                        </list>
                </t>
        </list>
        </t>

<t>More details on S-BFD Control packet demultiplexing are provided in
relevant S-BFD data-plane documents.</t>

</section>


<section title="Responder Procedures">

<t>A network node that receives S-BFD Control packets transmitted by an
initiator is referred to as the responder. The responder, upon reception
of S-BFD Control packets, is to verify the validity of the packets, as
described in <xref target="RFC5880" />.</t>

<section title="Responder Demultiplexing">

<t>An S-BFD packet MUST be demultiplexed with lower-layer information. The
following procedure SHOULD be executed by the responder:

        <list style="empty">
                <t>If the Your&nbsp;Discriminator field is not one of the
                entries allocated for local entities
                 <list style="empty">
                    <t>The packet MUST be discarded.</t>
                 </list>
                </t>
                <t>Else
                        <list style="empty">
                 <t>The packet is determined to be handled by a Reflector BFD
                 session responsible for that S-BFD Discriminator.</t>

                 <t>If allowable per local policy (e.g., administrative,
                 security, rate-limiter)

                    <list style="empty">
                            <t>The chosen Reflector BFD session SHOULD
                            transmit a response BFD Control packet using
                            the procedures described in
                            <xref target="_SBFD_PAK_REFLECTOR"/>.</t>

                    </list>
                 </t>
                        </list>
                </t>
        </list>
</t>

</section>

<section title="Transmission of S-BFD Control Packet by SBFDReflector" anchor="_SBFD_PAK_REFLECTOR">

<t>The contents of S-BFD Control packets sent by an SBFDReflector MUST be
set as per Section&nbsp;6.8.7 of <xref target="RFC5880" />. There are a few
fields that need to be set differently from <xref target="RFC5880" />,
as follows:

        <list style="empty">
                <t>State (Sta)
                        <list style="empty">
                 <t>Set to bfd.SessionState (either UP or AdminDown
                 only). Clarification of Reflector BFD session state is
                 described in <xref target="Add_Res_Beh" />.</t>

                        </list>
                </t>
                
                <t>Demand (D)
                        <list style="empty">
                 <t>Set to 0, to indicate that the S-BFD packet is sent by
                 the SBFDReflector.</t>
                        </list>
                </t>
                
                <t>Detect Mult
                        <list style="empty">
                 <t>Value to be copied from the Detection Multiplier field
                 of the received BFD packet.</t>
                        </list>
                </t>

                <t>My Discriminator
                        <list style="empty">
                 <t>Value to be copied from the Your&nbsp;Discriminator
                 field of the received BFD packet.</t>
                        </list>
                </t>
                <t>Your Discriminator
                        <list style="empty">
                 <t>Value to be copied from the My&nbsp;Discriminator field
                 of the received BFD packet.</t>
                        </list>
                </t>

                <t>Desired Min TX Interval
                        <list style="empty">
                 <t>Value to be copied from the Desired Min TX Interval field
                 of the received BFD packet.</t>
                        </list>
                </t>
                
                <t>Required Min RX Interval
                   <list style="empty">
                       <t>Set to bfd.RequiredMinRxInterval. Value
                       indicating the minimum interval, in microseconds,
                       between received S&nbhy;BFD Control packets. Further
                       details are provided in <xref target="Add_Res_Beh"/>.
                       </t>
                   </list>
                </t>

                <t>Required Min Echo RX Interval
                        <list style="empty">
                 <t> If the device supports looping back S-BFD Echo packets
                    <list style="empty">
                            <t>Set to the minimum required S-BFD Echo packet
                            receive interval for this session.</t>
                    </list>
                 </t>
                 <t> Else
                    <list style="empty">
                            <t>Set to 0.</t>
                    </list>
                 </t>
                        </list>
                </t>
        </list>
</t>

</section>


<section title="Additional SBFDReflector Behaviors" anchor="Add_Res_Beh">

<t>

<list style="symbols">

<t>S-BFD Control packets transmitted by the SBFDReflector MUST have
Required Min RX Interval set to a value that expresses, in
microseconds, the minimum interval between incoming S-BFD Control packets
that this SBFDReflector can handle. The SBFDReflector can control how
fast SBFDInitiators will be sending S-BFD Control packets to themselves by
ensuring that Required Min RX Interval indicates a value based on the
current load.</t>

<t>
When the SBFDReflector receives an S-BFD Control packet from an SBFDInitiator,
then the SBFDReflector needs to determine what "state" to send in the response
S-BFD Control packet.  If the monitored local entity is in service, then the
state MUST be set to UP.  If the monitored local entity is "temporarily out
of service", then the state SHOULD be set to AdminDown.
</t>

<t>If an SBFDReflector receives an S-BFD Control packet with the
Demand (D) bit cleared, the packet MUST be discarded (see <xref target="loop"
/>).</t>

</list>
</t>

</section>

</section>

<section title="Initiator Procedures">

<t>S-BFD Control packets transmitted by an SBFDInitiator MUST set
the Your&nbsp;Discriminator field to an S-BFD Discriminator corresponding
to the remote entity.</t>

<t>Every SBFDInitiator MUST have a locally unique My&nbsp;Discriminator
value allocated from the BFD Discriminator pool.</t>

<t><xref target="fig-ini"/> describes the high-level concept of continuity
testing using S-BFD. R2 allocates XX as the S-BFD Discriminator for network
reachability purposes and advertises XX to neighbors. <xref target="fig-ini"/>
shows R1 and R4 performing a continuity test to R2.

<figure anchor="fig-ini" title="S-BFD Continuity Test" align="left"><preamble></preamble><artwork align="left"><![CDATA[
       +--- md=50/yd=XX (ping) ----+
       |                           |
       |+-- md=XX/yd=50 (pong) --+ |
       ||                        | |
       |v                        | v
       R1 ==================== R2[*] ========= R3 ========= R4
                                 | ^                        |^
                                 | |                        ||
                                 | +-- md=60/yd=XX (ping) --+|
                                 |                           |
                                 +---- md=XX/yd=60 (pong) ---+

      [*] Reflector BFD session on R2.
      === Links connecting network nodes.
      --- S-BFD Control packet traversal.
]]></artwork></figure>
</t>

<section title="SBFDInitiator State Machine" anchor="SBFDInitiator">

<t>An SBFDInitiator may be a "persistent" session on the initiator with a timer
for S-BFD Control packet transmissions (stateful SBFDInitiator). An
SBFDInitiator may also be a module, a script, or a tool on the initiator that
transmits one or more S-BFD Control packets &quot;when needed&quot; (stateless
SBFDInitiator). For stateless SBFDInitiators, a complete BFD state machine may
not be applicable. For stateful SBFDInitiators, the states and the state
machine described in <xref target="RFC5880" /> will not function due to the
SBFDReflector session only sending the UP and AdminDown states (i.e., the
SBFDReflector session does not send the INIT state). The following diagram
provides the RECOMMENDED state machine for stateful SBFDInitiators. The
notation on each arc represents the state of the SBFDInitiator (as received in
the State field in the S-BFD Control packet) or indicates the expiration of
the Detection Timer. See <xref target="fig4" />.
</t>
                             
<figure anchor="fig4" title="SBFDInitiator Finite State Machine" align="left"><preamble></preamble><artwork align="left"><![CDATA[
                    +--+
       ADMIN DOWN,  |  |
       TIMER        |  V
                  +------+   UP                +------+
                  |      |-------------------->|      |----+
                  | DOWN |                     |  UP  |    | UP
                  |      |<--------------------|      |<---+
                  +------+   ADMIN DOWN,       +------+
                             TIMER
]]></artwork></figure>

<t>
Note that the above state machine is different from the base BFD specification
<xref target="RFC5880" />. This is because the INIT state is no longer
applicable for the SBFDInitiator. Another important difference is the
transition of the state machine from the DOWN state to the UP state when a
packet with an UP state setting is received by the SBFDInitiator. The
definitions of the states and events have the same meanings as those
defined in the base BFD specification <xref target="RFC5880" />.

</t>
</section>

<section title="Transmission of S-BFD Control Packet by SBFDInitiator" anchor="_SBFD_PAK_INITIATOR">

<t>The contents of S-BFD Control packets sent by an SBFDInitiator MUST be
set as per Section&nbsp;6.8.7 of <xref target="RFC5880" />. There are a few
fields that need to be set differently from <xref target="RFC5880" />,
as follows:
        <list style="empty">
                <t>Demand (D)
                        <list style="empty">
                 <t>Used to indicate that the S-BFD packet originated
                 from the SBFDInitiator.  Always set to 1.</t>
                        </list>
                </t>
                
                <t>Your Discriminator
                        <list style="empty">
                 <t>Set to bfd.RemoteDiscr. &nbsp;bfd.RemoteDiscr is
                 set to the Discriminator value of the remote
                 entity. It MAY be learnt from routing
                 protocols or configured locally.</t>
                        </list>
                </t>
                
                <t>Required Min RX Interval
                        <list style="empty">
                 <t>Set to 0.</t>
                        </list>
                </t>
                <t>Required Min Echo RX Interval
                        <list style="empty">
                 <t>Set to 0.</t>
                        </list>
                </t>
        </list>
</t>

</section>


<section title="Additional SBFDInitiator Behaviors">

<t>
<list style="symbols">

<t>If the SBFDInitiator receives a valid S-BFD Control packet in response to
a transmitted S-BFD Control packet to a remote entity, then the SBFDInitiator
SHOULD conclude that the S-BFD Control packet reached the intended remote
entity.</t>

<t>
When an SBFDInitiator receives a response S-BFD Control packet, if the state
specified is AdminDown, the SBFDInitiator MUST NOT conclude that the
reachability of the corresponding remote entity is lost and MUST back off
the packet transmission interval for the remote entity to an interval
no faster than 1&nbsp;second.
</t>

<t>When a sufficient number of S-BFD packets have not arrived as they should,
the SBFDInitiator SHOULD declare loss of reachability to the remote
entity. The criteria for declaring loss of reachability and the action that
would be triggered as a result are outside the scope of this document; the
action MAY include logging an error.</t>

<t>Regarding the third bullet item, it is critical for an implementation to
understand the latency to/from the Reflector BFD session on the responder. In
other words, for the very first S-BFD packet transmitted by the
SBFDInitiator, an implementation MUST NOT expect a response S-BFD packet
to be received for a time equivalent to the sum of the latencies: initiator
to responder and responder back to initiator.</t>

<t>If the SBFDInitiator receives an S-BFD Control packet with the
Demand (D) bit set, the packet MUST be discarded (see <xref target="loop"
/>).</t>

</list>
</t>

</section>

</section>



<section title="Diagnostic Values">

<t>The diagnostic value in both directions MAY be set to a certain value,
to attempt to communicate further information to both ends. Implementations
MAY use the already&nbhy;existing diagnostic values defined in
Section&nbsp;4.1 of <xref target="RFC5880" />. However, details regarding
this topic are outside the scope of this specification.</t>

</section>

<section title="The Poll Sequence">

<t>The Poll Sequence MAY be used in both directions. The Poll Sequence MUST
operate in accordance with <xref target="RFC5880" />. An SBFDReflector MAY use
the Poll Sequence to slow down the rate at which S-BFD Control packets are
generated from an SBFDInitiator. This is done by the SBFDReflector, using the
procedures described in <xref target="Add_Res_Beh" /> and setting the Poll (P)
bit in the reflected S-BFD Control packet. The SBFDInitiator is to then send
the next S-BFD Control packet with the Final (F) bit set. If an SBFDReflector
receives an S-BFD Control packet with the P&nbsp;bit set, then the
SBFDReflector MUST respond with an S-BFD Control packet with the P&nbsp;bit
cleared and the F&nbsp;bit set.</t>

</section>

    </section>

    <section title="Operational Considerations">
<t>
S-BFD provides a smooth and continuous (i.e., seamless) operational experience
as an Operations, Administration, and Maintenance (OAM) mechanism for
connectivity checking and connection verification. This is achieved by
providing a simplified mechanism with a large proportion of negotiation
aspects eliminated, resulting in faster and simpler provisioning.
</t>
<t>
Because of this simplified mechanism, due to a misconfiguration an
SBFDInitiator could send S-BFD Control packets to a target that does not exist
or that is outside the S-BFD administrative domain. As explained in <xref
target="SBFDInitiator" />, an SBFDInitiator can be a persistent initiator or
a "when needed" one. When an S-BFD persistent SBFDInitiator is used, a
deployment SHOULD ensure that S-BFD Control packets do not propagate
for an extended period of time outside of the administrative domain that
uses it. Further, operational measures SHOULD be taken to determine if
responses to S-BFD packets are not sent for an extended period of time and
then remediate the situation. These potential concerns are largely mitigated
by dynamic advertisement mechanisms for S-BFD and with automation checks
before applying configurations.
</t>
    <section title="Scaling Aspect">

<t>This mechanism brings forth one noticeable difference in terms of the
scaling aspect: the number of SBFDReflectors. This specification eliminates
the need for egress nodes to have fully active BFD sessions when only one side
desires to perform continuity tests. With the introduction of the
Reflector BFD concept, egress is no longer required to create any active
BFD sessions on a per&nbhy;path/LSP/function basis. Because of this, the
total number of BFD sessions in a network is reduced.</t>
 
    </section>

    <section title="Congestion Considerations">
<t>
When S-BFD performs failure detection, it consumes resources, including
bandwidth and CPU processing. To avoid congestion, it is therefore
imperative that operators correctly provision the rates at which S-BFD
packets are transmitted. When BFD is used across multiple hops, a congestion
control mechanism MUST be implemented, and when congestion is detected, the
BFD implementation MUST reduce the amount of traffic it generates.
The exact mechanism used to detect congestion is outside the scope of this
specification but may include the detection of lost BFD Control packets or
other means. The SBFDReflector can limit the rate at which SBFDInitiators
will be sending S-BFD Control packets by utilizing Required Min RX Interval,
but at the expense of detection time (i.e., detection time will increase).
</t>
    </section>
    </section>

    <section title="Co-existence with Classical BFD Sessions">

<t>Demultiplexing requirements for the initial packet are described in
<xref target="_PRE_DEMUX" />. Because of this, the S-BFD mechanism can
co&nbhy;exist with classical BFD sessions.</t>

    </section>

<section title="S-BFD Echo Function">

<t>The concept of the S-BFD Echo function is similar to the BFD Echo function
described in <xref target="RFC5880" />. S-BFD Echo packets have the
destination of "self"; thus, S-BFD Echo packets are self-generated and
self-terminated after traversing a link/path. S-BFD Echo packets are expected
to U&nbhy;turn on the target node in the data plane and MUST&nbsp;NOT be
processed by any Reflector BFD sessions on the target&nbsp;node.</t>

<t>When using the S-BFD Echo function, it is RECOMMENDED that:

<list style="symbols">
<t>Both S-BFD Control packets and S-BFD Echo packets be sent.</t>
<t>Both S-BFD Control packets and S-BFD Echo packets have the same semantics
in the forward direction to reach the target node.</t>
</list>

In other words, it is not preferable to send just S-BFD Echo packets without
also sending S-BFD Control packets. There are two reasons behind this
suggestion:

<list style="symbols">
<t>S-BFD Control packets can verify the reachability of the intended
target node; this allows one to have confidence that S-BFD Echo packets
are U&nbhy;turning on the expected target node.</t>

<t>S-BFD Control packets can detect when the target node is going out of
service (i.e., by receiving AdminDown state).</t>
</list>
S-BFD Echo packets can be spoofed and can U&nbhy;turn in a transit node before
reaching the expected target node. When the S-BFD Echo function is used, it is
RECOMMENDED in this specification that both S-BFD Control packets and S-BFD
Echo packets be sent. While the additional use of S-BFD Control packets
alleviates these two concerns, some form of authentication MAY still be
included.
</t>

<t>
The usage of the Required Min Echo RX Interval field is described
in Sections&nbsp;<xref target="_SBFD_PAK_REFLECTOR" format="counter"/>
and <xref target="_SBFD_PAK_INITIATOR" format="counter"/>. Because of
the stateless nature of SBFDReflector sessions, a value specified in the
Required Min Echo RX Interval field is not very meaningful to the
SBFDReflector. Thus, it is RECOMMENDED that the Required Min Echo RX Interval
field simply be set to zero by the SBFDInitiator. The SBFDReflector
MAY set the Required Min Echo RX Interval field to an appropriate value
to control the rate at which it wants to receive S&nbhy;BFD Echo packets.</t>

<t>The following aspects of S-BFD Echo functions are left as implementation
details and are outside the scope of this document:

<list style="symbols">
<t>Format of the S-BFD Echo packet (e.g., data beyond UDP header).</t>
<t>Procedures on when and how to use the S-BFD Echo function.</t>
</list>
</t>

</section>

    <section anchor="Security" title="Security Considerations">

<t>The same security considerations as those described in <xref
target="RFC5880" /> apply to this document. Additionally, implementing the
following measures will strengthen security aspects of the mechanism described
by this document:

<list style="symbols">
<t>The SBFDInitiator MAY pick a sequence number to be set in
&quot;sequence number&quot; in the Authentication Section, based on
the configured authentication mode.</t>

<t>The SBFDReflector MUST NOT use the crypto sequence number to make a
decision about accepting the packet. This is because the SBFDReflector does
not maintain S-BFD peer state and because the SBFDReflector can receive S-BFD
packets from multiple SBFDInitiators. Consequently, BFD authentication can be
used, but not the sequence number.
</t>

<t>The SBFDReflector MAY use the Auth Key ID in the incoming packet
to verify the Authentication Data.
</t>

<t>The SBFDReflector MUST accept the packet if authentication is successful.</t>

<t>The SBFDReflector MUST compute the Authentication Data and MUST use the
same sequence number that it received in the S-BFD Control packet to which
it is responding.</t>

<t>The SBFDInitiator SHOULD accept an S-BFD Control packet with a
sequence number within the permissible range. One potential approach is
the procedure explained in <xref target="BFD-GEN-AUTH" />.</t>

</list>
</t>
<t>Using the above method,
<list style="symbols">
<t>SBFDReflectors continue to remain stateless, despite using security.</t>

<t>SBFDReflectors are not susceptible to replay attacks, as they always respond
to S-BFD Control packets irrespective of the sequence number carried.</t>

<t>An attacker cannot impersonate the responder, since the SBFDInitiator will
only accept S-BFD Control packets that come with the sequence number that it
had originally used when sending the S-BFD Control packet.</t>
</list>
</t>

<t>
Additionally, the use of strong forms of authentication is strongly
encouraged for S-BFD. The use of Simple Password authentication
<xref target="RFC5880"/> potentially puts other services at risk
if S-BFD packets can be intercepted and those password values are
reused for other services.
</t>

<t>
Considerations related to loop problems are covered in <xref target="loop" />.
</t>
    </section>

  </middle>

  <back>

    <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>
      <?rfc include="reference.RFC.5880"?>
       
    </references>
    
    <references title="Informative References">
      <?rfc include="reference.RFC.2460"?>

<reference  anchor='RFC791' target='http://www.rfc-editor.org/info/rfc791'>
<front>
<title>Internet Protocol</title>
<author initials='J.' surname='Postel' fullname='J. Postel'><organization /></author>
<date year='1981' month='September' />
</front>
<seriesInfo name='STD' value='5'/>
<seriesInfo name='RFC' value='791'/>
<seriesInfo name='DOI' value='10.17487/RFC791'/>
</reference>

      <?rfc include="reference.RFC.3031"?>

<!-- draft-ietf-bfd-seamless-ip (RFC 7881) -->
<reference anchor='RFC7881' target="http://www.rfc-editor.org/info/rfc7881">
<front>
<title>Seamless Bidirectional Forwarding Detection (S-BFD) for IPv4, IPv6, and MPLS</title>
<author initials='C' surname='Pignataro' fullname='Carlos Pignataro'>
    <organization />
</author>
<author initials='D' surname='Ward' fullname='David Ward'>
    <organization />
</author>
<author initials='N' surname='Akiya' fullname='Nobo Akiya'>
    <organization />
</author>
<date month='July' year='2016' />
</front>
<seriesInfo name='RFC' value='7881'/>
<seriesInfo name="DOI" value="10.17487/RFC7881"/>
</reference>

<!-- draft-ietf-bfd-seamless-use-case (RFC 7882) -->
<reference anchor='RFC7882' target="http://www.rfc-editor.org/info/rfc7882">
<front>
<title>Seamless Bidirectional Forwarding Detection (S-BFD) Use Cases</title>
<author initials='S' surname='Aldrin' fullname='Sam Aldrin'>
    <organization />
</author>
<author initials='C' surname='Pignataro' fullname='Carlos Pignataro'>
    <organization />
</author>
<author initials='G' surname='Mirsky' fullname='Greg Mirsky'>
    <organization />
</author>
<author initials='N' surname='Kumar' fullname='Nagendra Kumar'>
    <organization />
</author>
<date month='July' year='2016' />
</front>
<seriesInfo name='RFC' value='7882'/>
<seriesInfo name="DOI" value="10.17487/RFC7882"/>
</reference>

<!-- draft-ietf-pals-seamless-vccv (RFC 7885) -->
<reference anchor='RFC7885' target="http://www.rfc-editor.org/info/rfc7885">
<front>
<title>Seamless Bidirectional Forwarding Detection (S-BFD) for Virtual Circuit
Connectivity Verification (VCCV)</title>
<author initials='V' surname='Govindan' fullname='Vengada Govindan'>
    <organization />
</author>
<author initials='C' surname='Pignataro' fullname='Carlos Pignataro'>
    <organization />
</author>
<date month='July' year='2016' />
</front>
<seriesInfo name='RFC' value='7885'/>
<seriesInfo name="DOI" value="10.17487/RFC7885"/>
</reference>

<!-- draft-ietf-bfd-generic-crypto-auth (Expired) -->
<reference anchor='BFD-GEN-AUTH'>
<front>
<title>BFD Generic Cryptographic Authentication</title>
<author initials='M' surname='Bhatia' fullname='Manav Bhatia'>
    <organization />
</author>
<author initials='V' surname='Manral' fullname='Vishwas Manral'>
    <organization />
</author>
<author initials='D' surname='Zhang' fullname='Dacheng Zhang'>
    <organization />
</author>
<author initials='M' surname='Jethanandani' fullname='Mahesh Jethanandani'>
    <organization />
</author>
<date month='April' year='2014' />
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-bfd-generic-crypto-auth-06' />
</reference>

    </references>

<section title="Loop Problem and Solution" anchor="loop">
<t>Consider a scenario where we have two nodes and both are S-BFD capable.</t>

<figure align="left"><preamble></preamble><artwork align="left"><![CDATA[
 Node A (IP 2001:db8::1) ----------------- Node B (IP 2001:db8::2)
                                 |
                                 |
                      Man in the Middle (MITM)
]]></artwork></figure>

<t>Assume that Node&nbsp;A reserved a discriminator 0x01010101 for
target identifier 2001:db8::1 and has a reflector session in
listening&nbsp;mode. Similarly, Node&nbsp;B reserved a
discriminator 0x02020202 for its target identifier 2001:db8::2 and
also has a reflector session in listening&nbsp;mode.</t>

<t>Suppose that a MITM sends a spoofed packet with
My&nbsp;Discriminator = 0x01010101, Your&nbsp;Discriminator = 0x02020202,
source IP as 2001:db8::1, and destination IP as 2001:db8::2. When this
packet reaches Node B, the reflector session on Node B will swap the
discriminators and IP addresses of the received packet and reflect it back,
since the Your&nbsp;Discriminator value of the received packet matches
the reserved discriminator of Node B. The reflected packet that reached
Node A will have My&nbsp;Discriminator = 0x02020202 and
Your&nbsp;Discriminator = 0x01010101. Since the Your&nbsp;Discriminator
value of the received packet matches the reserved discriminator of Node A,
Node A will swap the discriminators and reflect the packet back to Node B.
Since the reflectors must set the TTL of the reflected packets to 255, the
above scenario will result in an infinite loop because of just one malicious
packet injected from the MITM.</t>

<t>The solution is to avoid the loop problem by using the D&nbsp;bit
(Demand mode bit). The initiator always sets the D bit, and the
reflector always clears it. This way, we can determine if a received
packet was a reflected packet and avoid reflecting it back.</t>

    </section>

    <section title="Acknowledgements" numbered="no">

      <t>The authors would like to thank Jeffrey Haas, Greg Mirsky,
      Marc Binderberger, and Alvaro Retana for performing thorough reviews and
      providing a number of suggestions. The authors would also like to
      thank Girija Raghavendra Rao, Les Ginsberg, Srihari Raghavan, Vanitha
      Neelamegam, and Vengada Prasad Govindan from Cisco Systems for
      providing valuable comments. Finally, the authors would also like to
      thank John E.&nbsp;Drake and Pablo Frank for providing comments and
      suggestions.</t>

    </section>

    <section title="Contributors" numbered="no">

<t>The following are key contributors to this document:

<list style="empty">
<?rfc subcompact="yes" ?>
<t>Tarek Saad, Cisco Systems, Inc.
</t>
<t>Siva Sivabalan, Cisco Systems, Inc.
</t>
<t>Nagendra Kumar, Cisco Systems, Inc.
</t>
<t>Mallik Mudigonda, Cisco Systems, Inc.
</t>
<t>Sam Aldrin, Google
</t>
</list>
<?rfc subcompact="no" ?>
</t>
    </section>
  </back>
</rfc>
