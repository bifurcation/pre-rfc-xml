<?xml version='1.0' encoding="US-ASCII" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc rfcedstyle="yes"?>
<?rfc compact="yes"?>  
<?rfc subcompact="no"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>

<rfc number="6455" ipr="trust200902" category="std" submissionType="IETF" consensus="yes">

  <front>
    <title>The WebSocket Protocol</title>
    <author initials='I.F.' surname='Fette' fullname='Ian Fette'>
      <organization>Google, Inc.</organization>
      <address>
        <email>ifette+ietf@google.com</email>
        <uri>http://www.ianfette.com/</uri>
      </address>
    </author>
    <author initials="A." surname="Melnikov" fullname="Alexey Melnikov">
      <organization>Isode Ltd.</organization>
      <address>
	<postal>
	  <street>5 Castle Business Village</street>
	  <street>36 Station Road</street>
	  <city>Hampton</city>
	  <region>Middlesex</region>
	  <code>TW12 2BX</code>
	  <country>UK</country>
	</postal>
	<email>Alexey.Melnikov@isode.com</email>
      </address>
    </author>

    <date month="December" year="2011"/>
    <area>Applications</area>
    <workgroup>HyBi Working Group</workgroup>
    <keyword>HYBI</keyword>
    <keyword>websocket</keyword>

    <abstract>
      <t>The WebSocket Protocol enables two-way communication between a client
      running untrusted code in a controlled environment to a remote host
      that has opted-in to communications from that code. The security model used
      for this is the origin-based security model commonly used by web browsers.
      The protocol consists of an opening handshake followed by basic message framing,
      layered over TCP. The goal of this technology is to provide a mechanism for
      browser-based applications that need two-way communication with servers that
      does not rely on opening multiple HTTP connections (e.g., using XMLHttpRequest
      or &lt;iframe&gt;s and long polling).
      </t>

    </abstract>
  </front>
  <middle>


    <section title='Introduction'>
      <section title='Background'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>Historically, creating web applications that need bidirectional
	   communication between a client and a server (e.g., instant messaging
	   and gaming applications) has required an abuse of HTTP to
	   poll the server for updates while sending upstream
	   notifications as distinct HTTP calls <xref target="RFC6202" />.</t>
	  
        <t>This results in a variety of problems:
          <list style='symbols'>
            <t>The server is forced to use a number of different underlying TCP
connections for each client: one for sending information to the client and a
new one for each incoming message.</t>

            <t>The wire protocol has a high overhead, with each client-to-server message having an HTTP header.</t>
            <t>The client-side script is forced to maintain a mapping from the outgoing connections to the incoming connection to track replies.</t>
          </list>
        </t>
	  

        <t>
          A simpler solution would be to use a single TCP connection for
traffic in both directions. This is what the WebSocket Protocol
provides. Combined with the WebSocket API <xref target='WSAPI'/>, it provides an alternative to HTTP
polling for two-way communication from a web page to a remote server.

        </t>
        <t>The same technique can be used for a variety of web applications: games, stock tickers, multiuser applications with simultaneous editing, user interfaces exposing server-side services in real time, etc.</t>

<t>
   The WebSocket Protocol is designed to supersede existing
   bidirectional communication technologies that use HTTP as a
   transport layer to benefit from existing infrastructure
   (proxies, filtering, authentication).  Such technologies
   were implemented as trade-offs between efficiency and reliability
   because HTTP was not initially meant to be used for bidirectional
   communication (see <xref target="RFC6202"/> for further discussion).  The
   WebSocket Protocol attempts to address the goals of existing
   bidirectional HTTP technologies in the context of the existing
   HTTP infrastructure; as such, it is designed to work over HTTP
   ports 80 and 443 as well as to support HTTP proxies and
   intermediaries, even if this implies some complexity specific to
   the current environment.  However, the design does not limit
   WebSocket to HTTP, and future implementations could use a
   simpler handshake over a dedicated port without reinventing
   the entire protocol.  This last point is important because the
   traffic patterns of interactive messaging do not closely match
   standard HTTP traffic and can induce unusual loads on some
   components.
</t>

      </section>
      <section title='Protocol Overview'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>The protocol has two parts: a handshake and the data transfer.</t>
        <t>
          The handshake from the client looks as follows:</t>
        <figure>
          <artwork>
     GET /chat HTTP/1.1
     Host: server.example.com
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
     Origin: http://example.com
     Sec-WebSocket-Protocol: chat, superchat
     Sec-WebSocket-Version: 13
          </artwork>
        </figure>
        <t>The handshake from the server looks as follows:</t>
        <figure>
          <artwork>
     HTTP/1.1 101 Switching Protocols
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
     Sec-WebSocket-Protocol: chat
          </artwork>
        </figure>
        <t>The leading line from the client follows the Request-Line format. The leading line from the server follows the Status-Line format. The Request-Line and Status-Line productions are defined in <xref target='RFC2616'/>.
        </t>
        <t>
          An unordered set of header fields comes after the leading line in both cases. The meaning of these header fields is specified in <xref target='handshake' /> of this document. Additional header fields may also be present, such as cookies <xref target='RFC6265'/>. The format and parsing of headers is as defined in <xref target='RFC2616'/>.
        </t>

        <t>Once the client and server have both sent their handshakes, and if the handshake was successful, then the data transfer part starts. This is a two-way communication channel where each side can, independently from the other, send data at will.</t>


	<t>After a successful handshake, clients and servers transfer data back and forth
	in conceptual units referred to in this specification as &quot;messages&quot;.
	On the wire, a message is composed of one or more frames.
	The WebSocket message does not necessarily correspond to a particular network layer
	framing, as a fragmented message may be coalesced or split by an intermediary.</t>
	  
        <t>A frame has an associated type. Each frame belonging to the same message
	contains the same type of data. Broadly speaking, there are types for
	textual data (which is interpreted as UTF-8 <xref target='RFC3629'/> text),
	binary data (whose interpretation is left up to the application), and control frames
	(which are not intended to carry data for the application but instead for protocol-level
	signaling, such as to signal that the connection should be closed). This version of
	the protocol defines six frame types and leaves ten reserved for future use.</t>


	  
      </section>
      <section title='Opening Handshake'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>The opening handshake is intended to be compatible with HTTP-based server-side software and intermediaries, so that a single port can be used by both HTTP clients talking to that server and WebSocket clients talking to that server. To this end, the WebSocket client&apos;s handshake is an HTTP Upgrade
request:</t>
        <figure>
          <artwork>
     GET /chat HTTP/1.1
     Host: server.example.com
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
     Origin: http://example.com
     Sec-WebSocket-Protocol: chat, superchat
     Sec-WebSocket-Version: 13
          </artwork>
        </figure>
        <t>In compliance with <xref target='RFC2616'/>, header fields in the handshake may be sent by
	   the client in any order, so the order in which different header fields
	   are received is not significant.</t>
        <t>The &quot;Request-URI&quot; of the GET method <xref target='RFC2616'/> is used to
	identify the endpoint of the WebSocket connection, both to allow multiple domains to
	be served from one IP address and to allow multiple WebSocket endpoints to be served
	by a single server.</t>
	  
        <t>The client includes the hostname in the |Host| header field of its handshake
	as per <xref target='RFC2616'/>, so that both the client and the server can verify
	that they agree on which host is in use.</t>
	  
        <t>Additional header fields are used to select options in the WebSocket Protocol.
	Typical options available in this version are the subprotocol selector
	(|Sec-WebSocket-Protocol|), list of extensions support by the client
	(|Sec-WebSocket-Extensions|), |Origin| header field, etc.
	The |Sec-WebSocket-Protocol| request-header field can be used to indicate what
	subprotocols (application-level protocols layered over the WebSocket Protocol) are
	acceptable to the client. The server selects one or none of the acceptable protocols
	and echoes that value in its handshake to indicate that it has selected that protocol.</t>

        <figure>
          <artwork>
     Sec-WebSocket-Protocol: chat</artwork>
        </figure>
        <t>The |Origin| header field <xref target='RFC6454'/> is used to protect
        against unauthorized cross-origin use of a WebSocket server by scripts using
        the WebSocket API in a web browser. The server is informed of the script origin
        generating the WebSocket connection request. If the server does not wish to accept
        connections from this origin, it can choose to reject the connection by sending
        an appropriate HTTP error code. This header field is sent by browser clients;
        for non-browser clients, this header field may be sent if it makes sense in the context
        of those clients.</t>

        <t>Finally, the server has to prove to the client that it received the
client&apos;s WebSocket handshake, so that the server doesn&apos;t accept
connections that are not WebSocket connections. This prevents an attacker from
tricking a WebSocket server by sending it carefully crafted packets using
XMLHttpRequest <xref target="XMLHttpRequest"/> or a form submission.</t>

        <t>To prove that the handshake was received, the server has to take two pieces of information and combine them to form a response. The first piece of information comes from the |Sec-WebSocket-Key| header field in the client handshake:</t>
        <figure>
          <artwork>
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
          </artwork>
        </figure>
        <t>
          For this header field, the server has to take the value (as present
in the header field, e.g., the base64-encoded <xref target='RFC4648'/> version
minus any leading and trailing whitespace) and concatenate this with the
Globally Unique Identifier (GUID, <xref target='RFC4122'/>)
&quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; in string form, which is
unlikely to be used by network endpoints that do not understand the WebSocket
Protocol. A SHA-1 hash (160 bits) <xref target='FIPS.180-3' />, base64-encoded (see Section 4 of <xref
target='RFC4648'/>), of this concatenation is then returned in the
server&apos;s handshake.

        </t>
        <t>Concretely, if as in the example above, the |Sec-WebSocket-Key| header
field had the value &quot;dGhlIHNhbXBsZSBub25jZQ==&quot;, the server would
concatenate the string &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; to form
the string
&quot;dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;. The
server would then take the SHA-1 hash of this, giving the value 0xb3 0x7a 0x4f
0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4
0xea. This value is then base64-encoded (see Section 4 of <xref
target='RFC4648'/>), to give the value
&quot;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&quot;. This value would then be echoed in
the |Sec-WebSocket-Accept| header field.</t>
        <t>

        </t>
        <t>The handshake from the server is much simpler than the client handshake. The first line is an HTTP Status-Line, with the status code 101:</t>
        <figure>
          <artwork>
     HTTP/1.1 101 Switching Protocols</artwork>
        </figure>
        <t>Any status code other than 101 indicates that the WebSocket handshake
        has not completed and that the semantics of HTTP still apply. The
        headers follow the status code.</t>
          <t>The |Connection| and |Upgrade| header fields complete the HTTP Upgrade. The |Sec-WebSocket-Accept| header field indicates whether the server is willing to accept the connection. If present, this header field must include a hash of the client&apos;s nonce sent in |Sec-WebSocket-Key| along with a predefined GUID. Any other value must not be interpreted as an acceptance of the connection by the server.</t>
        <figure>
          <artwork>
     HTTP/1.1 101 Switching Protocols
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
          </artwork>
        </figure>
        <t>These fields are checked by the WebSocket client for scripted
pages. If the |Sec-WebSocket-Accept| value does not match the expected value,
if the header field is missing, or if the HTTP status code is not 101, the
connection will not be established, and WebSocket frames will not be sent.</t>

        <t>Option fields can also be included. In this version of the protocol,
the main option field is |Sec-WebSocket-Protocol|, which indicates the
subprotocol that the server has selected. WebSocket clients verify that the
server included one of the values that was specified in the WebSocket
client&apos;s handshake. A server that speaks multiple subprotocols has to make
sure it selects one based on the client&apos;s handshake and specifies it in
its handshake.</t>

        <figure>
          <artwork>
     Sec-WebSocket-Protocol: chat</artwork>
        </figure>
        <t>The server can also set cookie-related option fields to <spanx style='emph'>set</spanx> cookies, as described in <xref target='RFC6265'/>.
        </t>
      </section>
      <section title='Closing Handshake'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>The closing handshake is far simpler than the opening handshake.</t>
        <t>Either peer can send a control frame with data containing a
specified control sequence to begin the closing handshake (detailed in <xref
target='closeframe'/>). Upon receiving such a frame, the other peer sends a
Close frame in response, if it hasn&apos;t already sent one. Upon receiving
<spanx style='emph'>that</spanx> control frame, the first peer then closes the
connection, safe in the knowledge that no further data is forthcoming.</t>

        <t>After sending a control frame indicating the connection should be closed, a peer does not send any further data; after receiving a control frame indicating the connection should be closed, a peer discards any further data received.</t>
        <t>It is safe for both peers to initiate this handshake simultaneously.</t>
        <t>The closing handshake is intended to complement the TCP closing handshake (FIN/ACK), on the basis that the TCP closing handshake is not always reliable end-to-end, especially in the presence of intercepting proxies and other intermediaries.</t>
        <t>By sending a Close frame and waiting for a Close frame in response, certain cases are avoided where data may be unnecessarily lost. For instance, on some platforms, if a socket is closed with data in the receive queue, a RST packet is sent, which will then cause recv() to fail for the party that received the RST, even if there was data waiting to be read.</t>
      </section>
      <section title='Design Philosophy'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>The WebSocket Protocol is designed on the principle that there should be minimal framing (the only framing that exists is to make the protocol frame-based instead of stream-based and to support a distinction between Unicode text and binary frames). It is expected that metadata would be layered on top of WebSocket by the application layer, in the same way that metadata is layered on top of TCP by the application layer (e.g., HTTP).</t>
        <t>Conceptually, WebSocket is really just a layer on top of TCP that does the following:
	    <list style='symbols'>	
	
		<t>adds a web origin-based security model for browsers</t>


		<t>adds an addressing and protocol naming mechanism to support
		multiple services on one port and multiple host names on one IP
		address</t>
		
		<t>layers a framing mechanism on top of TCP to get back to the IP
		packet mechanism that TCP is built on, but without length limits</t>

		<t>includes an additional closing handshake in-band that is designed
		to work in the presence of proxies and other intermediaries</t>
		
	    </list>

	Other than that, WebSocket adds nothing.  Basically it is intended
	to be as close to just exposing raw TCP to script as possible given
	the constraints of the Web. It&apos;s also designed in such a way that
	its servers can share a port with HTTP servers, by having its
	handshake be a valid HTTP Upgrade request. One could
  conceptually use other protocols to establish client-server messaging,
  but the intent of WebSockets is to provide a relatively simple
  protocol that can coexist with HTTP and deployed HTTP infrastructure
  (such as proxies) and that is as close to TCP as is safe for use with
  such infrastructure given security considerations, with targeted
  additions to simplify usage and keep simple things simple (such
  as the addition of message semantics).</t>

        <t>The protocol is intended to be extensible; future versions will likely introduce additional concepts such as multiplexing.</t>
      </section>
      <section title='Security Model' anchor='secmodel'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>The WebSocket Protocol uses the origin model used by web browsers to
restrict which web pages can contact a WebSocket server when the WebSocket
Protocol is used from a web page. Naturally, when the WebSocket Protocol is
used by a dedicated client directly (i.e., not from a web page through a web
browser), the origin model is not useful, as the client can provide any
arbitrary origin string.</t>

        <t>This protocol is intended to fail to establish a connection with
servers of pre-existing protocols like SMTP <xref target='RFC5321'/> and HTTP,
while allowing HTTP servers to opt-in to supporting this protocol if
desired. This is achieved by having a strict and elaborate handshake and by
limiting the data that can be inserted into the connection before the handshake
is finished (thus limiting how much the server can be influenced).</t>

        <t>It is similarly intended to fail to establish a connection when data
from other protocols, especially HTTP, is sent to a WebSocket server, for
example, as might happen if an HTML "form" were submitted to a WebSocket
server. This is primarily achieved by requiring that the server prove that it
read the handshake, which it can only do if the handshake contains the
appropriate parts, which can only be sent by a WebSocket
client. In particular, at the time of writing of this specification, fields
starting with |Sec-| cannot be set by an attacker from a web browser using only
HTML and JavaScript APIs such as XMLHttpRequest <xref
target="XMLHttpRequest"/>.</t>

      </section>
      <section title='Relationship to TCP and HTTP'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>The WebSocket Protocol is an independent TCP-based protocol. Its only relationship to HTTP is that its handshake is interpreted by HTTP servers as an Upgrade request.</t>
        <t>By default, the WebSocket Protocol uses port 80 for regular
WebSocket connections and port 443 for WebSocket connections tunneled over
Transport Layer Security (TLS) <xref target='RFC2818'/>.</t>
      </section>
      <section title='Establishing a Connection'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>
        When a connection is to be made to a port that is shared by an HTTP
        server (a situation that is quite likely to occur with traffic to
        ports 80 and 443), the connection will appear to the HTTP server to
        be a regular GET request with an Upgrade offer.  In relatively simple
        setups with just one IP address and a single server for all traffic
        to a single hostname, this might allow a practical way for systems
        based on the WebSocket Protocol to be deployed.  In more elaborate
        setups (e.g., with load balancers and multiple servers), a dedicated
        set of hosts for WebSocket connections separate from the HTTP servers
        is probably easier to manage. At the time of writing of this
        specification, it should be noted that connections on ports 80 and 443
        have significantly different success rates, with connections on
        port 443 being significantly more likely to succeed, though this may
        change with time.
        </t>
      </section>
      <section title='Subprotocols Using the WebSocket Protocol'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>The client can request that the server use a specific subprotocol by including the |Sec-WebSocket-Protocol| field in its handshake. If it is specified, the server needs to include the same field and one of the selected subprotocol values in its response for the connection to be established.</t>
        <t>These subprotocol names should be registered as per <xref target='spr'/>. To avoid potential collisions, it is recommended to use names that contain the ASCII version of the domain name of the subprotocol&apos;s originator. For example, if Example Corporation were to create a Chat subprotocol to be implemented by many servers around the Web, they could name it &quot;chat.example.com&quot;. If the Example Organization called their competing subprotocol &quot;chat.example.org&quot;, then the two subprotocols could be implemented by servers simultaneously, with the server dynamically selecting which subprotocol to use based on the value sent by the client.</t>
        <t>Subprotocols can be versioned in backward-incompatible ways by
changing the subprotocol name, e.g., going from
&quot;bookings.example.net&quot; to &quot;v2.bookings.example.net&quot;. These
subprotocols would be considered completely separate by WebSocket
clients. Backward-compatible versioning can be implemented by reusing the same
subprotocol string but carefully designing the actual subprotocol to support
this kind of extensibility.</t>

      </section>
    </section>
    <section title='Conformance Requirements'>
      <t>All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.</t>
      <t>
        The key words &quot;MUST&quot;, &quot;MUST NOT&quot;,
&quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be
interpreted as described in <xref target='RFC2119'/>.

      </t>
      <t>Requirements phrased in the imperative as part of algorithms (such as
&quot;strip any leading space characters&quot; or &quot;return false and abort
these steps&quot;) are to be interpreted with the meaning of the key word
(&quot;MUST&quot;, &quot;SHOULD&quot;, &quot;MAY&quot;, etc.) used in
introducing the algorithm.</t>

      <t>Conformance requirements phrased as algorithms or specific steps MAY
be implemented in any manner, so long as the end result is equivalent. (In
particular, the algorithms defined in this specification are intended to be
easy to follow and not intended to be performant.)</t>


      <section title='Terminology and Other Conventions'>
        <t>
          <spanx style='emph'>ASCII</spanx> shall mean the character-encoding scheme defined in  <xref target='ANSI.X3-4.1986'/>.
        </t>
        <t>This document makes reference to UTF-8 values and uses UTF-8
          notational formats as defined in STD 63 <xref target='RFC3629'/>.
        </t>
        <t>Key terms such as named algorithms or
          definitions are indicated like <spanx style='emph'>this</spanx>.
        </t>
        <t>Names of header fields or variables are indicated like |this|.
        </t>
        <t>Variable values are indicated like /this/.
        </t>
        <t>This document references the procedure to
        <spanx style='emph'>Fail the WebSocket Connection</spanx>. This procedure is
        defined in <xref target='fail_ws'/>.
        </t>
        <t>
          <spanx style='emph'>Converting a string to ASCII lowercase</spanx>
means replacing all characters in the range U+0041 to U+005A (i.e., LATIN
CAPITAL LETTER A to LATIN CAPITAL LETTER Z) with the corresponding characters
in the range U+0061 to U+007A (i.e., LATIN SMALL LETTER A to LATIN SMALL LETTER
Z).

        </t>
        <t>
          Comparing two strings in an <spanx style='emph'>ASCII
case-insensitive</spanx> manner means comparing them exactly, code point for
code point, except that the characters in the range U+0041 to U+005A (i.e.,
LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) and the corresponding
characters in the range U+0061 to U+007A (i.e., LATIN SMALL LETTER A to LATIN
SMALL LETTER Z) are considered to also match.

        </t>
        <t>
          The term &quot;URI&quot; is used in this document as defined in <xref target='RFC3986'/>.
        </t>
        <t>
          When an implementation is required to <spanx style='emph'>send</spanx> data as part of the WebSocket Protocol, the implementation MAY delay the actual transmission arbitrarily, e.g., buffering data so as to send fewer IP packets.
        </t>

	<t>Note that this document uses both <xref target='RFC5234'/> and
	<xref target='RFC2616'/> variants of ABNF in different sections.</t>

      </section>
    </section>
    <section title='WebSocket URIs' anchor='ws_uris'>
      <t>This specification defines two URI schemes, using the ABNF syntax
        defined in RFC 5234 <xref target='RFC5234'/>, and terminology and ABNF
        productions defined by the URI specification RFC 3986 <xref
          target='RFC3986'/>.
      </t>
      <t>
        <figure height="" suppress-title="false" width="" alt="" title="" align="left">
        <artwork type="abnf" height="" name="" width="" alt="" align="left" xml:space="preserve"><![CDATA[
       ws-URI = "ws:" "//" host [ ":" port ] path [ "?" query ]
       wss-URI = "wss:" "//" host [ ":" port ] path [ "?" query ]

       host = <host, defined in [RFC3986], Section 3.2.2>
       port = <port, defined in [RFC3986], Section 3.2.3>
       path = <path-abempty, defined in [RFC3986], Section 3.3>
       query = <query, defined in [RFC3986], Section 3.4>
]]></artwork></figure>
      </t>
      <t>
        The port component is OPTIONAL; the default for &quot;ws&quot; is port
        80, while the default for &quot;wss&quot; is port 443.
      </t>
      <t>
        The URI is called &quot;secure&quot; (and it is said that &quot;the secure flag is
	set&quot;) if the scheme component matches &quot;wss&quot; case-insensitively.
      </t>
      <t>
        The &quot;resource-name&quot; (also known as /resource name/ in <xref target='clienths'/>)
	can be constructed by concatenating the following:
        <list style="symbols">
          <t>
            &quot;/&quot; if the path component is empty
          </t>
          <t>
            the path component
          </t>
          <t>
            &quot;?&quot; if the query component is non-empty
          </t>
          <t>
            the query component
          </t>
        </list>
      </t>
      <t>
        Fragment identifiers are meaningless in the context of WebSocket URIs
        and MUST NOT be used on these URIs. 
As with any URI scheme,
the character "#", when not indicating the start of a fragment,
MUST be escaped as %23.
      </t>
    </section>
      
    <section title='Opening Handshake' anchor='handshake'>
      <section title='Client Requirements' anchor='clienths'>
        <t>To <spanx style='emph'>Establish a WebSocket Connection</spanx>, a
        client opens a connection and sends a handshake as defined in this
        section. A connection is defined to initially be in a CONNECTING state.
        A client will need to supply a /host/, /port/, /resource name/,
        and a /secure/ flag, which are the components of a WebSocket URI as
        discussed in <xref target='ws_uris'/>, along with a list of /protocols/
        and /extensions/ to be used. Additionally, if the client is a web
        browser, it supplies /origin/.
        </t>
        <t>Clients running in controlled environments, e.g., browsers on
        mobile handsets tied to specific carriers, MAY offload the management
        of the connection to another agent on the network. In such a
        situation, the client for the purposes of this specification is
        considered to include both the handset software and any such
        agents.</t>

        <t>When the client is to <spanx style='emph'>Establish a
        WebSocket Connection</spanx> given a set
        of (/host/, /port/, /resource name/, and /secure/ flag), along with a
        list of /protocols/ and /extensions/ to be used, and an /origin/ in the
        case of web browsers,
        it MUST open a connection, send an opening handshake, and read the
        server&apos;s handshake in response. The exact requirements of how the
        connection should be opened, what should be sent in the opening
        handshake, and how the server&apos;s response should be interpreted are
        as follows in this section.
        In the following text, we will use terms
        from <xref target='ws_uris'/>, such as &quot;/host/&quot; and
        &quot;/secure/ flag&quot; as defined in that section.
        <list style='numbers'>
          <t>The components of the WebSocket URI passed into this algorithm
            (/host/, /port/, /resource name/, and /secure/ flag) MUST be valid
            according to the specification of WebSocket URIs specified in <xref
              target='ws_uris'/>. If any of the components are invalid, the
            client MUST <spanx style='emph'>Fail the WebSocket
              Connection</spanx> and abort these steps.
          </t>

          <t>If the client already has a WebSocket connection to the
          remote host (IP address) identified by /host/ and port /port/ pair,
          even if the remote host is known by another name, the client MUST
          wait until that connection has
          been established or for that connection to have failed. There MUST be
          no more than one connection in a CONNECTING state. If
          multiple connections to the same IP address are attempted
          simultaneously, the client MUST serialize them so that there is
          no more than one connection at a time running through the following
          steps.
          <vspace blankLines='1'/>
          If the client cannot determine the IP address of the remote host
          (for example, because all communication is being done through a proxy
          server that performs DNS queries itself), then the client MUST
          assume for the purposes of this step that each host name refers to a
          distinct remote host, and instead the client SHOULD limit the total number of
          simultaneous pending connections to a reasonably
          low number (e.g., the client might allow simultaneous pending connections
          to a.example.com and b.example.com, but if thirty simultaneous connections
	  to a single host are requested, that may not be allowed).
	  For example, in a web browser context, the client needs to consider the number of tabs the user
	  has open in setting a limit to the number of simultaneous pending connections.
          <vspace blankLines='1'/>
          NOTE: This makes it harder for a script to perform a denial-of-service attack by just opening a large number of WebSocket
          connections to a remote host. A server can further reduce the load
          on itself when attacked by pausing before
          closing the connection, as that will reduce the rate at which the
          client reconnects.
          <vspace blankLines='1'/>
          NOTE: There is no limit to the number of established WebSocket
          connections a client can have with a single remote host.
          Servers can refuse to accept connections from hosts/IP addresses with an
          excessive number of existing connections or disconnect
          resource-hogging connections when suffering high load.</t>

          <t><spanx style='emph'>Proxy Usage</spanx>: If the client is
          configured to use a proxy when using the WebSocket Protocol to
          connect to host /host/ and port /port/, then the client
          SHOULD connect to that proxy and ask it to open a TCP connection to
          the host given by /host/ and the port given by /port/.
          <list style='empty'>
            <t>EXAMPLE: For example, if the client uses an HTTP proxy for
            all traffic, then if it was to try to connect to port 80 on server
            example.com, it might send the following lines to the proxy
            server:

            <figure>
              <artwork>
           CONNECT example.com:80 HTTP/1.1
           Host: example.com
              </artwork>
            </figure>
            </t>

            <t>If there was a password, the connection might look like:

            <figure>
              <artwork>
           CONNECT example.com:80 HTTP/1.1
           Host: example.com
           Proxy-authorization: Basic ZWRuYW1vZGU6bm9jYXBlcyE=
              </artwork>
            </figure>
            </t>
          </list>
          If the client is not configured to use a proxy, then a
          direct TCP connection SHOULD be opened to the host given by
          /host/ and the port given by /port/.
          <vspace blankLines='1'/>
          NOTE: Implementations that do not expose explicit UI for selecting a
          proxy for WebSocket connections separate from other proxies are
          encouraged to use a SOCKS5 <xref target='RFC1928'/> proxy for WebSocket connections, if
          available, or failing that, to prefer the proxy configured for HTTPS
          connections over the proxy configured for HTTP connections.
          <vspace blankLines='1'/>
          For the purpose of proxy autoconfiguration scripts, the URI to pass
          the function MUST be constructed from /host/, /port/, /resource
          name/, and the /secure/ flag using the definition of a
          WebSocket URI as given in <xref target="ws_uris" />.
          <vspace blankLines='1'/>
          NOTE: The WebSocket Protocol can be identified in proxy
          autoconfiguration scripts from the scheme (&quot;ws&quot; for
          unencrypted connections and &quot;wss&quot; for encrypted
          connections).</t>

          <t>If the connection could not be opened, either because a direct
          connection failed or because any proxy used returned an error, then
          the client MUST <spanx style='emph'>Fail the WebSocket
            Connection</spanx> and abort the connection attempt.</t>

          <t> If /secure/ is true, the client MUST perform a TLS handshake
            over the connection after opening the connection and before
            sending the handshake data
            <xref target='RFC2818'/>. If this fails (e.g., the server&apos;s
            certificate could not be verified), then the client MUST <spanx
              style='emph'>Fail the WebSocket Connection</spanx>
            and abort the connection. Otherwise, all
          further communication on this channel MUST run through the encrypted
          tunnel <xref target='RFC5246'/>.
          <vspace blankLines='1'/>
          Clients MUST use the Server Name Indication extension in the TLS
          handshake <xref target='RFC6066'/>.
        </t>
        </list>
        </t>

        <t anchor='clientopenhs'>Once a connection to the server has been
          established (including a
        connection via a proxy or over a TLS-encrypted tunnel), the client
        MUST send an opening handshake to the server. The handshake consists of
        an HTTP Upgrade request, along with a list of required and optional
        header fields. The requirements for this handshake are as follows.
        <list style='numbers'>
          <t>The handshake MUST be a valid HTTP request as specified by <xref
          target='RFC2616'/>.</t>

          <t>The method of the request MUST be GET, and the HTTP version MUST be
          at least 1.1.
          <vspace blankLines='1' />
          For example, if the WebSocket URI is
          &quot;ws://example.com/chat&quot;, the first line sent should be
          &quot;GET /chat HTTP/1.1&quot;.</t>

          <t>The &quot;Request-URI&quot; part of the request MUST match the
/resource name/ defined in
          <xref target='ws_uris'/> (a relative URI) or be an absolute http/https URI that,
          when parsed, has a /resource name/, /host/, and /port/ that match the corresponding
          ws/wss URI.</t>

          <t>
The request MUST contain a |Host| header field whose value contains
/host/ plus optionally ":" followed by /port/ (when not using the
default port).
</t>

          <t>
The request MUST contain an |Upgrade| header field whose value
MUST include the "websocket" keyword.
</t>

          <t>
The request MUST contain a |Connection| header field
whose value MUST include the "Upgrade" token.
</t>

          <t>The request MUST include a header field with the name
          |Sec-WebSocket-Key|. The value of this header field MUST be a
          nonce consisting of a randomly selected 16-byte value that has been
          base64-encoded (see Section 4 of <xref target='RFC4648'/>). The nonce MUST be
          selected randomly for each connection. <vspace blankLines='1'/>
          NOTE: As an example, if the randomly selected value was the sequence
          of bytes 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c
          0x0d 0x0e 0x0f 0x10, the value of the header field would be
          &quot;AQIDBAUGBwgJCgsMDQ4PEC==&quot;</t>

          <t>The request MUST include a header field with the name
          |Origin| <xref target='RFC6454'/> if the request is coming from a
          browser client. If the connection is from a non-browser client, the
          request MAY include this header field if the semantics of that client match
          the use-case described here for browser clients.
          The value of this header field is
          the ASCII serialization of origin of the context in which the code
          establishing the connection is running. See <xref target='RFC6454'/>
          for the details of how this header field value is constructed.
          <vspace blankLines='1'/>
          As an example, if code downloaded from www.example.com attempts to
          establish a connection to ww2.example.com, the value of the header field
          would be &quot;http://www.example.com&quot;.</t>


          <t>The request MUST include a header field with the name
          |Sec-WebSocket-Version|. The value of this header field MUST be 13.

<vspace blankLines='1'/>
NOTE: Although draft versions of this document (-09, -10, -11, and -12) were posted (they
            were mostly comprised of editorial changes and clarifications and not changes
	    to the wire protocol), values 9, 10, 11, and 12 were not used as valid values for
            Sec-WebSocket-Version. These values were reserved in the IANA registry
            but were not and will not be used.
          </t>

          <t anchor="swp-defined">The request MAY include a header field with the name
          |Sec-WebSocket-Protocol|. If present, this value indicates
          one or more comma-separated subprotocol the client wishes to speak, ordered by preference.
          The elements that
          comprise this value MUST be non-empty strings with characters in
          the range U+0021 to U+007E not including separator characters as
          defined in <xref target='RFC2616'/> and MUST all be unique strings.
          The ABNF for the value of this header field is 1#token, where the
          definitions of constructs and rules are as given in <xref target='RFC2616'/>.</t>

          <t>The request MAY include a header field with the name
          |Sec-WebSocket-Extensions|. If present, this value
          indicates the protocol-level extension(s) the client wishes to
          speak. The interpretation and format of
          this header field is described in <xref target="negotiation" />.</t>

          <t> The request MAY include any other header fields, for example, cookies
          <xref target='RFC6265'/> and/or authentication-related header fields
	  such as the |Authorization| header field <xref target='RFC2616'/>, which are
	  processed according to documents that define them.
          </t>
        </list>
        </t>

        <t>Once the client&apos;s opening handshake has been sent, the client MUST
        wait for a response from the server before sending any further data.
        The client MUST validate the server&apos;s response as follows:
        <list style='numbers'>
          <t>If the status code received from the server is not 101, the
          client handles the response per HTTP <xref target='RFC2616'/> procedures.
	  In particular, the client might perform authentication if it receives a
	  401 status code; the server might redirect the client using a 3xx status code
	  (but clients are not required to follow them), etc.
	  Otherwise, proceed as follows.</t>

          <t>If the response lacks an |Upgrade| header field or the
          |Upgrade| header field contains a value that is not an ASCII
          case-insensitive match for the value &quot;websocket&quot;, the
          client MUST <spanx style='emph'>Fail the WebSocket Connection</spanx>.</t>

          <t>If the response lacks a |Connection| header field or the
          |Connection| header field doesn't contain a token that is an ASCII
          case-insensitive match for the value &quot;Upgrade&quot;, the client
          MUST <spanx style='emph'>Fail the WebSocket Connection</spanx>.</t>

          <t>If the response lacks a |Sec-WebSocket-Accept| header field or
          the |Sec-WebSocket-Accept| contains a value other than the
          base64-encoded SHA-1 of the concatenation of the
          |Sec-WebSocket-Key| (as a string, not base64-decoded) with
          the string &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; but ignoring
	  any leading and trailing whitespace, the
          client MUST <spanx style='emph'>Fail the WebSocket Connection</spanx>.
          </t>

          <t>If the response includes a |Sec-WebSocket-Extensions|
            header field and this header field indicates the use of an extension that was
            not present in the client&apos;s handshake (the server has indicated
            an extension not requested by the client), the client MUST <spanx
              style='emph'>Fail the WebSocket Connection</spanx>.
           (The parsing of this header field to determine which
            extensions are requested is discussed in <xref
              target='negotiation'/>.)</t>
	    
          <t>If the response includes a |Sec-WebSocket-Protocol|
            header field and this header field indicates the use of a subprotocol that was
            not present in the client&apos;s handshake (the server has indicated
            a subprotocol not requested by the client), the client MUST <spanx
              style='emph'>Fail the WebSocket Connection</spanx>.</t>
        </list>
        </t>

        <t>If the server&apos;s response does not conform to the requirements
          for the server&apos;s handshake as defined in this section and in
          <xref target='server_handshake'/>, the client MUST <spanx
            style='emph'>Fail the WebSocket Connection</spanx>.
        </t>

        <t>Please note that according to <xref target='RFC2616'/>, all header field
	names in both HTTP requests and HTTP responses are case-insensitive.</t>

        <t> If the server&apos;s response is validated as provided for above, it
        is said that <spanx style='emph'>The WebSocket Connection is
          Established</spanx> and that the WebSocket Connection is in the OPEN
        state. The <spanx style='emph'>Extensions In Use</spanx>
        is defined to be a (possibly empty) string, the value of
        which is equal to the value of the |Sec-WebSocket-Extensions| header field
        supplied by the server&apos;s handshake or the null value if that
        header field was not present in the server&apos;s handshake. The <spanx
          style='emph'>Subprotocol In Use</spanx> is defined to be the value of
        the |Sec-WebSocket-Protocol| header field in the server&apos;s handshake or
        the null value if that header field was not present in the server&apos;s
        handshake. Additionally, if any header fields in the server&apos;s handshake
        indicate that cookies should be set (as defined by <xref
          target='RFC6265'/>),

        these cookies are referred to
        as <spanx style='emph'>Cookies Set During the Server&apos;s Opening
          Handshake</spanx>.
        </t>
      </section>
      <section title='Server-Side Requirements'>

        <t>Servers MAY offload the management of the connection to other
        agents on the network, for example, load balancers and reverse proxies.
        In such a situation, the server for the purposes of this specification is
        considered to include all parts of the server-side infrastructure from
        the first device to terminate the TCP connection all the way to the
        server that processes requests and sends responses.</t>

        <t>EXAMPLE: A data center might have a server that
        responds to WebSocket requests with an appropriate handshake and
        then passes the connection to another server to actually process the
        data frames. For the purposes of this specification, the "server" is
        the combination of both computers.</t>

        <section title='Reading the Client&apos;s Opening Handshake'>
          <t>When a client starts a WebSocket connection, it sends its part of
          the opening handshake. The server must parse at least part of this
          handshake in order to obtain the necessary information to generate
          the server part of the handshake.</t>

          <t>The client&apos;s opening handshake consists of the following
          parts. If the server, while reading the handshake, finds that the
          client did not send a handshake that matches the description below
	  (note that as per <xref target='RFC2616'/>, the order of the header
	  fields is not important),
          including but not limited to any violations of the ABNF grammar
          specified for the components of the handshake,
          the server MUST stop processing the client&apos;s handshake and
          return an HTTP response with an appropriate error code (such as 400
          Bad Request).
          <list style='numbers'>
            <t>An HTTP/1.1 or higher GET request, including a
            &quot;Request-URI&quot; <xref target='RFC2616'/> that should be
            interpreted as a /resource name/ defined in <xref target='ws_uris'/>
            (or an absolute HTTP/HTTPS URI containing the /resource name/). </t>

            <t>A |Host| header field containing the server's
            authority.</t>

	    <t>An |Upgrade| header field containing the value &quot;websocket&quot;,
	    treated as an ASCII case-insensitive value.</t>

	    <t>A |Connection| header field that includes the token &quot;Upgrade&quot;,
	    treated as an ASCII case-insensitive value.</t>
	      
            <t>A |Sec-WebSocket-Key| header field with a base64-encoded
            (see Section 4 of <xref target='RFC4648'/>) value that, when decoded, is 16 bytes in length.</t>

            <t>A |Sec-WebSocket-Version| header field, with a value of 13.</t>

            <t>Optionally, an |Origin| header field. This
            header field is sent by all browser clients. A connection attempt
            lacking this header field SHOULD NOT be interpreted as coming from
            a browser client.</t>

            <t>Optionally, a |Sec-WebSocket-Protocol| header field, with a
            list of values indicating which protocols the client would like to
            speak, ordered by preference.</t>

            <t>Optionally, a |Sec-WebSocket-Extensions| header field, with
            a list of values indicating which extensions the client would like
            to speak. The interpretation of this header field is discussed in
            <xref target="negotiation" />.</t>

            <t>Optionally, other header fields, such as those used to send cookies
	    or request authentication to a server. Unknown header fields are ignored,
	    as per <xref target="RFC2616"/>.</t>
          </list>
          </t>
        </section>
        <section title='Sending the Server&apos;s Opening Handshake'
            anchor='server_handshake'>
          <t>When a client establishes a WebSocket connection to a server, the
          server MUST complete the following steps to accept the connection
          and send the server&apos;s opening handshake.
          <list style='numbers'>
            <t>If the connection is happening on an HTTPS (HTTP-over-TLS) port,
	    perform a TLS handshake
            over the connection. If this fails (e.g., the client indicated a
            host name in the extended client hello &quot;server_name&quot;
            extension that the server does not host), then close the
            connection; otherwise, all further communication for the
            connection (including the server&apos;s handshake) MUST run through
            the encrypted tunnel <xref target='RFC5246'/>.</t>

            <t>The server can perform additional client authentication,
	    for example, by returning a 401 status code with the corresponding
	    |WWW-Authenticate| header field as described in <xref target='RFC2616'/>.</t>

            <t>The server MAY redirect the client using a 3xx status code
	    <xref target='RFC2616'/>. Note that this step can happen together
	    with, before, or after the optional authentication step described above.</t>

            <t anchor='server_handshake_info'>Establish the following information:
            <list style='hanging'>
              <t hangText='/origin/'><vspace blankLines='0'/>
              The |Origin| header field in the client&apos;s handshake
              indicates the origin of the script establishing the connection.
              The origin is serialized to ASCII and converted to lowercase.
              The server MAY use this information as part of a determination
              of whether to accept the incoming connection. If the server does
              not validate the origin, it will accept connections from anywhere.
              If the server does not wish to accept this connection, it MUST
              return an appropriate HTTP error code (e.g., 403 Forbidden) and
              abort the WebSocket handshake described in this section.
              For more detail, refer to <xref
              target="securityconsiderations" />.</t>

              <t hangText='/key/'><vspace blankLines='0'/>
              The |Sec-WebSocket-Key| header field in the client&apos;s handshake
              includes a base64-encoded value that, if decoded, is 16 bytes in
              length. This (encoded) value is used in the creation of the
              server&apos;s handshake to indicate an acceptance of the
              connection. It is not necessary for the server to base64-decode
              the |Sec-WebSocket-Key| value.</t>

              <t hangText='/version/'><vspace blankLines='0'/>
              The |Sec-WebSocket-Version| header field in the client&apos;s handshake
              includes the version of the WebSocket Protocol with which the client is
              attempting to communicate. If this version does not match
              a version understood by the server, the server MUST abort the
              WebSocket handshake described in this section and instead send an
              appropriate HTTP error code (such as 426 Upgrade Required) and a
              |Sec-WebSocket-Version| header field indicating the
              version(s) the server is capable of understanding.
              </t>

              <t hangText='/resource name/'><vspace blankLines='0'/>
              An identifier for the service provided by the server. If the
              server provides multiple services, then the value should be
              derived from the resource name given in the client&apos;s
              handshake in the "Request-URI" <xref target='RFC2616'/>
              of the GET method. If the requested service is not available, the
            server MUST send an appropriate HTTP error code (such as 404 Not
            Found) and abort the WebSocket handshake.</t>

              <t hangText='/subprotocol/'><vspace blankLines='0'/>
              Either a single value representing the subprotocol the
              server is ready to use or null. The value chosen MUST be derived from the
              client&apos;s handshake, specifically by selecting one of the
              values from the |Sec-WebSocket-Protocol| field that the
              server is willing to use for this connection (if any). If the
              client&apos;s handshake did not contain such a header field or if the
              server does not agree to any of the client&apos;s requested
              subprotocols, the only acceptable value is null.  The
              absence of such a field is equivalent to the null value (meaning
              that if the server does not wish to agree to one of the suggested
              subprotocols, it MUST NOT send back a |Sec-WebSocket-Protocol|
              header field in its response). The empty
              string is not the same as the null value for these purposes and
              is not a legal value for this field. The ABNF for the
              value of this header field is (token), where the
              definitions of constructs and rules are as given in <xref
              target='RFC2616' />.</t>

              <t hangText='/extensions/'><vspace blankLines='0'/>
              A (possibly empty) list representing the protocol-level
              extensions the server is ready to use. If the server supports
              multiple extensions, then the value MUST be derived from the
              client&apos;s handshake, specifically by selecting one or more of
              the
              values from the |Sec-WebSocket-Extensions| field. The
              absence of such a field is equivalent to the null value. The
              empty string is not the same as the null value for these
              purposes. Extensions not listed by the client MUST NOT be listed.
              The method by which these values should be selected and
              interpreted is discussed in <xref target="negotiation" />.</t>
            </list>
            </t>

            <t>If the server chooses to accept the incoming connection, it
            MUST reply with a valid HTTP response indicating the following.
            <list style='numbers'>
              <t>A Status-Line with a 101 response code as per RFC 2616
                <xref target='RFC2616'/>. Such a response could look like
              &quot;HTTP/1.1 101 Switching Protocols&quot;.</t>

              <t>An |Upgrade| header field with value
                &quot;websocket&quot; as per RFC 2616 <xref target='RFC2616'/>.
              </t>

              <t>A |Connection| header field with value
                &quot;Upgrade&quot;.</t>

              <t>A |Sec-WebSocket-Accept| header field. The value of this
              header field is constructed by concatenating /key/, defined above
              in step 4 in
              <xref target='server_handshake' />, with the string
              &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;, taking the
              SHA-1 hash of this concatenated value to obtain a 20-byte value
              and base64-encoding (see Section 4 of <xref target='RFC4648'/>) this 20-byte hash.
              <vspace blankLines='1'/>The ABNF <xref target='RFC2616'/> of this header field is defined as
              follows:
              <figure>
                <artwork>
        Sec-WebSocket-Accept     = base64-value-non-empty
        base64-value-non-empty = (1*base64-data [ base64-padding ]) |
                                 base64-padding
        base64-data      = 4base64-character
        base64-padding   = (2base64-character "==") |
                           (3base64-character "=")
        base64-character = ALPHA | DIGIT | "+" | "/"
                </artwork>
              </figure>

              NOTE: As an example, if the value of the
              |Sec-WebSocket-Key| header field in the client's handshake
              were &quot;dGhlIHNhbXBsZSBub25jZQ==&quot;, the server would
              append the string
              &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; to form the
              string
    &quot;dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;.
              The server would then take the SHA-1 hash of this string, giving
              the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46
              0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea. This value is then
              base64-encoded, to give the value
              &quot;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&quot;, which would be
              returned in the |Sec-WebSocket-Accept| header field.</t>

              <t>Optionally, a |Sec-WebSocket-Protocol| header field,
              with a value /subprotocol/ as defined in
              step 4 in
              <xref target='server_handshake' />.</t>

              <t>Optionally, a |Sec-WebSocket-Extensions| header field,
              with a value /extensions/ as defined in
              step 4
              in <xref target='server_handshake' />. If multiple extensions are
              to be used, they can all be listed in a single
              |Sec-WebSocket-Extensions| header field or split between multiple instances
	      of the |Sec-WebSocket-Extensions| header field.
              </t>
            </list>
            </t>
          </list>
          </t>

          <t>This completes the server&apos;s handshake. If the server
          finishes these steps without aborting the WebSocket handshake,
          the server considers the WebSocket connection to be established and
          that the WebSocket connection is in the OPEN state. At this point, the
          server may begin sending (and receiving) data.

          </t>
        </section>
      </section>

      <section title='Collected ABNF for New Header Fields Used in Handshake'>

        <t>This section is using ABNF syntax/rules from Section 2.1 of
	  <xref target="RFC2616"/>, including the "implied *LWS rule".
        </t>

	<t>Note that the following ABNF conventions are used in this section.
	Some names of the rules correspond to names of the corresponding header fields.
	Such rules express values of the corresponding header fields, for example,
	the Sec-WebSocket-Key ABNF rule describes syntax of the |Sec-WebSocket-Key|
	header field value.

	ABNF rules with the "-Client" suffix in the name are only used in requests sent
	by the client to the server; ABNF rules with the "-Server" suffix in the name
	are only used in responses sent by the server to the client. For example,
	the ABNF rule Sec-WebSocket-Protocol-Client describes syntax of the
	|Sec-WebSocket-Protocol| header field value sent by the client to the server.
	</t>

        <t>The following new header fields can be sent during the handshake from the client
        to the server:</t>

        <figure>
          <artwork>
   Sec-WebSocket-Key = base64-value-non-empty
   Sec-WebSocket-Extensions = extension-list
   Sec-WebSocket-Protocol-Client = 1#token
   Sec-WebSocket-Version-Client = version

   base64-value-non-empty = (1*base64-data [ base64-padding ]) |
                             base64-padding
   base64-data      = 4base64-character
   base64-padding   = (2base64-character "==") |
                      (3base64-character "=")
   base64-character = ALPHA | DIGIT | "+" | "/"
   extension-list = 1#extension
   extension = extension-token *( ";" extension-param )
   extension-token = registered-token
   registered-token = token
   extension-param = token [ "=" (token | quoted-string) ]
        ; When using the quoted-string syntax variant, the value
        ; after quoted-string unescaping MUST conform to the 
        ; 'token' ABNF.
   NZDIGIT       =  "1" | "2" | "3" | "4" | "5" | "6" |
                    "7" | "8" | "9"
   version = DIGIT | (NZDIGIT DIGIT) |
             ("1" DIGIT DIGIT) | ("2" DIGIT DIGIT)
             ; Limited to 0-255 range, with no leading zeros
          </artwork>
        </figure>

          <t>
        The following new header fields can be sent during the handshake from the server
        to the client:
        </t>

          <figure>
            <artwork>
   Sec-WebSocket-Extensions = extension-list
   Sec-WebSocket-Accept     = base64-value-non-empty
   Sec-WebSocket-Protocol-Server = token
   Sec-WebSocket-Version-Server = 1#version
            </artwork>
          </figure>

      </section>

      <section title='Supporting Multiple Versions of WebSocket Protocol'>

        <t>This section provides some guidance on supporting multiple versions
	of the WebSocket Protocol in clients and servers.</t>

        <t>Using the WebSocket version advertisement capability
	(the |Sec-WebSocket-Version| header field), a client can initially request
	the version of the WebSocket Protocol that it prefers (which doesn't
	necessarily have to be the latest supported by the client).
	If the server supports the requested version and the handshake message
	is otherwise valid, the server will accept that version.
	If the server doesn't support the requested version, it MUST respond
	with a |Sec-WebSocket-Version| header field (or multiple |Sec-WebSocket-Version|
	header fields) containing all versions it is willing to use.
	At this point, if the client supports one of the advertised versions,
	it can repeat the WebSocket handshake using a new version value.</t>

        <t>The following example demonstrates version negotiation described above:</t>

        <figure>
          <artwork>
   GET /chat HTTP/1.1
   Host: server.example.com
   Upgrade: websocket
   Connection: Upgrade
   ...
   Sec-WebSocket-Version: 25
          </artwork>
        </figure>

        <t>The response from the server might look as follows:</t>

        <figure>
          <artwork>
   HTTP/1.1 400 Bad Request
   ...
   Sec-WebSocket-Version: 13, 8, 7
          </artwork>
        </figure>

        <t>Note that the last response from the server might also look like:</t>

        <figure>
          <artwork>
   HTTP/1.1 400 Bad Request
   ...
   Sec-WebSocket-Version: 13
   Sec-WebSocket-Version: 8, 7
          </artwork>
        </figure>

        <t>The client now repeats the handshake that conforms to version 13:</t>

        <figure>
          <artwork>
   GET /chat HTTP/1.1
   Host: server.example.com
   Upgrade: websocket
   Connection: Upgrade
   ...
   Sec-WebSocket-Version: 13
          </artwork>
        </figure>

      </section>

    </section>
      
      
    <section title='Data Framing' anchor='framing'>
      <section title='Overview'>
        <t>In the WebSocket Protocol, data is transmitted using a sequence of
        frames. To avoid confusing network intermediaries (such as 
        intercepting proxies) and for security reasons that are further 
        discussed in <xref target="masking-reasons" />, a client MUST mask all frames that it 
        sends to the server (see <xref target="masking"/> for further details).
        (Note that masking is done whether or not the WebSocket Protocol is running
	over TLS.) The 
        server MUST close the connection upon receiving a frame that is 
        not masked.  In this case, a server MAY send a Close frame with a 
        status code of 1002 (protocol error) as defined in <xref target="closestatus"/>.
        A server MUST NOT mask any frames that it sends to the client.  A 
        client MUST close a connection if it detects a masked frame.  In 
        this case, it MAY use the status code 1002 (protocol error) as 
        defined in <xref target="closestatus"/>.  (These rules might be relaxed
        in a future specification.)</t>

        <t>The base framing protocol defines a frame type with an opcode, a
        payload length, and designated locations for "Extension data" and "Application
        data", which together define the "Payload
        data". Certain bits and opcodes are reserved for future expansion of
        the protocol.</t>



        <t>A data frame MAY be transmitted by either the client or the server
        at any time after opening handshake completion and before that endpoint
        has sent a Close frame (<xref target="closeframe"/>).</t>
      </section>
      <section title='Base Framing Protocol' anchor='baseframing'>
        <t>
          This wire format for the data transfer part is described by
	  the ABNF <xref target='RFC5234'/> given in detail in this section.
	  (Note that, unlike in other sections of this document, the ABNF
	  in this section is operating on groups of bits. The length of
	  each group of bits is indicated in a comment. When encoded on
	  the wire, the most significant bit is the leftmost in the ABNF).
	  A high-level overview of the framing is given in the following figure.
	  In a case of conflict between the figure below and the ABNF specified
	  later in this section, the figure is authoritative.
        </t>

        <figure>
          <artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-------+-+-------------+-------------------------------+
  |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
  |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
  |N|V|V|V|       |S|             |   (if payload len==126/127)   |
  | |1|2|3|       |K|             |                               |
  +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
  |     Extended payload length continued, if payload len == 127  |
  + - - - - - - - - - - - - - - - +-------------------------------+
  |                               |Masking-key, if MASK set to 1  |
  +-------------------------------+-------------------------------+
  | Masking-key (continued)       |          Payload Data         |
  +-------------------------------- - - - - - - - - - - - - - - - +
  :                     Payload Data continued ...                :
  + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
  |                     Payload Data continued ...                |
  +---------------------------------------------------------------+
          </artwork>
        </figure>
        <t>
          <list style="hanging">
            <t hangText="FIN:">1 bit
              <vspace blankLines="1"/>
              Indicates that this is the final fragment in a message. The first
              fragment MAY also be the final fragment.
            </t>
            <t hangText="RSV1, RSV2, RSV3:">1 bit each
              <vspace blankLines="1"/>
              MUST be 0 unless an extension is negotiated that defines
              meanings for non-zero values. If a nonzero value is received and
              none of the negotiated extensions defines the meaning of such a
              nonzero value, the receiving endpoint MUST <spanx
                style='emph'>Fail the WebSocket Connection</spanx>.
            </t>
            <t hangText="Opcode:">4 bits
              <vspace blankLines="1"/>
              Defines the interpretation of the "Payload data". If an unknown
              opcode is received, the receiving endpoint MUST
              <spanx style='emph'>Fail the WebSocket Connection</spanx>.
              The following values are defined.
              <list style='symbols'>
                <t>%x0 denotes a continuation frame</t>
                <t>%x1 denotes a text frame</t>
                <t>%x2 denotes a binary frame</t>
                <t>%x3-7 are reserved for further non-control frames</t>
                <t>%x8 denotes a connection close</t>
                <t>%x9 denotes a ping</t>
                <t>%xA denotes a pong</t>
                <t>%xB-F are reserved for further control frames</t>
              </list>
            </t>
            <t hangText="Mask:">1 bit
              <vspace blankLines="1"/>
              Defines whether the "Payload data" is masked. If set to 1, a
              masking key is present in masking-key, and this is used to unmask
              the "Payload data" as per <xref target="masking" />. All frames sent
              from client to server have this bit set to 1.
            </t>
            <t hangText="Payload length:">7 bits, 7+16 bits, or 7+64 bits
              <vspace blankLines="1"/>
              The length of the "Payload data", in bytes: if 0-125, that is the
              payload length. If 126, the following 2 bytes interpreted as a
              16-bit unsigned integer are the payload length.  If 127, the
              following 8 bytes interpreted as a 64-bit unsigned integer (the
              most significant bit MUST be 0)
              are the payload length. Multibyte length quantities are expressed
              in network byte order. Note that in all cases, the minimal number
	      of bytes MUST be used to encode the length, for example, the length
	      of a 124-byte-long string can't be encoded as the sequence
	      126, 0, 124. The payload length is the length of the
              "Extension data" + the length of the "Application data". The length
              of the "Extension data" may be zero, in which case the payload
              length is the length of the "Application data".
            </t>
            <t hangText="Masking-key:">0 or 4 bytes
              <vspace blankLines="1"/>
              All frames sent from the client to the server are masked by a
              32&nbhy;bit value that is contained within the frame. This field is
              present if the mask bit is set to 1 and is absent if the mask
              bit is set to 0. See <xref target="masking" /> for
              further information on client-to-server masking.
            </t>
            <t hangText="Payload data:">(x+y) bytes
              <vspace blankLines="1"/>
              The "Payload data" is defined as "Extension data" concatenated with
              "Application data".
            </t>

            <t hangText="Extension data:">x bytes
              <vspace blankLines="1"/>
              The "Extension data" is 0 bytes unless an extension
              has been negotiated. Any extension MUST specify the length of the
              "Extension data", or how that length may be calculated, and how
              the extension use MUST be negotiated during the opening
              handshake. If present, the "Extension data" is included in the
              total payload length.
            </t>
            <t hangText="Application data:">y bytes
              <vspace blankLines="1"/>
              Arbitrary "Application data", taking up the remainder of the frame
              after any "Extension data". The length of the "Application data" is
              equal to the payload length minus the length of the "Extension
              data".
            </t>
          </list>
        </t>
        <t>The base framing protocol is formally defined by the following ABNF <xref target='RFC5234'/>. It is important to note that the representation of this data is binary, not ASCII characters. As such, a field with a length of 1 bit that takes values %x0 / %x1 is represented as a single bit whose value is 0 or 1, not a full byte (octet) that stands for the characters &quot;0&quot; or &quot;1&quot; in the ASCII encoding. A field with a length of 4 bits with values between %x0-F again is represented by 4 bits, again NOT by an ASCII character or full byte (octet) with these values. <xref target="RFC5234" /> does not specify a
character encoding: &quot;Rules resolve into a string of terminal values,
sometimes called characters.  In ABNF, a character is merely a non-negative
integer. In certain contexts, a specific mapping (encoding) of values into a
character set (such as ASCII) will be specified.&quot; Here, the specified
encoding is a binary encoding where each terminal value is encoded in the
specified number of bits, which varies for each field.  </t>


        <figure height="" suppress-title="false" width="" alt="" title="" align="left">
        <artwork align="left" xml:space="preserve"><![CDATA[
 ws-frame                = frame-fin           ; 1 bit in length
                           frame-rsv1          ; 1 bit in length
                           frame-rsv2          ; 1 bit in length
                           frame-rsv3          ; 1 bit in length
                           frame-opcode        ; 4 bits in length
                           frame-masked        ; 1 bit in length
                           frame-payload-length   ; either 7, 7+16, 
                                                  ; or 7+64 bits in 
                                                  ; length
                           [ frame-masking-key ]  ; 32 bits in length
                           frame-payload-data     ; n*8 bits in 
                                                  ; length, where 
                                                  ; n >= 0

 frame-fin               = %x0 ; more frames of this message follow
                         / %x1 ; final frame of this message
                               ; 1 bit in length

 frame-rsv1              = %x0 / %x1
                           ; 1 bit in length, MUST be 0 unless 
                           ; negotiated otherwise

 frame-rsv2              = %x0 / %x1
                           ; 1 bit in length, MUST be 0 unless 
                           ; negotiated otherwise

 frame-rsv3              = %x0 / %x1
                           ; 1 bit in length, MUST be 0 unless 
                           ; negotiated otherwise

 frame-opcode            = frame-opcode-non-control /
                           frame-opcode-control /
                           frame-opcode-cont

 frame-opcode-cont       = %x0 ; frame continuation

 frame-opcode-non-control= %x1 ; text frame
                         / %x2 ; binary frame
                         / %x3-7
                         ; 4 bits in length,
                         ; reserved for further non-control frames

 frame-opcode-control    = %x8 ; connection close
                         / %x9 ; ping
                         / %xA ; pong
                         / %xB-F ; reserved for further control 
                                 ; frames
                                 ; 4 bits in length

 frame-masked            = %x0
                         ; frame is not masked, no frame-masking-key
                         / %x1
                         ; frame is masked, frame-masking-key present
                         ; 1 bit in length

 frame-payload-length    = ( %x00-7D )
                         / ( %x7E frame-payload-length-16 )
                         / ( %x7F frame-payload-length-63 )
                         ; 7, 7+16, or 7+64 bits in length, 
                         ; respectively

 frame-payload-length-16 = %x0000-FFFF ; 16 bits in length

 frame-payload-length-63 = %x0000000000000000-7FFFFFFFFFFFFFFF
                         ; 64 bits in length

 frame-masking-key       = 4( %x00-FF )
                           ; present only if frame-masked is 1
                           ; 32 bits in length

 frame-payload-data      = (frame-masked-extension-data
                            frame-masked-application-data)
                         ; when frame-masked is 1
                           / (frame-unmasked-extension-data
                             frame-unmasked-application-data)
                         ; when frame-masked is 0

 frame-masked-extension-data     = *( %x00-FF )
                         ; reserved for future extensibility
                         ; n*8 bits in length, where n >= 0

 frame-masked-application-data   = *( %x00-FF )
                         ; n*8 bits in length, where n >= 0

 frame-unmasked-extension-data   = *( %x00-FF )
                         ; reserved for future extensibility
                         ; n*8 bits in length, where n >= 0

 frame-unmasked-application-data = *( %x00-FF )
                         ; n*8 bits in length, where n >= 0
]]></artwork></figure>
        <t>
        </t>
      </section>
      <section title='Client-to-Server Masking' anchor="masking">

        <t>A masked frame MUST have the field frame-masked set to 1, as defined
        in <xref target="baseframing" />.
        </t>
        <t>The masking key is contained completely within the frame, as defined
        in <xref target="baseframing" /> as frame-masking-key. It is used to
        mask the "Payload data" defined in the same section as frame-payload-data,
        which includes "Extension data" and "Application data".</t>

        <t>The masking key is a 32-bit value chosen at random by the client.
	When preparing a masked frame, the client MUST pick a fresh
        masking key from the set of allowed 32-bit values. The masking key needs to
        be unpredictable; thus, the masking key MUST be derived from a strong source
        of entropy, and the masking key for a given frame MUST NOT make it simple
        for a server/proxy to predict the masking key for a subsequent frame.
        The unpredictability of the masking key is essential to
        prevent authors of malicious applications from selecting the
        bytes that appear on the wire. RFC 4086 <xref
        target='RFC4086'/> discusses what entails a suitable source of entropy
        for security-sensitive applications.</t>

        <t> The masking does not affect the length
        of the "Payload data". To convert masked data into unmasked data, or vice
        versa, the following algorithm is applied. The same algorithm applies
        regardless of the direction of the translation, e.g., the same steps are
        applied to mask the data as to unmask the data.</t>

        <t>Octet i of the transformed data (&quot;transformed-octet-i&quot;)
        is the XOR of octet i of the original
        data (&quot;original-octet-i&quot;) with octet at index i modulo 4 of the
        masking key (&quot;masking-key-octet-j&quot;):</t>
        <figure>
          <artwork>
            <![CDATA[
  j                   = i MOD 4
  transformed-octet-i = original-octet-i XOR masking-key-octet-j
            ]]>
          </artwork>
        </figure>

        <t>The payload length, indicated in the framing as frame-payload-length,
        does NOT include the length of the masking key. It is the length of the
        "Payload data", e.g., the number of bytes following the masking key.</t>

      </section>
      <section title="Fragmentation" anchor='fragmentation'>
        <t>
          The primary purpose of fragmentation is to allow sending a message
          that is of unknown size when the message is started without having
          to buffer that message. If messages couldn&apos;t be fragmented,
          then an endpoint would have to buffer the entire message so its
          length could be counted before the first byte is sent. With
          fragmentation, a server or intermediary may choose a reasonable size
          buffer and, when the buffer is full, write a fragment to the network.
        </t>
        <t>
          A secondary use-case for fragmentation is for multiplexing, where it
          is not desirable for a large message on one logical channel to
          monopolize the output channel, so the multiplexing needs to be free
          to split the message into smaller fragments to better share the output
          channel. (Note that the multiplexing extension is not described in
          this document.)
        </t>
	  
	<t>Unless specified otherwise by an extension, frames have no semantic
	meaning. An intermediary might coalesce and/or split frames, if no extensions
	were negotiated by the client and the server or if some extensions
	were negotiated, but the intermediary understood all the extensions
	negotiated and knows how to coalesce and/or split frames in the presence
	of these extensions. One implication of this is that in absence of extensions,
	senders and receivers must not depend on the presence of specific frame boundaries.</t>

        <t>The following rules apply to fragmentation:
          <list style="symbols">
            <t>An unfragmented message consists of a single frame with the FIN
            bit set (<xref target='baseframing'/>) and an opcode other than 0.</t>
            <t>A fragmented message consists of a single frame with the FIN
            bit clear and an opcode other than 0, followed by zero or more
            frames with the FIN bit clear and the opcode set to 0, and
            terminated by a single frame with the FIN bit set and an opcode of
            0. A fragmented message is conceptually equivalent to a single
            larger message whose payload is equal to the concatenation of the
            payloads of the fragments in order; however, in the presence of
            extensions, this may not hold true as the extension defines the
            interpretation of the "Extension data" present. For instance,
            "Extension data" may only be present at the beginning of the first
            fragment and apply to subsequent fragments, or there may be
            "Extension data" present in each of the fragments that applies only to
            that particular fragment. In the absence of "Extension data",
            the following example demonstrates how fragmentation works.
            <vspace blankLines='1'/>
            EXAMPLE: For a text message sent as
            three fragments, the first fragment would have an opcode of 0x1 and
            a FIN bit clear, the second fragment would have an opcode of 0x0 and
            a FIN bit clear, and the third fragment would have an opcode of 0x0
            and a FIN bit that is set.
            </t>
            <t>Control frames (see <xref target="controlframes"/>) MAY be injected in the middle of a fragmented
            message. Control frames themselves MUST NOT be fragmented.</t>
            <t>Message fragments MUST be delivered to the recipient in the order
            sent by the sender.</t>
            <t>The fragments of one message MUST NOT be interleaved between the
            fragments of another message unless an extension has been negotiated
            that can interpret the interleaving.</t>
            <t>An endpoint MUST be capable of handling control frames in the
            middle of a fragmented message.</t>
            <t>A sender MAY create fragments of any size for non-control
            messages.</t>
            <t>Clients and servers MUST support receiving both fragmented and
            unfragmented messages.
            </t>
            <t>As control frames cannot be fragmented, an intermediary MUST NOT
            attempt to change the fragmentation of a control frame.</t>

            <t>An intermediary MUST NOT change the fragmentation of a message
            if any reserved bit values are used and the meaning of these
            values is not known to the intermediary.</t>
	      

            <t>An intermediary MUST NOT change the fragmentation of any message
            in the context of a connection where extensions have been negotiated
            and the intermediary is not aware of the semantics of the negotiated
            extensions.
            Similarly, an intermediary that didn't see the WebSocket handshake
            (and wasn't notified about its content) that resulted in a WebSocket connection
            MUST NOT change the fragmentation of any message of such connection.</t>

            <t>
              As a consequence of these rules, all fragments of a message are
              of the same type, as set by the first fragment's opcode. Since
              control frames cannot be fragmented, the type for all fragments
              in a message MUST be either text, binary, or one of the
              reserved opcodes.
            </t>
          </list>
        </t>
        <t>
        NOTE: If control frames could not be interjected,
        the latency of a ping, for example, would be very long if behind a
        large message. Hence, the requirement of handling
        control frames in the middle of a fragmented message.
        </t>
	  
        <t>
        IMPLEMENTATION NOTE: In the absence of any extension,
	a receiver doesn't have to buffer the whole frame in order to process it.	
	For example, if a streaming API is used, a part of a frame can be delivered
	to the application. However, note that this assumption might not hold true
	for all future WebSocket extensions.
        </t>
	  
      </section>
      <section title="Control Frames" anchor="controlframes">
        <t>Control frames are identified by opcodes where the most significant
        bit of the
        opcode is 1. Currently defined opcodes for control frames include 0x8
        (Close), 0x9 (Ping), and 0xA (Pong). Opcodes 0xB-0xF are reserved for
        further control frames yet to be defined.</t>
        <t>Control frames are used to communicate state about the
        WebSocket. Control frames can be interjected in the middle of a
        fragmented message.
        </t>
        <t>All control frames MUST have a payload length of 125 bytes or less
        and MUST NOT be fragmented.</t>
        <section title="Close" anchor="closeframe">
          <t>The Close frame contains an opcode of 0x8.</t>
          <t>The Close frame MAY contain a body (the &quot;Application
          data&quot; portion of the frame) that indicates a reason
          for closing, such as an endpoint shutting down, an endpoint
          having received a frame too large, or an endpoint having
          received a frame that does not conform to the format expected
          by the endpoint. If there is a body, the first two bytes of the
          body MUST be a 2-byte unsigned integer (in network byte order)
          representing a status code with value /code/ defined in
          <xref target="status_codes"/>.
          Following the
          2-byte integer, the body MAY contain UTF&nbhy;8-encoded data with value
          /reason/, the interpretation of which is not defined by this
          specification. This data is not necessarily human readable but may
          be useful for debugging or passing information relevant to the script
          that opened the connection. As the data is not guaranteed to be human
          readable, clients MUST NOT show it to end users.</t>
          <t>Close frames sent from client to server must be masked as per
            <xref target='masking'/>.  </t>
          <t>The application MUST NOT send any more data frames after sending
          a Close frame.</t>
          <t>If an endpoint receives a Close frame and did not
          previously send a Close frame, the endpoint MUST send a Close
          frame in response. (When sending a Close frame in response, the endpoint
          typically echos the status code it received.)
          It SHOULD do so as soon as practical. An
          endpoint MAY delay sending a Close frame until its current message is
          sent (for instance, if the majority of a fragmented message is already
          sent, an endpoint MAY send the remaining fragments before sending a
          Close frame). However, there is no guarantee that the endpoint that
          has already sent a Close frame will continue to process data.
          </t>
          <t>After both sending and receiving a Close message, an endpoint
          considers the WebSocket connection closed and
          MUST close the underlying TCP connection. The server MUST close the
          underlying TCP connection immediately; the client SHOULD wait for the
          server to close the connection but MAY close the connection at any
          time after sending and receiving a Close message, e.g., if it has not
          received a TCP Close from the server in a reasonable time period.</t>
          <t>If a client and server both send a Close message at the same time,
          both endpoints will have sent and received a Close message and should
          consider the WebSocket connection closed and close the underlying
          TCP connection.</t>
        </section>
        <section title="Ping" anchor="pingframe">
          <t>The Ping frame contains an opcode of 0x9.</t>
          <t>A Ping frame MAY include "Application data".</t>
          <t>Upon receipt of a Ping frame, an endpoint MUST send a Pong
            frame in response, unless it already received a Close frame.
	    It SHOULD respond with Pong frame as soon as is practical. Pong
            frames are discussed in <xref target='pongframe'/>.
          </t>
          <t>An endpoint MAY send a Ping frame any time after the connection
          is established and before the connection is closed. 
</t>
<t>NOTE: A Ping
          frame may serve either as a keepalive or as a means to verify that the
          remote endpoint is still responsive.</t>
        </section>
        <section title="Pong" anchor='pongframe'>
          <t>The Pong frame contains an opcode of 0xA.</t>
          <t><xref target="pingframe" /> details requirements that apply to both
          Ping and Pong frames.</t>
          <t>A Pong frame sent in response to a Ping frame must have identical
            "Application data" as found in the message body of the Ping frame
            being replied to.</t>
          <t>If an endpoint receives a Ping frame and has not yet sent Pong
          frame(s) in response to previous Ping frame(s), the endpoint MAY elect
          to send a Pong frame for only the most recently processed Ping frame.
          </t>
          <t>A Pong frame MAY be sent unsolicited. This serves as a
          unidirectional heartbeat. A response to an unsolicited Pong frame is not
          expected.</t>
        </section>


      </section>
      <section title="Data Frames" anchor="dataframes">
        <t>
          Data frames (e.g., non-control frames) are identified by opcodes where
          the most significant bit of the opcode is 0. Currently defined opcodes
          for data frames include 0x1 (Text), 0x2 (Binary). Opcodes 0x3-0x7 are
          reserved for further non-control frames yet to be defined.
        </t>
        <t>
          Data frames carry application-layer and/or extension-layer data. The
          opcode determines the interpretation of the data:
          <list style="hanging">
            <t hangText="Text">
              <vspace blankLines='1'/>
              The "Payload data" is text data encoded as UTF-8.
	      Note that a particular text frame might include a partial UTF-8 sequence;
	      however, the whole message MUST contain valid UTF-8.
	      Invalid UTF-8 in reassembled messages is handled as described in <xref target='badutf8'/>.
            </t>
            <t hangText="Binary">
              <vspace blankLines='1'/>
              The "Payload data" is arbitrary binary data whose interpretation
              is solely up to the application layer.
            </t>
          </list>
        </t>
      </section>
      <section title="Examples">
        <t>
          <list style="symbols">
            <t>
              A single-frame unmasked text message
              <list style="symbols">
                <t>0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains "Hello")</t>
              </list>
            </t>
            <t>
              A single-frame masked text message
              <list style="symbols">
                <t>0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58 (contains "Hello")</t>
              </list>
            </t>
            <t>
              A fragmented unmasked text message
              <list style="symbols">
                <t>0x01 0x03 0x48 0x65 0x6c (contains "Hel")</t>
                <t>0x80 0x02 0x6c 0x6f (contains "lo")</t>
              </list>
            </t>
            <t>
              Unmasked Ping request and masked Ping response
              <list style="symbols">
                <t>0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains a body of "Hello", but the contents of the body are arbitrary)</t>
                <t>0x8a 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58 (contains a body of "Hello", matching the body of the ping)</t>
              </list>
            </t>
            <t>
              256 bytes binary message in a single unmasked frame
              <list style="symbols">
                <t>0x82 0x7E 0x0100 [256 bytes of binary data]</t>
              </list>
            </t>
            <t>
              64KiB binary message in a single unmasked frame
              <list style="symbols">
                <t>0x82 0x7F 0x0000000000010000 [65536 bytes of binary data]</t>
              </list>
            </t>
          </list>
        </t>
      </section>
      <section title="Extensibility">
        <t>The protocol is designed to allow for extensions, which will add
        capabilities to the base protocol. The endpoints of a connection MUST
        negotiate the use of any extensions during the opening handshake. This
        specification provides opcodes 0x3 through 0x7 and 0xB through 0xF, the
        "Extension data" field, and the frame-rsv1, frame-rsv2, and frame-rsv3
        bits of the frame header for use by extensions. The
        negotiation of extensions is discussed in further detail in
        <xref target="negotiation" />.
        Below are some anticipated uses of extensions. This list is neither
        complete nor prescriptive.
          <list style="symbols">

            <t>"Extension data" may be placed in the "Payload data" before the
            "Application data".</t>
            <t>Reserved bits can be allocated for per-frame needs.</t>
            <t>Reserved opcode values can be defined.</t>
            <t>Reserved bits can be allocated to the opcode field if more
            opcode values are needed.</t>
            <t>A reserved bit or an &quot;extension&quot; opcode can be defined
            that allocates additional bits out of the "Payload data" to define
            larger opcodes or more per-frame bits.</t>
          </list>
        </t>
      </section>
    </section>

    <section title='Sending and Receiving Data'>
      <section title='Sending Data' anchor='send_data'>
        <t>
          To <spanx style='emph'>Send a WebSocket Message</spanx> comprising of
          /data/ over a
          WebSocket connection, an endpoint MUST perform the following steps.
          <list style='numbers'>
            <t>The endpoint MUST ensure the WebSocket connection is in the OPEN
              state (cf. Sections <xref target="clienths" format="counter"/> and
              <xref target="server_handshake" format="counter"/>.) If at any point the state of
              the WebSocket connection changes, the endpoint MUST abort the
              following steps.
            </t>
            <t>
              An endpoint MUST encapsulate the /data/ in a WebSocket frame as
              defined in <xref target='baseframing' />. If the
              data to be sent is large or if the data is not available in its
              entirety at the point the endpoint wishes to begin sending the
              data, the endpoint MAY alternately encapsulate the data in a
              series of frames as defined in <xref target='fragmentation'/>.
            </t>
            <t>The opcode (frame-opcode) of the first frame containing the data
              MUST be set to
              the appropriate value from <xref target='baseframing' /> for data
              that is to be interpreted by the recipient as text or binary data.
            </t>
            <t>The FIN bit (frame-fin) of the last frame containing the data
              MUST be set to 1 as defined in <xref target='baseframing' />.
            </t>
            <t>If the data is being sent by the client, the frame(s) MUST be
              masked as defined in <xref target='masking' />.
            </t>
            <t>If any extensions (<xref target='extensions' />) have been
              negotiated for the WebSocket
              connection, additional considerations may apply as per the
              definition of those extensions.
            </t>
            <t>The frame(s) that have been formed MUST be transmitted over the
              underlying network connection.
            </t>
          </list>
        </t>
      </section>
      <section title='Receiving Data' anchor='rcv_data'>
        <t>
          To receive WebSocket data, an endpoint listens on the underlying
          network connection. Incoming data MUST be parsed as WebSocket frames
          as defined in <xref target='baseframing' />.
          If a control frame (<xref target='controlframes'/>) is received, the
          frame MUST be handled as defined by <xref target='controlframes'/>.
          Upon receiving a data frame (<xref target='dataframes' />), the
          endpoint MUST note the /type/ of the data as defined by the opcode
          (frame-opcode) from <xref target='baseframing' />. The 
          "Application data" from this frame is defined as
          the /data/ of the message. If the frame comprises an unfragmented
          message (<xref target='fragmentation' />), it is said that <spanx
            style='emph'>A WebSocket Message Has Been Received</spanx> with type
          /type/ and data /data/. If the frame is part of a fragmented message,
          the "Application data" of the subsequent
          data frames is concatenated to form the /data/. When the last fragment
          is received as indicated by the FIN bit (frame-fin), it is said that
          <spanx style='emph'>A WebSocket Message Has Been Received</spanx> with
          data /data/ (comprised of the concatenation of the 
          "Application data" of the fragments) and type
          /type/ (noted from the first frame of the fragmented message).
          Subsequent data frames MUST be interpreted as belonging to a new
          WebSocket message.
        </t>
        <t>Extensions (<xref target='extensions' />) MAY change the semantics of
          how data is read, specifically including what comprises a message
          boundary. Extensions, in addition to adding &quot;Extension data&quot;
          before the &quot;Application data&quot; in a payload, MAY also modify
          the &quot;Application data&quot; (such as by compressing it).
        </t>
        <t>A server MUST remove masking for data frames received from a client as
          described in <xref target='masking' />.
        </t>
      </section>
    </section>
    <section title='Closing the Connection' anchor='closing_connection'>
      <section title='Definitions'>

        <section title="Close the WebSocket Connection" anchor="close_wsc">
          <t>
            To <spanx style="emph">Close the WebSocket Connection</spanx>,
            an endpoint closes the underlying TCP connection. An endpoint
            SHOULD use a method that cleanly closes the TCP connection, as well
            as the TLS session, if applicable,
            discarding any trailing bytes that may have been received. An endpoint
            MAY close the connection via any means available when necessary,
            such as when under attack.
          </t>
          <t>
            The underlying TCP connection, in most normal cases, SHOULD be
            closed first by the server, so that it holds the TIME_WAIT state and
            not the client (as this would prevent it from re-opening the
            connection for 2 maximum segment lifetimes (2MSL), while there is no corresponding server impact
            as a TIME_WAIT connection is immediately reopened upon a new SYN
            with a higher seq number). In abnormal cases (such as not having
            received a TCP Close from the server after a reasonable amount of
            time) a client MAY initiate the TCP Close. As such, when a server is
            instructed to <spanx style='emph'>Close the WebSocket
            Connection</spanx> it SHOULD initiate a TCP Close immediately, and
            when a client is instructed to do the same, it SHOULD wait for a TCP
            Close from the server.
          </t>
          <t>
            As an example of how to obtain a clean closure in C
            using Berkeley sockets, one would call shutdown() with SHUT_WR
            on the socket, call recv() until obtaining a return value of 0
            indicating that the peer has also performed an orderly shutdown,
            and finally call close() on the socket.
          </t>
        </section>
        <section title="Start the WebSocket Closing Handshake"
                 anchor="start_closing">
          <t>
            To <spanx style="emph">Start the WebSocket Closing
              Handshake</spanx> with a status code (<xref
              target='status_codes'/>) /code/ and an optional close reason
            (<xref target='close_reason'/>) /reason/, an endpoint MUST send a
            Close control frame, as
            described in <xref target='closeframe' />, whose status code is set
            to /code/ and whose close reason is set to /reason/.
            Once an endpoint has both sent and received a Close
            control frame, that endpoint SHOULD <spanx style='emph'>Close the
            WebSocket Connection</spanx> as defined in <xref
            target='close_wsc'/>.
          </t>
        </section>
        <section title="The WebSocket Closing Handshake is Started">
          <t>
            Upon either sending or receiving a Close control frame, it is said
            that <spanx style='emph'>The WebSocket Closing Handshake is
              Started</spanx> and that the WebSocket connection is in the
            CLOSING state.
          </t>
        </section>
        <section title='The WebSocket Connection is Closed' anchor='is_closed'>
          <t>
            When the underlying TCP connection is closed, it is said that
            <spanx style='emph'>The WebSocket Connection is Closed</spanx> and
            that the WebSocket connection is in the CLOSED state.
            If the TCP connection was
            closed after the WebSocket closing handshake was completed,
            the WebSocket connection is said to have been closed <spanx
            style='emph'>cleanly</spanx>.
          </t>
          <t>If the WebSocket connection could not be established, it is also
            said that <spanx style='emph'>The WebSocket Connection is
              Closed</spanx>, but not <spanx style='emph'>cleanly</spanx>.
          </t>
        </section>
        <section title='The WebSocket Connection Close Code' anchor='closecode'>
          <t>As defined in Sections <xref target='closeframe' format="counter" /> and <xref
              target='status_codes' format="counter" />, a Close control frame may contain a
            status code indicating a reason for closure. A closing of the
            WebSocket connection may be initiated by either endpoint,
            potentially simultaneously. <spanx style='emph'>The WebSocket
              Connection Close Code</spanx> is defined as the status code (<xref
              target='status_codes' />) contained in the first Close control
            frame received by the application implementing this protocol.
            If this Close control frame
            contains no status code, <spanx style='emph'>The WebSocket
              Connection Close Code</spanx> is considered to be 1005. If <spanx
              style='emph'>The WebSocket Connection is Closed</spanx> and no
            Close control frame was received by the endpoint (such as
            could occur if the underlying transport connection is lost), <spanx
              style='emph'>The WebSocket Connection Close Code</spanx> is
            considered to be 1006.
          </t>
          <t>NOTE: Two endpoints may not agree on the value of <spanx
              style='emph'>The WebSocket Connection Close Code</spanx>.
            As an example, if the remote endpoint sent a Close frame but the
            local application has not yet read the data containing the Close
            frame from its socket&apos;s receive buffer, and the local
            application independently decided to close the connection and send a
            Close frame, both endpoints will have sent and received a Close
            frame and will not send further Close frames. Each endpoint will
            see the status code sent by the other end as <spanx
              style='emph'>The WebSocket Connection Close Code</spanx>.
            As such, it is possible that the
            two endpoints may not agree on the value of <spanx style='emph'>The
              WebSocket Connection Close Code</spanx> in the case that both
            endpoints <spanx style='emph'>Start the WebSocket Closing
              Handshake</spanx> independently and at roughly the same time.
          </t>
        </section>
        <section title='The WebSocket Connection Close Reason'
          anchor='close_reason'>
          <t>As defined in 
Sections <xref target='closeframe' format="counter"/> and <xref
              target='status_codes' format="counter"/>, a Close control frame may contain a
            status code indicating a reason for closure, followed by UTF&nbhy;8-encoded data, the interpretation of said data being left to the
            endpoints and not defined by this protocol. A closing of the
            WebSocket connection may be initiated by either endpoint,
            potentially simultaneously. <spanx style='emph'>The WebSocket
              Connection Close Reason</spanx> is defined as the UTF&nbhy;8-encoded
            data following the status code (<xref
              target='status_codes' />) contained in the first Close control
            frame received by the application implementing this protocol.
            If there is no such data in
            the Close control frame, <spanx style='emph'>The WebSocket
              Connection Close Reason</spanx> is the empty string.</t>
          <t>NOTE: Following the same logic as noted in <xref target='closecode'
              />, two endpoints may not agree on <spanx
              style='emph'>The WebSocket Connection Close Reason</spanx>.
          </t>
        </section>
        <section title='Fail the WebSocket Connection' anchor='fail_ws'>
          <t>
            Certain algorithms and specifications require an endpoint to
            <spanx style='emph'>Fail the WebSocket Connection</spanx>. To
            do so, the client MUST <spanx style='emph'>Close the
            WebSocket Connection</spanx>, and MAY report the problem
            to the user (which would be especially useful for developers) in
            an appropriate manner. Similarly, to do so, the server MUST
            <spanx style='emph'>Close the WebSocket Connection</spanx>,
            and SHOULD log the problem.
          </t>
            <t>If <spanx style='emph'>The WebSocket Connection is
                Established</spanx> prior to the point where the endpoint is
            required to <spanx style='emph'>Fail the WebSocket
              Connection</spanx>, the endpoint SHOULD send a Close frame with an
            appropriate status code (<xref target='status_codes'/>) before
            proceeding to <spanx style='emph'>Close the WebSocket
              Connection</spanx>. An endpoint MAY omit sending a Close frame if
            it believes the other side is unlikely to be able to receive and
            process the Close frame, due to the nature of the error that led 
            the WebSocket connection to fail in the first place. An
            endpoint MUST NOT continue to attempt to process data (including a
            responding Close frame) from the remote endpoint after being
            instructed to <spanx style='emph'>Fail the WebSocket
              Connection</spanx>.
            </t>
            <t>
            Except as indicated above or as specified by the application
            layer (e.g., a script using the WebSocket API), clients SHOULD
            NOT close the connection.
          </t>
        </section>
      </section>
      <section title='Abnormal Closures'>
        <section title='Client-Initiated Closure'>
          <t>


            Certain algorithms, in particular during the opening handshake, require
            the client to <spanx style='emph'>Fail the WebSocket
            Connection</spanx>.
            To do so, the client MUST
            <spanx style='emph'>Fail the WebSocket Connection</spanx> as
            defined in <xref target='fail_ws'/>.
          </t>
          <t>If at any point the underlying transport layer connection is
            unexpectedly lost, the client MUST <spanx style='emph'>Fail the
              WebSocket Connection</spanx>.
          </t>
          <t>
            Except as indicated above or as specified by the application layer
            (e.g., a script using the WebSocket API), clients SHOULD NOT
            close the connection.
          </t>

        </section>
        <section title='Server-Initiated Closure'>
          <t>
            Certain algorithms require or recommend that the server
            <spanx style='emph'>Abort the WebSocket Connection</spanx> during
            the opening handshake. To do so, the server MUST simply <spanx
            style='emph'>Close the WebSocket Connection</spanx> (<xref
            target='close_wsc'/>).
          </t>
        </section>
        <section title='Recovering from Abnormal Closure'>
          <t>
            Abnormal closures may be caused by any number of reasons. Such
            closures could be the result of a transient error, in which case
            reconnecting may lead to a good connection and a resumption of
            normal operations. Such closures may also be the result of a
            nontransient problem, in which case if each deployed client
            experiences an abnormal closure and immediately and persistently tries
            to reconnect, the server may experience what amounts to a
            denial-of-service 
            attack by a large number of clients trying to reconnect. The
            end result of such a scenario could be that the service is unable to
            recover in a timely
            manner or
            recovery is made much more difficult.
          </t>
          <t>
            To prevent this, clients SHOULD use some form of backoff when
            trying to reconnect after abnormal closures as described in this
            section.
          </t>
          <t>
            The first reconnect attempt SHOULD be delayed by a random
            amount of time. The parameters by which this random delay is chosen
            are left to the client to decide; a value chosen randomly between 0
            and 5 seconds is a reasonable initial delay though clients MAY choose
            a different interval from which to select a delay length based on
            implementation experience and particular application.
          </t>
          <t>
            Should the first reconnect attempt fail, subsequent reconnect attempts
            SHOULD be delayed by increasingly longer amounts of time, using a
            method such as truncated binary exponential backoff.
          </t>
        </section>
      </section>
      <section title='Normal Closure of Connections'>
        <t>
          Servers MAY close the WebSocket connection whenever desired. Clients
          SHOULD NOT close the WebSocket connection arbitrarily. In
          either case, an endpoint initiates a closure by following the
          procedures to <spanx style='emph'>Start the WebSocket Closing
          Handshake</spanx> (<xref target='start_closing'/>).
        </t>
      </section>
      <section title='Status Codes' anchor='status_codes'>
        <t>
          When closing an established connection (e.g., when sending a Close
          frame, after the opening handshake has completed), an endpoint MAY
          indicate
          a reason for closure. The interpretation of this reason by an
          endpoint, and the action an endpoint should take given this reason,
          are left undefined by this specification. This specification defines
          a set of pre-defined status codes and specifies which ranges may be
          used by extensions, frameworks, and end applications. The status
          code and any associated textual message are optional components of a
          Close frame.
        </t>
        <section title='Defined Status Codes' anchor="closestatus">
          <t>
            Endpoints MAY use the following pre-defined status codes
            when sending a Close frame.
            <list style='hanging'>
              <t hangText='1000'>
                <vspace blankLines='1'/>
                1000 indicates a normal closure, meaning that the purpose for which the
                connection was established has been fulfilled.
              </t>
              <t hangText='1001'>
                <vspace blankLines='1'/>
                1001 indicates that an endpoint is &quot;going away&quot;,
                such as a server going down or a browser having navigated away
                from a page.
              </t>
              <t hangText='1002'>
                <vspace blankLines='1'/>
                1002 indicates that an endpoint is terminating the connection
                due to a protocol error.
              </t>
              <t hangText='1003'>
                <vspace blankLines='1'/>
                1003 indicates that an endpoint is terminating the connection
                because it has received a type of data it cannot accept (e.g.,
                an endpoint that understands only text data MAY send this if it
                receives a binary message).
              </t>
              <t hangText='1004'>
                <vspace blankLines='1'/>
                Reserved. The specific meaning might be defined in the future.
              </t>
              <t hangText='1005'>
                <vspace blankLines='1'/>
                1005 is a reserved value and MUST NOT be set as a status code in
                a Close control frame by an endpoint. It is designated for use
                in applications expecting a status code to indicate that no
                status code was actually present.
              </t>
              <t hangText='1006'>
                <vspace blankLines='1'/>
                1006 is a reserved value and MUST NOT be set as a status code in
                a Close control frame by an endpoint. It is designated for use
                in applications expecting a status code to indicate that the
                connection was closed abnormally, e.g., without sending or
                receiving a Close control frame.
              </t>
              <t hangText='1007'>
                <vspace blankLines='1'/>
                1007 indicates that an endpoint is terminating the connection
		because it has received data within a message that was not consistent
		with the type of the message (e.g., non-UTF-8 <xref target='RFC3629'/>
		data within a text message).
              </t>
              <t hangText='1008'>
                <vspace blankLines='1'/>
                1008 indicates that an endpoint is terminating the connection
                because it has received a message that violates its policy.
		This is a generic status code that can be returned when
		there is no other more suitable status code (e.g., 1003 or 1009)
		or if there is a need to hide specific details about the policy.
              </t>
              <t hangText='1009'>
                <vspace blankLines='1'/>
                1009 indicates that an endpoint is terminating the connection
                because it has received a message that is too big for it to process.
              </t>
              <t hangText='1010'>
                <vspace blankLines='1'/>
                1010 indicates that an endpoint (client) is terminating the connection
                because it has expected the server to negotiate one or more extension,
		but the server didn't return them in the response message of the WebSocket
		handshake. The list of extensions that are needed SHOULD appear in the
		/reason/ part of the Close frame.
		Note that this status code is not used by the server, because it can
		fail the WebSocket handshake instead.
              </t>

<t hangText='1011'>
<vspace blankLines='1'/>
     1011 indicates that a server is terminating the connection
     because it encountered an unexpected condition that prevented
     it from fulfilling the request.
</t>

<t hangText='1015'>
<vspace blankLines='1'/>
     1015 is a reserved value and MUST NOT be set as a status code in a
     Close control frame by an endpoint.  It is designated for use in
     applications expecting a status code to indicate that the
     connection was closed due to a failure to perform a TLS handshake
     (e.g., the server certificate can't be verified).
</t>

            </list>
          </t>
        </section>
        <section title='Reserved Status Code Ranges'>
          <t>
            <list style='hanging'>
              <t hangText='0-999'>
                <vspace blankLines='1'/>
                Status codes in the range 0-999 are not used.
              </t>
              <t hangText='1000-2999'>
                <vspace blankLines='1'/>
                Status codes in the range 1000-2999 are reserved for
                definition by this protocol, its future revisions,
                and extensions specified in a permanent and readily
                available public specification.
              </t>
              <t hangText='3000-3999'>
                <vspace blankLines='1'/>
                Status codes in the range 3000-3999 are reserved for use by
                libraries, frameworks, and applications. These status codes are
                registered directly with IANA.

                The interpretation of these codes is undefined by this protocol.
              </t>
              <t hangText='4000-4999'>
                <vspace blankLines='1'/>
                Status codes in the range 4000-4999 are reserved for private
                use and thus can't be registered. Such codes can be used by
                prior agreements between WebSocket applications.
                The interpretation of these codes is undefined by this
                protocol.
              </t>
            </list>
          </t>
        </section>
      </section>
    </section>
    <section title='Error Handling'>
      <section title='Handling Errors in UTF-8-Encoded Data' anchor='badutf8'>
        <t>When an endpoint is to interpret a byte stream as UTF-8 but finds that
	the byte stream is not, in fact, a valid UTF-8 stream, that endpoint MUST
	<spanx style='emph'>Fail the WebSocket Connection</spanx>.
	This rule applies both during the opening handshake and during subsequent
	data exchange.
        </t>
      </section>
    </section>
    <section title="Extensions" anchor="extensions">
      <t>WebSocket clients MAY request extensions to this specification,
      and WebSocket servers MAY accept some or all extensions
      requested by the client. A server MUST NOT respond with any
      extension not requested by the client. If extension
      parameters are included in negotiations between the client and the server,
      those
      parameters MUST be chosen in accordance with the specification of the
      extension to which the parameters apply.</t>
      <section title="Negotiating Extensions" anchor="negotiation">
        <t> A client requests extensions by including a
        |Sec-WebSocket-Extensions| header field, which follows the normal
        rules for HTTP header fields (see <xref target="RFC2616"/>,
        Section 4.2) and the value of the header field is defined by the following
        ABNF <xref target='RFC2616'/>. Note that this section
        is using ABNF syntax/rules from <xref target="RFC2616"/>, including the
        "implied *LWS rule". If a value is
        received by either the client or the server during negotiation that does
        not conform to the ABNF below, the recipient of such malformed data MUST
        immediately <spanx style="emph">Fail the WebSocket Connection</spanx>.
        </t>
        <figure>
          <artwork>
      Sec-WebSocket-Extensions = extension-list
      extension-list = 1#extension
      extension = extension-token *( ";" extension-param )
      extension-token = registered-token
      registered-token = token
      extension-param = token [ "=" (token | quoted-string) ]
          ;When using the quoted-string syntax variant, the value
          ;after quoted-string unescaping MUST conform to the
          ;'token' ABNF.
          </artwork>
        </figure>

        <t>Note that like other HTTP header fields, this header field MAY be split or
        combined across multiple lines. Ergo, the following are equivalent:</t>

        <figure>
          <artwork>
      Sec-WebSocket-Extensions: foo
      Sec-WebSocket-Extensions: bar; baz=2
          </artwork>
        </figure>

        <t>is exactly equivalent to</t>

        <figure>
          <artwork>
      Sec-WebSocket-Extensions: foo, bar; baz=2
          </artwork>
        </figure>

        <t>Any extension-token used MUST be a registered token
        (see <xref target="enr"/>). The parameters supplied with any given extension MUST be
        defined for that extension. Note that the client is only offering to
        use any advertised extensions and MUST NOT use them unless the server
        indicates that it wishes to use the extension.</t>

        <t>Note that the order of extensions is significant. Any interactions
        between multiple extensions MAY be defined in the documents defining the
        extensions. In the absence of such definitions, the interpretation is
        that the header fields listed by the client in its request represent a
        preference of the header fields it wishes to use, with the first options
        listed being most preferable. The extensions listed by the server in
        response represent the extensions actually in use for the connection.
        Should the extensions
        modify the data and/or framing, the order of operations on the data
        should be assumed to be the same as the order in which the extensions
        are listed in the server's response in the opening handshake.</t>

        <t>For example, if there are two extensions &quot;foo&quot; and
        &quot;bar&quot; and if the header field |Sec-WebSocket-Extensions| sent by the
        server has the value "foo, bar", then operations on the data will be
        made as bar(foo(data)), be those changes to the data itself (such as
        compression) or changes to the framing that may &quot;stack&quot;.</t>

        <t>Non-normative examples of acceptable extension header fields (note that long lines are folded for readability):</t>
        <figure>
          <artwork>
      Sec-WebSocket-Extensions: deflate-stream
      Sec-WebSocket-Extensions: mux; max-channels=4; flow-control,
       deflate-stream
      Sec-WebSocket-Extensions: private-extension
          </artwork>
        </figure>

        <t>A server accepts one or more extensions by including a
        |Sec-WebSocket-Extensions| header field containing one or more
        extensions that were requested by the client. The interpretation of any
        extension parameters, and what constitutes a valid response by a server
        to a requested set of parameters by a client, will be defined by each
        such extension.</t>
      </section>
      <section title="Known Extensions">
        <t>Extensions provide a mechanism for implementations to opt-in to
        additional protocol features. This document doesn't define any
        extension, but implementations MAY use extensions defined
        separately.</t>
      </section>
    </section>

    <section title='Security Considerations' anchor="securityconsiderations">
      <t>This section describes some security considerations applicable to the WebSocket Protocol.
      Specific security considerations are described in subsections of this section.</t>
      <section title="Non-Browser Clients">



        <t>The WebSocket Protocol protects against
 malicious JavaScript running inside a trusted application such as a
 web browser, for example, by checking of the |Origin| header field (see
 below).  
        See <xref target="secmodel"/> for additional details.
        Such assumptions don't hold true in the case of a more-capable client.
        </t>

        <t>While this protocol is intended to be used by scripts in web pages,
        it can also be used directly by hosts. Such hosts are acting on their own behalf
        and can therefore send fake |Origin| header fields, misleading the server.
        Servers should therefore be careful about assuming that they are talking directly
        to scripts from known origins and must consider that they might be accessed in
        unexpected ways. In particular, a server should not trust that any input is valid.</t>
        
        <t>EXAMPLE: If the server uses input as part of SQL queries, all input text should be escaped before being passed to the SQL server, lest the server be susceptible to SQL injection.</t>
      </section>
      <section title="Origin Considerations">

        <t>Servers that are not intended to process input from any web page but only for certain 
        sites SHOULD verify the |Origin| field is an origin they expect.
	If the origin indicated is unacceptable to the server, then it SHOULD respond to the WebSocket
	handshake with a reply containing HTTP 403 Forbidden status code.

      </t>
        <t>

        </t>


        <t>
          The |Origin| header field protects from the attack cases
          when the untrusted party is typically the author of a JavaScript
          application that is executing in the context of the trusted client. The client
          itself can contact the server and, via the mechanism of the
          |Origin| header field, determine whether to extend those
          communication privileges to the JavaScript application.
          The intent is not to prevent non-browsers from establishing
          connections but rather to ensure that trusted browsers under the control of
          potentially malicious JavaScript cannot fake a WebSocket
          handshake.
        </t>
      </section>
      <section title='Attacks On Infrastructure (Masking)' anchor='masking-reasons'>

        <t>
          In addition to endpoints being the target of attacks via WebSockets,
          other parts of web infrastructure, such as proxies, may be the subject
          of an attack.
        </t>
        <t>
          As this protocol was being developed, an experiment was
          conducted to demonstrate a class of attacks on proxies that
          led to the poisoning of caching proxies deployed in the wild <xref target="TALKING"/>.
          The general form of the attack was to establish a connection
          to a server under the &quot;attacker&apos;s&quot; control,
          perform an UPGRADE on the HTTP connection similar to what
          the WebSocket Protocol does to establish a connection, and
          subsequently send data over that UPGRADEd connection that
          looked like a GET request for a specific known resource
          (which in an attack would likely be something like a widely
          deployed script for tracking hits or a resource on an
          ad-serving network). The remote server would respond with
          something that looked like a response to the fake GET request,
          and this response would be cached by a nonzero percentage of
          deployed intermediaries, thus poisoning the cache. The net
          effect of this attack would be that if a user could be
          convinced to visit a website the attacker controlled, the
          attacker could potentially poison the cache for that user
          and other users behind the same cache and run malicious
          script on other origins, compromising the web security model.
        </t>
        <t>
         To avoid such attacks on deployed intermediaries,  it is not
         sufficient to prefix application-supplied data with framing that is not
         compliant with HTTP, as it is not possible to exhaustively discover and test
         that each nonconformant intermediary does not skip such non-HTTP
         framing and act incorrectly on the frame payload.  Thus, the defense
         adopted is to mask all data from the client to the server, so that the
         remote script (attacker) does not have control over how the data being
         sent appears on the wire and thus cannot construct a message that
         could be misinterpreted by an intermediary as an HTTP request.
        </t>
        <t>
	  Clients MUST choose a new masking key for each frame, using
	  an algorithm that cannot be predicted by end applications that
	  provide data.  For example, each masking could be drawn from
	  a cryptographically strong random number generator.
	  If the same key is used or a decipherable pattern
          exists for how the next key is chosen, the attacker can send
          a message that, when masked, could appear to be an HTTP
          request (by taking the message the attacker wishes to see
          on the wire and masking it with the next masking key to be
          used, the masking key will
          effectively unmask the data when the client applies it).
        </t>
        <t>
          It is also necessary that once the transmission of a frame
          from a client has begun, the payload (application-supplied
          data) of that frame must not be capable of being modified by
          the application. Otherwise, an attacker could send a long
          frame where the initial data was a known value (such as all
          zeros), compute the masking key being used upon receipt of
          the first part of the data, and then modify
          the data that is yet to be sent in the frame to appear as an
          HTTP request when masked. (This is essentially the same
          problem described in the previous paragraph with using a
          known or predictable masking key.) If additional data is to
          be sent or data to be sent is somehow changed, that new or
          changed data must be sent in a new frame and thus with a
          new masking key. In short, once transmission of a frame
          begins, the contents must not be modifiable by the remote
          script (application).
        </t>
        <t>
          The threat model being protected against is one in which the
          client sends data that appears to be an HTTP request. As such,
          the channel that needs to be masked is the data from the
          client to the server. The data from the server to the client
          can be made to look like a response, but to accomplish this
          request, the client must also be able to forge a request. As
          such, it was not deemed necessary to mask data in both
          directions (the data from the server to the client is not
          masked).
        </t>


        <t>
	Despite the protection provided by masking, non-compliant HTTP proxies
	will still be vulnerable to poisoning attacks of this type by clients
	and servers that do not apply masking.
        </t>

      </section>


      <section title='Implementation-Specific Limits'>

        <t>Implementations that have implementation- and/or platform-specific
        limitations regarding the frame size or total message size after reassembly
        from multiple frames MUST protect themselves against exceeding those limits.
        (For example, a malicious endpoint can try to exhaust its peer's memory or
        mount a denial-of-service attack by sending either a single big frame
        (e.g., of size 2**60) or by sending a long stream
        of small frames that are a part of a fragmented message.)
        Such an implementation SHOULD impose a limit on frame sizes
        and the total message size after reassembly from multiple frames.</t>

      </section>

	<section title='WebSocket Client Authentication'>
    	
	  <t>This protocol doesn't prescribe any particular way that servers can authenticate clients
	  during the WebSocket handshake. The WebSocket server can use any client authentication mechanism
	  available to a generic HTTP server, such as cookies, HTTP authentication, or TLS authentication.
	  </t>

	</section>
	



	<section title='Connection Confidentiality and Integrity'>
	    
    <t>Connection confidentiality and integrity is provided by running
    the WebSocket Protocol over TLS (wss URIs). WebSocket implementations
    MUST support TLS and SHOULD employ it when communicating with
    their peers.</t>

    <t>
      For connections using TLS, the amount of benefit provided by
      TLS depends greatly on the strength of the algorithms negotiated during
      the TLS handshake. For example, some TLS cipher mechanisms don't provide
      connection confidentiality. To achieve reasonable levels of protection, clients
      should use only Strong TLS algorithms. &quot;Web Security Context: User
      Interface Guidelines&quot; <xref target='W3C.REC-wsc-ui-20100812'/>
      discusses what constitutes Strong TLS algorithms.
      <xref target='RFC5246'/> provides additional guidance in Appendix A.5 and
      Appendix D.3.
    </t>
	
	</section>

	<section title='Handling of Invalid Data'>
	
      <t>
      Incoming data MUST always be validated by both clients and servers.
      If, at any time, an endpoint is faced with data that it does not understand
      or that violates some criteria by which the endpoint determines safety of input,
      or when the endpoint sees an opening handshake that does not correspond to
      the values it is expecting (e.g., incorrect path or origin in the client request),
      the endpoint MAY drop the TCP connection. If the invalid data was received after
      a successful WebSocket handshake, the endpoint SHOULD send a Close frame with an
      appropriate status code (<xref target='status_codes'/>) before
      proceeding to <spanx style='emph'>Close the WebSocket Connection</spanx>.
      Use of a Close frame with an appropriate status code can help in diagnosing
      the problem.
      If the invalid data is sent during the WebSocket handshake, the server SHOULD
      return an appropriate HTTP <xref target='RFC2616'/> status code.
      </t>

      <t>

      </t>

      <t>A common class of security problems arises when sending text data using
      the wrong encoding. This protocol specifies that messages with a Text data type
      (as opposed to Binary or other types) contain UTF&nbhy;8-encoded data. Although the length
      is still indicated and applications implementing this protocol should use the length
      to determine where the frame actually ends, sending data in an improper encoding may
      still break assumptions that applications built on top of this protocol may make,
      leading to anything from misinterpretation of data to loss of data or potential
      security bugs.</t>
	
	</section>

	<section title='Use of SHA-1 by the WebSocket Handshake'>

<t>
The WebSocket handshake described in this document doesn't depend on any security
properties of SHA-1, such as collision resistance or resistance to the
second pre-image attack (as described in <xref target="RFC4270"/>).
</t>

	</section>
	
    </section>
    <section title='IANA Considerations'>
      <section title='Registration of New URI Schemes'>
        <section title='Registration of &quot;ws&quot; Scheme' anchor='wsdef'>
        <t>
          A |ws| URI identifies a WebSocket server and resource name.
          <list style='hanging'>
            <t hangText='URI scheme name'>
              <vspace blankLines='0'/>ws
            </t>
            <t hangText='Status'>
              <vspace blankLines='0'/>Permanent
            </t>



            <t hangText='URI scheme syntax'>
              <vspace blankLines='0'/>Using the ABNF <xref target='RFC5234'/>
syntax and ABNF terminals from the URI specification <xref target='RFC3986'/>:

<figure>
                <artwork>
        &quot;ws:&quot; &quot;//&quot; authority path-abempty [ &quot;?&quot; query ]</artwork>
              </figure>

              <vspace blankLines='1'/>
              The &lt;path-abempty&gt; and &lt;query&gt; <xref
target='RFC3986'/> components form the resource name sent to the server to
identify the kind of service desired. Other components have the meanings
described in <xref target='RFC3986'/>.
            </t>
            <t hangText='URI scheme semantics'>
              <vspace blankLines='0'/>The only operation for this scheme is to open a connection using the WebSocket Protocol.
            </t>
            <t hangText='Encoding considerations'>
              <vspace blankLines='0'/>Characters in the host component that are excluded by the syntax
		defined above MUST be converted from Unicode to ASCII as specified in
		<xref target='RFC3987'/> or its replacement. For the purposes of scheme-based
		normalization, Internationalized Domain Name (IDN) forms of the host component and their conversions
		to punycode are considered equivalent (see Section 5.3.3 of <xref target='RFC3987'/>).
              <vspace blankLines='1'/>

              Characters in other components that are excluded by the syntax
defined above MUST be converted from Unicode to ASCII by first encoding the
characters as UTF-8 and then replacing the corresponding bytes using their
percent-encoded form as defined in the URI <xref target='RFC3986'/> and Internationalized Resource
Identifier (IRI) <xref target='RFC3987'/> specifications.
            </t>
            <t hangText='Applications/protocols that use this URI scheme name'>
              <vspace blankLines='0'/>WebSocket Protocol
            </t>
            <t hangText='Interoperability considerations'>
              <vspace blankLines='0'/>Use of WebSocket requires use of HTTP version 1.1 or higher.
            </t>
            <t hangText='Security considerations'>
              <vspace blankLines='0'/>See &quot;Security Considerations&quot; section.
            </t>
            <t hangText='Contact'>
              <vspace blankLines='0'/>HYBI WG &lt;hybi@ietf.org&gt;
            </t>
            <t hangText='Author/Change controller'>
              <vspace blankLines='0'/>IETF &lt;iesg@ietf.org&gt;
            </t>
            <t hangText='References'>
              <vspace blankLines='0'/>RFC 6455
            </t>
          </list>
        </t>
      </section>
      <section title='Registration of &quot;wss&quot; Scheme' anchor='wssdef'>
        <t>
          A |wss| URI identifies a WebSocket server and resource name and
indicates that traffic over that connection is to be protected via TLS
(including standard benefits of TLS such as data confidentiality and integrity
and endpoint authentication).

          <list style='hanging'>
            <t hangText='URI scheme name'>
              <vspace blankLines='0'/>wss
            </t>
            <t hangText='Status'>
              <vspace blankLines='0'/>Permanent
            </t>
            <t hangText='URI scheme syntax'>
              <vspace blankLines='0'/>Using the ABNF <xref target='RFC5234'/>
syntax and ABNF terminals from the URI specification <xref target='RFC3986'/>:

<figure>
                <artwork>
        &quot;wss:&quot; &quot;//&quot; authority path-abempty [ &quot;?&quot; query ]</artwork>
              </figure>

              <vspace blankLines='1'/>
              The &lt;path-abempty&gt; and &lt;query&gt; components form the
resource name sent to the server to identify the kind of service desired. Other
components have the meanings described in <xref target='RFC3986'/>.
            </t>
            <t hangText='URI scheme semantics'>
              <vspace blankLines='0'/>The only operation for this scheme is to open a connection using the WebSocket Protocol, encrypted using TLS.
            </t>
            <t hangText='Encoding considerations'>
              <vspace blankLines='0'/>Characters in the host component that are excluded by the syntax
		defined above MUST be converted from Unicode to ASCII as specified in
		<xref target='RFC3987'/> or its replacement. For the purposes of scheme-based
		normalization IDN forms of the host component and their conversions
		to punycode are considered equivalent (see Section 5.3.3 of <xref target='RFC3987'/>).

              <vspace blankLines='1'/>
              Characters in other components that are excluded by the syntax
defined above MUST be converted from Unicode to ASCII by first encoding the
characters as UTF-8 and then replacing the corresponding bytes using their
percent-encoded form as defined in the URI <xref target='RFC3986'/> and IRI
<xref target='RFC3987'/> specifications.
            </t>
            <t hangText='Applications/protocols that use this URI scheme name'>
              <vspace blankLines='0'/>WebSocket Protocol over TLS
            </t>
            <t hangText='Interoperability considerations'>
              <vspace blankLines='0'/>Use of WebSocket requires use of HTTP version 1.1 or higher.
            </t>
            <t hangText='Security considerations'>
              <vspace blankLines='0'/>See &quot;Security Considerations&quot; section.
            </t>
            <t hangText='Contact'>
              <vspace blankLines='0'/>HYBI WG &lt;hybi@ietf.org&gt;
            </t>
            <t hangText='Author/Change controller'>
              <vspace blankLines='0'/>IETF &lt;iesg@ietf.org&gt;
            </t>
            <t hangText='References'>
              <vspace blankLines='0'/>RFC 6455
            </t>
          </list>
        </t>
      </section>
    </section>
      <section title='Registration of the &quot;WebSocket&quot; HTTP Upgrade Keyword'>
        <t>This section defines a keyword registered in the HTTP
          Upgrade Tokens Registry as per RFC 2817
          <xref target='RFC2817'/>.
          <list style='hanging'>
            <t hangText='Name of token'>
              <vspace blankLines='0'/>WebSocket
            </t>
            <t hangText='Author/Change controller'>
              <vspace blankLines='0'/>IETF &lt;iesg@ietf.org&gt;
            </t>
            <t hangText='Contact'>
              <vspace blankLines='0'/>HYBI &lt;hybi@ietf.org&gt;
            </t>
            <t hangText='References'>
              <vspace blankLines='0'/>RFC 6455
            </t>
          </list>
        </t>
      </section>

      <section title='Registration of New HTTP Header Fields'>
        <section title='Sec-WebSocket-Key'>
        <t>
          This section describes a header field registered in the
          Permanent Message Header Field Names registry <xref target='RFC3864'/>.
        </t>
        <t>
          <list style='hanging'>
            <t hangText='Header field name'>
              <vspace blankLines='0'/>Sec-WebSocket-Key
            </t>
            <t hangText='Applicable protocol'>
              <vspace blankLines='0'/>http
            </t>
            <t hangText='Status'>
              <vspace blankLines='0'/>standard
            </t>
            <t hangText='Author/Change controller'>
              <vspace blankLines='0'/>IETF
            </t>
            <t hangText='Specification document(s)'>
              <vspace blankLines='0'/>RFC 6455
            </t>
            <t hangText='Related information'>
              <vspace blankLines='0'/>This header field is only used for WebSocket opening handshake.
            </t>
          </list>
        </t>
        <t>The |Sec-WebSocket-Key| header field is used in the WebSocket opening handshake.
	It is sent from the client to the server to provide part of the information used by
	the server to prove that it received a valid WebSocket opening handshake.
	This helps ensure that the server does not accept connections from non-WebSocket
	clients (e.g., HTTP clients) that are being abused to send data to unsuspecting
	WebSocket servers.</t>

        <t>The |Sec-WebSocket-Key| header field MUST NOT appear more than once in an HTTP request.</t>

      </section>
      <section title='Sec-WebSocket-Extensions' anchor='swe'>
        <t>
          This section describes a header field for registration in
          the Permanent Message Header Field Names registry <xref target='RFC3864'/>.
        </t>
        <t>
          <list style='hanging'>
            <t hangText='Header field name'>
              <vspace blankLines='0'/>Sec-WebSocket-Extensions
            </t>
            <t hangText='Applicable protocol'>
              <vspace blankLines='0'/>http
            </t>
            <t hangText='Status'>
              <vspace blankLines='0'/>standard
            </t>
            <t hangText='Author/Change controller'>
              <vspace blankLines='0'/>IETF
            </t>
            <t hangText='Specification document(s)'>
              <vspace blankLines='0'/>RFC 6455
            </t>
            <t hangText='Related information'>
              <vspace blankLines='0'/>This header field is only used for WebSocket opening handshake.
            </t>
          </list>
        </t>
        <t>The |Sec-WebSocket-Extensions| header field is used in the WebSocket opening handshake.
	It is initially sent from the client to the server, and then subsequently sent from
	the server to the client, to agree on a set of protocol-level extensions to use for
	the duration of the connection.</t>

        <t>The |Sec-WebSocket-Extensions| header field MAY appear multiple times in an HTTP request
	(which is logically the same as a single |Sec-WebSocket-Extensions| header field that contains all values.
        However, the |Sec-WebSocket-Extensions| header field MUST NOT appear more than once in an HTTP response.</t>

      </section>
        <section title='Sec-WebSocket-Accept'>
          <t>
            This section describes a header field registered in the
            Permanent Message Header Field Names registry <xref target='RFC3864'/>.
          </t>
          <t>
            <list style='hanging'>
              <t hangText='Header field name'>
                <vspace blankLines='0'/>Sec-WebSocket-Accept
              </t>
              <t hangText='Applicable protocol'>
                <vspace blankLines='0'/>http
              </t>
              <t hangText='Status'>
                <vspace blankLines='0'/>standard
              </t>
              <t hangText='Author/Change controller'>
                <vspace blankLines='0'/>IETF
              </t>
              <t hangText='Specification document(s)'>
                <vspace blankLines='0'/>RFC 6455
              </t>
              <t hangText='Related information'>
                <vspace blankLines='0'/>This header field is only used for the WebSocket opening handshake.
              </t>
            </list>
          </t>

          <t>The |Sec-WebSocket-Accept| header field is used in the WebSocket opening handshake.
	  It is sent from the server to the client to confirm that the server is willing to initiate
	  the WebSocket connection.</t>

          <t>The |Sec-WebSocket-Accept| header MUST NOT appear more than once in an HTTP response.</t>

        </section>

        <section title='Sec-WebSocket-Protocol' anchor='swp'>
          <t>
            This section describes a header field registered in the
            Permanent Message Header Field Names registry <xref target='RFC3864'/>.
          </t>
          <t>
            <list style='hanging'>
              <t hangText='Header field name'>
                <vspace blankLines='0'/>Sec-WebSocket-Protocol
              </t>
              <t hangText='Applicable protocol'>
                <vspace blankLines='0'/>http
              </t>
              <t hangText='Status'>
                <vspace blankLines='0'/>standard
              </t>
              <t hangText='Author/Change controller'>
                <vspace blankLines='0'/>IETF
              </t>
              <t hangText='Specification document(s)'>
                <vspace blankLines='0'/>RFC 6455
              </t>
              <t hangText='Related information'>
                <vspace blankLines='0'/>This header field is only used for the WebSocket opening handshake.
              </t>
            </list>
          </t>
          <t>The |Sec-WebSocket-Protocol| header field is used in the WebSocket opening handshake.
	  It is sent from the client to the server and back from the server to the client to confirm
	  the subprotocol of the connection. This enables scripts to both select a subprotocol and
	  be sure that the server agreed to serve that subprotocol.</t>

          <t>The |Sec-WebSocket-Protocol| header field MAY appear multiple times in an HTTP request
	  (which is logically the same as a single |Sec-WebSocket-Protocol| header field that contains all values).
          However, the |Sec-WebSocket-Protocol| header field MUST NOT appear more than once in an HTTP response.</t>

        </section>
        <section title='Sec-WebSocket-Version'>
          <t>
            This section describes a header field registered in the
            Permanent Message Header Field Names registry <xref target='RFC3864'/>.
          </t>
          <t>
            <list style='hanging'>
              <t hangText='Header field name'>
                <vspace blankLines='0'/>Sec-WebSocket-Version
              </t>
              <t hangText='Applicable protocol'>
                <vspace blankLines='0'/>http
              </t>
              <t hangText='Status'>
                <vspace blankLines='0'/>standard
              </t>
              <t hangText='Author/Change controller'>
                <vspace blankLines='0'/>IETF
              </t>
              <t hangText='Specification document(s)'>
                <vspace blankLines='0'/>RFC 6455
              </t>
              <t hangText='Related information'>
                <vspace blankLines='0'/>This header field is only used for the WebSocket opening handshake.
              </t>
            </list>
          </t>
          <t>
            The |Sec-WebSocket-Version| header field is used in the WebSocket opening handshake.
            It is sent from the client to the server to indicate the protocol version of
            the connection. This enables servers to correctly interpret the opening handshake
            and subsequent data being sent from the data, and close the connection if the server
            cannot interpret that data in a safe manner.
            The |Sec-WebSocket-Version| header field is also sent from the server to the client
            on WebSocket handshake error, when the version received from the client does not match
            a version understood by the server. In such a case, the header field includes
            the protocol version(s) supported by the server.
          </t>
          <t>
            Note that there is no expectation that higher version numbers are necessarily
            backward compatible with lower version numbers.
          </t>

          <t>The |Sec-WebSocket-Version| header field MAY appear multiple times in an HTTP response
	  (which is logically the same as a single |Sec-WebSocket-Version| header field that contains all values).
          However, the |Sec-WebSocket-Version| header field MUST NOT appear more than once in an HTTP request.</t>

        </section>        
        
      </section>

      
      <section title='WebSocket Extension Name Registry' anchor='enr'>
        <t>
          This specification creates a new IANA registry for
          WebSocket Extension names to be used with the WebSocket Protocol in
          accordance with the principles set out in RFC 5226
          <xref target='RFC5226'/>.
        </t>
        <t>As part of this registry, IANA maintains the following
          information:
          <list style='hanging'>
            <t hangText='Extension Identifier'>
              <vspace blankLines='0'/>The identifier of the extension, as will
              be used in the |Sec-WebSocket-Extensions| header field registered in
              <xref target='swe'/> of this specification. The value must
              conform to the requirements for an extension-token as defined in
              <xref target='negotiation'/> of this specification.
            </t>
            <t hangText='Extension Common Name'>
              <vspace blankLines='0'/>The name of the extension, as the
              extension is generally referred to.
            </t>
            <t hangText='Extension Definition'>
              <vspace blankLines='0'/>A reference to the document in which the
              extension being used with the WebSocket Protocol is defined.
            </t>
            <t hangText='Known Incompatible Extensions'>
              <vspace blankLines='0'/>A list of extension identifiers with which
              this extension is known to be incompatible.
            </t>
          </list>
        </t>
        <t>WebSocket Extension names are to be subject to the &quot;First Come First Served&quot;
          IANA registration policy <xref target='RFC5226'/>.
        </t>
        <t>There are no initial values in this registry.
        </t>

      </section>

      <section title='WebSocket Subprotocol Name Registry' anchor='spr'>
        <t>
          This specification creates a new IANA registry for
          WebSocket Subprotocol names to be used with the WebSocket Protocol in
          accordance with the principles set out in RFC 5226
          <xref target='RFC5226'/>.
        </t>
        <t>As part of this registry, IANA maintains the following
          information:
          <list style='hanging'>
            <t hangText='Subprotocol Identifier'>
              <vspace blankLines='0'/>The identifier of the subprotocol, as will
              be used in the |Sec-WebSocket-Protocol| header field registered in
              <xref target='swp'/> of this specification. The value must
              conform to the requirements given in
              item 10 of
              <xref target='clienths'/> of this specification -- namely, the
              value must be a token as defined by RFC 2616 <xref target='RFC2616'/>.
            </t>
            <t hangText='Subprotocol Common Name'>
              <vspace blankLines='0'/>The name of the subprotocol, as the
              subprotocol is generally referred to.
            </t>
            <t hangText='Subprotocol Definition'>
              <vspace blankLines='0'/>A reference to the document in which the
              subprotocol being used with the WebSocket Protocol is defined.
            </t>
          </list>
        </t>
        <t>WebSocket Subprotocol names are to be subject to the &quot;First Come First
          Served&quot; IANA registration policy <xref target='RFC5226'/>.
        </t>
      </section>

      <section title='WebSocket Version Number Registry'>
        <t>
          This specification creates a new IANA registry for
          WebSocket Version Numbers to be used with the WebSocket Protocol in
          accordance with the principles set out in RFC 5226
          <xref target='RFC5226'/>.
        </t>
        <t>As part of this registry, IANA maintains the following
          information:
          <list style='hanging'>
            <t hangText='Version Number'>
              <vspace blankLines='0'/>The version number to be used in the |Sec-WebSocket-Version| is
      specified in <xref target='clienths'/> of this specification.  The value must be
      a non-negative integer in the range between 0 and 255 (inclusive).
            </t>
            <t hangText='Reference'>
              <vspace blankLines='0'/>The RFC requesting a new version number
or a draft name with version number (see below).
            </t>

            <t hangText='Status'>
              <vspace blankLines='0'/>Either "Interim" or "Standard". See below
for description.
            </t>
          </list>
        </t>

<t>A version number is designated as either &quot;Interim&quot; or &quot;Standard&quot;.</t>

<t>
   A &quot;Standard&quot; version number is documented in an RFC and used to
   identify a major, stable version of the WebSocket protocol, such as
   the version defined by this RFC.  &quot;Standard&quot; version numbers are
   subject to the &quot;IETF Review&quot; IANA registration policy <xref target='RFC5226'/>.
</t>
<t>
   An &quot;Interim&quot; version number is documented in an Internet-Draft and
   used to help implementors identify and interoperate with deployed
   versions of the WebSocket protocol, such as versions developed
   before the publication of this RFC.  &quot;Interim&quot; version numbers are
   subject to the &quot;Expert Review&quot; IANA registration policy <xref target='RFC5226'/>,
   with the chairs of the HYBI Working Group (or, if the working group
   closes, the Area Directors for the IETF Applications Area) being the
   initial Designated Experts.
</t>
        <t>IANA has added initial values to the registry as follows.

          <figure>
            <artwork>
+--------+-----------------------------------------+----------+
|Version |                Reference                |  Status  |
| Number |                                         |          |
+--------+-----------------------------------------+----------+    
| 0      + draft-ietf-hybi-thewebsocketprotocol-00 | Interim  |
+--------+-----------------------------------------+----------+
| 1      + draft-ietf-hybi-thewebsocketprotocol-01 | Interim  |
+--------+-----------------------------------------+----------+
| 2      + draft-ietf-hybi-thewebsocketprotocol-02 | Interim  |
+--------+-----------------------------------------+----------+
| 3      + draft-ietf-hybi-thewebsocketprotocol-03 | Interim  |
+--------+-----------------------------------------+----------+
| 4      + draft-ietf-hybi-thewebsocketprotocol-04 | Interim  |
+--------+-----------------------------------------+----------+
| 5      + draft-ietf-hybi-thewebsocketprotocol-05 | Interim  |
+--------+-----------------------------------------+----------+
| 6      + draft-ietf-hybi-thewebsocketprotocol-06 | Interim  |
+--------+-----------------------------------------+----------+
| 7      + draft-ietf-hybi-thewebsocketprotocol-07 | Interim  |
+--------+-----------------------------------------+----------+
| 8      + draft-ietf-hybi-thewebsocketprotocol-08 | Interim  |
+--------+-----------------------------------------+----------+
| 9      +                Reserved                 |          |
+--------+-----------------------------------------+----------+
| 10     +                Reserved                 |          |
+--------+-----------------------------------------+----------+
| 11     +                Reserved                 |          |
+--------+-----------------------------------------+----------+
| 12     +                Reserved                 |          |
+--------+-----------------------------------------+----------+
| 13     +                RFC 6455                 | Standard |
+--------+-----------------------------------------+----------+
</artwork>
          </figure>
        </t>

      </section>

      <section title='WebSocket Close Code Number Registry'>
        <t>
          This specification creates a new IANA registry for
          WebSocket Connection Close Code Numbers in
          accordance with the principles set out in RFC 5226
          <xref target='RFC5226'/>.
        </t>
        <t>As part of this registry, IANA maintains the following
          information:
          <list style='hanging'>
            <t hangText='Status Code'>
              <vspace blankLines='0'/>The Status Code denotes a reason for
              a WebSocket connection closure as per <xref
                target='status_codes'/> of this document. The status code is an
              integer number between 1000 and 4999 (inclusive).
            </t>
            <t hangText='Meaning'>
              <vspace blankLines='0'/>The meaning of the status code.
              Each status code has to have a unique meaning.
            </t>
            <t hangText='Contact'>
              <vspace blankLines='0'/>A contact for the entity reserving the
              status code.
            </t>
            <t hangText='Reference'>
              <vspace blankLines='0'/>The stable document requesting the status
              codes and defining their meaning. This is required for status codes in the
              range 1000-2999 and recommended for status codes in the range 3000-3999.
            </t>
          </list>
        </t>
        <t>WebSocket Close Code Numbers are subject to different
          registration requirements depending on their range. 
          Requests for
          status codes for use by this protocol and its subsequent versions or
          extensions are subject to any one of the "Standards Action",
          "Specification Required" (which implies "Designated Expert"), or "IESG Review"
          IANA registration policies and should be granted
          in the range 1000-2999. Requests for status codes for use by libraries,
          frameworks, and applications are subject to the "First Come First Served"
          IANA registration policy and should be granted in the range 3000-3999.
          The range of status codes from 4000-4999 is designated for Private
Use. &nbsp;Requests should indicate whether they are requesting
          status codes for use by the WebSocket Protocol (or a future version of
          the protocol), by extensions, or by libraries/frameworks/applications.
        </t>
        <t>IANA has added initial values to the registry
        as follows.
          <figure>
            <artwork>
  |Status Code | Meaning         | Contact       | Reference |
 -+------------+-----------------+---------------+-----------|
  | 1000       | Normal Closure  | hybi@ietf.org | RFC 6455  |
 -+------------+-----------------+---------------+-----------|
  | 1001       | Going Away      | hybi@ietf.org | RFC 6455  |
 -+------------+-----------------+---------------+-----------|
  | 1002       | Protocol error  | hybi@ietf.org | RFC 6455  |
 -+------------+-----------------+---------------+-----------|
  | 1003       | Unsupported Data| hybi@ietf.org | RFC 6455  |
 -+------------+-----------------+---------------+-----------|
  | 1004       | ---Reserved---- | hybi@ietf.org | RFC 6455  |
 -+------------+-----------------+---------------+-----------|
  | 1005       | No Status Rcvd  | hybi@ietf.org | RFC 6455  |
 -+------------+-----------------+---------------+-----------|
  | 1006       | Abnormal Closure| hybi@ietf.org | RFC 6455  |
 -+------------+-----------------+---------------+-----------|
  | 1007       | Invalid frame   | hybi@ietf.org | RFC 6455  |
  |            | payload data    |               |           |
 -+------------+-----------------+---------------+-----------|
  | 1008       | Policy Violation| hybi@ietf.org | RFC 6455  |
 -+------------+-----------------+---------------+-----------|
  | 1009       | Message Too Big | hybi@ietf.org | RFC 6455  |
 -+------------+-----------------+---------------+-----------|
  | 1010       | Mandatory Ext.  | hybi@ietf.org | RFC 6455  |
 -+------------+-----------------+---------------+-----------|
  | 1011       | Internal Server | hybi@ietf.org | RFC 6455  |
  |            | Error           |               |           |
 -+------------+-----------------+---------------+-----------|
  | 1015       | TLS handshake   | hybi@ietf.org | RFC 6455  |
 -+------------+-----------------+---------------+-----------|
</artwork>
          </figure>
        </t>
      </section>
      <section title='WebSocket Opcode Registry'>
        <t>
          This specification creates a new IANA registry for
          WebSocket Opcodes in
          accordance with the principles set out in RFC 5226
          <xref target='RFC5226'/>.
        </t>
        <t>As part of this registry, IANA maintains the following
          information:
          <list style='hanging'>
            <t hangText='Opcode'>
              <vspace blankLines='0'/>The opcode denotes the frame type of the
              WebSocket frame, as defined in <xref target='baseframing'/>.
              The opcode is an integer number between 0 and 15, inclusive.
            </t>
            <t hangText='Meaning'>
              <vspace blankLines='0'/>The meaning of the opcode value.
            </t>
            <t hangText='Reference'>
              <vspace blankLines='0'/>The specification requesting the opcode.
            </t>
          </list>
        </t>
        <t>WebSocket Opcode numbers are subject to the &quot;Standards Action&quot;
          IANA registration policy <xref target='RFC5226'/>.
        </t>
        <t>IANA has added initial values to the registry as follows.
          <figure>
            <artwork>
  |Opcode  | Meaning                             | Reference |
 -+--------+-------------------------------------+-----------|
  | 0      | Continuation Frame                  | RFC 6455  |
 -+--------+-------------------------------------+-----------|
  | 1      | Text Frame                          | RFC 6455  |
 -+--------+-------------------------------------+-----------|
  | 2      | Binary Frame                        | RFC 6455  |
 -+--------+-------------------------------------+-----------|
  | 8      | Connection Close Frame              | RFC 6455  |
 -+--------+-------------------------------------+-----------|
  | 9      | Ping Frame                          | RFC 6455  |
 -+--------+-------------------------------------+-----------|
  | 10     | Pong Frame                          | RFC 6455  |
 -+--------+-------------------------------------+-----------|
</artwork>
          </figure>
        </t>
      </section>
      <section title='WebSocket Framing Header Bits Registry'>
        <t>
          This specification creates a new IANA registry for
          WebSocket Framing Header Bits in
          accordance with the principles set out in RFC 5226
          <xref target='RFC5226'/>. This registry controls assignment of the
          bits marked RSV1, RSV2, and RSV3 in <xref target='baseframing'/>.
        </t>
        <t>These bits are reserved for future versions or extensions of this
          specification.</t>
        <t>WebSocket Framing Header Bits assignments are subject to the &quot;Standards Action&quot;
          IANA registration policy <xref target='RFC5226'/>.
        </t>
      </section>
    </section>
    <section title='Using the WebSocket Protocol from Other Specifications'
        anchor='otherspecs'>
      <t>The WebSocket Protocol is intended to be used by another specification to provide a generic mechanism for dynamic author-defined content, e.g., in a specification defining a scripted API.</t>
      <t>
        Such a specification first needs to <spanx style='emph'>Establish a WebSocket Connection</spanx>, providing that algorithm with:
        <list style='symbols'>
          <t>The destination, consisting of a /host/ and a /port/.</t>
          <t>A /resource name/, which allows for multiple services to be identified at one host and port.</t>
          <t>A /secure/ flag, which is true if the connection is to be encrypted and false otherwise.</t>
          <t>
            An ASCII serialization of an origin <xref target='RFC6454'/> that
is being made responsible for the connection.
          </t>
          <t>Optionally, a string identifying a protocol that is to be layered over the WebSocket connection.</t>
        </list>
      </t>
      <t>The /host/, /port/, /resource name/, and /secure/ flag are usually obtained from a URI using the steps to parse a WebSocket URI&apos;s components. These steps fail if the URI does not specify a WebSocket.</t>
      <t>If at any time the connection is to be closed, then the specification needs to use the <spanx style='emph'>Close the WebSocket Connection</spanx> algorithm (<xref target='close_wsc'/>).</t>
      <t><xref target='is_closed'/> defines when <spanx style='emph'>The
          WebSocket Connection is Closed</spanx>.</t>
      <t>While a connection is open, the specification will need to handle the cases when <spanx style='emph'>A WebSocket Message Has Been Received</spanx> (<xref target='rcv_data'/>).</t>
      <t>To send some data /data/ to an open connection, the specification needs to <spanx style='emph'>Send a WebSocket Message</spanx> (<xref target='send_data'/>).</t>
    </section>
    <section title='Acknowledgements'>
      <t>
        Special thanks are due to Ian Hickson, who was the original author and
editor of this protocol. The initial design of this specification benefitted
from the participation of many people in the WHATWG and WHATWG mailing
list. Contributions to that specification are not tracked by section, but a
list of all who contributed to that specification is given in the WHATWG HTML
specification at http://whatwg.org/html5.
      </t>
      <t>Special thanks also to John Tamplin for providing a significant amount of text for the "Data Framing" section of this specification.</t>
      <t>Special thanks also to Adam Barth for providing a significant amount of text and background research for the "Data Masking" section of this specification.</t>

      <t>
      Special thanks to Lisa Dusseault for the Apps Area review (and for helping to start
      this work), Richard Barnes for the Gen-Art review, and Magnus Westerlund for
      the Transport Area Review. Special thanks to HYBI WG past and present WG chairs
      who tirelessly worked behind the scene to move this work toward completion:
      Joe Hildebrand, Salvatore Loreto, and Gabriel Montenegro. And last but not least,
      special thank you to the responsible Area Director Peter Saint-Andre.
      </t>

      <t>
        Thank you to the following people who participated in discussions on the HYBI WG
        mailing list and contributed ideas and/or provided detailed reviews (the list is likely
        to be incomplete):

        Greg Wilkins, John Tamplin, Willy Tarreau, Maciej Stachowiak, Jamie Lokier,
        Scott Ferguson, Bjoern Hoehrmann, Julian Reschke, Dave Cridland, Andy Green,
        Eric Rescorla, Inaki Baz Castillo, Martin Thomson, Roberto Peon, Patrick McManus,
        Zhong Yu, Bruce Atherton, Takeshi Yoshino, Martin J. Duerst, James Graham,
        Simon Pieters, Roy T. Fielding, Mykyta Yevstifeyev, Len Holgate, Paul Colomiets,
	Piotr Kulaga, Brian Raymor, Jan Koehler, Joonas Lehtolahti, Sylvain Hellegouarch,
	Stephen Farrell, Sean Turner, Pete Resnick, Peter Thorson, Joe Mason, John Fallows,
	and Alexander Philippou.

        Note that people listed above didn't necessarily endorse the end result of this work.</t>
    </section>
  </middle>

<?rfc rfcedstyle="no"?>
  <back>
    <references title="Normative References">

<reference anchor="ANSI.X3-4.1986">
<front>
<title>Coded Character Set - 7-bit American Standard Code for Information
Interchange</title>
<author>
<organization>American National Standards Institute</organization>
</author>
<date month="" year="1986" />
</front>

<seriesInfo name="ANSI" value="X3.4" />

</reference>

<reference anchor="FIPS.180-3" target="http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf">
<front>
<title>Secure Hash Standard</title>
<author>
<organization>National Institute of Standards and Technology</organization>
</author>
<date month="October" year="2008" />
</front>

<seriesInfo name="FIPS" value="PUB 180-3" />

</reference>


      <?rfc include='reference.RFC.1928.xml'?> 
      <?rfc include='reference.RFC.2119.xml'?>
      <?rfc include='reference.RFC.2616.xml'?>
      <?rfc include='reference.RFC.2817.xml'?> 
      <?rfc include='reference.RFC.2818.xml'?> 
      <?rfc include='reference.RFC.3629.xml'?>
      <?rfc include='reference.RFC.3864.xml'?>
      <?rfc include='reference.RFC.3986.xml'?>
      <?rfc include='reference.RFC.3987.xml'?>
      <?rfc include='reference.RFC.4086.xml'?>
      <?rfc include='reference.RFC.5246.xml'?>
      <?rfc include='reference.RFC.6066.xml'?>
      <?rfc include='reference.RFC.4648.xml'?> 
      <?rfc include='reference.RFC.5226.xml'?>
      <?rfc include='reference.RFC.5234.xml'?>


<reference anchor='RFC6454'>
<front>
<title>The Web Origin Concept</title>

<author initials='A' surname='Barth' fullname='Adam Barth'>
    <organization />
</author>

<date month='December' year='2011' />

</front>
<seriesInfo name="RFC" value="6454"/>

</reference>



    </references>
    <references title="Informative References">


<reference anchor='WSAPI'
target='http://www.w3.org/TR/2011/WD-websockets-20110929/'>
<front>
<title>The WebSocket API</title>
<author initials='I.E.' surname='Hickson' fullname='Ian Hickson'>
    <organization>Google, Inc.</organization>
</author>
<date year='2011' month='September' day='29'/>
</front>
<seriesInfo name='W3C Working Draft' value='WD-websockets-20110929'/>
<annotation>
Latest version available at
<eref target='http://www.w3.org/TR/websockets/'/>.
</annotation>
</reference>


      <?rfc include='reference.RFC.4122.xml'?> 
      <?rfc include='reference.RFC.6265.xml'?> 
      <?rfc include='reference.RFC.5321.xml'?> 
      <?rfc include='reference.RFC.6202.xml'?>
      <?rfc include='reference.RFC.4270.xml'?>


<reference anchor='W3C.REC-wsc-ui-20100812'
           target='http://www.w3.org/TR/2010/REC-wsc-ui-20100812/'>
<front>
<title>Web Security Context: User Interface Guidelines</title>

<author initials='T.' surname='Roessler' fullname='Thomas Roessler'>
    <organization />
</author>

<author initials='A.' surname='Saldhana' fullname='Anil Saldhana'>
    <organization />
</author>

<date month='August' day='12' year='2010' />
</front>

<seriesInfo name='World Wide Web Consortium Recommendation'
value='REC-wsc-ui-20100812' />
<format type='HTML' target='http://www.w3.org/TR/2010/REC-wsc-ui-20100812' />
<annotation>
Latest version available at
<eref target='http://www.w3.org/TR/wsc-ui/'/>.
</annotation>
</reference>


      <reference anchor='TALKING'
target='http://w2spconf.com/2011/papers/websocket.pdf'>

        <front>
          <title>Talking to Yourself for Fun and Profit</title>
          <author initials='L-S.' surname='Huang' fullname='Lin-Shung Huang'>
            <organization>Carnegie Mellon University</organization>
          </author>

          <author initials='E. Y.' surname='Chen' fullname='Eric Y. Chen'>
            <organization>Carnegie Mellon University</organization>
          </author>

          <author initials='A.' surname='Barth' fullname='Adam Barth'>
            <organization>Google, Inc.</organization>
          </author>

          <author initials='E.' surname='Rescorla' fullname='Eric Rescorla'>
            <organization>RTFM</organization>
          </author>

          <author initials='C.' surname='Jackson' fullname='Collin Jackson'>
            <organization>Carnegie Mellon University</organization>
          </author>


          <date year="2010"/>
        </front>
      </reference>

<reference anchor='XMLHttpRequest'
target='http://www.w3.org/TR/2010/CR-XMLHttpRequest-20100803/'>
<front>
<title>XMLHttpRequest</title>
<author initials='A.' surname='van Kesteren' fullname='Anne van Kesteren' role="editor">
    <organization>Opera Software ASA</organization>
</author>
<date year='2010' month='August' day='03'/>
</front>
<seriesInfo name='W3C Candidate Recommendation'
value='CR-XMLHttpRequest-20100803'/>
<annotation>
Latest version available at
<eref target='http://www.w3.org/TR/XMLHttpRequest/'/>.
</annotation>
</reference>


    </references>
<?rfc rfcedstyle="yes"?>
  </back>

</rfc>
