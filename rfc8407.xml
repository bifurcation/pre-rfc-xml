<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<?rfc toc="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>

<rfc ipr="trust200902"  obsoletes="6087" category="bcp" submissionType="IETF" consensus="yes"
     number="8407" seriesNo="216">
    <front>
    <title abbrev="Guidelines for YANG Documents">Guidelines for Authors and Reviewers of Documents Containing&nbsp;YANG&nbsp;Data&nbsp;Models</title>

    <author initials="A" surname="Bierman" fullname='Andy Bierman' >
      <organization>YumaWorks</organization>
      <address>
        <email>andy@yumaworks.com</email>
      </address>
    </author>
	<date month="October" year="2018"/>

    <abstract>
      <t>	
This memo provides guidelines for authors and reviewers
of specifications containing YANG modules.
Recommendations and
procedures are defined, which are intended to
increase interoperability and usability
of Network Configuration Protocol (NETCONF)
and RESTCONF protocol implementations that utilize
YANG modules. This document obsoletes RFC 6087.
	</t>
</abstract>
</front>
<middle>
<section title="Introduction">
    <t>
The standardization of network configuration interfaces for use
with network configuration management protocols,
such as the Network Configuration Protocol <xref target="RFC6241"/>
and the RESTCONF protocol <xref target="RFC8040"/>,
requires a modular set of data models that can be reused
and extended over time.
    </t>
    <t>
This document defines a set of usage guidelines for
documents containing YANG 1.1 <xref target="RFC7950"/>
and YANG 1.0 <xref target="RFC6020"/> data models.  YANG is used to define
the data structures, protocol operations, and notification content
used within a NETCONF and/or RESTCONF server.
A NETCONF or RESTCONF server that supports a particular
YANG module will support client NETCONF and/or RESTCONF operation requests,
as indicated by the specific content defined in the YANG module.
    </t>
    <t>
Many YANG constructs are defined as optional to use, such as
the "description" statement.  However, in order to
make YANG modules more useful,
it is desirable to define a set of usage guidelines that entails
a higher level of compliance than the minimum level
defined in the YANG specification <xref target="RFC7950"/>.
    </t>
    <t>
In addition, YANG allows constructs such as infinite length
identifiers and string values, or top-level mandatory nodes,
that a compliant server is not required to support.
Only constructs that all servers are required to support
can be used in IETF YANG modules.
    </t>
    <t>
This document defines usage guidelines related to
the NETCONF operations layer and NETCONF
content layer, as defined in <xref target="RFC6241"/>,
and the RESTCONF methods and RESTCONF
resources, as defined in <xref target="RFC8040"/>.
    </t>
    <t>
These guidelines are intended to be used by authors and
reviewers to improve the readability
and interoperability of published YANG data models.
    </t>
    <t>
Note that this document is not a YANG tutorial, and the reader
is expected to know the YANG data modeling language before
implementing the guidance in this document.
    </t>
<section title="Changes since RFC 6087">
  <t>

The following changes have been made to the guidelines published in <xref target="RFC6087"/>:
    </t>
<t>
 <list style="symbols">
   <t>
Updated NETCONF reference from RFC 4741 to RFC 6241
 </t>
 <t>
Updated NETCONF over the Secure Shell (SSH) citation from RFC 4742 to RFC 6242
 </t>
 <t>
Updated YANG Types reference from RFC 6021 to RFC 6991
 </t>
 <t>
Updated obsolete URLs for IETF resources
 </t>
 <t>
Changed top-level data node guideline
 </t>
 <t>
Clarified XML Path Language (XPath) usage for a literal value representing a YANG identity
 </t>
 <t>
Clarified XPath usage for a when-stmt
 </t>
 <t>
Clarified XPath usage for "preceding&#8209;sibling" and "following&#8209;sibling" axes
 </t>
 <t>
Added terminology guidelines
 </t>
<t>
Added mention of RFC 8174, which updates RFC 2119 by clarifying the use of capitalized key words
</t>
 <t>
Added YANG tree diagram guidelines
 </t>
 <t>
Updated XPath guidelines for type conversions and function library usage
 </t>
 <t>
Updated "Data Types" section
 </t>
 <t>
Updated "Notification Definitions" section
 </t>
 <t>
Clarified conditional key leaf nodes
 </t>
 <t>
Clarified usage of "uint64" and "int64" data types
 </t>
 <t>
Added text on YANG feature usage
 </t>
 <t>
Added "Identifier Naming Conventions" section
 </t>
 <t>
Clarified use of mandatory nodes with conditional augmentations
 </t>
 <t>
Clarified namespace and domain conventions for example modules
 </t>
 <t>
Clarified conventions for identifying code components
 </t>
 <t>
Added YANG 1.1 guidelines
 </t>
 <t>
Added "YANG Data Node Constraints" section
 </t>
 <t>
Added mention of the RESTCONF protocol
 </t>
 <t>
Added guidelines for datastores revised by the Network Management Datastore Architecture (NMDA)
 </t>
 </list>
</t>
</section>
</section>
<section title="Terminology">
   <t>
The following terms are used throughout this document:
    </t>
<t>
 <list style="symbols">
 <t>
published: A stable release of a module or submodule.
For example, the &quot;Request for Comments&quot; described in
Section 2.1 of <xref target="RFC2026"/> is considered a stable publication.
 </t>
 <t>
unpublished: An unstable release of a module or submodule.
For example the &quot;Internet&#8209;Draft&quot; described in
Section 2.2 of <xref target="RFC2026"/> is considered an unstable publication
that is a work in progress, subject to change at any time.
 </t>
 <t>
YANG fragment: A set of YANG statements that are not intended
to represent a complete YANG module or submodule.  These statements
are not intended for actual use, except to provide an example
of YANG statement usage.  The invalid syntax &quot;...&quot; is sometimes
used to indicate that additional YANG statements would be
present in a real YANG module.
 </t>
 <t>
YANG tree diagram: A diagram representing the contents
of a YANG module, as defined in
<xref target="RFC8340"/>. It is also called a &quot;tree diagram&quot;.
 </t>
 </list>
</t>

  
<section title="NETCONF Terms">
    <t>
The following terms are defined in <xref target="RFC6241"/>
and are not redefined here:
    </t>
<t>
 <list style="symbols">
 <t>
capabilities
 </t>
 <t>
client
 </t>
 <t>
operation
 </t>
 <t>
server
 </t>
 </list>
</t>
</section>
<section title="YANG Terms">
    <t>
The following terms are defined in <xref target="RFC7950"/>
and are not redefined here:
    </t>
<t>
 <list style="symbols">
 <t>
data node
 </t>
 <t>
module
 </t>
 <t>
namespace
 </t>
 <t>
submodule
 </t>
 <t>
version
 </t>
 <t>
YANG
 </t>
 <t>
YIN
 </t>
 </list>
</t>
    <t>
Note that the term &apos;module&apos; may be used as a generic term for a YANG module or submodule.
When describing properties that are specific to submodules,
the term &apos;submodule&apos; is used instead.
    </t>
</section>
<section title="NMDA Terms">
    <t>
The following terms are defined in <xref target="RFC8342"/>
and are not redefined here:
    </t>
<t>
 <list style="symbols">
 <t>
configuration
 </t>
 <t>
conventional configuration datastore
 </t>
 <t>
datastore
 </t>
 <t>
operational state
 </t>
 <t>
operational state datastore
 </t>
 </list>
</t>
</section>
<section title="Requirements Notation">
   <t>
The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;,
&quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;,
and &quot;OPTIONAL&quot; in this document are to be interpreted as
described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when,
they appear in all capitals, as shown here.
    </t>
</section>
</section>

<section title="General Documentation Guidelines">
    <t>
YANG modules under review are likely to be contained in
Internet-Drafts (I-Ds).  All guidelines for I-D authors <xref
target="ID-Guidelines"/> MUST be followed.  The
guidelines for RFCs should be followed and are defined
in the following: <xref target="RFC7322"/> (and any future RFCs that obsolete it), <xref target="RFC-STYLE"/>, and <xref
target="RFC7841"/>.

    </t>
    <t>
The following sections MUST be present in an I-D
containing a module:
    </t>
<t>
 <list style="symbols">
   <t>

     
Narrative sections
 </t>
 <t>
Definition sections
 </t>
 <t>
Security Considerations section
 </t>
 <t>
IANA Considerations section
 </t>
 <t>
References section
 </t>
 </list>
</t>
    <t>
There are three usage scenarios for YANG that can appear in
an I-D or RFC:
    </t>
<t>
 <list style="symbols">
 <t>
normative module or submodule
 </t>
 <t>
example module or submodule
 </t>
 <t>
example YANG fragment not part of any module or submodule
 </t>
 </list>
</t>
    <t>
The guidelines in this document refer mainly to a normative
module or submodule but may be applicable to
example modules and YANG fragments as well.
    </t>
<section title="Module Copyright" anchor="MODULECOPY">
    <t>
The module "description" statement MUST contain a reference to
the latest approved IETF Trust Copyright statement,
which is available online at:
    </t>
        <figure>
            <artwork><![CDATA[
    <https://trustee.ietf.org/license-info/>
            ]]></artwork>
        </figure>
</section>
<section title="Code Components">
    <t>
Each normative YANG module or submodule contained within
an I-D or RFC
is considered to be a code component.  The strings &quot;&lt;CODE BEGINS&gt;&quot;
and &quot;&lt;CODE ENDS&gt;&quot; MUST be used to identify each code component.
    </t>
    <t>
The &quot;&lt;CODE BEGINS&gt;&quot; tag SHOULD be followed by a string identifying
the file name specified in Section 5.2 of <xref target="RFC7950"/>.
The name string form that includes the revision date SHOULD be used.
The revision date MUST match the date used in the most recent revision
of the module.
    </t>

    <t>
The following example is for the &quot;2016&#8209;03&#8209;20&quot; revision
of the &quot;ietf&#8209;foo&quot; module:
    </t>
<t>&lt;CODE BEGINS> file "ietf-foo@2016-03-20.yang"</t>
        <figure>
            <artwork><![CDATA[
    module ietf-foo {
      namespace "urn:ietf:params:xml:ns:yang:ietf-foo";
      prefix "foo";
      organization "...";
      contact "...";
      description "...";
      revision 2016-03-20 {
        description "Latest revision";
        reference "RFC XXXX: Foo Protocol";
      }
      // ... more statements
    }
            ]]></artwork>
        </figure>
<t>&lt;CODE ENDS></t>
<section title="Example Modules">
    <t>
Example modules are not code components.
The &lt;CODE BEGINS&gt; convention MUST NOT be used for example modules.
    </t>
    <t>
An example module SHOULD be named using the term &quot;example&quot;,
followed by a hyphen, followed by a descriptive name,
e.g., &quot;example&#8209;toaster&quot;.
See <xref target="TEMPNS"/> regarding the namespace guidelines for example modules.
    </t>
</section>
</section>
<section title="Terminology Section">
    <t>
A terminology section MUST be present if any terms are defined
in the document or if any terms are imported from other documents.
    </t>
</section>
<section title="Tree Diagrams">
    <t>
YANG tree diagrams provide a concise representation of a YANG
module and SHOULD be included to help readers understand
YANG module structure. Guidelines on tree diagrams can be
found in Section 3 of <xref target="RFC8340"/>.
    </t>
    <t>
If YANG tree diagrams are used, then an informative reference
to the YANG tree diagrams specification MUST be included
in the document. Refer to Section 2.2 of <xref target="RFC8349"/>
for an example of such a reference.
    </t>
</section>
<section title="Narrative Sections">
    <t>
The narrative part MUST include an overview section that describes
the scope and field of application of the module(s) defined by the
specification and that specifies the relationship (if any) of these
modules to other standards, particularly to standards containing
other YANG modules.  The narrative part SHOULD include one or more
sections to briefly describe the structure of the modules defined
in the specification.
    </t>
    <t>
If the module or modules defined by the specification imports definitions
from other modules (except for those defined in <xref target="RFC7950"/>
or <xref target="RFC6991"/>) or are always implemented in
conjunction with other modules, then those facts MUST be noted in
the overview section; any special interpretations of definitions in other modules MUST be noted as well.

Refer to Section 2.3 of <xref target="RFC8349"/> for
an example of this overview section.
    </t>
    <t>
If the document contains a YANG module(s) that is compliant
with NMDA <xref target="RFC8342"/>, then the
Introduction section should mention this fact.
    </t>
    <t>
Example:
    </t>
	<figure>
            <artwork><![CDATA[
  The YANG data model in this document conforms to the Network
  Management Datastore Architecture defined in
  RFC 8342.
            ]]></artwork>
        </figure>
    <t>
Consistent indentation SHOULD be used for all examples,
including YANG fragments and protocol message instance data.
If line wrapping is done for formatting purposes, then this SHOULD
be noted, as shown in the following example:
    </t>
        <figure>
            <artwork><![CDATA[
   [note: '\' line wrapping for formatting only]
            ]]></artwork>
        </figure>
	<figure>
            <artwork><![CDATA[
   <myleaf xmlns="tag:example.com,2017:example-two">\
     this is a long value so the line needs to wrap to stay\
     within 72 characters\
   </myleaf>
            ]]></artwork>
        </figure>
</section>
<section title="Definitions Section" anchor="def-section">
    <t>
This section contains the module(s) defined by the specification.
These modules SHOULD be written using the YANG 1.1 <xref target="RFC7950"/> syntax.
YANG 1.0 <xref target="RFC6020"/> syntax MAY be used if no YANG 1.1 constructs
or semantics are needed in the module. If any of the imported
YANG modules are written using YANG 1.1, then the module MUST
be written using YANG 1.1.
    </t>
    <t>
A YIN syntax version of the module MAY also be present in the document.
There MAY also be other types of modules present in the document,
such as Structure of Management Information Version 2 (SMIv2), which are not affected by these guidelines.
    </t>
    <t>
Note that if the module itself is considered normative and not an example
module or example YANG fragment,
then all YANG statements within a YANG module are considered
normative.
The use of keywords defined in <xref target="RFC2119"/> and <xref target="RFC8174"/>
apply to YANG "description" statements in normative modules
exactly as they would in any other normative section.
    </t>
    <t>
Example YANG modules and example YANG fragments
MUST NOT contain any normative text,
including any all-uppercase reserved words from <xref target="RFC2119"/> and <xref target="RFC8174"/>.
    </t>
    <t>
Consistent indentation and formatting SHOULD be used in all
YANG statements within a module.
    </t>
    <t>
See <xref target="YangGuidelines"/> for guidelines on YANG usage.
    </t>
</section>
<section title="Security Considerations Section">
    <t>
Each specification that defines one or more modules MUST contain a
section that discusses security considerations relevant to those
modules.
    </t>
    <t>
This section MUST be patterned after the latest approved
template (available at
&lt;https://trac.ietf.org/trac/ops/wiki/yang-security-guidelines&gt;).
<xref target="sec-template"/> contains the security considerations template dated
2013-05-08 and last updated on 2018-07-02.  Authors MUST check the web
page at the URL listed above in case there is a more recent version
available.
    </t>
    <t>
In particular:
    </t>
<t>
 <list style="symbols">
 <t>
Writable data nodes that could be especially
disruptive if abused MUST be explicitly listed by name, and the
associated security risks MUST be explained.
 </t>
 <t>
Readable data nodes that contain especially sensitive
information or that raise significant privacy concerns
MUST be explicitly listed by name, and the reasons for
the sensitivity/privacy concerns MUST be explained.
 </t>
 <t>
Operations (i.e., YANG "rpc" statements) that are potentially
harmful to system behavior or that raise significant
privacy concerns MUST be explicitly listed by name, and
the reasons for the sensitivity/privacy concerns
MUST be explained.
 </t>
 </list>
</t>
<section title="Security Considerations Section Template" anchor="sec-template">
    <t>
X.  Security Considerations
    </t>
    <t>
The YANG module specified in this document defines a schema for data that
is designed to be accessed via network management protocols such as
NETCONF <xref target="RFC6241"/> or RESTCONF <xref target="RFC8040"/>. The lowest NETCONF layer is
the secure transport layer, and the mandatory-to-implement secure
transport is Secure Shell (SSH) <xref target="RFC6242"/>. The lowest RESTCONF layer
is HTTPS, and the mandatory-to-implement secure transport is TLS <xref target="RFC8446"/>.
    </t>
    <t>

The NETCONF access control model <xref target="RFC8341"/> provides the means to restrict
access for particular NETCONF or RESTCONF users to a preconfigured subset
of all available NETCONF or RESTCONF protocol operations and content.
    </t>
	<figure>
            <artwork><![CDATA[
 -- if you have any writable data nodes (those are all the
 -- "config true" nodes, and remember, that is the default)
 -- describe their specific sensitivity or vulnerability.
            ]]></artwork>
        </figure>
    <t>
There are a number of data nodes defined in this YANG module that are
writable/creatable/deletable (i.e., "config true", which is the default).
These data nodes may be considered sensitive or vulnerable in some
network environments. Write operations (e.g., edit-config) to these
data nodes without proper protection can have a negative effect on
network operations. These are the subtrees and data nodes and
their sensitivity/vulnerability:
    </t>
    <t>
&lt;list subtrees and data nodes and state why they are sensitive&gt;
    </t>
        <figure>
            <artwork><![CDATA[
 -- for all YANG modules you must evaluate whether any readable data
 -- nodes (those are all the "config false" nodes, but also all other
 -- nodes, because they can also be read via operations like get or
 -- get-config) are sensitive or vulnerable (for instance, if they
 -- might reveal customer information or violate personal privacy
 -- laws such as those of the European Union if exposed to
 -- unauthorized parties)
            ]]></artwork>
        </figure>
    <t>
Some of the readable data nodes in this YANG module may be considered
sensitive or vulnerable in some network environments. It is thus important
to control read access (e.g., via get, get-config, or notification) to
these data nodes. These are the subtrees and data nodes and their
sensitivity/vulnerability:
    </t>
    <t>
&lt;list subtrees and data nodes and state why they are sensitive&gt;
    </t>
	<figure>
            <artwork><![CDATA[
 -- if your YANG module has defined any RPC operations
 -- describe their specific sensitivity or vulnerability.
            ]]></artwork>
        </figure>
    <t>
Some of the RPC operations in this YANG module may be considered
sensitive or vulnerable in some network environments. It is thus
important to control access to these operations. These are the
operations and their sensitivity/vulnerability:
    </t>
    <t>
&lt;list RPC operations and state why they are sensitive&gt;
    </t>
</section>
</section>
<section title="IANA Considerations Section">
    <t>
In order to comply with IESG policy as set forth in
&lt;https://www.ietf.org/id-info/checklist.html&gt;, every I-D that is
submitted to the IESG for publication MUST contain an IANA
Considerations section. The requirements for this section vary
depending on what actions are required of the IANA.  If there are no IANA considerations applicable to the document, then
the IANA Considerations section will state that "This document has no
IANA actions".  Refer to the guidelines in <xref target="RFC8126"/>
for more details.
    </t>
    <t>
Each normative YANG module MUST be registered in both the
"IETF XML Registry" <xref target="RFC3688"/> <xref target="IANA-XML"/> and the "YANG Module Names"
registry <xref target="RFC6020"/> <xref target="IANA-MOD-NAMES"/>.
This applies to new modules and updated modules.
An example of an update registration for the &quot;ietf&#8209;template&quot; module
can be found in <xref target="IANA"/>.
    </t>
<section title="Documents That Create a New Namespace">
    <t>
If an I-D defines a new namespace that is to be
administered by the IANA, then the document MUST include an IANA
Considerations section that specifies how the namespace is to be
administered.
    </t>
    <t>
Specifically, if any YANG module namespace statement value contained
in the document is not already registered with IANA, then a
new entry in the "ns" subregistry within the "IETF XML Registry" MUST be requested from the
IANA.  

    </t>
</section>
<section title="Documents That Extend an Existing Namespace">
    <t>
It is possible to extend an existing namespace using
a YANG submodule that belongs to an existing module
already administered by IANA.
In this case, the document containing the main module MUST be updated
to use the latest revision of the submodule.
    </t>
</section>
</section>
<section title="References Sections">
    <t>
For every import or include statement that appears in a
module contained
in the specification that identifies a module in a separate document,
a corresponding normative reference to that document MUST
appear in the Normative References section.  The reference MUST
correspond to the specific module version actually used within
the specification.
    </t>
    <t>
For every normative reference statement that appears
in a module contained
in the specification that identifies a separate document,
a corresponding normative reference to that document SHOULD
appear in the Normative References section.  The reference SHOULD
correspond to the specific document version actually used within
the specification.  If the reference statement identifies an
informative reference that identifies a separate document,
a corresponding informative reference to that document MAY
appear in the Informative References section.
    </t>
</section>
<section title="Validation Tools" anchor="modval">
    <t>
All modules need to be validated before submission in
an I-D. The &apos;pyang&apos; YANG compiler is
freely available from GitHub:
    </t>
        <figure>
            <artwork><![CDATA[
  <https://github.com/mbj4668/pyang>
            ]]></artwork>
        </figure>
    <t>
If the &apos;pyang&apos; compiler is used to validate a normative module,
then the &quot;&#8209;&#8209;ietf&quot; command-line
option MUST be used to identify any IETF guideline issues.
    </t>
    <t>
If the &apos;pyang&apos; compiler is used to validate an example module,
then the &quot;&#8209;&#8209;ietf&quot; command-line
option MAY be used to identify any IETF guideline issues.
    </t>
    <t>
The &quot;yanglint&quot; program is also freely available from GitHub.
    </t>
        <figure>
            <artwork><![CDATA[
   <https://github.com/CESNET/libyang>
            ]]></artwork>
        </figure>
    <t>
This tool can be used to validate XPath statements within YANG modules.
    </t>
</section>
<section title="Module Extraction Tools">
    <t>
A version of &apos;rfcstrip&apos; that will extract YANG
modules from an I-D or RFC is available.  The &apos;rfcstrip&apos; tool that supports
YANG module extraction is freely available at:
    </t>
	<figure>
            <artwork><![CDATA[
  <https://github.com/mbj4668/rfcstrip>
            ]]></artwork>
        </figure>
    <t>
This tool can be used to verify that the &quot;&lt;CODE BEGINS&gt;&quot; and &quot;&lt;CODE ENDS&gt;&quot;
tags are used correctly and that the normative YANG modules can be
extracted correctly.
    </t>
    <t>
The &quot;xym&quot; tool is freely available on GitHub and can
be used to extract YANG modules from a document.
    </t>
        <figure>
            <artwork><![CDATA[
   <https://github.com/xym-tool/xym>
            ]]></artwork>
        </figure>
</section>
<section title="Module Usage Examples">
    <t>
Each specification that defines one or more modules SHOULD contain
usage examples, either throughout the document or in an appendix.
This includes example instance document snippets in an appropriate
encoding (e.g., XML and/or JSON) to demonstrate
the intended usage of the YANG module(s).  Example modules MUST be
validated. Refer to <xref target="modval"/> for tools that validate YANG modules.
If IP addresses are used, then a mix of either IPv4 and IPv6
addresses or IPv6 addresses exclusively SHOULD be used in the examples.
    </t>
</section>
</section>
<section title="YANG Usage Guidelines" anchor="YangGuidelines">
    <t>
Modules in IETF Standards Track specifications MUST
comply with all syntactic and semantic requirements of YANG 1.1 <xref target="RFC7950"/>.
See the exception for YANG 1.0 in <xref target="def-section"/>.
The guidelines in this section are intended
to supplement the YANG specification <xref target="RFC7950"/>, which is
intended to define a minimum set of conformance
requirements.
    </t>
    <t>
In order to promote interoperability and establish
a set of practices based on previous experience,
the following sections establish usage guidelines
for specific YANG constructs.
    </t>
    <t>
Only guidelines that clarify or restrict the
minimum conformance requirements are included here.
    </t>
<section title="Module Naming Conventions">
    <t>
Normative modules contained in Standards Track documents
MUST be named according to the guidelines in
the IANA Considerations section of <xref target="RFC7950"/>.
    </t>
    <t>
A distinctive word or abbreviation (e.g., protocol name
or working group abbreviation) SHOULD be used in the
module name.  If new definitions are being defined
to extend one or more existing modules, then the same
word or abbreviation should be reused, instead of
creating a new one.
    </t>
    <t>
All published module names MUST be unique.
For a YANG module published in an RFC, this
uniqueness is guaranteed by IANA.  For unpublished
modules, the authors need to check that no other
work in progress is using the same module name.
    </t>
    <t>
Example modules are non-normative and SHOULD be named
with the prefix &quot;example&#8209;&quot;.
    </t>
    <t>
It is suggested that a stable prefix be selected that represents
the entire organization.  All normative YANG modules published
by the IETF MUST begin with the prefix &quot;ietf&#8209;&quot;.
Another standards organization, such as the IEEE, might use
the prefix &quot;ieee&#8209;&quot; for all YANG modules.
    </t>
    <t>
Once a module name is published, it MUST NOT be reused,
even if the RFC containing the module is reclassified
to "Historic" status.  A module name cannot be changed in YANG,
and this would be treated as a new module, not a name change.
    </t>
</section>
<section title="Prefixes">
    <t>
All YANG definitions are scoped by the module containing the
definition being referenced.  This allows definitions
from multiple modules to be used, even if the names are not unique.
In the example below, the identifier &quot;foo&quot; is used in all three modules:
    </t>
	<figure>
            <artwork><![CDATA[
    module example-foo {
      namespace "tag:example.com,2017:example-foo";
      prefix f;

      container foo;
    }

    module example-bar {
      namespace "tag:example.com,2017:example-bar";
      prefix b;

      typedef foo { type uint32; }
    }

    module example-one {
      namespace "tag:example.com,2017:example-one";
      prefix one;
      import example-foo { prefix f; }
      import example-bar { prefix b; }

      augment "/f:foo" {
         leaf foo { type b:foo; }
      }
    }
            ]]></artwork>
        </figure>
    <t>
YANG defines the following rules for prefix usage:
    </t>
<t>
 <list style="symbols">
 <t>
Prefixes are never used for built-in data types and YANG keywords.
 </t>
 <t>
A prefix MUST be used for any external statement (i.e., a statement
defined with the YANG &quot;extension&quot; statement).
 </t>
 <t>
The proper module prefix MUST be used for all identifiers imported from
other modules.
 </t>
 <t>
The proper module prefix MUST be used for all identifiers included from
a submodule.
 </t>
 </list>
</t>
    <t>
The following guidelines apply to prefix usage of the current (local) module:
    </t>
<t>
 <list style="symbols">
 <t>
The local module prefix SHOULD be used instead of no prefix in all path expressions.
 </t>
 <t>
The local module prefix MUST be used instead of no prefix in all &quot;default&quot;
statements for an &quot;identityref&quot; or &quot;instance&#8209;identifier&quot; data type.
 </t>
 <t>
The local module prefix MAY be used for references to typedefs, groupings, extensions,
features, and identities defined in the module.
 </t>
 </list>
</t>
    <t>
Prefix values SHOULD be short but are also likely to be unique.
Prefix values SHOULD NOT conflict with known modules that have been
previously published.
    </t>
</section>
<section title="Identifiers">
    <t>
Identifiers for all YANG identifiers
in published modules MUST be between 1 and 64 characters in length.
These include any construct specified as an "identifier&#8209;arg&#8209;str"
token in the ABNF in Section 14 of <xref target="RFC7950"/>.
    </t>
<section title="Identifier Naming Conventions">
    <t>
Identifiers SHOULD follow a consistent naming pattern
throughout the module.  Only lowercase letters, numbers,
and dashes SHOULD be used in identifier names.
Uppercase characters, the period character,
and the underscore character MAY be used
if the identifier represents a well-known value that
uses these characters. YANG does not permit any other characters
in YANG identifiers.
    </t>
    <t>
Identifiers SHOULD include complete words and/or well-known
acronyms or abbreviations.  Child nodes within a container
or list SHOULD NOT replicate the parent identifier.
YANG identifiers are hierarchical and are only meant to be
unique within the set of sibling nodes defined in
the same module namespace.
    </t>
    <t>
It is permissible to use common identifiers such as &quot;name&quot;
or &quot;id&quot; in data definition statements, especially if these
data nodes share a common data type.
    </t>
    <t>
Identifiers SHOULD NOT carry any special semantics that
identify data modeling properties. Only YANG statements and YANG
extension statements are designed to convey machine-readable data
modeling properties. For example, naming an object &quot;config&quot; or
&quot;state&quot; does not change whether it is configuration data or state
data. Only defined YANG statements or YANG extension statements can
be used to assign semantics in a machine-readable format in YANG.
    </t>
</section>
</section>
<section title="Defaults">
    <t>
In general, it is suggested that substatements
containing very common default values SHOULD NOT be present.
The following substatements are commonly used
with the default value, which would make the
module difficult to read if used everywhere they are allowed.
    </t>
<?rfc compact="yes"?><texttable title="Statement Defaults">
<ttcol align='left'> Statement</ttcol>
<ttcol align='left'>Default Value</ttcol>
<c>config</c>
<c>true</c>
<c>mandatory</c>
<c>false</c>
<c>max-elements</c>
<c>unbounded</c>
<c>min-elements</c>
<c>0</c>
<c>ordered-by</c>
<c>system</c>
<c>status</c>
<c>current</c>
<c>yin-element</c>
<c>false</c>
</texttable>
<?rfc compact="no"?></section>
<section title="Conditional Statements">
    <t>
A module may be conceptually partitioned in several
ways, using the "if&#8209;feature" and/or "when" statements.
    </t>
    <t>
Data model designers need to carefully consider all
modularity aspects, including the use of YANG conditional
statements.
    </t>
    <t>
If a data definition is optional, depending on server support for
a NETCONF or RESTCONF protocol capability, then a YANG "feature"
statement SHOULD be defined. The defined &quot;feature&quot;
statement SHOULD then be used in the conditional &quot;if&#8209;feature&quot;
statement referencing the optional data definition.
    </t>
    <t>
If any notification data, or any data definition, for a
non-configuration data node is not mandatory, then
the server may or may not be required to return
an instance of this data node.  If any conditional requirements
exist for returning the data node in a notification payload
or retrieval request, they MUST be documented somewhere.  For example,
a "when" or "if&#8209;feature" statement could apply to the data node,
or the conditional requirements could be explained in
a "description" statement within the data node or one of
its ancestors (if any).
    </t>
    <t>
If any "if&#8209;feature" statements apply to a list node, then
the same "if&#8209;feature" statements MUST apply to any key leaf
nodes for the list.  There MUST NOT be any "if&#8209;feature"
statements applied to any key leafs that do not also apply to
the parent list node.
    </t>
    <t>
There SHOULD NOT be any "when" statements applied to
a key leaf node.  It is possible that a "when" statement for
an ancestor node of a key leaf will have the exact
node-set result as the key leaf.  In such a case,
the "when" statement for the key leaf is redundant
and SHOULD be avoided.
    </t>
</section>
<section title="XPath Usage">
    <t>
This section describes guidelines for using the
XML Path Language (XPath) <xref target="W3C.REC-xpath"/>
within YANG modules.
    </t>
<section title="XPath Evaluation Contexts">
    <t>
YANG defines five separate contexts for evaluation of XPath statements:
    </t>
    <t><list style="numbers">
<t>The &quot;running&quot; datastore: collection of all YANG configuration
data nodes.  The document root is the conceptual container
(e.g., &quot;config&quot; in the &quot;edit&#8209;config&quot; operation), which is the
parent of all top-level data definition statements with a &quot;config&quot;
statement value of &quot;true&quot;.
    </t>
    <t>
State data + the &quot;running&quot; datastore: collection
of all YANG data nodes.   The document root is the conceptual container,
parent of all top-level data definition statements.
    </t>
    <t>
Notification: an event notification document. The document root
is the notification element.
    </t>
    <t>
RPC Input: The document root is the conceptual &quot;input&quot; node,
which is the parent of all RPC input parameter definitions.
    </t>
    <t>
RPC Output: The document root is the conceptual &quot;output&quot; node,
which is the parent of all RPC output parameter definitions.
    </t></list></t>
    <t>
Note that these XPath contexts cannot be mixed. For example,
a &quot;when&quot; statement in a notification context cannot reference
configuration data.
    </t>
        <figure>
            <artwork><![CDATA[
    notification foo {
      leaf mtu {
        // NOT okay because when-stmt context is this notification
        when "/if:interfaces/if:interface[name='eth0']";
        type leafref {
          // Okay because path-stmt has a different context
          path "/if:interfaces/if:interface/if:mtu";
        }
      }
    }
            ]]></artwork>
        </figure>
    <t>
It is especially important to consider the XPath evaluation
context for XPath expressions defined in groupings.
An XPath expression defined in a grouping
may not be portable, meaning it cannot be used in multiple
contexts and produce proper results.
    </t>
    <t>
If the XPath expressions defined in a grouping are intended
for a particular context, then this context SHOULD be identified
in the &quot;description&quot; statement for the grouping.
    </t>
</section>
<section title="Function Library">
    <t>
The "position" and "last" functions SHOULD NOT be used.
This applies to implicit use of the "position" function as well
(e.g., &apos;//chapter[42]&apos;).
A server is only required to maintain the relative XML document order
of all instances of a particular user-ordered list or leaf-list.
The "position" and "last" functions MAY be used if they are evaluated
in a context where the context node is
a user-ordered "list" or "leaf&#8209;list".
    </t>
    <t>
The "id" function SHOULD NOT be used. The "ID" attribute is
not present in YANG documents, so this function has no meaning.
The YANG compiler SHOULD return an empty string for this function.
    </t>
    <t>
The "namespace&#8209;uri" and "name" functions SHOULD NOT be used. Expanded names
in XPath are different than YANG. A specific canonical representation
of a YANG-expanded name does not exist.
    </t>
    <t>
The "lang" function SHOULD NOT be used. This function does not apply
to YANG because there is no "lang" attribute set with the document.
The YANG compiler SHOULD return &apos;false&apos; for this function.
    </t>
    <t>
The "local&#8209;name", "namespace&#8209;uri", "name", "string", and "number"
functions SHOULD NOT be used if the argument is a node-set.
If so, the function result will be determined by the
document order of the node-set.  Since this order can be different
on each server, the function results can also be different.
Any function call that implicitly converts a node-set to
a string will also have this issue.
    </t>
    <t>
The "local&#8209;name" function SHOULD NOT be used to reference local names
outside of the YANG module that defines the must or when expression
containing the "local&#8209;name" function. Example of a "local-name" function that
should not be used:
    </t>
        <figure>
            <artwork><![CDATA[
   /*[local-name()='foo']
            ]]></artwork>
        </figure>
    <t>
The "derived&#8209;from&#8209;or&#8209;self" function SHOULD be used instead of
an equality expression for identityref values. This allows
the identities to be conceptually augmented.
    </t>
    <t>
Example:
    </t>
        <figure>
            <artwork><![CDATA[
   // do not use
   when "md-name-format = 'name-format-null'";

   // this is preferred
   when "derived-from-or-self(md-name-format, 'name-format-null')";
            ]]></artwork>
        </figure>
</section>
<section title="Axes">
    <t>
The "attribute" and "namespace" axes are not supported in YANG
and MAY be empty in a NETCONF or RESTCONF server implementation.
    </t>
    <t>
The "preceding" and "following" axes SHOULD NOT be used.
These constructs rely on XML document order within a NETCONF or
RESTCONF server
configuration database, which may not be supported
consistently or produce reliable results across implementations.
Predicate expressions based on static node
properties (e.g., element name or value, and "ancestor" or
"descendant" axes) SHOULD be used instead.
The "preceding" and "following" axes MAY be used if
document order is not relevant to the outcome of the
expression (e.g., check for global uniqueness of a
parameter value).
    </t>
    <t>
The "preceding&#8209;sibling" and "following&#8209;sibling" axes
SHOULD NOT be used; however, they MAY be used if document
order is not relevant to the outcome of the
expression.
    </t>
    <t>
A server is only required to maintain the relative XML document order
of all instances of a particular user-ordered list or leaf-list.
The "preceding&#8209;sibling" and "following&#8209;sibling"
axes MAY be used if they are evaluated
in a context where the context node is
a user-ordered "list" or "leaf&#8209;list".
    </t>
</section>
<section title="Types">
    <t>
Data nodes that use the "int64" and "uint64" built-in
type SHOULD NOT be used within numeric or boolean expressions.
There are boundary conditions in which the translation
from the YANG 64-bit type to an XPath number can cause
incorrect results.  Specifically, an XPath "double" precision
floating-point number cannot represent very large positive
or negative 64-bit numbers because it only provides a total precision
of 53 bits.  The "int64" and "uint64" data types MAY be
used in numeric expressions if the value can be represented
with no more than 53 bits of precision.
    </t>
    <t>
Data modelers need to be careful not to
confuse the YANG value space and the XPath
value space.  The data types are not the same in both,
and conversion between YANG and XPath data types
SHOULD be considered carefully.
    </t>
    <t>
Explicit XPath data type conversions MAY be used
(e.g., "string", "boolean", or "number" functions),
instead of implicit XPath data type conversions.
    </t>
    <t>
XPath expressions that contain a literal value representing
a YANG identity SHOULD always include the declared prefix of
the module where the identity is defined.
    </t>
    <t>
XPath expressions for "when" statements SHOULD NOT reference
the context node or any descendant nodes of the context node.
They MAY reference descendant nodes if the "when" statement
is contained within an "augment" statement, and the referenced
nodes are not defined within the "augment" statement.
    </t>
    <t>
Example:
    </t>
	<figure>
            <artwork><![CDATA[
   augment "/rt:active-route/rt:input/rt:destination-address" {
      when "rt:address-family='v4ur:ipv4-unicast'" {
        description
          "This augment is valid only for IPv4 unicast.";
      }
      // nodes defined here within the augment-stmt
      // cannot be referenced in the when-stmt
   }
            ]]></artwork>
        </figure>
</section>
<section title="Wildcards">
    <t>
It is possible to construct XPath expressions that will evaluate
differently when combined with several modules within a server
implementation rather than when evaluated within the single module.
This is due to augmenting nodes from other modules.
    </t>
    <t>
Wildcard expansion is done within a server against all the nodes
from all namespaces, so it is possible for a "must" or "when" expression
that uses the &apos;*&apos; operator to always evaluate to false if
processed within a single YANG module.  In such cases, the
"description" statement SHOULD clarify that augmenting objects
are expected to match the wildcard expansion.
    </t>
        <figure>
            <artwork><![CDATA[
   when /foo/services/*/active {
     description
       "No services directly defined in this module.
        Matches objects that have augmented the services container.";
   }
            ]]></artwork>
        </figure>
</section>
<section title="Boolean Expressions">
    <t>
The YANG &quot;must&quot; and &quot;when&quot; statements use an XPath boolean expression
to define the test condition for the statement.  It is important
to specify these expressions in a way that will not cause inadvertent
changes in the result if the objects referenced in the expression
are updated in future revisions of the module.
    </t>
    <t>
For example, the leaf &quot;foo2&quot; must exist if the leaf &quot;foo1&quot; is equal
to &quot;one&quot; or &quot;three&quot;:
    </t>
        <figure>
            <artwork><![CDATA[
     leaf foo1 {
       type enumeration {
          enum one;
          enum two;
          enum three;
       }
     }

     leaf foo2 {
       // INCORRECT
       must "/f:foo1 != 'two'";
       type string;
     }

     leaf foo2 {
       // CORRECT
       must "/f:foo1 = 'one' or /f:foo1 = 'three'";
       type string;
     }
            ]]></artwork>
        </figure>
    <t>
In the next revision of the module, leaf &quot;foo1&quot; is extended
with a new enum named &quot;four&quot;:
    </t>
        <figure>
            <artwork><![CDATA[
     leaf foo1 {
       type enumeration {
          enum one;
          enum two;
          enum three;
          enum four;
       }
     }
            ]]></artwork>
        </figure>
    <t>
Now the first XPath expression will allow the enum &quot;four&quot;
to be accepted in addition to the &quot;one&quot; and &quot;three&quot; enum values.
    </t>
</section>
</section>
<section title="YANG Definition Lifecycle Management">
    <t>
The YANG status statement MUST be present within
a definition if its value
is "deprecated" or "obsolete". The status SHOULD NOT
be changed from "current" directly to "obsolete".
An object SHOULD be available for at least one year
with a "deprecated" status before it is changed to "obsolete".
    </t>
    <t>
The module or submodule name MUST NOT be changed, once
the document containing the module or submodule is published.
    </t>
    <t>
The module namespace URI value MUST NOT be changed,
once the document containing the module is published.
    </t>
    <t>
The revision date substatement within the import
statement SHOULD be present if any
groupings are used from the external module.
    </t>
    <t>
The revision date substatement within the include
statement SHOULD be present if any
groupings are used from the external submodule.
    </t>
    <t>
If an import statement is for a module from a stable source
(e.g., an RFC for an IETF module), then a reference-stmt
SHOULD be present within an import statement.
    </t>
        <figure>
            <artwork><![CDATA[
     import ietf-yang-types {
        prefix yang;
        reference "RFC 6991: Common YANG Data Types";
     }
            ]]></artwork>
        </figure>
    <t>
If submodules are used, then the document containing the
main module MUST be updated so that the main module
revision date is equal to or more recent than the revision date
of any submodule that is (directly or indirectly) included by the main module.
    </t>
    <t>
Definitions for future use SHOULD NOT be specified in a module.
Do not specify placeholder objects like the &quot;reserved&quot; example below:
    </t>
        <figure>
            <artwork><![CDATA[
    leaf reserved {
      type string;
      description
        "This object has no purpose at this time, but a future
         revision of this module might define a purpose
         for this object.";
      }
    }
            ]]></artwork>
        </figure>
</section>
<section title="Module Header, Meta, and Revision Statements">
    <t>
For published modules, the namespace MUST
be a globally unique
URI, as defined in <xref target="RFC3986"/>.
This value is usually assigned by the IANA.
    </t>
    <t>
The "organization" statement MUST be present.
If the module is contained in a document
intended for IETF Standards Track status, then
the organization SHOULD be the IETF working group (WG)
chartered to write the document.  For other standards
organizations, a similar approach is also suggested.
    </t>
    <t>
The "contact" statement MUST be present.
If the module is contained in a document
intended for Standards Track status, then
the WG web and mailing information
SHOULD be present, and the main document author or
editor contact information SHOULD be present.
If additional authors or editors exist,
their contact information MAY be present.
There is no need to include the contact information
for WG Chairs.
    </t>
    <t>
The "description" statement MUST be present.
For modules published within IETF documents,
the appropriate IETF Trust Copyright text MUST be present,
as described in <xref target="MODULECOPY"/>.
    </t>
    <t>
If the module relies on information contained
in other documents, which are not the same
documents implied by the import statements
present in the module, then these documents
MUST be identified in the reference
statement.
    </t>
    <t>
A "revision" statement MUST be present for each published
version of the module. The "revision" statement MUST
have a "reference" substatement.
It MUST identify the published document that
contains the module.
Modules are often extracted from their original
documents, and it is useful for developers
and operators to know how to find the
original source document in a consistent manner.
The "revision" statement MAY have a "description" substatement.
    </t>
    <t>
The following example shows the revision statement for
a published YANG module:
    </t>
        <figure>
            <artwork><![CDATA[
   revision "2012-02-22" {
     description
       "Initial version";
     reference
       "RFC 8341: Network Configuration 
                  Access Control Model";
   }
            ]]></artwork>
        </figure>
    <t>
For an unpublished module, a complete history of
each unpublished module revision is not required.
That is, within a sequence of draft versions, only the most recent
revision need be recorded in the module.
Do not remove or reuse a revision statement for a published module.
A new revision date is not required unless the module contents
have changed. If the module contents have changed, then
the revision date of that new module version MUST be updated to a date
later than that of the previous version.
    </t>
    <t>
The following example shows the two revision statements for
an unpublished update to a published YANG module:
    </t>
        <figure>
            <artwork><![CDATA[
   revision "2017-12-11" {
     description
       "Added support for YANG 1.1 actions and notifications tied to
        data nodes.  Clarify how NACM extensions can be used by other
        data models.";
     reference
       "RFC 8407: Network Configuration Protocol (NETCONF)
                  Access Control Model";
   }

   revision "2012-02-22" {
     description
       "Initial version";
     reference
       "RFC 8341: Network Configuration 
                  Access Control Model";
   }
            ]]></artwork>
        </figure>
</section>
<section title="Namespace Assignments" anchor="TEMPNS">
    <t>
It is RECOMMENDED that only valid YANG modules be
included in documents, whether or not the modules are published yet.
This allows:
    </t>
<t>
 <list style="symbols">
 <t>
the module to compile correctly instead
of generating disruptive fatal errors.
 </t>
 <t>
early implementors to use the modules
without picking a random value for the XML namespace.
 </t>
 <t>
early interoperability testing since
independent implementations will use the same
XML namespace value.
 </t>
 </list>
</t>
    <t>
Until a URI is assigned by the IANA, a proposed namespace URI
MUST be provided for the namespace statement in a YANG module.
A value SHOULD be selected that is not likely to collide with
other YANG namespaces.  Standard module names, prefixes,
and URI strings already listed in the "YANG Module Names" registry
MUST NOT be used.
    </t>
    <t>
A standard namespace statement value SHOULD have the
following form:
    </t>
        <figure>
            <artwork><![CDATA[
    <URN prefix string>:<module-name>
            ]]></artwork>
        </figure>
    <t>
The following URN prefix string SHOULD be used for published
and unpublished YANG modules:
    </t>
        <figure>
            <artwork><![CDATA[
    urn:ietf:params:xml:ns:yang:
            ]]></artwork>
        </figure>
    <t>
The following example URNs would be valid namespace
statement values for Standards Track modules:
    </t>
        <figure>
            <artwork><![CDATA[
    urn:ietf:params:xml:ns:yang:ietf-netconf-partial-lock

    urn:ietf:params:xml:ns:yang:ietf-netconf-state

    urn:ietf:params:xml:ns:yang:ietf-netconf
            ]]></artwork>
        </figure>
    <t>
Note that a different URN prefix string SHOULD be used for modules that are not Standards Track. The string SHOULD be selected according to the guidelines in <xref target="RFC7950"/>.
    </t>
    <t>
The following URIs exemplify what might be used by modules that are not Standards Track.  Note that the domain &quot;example.com&quot; SHOULD be used
by example modules in IETF I-Ds. These URIs are not intended to
be dereferenced. They are used for module namespace identification only.
    </t>
    <t>
Example URIs using URLs per <xref target="RFC3986"/>:
    </t>
        <figure>
            <artwork><![CDATA[
    https://example.com/ns/example-interfaces

    https://example.com/ns/example-system
            ]]></artwork>
        </figure>
    <t>
Example URIs using tags per <xref target="RFC4151"/>:
    </t>
        <figure>
            <artwork><![CDATA[
    tag:example.com,2017:example-interfaces

    tag:example.com,2017:example-system
            ]]></artwork>
        </figure>
</section>
<section title="Top-Level Data Definitions">
    <t>
The top-level data organization SHOULD be considered carefully,
in advance.  Data model designers need to consider how
the functionality for a given protocol or protocol family
will grow over time.
    </t>
    <t>
The separation of configuration data and operational state SHOULD
be considered carefully. It is sometimes useful to define separate
top-level containers for configuration and non-configuration data.
For some existing top-level data nodes, configuration data
was not in scope, so only one container representing operational
state was created. Refer to NMDA <xref target="RFC8342"/>
for details.
    </t>
    <t>
The number of top-level data nodes within a module
SHOULD be minimized. It is often useful to retrieve
related information within a single subtree.
If data is too distributed, it becomes difficult to
retrieve all at once.
    </t>
    <t>
The names and data organization SHOULD reflect persistent
information, such as the name of a protocol.  The name
of the working group SHOULD NOT be used because this
may change over time.
    </t>
    <t>
A mandatory database data definition is defined as
a node that a client must provide for the database
to be valid.  The server is not required to provide a value.
    </t>
    <t>
Top-level database data definitions MUST NOT be mandatory.
If a mandatory node appears at the top level, it will
immediately cause the database to be invalid.
This can occur when the server boots or when a module
is loaded dynamically at runtime.
    </t>
</section>
<section title="Data Types">
    <t>
Selection of an appropriate data type (i.e., built-in
type, existing derived type, or new derived type)
is very subjective; therefore, few requirements
can be specified on that subject.
    </t>
    <t>
Data model designers SHOULD use the most appropriate
built-in data type for the particular application.
    </t>
    <t>
The signed numeric data types (i.e., "int8",
"int16", "int32", and "int64") SHOULD NOT be used unless
negative values are allowed for the desired semantics.
    </t>
<section title="Fixed-Value Extensibility">
    <t>
If the set of values is fixed and the data type contents
are controlled by a single naming authority, then an
enumeration data type SHOULD be used.
    </t>
        <figure>
            <artwork><![CDATA[
    leaf foo {
      type enumeration {
        enum one;
        enum two;
      }
    }
            ]]></artwork>
        </figure>
    <t>
If extensibility of enumerated values is required,
then the "identityref" data type SHOULD be used
instead of an enumeration or other built-in type.
    </t>
        <figure>
            <artwork><![CDATA[
    identity foo-type {
      description "Base for the extensible type";
    }

    identity one {
      base f:foo-type;
    }
    identity two {
      base f:foo-type;
    }

    leaf foo {
      type identityref {
        base f:foo-type;
      }
    }
            ]]></artwork>
        </figure>
    <t>
Note that any module can declare an identity with base &quot;foo&#8209;type&quot;
that is valid for the &quot;foo&quot; leaf. Identityref values are
considered to be qualified names.
    </t>
</section>
<section title="Patterns and Ranges">
    <t>
For string data types, if a machine-readable pattern
can be defined for the desired semantics, then
one or more pattern statements SHOULD be present.
A single-quoted string SHOULD be used to specify the pattern,
since a double-quoted string can modify the content.
If the patterns used in a type definition have known limitations
such as false negative or false positive matches,
then these limitations SHOULD be documented within
the typedef or data definition.
    </t>
    <t>
The following typedef from <xref target="RFC6991"/> demonstrates the proper
use of the &quot;pattern&quot; statement:
    </t>
        <figure>
            <artwork><![CDATA[
    typedef ipv4-address-no-zone {
      type inet:ipv4-address {
        pattern '[0-9\.]*';
      }
      ...
    }
            ]]></artwork>
        </figure>
    <t>
For string data types, if the length of the string
is required to be bounded in all implementations,
then a length statement MUST be present.
    </t>
    <t>
The following typedef from <xref target="RFC6991"/> demonstrates the proper
use of the &quot;length&quot; statement:
    </t>
        <figure>
            <artwork><![CDATA[
    typedef yang-identifier {
      type string {
        length "1..max";
        pattern '[a-zA-Z_][a-zA-Z0-9\-_.]*';
        pattern '.|..|[^xX].*|.[^mM].*|..[^lL].*';
      }
      ...
    }
            ]]></artwork>
        </figure>
    <t>
For numeric data types, if the values allowed
by the intended semantics are different than
those allowed by the unbounded intrinsic data
type (e.g., "int32"), then a range statement SHOULD be present.
    </t>
    <t>
The following typedef from <xref target="RFC6991"/> demonstrates the proper
use of the &quot;range&quot; statement:
    </t>
        <figure>
            <artwork><![CDATA[
    typedef dscp {
      type uint8 {
         range "0..63";
      }
      ...
    }
            ]]></artwork>
        </figure>
</section>
<section title="Enumerations and Bits">
    <t>
For "enumeration" or "bits" data types, the semantics for
each "enum" or "bit" SHOULD be documented.  A separate
"description" statement (within each "enum" or "bit"
statement) SHOULD be present.
    </t>
        <figure>
            <artwork><![CDATA[
    leaf foo {
      // INCORRECT
      type enumeration {
        enum one;
        enum two;
      }
      description
        "The foo enum...
         one: The first enum
         two: The second enum";
    }

    leaf foo {
      // CORRECT
      type enumeration {
        enum one {
          description "The first enum";
        }
        enum two {
          description "The second enum";
        }
      }
      description
        "The foo enum...  ";
    }
            ]]></artwork>
        </figure>
</section>
<section title="Union Types">
    <t>
The YANG &quot;union&quot; type is evaluated by testing a value
against each member type in the union.  The first type definition
that accepts a value as valid is the member type used.
In general, member types SHOULD be ordered from most restrictive
to least restrictive types.
    </t>
    <t>
In the following example, the &quot;enumeration&quot; type will never
be matched because the preceding &quot;string&quot; type will match everything.
    </t>
    <t>
Incorrect:
    </t>
	<figure>
            <artwork><![CDATA[
   type union {
     type string;
     type enumeration {
       enum up;
       enum down;
     }
   }
            ]]></artwork>
        </figure>
    <t>
Correct:
    </t>
        <figure>
            <artwork><![CDATA[
   type union {
     type enumeration {
       enum up;
       enum down;
     }
     type string;
   }
            ]]></artwork>
        </figure>
    <t>
It is possible for different member types to match,
depending on the input encoding format.  In XML, all values
are passed as string nodes; but in JSON, there are different
value types for numbers, booleans, and strings.
    </t>
    <t>
In the following example, a JSON numeric value will always
be matched by the &quot;int32&quot; type, but in XML the string value
representing a number will be matched by the &quot;string&quot; type.
The second version will match the &quot;int32&quot; member type
no matter how the input is encoded.
    </t>
    <t>
Incorrect:
    </t>
        <figure>
            <artwork><![CDATA[
   type union {
     type string;
     type int32;
   }
            ]]></artwork>
        </figure>
    <t>
Correct:
    </t>
        <figure>
            <artwork><![CDATA[
   type union {
     type int32;
     type string;
   }
            ]]></artwork>
        </figure>
</section>
<section title="Empty and Boolean">
    <t>
YANG provides an &quot;empty&quot; data type, which has one value (i.e., present).
The default is &quot;not present&quot;, which is not actually a value.
When used within a list key, only one value can (and must) exist
for this key leaf.  The type &quot;empty&quot; SHOULD NOT be used
for a key leaf since it is pointless.
    </t>
    <t>
There is really no difference between a leaf of type &quot;empty&quot; and a leaf-list
of type &quot;empty&quot;. Both are limited to one instance.
The type &quot;empty&quot; SHOULD NOT be used for a leaf-list.
    </t>
    <t>
The advantage of using type &quot;empty&quot; instead of type &quot;boolean&quot;
is that the default (not present) does not take up any bytes
in a representation.  The disadvantage is that the client
may not be sure if an empty leaf is missing because it
was filtered somehow or not implemented. The client may not have
a complete and accurate schema for the data returned by the server
and may not be aware of the missing leaf.
    </t>
    <t>
The YANG &quot;boolean&quot; data type provides two values (&quot;true&quot; and &quot;false&quot;).
When used within a list key, two entries can exist
for this key leaf.  Default values are ignored for key leafs,
but a default statement is often used for plain boolean leafs.
The advantage of the &quot;boolean&quot; type is that the leaf or leaf-list
has a clear representation for both values.  The default value
is usually not returned unless explicitly requested by the client,
so no bytes are used in a typical representation.
    </t>
    <t>
In general, the &quot;boolean&quot; data type SHOULD be used instead
of the &quot;empty&quot; data type, as shown in the example below:
    </t>
    <t>
Incorrect:
    </t>
        <figure>
            <artwork><![CDATA[
   leaf flag1 {
     type empty;
   }
            ]]></artwork>
        </figure>
    <t>
Correct:
    </t>
        <figure>
            <artwork><![CDATA[
   leaf flag2 {
     type boolean;
     default false;
   }
            ]]></artwork>
        </figure>
</section>
</section>
<section title="Reusable Type Definitions">
    <t>
If an appropriate derived type exists in any
standard module, such as <xref target="RFC6991"/>,
then it SHOULD be used instead of defining a new derived type.
    </t>
    <t>
If an appropriate units identifier can be associated
with the desired semantics, then a units statement
SHOULD be present.
    </t>
    <t>
If an appropriate default value can be associated
with the desired semantics, then a default statement
SHOULD be present.
    </t>
    <t>
If a significant number of derived types are defined,
and it is anticipated that these data types will be reused
by multiple modules, then these derived types SHOULD be
contained in a separate module or submodule, to allow
easier reuse without unnecessary coupling.
    </t>
    <t>
The "description" statement MUST be present.
    </t>
    <t>
If the type definition semantics are defined
in an external document (other than another
YANG module indicated by an import
statement), then the reference
statement MUST be present.
    </t>
</section>
<section title="Reusable Groupings">
    <t>
A reusable grouping is a YANG grouping that can be imported
by another module and is intended for use by other modules.
This is not the same as a grouping that is used within the
module in which it is defined, but it happens to be exportable to another
module because it is defined at the top level of the YANG module.
    </t>
    <t>
The following guidelines apply to reusable groupings,
in order to make them as robust as possible:
    </t>
<t>
 <list style="symbols">
 <t>
Clearly identify the purpose of the grouping in the
&quot;description&quot; statement.
 </t>
 <t>
There are five different XPath contexts in YANG (rpc/input,
rpc/output, notification, "config true" data nodes, and all data nodes).
Clearly identify which XPath contexts are applicable or excluded
for the grouping.
 </t>
 <t>
Do not reference data outside the grouping in any &quot;path&quot;,
&quot;must&quot;, or &quot;when&quot; statements.
 </t>
 <t>
Do not include a &quot;default&quot; substatement on a leaf or choice unless
the value applies on all possible contexts.
 </t>
 <t>
Do not include a &quot;config&quot; substatement on a data node unless
the value applies on all possible contexts.
 </t>
 <t>
Clearly identify any external dependencies in the grouping
&quot;description&quot; statement, such as nodes referenced
by an absolute path from a &quot;path&quot;, &quot;must&quot;, or &quot;when&quot; statement.
 </t>
 </list>
</t>
</section>
<section title="Data Definitions">
    <t>
The "description" statement MUST be present in the following
YANG statements:
    </t>
<t>
 <list style="symbols">
 <t>
anyxml
 </t>
 <t>
augment
 </t>
 <t>
choice
 </t>
 <t>
container
 </t>
 <t>
extension
 </t>
 <t>
feature
 </t>
 <t>
grouping
 </t>
 <t>
identity
 </t>
 <t>
leaf
 </t>
 <t>
leaf-list
 </t>
 <t>
list
 </t>
 <t>
notification
 </t>
 <t>
rpc
 </t>
 <t>
typedef
 </t>
 </list>
</t>
    <t>
If the data definition semantics are defined in an external document,
(other than another
YANG module indicated by an import
statement), then a reference statement MUST be present.
    </t>
    <t>
The "anyxml" construct may be useful to represent an HTML banner
containing
markup elements, such as "&lt;b&gt;" and "&lt;/b&gt;",
and MAY be used in such cases.  However, this construct
SHOULD NOT be used if other YANG data node types can be used instead
to represent the desired syntax and semantics.
    </t>
    <t>
It has been found that the "anyxml" statement is not implemented
consistently across all servers.  It is possible that mixed-mode XML
will not be supported or that configuration anyxml nodes will not supported.
    </t>
    <t>
If there are referential integrity constraints associated
with the desired semantics that
can be represented with XPath, then one or more
"must" statements SHOULD be present.
    </t>
    <t>
For list and leaf-list data definitions, if the number of possible instances
is required to be bounded for all implementations,
then the max-elements statements SHOULD be present.
    </t>
    <t>
If any "must" or "when" statements are used within the
data definition, then the data definition "description" statement
SHOULD describe the purpose of each one.
    </t>
    <t>
The &quot;choice&quot; statement is allowed to be directly present within
a &quot;case&quot; statement in YANG 1.1. This needs to be considered
carefully. Consider simply including the nested &quot;choice&quot;
as additional &quot;case&quot; statements within the parent &quot;choice&quot; statement.
Note that the &quot;mandatory&quot; and &quot;default&quot; statements within
a nested &quot;choice&quot; statement only apply if the &quot;case&quot; containing
the nested &quot;choice&quot; statement is first selected.
    </t>
    <t>
If a list defines any key leafs, then these leafs SHOULD be
defined in order, as the first child nodes within the list.
The key leafs MAY be in a different order in some cases, e.g.,
they are defined in a grouping, and not inline in the list statement.
    </t>
<section title="Non-Presence Containers">
    <t>
A non-presence container is used to organize data into specific subtrees.
It is not intended to have semantics within the data model beyond this
purpose, although YANG allows it (e.g., a &quot;must&quot; statement within the
non-presence container).
    </t>
    <t>
Example using container wrappers:
    </t>
        <figure>
            <artwork><![CDATA[
    container top {
       container foos {
          list foo { ... }
       }
       container bars {
          list bar { ... }
       }
    }
            ]]></artwork>
        </figure>
    <t>
Example without container wrappers:
    </t>
        <figure>
            <artwork><![CDATA[
    container top {
       list foo { ... }
       list bar { ... }
    }
            ]]></artwork>
        </figure>
    <t>
Use of non-presence containers to organize data is a subjective matter
similar to use of subdirectories in a file system. Although these
containers do not have any semantics, they can impact protocol
operations for the descendant data nodes within a non-presence container,
so use of these containers SHOULD be considered carefully.
    </t>
    <t>
The NETCONF and RESTCONF protocols do not currently support the ability
to delete all list (or leaf-list) entries at once. This deficiency
is sometimes avoided by use of a parent container (i.e., deleting the
container also removes all child entries).
    </t>
</section>
<section title="Top-Level Data Nodes">
    <t>
Use of top-level objects needs to be considered carefully:
    </t>
<t>
 <list style="symbols">
 <t>
top-level siblings are not ordered
 </t>
 <t>
top-level siblings are not static and depend on the modules
that are loaded
 </t>
 <t>
for subtree filtering, retrieval of a top-level leaf-list
will be treated as a content-match node for all top-level-siblings
 </t>
 <t>
a top-level list with many instances may impact performance
 </t>
 </list>
</t>
</section>
</section>
<section title="Operation Definitions">
    <t>
If the operation semantics are defined in an external document
(other than another YANG module indicated by an import
statement), then a reference statement MUST be present.
    </t>
    <t>
If the operation impacts system behavior in some way,
it SHOULD be mentioned in the "description" statement.
    </t>
    <t>
If the operation is potentially harmful to system
behavior in some way,
it MUST be mentioned in the Security Considerations
section of the document.
    </t>
</section>
<section title="Notification Definitions">
    <t>
The "description" statement MUST be present.
    </t>
    <t>
If the notification semantics are defined in an external document
(other than another YANG module indicated by an import
statement), then a reference statement MUST be present.
    </t>
    <t>
If the notification refers to a specific resource instance,
then this instance SHOULD be identified in the notification data.
This is usually done by including "leafref" leaf nodes with the key leaf
values for the resource instance. For example:
    </t>
	<figure>
            <artwork><![CDATA[
  notification interface-up {
    description "Sent when an interface is activated.";
    leaf name {
      type leafref {
        path "/if:interfaces/if:interface/if:name";
      }
    }
  }
            ]]></artwork>
        </figure>
    <t>
Note that there are no formal YANG statements to identify
any data node resources associated with a notification.
The "description" statement for the notification SHOULD
specify if and how the notification identifies any data
node resources associated with the specific event.
    </t>
</section>
<section title="Feature Definitions">
    <t>
The YANG &quot;feature&quot; statement is used to define a label for
a set of optional functionality within a module.  The &quot;if&#8209;feature&quot;
statement is used in the YANG statements associated with a feature.
The description-stmt within a feature-stmt MUST
specify any interactions with other features.
    </t>
    <t>
The set of YANG features defined in a module should be considered
carefully. Very fine granular features increase interoperability
complexity and should be avoided. A likely misuse of the feature
mechanism is the tagging of individual leafs (e.g., counters) with
separate features.
    </t>
    <t>
If there is a large set of objects associated with a YANG feature,
then consider moving those objects to a separate module,
instead of using a YANG feature.  Note that the set of features
within a module is easily discovered by the reader, but
the set of related modules within the entire YANG library
is not as easy to identity. Module names with
a common prefix can help readers identity the set of related
modules, but this assumes the reader will have discovered
and installed all the relevant modules.
    </t>
    <t>
Another consideration for deciding whether to create a new module
or add a YANG feature is the stability of the module in question.
It may be desirable to have a stable base module that is
not changed frequently.  If new functionality is placed in
a separate module, then the base module does not need to
be republished.  If it is designed as a YANG feature, then
the module will need to be republished.
    </t>
    <t>
If one feature requires implementation of another feature,
then an &quot;if&#8209;feature&quot; statement SHOULD be used in the
dependent &quot;feature&quot; statement.
    </t>
    <t>
For example, feature2 requires implementation of feature1:
    </t>
	<figure>
            <artwork><![CDATA[
   feature feature1 {
     description "Some protocol feature";
   }

   feature feature2 {
     if-feature "feature1";
     description "Another protocol feature";
   }
            ]]></artwork>
        </figure>
</section>
<section title="YANG Data Node Constraints">
<section title="Controlling Quantity">
    <t>
The &quot;min&#8209;elements&quot; and &quot;max&#8209;elements&quot; statements can
be used to control how many list or leaf-list instances are
required for a particular data node.
YANG constraint statements SHOULD be used to identify conditions
that apply to all implementations of the data model.
If platform-specific limitations (e.g., the &quot;max&#8209;elements&quot;
supported for a particular list) are relevant to operations,
then a data model definition statement (e.g., &quot;max&#8209;ports&quot; leaf)
SHOULD be used to identify the limit.
    </t>
</section>
<section title="&quot;must&quot; versus &quot;when&quot;">
    <t>
&quot;must&quot; and &quot;when&quot; YANG statements are used to provide
cross-object referential tests.  They have very different behavior.
The &quot;when&quot; statement causes data node instances to be silently deleted
as soon as the condition becomes false.  A false &quot;when&quot; expression
is not considered to be an error.
    </t>
    <t>
The &quot;when&quot; statement SHOULD be used together with &quot;augment&quot;
or &quot;uses&quot; statements to achieve conditional model composition.
The condition SHOULD be based on static properties of the
augmented entry (e.g., list key leafs).
    </t>
    <t>
The &quot;must&quot; statement causes a datastore validation error
if the condition is false. This statement SHOULD be used
for enforcing parameter value restrictions that involve
more than one data node (e.g., end-time parameter
must be after the start-time parameter).
    </t>
</section>
</section>
<section title="&quot;augment&quot; Statements">
    <t>
The YANG &quot;augment&quot; statement is used to define a set of
data definition statements that will be added as child nodes
of a target data node.  The module namespace for these
data nodes will be the augmenting module, not the augmented
module.
    </t>
    <t>
A top-level &quot;augment&quot; statement SHOULD NOT be used if the
target data node is in the same module or submodule as the
evaluated &quot;augment&quot; statement.  The data definition statements
SHOULD be added inline instead.
    </t>
<section title="Conditional Augment Statements">
    <t>
The &quot;augment&quot; statement is often used together with
the &quot;when&quot; statement and/or &quot;if&#8209;feature&quot; statement
to make the augmentation conditional on some portion
of the data model.
    </t>
    <t>
The following example from <xref target="RFC7223"/> shows how
a conditional container called &quot;ethernet&quot; is added to the
&quot;interface&quot; list only for entries of the
type &quot;ethernetCsmacd&quot;.
    </t>
        <figure>
            <artwork><![CDATA[
     augment "/if:interfaces/if:interface" {
         when "if:type = 'ianaift:ethernetCsmacd'";

         container ethernet {
             leaf duplex {
                 ...
             }
         }
     }
            ]]></artwork>
        </figure>
</section>
<section title="Conditionally Mandatory Data Definition Statements">
    <t>
YANG has very specific rules about how configuration data
can be updated in new releases of a module.  These rules
allow an &quot;old client&quot; to continue interoperating with
a &quot;new server&quot;.
    </t>
    <t>
If data nodes are added to an existing entry, the
old client MUST NOT be required to provide any
mandatory parameters that were not in the original
module definition.
    </t>
    <t>
It is possible to add conditional &quot;augment&quot; statements such
that the old client would not know about the new condition
and would not specify the new condition. The conditional
&quot;augment&quot; statement can contain mandatory objects only if
the condition is false, unless explicitly requested by
the client.
    </t>
    <t>
Only a conditional &quot;augment&quot; statement that uses the &quot;when&quot;
statement form of a condition can be used in this manner.
The YANG features enabled on the server cannot be
controlled by the client in any way, so it is not safe
to add mandatory augmenting data nodes based on the
&quot;if&#8209;feature&quot; statement.
    </t>
    <t>
The XPath &quot;when&quot; statement condition MUST NOT reference
data outside of the target data node because the client
does not have any control over this external data.
    </t>
    <t>
In the following dummy example, it is okay to augment
the &quot;interface&quot; entry with &quot;mandatory&#8209;leaf&quot; because
the augmentation depends on support for &quot;some&#8209;new&#8209;iftype&quot;.
The old client does not know about this type, so it would
never select this type; therefore, it  would not add a mandatory data node.
    </t>
        <figure>
            <artwork><![CDATA[
  module example-module {

    yang-version 1.1;
    namespace "tag:example.com,2017:example-module";
    prefix mymod;

    import iana-if-type { prefix iana; }
    import ietf-interfaces { prefix if; }

    identity some-new-iftype {
       base iana:iana-interface-type;
    }

    augment "/if:interfaces/if:interface" {
       when "if:type = 'mymod:some-new-iftype'";

       leaf mandatory-leaf {
          type string;
          mandatory true;
       }
    }
  }
            ]]></artwork>
        </figure>
    <t>
Note that this practice is safe only for creating data resources.
It is not safe for replacing or modifying resources if the
client does not know about the new condition. The YANG data model
MUST be packaged in a way that requires the client to be aware
of the mandatory data nodes if it is aware of the condition
for this data.  In the example above, the &quot;some&#8209;new&#8209;iftype&quot;
identity is defined in the same module as the &quot;mandatory&#8209;leaf&quot;
data definition statement.
    </t>
    <t>
This practice is not safe for identities defined in a common
module such as &quot;iana&#8209;if&#8209;type&quot; because the client is not
required to know about &quot;my&#8209;module&quot; just because it knows about
the &quot;iana&#8209;if&#8209;type&quot; module.
    </t>
</section>
</section>
<section title="Deviation Statements">
    <t>
Per RFC 7950, Section 7.20.3, the YANG &quot;deviation&quot; statement
is not allowed to appear in IETF YANG modules,
but it can be useful for documenting server capabilities.
Deviation statements are not reusable and typically not shared across
all platforms.
    </t>
    <t>
There are several reasons that deviations might be needed in
an implementation, e.g., an object cannot be supported
on all platforms, or feature delivery is done
in multiple development phases.  Deviation statements can
also be used to add annotations to a module, which does not
affect the conformance requirements for the module.
    </t>
    <t>
It is suggested that deviation statements be defined in separate
modules from regular YANG definitions.  This allows the deviations to be
platform specific and/or temporary.
    </t>
    <t>
The order that deviation statements are evaluated can affect the
result.  Therefore, multiple deviation statements in the same module,
for the same target object, SHOULD NOT be used.
    </t>
    <t>
The &quot;max&#8209;elements&quot; statement is intended to describe an architectural
limit to the number of list entries.  It is not intended to
describe platform limitations. It is better to use a
&quot;deviation&quot; statement for the platforms that have a hard resource limit.
    </t>
    <t>
Example documenting platform resource limits:
    </t>
        <figure>
            <artwork><![CDATA[
  Wrong: (max-elements in the list itself)

     container backups {
       list backup {
          ...
          max-elements  10;
          ...
       }
     }

  Correct: (max-elements in a deviation)

     deviation /bk:backups/bk:backup {
       deviate add {
          max-elements  10;
       }
     }
            ]]></artwork>
        </figure>
</section>
<section title="Extension Statements">
    <t>
The YANG &quot;extension&quot; statement is used to specify external
definitions. This appears in the YANG syntax as
an &quot;unknown&#8209;statement&quot;. Usage of extension statements in
a published module needs to be considered carefully.
    </t>
    <t>
The following guidelines apply to the usage of YANG extensions:
    </t>
<t>
 <list style="symbols">
 <t>
The semantics of the extension MUST NOT contradict any
YANG statements. Extensions can add semantics not covered
by the normal YANG statements.
 </t>
 <t>
The module containing the extension statement MUST clearly
identify the conformance requirements for the extension.
It should be clear whether all implementations of the YANG
module containing the extension need to also implement
the extension. If not, identify what conditions apply that would
require implementation of the extension.
 </t>
 <t>
The extension MUST clearly identify where it can be used
within other YANG statements.
 </t>
 <t>
The extension MUST clearly identify if YANG statements or other
extensions are allowed or required within the extension as
substatements.
 </t>
 </list>
</t>
</section>
<section title="Data Correlation">
    <t>
Data can be correlated in various ways, using common data types,
common data naming, and common data organization.
There are several ways to extend the functionality of a module,
based on the degree of coupling between the old and new
functionality:
    </t>
<t>
 <list style="symbols">
 <t>
inline: update the module with new protocol-accessible objects.
The naming and data organization of the original objects is used.
The new objects are in the original module namespace.
 </t>
 <t>
augment: create a new module with new protocol-accessible objects
that augment the original data structure.
The naming and data organization of the original objects is used.
The new objects are in the new module namespace.
 </t>
 <t>
mirror: create new objects in a new module or the original module,
except use a new naming scheme and data location.  The naming
can be coupled in different ways. Tight coupling is achieved
with a &quot;leafref&quot; data type, with the &quot;require&#8209;instance&quot; substatement
set to &quot;true&quot;. This method SHOULD be used.
 </t>
 </list>
</t>
    <t>
If the new data instances are not limited to the values in use in the original
data structure, then the &quot;require&#8209;instance&quot; substatement MUST
be set to &quot;false&quot;.  Loose coupling is achieved by using key leafs with
the same data type as the original data structure.  This has the same
semantics as setting the &quot;require&#8209;instance&quot; substatement to &quot;false&quot;.
    </t>
    <t>
The relationship between configuration and operational state has
been clarified in NMDA <xref target="RFC8342"/>.
    </t>
<section title="Use of &quot;leafref&quot; for Key Correlation">
    <t>
Sometimes it is not practical to augment a data structure.
For example, the correlated data could have different keys
or contain mandatory nodes.
    </t>
    <t>
The following example shows the use of the &quot;leafref&quot; data type
for data correlation purposes:
    </t>
    <t>
Not preferred:
    </t>
        <figure>
            <artwork><![CDATA[
   list foo {
      key name;
      leaf name {
        type string;
      }
      ...
   }

   list foo-addon {
      key name;
      config false;
      leaf name {
        type string;
      }
      ...
   }
            ]]></artwork>
        </figure>
    <t>
Preferred:
    </t>
        <figure>
            <artwork><![CDATA[
   list foo {
      key name;
      leaf name {
        type string;
      }
      ...
   }

   list foo-addon {
      key name;
      config false;
      leaf name {
        type leafref {
          path "/foo/name";
          require-instance false;
        }
      }
      leaf addon {
        type string;
        mandatory true;
      }
   }
            ]]></artwork>
        </figure>
</section>
</section>
<section title="Operational State">
    <t>
The modeling of operational state with YANG has been refined over time.
At first, only data that has a &quot;config&quot; statement value of &quot;false&quot;
was considered to be operational state. This data was not considered to
be part of any datastore, which made the YANG XPath definition much more
complicated.
    </t>
    <t>
Operational state is now modeled using YANG according to the new NMDA
<xref target="RFC8342"/>
and conceptually contained in the operational state datastore,
which also includes the operational values of configuration data.
There is no longer any need to duplicate data structures
to provide separate configuration and operational state
sections.
    </t>
    <t>
This section describes some data modeling issues related to
operational state and guidelines for transitioning YANG data model design
to be NMDA compatible.
    </t>
<section title="Combining Operational State and Configuration Data" anchor="combine-data">
    <t>
If possible, operational state SHOULD be combined with
its associated configuration data.  This prevents
duplication of key leafs and ancestor nodes.
It also prevents race conditions for retrieval of
dynamic entries and allows configuration and operational
state to be retrieved together with minimal message overhead.
    </t>
        <figure>
            <artwork><![CDATA[
   container foo {
     ...
     // contains "config true" and "config false" nodes that have
     // no corresponding "config true" object (e.g., counters)
   }
            ]]></artwork>
        </figure>
</section>
<section title="Representing Operational Values of Configuration Data">
    <t>
If possible, the same data type SHOULD be used to represent the
configured value and the operational value, for a given leaf
or leaf-list object.
    </t>
    <t>
Sometimes the configured value set is different than the operational
value set for that object, for example, the &quot;admin&#8209;status&quot; and
&quot;oper&#8209;status&quot; leafs in <xref target="RFC8343"/>. In this case, a separate object
MAY be used to represent the configured and operational values.
    </t>
    <t>
Sometimes the list keys are not identical for configuration
data and the corresponding operational state.
In this case, separate lists MAY be used to represent the
configured and operational values.
    </t>
    <t>
If it is not possible to combine configuration and operational
state, then the keys used to represent list entries SHOULD
be the same type. The &quot;leafref&quot; data type SHOULD be used in
operational state for key leafs that have corresponding
configuration instances. The &quot;require&#8209;instance&quot; statement
MAY be set to &quot;false&quot; (in YANG 1.1 modules only)
to indicate instances are allowed in the operational state
that do not exist in the associated configuration data.
    </t>
    <t>
The need to replicate objects or define different operational state
objects depends on the data model.  It is not possible to define
one approach that will be optimal for all data models.
    </t>
    <t>
Designers SHOULD describe and justify any NMDA exceptions in detail,
such as the use of separate subtrees and/or separate leafs.
The &quot;description&quot; statements for both the configuration and the
operational state SHOULD be used for this purpose.
    </t>
</section>
<section title="NMDA Transition Guidelines">
    <t>
YANG modules SHOULD be designed with the assumption that they will be used on
servers supporting the operational state datastore.  With this in mind,
YANG modules SHOULD define "config false" nodes wherever they make sense
to the data model.  "Config false" nodes SHOULD NOT be defined
to provide the operational value for configuration nodes,
except when the value space of a configured and operational
value may differ, in which case a distinct "config false"
node SHOULD be defined to hold the operational value for the
configured node.
    </t>
    <t>
The following guidelines are meant to help modelers develop
YANG modules that will maximize the utility of the model with
both current and new implementations.
    </t>
    <t>
New modules and modules that are not concerned with the
operational state of configuration information SHOULD
immediately be structured to be NMDA compatible, as
described in <xref target="combine-data"/>. This transition MAY be deferred
if the module does not contain any configuration datastore objects.
    </t>
    <t>
The remaining are options that MAY be followed during the time
that NMDA mechanisms are being defined.
    </t>
    <t><list style="format (%c)"><t>
Modules that require immediate support for the NMDA features
SHOULD be structured for NMDA.  A temporary non-NMDA version of
this type of module MAY exist, as either an
existing model or a model created by hand or with
suitable tools that mirror the current modeling strategies.
Both the NMDA and the non-NMDA modules SHOULD be published in
the same document, with NMDA modules in the document main body
and the non-NMDA modules in a non-normative appendix.  The use
of the non-NMDA module will allow temporary bridging of the
time period until NMDA implementations are available.
    </t>
    <t>
For published models, the model should be republished with
an NMDA-compatible structure, deprecating non-NMDA constructs.
For example, the &quot;ietf&#8209;interfaces&quot; model in <xref target="RFC7223"/> has been
restructured as an NMDA-compatible model in <xref target="RFC8343"/>.
The &quot;/interfaces&#8209;state&quot; hierarchy has been marked &quot;status
deprecated&quot;.  Models that mark their &quot;/foo&#8209;state&quot; hierarchy
with &quot;status deprecated&quot; will allow NMDA-capable
implementations to avoid the cost of duplicating the state
nodes, while enabling non-NMDA-capable implementations to
utilize them for access to the operational values.
    </t>
    <t>
For models that augment models that have not been
structured with the NMDA, the modeler will have to consider
the structure of the base model and the guidelines listed
above.  Where possible, such models should move to new
revisions of the base model that are NMDA compatible.  When
that is not possible, augmenting &quot;state&quot; containers SHOULD be
avoided, with the expectation that the base model will be
re-released with the state containers marked as deprecated.
It is RECOMMENDED to augment only the &quot;/foo&quot; hierarchy of the
base model.  Where this recommendation cannot be followed,
then any new &quot;state&quot; elements SHOULD be included in their own
module.
    </t></list></t>
<section title="Temporary Non-NMDA Modules" anchor="temp-mods">
    <t>
A temporary non-NMDA module allows a non-NMDA-aware client
to access operational state from an NMDA-compliant server.
It contains the top-level "config false" data nodes that would have been
defined in a legacy YANG module (before NMDA).
    </t>
    <t>
A server that needs to support both NMDA and non-NMDA clients
can advertise both the new NMDA module and the temporary non-NMDA module.
A non-NMDA client can use separate &quot;foo&quot; and &quot;foo&#8209;state&quot; subtrees,
except the &quot;foo&#8209;state&quot; subtree is located in a different (temporary) module.
The NMDA module can be used by a non-NMDA client to access the
conventional configuration datastores and the deprecated &lt;get&gt; operation to access
nested "config false" data nodes.
    </t>
    <t>
To create the temporary non-NMDA model from an NMDA model, the
following steps can be taken:
    </t>
<t>
 <list style="symbols">
 <t>
Change the module name by appending &quot;&#8209;state&quot; to the original module name
 </t>
 <t>
Change the namespace by appending &quot;&#8209;state&quot; to the original namespace value
 </t>
 <t>
Change the prefix by appending &quot;&#8209;s&quot; to the original prefix value
 </t>
 <t>
Add an import to the original module (e.g., for typedef definitions)
 </t>
 <t>
Retain or create only the top-level nodes that have a &quot;config&quot; statement
value &quot;false&quot;. These subtrees represent "config false" data nodes that
were combined into the configuration subtree; therefore, they are not available
to non-NMDA aware clients. Set the &quot;status&quot; statement to &quot;deprecated&quot; for each new node.
 </t>
 <t>
The module description SHOULD clearly identify the module as a temporary non-NMDA module
 </t>
 </list>
</t>
</section>
<section title="Example: Create a New NMDA Module">
    <t>
Create an NMDA-compliant module, using combined configuration
and state subtrees, whenever possible.
    </t>
        <figure>
            <artwork><![CDATA[
  module example-foo {
    namespace "urn:example.com:params:xml:ns:yang:example-foo";
    prefix "foo";

    container foo {
      // configuration data child nodes
      // operational value in operational state datastore only
      // may contain "config false" nodes as needed
    }
 }
            ]]></artwork>
        </figure>
</section>
<section title="Example: Convert an Old Non-NMDA Module">
    <t>
Do not remove non-compliant objects from existing modules.
Instead, change the status to &quot;deprecated&quot;. At some point,
usually after 1 year, the status MAY be changed to &quot;obsolete&quot;.
    </t>
    <t>
Old Module:
    </t>
        <figure>
            <artwork><![CDATA[
  module example-foo {
    namespace "urn:example.com:params:xml:ns:yang:example-foo";
    prefix "foo";

    container foo {
      // configuration data child nodes
    }

    container foo-state {
      config false;
      // operational state child nodes
    }
 }
            ]]></artwork>
        </figure>
    <t>
Converted NMDA Module:
    </t>
        <figure>
            <artwork><![CDATA[
  module example-foo {
    namespace "urn:example.com:params:xml:ns:yang:example-foo";
    prefix "foo";

    container foo {
      // configuration data child nodes
      // operational value in operational state datastore only
      // may contain "config false" nodes as needed
      // will contain any data nodes from old foo-state
    }

    // keep original foo-state but change status to deprecated
    container foo-state {
      config false;
      status deprecated;
      // operational state child nodes
    }
 }
            ]]></artwork>
        </figure>
</section>
<section title="Example: Create a Temporary NMDA Module">
    <t>
Create a new module that contains the top-level operational state data nodes
that would have been available before they were combined with configuration
data nodes (to be NMDA compliant).
    </t>
        <figure>
            <artwork><![CDATA[
  module example-foo-state {
    namespace "urn:example.com:params:xml:ns:yang:example-foo-state";
    prefix "foo-s";

    // import new or converted module; not used in this example
    import example-foo { prefix foo; }

    container foo-state {
      config false;
      status deprecated;
      // operational state child nodes
    }
 }
            ]]></artwork>
        </figure>
</section>
</section>
</section>
<section title="Performance Considerations">
    <t>
It is generally likely that certain YANG statements require more
runtime resources than other statements.  Although there are no
performance requirements for YANG validation, the following information
MAY be considered when designing YANG data models:
    </t>
<t>
 <list style="symbols">
 <t>
Lists are generally more expensive than containers
 </t>
 <t>
"when" statement evaluation is generally more expensive than &quot;if&#8209;feature&quot;
or &quot;choice&quot; statements
 </t>
 <t>
&quot;must&quot; statements are generally more expensive than &quot;min&#8209;entries&quot;,
&quot;max&#8209;entries&quot;, &quot;mandatory&quot;, or &quot;unique&quot; statements
 </t>
 <t>
&quot;identityref&quot; leafs are generally more expensive than &quot;enumeration&quot; leafs
 </t>
 <t>
&quot;leafref&quot; and &quot;instance&#8209;identifier&quot; types with &quot;require&#8209;instance&quot; set to true
are generally more expensive than if &quot;require&#8209;instance&quot; is set to false
 </t>
 </list>
</t>
</section>
<section title="Open Systems Considerations">
    <t>
Only the modules imported by a particular module can be assumed
to be present in an implementation.
An open system MAY include any combination of YANG modules.
    </t>
</section>
<section title="Guidelines for Constructs Specific to YANG 1.1">
    <t>
The set of guidelines for YANG 1.1 will grow as operational experience is gained
with the new language features. This section contains an initial set
of guidelines for new YANG 1.1 language features.
    </t>
<section title="Importing Multiple Revisions">
    <t>
Standard modules SHOULD NOT import multiple revisions of the same module
into a module.  This MAY be done if independent definitions (e.g.,
enumeration typedefs) from specific revisions are needed in the
importing module.
    </t>
</section>
<section title="Using Feature Logic">
    <t>
The YANG 1.1 feature logic is much more expressive than YANG 1.0.
A &quot;description&quot; statement SHOULD describe the &quot;if&#8209;feature&quot; logic in text,
to help readers understand the module.
    </t>
    <t>
YANG features SHOULD be used instead of the &quot;when&quot; statement, if possible.
Features are advertised by the server, and objects conditional by the "if-feature" statement are
conceptually grouped together.  There is no such commonality
supported for &quot;when&quot; statements.
    </t>
    <t>
Features generally require less server implementation complexity
and runtime resources than objects that use &quot;when&quot; statements.
Features are generally static (i.e., set when a module is loaded and not changed
at runtime). However, every client edit might cause a &quot;when&quot;
statement result to change.
    </t>
</section>
<section title="&quot;anyxml&quot; versus &quot;anydata&quot;">
    <t>
The &quot;anyxml&quot; statement MUST NOT be used to represent a conceptual subtree
of YANG data nodes.  The &quot;anydata&quot; statement MUST be used for this purpose.
    </t>
</section>
<section title="&quot;action&quot; versus &quot;rpc&quot;">
    <t>
The use of &quot;action&quot; statements or &quot;rpc&quot; statements is a subjective
design decision.  RPC operations are not associated with any particular
data node. Actions are associated with a specific data node definition.
An &quot;action&quot; statement SHOULD be used if the protocol operation
is specific to a subset of all data nodes instead of all possible data nodes.
    </t>
    <t>
The same action name MAY be used in different definitions within different data node.
For example, a &quot;reset&quot; action defined with a data node definition
for an interface might have different parameters than for a power supply
or a VLAN. The same action name SHOULD be used to represent similar semantics.
    </t>
    <t>
The NETCONF Access Control Model (NACM) <xref target="RFC8341"/>
does not support parameter-based access control for RPC operations.
The user is given permission (or not) to invoke the RPC operation with
any parameters. For example, if each client is only allowed to reset their
own interface, then NACM cannot be used.
    </t>
    <t>
For example, NACM cannot enforce access control based on the value
of the &quot;interface&quot; parameter, only the &quot;reset&quot; operation itself:
    </t>
        <figure>
            <artwork><![CDATA[
   rpc reset {
     input {
       leaf interface {
         type if:interface-ref;
         mandatory true;
         description "The interface to reset.";
       }
     }
   }
            ]]></artwork>
        </figure>
    <t>
However, NACM can enforce access control for individual interface
instances, using a &quot;reset&quot; action. If the user does not have read access
to the specific &quot;interface&quot; instance, then it cannot invoke the &quot;reset&quot;
action for that interface instance:
    </t>
        <figure>
            <artwork><![CDATA[
   container interfaces {
     list interface {
       ...
       action reset { }
     }
   }
            ]]></artwork>
        </figure>
</section>
</section>
<section title="Updating YANG Modules (Published versus Unpublished)">
    <t>
YANG modules can change over time. Typically, new data model definitions
are needed to support new features.
YANG update rules defined in Section 11 of <xref target="RFC7950"/>
MUST be followed for published modules. They MAY be followed for
unpublished modules.
    </t>
    <t>
The YANG update rules only apply to published module revisions.
Each organization will have their own way to identify published
work that is considered to be stable and unpublished work
that is considered to be unstable.  For example, in the IETF,
the RFC document is used for published work, and the I-D
is used for unpublished work.
    </t>
</section>
</section>
<section title="IANA Considerations" anchor="IANA">

    <t>
The following registration in the "ns" subregistry of the "IETF XML Registry" <xref target="RFC3688"/> was detailed in  <xref target="RFC6087"/> and has been updated by IANA to reference this document.
    </t>
        <figure>
            <artwork><![CDATA[
    URI: urn:ietf:params:xml:ns:yang:ietf-template

    Registrant Contact: The IESG.

    XML: N/A, the requested URI is an XML namespace.
            ]]></artwork>
        </figure>
    <t>
The following assignment was detailed in <xref target="RFC6087"/> and has been updated by IANA in the "YANG Module Names" registry.

   This document has also been added as a reference for the "YANG
   Module Names" registry itself as it contains the template necessary
   for registration in <xref target="YANGMOD"/>.

    </t>
<?rfc compact="yes"?><texttable title="YANG Registry Assignment">
<ttcol align='left'> Field</ttcol>
<ttcol align='left'>Value</ttcol>
<c>Name</c>
<c>ietf-template</c>
<c>Namespace</c>
<c>urn:ietf:params:xml:ns:yang:ietf-template</c>
<c>Prefix</c>
<c>temp</c>
<c>Reference</c>
<c>RFC 8407</c>
</texttable>
<?rfc compact="no"?></section>
<section title="Security Considerations" anchor="Security">
    <t>
This document defines documentation guidelines for
NETCONF or RESTCONF content defined with the YANG data modeling
language; therefore, it does not introduce
any new or increased security risks into
the management system.
    </t>
</section>

</middle>
<back>
   <references title="Normative References">

<?rfc include="reference.RFC.2119" ?>
<?rfc include="reference.RFC.3688" ?>
<?rfc include="reference.RFC.3986" ?>
<?rfc include="reference.RFC.5378" ?>
<?rfc include="reference.RFC.6020" ?>
<?rfc include="reference.RFC.6241" ?>
<?rfc include="reference.RFC.6242" ?>
<?rfc include="reference.RFC.7950" ?>
<?rfc include="reference.RFC.8040" ?>
<?rfc include="reference.RFC.8174" ?>
<?rfc include="reference.RFC.8446" ?>

<!--draft-nmdsdt-netmod-revised-datastores is now RFC 8342-->
<?rfc include="reference.RFC.8342" ?>

<reference anchor="W3C.REC-xpath" target="http://www.w3.org/TR/1999/REC-xpath-19991116">
      <front>
        <title>XML Path Language (XPath) Version 1.0</title>
        <author initials="J." surname="Clark" fullname="James Clark">
          <organization/>
        </author>
        <author initials="S." surname="DeRose" fullname="Steven DeRose">
          <organization/>
        </author>
        <date month="November" year="1999"/>
      </front>
      <seriesInfo name="W3C Recommendation" value="REC-xpath-19991116"/>
      <format type="HTML" target="http://www.w3.org/TR/1999/REC-xpath-19991116"/>
</reference>

<reference anchor="ID-Guidelines"
           target="https://www.ietf.org/standards/ids/guidelines/">
<front>
<title>Guidelines to Authors of Internet-Drafts</title>
<author initials="R." surname="Housley" fullname="R. Housley">
<organization/>
</author>
<date year="2010" month="December"/>
</front>
</reference>

</references>
<references title="Informative References">

<?rfc include="reference.RFC.2026" ?>
<?rfc include="reference.RFC.4151" ?>
<?rfc include="reference.RFC.4181" ?>
<?rfc include="reference.RFC.8126" ?>
<?rfc include="reference.RFC.6087" ?>
<?rfc include="reference.RFC.7223" ?>

<!--draft-ietf-netconf-rfc6536bis is now RFC 8341-->
<?rfc include="reference.RFC.8341" ?>


<reference anchor="RFC-STYLE"
           target="http://www.rfc-editor.org/styleguide/">
        <front>
            <title>Style Guide</title>
            <author>
              <organization>RFC Editor</organization>
            </author>
            <date/>
        </front>
    </reference>


<?rfc include="reference.RFC.7322" ?>
<?rfc include="reference.RFC.6991" ?>
<?rfc include="reference.RFC.7841" ?>

<!--draft-ietf-netmod-yang-tree-diagrams is now RFC 8340-->
<?rfc include="reference.RFC.8340" ?>

<!--draft-ietf-netmod-rfc8022bis is now RFC 8349-->
<?rfc include="reference.RFC.8349" ?>

<!--draft-ietf-netmod-rfc7223bis is now RFC 8343-->
<?rfc include="reference.RFC.8343" ?>


<reference anchor="IANA-XML"
           target="https://www.iana.org/assignments/xml-registry/">
        <front>
            <title>IETF XML Registry</title>
            <author>
              <organization>IANA</organization>
            </author>
            <date/>
        </front>
    </reference>


<reference anchor="IANA-MOD-NAMES"
           target="https://www.iana.org/assignments/yang-parameters/">
        <front>
            <title>YANG Module Names</title>
            <author>
              <organization>IANA</organization>
            </author>
            <date/>
        </front>
    </reference>

</references>

<section title="Module Review Checklist">
    <t>
This section is adapted from RFC 4181.
    </t>
    <t>
The purpose of a YANG module review is to review
the YANG module for both technical correctness and
adherence to IETF documentation requirements.
The following checklist may be helpful when reviewing
an I-D:
    </t>
<t>
 <list style="symbols">
 <t>
I-D Boilerplate -- verify that the document contains the required
I-D boilerplate (see
&lt;https://www.ietf.org/id-info/guidelines.html&gt;), including the
appropriate statement to permit publication as an RFC, and
that the I-D boilerplate does not contain references or section numbers.
 </t>
 <t>
Abstract -- verify that the abstract does not contain references,
that it does not have a section number, and that its content follows
the guidelines in &lt;https://www.ietf.org/id-info/guidelines.html&gt;.
 </t>
 <t>
Copyright Notice -- verify that the document has the appropriate
text regarding the rights that document contributors provide to
the IETF Trust <xref target="RFC5378"/>.  Verify that it contains the
full IETF Trust copyright notice at the beginning of the document.
The IETF Trust Legal Provisions (TLP) can be found at:
 </t>
 </list>
</t>
         <figure>
            <artwork><![CDATA[
   <https://trustee.ietf.org/license-info/>
            ]]></artwork>
        </figure>
<t>
 <list style="symbols">
 <t>
Security Considerations section -- verify that the document uses the
latest approved template from the Operations and Management (OPS) area website
(see &lt;https://trac.ietf.org/area/ops/trac/wiki/yang-security-guidelines&gt;)
and that the guidelines therein have been followed.
 </t>
 <t>
IANA Considerations section -- this section must always be
present.  For each module within the document, ensure that the
IANA Considerations section contains entries
for the following IANA registries:
 </t>
 </list>
</t>

<t>
  <list style="hanging" hangIndent="6">
    <t>XML Namespace Registry: Register the YANG module namespace.</t>
    <t>YANG Module Registry: Register the YANG module name, prefix,
      namespace, and RFC number, according to the rules specified
      in <xref target="RFC6020"/>.</t>
  </list>
</t>

<t>
 <list style="symbols">
 <t>
References -- verify that the references are properly divided
between normative and informative references, that RFCs 2119 and
8174 are
included as normative references if the terminology defined therein
is used in the document, that all references required by the
boilerplate are present, that all YANG modules containing imported
items are cited as normative references, and that all citations point
to the most current RFCs, unless there is a valid reason to do
otherwise (for example, it is okay to include an informative reference
to a previous version of a specification to help explain a feature
included for backward compatibility).  Be sure citations for all
imported modules are present somewhere in the document
text (outside the YANG module). If a YANG module contains reference
or "description" statements that refer to an I-D,
then the I-D is included as an informative reference.
 </t>
 <t>
License -- verify that the document contains the Simplified BSD
License in each YANG module or submodule. Some guidelines
related to this requirement are described in
<xref target="MODULECOPY"/>.
Make sure that the correct year is used in all
copyright dates.  Use
the approved text from the latest TLP
document, which can be found at:
 </t>
 </list>
</t>
        <figure>
            <artwork><![CDATA[
   <https://trustee.ietf.org/license-info/>
            ]]></artwork>
        </figure>
<t>
 <list style="symbols">
 <t>
Other Issues -- check for any issues mentioned
in &lt;https://www.ietf.org/id-info/checklist.html&gt;
that are not covered elsewhere.
 </t>
 <t>
Technical Content -- review the actual technical content for
compliance with the guidelines in this document.  The use of a YANG
module compiler is recommended when checking for syntax errors.
A list of freely available tools and other information, including formatting advice, can be found at:
 </t>
 </list>
</t>
        <figure>
            <artwork><![CDATA[
   <https://trac.ietf.org/trac/netconf/wiki>
    and
   <https://trac.ietf.org/trac/netmod/wiki>

   Checking for correct syntax, however, is only part of the job.
   It is just as important to actually read the YANG module document
   from the point of view of a potential implementor.  It is
   particularly important to check that "description" statements are
   sufficiently clear and unambiguous to allow interoperable
   implementations to be created.
            ]]></artwork>
        </figure>
      </section>


<section title="YANG Module Template" anchor="YANGMOD">
<t>&lt;CODE BEGINS> file "ietf-template@2016-03-20.yang"</t>
        <figure>
            <artwork><![CDATA[
module ietf-template {
  yang-version 1.1;

  // replace this string with a unique namespace URN value                                 

  namespace "urn:ietf:params:xml:ns:yang:ietf-template";

  // replace this string, and try to pick a unique prefix                                  

  prefix temp;

  // import statements here: e.g.,                                                         
  // import ietf-yang-types { prefix yang; }                                               
  // import ietf-inet-types { prefix inet; }                                               
  // identify the IETF working group if applicable                                         

  organization
    "IETF NETMOD (NETCONF Data Modeling Language) Working Group";

  // update this contact statement with your info                                          

  contact
    "WG Web:   <http://datatracker.ietf.org/wg/your-wg-name/>
     WG List:  <mailto:your-wg-name@ietf.org>

     Editor:   your-name
               <mailto:your-email@example.com>";

  // replace the first sentence in this description statement.                             
  // replace the copyright notice with the most recent                                     
  // version, if it has been updated since the publication                                 
  // of this document                                                                      

  description
    "This module defines a template for other YANG modules.

     Copyright (c) <insert year> IETF Trust and the persons
     identified as authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX; see
     the RFC itself for full legal notices.";

  // RFC Ed.: replace XXXX with actual RFC number and remove
  // this note
  // replace '2016-03-20' with the module publication date
  // the format is (year-month-day)

  revision 2016-03-20 {
    description
      "what changed in this revision";
    reference "RFC XXXX: <Replace With Document Title>";
  }

  // extension statements                                                                  
  // feature statements                                                                    
  // identity statements                                                                   
  // typedef statements                                                                    
  // grouping statements                                                                   
  // data definition statements                                                            
  // augment statements                                                                    
  // rpc statements                                                                        
  // notification statements                                                               
  // DO NOT put deviation statements in a published module                                 
}
            ]]></artwork>
        </figure>
<t>&lt;CODE ENDS></t>
</section>

<section title="Acknowledgments" numbered="no">
    <t>
The structure and contents of this document are adapted from "Guidelines for Authors and Reviewers of MIB Documents" <xref target="RFC4181"/>, by C.&nbsp;M.&nbsp;Heard.
    </t>
    <t>
The working group thanks Martin Bjorklund, Juergen
Schoenwaelder, Ladislav Lhotka, Jernej Tuljak, Lou Berger, Robert Wilton, Kent Watsen,
and William Lupton for their
extensive reviews and contributions to this document.
    </t>
</section>

</back></rfc>
