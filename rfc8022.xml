<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc number="8022" ipr="trust200902" category="std" submissionType="IETF" consensus="yes">

  <front>
    <title abbrev="YANG Routing Management">A YANG Data Model for
    Routing Management</title>

    <author initials="L." surname="Lhotka" fullname="Ladislav Lhotka">
      <organization>CZ.NIC</organization>
      <address>
        <email>lhotka@nic.cz</email>
      </address>
    </author>
    <author initials="A." surname="Lindem" fullname="Acee Lindem">
      <organization>Cisco Systems</organization>
      <address>
        <email>acee@cisco.com</email>
      </address>
    </author>
    <date month="November" year="2016"/>
    
<area>Operations and Management</area>
<workgroup>NETMOD Working Group</workgroup>

<keyword>configuration</keyword>
<keyword>IPv6 router advertisements</keyword>
<keyword>NETCONF</keyword>
<keyword>RESTCONF</keyword>

    <abstract>
      <t>This document contains a specification of three YANG modules
      and one submodule. Together they form the core routing data
      model that serves as a framework for configuring and managing a
      routing subsystem. It is expected that these modules will be
      augmented by additional YANG modules defining data models for
      control-plane protocols, route filters, and other functions. The core
      routing data model provides common building blocks for such
      extensions -- routes, Routing Information Bases (RIBs), and
      control-plane protocols.</t>
    </abstract>
  </front>
  <middle>

    <section anchor="sec.introduction" title="Introduction">

      <t>This document contains a specification of the following YANG
      modules:
      <list style="symbols">
        <t>The "ietf-routing" module provides generic components of a
        routing data model.</t>
        <t>The "ietf-ipv4-unicast-routing" module augments the
        "ietf-routing" module with additional data specific to IPv4
        unicast.</t>
        <t>The "ietf-ipv6-unicast-routing" module augments the
        "ietf-routing" module with additional data specific to IPv6
        unicast. Its submodule "ietf-ipv6-router-advertisements" also
        augments the "ietf-interfaces"&nbsp;<xref target="RFC7223"/> and
        "ietf-ip"&nbsp;<xref target="RFC7277"/> modules with IPv6 router
        configuration variables required by <xref target="RFC4861"/>.</t>
      </list></t>

      <t>These modules together define the so-called core routing data
      model, which is intended as a basis for future data model
      development covering more-sophisticated routing systems. While
      these three modules can be directly used for simple IP devices
      with static routing (see <xref target="app.minimum"/>), their
      main purpose is to provide essential building blocks for more-complicated data models involving multiple control-plane protocols,
      multicast routing, additional address families, and advanced
      functions such as route filtering or policy routing. 


To this
      end, it is expected that the core routing data model will be
      augmented by numerous modules developed by various IETF working
      groups.</t>

    </section>

    <section anchor="sec.term-not" title="Terminology and Notation">

      
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>


      <t>The following terms are defined in <xref target="RFC6241"/>:
      <list style="symbols">
        <t>client</t>
        <t>message</t>
        <t>protocol operation</t>
        <t>server</t>
      </list></t>

      <t>The following terms are defined in <xref target="RFC7950"/>:
      <list style="symbols">
	<t>action</t>
        <t>augment</t>
        <t>configuration data</t>
        <t>container</t>
        <t>container with presence</t>
        <t>data model</t>
        <t>data node</t>
        <t>feature</t>
        <t>leaf</t>
        <t>list</t>
        <t>mandatory node</t>
        <t>module</t>
        <t>schema tree</t>
        <t>state data</t>
        <t>RPC (Remote Procedure Call) operation</t>
      </list></t>

      <section anchor="sec.new-terms" title="Glossary of New Terms">
        <t><list style="hanging">
          <t hangText="core routing data model:"> YANG data model
          comprising "ietf-routing", "ietf-ipv4-unicast-routing", and
          "ietf-ipv6-unicast-routing" modules.</t>
          <t hangText="direct route:">a route to a directly connected
          network.</t>
          <t hangText="Routing Information Base (RIB):">An object
          containing a list of routes together with other
          information. See <xref target="sec.rib"/> for details.</t>
          <t hangText="system-controlled entry:">An entry of a list in
          state data ("config false") that is created by the system
          independently of what has been explicitly configured. See
          <xref target="sec.system-user"/> for details.</t>
          <t hangText="user-controlled entry:">An entry of a list in
          state data ("config false") that is created and deleted as a
          direct consequence of certain configuration changes. See
          <xref target="sec.system-user"/> for details.</t>
        </list></t>
      </section>

      <section anchor="sec.tree-symbols" title="Tree Diagrams">
        <t>A simplified graphical representation of the complete data
        tree is presented in <xref target="app.data-tree"/>, and similar
        diagrams of its various subtrees appear in the main text.</t>
        
<t><list style="symbols">
  <t>Brackets "[" and "]" enclose list keys.</t>
  <t>Curly braces "{" and "}" contain names of optional features that
  make the corresponding node conditional.</t>
  <t>Abbreviations before data node names: "rw" means configuration
  (read-write), "ro" state data (read-only), "-x" RPC operations or
  actions, and "-n" notifications.</t>
  <t>Symbols after data node names: "?" means an optional node, "!" a
  container with presence, and "*" denotes a "list" or "leaf-list".</t>
  <t>Parentheses enclose choice and case nodes, and case nodes are
  also marked with a colon (":").</t>
  <t>Ellipsis ("...")  stands for contents of subtrees that are not
  shown.</t>
</list></t>

      </section>

      <section anchor="sec.prefixes" title="Prefixes in Data Node Names">
        <t>In this document, names of data nodes, actions, and other
        data model objects are often used without a prefix, as long as
        it is clear from the context in which YANG module each name is
        defined. Otherwise, names are prefixed using the standard prefix
        associated with the corresponding YANG module, as shown in <xref target="tab.prefixes"/>.</t>

        <texttable anchor="tab.prefixes" title="Prefixes and Corresponding YANG Modules">
          <ttcol>Prefix</ttcol>
          <ttcol>YANG module</ttcol>
          <ttcol>Reference</ttcol>
          <c>if</c><c>ietf-interfaces</c><c><xref target="RFC7223"/></c>
          <c>ip</c><c>ietf-ip</c><c><xref target="RFC7277"/></c>
          <c>rt</c><c>ietf-routing</c><c><xref target="sec.mod-rt"/></c>
          <c>v4ur</c><c>ietf-ipv4-unicast-routing</c>
          <c><xref target="sec.mod-v4ur"/></c>
          <c>v6ur</c><c>ietf-ipv6-unicast-routing</c>
          <c><xref target="sec.mod-v6ur"/></c>
          <c>yang</c><c>ietf-yang-types</c><c><xref target="RFC6991"/></c>
          <c>inet</c><c>ietf-inet-types</c><c><xref target="RFC6991"/></c>
        </texttable>
      </section>

    </section>

    <section anchor="sec.objectives" title="Objectives">
      <t>The initial design of the core routing data model was driven by
      the following objectives:
      <list style="symbols">
        <t>The data model should be suitable for the common address
        families -- in particular, IPv4 and IPv6 -- and for unicast and
        multicast routing, as well as Multiprotocol Label Switching
        (MPLS).</t>
        <t>A simple IP routing system, such as one that uses only
        static routing, should be configurable in a simple way,
        ideally without any need to develop additional YANG
        modules.</t>
        <t>On the other hand, the core routing framework must allow
        for complicated implementations involving multiple Routing
        Information Bases (RIBs) and multiple control-plane protocols, as
        well as controlled redistributions of routing information.</t>
        <t>
Because device vendors will want to map the data models built on this
    generic framework to their proprietary data models and
    configuration interfaces, the framework should be
    flexible enough to facilitate that and accommodate data
    models with different logic.</t>
      </list>
      </t>
    </section>

    <section anchor="sec.design" title="The Design of the Core Routing Data Model">

      <t>The core routing data model consists of three YANG modules
      and one submodule. The first module, "ietf-routing", defines the
      generic components of a routing system. The other two modules,
      "ietf-ipv4-unicast-routing" and "ietf-ipv6-unicast-routing",
      augment the "ietf-routing" module with additional data nodes
      that are needed for IPv4 and IPv6 unicast routing,
      respectively. The "ietf-ipv6-unicast-routing" module has a
      submodule, "ietf-ipv6-router-advertisements", that augments the
      "ietf-interfaces"&nbsp;<xref target="RFC7223"/> and "ietf-ip"&nbsp;<xref target="RFC7277"/> modules with configuration variables for IPv6
      router advertisements as required by <xref target="RFC4861"/>. Figures <xref target="fig.confdata" format="counter"/> and&nbsp;<xref target="fig.statedata" format="counter"/> show abridged views of the configuration and
      state data hierarchies. See <xref target="app.data-tree"/> for
      the complete data trees.</t>

      <figure anchor="fig.confdata" title="Configuration Data Hierarchy">
        <artwork>
+--rw routing
   +--rw router-id?
   +--rw control-plane-protocols
   |  +--rw control-plane-protocol* [type name]
   |     +--rw type
   |     +--rw name
   |     +--rw description?
   |     +--rw static-routes
   |        +--rw v6ur:ipv6
   |        |     ...
   |        +--rw v4ur:ipv4
   |              ...
   +--rw ribs
      +--rw rib* [name]
         +--rw name
         +--rw address-family?
         +--rw description?
</artwork>

      </figure>

      <figure anchor="fig.statedata" title="State Data Hierarchy">
        <artwork>
+--ro routing-state
   +--ro router-id?
   +--ro interfaces
   |  +--ro interface*
   +--ro control-plane-protocols
   |  +--ro control-plane-protocol* [type name]
   |     +--ro type
   |     +--ro name
   +--ro ribs
      +--ro rib* [name]
         +--ro name
         +--ro address-family
         +--ro default-rib?
         +--ro routes
         |  +--ro route*
         |        ...
</artwork>

      </figure>

      <t>As can be seen from Figures <xref target="fig.confdata" format="counter"/> and&nbsp;<xref target="fig.statedata" format="counter"/>, the core routing data model introduces
      several generic components of a routing framework: routes, RIBs
      containing lists of routes, and control-plane protocols. <xref target="sec.building-blocks"/> describes these components in
      more detail.</t>

      <section anchor="sec.system-user" title="System-Controlled and User-Controlled List Entries">
        <t>The core routing data model defines several lists in the
        schema tree, such as "rib", that have to be populated with at
        least one entry in any properly functioning device, and
        additional entries may be configured by a client.</t>
        <t>In such a list, the server creates the required item as a
        so-called system-controlled entry in state data, i.e., inside
        the "routing-state" container.</t>
        <t>An example can be seen in <xref target="app.get-reply"/>: the
        "/routing-state/ribs/rib" list has two
        system-controlled entries named "ipv4-master" and
        "ipv6-master".</t>
        <t>Additional entries may be created in the configuration by
        a client, e.g., via the NETCONF protocol. These are so-called
        user-controlled entries. If the server accepts a configured
        user-controlled entry, then this entry also appears in the
        state data version of the list.</t>
        <t>Corresponding entries in both versions of the list (in
        state data and configuration) have the same value of the list
        key.</t>
        <t>A client may also provide supplemental configuration of
        system-controlled entries. To do so, the client creates a new
        entry in the configuration with the desired contents. In order
        to bind this entry to the corresponding entry in the state
        data list, the key of the configuration entry has to be set to
        the same value as the key of the state entry.</t>
        <t>Deleting a user-controlled entry from the configuration list
        results in the removal of the corresponding entry in the
        state data list. In contrast, if a system-controlled
        entry is deleted from the configuration list, only the extra
        configuration specified in that entry is removed but the
        corresponding state data entry remains in the list.</t>
      </section>

    </section>

    <section anchor="sec.building-blocks" title="Basic Building Blocks">

      <t>This section describes the essential components of the core
      routing data model.</t>

      <section anchor="sec.route" title="Route">
        <t>Routes are basic elements of information in a routing
        system. The core routing data model defines only the following
        minimal set of route attributes:
        <list style="symbols">
          <t>"destination-prefix": address prefix specifying the set
          of destination addresses for which the route may be
          used. This attribute is mandatory.</t>
          <t>"route-preference": an integer value (also known as
          administrative distance) that is used for selecting a
          preferred route among routes with the same destination
          prefix. A lower value means a more preferred route.</t>


          <t>"next-hop": determines the outgoing interface and/or
          next-hop address(es), or a special operation to be performed with a
          packet.</t>
        </list>
        </t>
        <t>Routes are primarily state data that appear as entries of
        RIBs (<xref target="sec.rib"/>) but they may also be found in
        configuration data, for example, as manually configured static
        routes. In the latter case, configurable route attributes are
        generally a subset of attributes defined for RIB routes.</t>
      </section>

      <section anchor="sec.rib" title="Routing Information Base (RIB)">
        <t>Every implementation of the core routing data model manages
        one or more Routing Information Bases (RIBs). A RIB is a list
        of routes complemented with administrative data. Each RIB
        contains only routes of one address family. An address family
        is represented by an identity derived from the
        "rt:address-family" base identity.</t>
        <t>In the core routing data model, RIBs are state data
        represented as entries of the list
        "/routing-state/ribs/rib". The contents of
        RIBs are controlled and manipulated by control-plane protocol
        operations that may result in route additions, removals, and
        modifications. This also includes manipulations via the
        "static" and/or "direct" pseudo-protocols; see <xref target="sec.pseudoproto"/>.</t>

        <t>For every supported address family, exactly one RIB MUST be
        marked as the so-called default RIB to which control-plane
	protocols place their routes by default.</t>

        <t>Simple router implementations that do not advertise the
        feature "multiple-ribs" will typically create one
        system-controlled RIB per supported address family and mark
        it as the default RIB.</t>

        <t>More-complex router implementations advertising the
        "multiple-ribs" feature support multiple RIBs per address
        family that can be used for policy routing and other
        purposes.</t>

        <t>The following action (see Section&nbsp;7.15 of <xref target="RFC7950"/>) is defined for the "rib" list:
        <list style="symbols">
          <t>active-route -- return the active RIB route for the
          destination address that is specified as the action's input
          parameter.</t>
        </list></t>

      </section>

      <section anchor="sec.proto" title="Control-Plane Protocol">

        <t>The core routing data model provides an open-ended
        framework for defining multiple control-plane protocol
        instances, e.g., for Layer 3 routing protocols. Each control-plane protocol instance MUST be assigned a type, which is an
        identity derived from the "rt:control&nbhy;plane-protocol" base
        identity. The core routing data model defines two identities
        for the direct and static pseudo-protocols (<xref target="sec.pseudoproto"/>).</t>
        <t>Multiple control-plane protocol instances of the same type MAY be
        configured.</t>

        <section anchor="sec.pseudoproto" title="Routing Pseudo-Protocols">

          <t>The core routing data model defines two special routing
          protocol types -- "direct" and "static". Both are in fact
          pseudo-protocols, which means that they are confined to the
          local device and do not exchange any routing information
          with adjacent routers.</t>
          <t>Every implementation of the core routing data model MUST
          provide exactly one instance of the "direct" pseudo-protocol
          type. It is the source of direct routes for all configured
          address families. Direct routes are normally supplied by the
          operating system kernel, based on the configuration of
          network interface addresses; see <xref target="sec.ietf-ip"/>.</t>
          <t>A pseudo-protocol of the type "static" allows for specifying
          routes manually. It MAY be configured in zero or multiple
          instances, although a typical configuration will have exactly
          one instance.</t>
        </section>

        <section anchor="sec.newproto" title="Defining New Control-Plane Protocols">
          <t>It is expected that future YANG modules will create data
          models for additional control-plane protocol types. Such a new
          module has to define the protocol-specific configuration and
          state data, and it has to integrate it into the core routing
          framework in the following way:
          <list style="symbols">
            <t>A new identity MUST be defined for the control-plane protocol,
            and its base identity MUST be set to "rt:control-plane-protocol"
            or to an identity derived from "rt:control&nbhy;plane-protocol".</t>
            <t>Additional route attributes MAY be defined, preferably in
            one place by means of defining a YANG grouping. The new
            attributes have to be inserted by augmenting the definitions
            of the nodes
            <figure>
              <artwork>
    /rt:routing-state/rt:ribs/rt:rib/rt:routes/rt:route
              </artwork>
            </figure>
            and
            <figure>
              <artwork>
    /rt:routing-state/rt:ribs/rt:rib/rt:output/rt:route,
              </artwork>
            </figure>
            and possibly other places in the configuration, state
            data, notifications, and input/output parameters of
            actions or RPC operations.</t>
            <t>Configuration parameters and/or state data for the new
            protocol can be defined by augmenting the
            "control-plane-protocol" data node under both "/routing"
            and "/routing-state".</t>
          </list></t>
          <t>By using a "when" statement, the augmented configuration
          parameters and state data specific to the new protocol
          SHOULD be made conditional and valid only if the value of
          "rt:type" or "rt:source&nbhy;protocol" is equal to (or derived
          from) the new protocol's identity.</t>
          <t>It is also RECOMMENDED that protocol-specific data nodes
          be encapsulated in an appropriately named container with
          presence. Such a container may contain mandatory data nodes
          that are otherwise forbidden at the top level of an
          augment.</t>
          <t>The above steps are implemented by the example YANG
          module for the Routing Information Protocol (RIP) in <xref
          target="app.rip"/>.</t>

        </section>
      </section>

      <section anchor="sec.4861" title="Parameters of IPv6 Router Advertisements">

        <t>YANG module "ietf-ipv6-router-advertisements" (<xref target="sec.mod-v6ra"/>), which is a submodule of the
        "ietf-ipv6-unicast-routing" module, augments the configuration
        and state data of IPv6 interfaces with definitions of the
        following variables as required by Section 6.2.1 of <xref target="RFC4861"/>:
        <list style="symbols">
          <t>send-advertisements</t>
          <t>max-rtr-adv-interval</t>
          <t>min-rtr-adv-interval</t>
          <t>managed-flag</t>
          <t>other-config-flag</t>
          <t>link-mtu</t>
          <t>reachable-time</t>
          <t>retrans-timer</t>
          <t>cur-hop-limit</t>
          <t>default-lifetime</t>
          <t>prefix-list: a list of prefixes to be advertised.<vspace blankLines="1"/>The
          following parameters are associated with each prefix in the
          list:
          <list style="symbols">
            <t>valid-lifetime</t>
            <t>on-link-flag</t>
            <t>preferred-lifetime</t>
            <t>autonomous-flag</t>
          </list></t>
        </list></t>
        <t>NOTES:</t>
        <t><list style="numbers">
          <t>The "IsRouter" flag, which is also required by <xref target="RFC4861"/>, is implemented in the "ietf-ip" module
          <xref target="RFC7277"/> (leaf "ip:forwarding").</t>
          <t>The original specification <xref target="RFC4861"/>
          allows the implementations to decide whether the
          "valid-lifetime" and "preferred-lifetime" parameters remain
          the same in consecutive advertisements or decrement in real
          time. However, the latter behavior seems problematic because
          the values might be reset again to the (higher) configured
          values after a configuration is reloaded. Moreover, no
          implementation is known to use the decrementing
          behavior. The "ietf-ipv6-router-advertisements" submodule
          therefore stipulates the former behavior with constant
          values.</t>
        </list></t>

      </section>

    </section>

    <section anchor="sec.interactions" title="Interactions with Other YANG Modules">
      <t>The semantics of the core routing data model also depends on
      several configuration parameters that are defined in other YANG
      modules.</t>

      <section anchor="sec.ietf-if" title="Module &quot;ietf-interfaces&quot;">
        <t>The following boolean switch is defined in the
        "ietf-interfaces" YANG module <xref target="RFC7223"/>:
        <list style="hanging">
          <t hangText="/if:interfaces/if:interface/if:enabled">
            <vspace blankLines="1"/>
            If this switch is set to "false" for a network-layer
            interface, then all routing and forwarding functions MUST
            be disabled on this interface.
          </t>
        </list>
        </t>
      </section>

      <section anchor="sec.ietf-ip" title="Module &quot;ietf-ip&quot;">
        <t>The following boolean switches are defined in the "ietf-ip"
        YANG module <xref target="RFC7277"/>:
        <list style="hanging">
          <t hangText="/if:interfaces/if:interface/ip:ipv4/ip:enabled">
            <vspace blankLines="1"/>
            If this switch is set to "false" for a network-layer
            interface, then all IPv4 routing and forwarding functions
            MUST be disabled on this interface.
          </t>
          <t hangText="/if:interfaces/if:interface/ip:ipv4/ip:forwarding">
            <vspace blankLines="1"/>
            If this switch is set to "false" for a network-layer
            interface, then the forwarding of IPv4 datagrams through
            this interface MUST be disabled. However, the interface MAY
            participate in other IPv4 routing functions, such as routing
            protocols.
          </t>
          <t hangText="/if:interfaces/if:interface/ip:ipv6/ip:enabled">
            <vspace blankLines="1"/>
            If this switch is set to "false" for a network-layer
            interface, then all IPv6 routing and forwarding functions
            MUST be disabled on this interface.
          </t>
          <t hangText="/if:interfaces/if:interface/ip:ipv6/ip:forwarding">
            <vspace blankLines="1"/>
            If this switch is set to "false" for a network-layer
            interface, then the forwarding of IPv6 datagrams through
            this interface MUST be disabled. However, the interface MAY
            participate in other IPv6 routing functions, such as routing
            protocols.
          </t>
        </list>
        </t>
        <t>In addition, the "ietf-ip" module allows for configuring IPv4
        and IPv6 addresses and network prefixes or masks on network-layer
         interfaces. Configuration of these parameters on an
        enabled interface MUST result in an immediate creation of the
        corresponding direct route. The destination prefix of this route
        is set according to the configured IP address and network
        prefix/mask, and the interface is set as the outgoing interface
        for that route.</t>
      </section>

    </section>

    <section anchor="sec.mod-rt" title="Routing Management YANG Module">

      <figure>
        <artwork>
&lt;CODE BEGINS&gt; file "ietf-routing@2016-11-04.yang"

module ietf-routing {

  yang-version "1.1";

  namespace "urn:ietf:params:xml:ns:yang:ietf-routing";

  prefix "rt";

  import ietf-yang-types {
    prefix "yang";
  }

  import ietf-interfaces {
    prefix "if";
  }

  organization
    "IETF NETMOD (NETCONF Data Modeling Language) Working Group";

  contact
    "WG Web:&nbsp;&nbsp;&nbsp;&lt;https://datatracker.ietf.org/wg/netmod/&gt;
     WG List:&nbsp;&nbsp;&lt;mailto:netmod@ietf.org&gt;

     WG Chair: Lou Berger
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mailto:lberger@labn.net&gt;

     WG Chair: Kent Watsen
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mailto:kwatsen@juniper.net&gt;

     Editor:&nbsp;&nbsp;&nbsp;Ladislav Lhotka
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mailto:lhotka@nic.cz&gt;

     Editor:&nbsp;&nbsp;&nbsp;Acee Lindem
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mailto:acee@cisco.com&gt;";

  description
    "This YANG module defines essential components for the management
     of a routing subsystem.

     Copyright (c) 2016 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
     NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'MAY', and
     'OPTIONAL' in the module text are to be interpreted as described
     in RFC&nbsp;2119.

     This version of this YANG module is part of RFC&nbsp;8022; 
     see the RFC itself for full legal notices.";

  revision 2016-11-04 {
    description
      "Initial revision.";
    reference
      "RFC 8022: A YANG Data Model for Routing Management";
  }

  /* Features */

  feature multiple-ribs {
    description
      "This feature indicates that the server supports user-defined
       RIBs.

       Servers that do not advertise this feature SHOULD provide
       exactly one system-controlled RIB per supported address family
       and make it also the default RIB.  This RIB then appears as an
       entry of the list /routing-state/ribs/rib.";
  }

  feature router-id {
    description
      "This feature indicates that the server supports configuration
       of an explicit 32-bit router ID that is used by some routing
       protocols.

       Servers that do not advertise this feature set a router ID
       algorithmically, usually to one of the configured IPv4 
       addresses.  However, this algorithm is implementation
       specific.";
  }

  /* Identities */

  identity address-family {
    description
      "Base identity from which identities describing address
       families are derived.";
  }

  identity ipv4 {
    base address-family;
    description
      "This identity represents IPv4 address family.";
  }

  identity ipv6 {
    base address-family;
    description
      "This identity represents IPv6 address family.";
  }

  identity control-plane-protocol {
    description
      "Base identity from which control-plane protocol identities are
       derived.";
  }

  identity routing-protocol {
    base control-plane-protocol;
    description
      "Identity from which Layer 3 routing protocol identities are
       derived.";
  }

  identity direct {
    base routing-protocol;
    description
      "Routing pseudo-protocol that provides routes to directly
       connected networks.";
  }

  identity static {
    base routing-protocol;
    description
      "Static routing pseudo-protocol.";
  }

  /* Type Definitions */

  typedef route-preference {
    type uint32;
    description
      "This type is used for route preferences.";
  }

  /* Groupings */

  grouping address-family {
    description
      "This grouping provides a leaf identifying an address
       family.";
    leaf address-family {
      type identityref {
        base address-family;
      }
      mandatory "true";
      description
        "Address family.";
    }
  }

  grouping router-id {
    description
      "This grouping provides router ID.";
    leaf router-id {
      type yang:dotted-quad;
      description
        "A 32-bit number in the form of a dotted quad that is used by
         some routing protocols identifying a router.";
      reference
        "RFC 2328: OSPF Version 2.";
    }
  }

  grouping special-next-hop {
    description
      "This grouping provides a leaf with an enumeration of special
       next hops.";
    leaf special-next-hop {
      type enumeration {
        enum blackhole {
          description
            "Silently discard the packet.";
        }
        enum unreachable {
          description
            "Discard the packet and notify the sender with an error
             message indicating that the destination host is
             unreachable.";
        }
        enum prohibit {
          description
            "Discard the packet and notify the sender with an error
             message indicating that the communication is
             administratively prohibited.";
        }
        enum receive {
          description
            "The packet will be received by the local system.";
        }
      }
      description
        "Options for special next hops.";
    }
  }

  grouping next-hop-content {
    description
      "Generic parameters of next hops in static routes.";
    choice next-hop-options {
      mandatory "true";
      description
        "Options for next hops in static routes.

         It is expected that further cases will be added through
         augments from other modules.";
      case simple-next-hop {
        description
          "This case represents a simple next hop consisting of the
           next-hop address and/or outgoing interface.

           Modules for address families MUST augment this case with a
           leaf containing a next-hop address of that address
           family.";
        leaf outgoing-interface {
          type if:interface-ref;
          description
            "Name of the outgoing interface.";
        }
      }
      case special-next-hop {
        uses special-next-hop;
      }
      case next-hop-list {
        container next-hop-list {
          description
            "Container for multiple next-hops.";
          list next-hop {
            key "index";
            description
              "An entry of a next-hop list.

               Modules for address families MUST augment this list
               with a leaf containing a next-hop address of that
               address family.";
            leaf index {
              type string;
              description
                "A user-specified identifier utilized to uniquely
                 reference the next-hop entry in the next-hop list.
                 The value of this index has no semantic meaning
                 other than for referencing the entry.";
            }
            leaf outgoing-interface {
              type if:interface-ref;
              description
                "Name of the outgoing interface.";
            }
          }
        }
      }
    }
  }

  grouping next-hop-state-content {
    description
      "Generic parameters of next hops in state data.";
    choice next-hop-options {
      mandatory "true";
      description
        "Options for next hops in state data.

         It is expected that further cases will be added through
         augments from other modules, e.g., for recursive
         next hops.";
      case simple-next-hop {
        description
          "This case represents a simple next hop consisting of the
           next-hop address and/or outgoing interface.

           Modules for address families MUST augment this case with a
           leaf containing a next-hop address of that address
           family.";
        leaf outgoing-interface {
          type if:interface-state-ref;
          description
            "Name of the outgoing interface.";
        }
      }
      case special-next-hop {
        uses special-next-hop;
      }
      case next-hop-list {
        container next-hop-list {
          description
            "Container for multiple next hops.";
          list next-hop {
            description
              "An entry of a next-hop list.

               Modules for address families MUST augment this list
               with a leaf containing a next-hop address of that
               address family.";
            leaf outgoing-interface {
              type if:interface-state-ref;
              description
                "Name of the outgoing interface.";
            }
          }
        }
      }
    }
  }

  grouping route-metadata {
    description
      "Common route metadata.";
    leaf source-protocol {
      type identityref {
        base routing-protocol;
      }
      mandatory "true";
      description
        "Type of the routing protocol from which the route
         originated.";
    }
    leaf active {
      type empty;
      description
        "Presence of this leaf indicates that the route is preferred
         among all routes in the same RIB that have the same
         destination prefix.";
    }
    leaf last-updated {
      type yang:date-and-time;
      description
        "Time stamp of the last modification of the route.  If the
         route was never modified, it is the time when the route was
         inserted into the RIB.";
    }
  }

  /* State data */

  container routing-state {
    config "false";
    description
      "State data of the routing subsystem.";
    uses router-id {
      description
        "Global router ID.

         It may be either configured or assigned algorithmically by
         the implementation.";
    }
    container interfaces {
      description
        "Network-layer interfaces used for routing.";
      leaf-list interface {
        type if:interface-state-ref;
        description
          "Each entry is a reference to the name of a configured
           network-layer interface.";
      }
    }
    container control-plane-protocols {
      description
        "Container for the list of routing protocol instances.";
      list control-plane-protocol {
        key "type name";
        description
          "State data of a control-plane protocol instance.

           An implementation MUST provide exactly one
           system-controlled instance of the 'direct'
           pseudo-protocol.  Instances of other control-plane
           protocols MAY be created by configuration.";
        leaf type {
          type identityref {
            base control-plane-protocol;
          }
          description
            "Type of the control-plane protocol.";
        }
        leaf name {
          type string;
          description
            "The name of the control-plane protocol instance.

             For system-controlled instances this name is persistent,
             i.e., it SHOULD NOT change across reboots.";
        }
      }
    }
    container ribs {
      description
        "Container for RIBs.";
      list rib {
        key "name";
        min-elements "1";
        description
          "Each entry represents a RIB identified by the 'name' key.
           All routes in a RIB MUST belong to the same address
           family.

           An implementation SHOULD provide one system-controlled
           default RIB for each supported address family.";
        leaf name {
          type string;
          description
            "The name of the RIB.";
        }
        uses address-family;
        leaf default-rib {
          if-feature "multiple-ribs";
          type boolean;
          default "true";
          description
            "This flag has the value of 'true' if and only if the RIB
             is the default RIB for the given address family.

             By default, control-plane protocols place their routes
             in the default RIBs.";
        }
        container routes {
          description
            "Current content of the RIB.";
          list route {
            description
              "A RIB route entry.  This data node MUST be augmented
               with information specific for routes of each address
               family.";
            leaf route-preference {
              type route-preference;
              description
                "This route attribute, also known as administrative
                 distance, allows for selecting the preferred route
                 among routes with the same destination prefix.  A
                 smaller value means a more preferred route.";
            }
            container next-hop {
              description
                "Route's next-hop attribute.";
              uses next-hop-state-content;
            }
            uses route-metadata;
          }
        }
        action active-route {
          description
            "Return the active RIB route that is used for the
             destination address.

             Address-family-specific modules MUST augment input
             parameters with a leaf named 'destination-address'.";
          output {
            container route {
              description
                "The active RIB route for the specified destination.

                 If no route exists in the RIB for the destination
                 address, no output is returned.

                 Address-family-specific modules MUST augment this
                 container with appropriate route contents.";
              container next-hop {
                description
                  "Route's next-hop attribute.";
                uses next-hop-state-content;
              }
              uses route-metadata;
            }
          }
        }
      }
    }
  }

  /* Configuration Data */

  container routing {
    description
      "Configuration parameters for the routing subsystem.";
    uses router-id {
      if-feature "router-id";
      description
        "Configuration of the global router ID.  Routing protocols
         that use router ID can use this parameter or override it
         with another value.";
    }
    container control-plane-protocols {
      description
        "Configuration of control-plane protocol instances.";
      list control-plane-protocol {
        key "type name";
        description
          "Each entry contains configuration of a control-plane
           protocol instance.";
        leaf type {
          type identityref {
            base control-plane-protocol;
          }
          description
            "Type of the control-plane protocol - an identity derived
             from the 'control-plane-protocol' base identity.";
        }
        leaf name {
          type string;
          description
            "An arbitrary name of the control-plane protocol
             instance.";
        }
        leaf description {
          type string;
          description
            "Textual description of the control-plane protocol
             instance.";
        }
        container static-routes {
          when "derived-from-or-self(../type, 'rt:static')" {
            description
              "This container is only valid for the 'static' routing
               protocol.";
          }
          description
            "Configuration of the 'static' pseudo-protocol.

             Address-family-specific modules augment this node with
             their lists of routes.";
        }
      }
    }
    container ribs {
      description
        "Configuration of RIBs.";
      list rib {
        key "name";
        description
          "Each entry contains configuration for a RIB identified by
           the 'name' key.

           Entries having the same key as a system-controlled entry
           of the list /routing-state/ribs/rib are used for
           configuring parameters of that entry.  Other entries 
           define additional user-controlled RIBs.";
        leaf name {
          type string;
          description
            "The name of the RIB.

             For system-controlled entries, the value of this leaf
             must be the same as the name of the corresponding entry
             in state data.

             For user-controlled entries, an arbitrary name can be
             used.";
        }
        uses address-family {
          description
            "Address family of the RIB.

             It is mandatory for user-controlled RIBs.  For
             system-controlled RIBs it can be omitted; otherwise, it
             must match the address family of the corresponding state
             entry.";
          refine "address-family" {
            mandatory "false";
          }
        }
        leaf description {
          type string;
          description
            "Textual description of the RIB.";
        }
      }
    }
  }
}

&lt;CODE ENDS&gt;</artwork>

      </figure>

    </section>

    <section anchor="sec.mod-v4ur" title="IPv4 Unicast Routing Management YANG Module">

      <figure>
        <artwork>
&lt;CODE BEGINS&gt; file "ietf-ipv4-unicast-routing@2016-11-04.yang"

module ietf-ipv4-unicast-routing {

  yang-version "1.1";

  namespace "urn:ietf:params:xml:ns:yang:ietf-ipv4-unicast-routing";

  prefix "v4ur";

  import ietf-routing {
    prefix "rt";
  }

  import ietf-inet-types {
    prefix "inet";
  }

  organization
    "IETF NETMOD (NETCONF Data Modeling Language) Working Group";

  contact
    "WG Web:&nbsp;&nbsp;&nbsp;&lt;https://datatracker.ietf.org/wg/netmod/&gt;
     WG List:&nbsp;&nbsp;&lt;mailto:netmod@ietf.org&gt;

     WG Chair: Lou Berger
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mailto:lberger@labn.net&gt;

     WG Chair: Kent Watsen
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mailto:kwatsen@juniper.net&gt;

     Editor:&nbsp;&nbsp;&nbsp;Ladislav Lhotka
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mailto:lhotka@nic.cz&gt;

     Editor:&nbsp;&nbsp;&nbsp;Acee Lindem
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mailto:acee@cisco.com&gt;";

  description
    "This YANG module augments the 'ietf-routing' module with basic
     configuration and state data for IPv4 unicast routing.

     Copyright (c) 2016 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
     NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'MAY', and
     'OPTIONAL' in the module text are to be interpreted as described
     in RFC&nbsp;2119.

     This version of this YANG module is part of RFC&nbsp;8022; 
     see the RFC itself for full legal notices.";

  revision 2016-11-04 {
    description
      "Initial revision.";
    reference
      "RFC 8022: A YANG Data Model for Routing Management";
  }

  /* Identities */

  identity ipv4-unicast {
    base rt:ipv4;
    description
      "This identity represents the IPv4 unicast address family.";
  }

  /* State data */

  augment "/rt:routing-state/rt:ribs/rt:rib/rt:routes/rt:route" {
    when "derived-from-or-self(../../rt:address-family, "
       + "'v4ur:ipv4-unicast')" {
      description
        "This augment is valid only for IPv4 unicast.";
    }
    description
      "This leaf augments an IPv4 unicast route.";
    leaf destination-prefix {
      type inet:ipv4-prefix;
      description
        "IPv4 destination prefix.";
    }
  }

  augment "/rt:routing-state/rt:ribs/rt:rib/rt:routes/rt:route/"
        + "rt:next-hop/rt:next-hop-options/rt:simple-next-hop" {
    when "derived-from-or-self(../../../rt:address-family, "
       + "'v4ur:ipv4-unicast')" {
      description
        "This augment is valid only for IPv4 unicast.";
    }
    description
      "Augment 'simple-next-hop' case in IPv4 unicast routes.";
    leaf next-hop-address {
      type inet:ipv4-address;
      description
        "IPv4 address of the next hop.";
    }
  }

  augment "/rt:routing-state/rt:ribs/rt:rib/rt:routes/rt:route/"
        + "rt:next-hop/rt:next-hop-options/rt:next-hop-list/"
        + "rt:next-hop-list/rt:next-hop" {
    when "derived-from-or-self(../../../../../rt:address-family, "
       + "'v4ur:ipv4-unicast')" {
      description
        "This augment is valid only for IPv4 unicast.";
    }
    description
      "This leaf augments the 'next-hop-list' case of IPv4 unicast
       routes.";
    leaf address {
      type inet:ipv4-address;
      description
        "IPv4 address of the next-hop.";
    }
  }

  augment
    "/rt:routing-state/rt:ribs/rt:rib/rt:active-route/rt:input" {
    when "derived-from-or-self(../rt:address-family, "
       + "'v4ur:ipv4-unicast')" {
      description
        "This augment is valid only for IPv4 unicast RIBs.";
    }
    description
      "This augment adds the input parameter of the 'active-route'
       action.";
    leaf destination-address {
      type inet:ipv4-address;
      description
        "IPv4 destination address.";
    }
  }

  augment "/rt:routing-state/rt:ribs/rt:rib/rt:active-route/"
        + "rt:output/rt:route" {
    when "derived-from-or-self(../../rt:address-family, "
       + "'v4ur:ipv4-unicast')" {
      description
        "This augment is valid only for IPv4 unicast.";
    }
    description
      "This augment adds the destination prefix to the reply of the
       'active-route' action.";
    leaf destination-prefix {
      type inet:ipv4-prefix;
      description
        "IPv4 destination prefix.";
    }
  }

  augment "/rt:routing-state/rt:ribs/rt:rib/rt:active-route/"
        + "rt:output/rt:route/rt:next-hop/rt:next-hop-options/"
        + "rt:simple-next-hop" {
    when "derived-from-or-self(../../../rt:address-family, "
       + "'v4ur:ipv4-unicast')" {
      description
        "This augment is valid only for IPv4 unicast.";
    }
    description
      "Augment 'simple-next-hop' case in the reply to the
       'active-route' action.";
    leaf next-hop-address {
      type inet:ipv4-address;
      description
        "IPv4 address of the next hop.";
    }
  }

  augment "/rt:routing-state/rt:ribs/rt:rib/rt:active-route/"
        + "rt:output/rt:route/rt:next-hop/rt:next-hop-options/"
        + "rt:next-hop-list/rt:next-hop-list/rt:next-hop" {
    when "derived-from-or-self(../../../../../rt:address-family, "
       + "'v4ur:ipv4-unicast')" {
      description
        "This augment is valid only for IPv4 unicast.";
    }
    description
      "Augment 'next-hop-list' case in the reply to the
       'active-route' action.";
    leaf next-hop-address {
      type inet:ipv4-address;
      description
        "IPv4 address of the next hop.";
    }
  }

  /* Configuration data */

  augment "/rt:routing/rt:control-plane-protocols/"
        + "rt:control-plane-protocol/rt:static-routes" {
    description
      "This augment defines the configuration of the 'static'
       pseudo-protocol with data specific to IPv4 unicast.";
    container ipv4 {
      description
        "Configuration of a 'static' pseudo-protocol instance
         consists of a list of routes.";
      list route {
        key "destination-prefix";
        description
          "A list of static routes.";
        leaf destination-prefix {
          type inet:ipv4-prefix;
          mandatory "true";
          description
            "IPv4 destination prefix.";
        }
        leaf description {
          type string;
          description
            "Textual description of the route.";
        }
        container next-hop {
          description
            "Configuration of next-hop.";
          uses rt:next-hop-content {
            augment "next-hop-options/simple-next-hop" {
              description
                "Augment 'simple-next-hop' case in IPv4 static
                 routes.";
              leaf next-hop-address {
                type inet:ipv4-address;
                description
                  "IPv4 address of the next hop.";
              }
            }
            augment "next-hop-options/next-hop-list/next-hop-list/"
                  + "next-hop" {
              description
                "Augment 'next-hop-list' case in IPv4 static
                 routes.";
              leaf next-hop-address {
                type inet:ipv4-address;
                description
                  "IPv4 address of the next hop.";
              }
            }
          }
        }
      }
    }
  }
}

&lt;CODE ENDS&gt;</artwork>

      </figure>

    </section>

    <section anchor="sec.mod-v6ur" title="IPv6 Unicast Routing Management YANG Module">

      <figure>
        <artwork>
&lt;CODE BEGINS&gt; file "ietf-ipv6-unicast-routing@2016-11-04.yang"

module ietf-ipv6-unicast-routing {

  yang-version "1.1";

  namespace "urn:ietf:params:xml:ns:yang:ietf-ipv6-unicast-routing";

  prefix "v6ur";

  import ietf-routing {
    prefix "rt";
  }

  import ietf-inet-types {
    prefix "inet";
  }

  include ietf-ipv6-router-advertisements {
    revision-date 2016-11-04;
  }

  organization
    "IETF NETMOD (NETCONF Data Modeling Language) Working Group";

  contact
    "WG Web:&nbsp;&nbsp;&nbsp;&lt;https://datatracker.ietf.org/wg/netmod/&gt;
     WG List:&nbsp;&nbsp;&lt;mailto:netmod@ietf.org&gt;

     WG Chair: Lou Berger
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mailto:lberger@labn.net&gt;

     WG Chair: Kent Watsen
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mailto:kwatsen@juniper.net&gt;

     Editor:&nbsp;&nbsp;&nbsp;Ladislav Lhotka
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mailto:lhotka@nic.cz&gt;

     Editor:&nbsp;&nbsp;&nbsp;Acee Lindem
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mailto:acee@cisco.com&gt;";

  description
    "This YANG module augments the 'ietf-routing' module with basic
     configuration and state data for IPv6 unicast routing.

     Copyright (c) 2016 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
     NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'MAY', and
     'OPTIONAL' in the module text are to be interpreted as described
     in RFC&nbsp;2119.

     This version of this YANG module is part of RFC&nbsp;8022; 
     see the RFC itself for full legal notices.";

  revision 2016-11-04 {
    description
      "Initial revision.";
    reference
      "RFC 8022: A YANG Data Model for Routing Management";
  }

  /* Identities */

  identity ipv6-unicast {
    base rt:ipv6;
    description
      "This identity represents the IPv6 unicast address family.";
  }

  /* State data */

  augment "/rt:routing-state/rt:ribs/rt:rib/rt:routes/rt:route" {
    when "derived-from-or-self(../../rt:address-family, "
       + "'v6ur:ipv6-unicast')" {
      description
        "This augment is valid only for IPv6 unicast.";
    }
    description
      "This leaf augments an IPv6 unicast route.";
    leaf destination-prefix {
      type inet:ipv6-prefix;
      description
        "IPv6 destination prefix.";
    }
  }

  augment "/rt:routing-state/rt:ribs/rt:rib/rt:routes/rt:route/"
        + "rt:next-hop/rt:next-hop-options/rt:simple-next-hop" {
    when "derived-from-or-self(../../../rt:address-family, "
       + "'v6ur:ipv6-unicast')" {
      description
        "This augment is valid only for IPv6 unicast.";
    }
    description
      "Augment 'simple-next-hop' case in IPv6 unicast routes.";
    leaf next-hop-address {
      type inet:ipv6-address;
      description
        "IPv6 address of the next hop.";
    }
  }

  augment "/rt:routing-state/rt:ribs/rt:rib/rt:routes/rt:route/"
        + "rt:next-hop/rt:next-hop-options/rt:next-hop-list/"
        + "rt:next-hop-list/rt:next-hop" {
    when "derived-from-or-self(../../../../../rt:address-family, "
       + "'v6ur:ipv6-unicast')" {
      description
        "This augment is valid only for IPv6 unicast.";
    }
    description
      "This leaf augments the 'next-hop-list' case of IPv6 unicast
       routes.";
    leaf address {
      type inet:ipv6-address;
      description
        "IPv6 address of the next hop.";
    }
  }

  augment
    "/rt:routing-state/rt:ribs/rt:rib/rt:active-route/rt:input" {
    when "derived-from-or-self(../rt:address-family, "
       + "'v6ur:ipv6-unicast')" {
      description
        "This augment is valid only for IPv6 unicast RIBs.";
    }
    description
      "This augment adds the input parameter of the 'active-route'
       action.";
    leaf destination-address {
      type inet:ipv6-address;
      description
        "IPv6 destination address.";
    }
  }

  augment "/rt:routing-state/rt:ribs/rt:rib/rt:active-route/"
        + "rt:output/rt:route" {
    when "derived-from-or-self(../../rt:address-family, "
       + "'v6ur:ipv6-unicast')" {
      description
        "This augment is valid only for IPv6 unicast.";
    }
    description
      "This augment adds the destination prefix to the reply of the
       'active-route' action.";
    leaf destination-prefix {
      type inet:ipv6-prefix;
      description
        "IPv6 destination prefix.";
    }
  }

  augment "/rt:routing-state/rt:ribs/rt:rib/rt:active-route/"
        + "rt:output/rt:route/rt:next-hop/rt:next-hop-options/"
        + "rt:simple-next-hop" {
    when "derived-from-or-self(../../../rt:address-family, "
       + "'v6ur:ipv6-unicast')" {
      description
        "This augment is valid only for IPv6 unicast.";
    }
    description
      "Augment 'simple-next-hop' case in the reply to the
       'active-route' action.";
    leaf next-hop-address {
      type inet:ipv6-address;
      description
        "IPv6 address of the next hop.";
    }
  }

  augment "/rt:routing-state/rt:ribs/rt:rib/rt:active-route/"
        + "rt:output/rt:route/rt:next-hop/rt:next-hop-options/"
        + "rt:next-hop-list/rt:next-hop-list/rt:next-hop" {
    when "derived-from-or-self(../../../../../rt:address-family, "
       + "'v6ur:ipv6-unicast')" {
      description
        "This augment is valid only for IPv6 unicast.";
    }
    description
      "Augment 'next-hop-list' case in the reply to the
       'active-route' action.";
    leaf next-hop-address {
      type inet:ipv6-address;
      description
        "IPv6 address of the next hop.";
    }
  }

  /* Configuration data */

  augment "/rt:routing/rt:control-plane-protocols/"
        + "rt:control-plane-protocol/rt:static-routes" {
    description
      "This augment defines the configuration of the 'static'
       pseudo-protocol with data specific to IPv6 unicast.";
    container ipv6 {
      description
        "Configuration of a 'static' pseudo-protocol instance
         consists of a list of routes.";
      list route {
        key "destination-prefix";
        description
          "A list of static routes.";
        leaf destination-prefix {
          type inet:ipv6-prefix;
          mandatory "true";
          description
            "IPv6 destination prefix.";
        }
        leaf description {
          type string;
          description
            "Textual description of the route.";
        }
        container next-hop {
          description
            "Configuration of next-hop.";
          uses rt:next-hop-content {
            augment "next-hop-options/simple-next-hop" {
              description
                "Augment 'simple-next-hop' case in IPv6 static
                 routes.";
              leaf next-hop-address {
                type inet:ipv6-address;
                description
                  "IPv6 address of the next hop.";
              }
            }
            augment "next-hop-options/next-hop-list/next-hop-list/"
                  + "next-hop" {
              description
                "Augment 'next-hop-list' case in IPv6 static
                 routes.";
              leaf next-hop-address {
                type inet:ipv6-address;
                description
                  "IPv6 address of the next hop.";
              }
            }
          }
        }
      }
    }
  }
}

&lt;CODE ENDS&gt;</artwork>

      </figure>

      <section anchor="sec.mod-v6ra" title="IPv6 Router Advertisements Submodule">

      <figure>
        <artwork>
&lt;CODE BEGINS&gt; file "ietf-ipv6-router-advertisements@2016-11-04.yang"

submodule ietf-ipv6-router-advertisements {

  yang-version "1.1";

  belongs-to ietf-ipv6-unicast-routing {
    prefix "v6ur";
  }

  import ietf-inet-types {
    prefix "inet";
  }

  import ietf-interfaces {
    prefix "if";
  }

  import ietf-ip {
    prefix "ip";
  }

  organization
    "IETF NETMOD (NETCONF Data Modeling Language) Working Group";

  contact
    "WG Web:&nbsp;&nbsp;&nbsp;&lt;https://datatracker.ietf.org/wg/netmod/&gt;
     WG List:&nbsp;&nbsp;&lt;mailto:netmod@ietf.org&gt;

     WG Chair: Lou Berger
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mailto:lberger@labn.net&gt;

     WG Chair: Kent Watsen
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mailto:kwatsen@juniper.net&gt;

     Editor:&nbsp;&nbsp;&nbsp;Ladislav Lhotka
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mailto:lhotka@nic.cz&gt;

     Editor:&nbsp;&nbsp;&nbsp;Acee Lindem
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mailto:acee@cisco.com&gt;";

  description
    "This YANG module augments the 'ietf-ip' module with
     configuration and state data of IPv6 router advertisements.

     Copyright (c) 2016 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
     NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'MAY', and
     'OPTIONAL' in the module text are to be interpreted as described
     in RFC&nbsp;2119.

     This version of this YANG module is part of RFC&nbsp;8022; 
     see the RFC itself for full legal notices.";

  reference
    "RFC 4861: Neighbor Discovery for IP version 6 (IPv6).";

  revision 2016-11-04 {
    description
      "Initial revision.";
    reference
      "RFC 8022: A YANG Data Model for Routing Management";
  }

  /* State data */

  augment "/if:interfaces-state/if:interface/ip:ipv6" {
    description
      "Augment interface state data with parameters of IPv6 router
       advertisements.";
    container ipv6-router-advertisements {
      description
        "Parameters of IPv6 Router Advertisements.";
      leaf send-advertisements {
        type boolean;
        description
          "A flag indicating whether or not the router sends periodic
           Router Advertisements and responds to Router
           Solicitations.";
      }
      leaf max-rtr-adv-interval {
        type uint16 {
          range "4..1800";
        }
        units "seconds";
        description
          "The maximum time allowed between sending unsolicited
           multicast Router Advertisements from the interface.";
      }
      leaf min-rtr-adv-interval {
        type uint16 {
          range "3..1350";
        }
        units "seconds";
        description
          "The minimum time allowed between sending unsolicited
           multicast Router Advertisements from the interface.";
      }
      leaf managed-flag {
        type boolean;
        description
          "The value that is placed in the 'Managed address
           configuration' flag field in the Router Advertisement.";
      }
      leaf other-config-flag {
        type boolean;
        description
          "The value that is placed in the 'Other configuration' flag
           field in the Router Advertisement.";
      }
      leaf link-mtu {
        type uint32;
        description
          "The value that is placed in MTU options sent by the
           router.  A value of zero indicates that no MTU options are
           sent.";
      }
      leaf reachable-time {
        type uint32 {
          range "0..3600000";
        }
        units "milliseconds";
        description
          "The value that is placed in the Reachable Time field in
           the Router Advertisement messages sent by the router.  A
           value of zero means unspecified (by this router).";
      }
      leaf retrans-timer {
        type uint32;
        units "milliseconds";
        description
          "The value that is placed in the Retrans Timer field in the
           Router Advertisement messages sent by the router.  A value
           of zero means unspecified (by this router).";
      }

      leaf cur-hop-limit {
        type uint8;
        description
          "The value that is placed in the Cur Hop Limit field in the
           Router Advertisement messages sent by the router.  A value
           of zero means unspecified (by this router).";
      }
      leaf default-lifetime {
        type uint16 {
          range "0..9000";
        }
        units "seconds";
        description
          "The value that is placed in the Router Lifetime field of
           Router Advertisements sent from the interface, in seconds.
           A value of zero indicates that the router is not to be
           used as a default router.";
      }
      container prefix-list {
        description
          "A list of prefixes that are placed in Prefix Information
           options in Router Advertisement messages sent from the
           interface.

           By default, these are all prefixes that the router
           advertises via routing protocols as being on-link for the
           interface from which the advertisement is sent.";
        list prefix {
          key "prefix-spec";
          description
            "Advertised prefix entry and its parameters.";
          leaf prefix-spec {
            type inet:ipv6-prefix;
            description
              "IPv6 address prefix.";
          }
          leaf valid-lifetime {
            type uint32;
            units "seconds";
            description
              "The value that is placed in the Valid Lifetime in the
               Prefix Information option.  The designated value of 
               all 1's (0xffffffff) represents infinity.

               An implementation SHOULD keep this value constant in
               consecutive advertisements except when it is
               explicitly changed in configuration.";
          }
          leaf on-link-flag {
            type boolean;
            description
              "The value that is placed in the on-link flag ('L-bit')
               field in the Prefix Information option.";
          }
          leaf preferred-lifetime {
            type uint32;
            units "seconds";
            description
              "The value that is placed in the Preferred Lifetime in
               the Prefix Information option, in seconds.  The
               designated value of all 1's (0xffffffff) represents
               infinity.

               An implementation SHOULD keep this value constant in
               consecutive advertisements except when it is
               explicitly changed in configuration.";
          }
          leaf autonomous-flag {
            type boolean;
            description
              "The value that is placed in the Autonomous Flag field
               in the Prefix Information option.";
          }
        }
      }
    }
  }

  /* Configuration data */

  augment "/if:interfaces/if:interface/ip:ipv6" {
    description
      "Augment interface configuration with parameters of IPv6 router
       advertisements.";
    container ipv6-router-advertisements {
      description
        "Configuration of IPv6 Router Advertisements.";
      leaf send-advertisements {
        type boolean;
        default "false";
        description
          "A flag indicating whether or not the router sends periodic
           Router Advertisements and responds to Router
           Solicitations.";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvSendAdvertisements.";
      }
      leaf max-rtr-adv-interval {
        type uint16 {
          range "4..1800";
        }
        units "seconds";
        default "600";
        description
          "The maximum time allowed between sending unsolicited
           multicast Router Advertisements from the interface.";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           MaxRtrAdvInterval.";
      }
      leaf min-rtr-adv-interval {
        type uint16 {
          range "3..1350";
        }
        units "seconds";
        must ". &lt;= 0.75 * ../max-rtr-adv-interval" {
          description
            "The value MUST NOT be greater than 75% of
             'max-rtr-adv-interval'.";
        }
        description
          "The minimum time allowed between sending unsolicited
           multicast Router Advertisements from the interface.

           The default value to be used operationally if this leaf is
           not configured is determined as follows:

           - if max-rtr-adv-interval &gt;= 9 seconds, the default 
             value is 0.33 * max-rtr-adv-interval;

           - otherwise, it is 0.75 * max-rtr-adv-interval.";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           MinRtrAdvInterval.";
      }
      leaf managed-flag {
        type boolean;
        default "false";
        description
          "The value to be placed in the 'Managed address
           configuration' flag field in the Router Advertisement.";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvManagedFlag.";
      }
      leaf other-config-flag {
        type boolean;
        default "false";
        description
          "The value to be placed in the 'Other configuration' flag
           field in the Router Advertisement.";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvOtherConfigFlag.";
      }
      leaf link-mtu {
        type uint32;
        default "0";
        description
          "The value to be placed in MTU options sent by the router.
           A value of zero indicates that no MTU options are sent.";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvLinkMTU.";
      }
      leaf reachable-time {
        type uint32 {
          range "0..3600000";
        }
        units "milliseconds";
        default "0";
        description
          "The value to be placed in the Reachable Time field in the
           Router Advertisement messages sent by the router.  A value
           of zero means unspecified (by this router).";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvReachableTime.";
      }
      leaf retrans-timer {
        type uint32;
        units "milliseconds";
        default "0";
        description
          "The value to be placed in the Retrans Timer field in the
           Router Advertisement messages sent by the router.  A value
           of zero means unspecified (by this router).";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvRetransTimer.";
      }
      leaf cur-hop-limit {
        type uint8;
        description
          "The value to be placed in the Cur Hop Limit field in the
           Router Advertisement messages sent by the router.  A value
           of zero means unspecified (by this router).

           If this parameter is not configured, the device SHOULD use
           the value specified in IANA Assigned Numbers that was in
           effect at the time of implementation.";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvCurHopLimit.

           IANA: IP Parameters,
           http://www.iana.org/assignments/ip-parameters";
      }
      leaf default-lifetime {
        type uint16 {
          range "0..9000";
        }
        units "seconds";
        description
          "The value to be placed in the Router Lifetime field of
           Router Advertisements sent from the interface, in seconds.
           It MUST be either zero or between max-rtr-adv-interval and
           9000 seconds.  A value of zero indicates that the router 
           is not to be used as a default router.  These limits may 
           be overridden by specific documents that describe how IPv6
           operates over different link layers.

           If this parameter is not configured, the device SHOULD use
           a value of 3 * max-rtr-adv-interval.";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvDefaultLifeTime.";
      }
      container prefix-list {
        description
          "Configuration of prefixes to be placed in Prefix
           Information options in Router Advertisement messages sent
           from the interface.

           Prefixes that are advertised by default but do not have
           their entries in the child 'prefix' list are advertised
           with the default values of all parameters.

           The link-local prefix SHOULD NOT be included in the list
           of advertised prefixes.";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvPrefixList.";
        list prefix {
          key "prefix-spec";
          description
            "Configuration of an advertised prefix entry.";
          leaf prefix-spec {
            type inet:ipv6-prefix;
            description
              "IPv6 address prefix.";
          }
          choice control-adv-prefixes {
            default "advertise";
            description
              "Either the prefix is explicitly removed from the
               set of advertised prefixes, or the parameters with 
               which it is advertised are specified (default case).";
            leaf no-advertise {
              type empty;
              description
                "The prefix will not be advertised.

                 This can be used for removing the prefix from the
                 default set of advertised prefixes.";
            }
            case advertise {
              leaf valid-lifetime {
                type uint32;
                units "seconds";
                default "2592000";
                description
                  "The value to be placed in the Valid Lifetime in
                   the Prefix Information option.  The designated
                   value of all 1's (0xffffffff) represents
                   infinity.";
                reference
                  "RFC 4861: Neighbor Discovery for IP version 6
                   (IPv6) - AdvValidLifetime.";
              }
              leaf on-link-flag {
                type boolean;
                default "true";
                description
                  "The value to be placed in the on-link flag
                   ('L-bit') field in the Prefix Information
                   option.";
                reference
                  "RFC 4861: Neighbor Discovery for IP version 6
                   (IPv6) - AdvOnLinkFlag.";
              }
              leaf preferred-lifetime {
                type uint32;
                units "seconds";
                must ". &lt;= ../valid-lifetime" {
                  description
                    "This value MUST NOT be greater than
                     valid-lifetime.";
                }
                default "604800";
                description
                  "The value to be placed in the Preferred Lifetime
                   in the Prefix Information option.  The designated
                   value of all 1's (0xffffffff) represents
                   infinity.";
                reference
                  "RFC 4861: Neighbor Discovery for IP version 6
                   (IPv6) - AdvPreferredLifetime.";
              }
              leaf autonomous-flag {
                type boolean;
                default "true";
                description
                  "The value to be placed in the Autonomous Flag
                   field in the Prefix Information option.";
                reference
                  "RFC 4861: Neighbor Discovery for IP version 6
                   (IPv6) - AdvAutonomousFlag.";
              }
            }
          }
        }
      }
    }
  }
}

&lt;CODE ENDS&gt;</artwork>

      </figure>

    </section>

    </section>

    <section anchor="sec.iana" title="IANA Considerations">

      <t>This document registers the following namespace URIs in the
      "IETF XML Registry" <xref target="RFC3688"/>:</t>
      <figure>
        <artwork>
URI: urn:ietf:params:xml:ns:yang:ietf-routing
Registrant Contact: The IESG.
XML: N/A; the requested URI is an XML namespace.
        </artwork>
      </figure>
      <figure>
        <artwork>
URI: urn:ietf:params:xml:ns:yang:ietf-ipv4-unicast-routing
Registrant Contact: The IESG.
XML: N/A; the requested URI is an XML namespace.
        </artwork>
      </figure>
      <figure>
        <artwork>
URI: urn:ietf:params:xml:ns:yang:ietf-ipv6-unicast-routing
Registrant Contact: The IESG.
XML: N/A; the requested URI is an XML namespace.
        </artwork>
      </figure>

      <t>This document registers the following YANG modules in the "YANG
      Module Names" registry <xref target="RFC6020"/>:</t>

      <figure>
        <artwork>
Name:         ietf-routing
Namespace:    urn:ietf:params:xml:ns:yang:ietf-routing
Prefix:       rt
Reference:    RFC 8022
        </artwork>
      </figure>
      <figure>
        <artwork>
Name:         ietf-ipv4-unicast-routing
Namespace:    urn:ietf:params:xml:ns:yang:ietf-ipv4-unicast-routing
Prefix:       v4ur
Reference:    RFC 8022
        </artwork>
      </figure>
      <figure>
        <artwork>
Name:         ietf-ipv6-unicast-routing
Namespace:    urn:ietf:params:xml:ns:yang:ietf-ipv6-unicast-routing
Prefix:       v6ur
Reference:    RFC 8022
        </artwork>
      </figure>

      <t>This document registers the following YANG submodule in the "YANG
      Module Names" registry <xref target="RFC6020"/>:</t>

      <figure>
        <artwork>
Name:         ietf-ipv6-router-advertisements
Module:       ietf-ipv6-unicast-routing
Reference:    RFC 8022
        </artwork>
      </figure>
    </section>

    <section anchor="sec-cons" title="Security Considerations">

      <t>Configuration and state data conforming to the core routing
      data model (defined in this document) are designed to be
      accessed via a management protocol with a secure transport layer,
      such as NETCONF <xref target="RFC6241"/>. The NETCONF access
      control model <xref target="RFC6536"/> provides the means to
      restrict access for particular NETCONF users to a preconfigured
      subset of all available NETCONF protocol operations and
      content.</t>
      <t>A number of configuration data nodes defined in the YANG
      modules belonging to the core routing data model are
      writable/creatable/deletable (i.e., "config true" in YANG terms,
      which is the default).  These data nodes may be considered
      sensitive or vulnerable in some network environments.  Write
      operations to these data nodes, such as "edit-config" in
      NETCONF, can have negative effects on the network if the
      protocol operations are not properly protected.</t>
      <t>The vulnerable "config true" parameters and subtrees are the
      following:
      <list style="hanging">

        <t hangText="/routing/control-plane-protocols/control-plane-protocol:">This
        list specifies the control-plane protocols configured on a
        device.</t>

        <t hangText="/routing/ribs/rib:">This list
        specifies the RIBs configured for the device.</t>
      </list>

      Unauthorized access to any of these lists can adversely affect the
      routing subsystem of both the local device and the network. This
      may lead to network malfunctions, delivery of packets to
      inappropriate destinations, and other problems.</t>

    </section>

  </middle>

  <back>

    <references title="Normative References">
   <?rfc include="reference.RFC.2119"?>
   <?rfc include="reference.RFC.3688"?>
   <?rfc include="reference.RFC.4861"?>
   <?rfc include="reference.RFC.6020"?>
   <?rfc include="reference.RFC.6241"?>
   <?rfc include="reference.RFC.6991"?>
   <?rfc include="reference.RFC.7223"?>
   <?rfc include="reference.RFC.7277"?>
   <?rfc include="reference.RFC.7950"?>
    </references>

    <references title="Informative References">
   <?rfc include="reference.RFC.6087"?>
   <?rfc include="reference.RFC.6536"?>
   <?rfc include="reference.RFC.7895"?>
   <?rfc include="reference.RFC.7951"?>
    </references>

    <section anchor="app.data-tree" title="The Complete Data Trees">

      <t>This appendix presents the complete configuration and
      state data trees of the core routing data model.
      See <xref target="sec.tree-symbols"/> for an explanation of the
      symbols used. The data type of every leaf node is shown near the right
      end of the corresponding line.</t>

      <section anchor="app.config-tree" title="Configuration Data">

        <figure>
          <artwork>
+--rw routing
   +--rw router-id?                 yang:dotted-quad
   +--rw control-plane-protocols
   |  +--rw control-plane-protocol* [type name]
   |     +--rw type             identityref
   |     +--rw name             string
   |     +--rw description?     string
   |     +--rw static-routes
   |        +--rw v6ur:ipv6
   |        |  +--rw v6ur:route* [destination-prefix]
   |        |     +--rw v6ur:destination-prefix    inet:ipv6-prefix
   |        |     +--rw v6ur:description?          string
   |        |     +--rw v6ur:next-hop
   |        |        +--rw (v6ur:next-hop-options)
   |        |           +--:(v6ur:simple-next-hop)
   |        |           |  +--rw v6ur:outgoing-interface?
   |        |           |  +--rw v6ur:next-hop-address?
   |        |           +--:(v6ur:special-next-hop)
   |        |           |  +--rw v6ur:special-next-hop?   enumeration
   |        |           +--:(v6ur:next-hop-list)
   |        |              +--rw v6ur:next-hop-list
   |        |                 +--rw v6ur:next-hop* [index]
   |        |                    +--rw v6ur:index              string
   |        |                    +--rw v6ur:outgoing-interface?
   |        |                    +--rw v6ur:next-hop-address?
   |        +--rw v4ur:ipv4
   |           +--rw v4ur:route* [destination-prefix]
   |              +--rw v4ur:destination-prefix    inet:ipv4-prefix
   |              +--rw v4ur:description?          string
   |              +--rw v4ur:next-hop
   |                 +--rw (v4ur:next-hop-options)
   |                    +--:(v4ur:simple-next-hop)
   |                    |  +--rw v4ur:outgoing-interface?
   |                    |  +--rw v4ur:next-hop-address?
   |                    +--:(v4ur:special-next-hop)
   |                    |  +--rw v4ur:special-next-hop?   enumeration
   |                    +--:(v4ur:next-hop-list)
   |                       +--rw v4ur:next-hop-list
   |                          +--rw v4ur:next-hop* [index]
   |                             +--rw v4ur:index              string
   |                             +--rw v4ur:outgoing-interface?
   |                             +--rw v4ur:next-hop-address?
   +--rw ribs
      +--rw rib* [name]
         +--rw name              string
         +--rw address-family?   identityref
         +--rw description?      string
</artwork>

        </figure>

      </section>

      <section anchor="app.state-tree" title="State Data">

        <figure>
          <artwork>
   +--ro routing-state
   |  +--ro router-id?                 yang:dotted-quad
   |  +--ro interfaces
   |  |  +--ro interface*   if:interface-state-ref
   |  +--ro control-plane-protocols
   |  |  +--ro control-plane-protocol* [type name]
   |  |     +--ro type    identityref
   |  |     +--ro name    string
   |  +--ro ribs
   |     +--ro rib* [name]
   |        +--ro name              string
   |        +--ro address-family    identityref
   |        +--ro default-rib?      boolean {multiple-ribs}?
   |        +--ro routes
   |        |  +--ro route*
   |        |     +--ro route-preference?          route-preference
   |        |     +--ro next-hop
   |        |     |  +--ro (next-hop-options)
   |        |     |     +--:(simple-next-hop)
   |        |     |     |  +--ro outgoing-interface?
   |        |     |     |  +--ro v6ur:next-hop-address?
   |        |     |     |  +--ro v4ur:next-hop-address?
   |        |     |     +--:(special-next-hop)
   |        |     |     |  +--ro special-next-hop?        enumeration
   |        |     |     +--:(next-hop-list)
   |        |     |        +--ro next-hop-list
   |        |     |           +--ro next-hop*
   |        |     |              +--ro outgoing-interface?
   |        |     |              +--ro v6ur:address?
   |        |     |              +--ro v4ur:address?
   |        |     +--ro source-protocol            identityref
   |        |     +--ro active?                    empty
   |        |     +--ro last-updated?              yang:date-and-time
   |        |     +--ro v6ur:destination-prefix?   inet:ipv6-prefix
   |        |     +--ro v4ur:destination-prefix?   inet:ipv4-prefix
   |        +---x active-route
   |           +---w input
   |           |  +---w v6ur:destination-address?   inet:ipv6-address
   |           |  +---w v4ur:destination-address?   inet:ipv4-address
   |           +--ro output
   |              +--ro route
   |                 +--ro next-hop
   |                 |  +--ro (next-hop-options)
   |                 |     +--:(simple-next-hop)
   |                 |     |  +--ro outgoing-interface?
   |                 |     |  +--ro v6ur:next-hop-address?
   |                 |     |  +--ro v4ur:next-hop-address?
   |                 |     +--:(special-next-hop)
   |                 |     |  +--ro special-next-hop?     enumeration
   |                 |     +--:(next-hop-list)
   |                 |        +--ro next-hop-list
   |                 |           +--ro next-hop*
   |                 |              +--ro outgoing-interface?
   |                 |              +--ro v6ur:next-hop-address?
   |                 |              +--ro v4ur:next-hop-address?
   |                 +--ro source-protocol            identityref
   |                 +--ro active?                    empty
   |                 +--ro last-updated?           yang:date-and-time
   |                 +--ro v6ur:destination-prefix?  inet:ipv6-prefix
   |                 +--ro v4ur:destination-prefix?  inet:ipv4-prefix
</artwork>

        </figure>

      </section>

    </section>

    <section anchor="app.minimum" title="Minimum Implementation">

      <t>Some parts and options of the core routing model, such as
      user-defined RIBs, are intended only for advanced routers. This
      appendix gives basic non-normative guidelines for implementing a
      bare minimum of available functions. Such an implementation may
      be used for hosts or very simple routers.</t>
      <t>A minimum implementation does not support the feature
      "multiple&nbhy;ribs". This means that a single system-controlled RIB
      is available for each supported address family -- IPv4, IPv6, or
      both. These RIBs are also the default RIBs. No user-controlled
      RIBs are allowed.</t>
      <t>In addition to the mandatory instance of the "direct"
      pseudo-protocol, a minimum implementation should support
      configuring instance(s) of the "static" pseudo-protocol.</t>
      <t>For hosts that are never intended to act as routers, the
      ability to turn on sending IPv6 router advertisements (<xref target="sec.4861"/>) should be removed.</t>
      <t>Platforms with severely constrained resources may use
      deviations for restricting the data model, e.g., limiting the
      number of "static" control-plane protocol instances.</t>

    </section>

    <section anchor="app.rip" title="Example: Adding a New Control-Plane Protocol">

      <t>This appendix demonstrates how the core routing data model
      can be extended to support a new control-plane protocol. The YANG
      module "example-rip" shown below is intended as an illustration
      rather than a real definition of a data model for the Routing
      Information Protocol (RIP). For the sake of brevity, this module does not
      obey all the guidelines specified in <xref target="RFC6087"/>. See also <xref target="sec.newproto"/>.</t>

      <figure>
        <artwork>
module example-rip {

  yang-version "1.1";

  namespace "http://example.com/rip";

  prefix "rip";

  import ietf-interfaces {
    prefix "if";
  }

  import ietf-routing {
    prefix "rt";
  }

  identity rip {
    base rt:routing-protocol;
    description
      "Identity for the Routing Information Protocol (RIP).";
  }

  typedef rip-metric {
    type uint8 {
      range "0..16";
    }
  }

  grouping route-content {
    description
      "This grouping defines RIP-specific route attributes.";
    leaf metric {
      type rip-metric;
    }
    leaf tag {
      type uint16;
      default "0";
      description
        "This leaf may be used to carry additional info, e.g., 
         autonomous system (AS) number.";
    }
  }

  augment "/rt:routing-state/rt:ribs/rt:rib/rt:routes/rt:route" {
    when "derived-from-or-self(rt:source-protocol, 'rip:rip')" {
      description
        "This augment is only valid for a route whose source
         protocol is RIP.";
    }
    description
      "RIP-specific route attributes.";
    uses route-content;
  }

  augment "/rt:routing-state/rt:ribs/rt:rib/rt:active-route/"
        + "rt:output/rt:route" {
    description
      "RIP-specific route attributes in the output of 'active-route'
       RPC.";
    uses route-content;
  }

  augment "/rt:routing/rt:control-plane-protocols/"
        + "rt:control-plane-protocol" {
    when "derived-from-or-self(rt:type,'rip:rip')" {
      description
        "This augment is only valid for a routing protocol instance
         of type 'rip'.";
    }
    container rip {
      presence "RIP configuration";
      description
        "RIP instance configuration.";
      container interfaces {
        description
          "Per-interface RIP configuration.";
        list interface {
          key "name";
          description
            "RIP is enabled on interfaces that have an entry in this
             list, unless 'enabled' is set to 'false' for that
             entry.";
          leaf name {
            type if:interface-ref;
          }
          leaf enabled {
            type boolean;
            default "true";
          }
          leaf metric {
            type rip-metric;
            default "1";
          }
        }
      }
      leaf update-interval {
        type uint8 {
          range "10..60";
        }
        units "seconds";
        default "30";
        description
          "Time interval between periodic updates.";
      }
    }
  }
}
</artwork>

      </figure>

    </section>

    <section anchor="app.get-reply" title="Data Tree Example">

      <t>This section contains an example of an instance data tree in the
      JSON encoding <xref target="RFC7951"/>,
      containing both configuration and state data. The data conforms
      to a data model that is defined by the following YANG library
      specification <xref target="RFC7895"/>:

      <figure>
	<artwork>
{
  "ietf-yang-library:modules-state": {
    "module-set-id": "c2e1f54169aa7f36e1a6e8d0865d441d3600f9c4",
    "module": [
      {
        "name": "ietf-routing",
        "revision": "2016-11-04",
        "feature": [
          "multiple-ribs",
          "router-id"
        ],
        "namespace": "urn:ietf:params:xml:ns:yang:ietf-routing",
        "conformance-type": "implement"
      },
      {
        "name": "ietf-ipv4-unicast-routing",
        "revision": "2016-11-04",
        "namespace":
          "urn:ietf:params:xml:ns:yang:ietf-ipv4-unicast-routing",
        "conformance-type": "implement"
      },
      {
        "name": "ietf-ipv6-unicast-routing",
        "revision": "2016-11-04",
        "namespace":
          "urn:ietf:params:xml:ns:yang:ietf-ipv6-unicast-routing",
        "conformance-type": "implement"
      },
      {
        "name": "ietf-interfaces",
        "revision": "2014-05-08",
        "namespace": "urn:ietf:params:xml:ns:yang:ietf-interfaces",
        "conformance-type": "implement"
      },
      {
        "name": "ietf-inet-types",
        "namespace": "urn:ietf:params:xml:ns:yang:ietf-inet-types",
        "revision": "2013-07-15",
        "conformance-type": "import"
      },
      {
        "name": "ietf-yang-types",
        "namespace": "urn:ietf:params:xml:ns:yang:ietf-yang-types",
        "revision": "2013-07-15",
        "conformance-type": "import"
      },
      {
        "name": "iana-if-type",
        "namespace": "urn:ietf:params:xml:ns:yang:iana-if-type",
        "revision": "",
        "conformance-type": "implement"
      },
      {
        "name": "ietf-ip",
        "revision": "2014-06-16",
        "namespace": "urn:ietf:params:xml:ns:yang:ietf-ip",
        "conformance-type": "implement"
      }
    ]
  }
}
</artwork>

      </figure></t>

      <t>A simple network setup as shown in <xref target="fig.exnet"/> is assumed: router "A" uses static default
      routes with the "ISP" router as the next hop. IPv6 router
      advertisements are configured only on the "eth1" interface and
      disabled on the upstream "eth0" interface.</t>

      <figure anchor="fig.exnet" title="Example of Network Configuration">
        <artwork>
                +-----------------+
                |                 |
                |    Router ISP   |
                |                 |
                +--------+--------+
                         |2001:db8:0:1::2
                         |192.0.2.2
                         |
                         |
                         |2001:db8:0:1::1
                     eth0|192.0.2.1
                +--------+--------+
                |                 |
                |     Router A    |
                |                 |
                +--------+--------+
                     eth1|198.51.100.1
                         |2001:db8:0:2::1
                         |
</artwork>

      </figure>

      <t>The instance data tree could then be as follows:</t>

      <figure>
        <artwork>
{
  "ietf-interfaces:interfaces": {
    "interface": [
      {
        "name": "eth0",
        "type": "iana-if-type:ethernetCsmacd",
        "description": "Uplink to ISP.",
        "ietf-ip:ipv4": {
          "address": [
            {
              "ip": "192.0.2.1",
              "prefix-length": 24
            }
          ],
          "forwarding": true
        },
        "ietf-ip:ipv6": {
          "address": [
            {
              "ip": "2001:0db8:0:1::1",
              "prefix-length": 64
            }
          ],
          "forwarding": true,
          "autoconf": {
            "create-global-addresses": false
          }
        }
      },
      {
        "name": "eth1",
        "type": "iana-if-type:ethernetCsmacd",
        "description": "Interface to the internal network.",
        "ietf-ip:ipv4": {
          "address": [
            {
              "ip": "198.51.100.1",
              "prefix-length": 24
            }
          ],
          "forwarding": true
        },
        "ietf-ip:ipv6": {
          "address": [
            {
              "ip": "2001:0db8:0:2::1",
              "prefix-length": 64
            }
          ],
          "forwarding": true,
          "autoconf": {
            "create-global-addresses": false
          },
          "ietf-ipv6-unicast-routing:ipv6-router-advertisements": {
            "send-advertisements": true
          }
        }
      }
    ]
  },
  "ietf-interfaces:interfaces-state": {
    "interface": [
      {
        "name": "eth0",
        "type": "iana-if-type:ethernetCsmacd",
        "phys-address": "00:0C:42:E5:B1:E9",
        "oper-status": "up",
        "statistics": {
          "discontinuity-time": "2015-10-24T17:11:27+02:00"
        },
        "ietf-ip:ipv4": {
          "forwarding": true,
          "mtu": 1500,
          "address": [
            {
              "ip": "192.0.2.1",
              "prefix-length": 24
            }
          ]
        },
        "ietf-ip:ipv6": {
          "forwarding": true,
          "mtu": 1500,
          "address": [
            {
              "ip": "2001:0db8:0:1::1",
              "prefix-length": 64
            }
          ],
          "ietf-ipv6-unicast-routing:ipv6-router-advertisements": {
            "send-advertisements": false
          }
        }
      },
      {
        "name": "eth1",
        "type": "iana-if-type:ethernetCsmacd",
        "phys-address": "00:0C:42:E5:B1:EA",
        "oper-status": "up",
        "statistics": {
          "discontinuity-time": "2015-10-24T17:11:29+02:00"
        },
        "ietf-ip:ipv4": {
          "forwarding": true,
          "mtu": 1500,
          "address": [
            {
              "ip": "198.51.100.1",
              "prefix-length": 24
            }
          ]
        },
        "ietf-ip:ipv6": {
          "forwarding": true,
          "mtu": 1500,
          "address": [
            {
              "ip": "2001:0db8:0:2::1",
              "prefix-length": 64
            }
          ],
          "ietf-ipv6-unicast-routing:ipv6-router-advertisements": {
            "send-advertisements": true,
            "prefix-list": {
              "prefix": [
                {
                  "prefix-spec": "2001:db8:0:2::/64"
                }
              ]
            }
          }
        }
      }
    ]
  },
  "ietf-routing:routing": {
    "router-id": "192.0.2.1",
    "control-plane-protocols": {
      "control-plane-protocol": [
        {
          "type": "ietf-routing:static",
          "name": "st0",
          "description":
            "Static routing is used for the internal network.",
          "static-routes": {
            "ietf-ipv4-unicast-routing:ipv4": {
              "route": [
                {
                  "destination-prefix": "0.0.0.0/0",
                  "next-hop": {
                    "next-hop-address": "192.0.2.2"
                  }
                }
              ]
            },
            "ietf-ipv6-unicast-routing:ipv6": {
              "route": [
                {
                  "destination-prefix": "::/0",
                  "next-hop": {
                    "next-hop-address": "2001:db8:0:1::2"
                  }
                }
              ]
            }
          }
        }
      ]
    }
  },
  "ietf-routing:routing-state": {
    "interfaces": {
      "interface": [
        "eth0",
        "eth1"
      ]
    },
    "control-plane-protocols": {
      "control-plane-protocol": [
        {
          "type": "ietf-routing:static",
          "name": "st0"
        }
      ]
    },
    "ribs": {
      "rib": [
        {
          "name": "ipv4-master",
          "address-family":
            "ietf-ipv4-unicast-routing:ipv4-unicast",
          "default-rib": true,
          "routes": {
            "route": [
              {
                "ietf-ipv4-unicast-routing:destination-prefix":
                  "192.0.2.1/24",
                "next-hop": {
                  "outgoing-interface": "eth0"
                },
                "route-preference": 0,
                "source-protocol": "ietf-routing:direct",
                "last-updated": "2015-10-24T17:11:27+02:00"
              },
              {
                "ietf-ipv4-unicast-routing:destination-prefix":
                  "198.51.100.0/24",
                "next-hop": {
                  "outgoing-interface": "eth1"
                },
                "source-protocol": "ietf-routing:direct",
                "route-preference": 0,
                "last-updated": "2015-10-24T17:11:27+02:00"
              },
              {
                "ietf-ipv4-unicast-routing:destination-prefix":
                  "0.0.0.0/0",
                "source-protocol": "ietf-routing:static",
                "route-preference": 5,
                "next-hop": {
                  "ietf-ipv4-unicast-routing:next-hop-address":
                    "192.0.2.2"
                },
                "last-updated": "2015-10-24T18:02:45+02:00"
              }
            ]
          }
        },
        {
          "name": "ipv6-master",
          "address-family":
            "ietf-ipv6-unicast-routing:ipv6-unicast",
          "default-rib": true,
          "routes": {
            "route": [
              {
                "ietf-ipv6-unicast-routing:destination-prefix":
                  "2001:db8:0:1::/64",
                "next-hop": {
                  "outgoing-interface": "eth0"
                },
                "source-protocol": "ietf-routing:direct",
                "route-preference": 0,
                "last-updated": "2015-10-24T17:11:27+02:00"
              },
              {
                "ietf-ipv6-unicast-routing:destination-prefix":
                  "2001:db8:0:2::/64",
                "next-hop": {
                  "outgoing-interface": "eth1"
                },
                "source-protocol": "ietf-routing:direct",
                "route-preference": 0,
                "last-updated": "2015-10-24T17:11:27+02:00"
              },
              {
                "ietf-ipv6-unicast-routing:destination-prefix":
                  "::/0",
                "next-hop": {
                  "ietf-ipv6-unicast-routing:next-hop-address":
                    "2001:db8:0:1::2"
                },
                "source-protocol": "ietf-routing:static",
                "route-preference": 5,
                "last-updated": "2015-10-24T18:02:45+02:00"
              }
            ]
          }
        }
      ]
    }
  }
}
</artwork>

      </figure>

    </section>

    <section anchor="acknowledgments" title="Acknowledgments" numbered="no">
      <t>The authors wish to thank Nitin&nbsp;Bahadur, Martin&nbsp;Bjorklund,
      Dean Bogdanovic, Jeff Haas, Joel&nbsp;Halpern, Wes&nbsp;Hardaker,
      Sriganesh&nbsp;Kini, David&nbsp;Lamparter, Andrew&nbsp;McGregor, Jan&nbsp;Medved,
      Xiang&nbsp;Li, Stephane Litkowski, Thomas&nbsp;Morin, Tom&nbsp;Petch,
      Yingzhen&nbsp;Qu, Bruno&nbsp;Rijsman, Juergen&nbsp;Schoenwaelder, Phil&nbsp;Shafer,
      Dave&nbsp;Thaler, Yi&nbsp;Yang, Derek&nbsp;Man&nbhy;Kit&nbsp;Yeung, and Jeffrey&nbsp;Zhang for
      their helpful comments and suggestions.</t>
    </section>

  </back>

</rfc>
