<?xml version='1.0' encoding='US-ASCII'?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- XML source generated by id2xml December 11, 2017 -->

<!ENTITY RFC2119 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC4250 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4250.xml">
<!ENTITY RFC4251 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4251.xml">
<!ENTITY RFC4252 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4252.xml">
<!ENTITY RFC4253 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4253.xml">
<!ENTITY RFC4254 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4254.xml">
<!ENTITY RFC8126 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml">
<!ENTITY RFC8174 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml">
<!ENTITY I-D.ietf-curdle-rsa-sha2 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-curdle-rsa-sha2-10.xml">
<!ENTITY I-D.ietf-curdle-rsa-sha2 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-curdle-rsa-sha2.xml">
]>

<rfc number="8308" submissionType="IETF" 
category="std" consensus="yes" ipr="trust200902" updates="4251, 4252, 4253, 4254">

        <?rfc compact="yes"?>
	<?rfc subcompact="no"?>
	<?rfc sortrefs="yes"?>
	<?rfc symrefs="yes"?>
	<?rfc toc="yes"?>

	<front>

	<title abbrev="Extension Negotiation in SSH">Extension Negotiation in the
	Secure Shell (SSH) Protocol</title>
	<author fullname="Denis Bider" initials="D." surname="Bider">
	<organization>Bitvise Limited</organization>
	<address><postal><street>4105 Lombardy Court</street>
	<street>Colleyville, TX  76034</street>
	<street>United States of America</street>
	</postal>
	<email>ietf-ssh3@denisbider.com</email>
	<uri>https://www.bitvise.com/</uri>
	</address>
	</author>

	<date month="February" year="2018"/>

<!-- search by indicators that appear in SSH_MSG_KEXINIT -->
<keyword>ext-info</keyword>
<keyword>ext-info-s</keyword>
<keyword>ext-info-c</keyword>

<!-- search by SSH packet name -->
<keyword>SSH_MSG_EXT_INFO</keyword>
<keyword>SSH_MSG_NEWCOMPRESS</keyword>

<!-- search by extension name -->
<keyword>server-sig-algs</keyword>
<keyword>delay-compression</keyword>
<keyword>no-flow-control</keyword>
<keyword>elevation</keyword>

<!-- search by words and phrases related to extensions -->
<keyword>delay compression</keyword>
<keyword>delayed compression</keyword>
<keyword>flow control</keyword>
<keyword>elevated</keyword>


	<abstract><t>
   This memo updates RFCs 4251, 4252, 4253, and 4254 by defining a
   mechanism for Secure Shell (SSH) clients and servers to exchange information about
   supported protocol extensions confidentially after SSH key exchange.</t>

	</abstract>
	</front>

	<middle>
	<section title="Overview and Rationale" anchor="section-1"><t>
   Secure Shell (SSH) is a common protocol for secure communication on
   the Internet. The original design of the SSH transport layer <xref target="RFC4253"/>
   lacks proper extension negotiation. Meanwhile, diverse implementations
   take steps to ensure that known message types contain no unrecognized
   information. This makes it difficult for implementations to signal
   capabilities and negotiate extensions without risking disconnection.
  This obstacle has been recognized in the process of updating SSH to
  support RSA signatures using SHA-256 and SHA-512 <xref target="RFC8332"/>.
  To avoid trial and error as well as authentication penalties, a client
  must be able to discover public key algorithms a server accepts.
  This extension mechanism permits this discovery.</t>
	<t>
   This memo updates RFCs 4251, 4252, 4253, and 4254.</t>

	<section title="Requirements Terminology" anchor="section-1.1"><t>

    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
    "MAY", and "OPTIONAL" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/>
    when, and only when, they
    appear in all capitals, as shown here.</t>

	</section>

	<section title="Wire Encoding Terminology" anchor="section-1.2"><t>
   The wire encoding types in this document -- "byte", "uint32", "string",
   "boolean", "name-list" -- have meanings as described in <xref target="RFC4251"/>.</t>

	</section>

	</section>

	<section title="Extension Negotiation Mechanism" anchor="section-2"><section title="Signaling of Extension Negotiation in SSH_MSG_KEXINIT" anchor="section-2.1"><t>
   Applications implementing this mechanism MUST add one of the following
   indicator names to the field kex_algorithms in the SSH_MSG_KEXINIT
   message sent by the application in the first key exchange:</t>
<t><list style="symbols">
<t>When acting as server: "ext-info-s"</t>
<t>When acting as client: "ext-info-c"</t>
</list></t>
	<t>
   The indicator name is added without quotes and MAY be added at any
   position in the name-list, subject to proper separation from other
   names as per name-list conventions.</t>


	<t>
   The names are added to the kex_algorithms field because this is one
   of two name-list fields in SSH_MSG_KEXINIT that do not have a separate
   copy for each data direction.</t>

	<t>
   The indicator names inserted by the client and server are different to
   ensure these names will not produce a match and therefore not affect
   the algorithm chosen in key exchange algorithm negotiation.</t>

	<t>
   The inclusion of textual indicator names is intended to provide a clue
   for implementers to discover this mechanism.</t>

	</section>

	<section title="Enabling Criteria" anchor="section-2.2"><t>
   If a client or server offers "ext-info-c" or "ext-info-s"
   respectively, it MUST be prepared to accept an SSH_MSG_EXT_INFO
   message from the peer.</t>

	<t>
   A server only needs to send "ext-info-s" if it intends to process
   SSH_MSG_EXT_INFO from the client. A client only needs to send
   "ext-info-c" if it plans to process SSH_MSG_EXT_INFO from the server.</t>

	<t>
   If a server receives an "ext-info-c", or a client receives an
   "ext-info-s", it MAY send an SSH_MSG_EXT_INFO message but is not
   required to do so.</t>

	<t>
   Neither party needs to wait for the other's SSH_MSG_KEXINIT in order
   to decide whether to send the appropriate indicator in its own
   SSH_MSG_KEXINIT.</t>

	<t>
   Implementations MUST NOT send an incorrect indicator name for their
   role. Implementations MAY disconnect if the counterparty sends an
   incorrect indicator. If "ext-info-c" or "ext-info-s" ends up being
   negotiated as a key exchange method, the parties MUST disconnect.</t>

	</section>

	<section title="SSH_MSG_EXT_INFO Message" anchor="section-2.3"><t>
   A party that received the "ext-info-c" or "ext-info-s" indicator
   MAY send the following message:</t>

	<figure><artwork><![CDATA[
  byte       SSH_MSG_EXT_INFO (value 7)
  uint32     nr-extensions
  repeat the following 2 fields "nr-extensions" times:
    string   extension-name
    string   extension-value (binary)
]]></artwork>
	</figure>

	<t>
 Implementers should pay careful attention to <xref target="section-2.5"/>, in
 particular to the requirement to tolerate any sequence of bytes (including null bytes
 at any position) in an unknown extension's extension-value.
	</t>                                                                
	</section>

	<section title="Message Order" anchor="section-2.4"><t>
   If a client sends SSH_MSG_EXT_INFO, it MUST send it as the next packet
   following the client's first SSH_MSG_NEWKEYS message to the server.</t>

	<t>
   If a server sends SSH_MSG_EXT_INFO, it MAY send it at zero, one, or
   both of the following opportunities:</t>

	<t><list style="symbols"><t>As the next packet following the server's first SSH_MSG_NEWKEYS.<vspace blankLines="1"/>
	Where clients need information in the server's SSH_MSG_EXT_INFO to
    authenticate, it is helpful if the server sends its SSH_MSG_EXT_INFO
    not only as the next packet after SSH_MSG_NEWKEYS, but without delay.
	<vspace blankLines="1"/>
	Clients cannot rely on this because the server is not required to
    send the message at this time; if sent, it may be delayed by
    the network. However, if a timely SSH_MSG_EXT_INFO is received,
    a client can pipeline an authentication request after its
    SSH_MSG_SERVICE_REQUEST, even when it needs extension information.
	</t>

	<t>Immediately preceding the server's SSH_MSG_USERAUTH_SUCCESS, as
    defined in <xref target="RFC4252"/>.<vspace blankLines="1"/>
	The server MAY send SSH_MSG_EXT_INFO at this second opportunity,
    whether or not it sent it at the first. A client that sent
    "ext-info-c" MUST accept a server's SSH_MSG_EXT_INFO at both
    opportunities but MUST NOT require it.
	<vspace blankLines="1"/>
	This allows a server to reveal support for additional extensions
    that it was unwilling to reveal to an unauthenticated client. If a
    server sends a second SSH_MSG_EXT_INFO, this replaces any initial
    one, and both the client and the server re-evaluate extensions in
    effect. The server's second SSH_MSG_EXT_INFO is matched against the
    client's original.
	<vspace blankLines="1"/>
	The timing of the second opportunity is chosen for the following
    reasons. If the message was sent earlier, it would not allow the
    server to withhold information until the client has authenticated.
    If it was sent later, a client that needs information from the
    second SSH_MSG_EXT_INFO immediately after it authenticates would
    have no way to reliably know whether to expect the message.
	</t>

	</list>
	</t>

	</section>

	<section title="Interpretation of Extension Names and Values" anchor="section-2.5"><t>
   Each extension is identified by its extension-name and defines the
   conditions under which the extension is considered to be in effect.
   Applications MUST ignore unrecognized extension-names.</t>

<t>
  When it is specified, an extension MAY dictate that, in order to take effect,
  both parties must include it in their SSH_MSG_EXT_INFO or that it is 
  sufficient for only one party to include it. However, other rules
  MAY be specified. The relative order in which extensions appear in an
  SSH_MSG_EXT_INFO message MUST be ignored.
</t>

	<t>
   Extension-value fields are interpreted as defined by their respective
   extension. This field MAY be empty if permitted by the extension.
   Applications that do not implement or recognize an extension MUST
   ignore its extension-value, regardless of its size or content.
   Applications MUST tolerate any sequence of bytes -- including null
   bytes at any position -- in an unknown extension's extension-value.</t>

	<t>
   The cumulative size of an SSH_MSG_EXT_INFO message is limited only by
   the maximum packet length that an implementation may apply in
   accordance with <xref target="RFC4253"/>. Implementations MUST accept well-formed
   SSH_MSG_EXT_INFO messages up to the maximum packet length they accept.</t>

	</section>

	</section>

	<section title="Initially Defined Extensions"
		 anchor="section-3">

<section title="&quot;server-sig-algs&quot;" anchor="section-3.1">

<t>
This extension is sent with the following extension name and value:

<figure><artwork><![CDATA[
  string      "server-sig-algs"
  name-list   public-key-algorithms-accepted
]]></artwork></figure>
	</t>

	<t>
   The name-list type is a strict subset of the string type and is thus
   permissible as an extension-value. See <xref target="RFC4251"/> for more information.</t>

	<t>
   This extension is sent by the server and contains a list of public
   key algorithms that the server is able to process as part of a
   "publickey" authentication request. If a client sends this extension,
   the server MAY ignore it and MAY disconnect.</t>

	<t>
   In this extension, a server MUST enumerate all public key algorithms
   it might accept during user authentication. However, early
   server implementations that do not enumerate all accepted algorithms do exist.
   For this reason, a client MAY send a user authentication request using
   a public key algorithm not included in "server-sig-algs".</t>

	<t>
   A client that wishes to proceed with public key authentication MAY
   wait for the server's SSH_MSG_EXT_INFO so it can send a "publickey"
   authentication request with an appropriate public key algorithm,
   rather than resorting to trial and error.</t>

	<t>
   Servers that implement public key authentication SHOULD implement this
   extension.</t>

	<t>
   If a server does not send this extension, a client MUST NOT make any
   assumptions about the server's public key algorithm support, and MAY
   proceed with authentication requests using trial and error. Note that
   implementations are known to exist that apply authentication
   penalties if the client attempts to use an unexpected public key
   algorithm.</t>

	<t>
   Authentication penalties are applied by servers to deter brute-force
   password guessing, username enumeration, and other types of
   behavior deemed suspicious by server administrators or implementers.
   Penalties may include automatic IP address throttling or blocking,
   and they may trigger email alerts or auditing.</t>

	</section>


	<section title="&quot;delay-compression&quot;" anchor="section-3.2">
<t>This extension MAY be sent by both parties as follows:

	<figure><artwork><![CDATA[
  string         "delay-compression"
  string:
    name-list    compression_algorithms_client_to_server
    name-list    compression_algorithms_server_to_client
]]></artwork></figure>
</t>
	<t>
   The extension-value is a string that encodes two name-lists. The
   name-lists themselves have the encoding of strings. For example, to
   indicate a preference for algorithms "foo,bar" in the client-to-server
   direction and "bar,baz" in the server-to-client direction, a sender
   encodes the extension-value as follows (including its length):

<figure><artwork><![CDATA[
  00000016 00000007 666f6f2c626172 00000007 6261722c62617a
]]></artwork></figure>
	</t>

	<t>
   This same encoding could be sent by either party -- client or server.</t>

	<t>
   This extension allows the server and client to renegotiate compression
   algorithm support without having to conduct a key re-exchange, which puts
   new algorithms into effect immediately upon successful authentication.</t>

	<t>
   This extension takes effect only if both parties send it. Name-lists
   MAY include any compression algorithm that could have been negotiated
   in SSH_MSG_KEXINIT, except algorithms that define their own delayed
   compression semantics. This means "zlib,none" is a valid algorithm
   list in this context, but "zlib@openssh.com" is not.</t>

	<t>
   If both parties send this extension, but the name-lists do not contain
   a common algorithm in either direction, the parties MUST disconnect in
   the same way as if negotiation failed as part of SSH_MSG_KEXINIT.</t>

	<t>
   If this extension takes effect, the renegotiated compression algorithm
   is activated for the very next SSH message after the trigger message:

<list style="symbols">
<t>Sent by the server, the trigger message is SSH_MSG_USERAUTH_SUCCESS.</t>
<t>Sent by the client, the trigger message is SSH_MSG_NEWCOMPRESS.</t>
</list>
	</t>

	<t>
   If this extension takes effect, the client MUST send the following
   message within a reasonable number of outgoing SSH messages after
   receiving SSH_MSG_USERAUTH_SUCCESS, but not necessarily as the first
   such outgoing message:

<figure><artwork><![CDATA[
  byte       SSH_MSG_NEWCOMPRESS (value 8)
]]></artwork></figure>
	</t>

	<t>
   The purpose of SSH_MSG_NEWCOMPRESS is to avoid a race condition
   where the server cannot reliably know whether a message sent by
   the client was sent before or after receiving the server's
   SSH_MSG_USERAUTH_SUCCESS. For example, clients may send keep-alive
   messages during logon processing.</t>

	<t>
   As is the case for all extensions unless otherwise noted, the server
   MAY delay including this extension until its secondary
   SSH_MSG_EXT_INFO, sent before SSH_MSG_USERAUTH_SUCCESS. This allows
   the server to avoid advertising compression until the client has
   authenticated.</t>

	<t>
   If the parties renegotiate compression using this extension in a
   session where compression is already enabled and the renegotiated
   algorithm is the same in one or both directions, then the internal
   compression state MUST be reset for each direction at the time the
   renegotiated algorithm takes effect.</t>

	<section title="Awkwardly Timed Key Re-Exchange" anchor="section-3.2.1"><t>
   A party that has signaled, or intends to signal, support for this
   extension in an SSH session MUST NOT initiate key re-exchange in that
   session until either of the following occurs:</t>

	<t><list style="symbols"><t>This extension was negotiated, and the party that's about to start
    key re-exchange already sent its trigger message for compression.</t>

	<t>The party has sent (if server) or received (if client) the message
    SSH_MSG_USERAUTH_SUCCESS, and this extension was not negotiated.</t>

	</list>
	</t>

	<t>
   If a party violates this rule, the other party MAY disconnect.</t>

	<t>
   In general, parties SHOULD NOT start key re-exchange before successful
   user authentication but MAY tolerate it if not using this extension.</t>

	</section>

	<section title="Subsequent Re-Exchange" anchor="section-3.2.2"><t>
   In subsequent key re-exchanges that unambiguously begin after the
   compression trigger messages, the compression algorithms negotiated in
   re-exchange override the algorithms negotiated with this extension.</t>

	</section>

	<section title="Compatibility Note: OpenSSH up to Version 7.5"
		 anchor="section-3.2.3"><t>
   This extension uses a binary extension-value encoding. OpenSSH clients
   up to and including version 7.5 advertise support to receive
   SSH_MSG_EXT_INFO but disconnect on receipt of an extension-value
   containing null bytes. This is an error fixed in OpenSSH version&nbsp;7.6.</t>

	<t>
   Implementations that wish to interoperate with OpenSSH 7.5 and earlier
   are advised to check the remote party's SSH version string and omit
   this extension if an affected version is detected. Affected versions
   do not implement this extension, so there is no harm in omitting it.
   The extension SHOULD NOT be omitted if the detected OpenSSH version is
   7.6 or higher. This would make it harder for the OpenSSH project to
   implement this extension in a higher version.</t>

	</section>

	</section>

	<section title="&quot;no-flow-control&quot;" anchor="section-3.3">

<t>This extension is sent with the following extension name and value:

<figure><artwork><![CDATA[
  string      "no-flow-control"
  string      choice of: "p" for preferred | "s" for supported
]]></artwork></figure>
</t>
	<t>
   A party SHOULD send "s" if it supports "no-flow-control" but does not
   prefer to enable it. A party SHOULD send "p" if it prefers to enable
   the extension if the other party supports it. Parties MAY disconnect
   if they receive a different extension value.</t>

	<t>
For this extension to take effect, the following must occur:
<list style="symbols">
<t>This extension MUST be sent by both parties.</t>
<t>At least one party MUST have sent the value "p" (preferred).</t>
</list>
</t>
	<t>
   If this extension takes effect, the "initial window size" fields in
   SSH_MSG_CHANNEL_OPEN and SSH_MSG_CHANNEL_OPEN_CONFIRMATION, as defined
   in <xref target="RFC4254"/>, become meaningless. The values of these fields MUST be
   ignored, and a channel behaves as if all window sizes are infinite.
   Neither side is required to send any SSH_MSG_CHANNEL_WINDOW_ADJUST
   messages, and if received, such messages MUST be ignored.</t>

	<t>
   This extension is intended for, but not limited to, use by file transfer
   applications that are only going to use one channel and for which the
   flow control provided by SSH is an impediment, rather than a feature.</t>

	<t>
   Implementations MUST refuse to open more than one simultaneous channel
   when this extension is in effect. Nevertheless, server implementations
   SHOULD support clients opening more than one non-simultaneous channel.</t>

	<section title="Prior &quot;No Flow Control&quot; Practice" anchor="section-3.3.1"><t>
   Before this extension, some applications would simply not implement
   SSH flow control, sending an initial channel window size of 2^32 - 1.
   Applications SHOULD NOT do this for the following reasons:</t>

	<t><list style="symbols"><t>It is plausible to transfer more than 2^32 bytes over a channel.
    Such a channel will hang if the other party implements SSH flow
    control according to <xref target="RFC4254"/>.</t>

	<t>Implementations that cannot handle large channel window
    sizes exist, and they can exhibit non-graceful behaviors, including disconnect.</t>

	</list>
	</t>

	</section>

	</section>

	<section title="&quot;elevation&quot;" anchor="section-3.4"><t>
   The terms "elevation" and "elevated" refer to an operating system
   mechanism where an administrator's logon session is associated
   with two security contexts: one limited and one with administrative
   rights. To "elevate" such a session is to activate the security
   context with full administrative rights. For more information about
   this mechanism on Windows, see <xref target="WINADMIN"/> and <xref target="WINTOKEN"/>.</t>

	<t>This extension MAY be sent by the client as follows:

	<figure><artwork><![CDATA[
  string      "elevation"
  string      choice of: "y" | "n" | "d"
]]></artwork></figure>

	</t>
	<t>
   A client sends "y" to indicate its preference that the session should
   be elevated; "n" to not be elevated; and "d" for the server to use its
   default behavior. The server MAY disconnect if it receives a different
   extension value. If a client does not send the "elevation" extension,
   the server SHOULD act as if "d" was sent.</t>

	<t>
   If a client has included this extension, then after authentication, a
   server that supports this extension SHOULD indicate to the client
   whether elevation was done by sending the following global request:</t>

	<figure><artwork><![CDATA[
  byte        SSH_MSG_GLOBAL_REQUEST
  string      "elevation"
  boolean     want reply = false
  boolean     elevation performed
]]></artwork></figure>
	<t>
   Clients that implement this extension help reduce attack surface for
   Windows servers that handle administrative logins. Where clients do
   not support this extension, servers must elevate sessions to allow
   full access by administrative users always. Where clients support this
   extension, sessions can be created without elevation unless requested.</t>

	</section>

	</section>

	<section title="IANA Considerations" anchor="section-4"><section title="Additions to Existing Registries" anchor="section-4.1"><t>
   IANA has added the following entries to the 
   "Message Numbers" registry <xref target="IANA-M"/> under the "Secure Shell (SSH)
   Protocol Parameters" registry
   <xref target="RFC4250"/>:</t>

	<figure><artwork><![CDATA[
  Value    Message ID             Reference
  ----------------------------------------- 
  7        SSH_MSG_EXT_INFO       RFC 8308
  8        SSH_MSG_NEWCOMPRESS    RFC 8308
]]></artwork>
	</figure>
	<t>
   IANA has also added the following entries to the "Key
   Exchange Method Names" registry <xref target="IANA-KE"/>:</t>

	<figure><artwork><![CDATA[
  Method Name     Reference      Note
  ------------------------------------------
  ext-info-s      RFC 8308       Section 2
  ext-info-c      RFC 8308       Section 2
]]></artwork>
	</figure>
	</section>

	<section title="New Registry: Extension Names" anchor="section-4.2"><t>
   Also under the "Secure Shell (SSH) Protocol Parameters" registry, IANA has created
   a new "Extension Names" registry, with the following initial content:</t>

	<figure><artwork><![CDATA[
  Extension Name       Reference       Note
  ------------------------------------------------
  server-sig-algs      RFC 8308        Section 3.1
  delay-compression    RFC 8308        Section 3.2
  no-flow-control      RFC 8308        Section 3.3
  elevation            RFC 8308        Section 3.4
]]></artwork>
	</figure>
	<section title="Future Assignments to Extension Names Registry" anchor="section-4.2.1"><t>
   Names in the "Extension Names" registry MUST follow the conventions for
   names defined in <xref target="RFC4250"/>, Section 4.6.1.</t>

	<t>
   Requests for assignments of new non-local names in the "Extension Names"
   registry (i.e., names not including the '@' character) MUST be done
   using the IETF Review policy, as described in <xref target="RFC8126"/>.</t>

	</section>

	</section>

	</section>

	<section title="Security Considerations" anchor="section-5">


<t>
   Security considerations are discussed throughout this document. This
   document updates the SSH protocol as defined in <xref target="RFC4251"/> and related
   documents. The security considerations of <xref target="RFC4251"/> apply.</t>

	</section>

	</middle>

	<back>
	<references title="Normative References">
	&RFC2119;
	&RFC4250;
	&RFC4251;
	&RFC4252;
	&RFC4253;
	&RFC4254;
	&RFC8126;
        &RFC8174;
	</references>

	<references title="Informative References">


<!-- draft-ietf-curdle-rsa-sha2 AUTH48 as RFC-to-be 8332-->

<reference anchor="RFC8332" target="https://www.rfc-editor.org/info/rfc8332">
<front>
<title>Use of RSA Keys with SHA-256 and SHA-512 in the Secure Shell (SSH) Protocol</title>
<author initials='D' surname='Bider' fullname='Denis Bider'>
  <organization/>
</author>
<date month='February' year='2018'/>
</front>
<seriesInfo name="RFC" value="8332"/>
<seriesInfo name="DOI" value="10.17487/RFC8332"/>
</reference>

	<reference anchor="IANA-M" target="https://www.iana.org/assignments/ssh-parameters/"><front>
	<title>Message Numbers</title>
    <author><organization>IANA</organization></author>
    <date />
	</front>
	</reference>

	<reference anchor="IANA-KE" target="https://www.iana.org/assignments/ssh-parameters/"><front>
	<title>Key Exchange Method Names</title>
    <author><organization>IANA</organization></author>
    <date />
	</front>

	</reference>
	<reference anchor="WINADMIN" target="https://blogs.msdn.microsoft.com/winsdk/2013/03/22/how-to-launch-a-process-as-a-full-administrator-when-uac-is-enabled/"><front>
	<title>How to launch a process as a Full Administrator when UAC is enabled?</title>
	<author><organization>Microsoft</organization>
	</author>
	<date month="March" year="2013" />
	</front>

	</reference>
	<reference anchor="WINTOKEN" target="https://msdn.microsoft.com/en-us/library/windows/desktop/bb530718.aspx"><front>
	<title>TOKEN_ELEVATION_TYPE enumeration</title>
	<author><organization>Microsoft</organization>
	</author>

	<date/>
	</front>

	</reference>
	</references>
	<section title="Acknowledgments" numbered="no" anchor="acknowledgments"><t>
   Thanks to Markus Friedl and Damien Miller for comments and initial
   implementation. Thanks to Peter Gutmann, Roumen Petrov, Mark
   D. Baushke, Daniel Migault, Eric Rescorla, Matthew A.&nbsp;Miller, Mirja
   Kuehlewind, Adam Roach, Spencer Dawkins, Alexey Melnikov, and Ben
   Campbell for reviews and feedback.</t>

	</section>

	</back>

	</rfc>
	
