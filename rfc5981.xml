<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
	<!ENTITY rfc2119 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
	<!ENTITY rfc5905 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5905.xml'>
	<!ENTITY rfc2104 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml'>
	<!ENTITY rfc1034 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1034.xml'>
	<!ENTITY rfc5280 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml'>
	<!ENTITY rfc3447 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml'>
	<!ENTITY rfc3520 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3520.xml'>
	<!ENTITY rfc3521 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3521.xml'>
	<!ENTITY rfc5652 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5652.xml'>
	<!ENTITY rfc3986 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml'>
	<!ENTITY rfc4080 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4080.xml'>
	<!ENTITY rfc4081 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4081.xml'>
	<!ENTITY rfc4120 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4120.xml'>
	<!ENTITY rfc4868 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4868.xml'>
	<!ENTITY rfc4880 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4880.xml'>
	<!ENTITY rfc4514 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4514.xml'>
	<!ENTITY rfc5226 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml'>
	<!ENTITY rfc5971 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5971.xml'>
	<!ENTITY rfc5973 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5973.xml'>
	<!ENTITY rfc5974 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5974.xml'>
	<!ENTITY rfc5996 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5996.xml'>
]>

<!--[rfced] Please note that after you have approved the document,
post-xml2rfc changes will be made to update the header and
boilerplate as described in RFC 5741.
-->

<rfc number="5981" category="exp" ipr="trust200902" >

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc rfcedstyle="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

    <front>
        <title abbrev='NSLP AUTH'>
	Authorization for NSIS Signaling Layer Protocols
	</title>

        <author initials='J.' surname="Manner" fullname='Jukka Manner'>
        <organization>Aalto University</organization>
        <address>
        <postal>
        <street>Department of Communications and Networking (Comnet)</street>
        <street>P.O. Box 13000</street>
        <city>Aalto</city> <code>FI-00076</code>
        <country>Finland</country>
        </postal>
        <phone>+358 9 470 22481</phone>
        <email>jukka.manner@tkk.fi</email>
        </address>
        </author>

   <author initials="M." surname="Stiemerling" fullname="Martin
   Stiemerling">
     <organization abbrev="NEC">Network Laboratories, NEC Europe
     Ltd.</organization>
     <address>
       <postal>
         <street>Kurfuersten-Anlage 36</street>
         <city>Heidelberg</city>
         <code>69115</code>
         <country>Germany</country>
       </postal>
       <phone>+49 (0) 6221 4342 113</phone>
       <email>martin.stiemerling@neclab.eu</email>
       <uri> http://www.stiemerling.org </uri>
     </address>
   </author>

<author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
     <organization>Nokia Siemens Networks</organization>
     <address>
       <postal>
         <street>Linnoitustie 6</street>
         <city>Espoo</city>
         <code>02600</code>
         <country>Finland</country>
       </postal>
       <phone>+358 (50) 4871445</phone>
       <email>Hannes.Tschofenig@gmx.net</email>
       <uri>http://www.tschofenig.priv.at</uri>
     </address>
   </author>

<author initials="R." surname="Bless" fullname="Roland Bless" role="editor">
  <organization abbrev="KIT">
   Karlsruhe Institute of Technology
   </organization>
   <address>
     <postal>
          <street>Institute of Telematics</street>
          <street>Zirkel 2, Building 20.20</street>
          <street>P.O. Box 6980</street>
          <city>Karlsruhe</city>
          <code>76049</code>
          <country>Germany</country>
     </postal>
     <phone>+49 721 608 46413</phone>
     <email>roland.bless@kit.edu</email>
     <uri>http://tm.kit.edu/~bless</uri>
   </address>
   </author>

        <date month="January" year="2011"/>

<keyword>Security</keyword>
<keyword>Policy</keyword>
<keyword>Authentication</keyword>

        <abstract>

	<t>

Signaling layer protocols specified within the Next Steps in Signaling (NSIS) framework may rely
on the General Internet Signaling Transport (GIST) protocol to handle
authorization.  Still, the signaling layer protocol above GIST itself
may require separate authorization to be performed when a node
receives a request for a certain kind of service or resources.  This
document presents a generic model and object formats for session
authorization within the NSIS signaling layer protocols. The goal of
session authorization is to allow the exchange of information between
network elements in order to authorize the use of resources for a
service and to coordinate actions between the signaling and transport
planes.

	</t>

	</abstract>
    </front>

<middle> 



<section title="Introduction">

<t>

The Next Steps in Signaling (NSIS) framework <xref target="RFC4080" /> 
defines a suite of protocols for the next generation in Internet signaling.
The design is based on a generalized transport protocol for signaling applications,
the General Internet Signaling Transport (GIST) <xref
target="RFC5971" />, and various kinds of signaling
applications. Two signaling applications and their NSIS Signaling Layer
Protocol (NSLP) have been designed, a Quality of Service application
(QoS NSLP) <xref target="RFC5974" /> and a NAT/firewall
application (NATFW NSLP) <xref target="RFC5973" />.

</t>

<t>

The basic security architecture for NSIS is based on
a chain-of-trust model, where each GIST hop may choose the appropriate
security protocol, taking into account the signaling application
requirements. For instance, communication between two directly adjacent 
GIST peers may be secured via TCP/TLS. On the one hand, this model is 
appropriate for a number of different use cases and allows the 
signaling applications to leave the handling of security to GIST. 
On the other hand, several sessions of different signaling applications
are then multiplexed onto the same GIST TLS connection.
</t>

<t>

Yet, in order to allow for finer-grain per-session or per-user admission control,
it is necessary to provide a mechanism for ensuring that the use of
resources by a host has been properly authorized before allowing the
signaling application to commit the resource request, e.g., a QoS
reservation or mappings for NAT traversal.  In order to meet this
requirement, there must be information in the NSLP message that may
be used to verify the validity of the request.  This can be done by
providing the host with a Session Authorization Object that
is inserted into the message and verified by the respective 
network elements.

</t>
<t>

This document describes a generic NSLP-layer Session Authorization
Object (SESSION_AUTH) used to convey authorization information
for the request. "Generic" in this context means that it is usable by
all NSLPs. The scheme is based on third-party tokens. A trusted
third party provides authentication tokens to clients and allows
verification of the information by the network elements. The requesting
host inserts the authorization information (e.g., a policy object) 
acquired from the trusted third party into the NSLP message to allow 
verification of the network resource request. 
Network elements verify the request and then process
it based on admission policy (e.g., they perform a resource reservation
or change bindings or firewall filter). This work is
based on RFC 3520 <xref target="RFC3520" /> and RFC 3521 <xref
target="RFC3521" />.

</t>

<t>

The default operation when using NSLP-layer session authorization is
to add one authorization policy object. Yet, in order to support
end-to-end signaling and request authorization from different
networks, a host initiating an NSLP signaling session may add more
than one SESSION_AUTH object in the message. The identifier of the
authorizing entity can be used by the network elements to use the
third party they trust to verify the request.

</t>

</section>

<section title="Conventions Used in This Document">

<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in BCP 14, RFC 2119
<xref target="RFC2119" />.
</t>

<t>
The term "NSLP node" (NN) is used to refer to an NSIS node running an
NSLP protocol that can make use of the authorization object discussed in
this document. Currently, this node would run either the QoS NSLP <xref target="RFC5974" />
or the NAT/Firewall NSLP <xref target="RFC5973" /> service.
</t>

</section>

<section title="Session Authorization Object" anchor='sec-session-auth-object-formats'>

<t>

   This section presents a new NSLP-layer object called session
   authorization (SESSION_AUTH). The SESSION_AUTH object can be used in
   the currently specified and future NSLP protocols.

</t>
<t>

   The authorization attributes follow the format and specification
   given in RFC3520 <xref target="RFC3520" />.

</t>

<section title="Session Authorization Object format">

<t>

The SESSION_AUTH object contains a list of fields that describe
the session, along with other attributes. The object header follows 
the generic NSLP object header; therefore, it can be used together
with any NSLP.

</t>

<figure>
<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|A|B|r|r|         Type          |r|r|r|r|        Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+                                                               +
//         Session Authorization Attribute List                //
+                                                               +
+---------------------------------------------------------------+
]]></artwork>
</figure>

<t>

The value for the Type field comes from shared NSLP object type space.
The Length field is given in units of 32-bit words and measures the
length of the Value component of the TLV object (i.e., it does not
include the standard header).

</t>
<t>

The bits marked 'A' and 'B' are extensibility flags and are used to
signal the desired treatment for objects whose treatment has not been
defined in the protocol specification (i.e., whose Type field is
unknown at the receiver). The following four categories of object
have been identified, and are described here for informational
purposes only (for normative behavior, refer to the particular 
NSLP documents, e.g., <xref target="RFC5974" /> 
<xref target="RFC5973" />).

</t>

<t>
<list>
<t>

AB=00 ("Mandatory"): If the object is not understood, the entire
message containing it MUST be rejected, and an error message sent
back (usually of class/code "Protocol Error/Unknown object present").

</t>
<t>

AB=01 ("Ignore"): If the object is not understood, it MUST be deleted,
and the rest of the message processed as usual.

</t>
<t>

AB=10 ("Forward"): If the object is not understood, it MUST be
retained unchanged in any message forwarded as a result of message
processing, but not stored locally.

</t>
<t>

AB=11 ("Refresh"): If the object is not understood, it should be
incorporated into the locally stored signaling application state for
this flow/session, forwarded in any resulting message, and also used
in any refresh or repair message which is generated locally. 
This flag combination is not used by all NSLPs, e.g., it is not
used in the NATFW NSLP.

</t>
</list>
</t>

<t>

The remaining bits marked 'r' are reserved. The extensibility flags
follow the definition in the GIST specification. The SESSION_AUTH object
defined in this specification MUST have the AB bits set to "10". An NSLP 
Node (NN) may use the authorization information if it is configured to do 
so, but may also just skip the object.

</t>
<t>

Type: SESSION_AUTH_OBJECT (0x016)

</t>
<t>

Length: Variable, contains length of session authorization object list 
        in units of 32-bit words.

</t>
<t>

Session Authorization Attribute List: variable length

</t>

<t>
<list style="empty">
<t>
The session authorization attribute list is a collection of objects
that describes the session and provides other information necessary
to verify resource request (e.g., a resource reservation, binding, or
firewall filter change request). An initial set of valid
objects is described in <xref target="sec-SessionAuthAttr"/>.
</t>
</list>
</t>

</section>

<section title="Session Authorization Attributes" anchor='sec-SessionAuthAttr'>

<t>

A session authorization attribute may contain a variety of information
and has both an attribute type and sub-type. The attribute itself MUST be
a multiple of 4 octets in length, and any attributes that are not a
multiple of 4 octets long MUST be padded to a 4-octet boundary. All
padding bytes MUST have a value of zero.

</t>


<figure>
<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |    X-Type     |   SubType     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//                           Value ...                         //
+---------------------------------------------------------------+
]]></artwork>
</figure>

<t>
Length: 16 bits
</t>

<t>
<list style="empty">
<t>

The Length field is two octets and indicates the actual length of the
attribute (including Length, X-Type, and SubType fields) in number of
octets. The length does NOT include any padding of the value field
to make the attribute's length a multiple of 4 octets.
</t>
</list>
</t>

<t>
X-Type: 8 bits
</t>

<t>
<list style="empty">

<t>

Session authorization attribute type (X-Type) field is one octet. IANA
acts as a registry for X-Types as described in <xref target="sec-IANA"/>, IANA
Considerations. This specification uses the following X-Types:

</t>

<t>
<list style="numbers">
<t>
  AUTH_ENT_ID:          The unique identifier of the entity that
                       authorized the session.
</t>

<t>

  SESSION_ID:           The unique identifier for this session, usually
                       created locally at the authorizing entity.
                       See also RFC 3520 <xref target="RFC3520" />;
                       not to be confused with the SESSION-ID of GIST/NSIS.
</t>

<t>

  SOURCE_ADDR:          The address specification for the signaling
                       session initiator, i.e., the source address
		       of the signaling message originator.
</t>
<t>

  DEST_ADDR:            The address specification for the signaling
                       session endpoint.
</t>
<t>

  START_TIME:           The starting time for the session.

</t>
<t>

  END_TIME:             The end time for the session.

</t>
<t>

  AUTHENTICATION_DATA:  The authentication data of the Session
                        Authorization Object.
</t>

</list>
</t>
</list>
</t>

<t>
SubType: 8 bits

</t>
<t>
<list style="empty">
<t>

Session authorization attribute sub-type is one octet in length. The
value of the SubType depends on the X-Type.

</t>
</list>
</t>

<t>

Value: variable length

</t>
<t>

<list style="empty">
<t>
The attribute-specific information.
</t>
</list>
</t>

<section title="Authorizing Entity Identifier">

<t>

The AUTH_ENT_ID is used to identify the entity that authorized the
initial service request and generated the Session Authorization
Object.  The AUTH_ENT_ID may be represented in various
formats, and the SubType is used to define the format for the ID.
The format for AUTH_ENT_ID is as follows:

</t>

<figure>
<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |    X-Type     |   SubType     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//                        OctetString ...                      //
+---------------------------------------------------------------+
]]></artwork>
</figure>

<t>
Length: Length of the attribute, which MUST be > 4.

</t>
<t>

X-Type: AUTH_ENT_ID

</t>
<t>

SubType: 

</t>
<t>
<list style="empty">
<t>
The following sub-types for AUTH_ENT_ID are defined.  IANA acts as a
registry for AUTH_ENT_ID SubTypes as described in <xref target="sec-IANA"/>, IANA
Considerations.  Initially, the registry contains the following
SubTypes of AUTH_ENT_ID:
</t>

<t>

<list style="numbers">

<t>

  IPV4_ADDRESS:        IPv4 address represented in 32 bits.

</t>
<t>

  IPV6_ADDRESS:        IPv6 address represented in 128 bits.

</t>
<t>

  FQDN:                Fully Qualified Domain Name as defined in
                      <xref target="RFC1034" /> as an ASCII string.
</t>
<t>

  ASCII_DN:           X.500 Distinguished name as defined in
                      <xref target="RFC4514" /> as an ASCII string.
</t>
<t>

  UNICODE_DN:          X.500 Distinguished name as defined in 
                      <xref target="RFC4514" /> as a UTF-8 string.
</t>
<t>

  URI:                 Universal Resource Identifier, as defined
                      in <xref target="RFC3986" />.
</t>
<t>

  KRB_PRINCIPAL:       Fully Qualified Kerberos Principal name
                       represented by the ASCII string of a
                       principal, followed by the @ realm name as
                       defined in <xref target="RFC4120" /> (e.g.,
                       johndoe@nowhere).

</t>
<t>

  X509_V3_CERT:        The Distinguished Name of the subject of
                       the certificate as defined in <xref target="RFC4514" /> 
                       as a UTF-8 string.

</t>
<t>

  PGP_CERT:           The OpenPGP certificate of the
                      authorizing entity as defined as Public-Key Packet
                      in <xref target="RFC4880" />.

</t>
<t>

  HMAC_SIGNED:        Indicates that the AUTHENTICATION_DATA attribute
                      contains a self-signed HMAC signature <xref target="RFC2104" /> 
		      that ensures the integrity of the NSLP message. The HMAC is 
		      calculated over all NSLP objects given in the
		      NSLP_OBJECT_LIST attribute that MUST also be
		      present. The object specifies the hash 
		      algorithm that is used for calculation of the HMAC
		      as Transform ID from Transform Type 3 of the IKEv2
		      registry <xref target="RFC5996" />.
</t>


</list>
</t>
</list>
</t>

<t>

OctetString: Contains the authorizing entity identifier.

</t>

</section>

<section title="Session Identifier">  
 
<t>
SESSION_ID is a unique identifier used by the authorizing entity to
identify the request.  It may be used for a number of purposes,
including replay detection, or to correlate this request to a policy
decision entry made by the authorizing entity.  For example, the
SESSION_ID can be based on simple sequence numbers or on a standard
NTP timestamp.
</t>


<figure>
<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |    X-Type     |   SubType     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//                        OctetString ...                      //
+---------------------------------------------------------------+
]]></artwork>
</figure>


<t>
   Length: Length of the attribute, which MUST be > 4.
</t>
    
<t>
    X-Type: SESSION_ID
</t>

<t>
   SubType:
</t>

<t>
  No sub-types for SESSION_ID are currently defined; this field MUST
  be set to zero.  The authorizing entity is the only network entity
  that needs to interpret the contents of the SESSION_ID; therefore,
  the contents and format are implementation dependent.
</t>

<t>

OctetString: The OctetString contains the session identifier.

</t>

</section> <!-- end section SESSION_ID -->



<section title="Source Address">

<t>

SOURCE_ADDR is used to identify the source address specification of
the authorized session.  This X-Type may be useful in some scenarios
to make sure the resource request has been authorized for that
particular source address and/or port. Usually, it corresponds to
the signaling source, e.g., the IP source address of the GIST
packet, or flow source or flow destination address, respectively, 
which are contained in the GIST MRI (Message Routing Information)
object.

</t>

<figure>
<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |    X-Type     |   SubType     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//                        OctetString ...                      //
+---------------------------------------------------------------+
]]></artwork>
</figure>

<t>

Length:  Length of the attribute, which MUST be > 4.

</t>
<t>

X-Type: SOURCE_ADDR

</t>
<t>

SubType: 

</t>
<t>
<list style="empty">

<t>
The following sub-types for SOURCE_ADDR are defined.  IANA acts as
a registry for SOURCE_ADDR SubTypes as described in <xref target="sec-IANA"/>,
IANA Considerations.  Initially, the registry contains the
following SubTypes for SOURCE_ADDR:

</t>

<t>
<list style="numbers">

<t>
  IPV4_ADDRESS:        IPv4 address represented in 32 bits.
</t>
<t>

  IPV6_ADDRESS:        IPv6 address represented in 128 bits.
</t>
<t>

  UDP_PORT_LIST:       list of UDP port specifications,
                        represented as 16 bits per list entry.
</t>
<t>

  TCP_PORT_LIST:       list of TCP port specifications,
                        represented as 16 bits per list entry.
</t>
<t>

  SPI:                 Security Parameter Index, represented in 32
                       bits.

</t>
</list>
</t>
</list>
</t>

<t>

OctetString: The OctetString contains the source address information.

</t>
<t>

In scenarios where a source address is required (see <xref target='sec-framework'></xref>), 
at least one of the sub-types 1 or 2 MUST be included in every Session
Authorization Object. Multiple SOURCE_ADDR attributes MAY
be included if multiple addresses have been authorized. The source
address of the request (e.g., a QoS NSLP RESERVE) MUST match one of the
SOURCE_ADDR attributes contained in this Session Authorization Object.

</t>
<t>

At most, one instance of sub-type 3 MAY be included in every Session
Authorization Object. At most, one instance of sub-type 4
MAY be included in every Session Authorization Object.
Inclusion of a sub-type 3 attribute does not prevent inclusion of a
sub-type 4 attribute (i.e., both UDP and TCP ports may be authorized).

</t>
<t>

If no PORT attributes are specified, then all ports are considered
valid; otherwise, only the specified ports are authorized for use. Every
source address and port list must be included in a separate SOURCE_ADDR
attribute.

</t>
</section>

<section title="Destination Address">

<t>
DEST_ADDR is used to identify the destination address of the
authorized session.  This X-Type may be useful in some scenarios to
make sure the resource request has been authorized for that
particular destination address and/or port.

</t>

<figure>
<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |    X-Type     |   SubType     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//                        OctetString ...                      //
+---------------------------------------------------------------+
]]></artwork>
</figure>

<t>

Length: Length of the attribute in number of octets, which MUST be > 4.

</t>
<t>

X-Type: DEST_ADDR

</t>
<t>

SubType:
</t>
<t>
<list style="empty">
<t>

The following sub-types for DEST_ADDR are defined.  IANA acts as a
registry for DEST_ADDR SubTypes as described in <xref target="sec-IANA"/>, IANA
Considerations.  Initially, the registry contains the following SubTypes for DEST_ADDR:

</t>

<t>
<list style="numbers">
<t>

  IPV4_ADDRESS:        IPv4 address represented in 32 bits.

</t>
<t>

  IPV6_ADDRESS:        IPv6 address represented in 128 bits.

</t>
<t>

  UDP_PORT_LIST:       list of UDP port specifications,
                       represented as 16 bits per list entry.
</t>
<t>

  TCP_PORT_LIST:       list of TCP port specifications,
                        represented as 16 bits per list entry.

</t>
<t>

  SPI:                 Security Parameter Index, represented in 32
                       bits.
</t>
</list>
</t>
</list>
</t>

<t>

OctetString: The OctetString contains the destination address specification.

</t>
<t>

In scenarios where a destination address is required (see <xref target='sec-framework'></xref>),
at least one of the sub-types 1 or 2 MUST be included
in every Session Authorization Object. Multiple
DEST_ADDR attributes MAY be included if multiple addresses have been
authorized. The destination address field of the resource reservation
datagram (e.g., QoS NSLP Reserve) MUST match one of the DEST_ADDR attributes
contained in this Session Authorization Object.

</t>
<t>

At most, one instance of sub-type 3 MAY be included in every Session
Authorization Object. At most, one instance of sub-type 4
MAY be included in every Session Authorization Object.
Inclusion of a sub-type 3 attribute does not prevent inclusion of a
sub-type 4 attribute (i.e., both UDP and TCP ports may be authorized).

</t>
<t>

If no PORT attributes are specified, then all ports are considered
valid; otherwise, only the specified ports are authorized for use.

</t>
<t>

Every destination address and port list must be included in a
separate DEST_ADDR attribute.

</t>
</section>

<section title="Start Time">

<t>

START_TIME is used to identify the start time of the authorized session
and can be used to prevent replay attacks. If the SESSION_AUTH object is presented in a resource request, the network SHOULD reject
the request if it is not received within a few seconds of the start time
specified.

</t>

<figure>
<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |    X-Type     |   SubType     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//                        OctetString ...                      //
+---------------------------------------------------------------+
]]></artwork>
</figure>

<t>
Length: Length of the attribute, which MUST be > 4.

</t>
<t>

X-Type: START_TIME

</t>
<t>

SubType:

</t>
<t>
The following sub-type for START_TIME is defined.  IANA acts as a
registry for START_TIME SubTypes as described in <xref target="sec-IANA"/>, IANA
Considerations.  Initially, the registry contains the following SubType for START_TIME:

</t>

<t>
<list style="empty">
<t>
1  NTP_TIMESTAMP:        NTP Timestamp Format as defined in
                        RFC 5905 <xref target="RFC5905"/>.
</t>
</list>

</t>
<t>

OctetString: The OctetString contains the start time.

</t>
</section>

<section title="End Time">

<t>

END_TIME is used to identify the end time of the authorized session and
can be used to limit the amount of time that resources are authorized
for use (e.g., in prepaid session scenarios).

</t>

<figure>
<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |    X-Type     |   SubType     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//                        OctetString ...                      //
+---------------------------------------------------------------+
]]></artwork>
</figure>

<t>

Length: Length of the attribute, which MUST be > 4.

</t>
<t>

X-Type: END_TIME

</t>
<t>

SubType:
</t>
<t>

The following sub-type for END_TIME is defined.  IANA acts as a
registry for END_TIME SubTypes as described in <xref target="sec-IANA"/>, IANA
Considerations.  Initially, the registry contains the following SubType for END_TIME:

</t>
<t>

<list style="empty">
<t>
1 NTP_TIMESTAMP:        NTP Timestamp Format as defined in
                        RFC 5905 <xref target="RFC5905"/>.
</t>
</list>
</t>

<t>

OctetString: The OctetString contains the end time.

</t>

</section>

<section title="NSLP Object List" anchor='sec-nslp-object-list'>

<t>

The NSLP_OBJECT_LIST attribute contains a list of NSLP object
types that are used in the keyed-hash computation whose result is
given in the AUTHENTICATION_DATA attribute.  This allows for
an integrity protection of NSLP PDUs. If an NSLP_OBJECT_LIST
attribute has been included in the SESSION_AUTH object, an
AUTHENTICATION_DATA attribute MUST also be present.

</t>

<t>

The creator of this attribute lists every NSLP object type
whose NSLP PDU object was included in the computation of the
hash. The hash computation has to follow the order 
of the NSLP object types as specified by the list. The receiver can verify the 
integrity of the NSLP PDU by computing a hash over all NSLP 
objects that are listed in this attribute (in the given order), 
including all the attributes of the authorization object. 
Since all NSLP object types are unique over all different 
NSLPs, this will work for any NSLP.

</t>

<t>

Basic NSIS Transport Layer Protocol (NTLP) / NSLP objects like the session ID, the NSLPID, and
the MRI MUST be always included in the HMAC. Since they
are not carried within the NSLP itself, but only within GIST,
they have to be provided for HMAC calculation, e.g., they
can be delivered via the GIST API. They MUST be normalized to
their network representation from <xref target="RFC5971" /> 
again before calculating the hash. These values MUST be hashed first
(in the order session ID, NSLPID, MRI), before any other NSLP object values 
that are included in the hash computation.

</t>

<t>

A summary of the NSLP_OBJECT_LIST attribute format is described below.

</t>

<figure>
<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
| Length                        | NSLP_OBJ_LIST |     zero      |
+---------------+---------------+-------+-------+---------------+
| # of signed NSLP objects = n  |  rsv  |  NSLP object type (1) |
+-------+-------+---------------+-------+-------+---------------+
|  rsv  | NSLP object type (2)  |             .....            //
+-------+-------+---------------+---------------+---------------+
|  rsv  | NSLP object type (n)  |     (padding if required)     |
+--------------+----------------+---------------+---------------+
]]></artwork>
</figure>

<t>
Length: Length of the attribute, which MUST be > 4.
</t>

<t>

X-Type: NSLP_OBJECT_LIST

</t>
<t>
SubType: No sub-types for NSLP_OBJECT_LIST are currently defined.  
This field MUST be set to 0 and ignored upon reception.
</t>

<t>
# of signed NSLP objects: The number n of NSLP object types
that follow. n=0 is allowed; in that case, only a padding field is contained.
</t>

<t>
rsv: reserved bits; MUST be set to 0 and ignored upon reception.
</t>

<t>
NSLP object type: the NSLP 12-bit object type identifier
of the object that was included in the hash calculation.
The NSLP object type values comprise only 12 bits, so four
bits per type value are currently not used within the 
list. Depending on the number of signed objects, a 
corresponding padding word of 16 bits must be supplied.</t>

<t>
padding: padding MUST be added if the number of NSLP objects
is even and MUST NOT be added if the number of NSLP objects
is odd. If padding has to be applied, the padding field MUST 
be 16 bits set to 0, and its contents MUST be ignored upon 
reception.
</t>

</section>


<section title="Authentication Data">

<t>

The AUTHENTICATION_DATA attribute contains the authentication data of
the SESSION_AUTH object and signs all the data in the object up to the
AUTHENTICATION_DATA.  If the AUTHENTICATION_DATA attribute has been
included in the SESSION_AUTH object, it MUST be the last attribute in
the list. The algorithm used to compute the authentication data
depends on the AUTH_ENT_ID SubType field. See
<xref target='sec-session-auth-integrity'></xref> 
entitled "Integrity of the SESSION_AUTH Object".

</t>
<t>

A summary of the AUTHENTICATION_DATA attribute format is described below.

</t>

<figure>
<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |    X-Type     |   SubType     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//                        OctetString ...                      //
+---------------------------------------------------------------+
]]></artwork>
</figure>

<t>

Length: Length of the attribute, which MUST be > 4.

</t>
<t>

X-Type: AUTHENTICATION_DATA

</t>
<t>

SubType: No sub-types for AUTHENTICATION_DATA are currently defined.  
This field MUST be set to 0 and ignored upon reception.

</t>
<t>

OctetString: The OctetString contains the authentication data of the 
SESSION_AUTH.

</t>

</section>
</section>
</section>

<section title="Integrity of the SESSION_AUTH Object" anchor="sec-session-auth-integrity">

<t>
This section describes how to ensure that the integrity of the
SESSION_AUTH object is preserved.

</t>

<section title="Shared Symmetric Keys" anchor='sec-shared-key'>

<t>

In shared symmetric key environments, the AUTH_ENT_ID MUST be of
sub-types: IPV4_ADDRESS, IPV6_ADDRESS, FQDN, ASCII_DN, UNICODE_DN, or
URI.  An example SESSION_AUTH object is shown below.

</t>

<figure title="Example of a SESSION_AUTH Object" anchor="fig-session_auth">
<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1|0|0|0| Type = SESSION_AUTH   |0|0|0|0|    Object Length      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |   AUTH_ENT_ID | IPV4_ADDRESS  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   OctetString ...   (The authorizing entity's Identifier)     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |   AUTH_DATA   |     zero      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Key-ID                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   OctetString ...   (Authentication data)                     |
+---------------------------------------------------------------+
]]></artwork>
</figure>


<section title="Operational Setting Using Shared Symmetric Keys">

<t>

This assumes both the Authorizing Entity and the network router/PDP (Policy Decision Point) 
are provisioned with shared symmetric keys, policies detailing which
algorithm to be used for computing the authentication data, and
the expected length of the authentication data for that particular
algorithm.

</t>
<t>

Key maintenance is outside the scope of this document, but SESSION_AUTH
implementations MUST at least provide the ability to manually configure
keys and their parameters. The key used to produce the authentication
data is identified by the AUTH_ENT_ID field. Since multiple keys may be
configured for a particular AUTH_ENT_ID value, the first 32 bits of the
AUTHENTICATION_DATA field MUST be a Key-ID to be used to identify the appropriate
key.

Each key must also be configured with lifetime parameters for the
time period within which it is valid as well as an associated
cryptographic algorithm parameter specifying the algorithm to be used
with the key. At a minimum, all SESSION_AUTH implementations MUST
support the HMAC-SHA2-256 <xref target="RFC4868" /> <xref
target="RFC2104" /> cryptographic algorithm for computing the
authentication data.

</t>
<t>

It is good practice to regularly change keys. Keys MUST be configurable
such that their lifetimes overlap, thereby allowing smooth transitions between
keys. At the midpoint of the lifetime overlap between two keys, senders
should transition from using the current key to the next/longer-lived
key. Meanwhile, receivers simply accept any identified key received
within its configured lifetime and reject those that are not.

</t>
</section>

</section>

<section title="Kerberos" anchor='sec-kerberos'>

<t>

Since Kerberos <xref target="RFC4120" /> is widely used for end-user authorization, e.g., in
Windows domains, it is well suited for being used in the context of
user-based authorization for NSIS sessions. For instance, a user may
request a ticket for authorization to install rules in an
NATFW-capable router.

</t>

<t>

In a Kerberos environment, it is assumed that the user of the
NSLP requesting host requests a ticket from the Kerberos Key
Distribution Center (KDC) for using the NSLP node (router) as
a resource (target service). The NSLP requesting host (client) can 
present the ticket to the NSLP node via Kerberos by sending a KRB_CRED message to the NSLP node
independently but prior to the NSLP exchange. Thus, the principal 
name of the service must be known at the client in advance, though the exact IP 
address may not be known in advance. How the name is assigned
and made available to the client is implementation specific. 
The extracted common session key can subsequently be used to employ the HMAC_SIGNED variant of the SESSION_AUTH object.
</t>

<t>
Another option is to encapsulate the credentials in the AUTHENTICATION_DATA portion of the
SESSION_AUTH object. In this case, the AUTH_ENT_ID MUST be of the sub-type
KRB_PRINCIPAL.  The KRB_PRINCIPAL field is defined as the Fully
Qualified Kerberos Principal name of the authorizing entity.
The AUTHENTICATION_DATA portion of the SESSION_AUTH object contains the
KRB_CRED message that the receiving NSLP node has to extract
and verify. A second SESSION_AUTH object of type HMAC_SIGNED
SHOULD protect the integrity of the NSLP message, including the
prior SESSION_AUTH object. The session key included in the first
SESSION_AUTH object has to be used for HMAC calculation. 
</t>

<t>
An example of the Kerberos AUTHENTICATION_DATA object is shown below
in <xref target='fig-KERB-Example' />.</t>

<t>
<figure title="Example of a Kerberos AUTHENTICATION_DATA Object" anchor='fig-KERB-Example'>
<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1|0|0|0| Type = SESSION_AUTH   |0|0|0|0|    Object Length      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |   AUTH_ENT_ID |  KERB_P.      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   OctetString ...   (The principal@realm name)                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |   AUTH_DATA   |     zero      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   OctetString ...   (KRB_CRED Data)                           |
+---------------------------------------------------------------+
]]></artwork>
</figure>
</t>

</section>

<section title="Public Key">

<t>

In a public key environment, the AUTH_ENT_ID MUST be of the sub-types:
X509_V3_CERT or PGP_CERT. The authentication data is used for
authenticating the authorizing entity. Two examples of the public key
SESSION_AUTH object are shown in Figures <xref target='fig-PGP-CERT' format="counter"/>
and <xref target='fig-X509-V3-CERT' format="counter"/>.

</t>

<figure title="Example of a SESSION_AUTH_OBJECT Using a PGP Certificate" anchor='fig-PGP-CERT'>
<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1|0|0|0| Type = SESSION_AUTH   |0|0|0|0|    Object Length      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |   AUTH_ENT_ID |   PGP_CERT    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   OctetString ...   (Authorizing entity Digital Certificate)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |   AUTH_DATA   |     zero      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   OctetString ...   (Authentication data)                     |
+---------------------------------------------------------------+
]]></artwork>
</figure>

<figure title="Example of a SESSION_AUTH_OBJECT Using an X509_V3_CERT
 Certificate" anchor='fig-X509-V3-CERT'>
<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1|0|0|0| Type = SESSION_AUTH   |0|0|0|0|    Object   Length    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |   AUTH_ENT_ID | X509_V3_CERT  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   OctetString ...   (Authorizing entity Digital Certificate)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |   AUTH_DATA   |     zero      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   OctetString ...   (Authentication data)                     |
+---------------------------------------------------------------+
]]></artwork>
</figure>

<section title="Operational Setting for Public-Key-Based Authentication">

<t>
Public-key-based authentication assumes the following:

</t>
<t>
<list style="symbols">

<t>

  Authorizing entities have a pair of keys (private key and
   public key).

</t>
<t>

  The private key is secured with the authorizing entity.

</t>
<t>

  Public keys are stored in digital certificates; a trusted
   party, the certificate authority (CA), issues these digital
   certificates.

</t>
<t>

  The verifier (PDP or router) has the ability to verify the
   digital certificate.

</t>
</list>
</t>
<t>

The authorizing entity uses its private key to generate AUTHENTICATION_DATA.
Authenticators (router, PDP) use the authorizing entity's public key
(stored in the digital certificate) to verify and authenticate the
object.

</t>

<section title="X.509 V3 Digital Certificates">

<t>
When the AUTH_ENT_ID is of type X509_V3_CERT, AUTHENTICATION_DATA
MUST be generated by the authorizing entity following these steps:
</t>
<t>
<list style="symbols">
<t>

A signed-data is constructed as defined in RFC 5652 <xref
target="RFC5652" />. A digest is computed on the content (as specified
in <xref target="sec-SESSION-AUTH-generation"/>) with a
signer-specific message-digest algorithm. 
The certificates field contains the chain of X.509 V3
digital certificates from each authorizing entity.


The certificate revocation list is defined in the
crls field. The digest output is digitally signed following Section 8 of
RFC 3447 <xref target="RFC3447" />, using the signer's private key.

</t>
</list>
</t>
<t>

When the AUTH_ENT_ID is of type X509_V3_CERT, verification at the
verifying network element (PDP or router) MUST be done following these steps:

</t>
<t>
<list style="symbols">
<t>

  Parse the X.509 V3 certificate to extract the distinguished name
   of the issuer of the certificate.

</t>
<t>

  Certification Path Validation is performed as defined in Section 6
   of RFC 5280 <xref target="RFC5280"/>.

</t>
<t>

  Parse through the Certificate Revocation list to verify that the
   received certificate is not listed.

</t>
<t>

  Once  the X.509 V3 certificate is validated, the public key of the
   authorizing entity can be extracted from the certificate.

</t>
<t>

  Extract the digest algorithm and the length of the digested data
   by parsing the CMS (Cryptographic Message Syntax) signed-data.

</t>
<t>

  The recipient independently computes the message digest.  This
   message digest and the signer's public key are used to verify the
   signature value.

</t>
</list>
</t>
<t>


This verification ensures integrity, non-repudiation, and data origin.

</t>
</section>

<section title="PGP Digital Certificates">

<t>

When the AUTH_ENT_ID is of type PGP_CERT, AUTHENTICATION_DATA MUST be
generated by the authorizing entity following these steps:

</t>

<t>
  AUTHENTICATION_DATA contains a Signature Packet as defined in
   Section 5.2.3 of RFC 4880 <xref target="RFC4880"/>.  In summary:

</t>

<t>
<list style="symbols">
<t>

  Compute the hash of all data in the SESSION_AUTH object
   up to the AUTHENTICATION_DATA.

</t>
<t>

  The hash output is digitally signed following Section 8 of
  RFC 3447, using the signer's private key.

</t>
</list>
</t>
<t>

When the AUTH_ENT_ID is of type PGP_CERT, verification MUST be done
by the verifying network element (PDP or router) following these steps:

</t>
<t>
<list style="symbols">
<t>
  Validate the certificate.

</t>
<t>

  Once the PGP certificate is validated, the public key of the
   authorizing entity can be extracted from the certificate.

</t>
<t>

  Extract the hash algorithm and the length of the hashed data by
   parsing the PGP signature packet.

</t>
<t>

  The recipient independently computes the message digest.  This
   message digest and the signer's public key are used to verify the
   signature value.

</t>
</list>
</t>
<t>

This verification ensures integrity, non-repudiation, and data origin.

</t>
</section>
</section>
</section>

<section title="HMAC Signed" anchor='sec-hmac-signed'>

<t>
A SESSION_AUTH object that carries an AUTH_ENT_ID of HMAC_SIGNED 
is used as integrity protection for NSLP messages. The SESSION_AUTH
object MUST contain the following attributes:
</t>

<t>
<list style="symbols">
<t>
SOURCE_ADDR:        the source address of the entity that created
                   the HMAC
</t>

<t>
START_TIME:        the timestamp when the HMAC signature was 
                   calculated. This MUST be different for any 
		   two messages in sequence in order to prevent
		   replay attacks.  The NTP timestamp
		   currently provides a resolution of 200 picoseconds,
		   which should be sufficient.
</t>

<t>
NSLP_OBJECT_LIST:   this attribute lists all NSLP objects that
                   are included in HMAC calculation.
</t>


<t>
AUTHENTICATION_DATA: this attribute contains the Key-ID
                    that is used for HMAC calculation 
		    as well as the HMAC data itself <xref target="RFC2104" />.
</t>

</list>
</t>

<t>
The key used for HMAC calculation must be exchanged securely by some
other means, e.g., a Kerberos Ticket or pre-shared manual installation
etc.  The Key-ID in the AUTHENTICATION_DATA allows the reference to the
appropriate key and also to periodically change signing keys within a
session.  The key length MUST be at least 64 bits, but it is ideally
longer in order to defend against brute-force attacks during the key
validity period. For scalability reasons it is suggested to use a
per-user key for signing NSLP messages, but using a per-session key is
possible, too, at the cost of a per-session key exchange.  A per-user
key allows for verification of the authenticity of the message and
thus provides a basis for a session-based per-user authorization. It
is RECOMMENDED to periodically change the shared key in order to
prevent eavesdroppers from performing brute-force off-line attacks
on the shared key. The actual hash algorithm used in the HMAC
computation is specified by the "Transform ID" field (given as
Transform Type 3 of the IKEv2 registry <xref target="RFC5996" />).


The hash algorithm MUST be chosen consistently between the object
creator and the NN verifying the HMAC; this can be accomplished by
out-of-band mechanisms when the shared key is exchanged.
</t>

<t>
<xref target='fig-hmac-signed-obj'></xref> shows an example of
an object that is used for integrity protection of NSLP messages.
</t>

<t>
<figure title="Example of a SESSION_AUTH_OBJECT That Provides
Integrity Protection for NSLP Messages" anchor='fig-hmac-signed-obj'>
<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1|0|0|0| Type = SESSION_AUTH   |0|0|0|0|    Object   Length    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |   AUTH_ENT_ID | HMAC_SIGNED   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   reserved                    | Transform ID  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             | SOURCE_ADDR   |  IPV4_ADDRESS |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                IPv4 Source Address of NSLP sender             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |  START_TIME   | NTP_TIME_STAMP|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        NTP Time Stamp (1)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        NTP Time Stamp (2)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             | NSLP_OBJ_LIST |     zero      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|No. of signed NSLP objects = n |  rsv  |  NSLP object type (1) |
+-------+-------+---------------+-------+-------+---------------+
|  rsv  | NSLP object type (2)  |             .....            //
+-------+-------+---------------+---------------+---------------+
|  rsv  | NSLP object type (n)  |     (padding if required)     |
+--------------+----------------+---------------+---------------+
|            Length             |   AUTH_DATA   |     zero      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Key-ID                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Message Authentication Code HMAC Data                |
+---------------------------------------------------------------+
]]></artwork>
</figure>

</t>

</section> <!-- HMAC Signed -->

</section>

<section title="Framework" anchor='sec-framework'>

<t>

RFC 3521 <xref target="RFC3521" /> describes a framework in which the
SESSION_AUTH object may be utilized to transport information
required for authorizing resource reservation for data flows (e.g., media flows).
RFC 3521 introduces four different models:

</t>
<t>
<list style="numbers">

<t> 
The coupled model
</t>
<t>
The associated model with one policy server
</t>
<t>
The associated model with two policy servers
</t>
<t>
The non-associated model
</t>
</list>
</t>
<t>

The fields that are required in a SESSION_AUTH object
depend on which of the models is used.

</t>

<section title="The Coupled Model">

<t>
In the coupled model, the only information that MUST be included in the
SESSION_AUTH object is the SESSION_ID; 
it is used by the Authorizing Entity
to correlate the resource reservation request with the media authorized
during session setup. Since the End Host is assumed to be untrusted,
the Policy Server SHOULD take measures to ensure that the integrity of
the SESSION_ID is preserved in transit; the exact mechanisms to be used
and the format of the SESSION_ID are implementation dependent.

</t>

</section>

<section title="The Associated Model with One Policy Server">

<t>

In this model, the contents of the SESSION_AUTH object MUST
include:

</t>

<t>
<list style="symbols">
<t>

  A session identifier - SESSION_ID. This is information that the
  authorizing entity can use to correlate the resource request with 
  the data flows authorized during session setup.

</t>
<t>

  The identity of the authorizing entity - AUTH_ENT_ID.  This
   information is used by an NN to determine which
   authorizing entity (Policy Server) should be used to solicit
   resource policy decisions.

</t>
</list>
</t>

<t>

In some environments, an NN may have no means for determining
if the identity refers to a legitimate Policy Server within its domain.
In order to protect against redirection of authorization requests to a
bogus authorizing entity, the SESSION_AUTH MUST also include:

</t>

<t>
<list style="empty">
<t>

AUTHENTICATION_DATA. This authentication data is calculated over all
other fields of the SESSION_AUTH object.

</t>
</list>
</t>

</section>

<section title="The Associated Model with Two Policy Servers">

<t>
The content of the SESSION_AUTH object is identical to the
associated model with one policy server.

</t>

</section>

<section title="The Non-Associated Model">

<t>

In this model, the SESSION_AUTH object MUST contain sufficient information
to allow the Policy Server to make resource policy decisions
autonomously from the authorizing entity.  The object is
created using information about the session by the authorizing
entity.  The information in the SESSION_AUTH object MUST
include:

</t>
<t>
<list style="symbols">

<t>

  Initiating party's IP address or Identity (e.g., FQDN) - SOURCE_ADDR
   X-Type

</t>
<t>

  Responding party's IP address or Identity (e.g., FQDN) - DEST_ADDR
   X-Type

</t>
<t>

  The authorization lifetime - START_TIME X-Type

</t>
<t>

  The identity of the authorizing entity to allow for validation of
   the token in shared symmetric key and Kerberos schemes -
   AUTH_ENT_ID X-Type

</t>
<t>

  The credentials of the authorizing entity in a public-key
   scheme - AUTH_ENT_ID X-Type

</t>
<t>

  Authentication data used to prevent tampering with the
   SESSION_AUTH object - AUTHENTICATION_DATA X-Type

</t>
</list>
</t>

<t>

Furthermore, the SESSION_AUTH object MAY contain:

</t>
<t>
<list style="symbols">
<t>
  The lifetime of (each of) the media stream(s) - END_TIME X-Type

</t>
<t>

  Initiating party's port number - SOURCE_ADDR X-Type

</t>
<t>

  Responding party's port number - DEST_ADDR X-Type

</t>
</list>
</t>
<t>

All SESSION_AUTH fields MUST match with the resource request.  If a
field does not match, the request SHOULD be denied.

</t>

</section>

</section>

<section title="Message Processing Rules">

<t>

This section discusses the message processing related to the
SESSION_AUTH object. Details of the processing of the SESSION_AUTH object 
within QoS NSLP and NATFW NSLP are described. 
New NSLP protocols should use the same logic in making use of the
SESSION_AUTH object. 

</t>

<section title="Generation of the SESSION_AUTH by an Authorizing Entity" anchor='sec-SESSION-AUTH-generation'>

<t>
<list style="numbers">

<t>
Generate the SESSION_AUTH object with the appropriate
contents as specified in <xref target='sec-session-auth-object-formats'></xref>.

</t>
<t>

If authentication is needed, the entire SESSION_AUTH object is
constructed, excluding the length, type, and SubType fields of the
SESSION_AUTH field. Note that the message MUST include a START_TIME to
prevent replay attacks.  The output of the authentication algorithm,
plus appropriate header information, is appended as the
AUTHENTICATION_DATA attribute to the SESSION_AUTH object.

</t>

</list>

</t>

</section>



<section title="Processing within the QoS NSLP">

<t>

The SESSION_AUTH object may be used with QoS NSLP QUERY and RESERVE
messages to authorize the query operation for network resources, and a
resource reservation request, respectively.

</t>
<t>

Moreover, the SESSION_AUTH object may also be used with RESPONSE
messages in order to indicate that the authorizing entity changed the
original request. For example, the session start or end times may have
been modified, or the client may have requested authorization for all
ports, but the authorizing entity only allowed the use of certain ports.

</t>
<t>

If the QoS NSIS Initiator (QNI) receives a RESPONSE message with a
SESSION_AUTH object, the QNI MUST inspect the SESSION_AUTH object to see
which authentication attribute was changed by an authorizing entity. The
QNI SHOULD also silently accept SESSION_AUTH objects in the RESPONSE message
that do not indicate any change to the original authorization request.

</t>

<section title="Message Generation">

<t>

A QoS NSLP message is created as specified in <xref target="RFC5974" />.

</t>
<t>
<list style="numbers">
<t>
The policy element received from the authorizing entity
MUST be copied without modification into the SESSION_AUTH object.

</t>
<t>

The SESSION_AUTH object (containing the policy element) is inserted
in the NSLP message in the appropriate place.

</t>
</list>
</t>

</section>

<section title="Message Reception">

<t>
The QoS NSLP message is processed as specified in <xref target="RFC5974" /> with
the following modifications.

</t>
<t>
<list style="numbers">

<t>
If the QoS NSIS Entity (QNE) is policy aware then it SHOULD use the Diameter QoS
application or the RADIUS QoS protocol to communicate with the PDP. To
construct the AAA message it is necessary to extract the SESSION_AUTH
object and the QoS-related objects from the QoS NSLP message and to
craft the respective RADIUS or Diameter message. The message processing
and object format are described in the respective RADIUS or Diameter QoS
protocol, respectively. If the QNE is policy unaware, then it ignores
the policy data objects and continues processing the NSLP message.

</t>
<t>

If the response from the PDP is negative, the request must be
rejected. A negative response in RADIUS is an Access-Reject, and in
Diameter is based on the 'DIAMETER_SUCCESS' value in the Result-Code AVP
of the QoS-Authz-Answer (QAA) message. The QNE must construct and send a
RESPONSE message with the status of the authorization failure as specified
in <xref target="RFC5974" />.

</t>


<t>

Continue processing the NSIS message.

</t>
</list>
</t>

</section>

<section title="Authorization (QNE or PDP)">

<t>
<list style="numbers">

<t>

Retrieve the policy element from the SESSION_AUTH object. Check the
AUTH_ENT_ID type and SubType fields and return an error if the identity
type is not supported.

</t>
<t>

Verify the message integrity.

<list style="symbols">

<t>
  Shared symmetric key authentication: The QNE or PDP uses the 
   AUTH_ENT_ID field to consult a table keyed by that field. 
   The table should identify the cryptographic authentication 
   algorithm to be used along with the expected length of the 
   authentication data and the shared symmetric key for the 
   authorizing entity. Verify that the indicated length of the 
   authentication data is consistent with the configured table 
   entry and validate the authentication data.

</t>
<t>

  Public Key: Validate the certificate chain against the trusted
   Certificate Authority (CA) and validate the message signature
   using the public key.

</t>

<t>
  HMAC signed: The QNE or PDP uses the Key-ID field of the
  AUTHENTICATION_DATA attribute to consult a table keyed by that 
  field. The table should identify the cryptographic authentication 
  algorithm to be used along with the expected length of the 
  authentication data and the shared symmetric key for the 
  authorizing entity. Verify that the indicated length of the 
  authentication data is consistent with the configured table 
  entry and validate the integrity of the parts of the NSLP message,
  i.e., session ID, MRI, NSLPID, and all other NSLP elements listed 
  in the NSLP_OBJECT_LIST authentication data as well as the 
  SESSION_AUTH object contents (cf. <xref target="sec-integrity-protection"/>). 

</t>


<t>
  Kerberos: If AUTHENTICATION_DATA contains an encapsulated KRB_CRED message
  (cf. <xref target="sec-kerberos"/>), the integrity of the KRB_CRED
  message can be verified within Kerberos itself. Moreover, if
  the same NSLP message contains another SESSION_AUTH object using
  HMAC_SIGNED, the latter can be
  used to verify the message integrity as described above.
</t>
</list>
</t>

<t>
Once the identity of the authorizing entity and the validity of the
service request have been established, the authorizing router/PDP MUST
then consult its authorization policy in order to determine whether or
not the specific request is finally authorized (e.g., based on available
credits and on information in the subscriber's database). To the extent to
which these access control decisions require supplementary
information, routers/PDPs MUST ensure that supplementary information
is obtained securely.

</t>
<t>

Verify that the requested resources do not exceed the authorized QoS.

</t>
</list>
</t>

</section>

<section title="Error Signaling">

<t>

When the PDP (e.g., a RADIUS or Diameter server) fails to verify the
policy element, the appropriate actions described in the respective AAA
document need to be taken.

</t>

<t>

The QNE node MUST return a RESPONSE message with the INFO_SPEC error
code 'Authorization failure' as defined in the QoS NSLP specification
<xref target="RFC5974"/>. The
QNE MAY include an INFO_SPEC Object Value Info to indicate which
SESSION_AUTH attribute created the error.

</t>

</section>

</section>

<section title="Processing with the NATFW NSLP">

<t>
This section presents processing rules for the NATFW NSLP <xref target="RFC5973" />.

</t>

<section title="Message Generation">

<t>

A NATFW NSLP message is created as specified in <xref target="RFC5973" />.

</t>
<t>
<list style="numbers">
<t>
The policy element received from the authorizing entity MUST be
copied without modification into the SESSION_AUTH object.

</t>
<t>

The SESSION_AUTH object (containing the policy element) is
inserted in the NATFW NSLP message in the appropriate place.

</t>
</list>
</t>

</section>

<section title="Message Reception">

<t>

The NATFW NSLP message is processed as specified in <xref target="RFC5973" /> 
with the following modifications.

</t>
<t>
<list style="numbers">
<t>

If the router is policy aware, then it SHOULD use the Diameter
application or the RADIUS protocol to communicate with the PDP. To
construct the AAA message, it is necessary to extract the SESSION_AUTH
object and the objects related to NATFW policy rules from the NSLP
message and to craft the respective RADIUS or Diameter message. The
message processing and object format is described in the respective
RADIUS or Diameter protocols. If the router is policy
unaware, then it ignores the policy data objects and continues
processing the NSLP message.

</t>
<t>

Reject the message if the response from the PDP is negative. A
negative response in RADIUS is an Access-Reject, and in Diameter is
based on the 'DIAMETER_SUCCESS' value in the Result-Code AVP.

</t>
<t>

Continue processing the NSIS message.

</t>
</list>
</t>

</section>

<section title="Authorization (Router/PDP)">

<t>

<list style="numbers">
<t>
Retrieve the policy element from the SESSION_AUTH object. Check the
AUTH_ENT_ID type and SubType fields and return an error if the identity
type is not supported.
</t>

<t>

Verify the message integrity.

<list style="symbols">

<t>
Shared symmetric key authentication: The network router/PDP uses the
AUTH_ENT_ID field to consult a table keyed by that field. The table
should identify the cryptographic authentication algorithm to be used,
along with the expected length of the authentication data and the shared
symmetric key for the authorizing entity. Verify that the indicated
length of the authentication data is consistent with the configured
table entry and validate the authentication data.
</t>

<t>
Public Key: Validate the certificate chain against the trusted
Certificate Authority (CA) and validate the message signature using the
public key.

</t>

<t>
  HMAC signed: The QNE or PDP uses the Key-ID field of the
  AUTHENTICATION_DATA attribute to consult a table keyed by that 
  field. The table should identify the cryptographic authentication 
  algorithm to be used along with the expected length of the 
  authentication data and the shared symmetric key for the 
  authorizing entity. Verify that the indicated length of the 
  authentication data is consistent with the configured table 
  entry and validate the integrity of parts of the NSLP message,
  i.e., session ID, MRI, NSLPID, and all other NSLP elements listed 
  in the NSLP_OBJECT_LIST authentication data as well as the 
  SESSION_AUTH object contents (cf. <xref target="sec-integrity-protection"/>). 

</t>


<t>
  Kerberos: If AUTHENTICATION_DATA contains an encapsulated KRB_CRED message
  (cf. <xref target="sec-kerberos"/>), the integrity of the KRB_CRED
  message can be verified within Kerberos itself. Moreover, an
  if the same NSLP message contains another SESSION_AUTH object using
  HMAC_SIGNED, the latter can be
  used to verify the message integrity as described above.
</t>
</list>

</t>


<t>
Once the identity of the authorizing entity and the validity of the
service request have been established, the authorizing router/PDP MUST
then consult its authorization policy in order to determine whether or
not the specific request is authorized. To the extent to which these
access control decisions require supplementary information, routers/PDPs
MUST ensure that supplementary information is obtained securely.

</t>
</list>
</t>

</section>

<section title="Error Signaling">

<t>
When the PDP (e.g., a RADIUS or Diameter server) fails to verify the
SESSION_AUTH object, the appropriate actions described in the
respective AAA document need to be taken. The NATFW NSLP node MUST
return an error message of class 'Permanent failure' (0x5) with error
code 'Authorization failed' (0x02).
</t>
</section>

</section>

<section title="Integrity Protection of NSLP Messages" anchor="sec-integrity-protection">

<t>

The SESSION_AUTH object can also be used to provide an integrity
protection for every NSLP signaling message, thereby also authenticating
requests or responses. Assume that a user has deposited a shared key
at some NN. This NN can then verify the integrity of every NSLP message
sent by the user to the NN. Based on this authentication, the NN can
apply authorization policies to actions like resource
reservations or opening of firewall pinholes.

</t>

<t>

The sender of an NSLP message creates a SESSION_AUTH object that
contains the AUTH_ENT_ID attribute set to HMAC_SIGNED (cf. <xref
target='sec-hmac-signed'/>) and hashes with the shared key over all
NSLP objects that need to be protected and lists them in the
NSLP_OBJECT_LIST.  The SESSION_AUTH object itself is also protected by
the HMAC.  By inclusion of the SESSION_AUTH object into the NSLP
message, the receiver of this NSLP message can verify its integrity if
it has the suitable shared key for the HMAC. Any response to the
sender should also be protected by inclusion of a SESSION_AUTH object
in order to prevent attackers from sending unauthorized responses on behalf 
of the real NN. 

</t>

<t>

If a SESSION_AUTH object is present that has an AUTH_ENT_ID attribute
set to HMAC_SIGNED, the integrity of all NSLP elements listed in the
NSLP_OBJECT_LIST has to be checked, including the SESSION_AUTH object
contents itself. Furthermore, session ID, MRI, and NSLPID have to
be included into the HMAC calculation, too, as specified in 
<xref target='sec-nslp-object-list'></xref>.  The key that is used to
calculate the HMAC is referred to by the Key-ID included in the
AUTHENTICATION_DATA attribute.  If the provided timestamp in START_TIME is not
recent enough or the calculated HMAC differs from the one provided in
AUTHENTICATION_DATA, the message must be discarded silently and an error should
be logged locally.

</t>

</section>


</section>

<section title="Security Considerations">

<t>

This document describes a mechanism for session authorization to prevent
theft of service. There are three types of security issues to consider:
protection against replay attacks, integrity of the SESSION_AUTH
object, and the choice of the authentication algorithms and keys.

</t>

<t>

The first issue, replay attacks, MUST be prevented. In the
non-associated model, the SESSION_AUTH object MUST include a START_TIME
field, and the NNs as well as Policy Servers MUST support NTP to ensure proper clock
synchronization. Failure to ensure proper clock synchronization will
allow replay attacks since the clocks of the different network entities
may not be in sync. The start time is used to verify that the request
is not being replayed at a later time. In all other models, the
SESSION_ID is used by the Policy Server to ensure that the resource
request successfully correlates with records of an authorized session.
If a SESSION_AUTH object is replayed, it MUST be detected by the policy
server (using internal algorithms), and the request MUST be rejected.

</t>
<t>

The second issue, the integrity of the SESSION_AUTH object, is preserved in
untrusted environments by including the AUTHENTICATION_DATA attribute
in such environments.

</t>

<t>

In environments where shared symmetric keys are possible, they should be
used in order to keep the SESSION_AUTH object size to a strict
minimum, e.g., when wireless links are used. A secondary option would be
Public Key Infrastructure (PKI) authentication, which provides a high level of security and good
scalability. However, PKI authentication requires the presence of credentials in the
SESSION_AUTH object, thus impacting its size.

</t>

<t>

The SESSION_AUTH object can also serve to protect the integrity
of NSLP message parts by using the HMAC_SIGNED Authentication Data
as described in <xref target='sec-integrity-protection'></xref>.

</t>

<t>

When shared keys are used, e.g., in AUTHENTICATION_DATA 
(cf. <xref target='sec-shared-key' />)
or in conjunction with HMAC_SIGNED (cf. <xref target='sec-hmac-signed' />),
it is important that the keys are kept secret, i.e., they must be 
exchanged, stored, and managed in a secure and confidential manner,
so that no unauthorized party gets access to the key material.
If the key material is disclosed to an unauthorized party, authentication and integrity
protection are ineffective.
</t>

<t>

Furthermore, security considerations for public-key mechanisms using 
the X.509 certificate mechanisms described in <xref target="RFC5280" /> apply.  
Similarly, security considerations for PGP (Pretty Good Privacy) described in <xref target="RFC4880" /> apply.

</t>


<t>

Further security issues are outlined in RFC 4081 <xref target="RFC4081" />.

</t>

</section>

<section title="IANA Considerations" anchor='sec-IANA'>

<t>The SESSION_AUTH_OBJECT NSLP Message Object type is specified as 0x016.</t>

<t>This document specifies an 8-bit Session
authorization attribute type (X-Type) field as well
as 8-bit SubType fields per X-Type, for which IANA has 
created and will maintain corresponding sub-registries for the
NSLP Session Authorization Object. 
</t>

<t>
Initial values for the X-Type registry 
and the registration procedures according to <xref target="RFC5226" /> 
are as follows:
</t>

<figure>
<artwork><![CDATA[
Registration Procedure:
   Specification Required
]]></artwork>
</figure>

<figure>
<artwork><![CDATA[
X-Type    Description                       
--------  -------------------
0         Reserved
1         AUTH_ENT_ID                       
2         SESSION_ID                        
3         SOURCE_ADDR                       
4         DEST_ADDR                         
5         START_TIME                        
6         END_TIME                          
7         NSLP_OBJECT_LIST                          
8         AUTHENTICATION_DATA               
9-127     Unassigned
128-255   Reserved for Private or Experimental Use
]]></artwork>
</figure>

<t>In the following, registration procedures and 
initial values for the SubType registries are specified.
</t>

<t>
Sub-registry: AUTH_ENT_ID (X-Type 1) SubType values
</t>


<figure>
<artwork><![CDATA[
Registration Procedure:
   Specification Required
]]></artwork>
</figure>

<figure>
<artwork><![CDATA[
Registry:
SubType   Description
--------  -------------
0         Reserved
1         IPV4_ADDRESS
2         IPV6_ADDRESS
3         FQDN
4         ASCII_DN
5         UNICODE_DN
6         URI
7         KRB_PRINCIPAL
8         X509_V3_CERT
9         PGP_CERT
10        HMAC_SIGNED
11-127    Unassigned
128-255   Reserved for Private or Experimental Use
]]></artwork>
</figure>


<t>
Sub-registry: SOURCE_ADDR (X-Type 3) SubType values
</t>

<figure>
<artwork><![CDATA[
Registration Procedure:
   Specification Required
]]></artwork>
</figure>

<figure>
<artwork><![CDATA[
Registry:
SubType   Description   
--------  -------------
0         Reserved
1         IPV4_ADDRESS  
2         IPV6_ADDRESS  
3         UDP_PORT_LIST 
4         TCP_PORT_LIST 
5         SPI
6-127     Unassigned
128-255   Reserved for Private or Experimental Use
]]></artwork>
</figure>

<t>
Sub-registry: DEST_ADDR (X-Type 4) SubType values
</t>

<figure>
<artwork><![CDATA[
Registration Procedure:
   Specification Required
]]></artwork>
</figure>

<figure>
<artwork><![CDATA[
Registry:
0         Reserved
1         IPV4_ADDRESS  
2         IPV6_ADDRESS  
3         UDP_PORT_LIST 
4         TCP_PORT_LIST 
5         SPI
6-127     Unassigned
128-255   Reserved for Private or Experimental Use
]]></artwork>
</figure>

<t>
Sub-registry: START_TIME (X-Type 5) SubType values
</t>

<figure>
<artwork><![CDATA[
Registration Procedure:
   Specification Required
]]></artwork>
</figure>

<figure>
<artwork><![CDATA[
Registry:
SubType   Description  
--------  -------------
0         Reserved
1         NTP_TIMESTAMP
2-127     Unassigned
128-255   Reserved for Private or Experimental Use
]]></artwork>
</figure>

<t>
Sub-registry: END_TIME (X-Type 6) SubType values
</t> 

<figure>
<artwork><![CDATA[
Registration Procedure:
   Specification Required
]]></artwork>
</figure>

<figure>
<artwork><![CDATA[
Registry:
SubType   Description  
--------  -------------
0         Reserved
1         NTP_TIMESTAMP
2-127     Unassigned
128-255   Reserved for Private or Experimental Use
]]></artwork>
</figure>

</section>

<section title="Acknowledgments">

<t>
We would like to thank Xioaming Fu and Lars Eggert for 
providing reviews and comments. Helpful comments
were also provided by Gen-ART reviewer Ben Campbell, as well as Sean Turner
and Tim Polk from the Security Area.

This document is largely based on the RFC 3520 <xref target="RFC3520" /> and
credit therefore goes to the authors of RFC 3520 -- namely, Louis-Nicolas
Hamer, Brett Kosinski, Bill Gage, and Hugh Shieh. 

Part of this work was funded by Deutsche Telekom Laboratories
within the context of the BMBF-funded ScaleNet project.
</t>

</section>

</middle>

    <back>
        <references title='Normative References'>

	&rfc2119;
	&rfc3447;
	&rfc5905;
	&rfc5971;
	&rfc5973;
	&rfc5974;
	&rfc5996;

	</references>

	<references title='Informative References'>

	&rfc1034;
	&rfc2104;
	&rfc3986;
	&rfc5280;
	&rfc3520;
	&rfc3521;
	&rfc4080;
	&rfc4081;
	&rfc4120;
	&rfc4514;
	&rfc4868;
	&rfc4880;
	&rfc5652;
	&rfc5226;

	</references>

    </back>

</rfc>
