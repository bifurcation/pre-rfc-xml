<?xml version="1.0" encoding="US-ASCII"?>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc comments="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc number="8290"
     ipr="trust200902" 
     submissionType="IETF"
     consensus="yes"
     category="exp">

  <front>
    <title abbrev="FQ-CoDel">The Flow Queue CoDel Packet Scheduler and Active Queue Management Algorithm</title>

<!-- [rfced]  ADs, we moved the following references from Normative to Informative
at the request of an author. Moving these references was requested after the
document was approved for publication. Please review and let us know if you
approve. The changes are highlighted in this diff file:

I-D.ietf-tcpm-dctcp
I-D.ietf-tsvwg-rtcweb-qos
RFC2003
RFC2890
RFC3168
RFC4213
RFC6817
-->

    <author initials="T." surname="Hoeiland-Joergensen" fullname="Toke Hoeiland-Joergensen">
      <organization>Karlstad University</organization>
      <address>
        <postal>
          <street>Dept. of Computer Science</street>
          <city>Karlstad</city>
          <code>65188</code>
          <country>Sweden</country>
        </postal>
        <email>toke@toke.dk</email>
      </address>
    </author>
    <author initials="P." surname="McKenney" fullname="Paul McKenney">
      <organization>IBM Linux Technology Center</organization>
      <address>
        <postal>
          <street>1385 NW Amberglen Parkway</street>
          <city>Hillsboro</city>
          <region>OR</region>
          <code>97006</code>
          <country>United States of America</country>
        </postal>
        <email>paulmck@linux.vnet.ibm.com</email>
        <uri>http://www2.rdrop.com/~paulmck/</uri>
      </address>
    </author>
    <author initials="D." surname="Taht" fullname="Dave Taht">
      <organization>Teklibre</organization>
      <address>
        <postal>
          <street>2104 W First street</street> <street>Apt 2002</street>
          <city>FT Myers</city>
          <region>FL</region>
          <code>33901</code>
          <country>United States of America</country>
        </postal>
        <email>dave.taht@gmail.com</email>
        <uri>http://www.teklibre.com/</uri>
      </address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization></organization>
      <address>
        <postal>
          <street>21 Oak Knoll Road</street>
          <city>Carlisle</city>
          <region>MA</region>
          <code>993</code>
          <country>United States of America</country>
        </postal>
        <email>jg@freedesktop.org</email>
        <uri>https://en.wikipedia.org/wiki/Jim_Gettys</uri>
      </address>
    </author>
    <author initials="E." surname="Dumazet" fullname="Eric Dumazet">
      <organization>Google, Inc.</organization>
      <address>
        <postal>
          <street>1600 Amphitheatre Pkwy</street>
          <city>Mountain View</city>
          <region>CA</region>
          <code>94043</code>
          <country>United States of America</country>
        </postal>
        <email>edumazet@gmail.com</email>
      </address>
    </author>

    <date year="2018" month="January"/>

    <area>General</area>
    <workgroup>AQM working group</workgroup>
    
    <abstract>


<t>This memo presents the FQ-CoDel hybrid packet scheduler and
Active Queue Management (AQM) algorithm, a powerful tool for fighting bufferbloat and
reducing latency.</t>

<t>FQ-CoDel mixes packets from multiple flows and reduces the impact of
head-of-line blocking from bursty traffic. It provides isolation for
low-rate traffic such as DNS, web, and videoconferencing traffic. It
improves utilisation across the networking fabric, especially for
bidirectional traffic, by keeping queue lengths short, and it can be
implemented in a memory- and CPU-efficient fashion across a wide range
of hardware.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>The Flow Queue CoDel (FQ-CoDel) algorithm is a combined packet scheduler
and Active Queue Management (AQM) <xref target="RFC3168"/> algorithm developed as
part of the bufferbloat-fighting community effort <xref target="BLOATWEB"/>. 
It is
based on a modified Deficit Round Robin (DRR) queue scheduler
<xref target="DRR"/><xref target="DRRPP"/> with the CoDel AQM <xref target="RFC8289"/> algorithm
operating on each queue. 
This document describes the combined algorithm; reference implementations are
available for the ns-2 <xref target="NS2"/> and ns-3 <xref target="NS3"/>
network simulators, and the algorithm is included in the mainline Linux kernel as the fq_codel queueing discipline <xref target="LINUXSRC"/>.</t>

<!-- [rfced]  Please confirm that the [CODEL] citation is correct here. In
other instances in this document, [I-D.ietf-aqm-codel] (i.e., RFC-to-be
8289) is listed as the citation for the CoDel AQM algorithm.

Original
   Each queue is managed by the CoDel AQM algorithm
   [CODEL].  
-->

<t>FQ-CoDel is a general, efficient, nearly parameterless queue management
approach combining flow queueing with CoDel. It is a powerful tool for solving
bufferbloat <xref target="BLOAT"/> and has already been turned on by default in a number of
Linux distributions.

In this document, we describe the Linux implementation in sufficient
detail for others to independently implement the algorithm for deployment
outside the Linux ecosystem.</t>

<t>Since the FQ-CoDel algorithm was originally developed in the Linux
kernel, that implementation is still considered canonical. 

This document describes the algorithm in the abstract in Sections <xref
target="introduction" format="counter"/>-<xref target="scheduler" format="counter"/> and
separates out most implementation details in
subsequent sections; however, the Linux implementation is used as a reference
for default behaviour in the abstract algorithm description.</t>

<t>This document is structured as follows. This section gives
some concepts and terminology used in the rest of the document and
gives a short informal summary of the FQ-CoDel algorithm. <xref target="codel"/>
gives an overview of the CoDel algorithm. <xref target="fq"/> covers the flow hashing
and DRR portion. <xref target="scheduler"/> then describes the working of the
algorithm in detail, while <xref target="implementation"/> describes implementation
details and considerations. <xref target="limitations"/> lists some of the
limitations of using flow queueing. <xref target="deployment-status"/>
outlines the current status of FQ-CoDel deployment and lists some
possible future areas of inquiry. Finally, <xref target="security"/> reiterates some
important security points that must be observed in the implementation.</t>

<section anchor="conventions-used-in-this-document" title="Conventions Used in This Document">

        <t>
    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
    "MAY", and "OPTIONAL" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>

</section>
<section anchor="terminology-and-concepts" title="Terminology and Concepts">

<!-- [rfced]  Please review the use of underscores in the text (created by the
spanx element in the XML) and let us know if the underscores are
needed in each instance. We suggest using underscores only for emphasis. In
some instances in the document, underscores are used around parameter names or
terms. Perhaps they can be omitted or replaced with quotation marks in these
cases. Please review and let us know how to procede.

Example with parameter names:
   The _target_ parameter has the same semantics as CoDel. 

Example with term:
   The intention of FQ-CoDel's scheduler is to give each _flow_ its own
   queue, hence the term _Flow Queueing_.
-->



<t>
<list style="hanging" hangIndent="3">

<t hangText="Flow:">A flow is typically identified by a 5-tuple of source IP
address, destination IP address, source port number, destination port number,
and protocol number. It can also be identified by a superset or subset of those parameters,
by Media Access Control (MAC) address, or by other means. FQ-CoDel hashes
flows into a configurable number of buckets to assign packets to
internal queues.</t>

<t hangText="Queue:">A queue of packets represented internally in FQ-CoDel. In most
instances, each flow gets its own queue; however, because of the
possibility of hash collisions, this is not always the case. In an
attempt to avoid confusion, the word "queue" is used to refer to the
internal data structure, and "flow" is used to refer to the actual stream of
packets being delivered to the FQ-CoDel algorithm.</t>

<t hangText="Scheduler:">A mechanism to select which queue a packet is dequeued from.</t>

<t hangText="CoDel AQM:">The Active Queue Management algorithm employed by
FQ-CoDel as described in <xref target="RFC8289"/>.</t>

<t hangText="DRR:">Deficit Round Robin scheduling <xref target="DRR"/>.</t>

<t hangText="Quantum:">The maximum amount of bytes to be dequeued from a queue at
once.</t>

<t hangText="Interval:">Characteristic time period used by the control loop of CoDel
to detect when a persistent queue is developing (see Section 4.2 of
<xref target="RFC8289"/>).</t>

<t hangText="Target:">Setpoint value of the minimum sojourn time of packets in a queue
used as the target of the control loop in CoDel (see Section 4.3 of
<xref target="RFC8289"/>).</t>
</list>
</t>

</section>
<section anchor="informal-summary-of-fq-codel" title="Informal Summary of FQ-CoDel">

<t>FQ-CoDel is a hybrid of DRR <xref target="DRR"/> and CoDel <xref target="RFC8289"/>,
with an optimisation for sparse flows similar to Shortest Queue First
(SQF) <xref target="SQF"/> and DRR++ <xref target="DRRPP"/>. We call this
"flow queueing" rather
than "fair queueing", as flows that build a queue are treated differently
from flows that do not.</t>


<t>By default, FQ-CoDel stochastically classifies incoming packets into
different queues by hashing the 5-tuple of protocol number, source 
and destination IP addresses, and source and destination port numbers, 
perturbed with a random number selected at initiation time (although 
other flow classification schemes can optionally be configured instead; see <xref target="alternate-class"/>). Each
queue is managed by the CoDel AQM algorithm <xref target="CODEL"/> <xref target="RFC8289"/>. Packet ordering
within a queue is preserved, since queues have FIFO ordering.</t>

<t>The FQ-CoDel algorithm consists of two logical parts: (1) the scheduler,
which selects which queue to dequeue a packet from, and (2) the CoDel AQM,
which works on each of the queues. The subtleties of FQ-CoDel are mostly
in the scheduling part, whereas the interaction between the scheduler
and the CoDel algorithm are fairly straightforward.</t>

<t>At initialisation, each queue is set up to have a separate set of CoDel
state variables. By default, 1024 queues are created. The Linux
implementation at the time of writing supports anywhere from one to 65535 
separate queues, and each queue maintains the state variables throughout
its lifetime, and so acts the same as the non-FQ variant of CoDel would.
This means that with only one queue, FQ-CoDel behaves essentially the
same as CoDel by itself.</t>

<t>On dequeue, FQ-CoDel selects a queue from which to dequeue by a two-tier,
round-robin scheme, in which each queue is allowed to dequeue up to a
configurable quantum of bytes for each iteration. Deviations from this
quantum are maintained as byte credits for the queue, which serves to
make the fairness scheme byte-based rather than packet-based. The
two-tier, round-robin mechanism distinguishes between "new" queues (which
don't build up a standing queue) and "old" queues (which have queued
enough data to be active for more than one iteration of the round-robin
scheduler).</t>

<t>This new/old queue distinction has a particular consequence for 
queues that don't build up more than a quantum of bytes before being 
visited by the scheduler: such a queue will be removed from the list after it
empties and then re-added as a new queue the next time a packet arrives for
it. This means it will effectively get priority over queues that do not empty
out each round (a minor caveat is required here to protect against starvation,
see below).
Exactly how little data a flow has to send to keep its queue in this
state is somewhat difficult to reason about, because it depends on
both the egress link speed and the number of concurrent
flows. However, in practice, many things that are beneficial to have
prioritised for typical internet use (ACKs, DNS lookups, interactive
Secure Shell (SSH), HTTP requests, Voice over IP (VoIP)) <spanx style="emph">tend</spanx> to fall in this category,
which is why FQ-CoDel performs so well for many practical
applications. However, the implicitness of the prioritisation means
that for applications that require guaranteed priority (for instance,
multiplexing the network control plane over the network itself),
explicit classification is still needed.</t>

<t>This scheduling scheme has some subtlety to it, which is explained in
detail in the remainder of this document.</t>

</section>
</section>
<section anchor="codel" title="CoDel">

<t>CoDel is described in the Communications of the ACM paper <xref target="CODEL"/> and the IETF
document <xref target="RFC8289"/>. The basic idea is to control queue
length, maintaining sufficient queueing to keep the outgoing link busy
but avoiding building up the queue beyond that point. This is done by
preferentially dropping packets that remain in the queue for "too long".
Packets are dropped by head drop, which lowers the time for the drop
signal to propagate back to the sender by the length of the queue and
helps trigger TCP fast retransmit sooner.</t>

<t>The CoDel algorithm itself will not be described here; instead, we refer
the reader to the CoDel document <xref target="RFC8289"/>.</t>

</section>
<section anchor="fq" title="Flow Queueing">

<t>The intention of FQ-CoDel's scheduler is to give each flow its own
queue, hence the term "flow queueing".  Rather than a perfect realisation
of this, a hashing-based scheme is used, where flows are hashed into a
number of buckets, each of which has its own queue. The number of buckets is
configurable and presently defaults to 1024 in the Linux
implementation. This is enough to avoid hash collisions on a moderate
number of flows as seen, for instance, in a home gateway. Depending on the
characteristics of the link, this can be tuned to trade off memory for a
lower probability of hash collisions. See Sections <xref
target="probability-of-hash-collisions" format="counter"/> and <xref target="memory-overhead"
format="counter"/> for a more in-depth
discussion of this.</t>

<t>By default, the flow hashing is performed on the 5-tuple of source and
destination IP addresses, source and destination port numbers, and protocol number. While
the hashing can be customised to match on arbitrary packet bytes, care
should be taken when doing so; much of the benefit of the FQ-CoDel
scheduler comes from this per-flow distinction. However, the default
hashing does have some limitations, as discussed in <xref target="limitations"/>.</t>

<t>FQ-CoDel's DRR scheduler is byte-based, employing a deficit round-robin
mechanism between queues. 

This works by keeping track of the current number of "byte
credits" of each queue. This number is initialised to the
configurable quantum; each time a queue gets a dequeue opportunity, it
gets to dequeue packets, thus decreasing the number of credits by the packet
size for each packet. This continues until the value of the byte credits
counter becomes zero or less, at which point the counter is increased by one quantum, and
the dequeue opportunity ends.</t>

<t>This means that if one queue contains packets of, for instance, size
quantum/3, and another contains quantum-sized packets, the first queue
will dequeue three packets each time it gets a turn, whereas the second
only dequeues one. 

This means that flows that send small packets are not
penalised by the difference in packet sizes; rather, the DRR scheme
approximates a byte-based fairness queueing scheme. The size of
the quantum determines the scheduling granularity, with the trade-off
from too small a quantum being scheduling overhead. For small
bandwidths, lowering the quantum from the default MTU size can be
advantageous.</t>

<t>Unlike plain DRR, there are two sets of flows: a "new" list for flows
that have not built a queue recently and an "old" list for queues that
build a backlog. This distinction is an integral part of the FQ-CoDel
scheduler and is described in more detail in <xref target="scheduler"/>.</t>

</section>
<section anchor="scheduler" title="The FQ-CoDel Scheduler">
<t>To make its scheduling decisions, FQ-CoDel maintains two ordered lists
of active queues: new and old queues. When a packet is added
to a queue that is not currently active, that queue becomes active by
being added to the list of new queues. Later on, it is moved to the list
of old queues, from which it is removed when it is no longer active.
This behaviour is the source of some subtlety in the packet scheduling
at dequeue time, as explained below.</t>

<section anchor="enqueue" title="Enqueue">

<t>The packet enqueue mechanism consists of three stages: classifying
into a queue, timestamping and bookkeeping, and optionally dropping a
packet when the total number of enqueued packets goes over the maximum.</t>

<t>When a packet is enqueued, it is first classified into the appropriate
queue. 
By default, this is done by hashing (using a Jenkins hash
function <xref target="JENKINS"/>) on the 5-tuple of IP protocol, source and
destination IP addresses, and source and destination port numbers (if they
exist) and then taking
the hash value modulo the number of queues. The hash is salted by modulo
addition of a random value selected at initialisation time to prevent
possible DoS attacks if the hash is predictable ahead of time (see
<xref target="security"/>). The Linux kernel implements the Jenkins hash function by
mixing three 32-bit values into a single 32-bit output value. Inputs
larger than 96 bits are reduced by additional mixing steps, 96 bits at a
time.</t>

<t>Once the packet has been successfully classified into a queue, it is
handed over to the CoDel algorithm for timestamping. It is then added to
the tail of the selected queue, and the queue's byte count is updated by
the packet size. Then, if the queue is not currently active (i.e., if it
is not in either the list of new queues or the list of old queues), it is added
to the end of the list of new queues, and its number of credits is
initiated to the configured quantum. Otherwise, the queue is left in its
current queue list.</t>

<t>Finally, to protect against overload, the total number of enqueued packets
is compared with the configured limit. If the limit is exceeded (which can 
happen since a packet was just enqueued), the queue with the largest current
byte count is selected and half the number of packets from this queue (up to a
maximum of 64 packets) are dropped from the head of that queue. Dropping
several packets at once helps amortise the cost of finding the longest queue,
significantly lowering CPU usage in an overload situation.</t>

<section anchor="alternate-class" title="Alternative Classification Schemes">

<t>As mentioned previously, it is possible to modify the classification
scheme to provide a different notion of a flow. The Linux
implementation provides this option in the form of the <spanx style="verb">tc filter</spanx>
command. While this can add capabilities (for instance, matching on
other possible parameters such as MAC address, Diffserv code point
values, firewall rules, flow-specific markings, IPv6 flow label, etc.),
care should be taken to preserve the notion of flow because much of the
benefit of the FQ-CoDel scheduler comes from keeping flows in separate
queues.</t>

<t>For protocols that do not contain a port number (such as ICMP), the
Linux implementation simply sets the port numbers to zero and performs
the hashing as usual. In practice, this results in such protocols 
each getting their own queue (except in the case of hash collisions). An
implementation can perform other classifications for protocols that have
their own notion of a flow but SHOULD fall back to simply hashing on
source and destination IP address and protocol number in the absence
of other information.</t>

<t>The default classification scheme can additionally be improved by
performing decapsulation of tunnelled packets prior to hashing on the
5-tuple in the encapsulated payload. The Linux implementation does this
for common encapsulations known to the kernel, such as 6in4 <xref target="RFC4213"/>,
IP-in-IP <xref target="RFC2003"/>, and Generic Routing Encapsulation (GRE)
<xref target="RFC2890"/>. 

This helps to distinguish between flows that share the same
(outer) 5-tuple but, of course, is limited to unencrypted tunnels (see
<xref target="opaque-encap"/> for a discussion of encrypted tunnels).</t>

</section>
</section>
<section anchor="dequeue" title="Dequeue">

<t>Most of FQ-CoDel's work is done at packet dequeue time. It consists of
three parts: selecting a queue from which to dequeue a packet,
actually dequeueing it (employing the CoDel algorithm in the process),
and some final bookkeeping.</t>


<t>For the first part, the scheduler first looks at the list of new queues;
for the queue at the head of that list, if that queue has a negative
number of credits (i.e., it has already dequeued at least a quantum of
bytes), it is given an additional quantum of credits, the queue is put
onto <spanx style="emph">the end of</spanx> the list of old queues, and the routine selects the
next queue and starts again.</t>

<t>Otherwise, that queue is selected for dequeue. If the list of new queues
is empty, the scheduler proceeds down the list of old queues in the same
fashion (checking the credits and either selecting the queue for
dequeueing or adding credits and putting the queue back at the end of
the list).</t>

<t>After having selected a queue from which to dequeue a packet, the CoDel
algorithm is invoked on that queue. This applies the CoDel control law,
which is the mechanism CoDel uses to determine when to drop packets (see
<xref target="RFC8289"/>). As a result of this, one or more packets may be
discarded from the head of the selected queue before the packet that
should be dequeued is returned (or nothing is returned if the queue is
or becomes empty while being handled by the CoDel algorithm).</t>

<t>Finally, if the CoDel algorithm does not return a packet, then the queue
must be empty, and the scheduler does one of two things. If the queue
selected for dequeue came from the list of new queues, it is moved to
<spanx style="emph">the end of</spanx> the list of old queues. If instead it came from the list of
old queues, that queue is removed from the list, to be added back (as a
new queue) the next time a packet arrives that hashes to that queue.
Then (since no packet was available for dequeue), the whole dequeue
process is restarted from the beginning.</t>

<t>If, instead, the scheduler <spanx style="emph">did</spanx> get a packet back from the CoDel
algorithm, it subtracts the size of the packet from the byte credits for
the selected queue and returns the packet as the result of the dequeue
operation.</t>

<t>The step that moves an empty queue from the list of new queues to the
end of the list of old queues before it is removed is crucial to
prevent starvation. Otherwise, the queue could reappear (the next time a
packet arrives for it) before the list of old queues is visited; this
can go on indefinitely, even with a small number of active flows, if the
flow providing packets to the queue in question transmits at just the
right rate. 
This is prevented by first moving the queue to the end of 
the list of old queues, forcing the scheduler to service all old queues before
the empty queue is removed and thus preventing starvation.</t>

<t>The resulting migration of queues between the different states is
   summarised in the state diagram shown in Figure 1. Note that both the new
   and old queue states can additionally have arrival and
   dequeue events that do not change the state; these are omitted in the figure.</t>

<figure><artwork><![CDATA[
+-----------------+                +------------------+
|                 |     Empty      |                  |
|     Empty       |<---------------+       Old        +----+
|                 |                |                  |    |
+-------+---------+                +------------------+    |
        |                             ^            ^       |Credits
        |Arrival                      |            |       |Exhausted
        v                             |            |       |
+-----------------+                   |            |       |
|                 |      Empty or     |            |       |
|      New        +-------------------+            +-------+
|                 | Credits Exhausted
+-----------------+
]]></artwork></figure>

<t>Figure 1: Partial State Diagram for Queues between Different States</t>

</section>
</section>
<section anchor="implementation" title="Implementation Considerations">

<t>This section contains implementation details for the FQ-CoDel algorithm.
This includes the data structures and parameters used in the Linux
implementation, as well as discussion of some required features of the
target platform and other considerations.</t>

<section anchor="data-structures" title="Data Structures">
<t>The main data structure of FQ-CoDel is the array of queues, which is
instantiated with the number of queues specified by the "flows" parameter
at instantiation time. Each queue consists simply of an ordered list of
packets with FIFO semantics, two state variables tracking the queue
credits and total number of bytes enqueued, and the set of CoDel state
variables. Other state variables to track queue statistics can also be
included; for instance, the Linux implementation keeps a count of
dropped packets.</t>

<t>In addition to the queue structures themselves, FQ-CoDel maintains two
ordered lists containing references to the subset of queues that are
currently active. These are the lists of new and
old queues, as explained in <xref target="scheduler"/> above.</t>

<t>In the Linux implementation, queue space is shared: there's a global
   limit on the number of packets the queues can hold, but not a limit for each
   queue.</t>

</section>
<section anchor="parameters" title="Parameters">

<t>The following are the user configuration parameters exposed by the Linux
implementation of FQ-CoDel.</t>

<section anchor="interval" title="Interval">

<t>The "interval" parameter has the same semantics as CoDel and is used to
ensure that the minimum sojourn time of packets in a queue used as an
estimator by the CoDel control algorithm is a relatively up-to-date
value. That is, CoDel only reacts to delay experienced in the last epoch
of length interval. It SHOULD be set to be on the order of the
worst-case RTT through the bottleneck to give end points sufficient time
to react.</t>

<t>The default interval value is 100 ms.</t>

</section>
<section anchor="target" title="Target">

<t>The "target" parameter has the same semantics as CoDel. It is the
acceptable minimum standing/persistent queue delay for each FQ-CoDel
queue. This minimum delay is identified by tracking the local minimum
queue delay that packets experience.</t>

<t>The default target value is 5 ms, but this value should be tuned to be at
least the transmission time of a single MTU-sized packet at the prevalent
egress link speed (which, for example, is ~15 ms for 1 Mbps and MTU
1500). This prevents CoDel from being too aggressive at low bandwidths. It
should otherwise be set to 5-10% of the configured interval.</t>

</section>
<section anchor="packet-limit" title="Packet Limit">

<t>Routers do not have infinite memory, so some packet limit MUST be
enforced.</t>

<t>The "limit" parameter is the hard limit on the real queue size, measured
in number of packets. This limit is a global limit on the number of
packets in all queues; each individual queue does not have an upper
limit. When the limit is reached and a new packet arrives for enqueue, 
packets are dropped from the head of the largest queue (measured in bytes)
to make room for the new packet.</t>

<t>In Linux, the default packet limit is 10240 packets, which is suitable
for up to 10-Gigabit Ethernet speeds. In practice, the hard limit is
rarely (if ever) hit, as drops are performed by the CoDel algorithm long
before the limit is hit. For platforms that are severely memory
constrained, a lower limit can be used.</t>

</section>
<section anchor="quantum" title="Quantum">

<t>The "quantum" parameter is the number of bytes each queue gets to
dequeue on each round of the scheduling algorithm. The default is set to
1514 bytes, which corresponds to the Ethernet MTU plus the hardware
header length of 14 bytes.</t>

<t>In systems employing TCP Segmentation Offload (TSO), where a "packet"
consists of an offloaded packet train, it can presently be as large as
64 kilobytes. In systems using Generic Receive Offload (GRO), they can be
up to 17 times the TCP max segment size (or 25 kilobytes). These
mega-packets severely impact FQ-CoDel's ability to schedule traffic, and they
hurt latency needlessly. There is ongoing work in Linux to make smarter
use of offload engines.</t>

</section>
<section anchor="flows" title="Flows">

<t>The "flows" parameter sets the number of queues into which the
incoming packets are classified. Due to the stochastic nature of
hashing, multiple flows may end up being hashed into the same slot.</t>

<t>This parameter can be set only at initialisation time in the current
implementation, since memory has to be allocated for the hash table.</t>

<t>The default value is 1024 in the current Linux implementation.</t>

</section>
<section anchor="explicit-congestion-notification-ecn" title="Explicit Congestion Notification (ECN)">

<t>ECN <xref target="RFC3168"/> is enabled by default. Rather than do
anything special with
misbehaved ECN flows, FQ-CoDel relies on the packet scheduling system to
minimise their impact; thus, the number of unresponsive packets in a flow
being marked with ECN can grow to the overall packet limit but will not
otherwise affect the performance of the system.</t>

<t>ECN can be disabled by specifying the "noecn" parameter.</t>

</section>
<section anchor="ce-threshold" title="CE Threshold">

<t>This parameter enables DCTCP-like processing resulting
in Congestion Encountered (CE) marking on ECN-Capable Transport (ECT)
packets <xref target="RFC3168"/> starting at a lower sojourn delay setpoint than the
default CoDel target. Details of Data Center TCP (DCTCP) can be found in
<xref target="RFC8257"/>.</t>

<t>The "ce_threshold" parameter is disabled by
default; it can be enabled by setting it to a number of microseconds.</t>

</section>
</section>
<section anchor="probability-of-hash-collisions" title="Probability of Hash Collisions">

<t>Since the Linux FQ-CoDel implementation by default uses 1024 hash
buckets, the probability that (say) 100 flows will all hash to the same
bucket is something like ten to the power of minus 300. Thus, at least
one of the flows will almost certainly hash to some other queue.</t>

<t>Expanding on this, based on analytical equations for hash collision
probabilities, for 100 flows, the probability of no collision is 90.78%;
the probability that no more than two of the 100 flows will be involved
in any given collision is 99.57%; and the probability that no more than
three of the 100 flows will be involved in any given collision is 99.99%.
These probabilities assume a hypothetical perfect hashing function, so
in practice, they may be a bit lower. We have not found this difference
to matter in practice.</t>

<t>These probabilities can be improved upon by using set-associative
hashing, a technique used in the Cake algorithm currently being 
developed as a further refinement of the FQ-CoDel principles <xref target="CAKE"/>.
For a 4-way associative hash with the same number of total queues, the
probability of no collisions for 100 flows is 99.93%, while for an 8-way
associative hash, it is ~100%.</t>

</section>
<section anchor="memory-overhead" title="Memory Overhead">

<t>FQ-CoDel can be implemented with a low memory footprint (less than 64
bytes per queue on 64-bit systems). These are the data structures used
in the Linux implementation:</t>

<t>&lt;CODE BEGINS&gt;</t>

<figure><artwork><![CDATA[
struct codel_vars {
   u32             count;             /* number of dropped packets */
   u32             lastcount;     /* count entry to dropping state */
   bool            dropping;                /* currently dropping? */
   u16             rec_inv_sqrt;    /* reciprocal sqrt computation */
   codel_time_t    first_above_time;    /* when delay above target */
   codel_time_t    drop_next;                 /* next time to drop */
   codel_time_t    ldelay; /* sojourn time of last dequeued packet */
};

struct fq_codel_flow {
   struct sk_buff    *head;
   struct sk_buff    *tail;
   struct list_head  flowchain;
   int               credits;   /* current number of queue credits */
   u32               dropped; /* # of drops (or ECN marks) on flow */
   struct codel_vars cvars;
};
]]></artwork></figure>

<t>&lt;CODE ENDS&gt;</t>

<t>The master table managing all queues looks like this:</t>

<t>&lt;CODE BEGINS&gt;</t>

<figure><artwork><![CDATA[
struct fq_codel_sched_data {
   struct tcf_proto *filter_list;  /* optional external classifier */
   struct fq_codel_flow *flows;    /* Flows table [flows_cnt] */
   u32             *backlogs;      /* backlog table [flows_cnt] */
   u32             flows_cnt;      /* number of flows */
   u32             perturbation;   /* hash perturbation */
   u32             quantum;        /* psched_mtu(qdisc_dev(sch)); */
   struct codel_params cparams;
   struct codel_stats cstats;
   u32             drop_overlimit;
   u32             new_flow_count;

   struct list_head new_flows;     /* list of new flows */
   struct list_head old_flows;     /* list of old flows */
};
]]></artwork></figure>

<t>&lt;CODE ENDS&gt;</t>

</section>
<section anchor="per-packet-timestamping" title="Per-Packet Timestamping">

<t>The CoDel portion of the algorithm requires per-packet timestamps be
stored along with the packet. While this approach works well for
software-based routers, it may be impossible to retrofit devices that do
most of their processing in silicon and lack the space or mechanism for
timestamping.</t>

<t>Also, while perfect resolution is not needed, timestamp resolution finer
than the CoDel target setting is necessary. Furthermore, timestamping
functions in the core OS need to be efficient, as they are called at
least once on each packet enqueue and dequeue.</t>

</section>
<section anchor="limiting-queueing-in-lower-layers" title="Limiting Queueing in Lower Layers">

<t>When deploying a queue management algorithm such as FQ-CoDel, it is
important to ensure that the algorithm actually runs in the right place
to control the queue. In particular, lower layers of the operating system
networking stack can have queues of their own, as can device drivers and
hardware. Thus, it is desirable that the queue management algorithm runs
as close to the hardware as possible. However, scheduling such
complexity at interrupt time is difficult, so a small standing queue
between the algorithm and the wire is often needed at higher transmit
rates.</t>

<t>In Linux, the mechanism to ensure these different needs are balanced is
called "Byte Queue Limits" <xref target="BQL"/>; it controls the device driver
ring buffer (for physical line rates). For cases where this
functionality is not available, the queue can be controlled by means of
a software rate limiter such as Hierarchical Token Bucket <xref target="HTB"/> or
Hierarchical Fair-Service Curve <xref target="HFSC"/>. The Cake algorithm <xref target="CAKE"/>
integrates a software rate limiter for this purpose.</t>

<t>Other issues with queues at lower layers are described in <xref target="CODEL"/>.</t>

</section>
<section anchor="other-forms-of-fair-queueing" title="Other Forms of Fair Queueing">

<t>Much of the scheduling portion of FQ-CoDel is derived from DRR and is
substantially similar to DRR++. Versions based on Stochastic Fair
Queueing <xref target="SFQ"/> have also been produced and tested in ns2. Other forms
of fair queueing, such as Weighted Fair Queueing <xref target="WFQ"/> or Quick Fair
Queueing <xref target="QFQ"/>, have not been thoroughly explored, but there's no a
priori reason why the round-robin scheduling of FQ-CoDel couldn't be
replaced with something else.</t>

<t>For a comprehensive discussion of fairness queueing algorithms and their
combination with AQM, see <xref target="RFC7806"/>.</t>

</section>
<section anchor="differences-between-codel-and-fq-codel-behaviour"
	 title="Differences between CoDel and FQ-CoDel Behaviour">

<t>CoDel can be applied to a single queue system as a straight AQM, where
it converges towards an "ideal" drop rate (i.e., one that minimises delay
while keeping a high link utilisation) and then optimises around that
control point.</t>

<t>The scheduling of FQ-CoDel mixes packets of competing flows, which acts
to pace bursty flows to better fill the pipe. Additionally, a new flow
gets substantial leeway over other flows until CoDel finds an ideal drop
rate for it. However, for a new flow that exceeds the configured
quantum, more time passes before all of its data is delivered (as
packets from it, too, are mixed across the other existing queue-building
flows). Thus, FQ-CoDel takes longer (as measured in time) to converge
towards an ideal drop rate for a given new flow but does so within
fewer delivered <spanx style="emph">packets</spanx> from that flow.</t>

<t>Finally, the flow isolation provided by FQ-CoDel means that the CoDel
drop mechanism operates on the flows actually building queues; this
results in packets being dropped more accurately from the largest
flows than when only CoDel is used.  Additionally, flow isolation radically improves the
transient behaviour of the network when traffic or link characteristics
change (e.g., when new flows start up or the link bandwidth changes);
while CoDel itself can take a while to respond, FQ-CoDel reacts almost
immediately.</t>

</section>
</section>
<section anchor="limitations" title="Limitations of Flow Queueing">

<t>While FQ-CoDel has been shown in many scenarios to offer significant
performance gains compared to alternative queue management strategies,
there are some scenarios where the scheduling algorithm in particular is
not a good fit. This section documents some of the known cases in which
either the default behaviour may require tweaking or alternatives
to flow queueing should be considered.</t>

<section anchor="fairness-between-things-other-than-flows" title="Fairness between Things Other Than Flows">
<t>In some parts of the network, enforcing flow-level fairness may not be
desirable, or some other form of fairness may be more important. Some
examples of this include an ISP that may be more
interested in ensuring fairness between customers than between flows or
a hosting or transit provider that wishes to ensure fairness between
connecting Autonomous Systems or networks. Another issue can be that the
number of simultaneous flows experienced at a particular link can be too
high for flow-based fairness queueing to be effective.</t>

<t>Whatever the reason, in a scenario where fairness between flows is not
desirable, reconfiguring FQ-CoDel to match on a different characteristic
can be a way forward. The implementation in Linux can leverage the
packet matching mechanism of the "tc" subsystem to use any
available packet field to partition packets into virtual queues, for
instance, to match on address or subnet source/destination pairs,
application-layer characteristics, etc.</t>

<t>Furthermore, as commonly deployed today, FQ-CoDel is used with three
or more tiers of service classification, based on Diffserv markings:
priority, best effort, and background. Some products do more detailed
classification, including deep packet inspection and
destination-specific filters to achieve their desired result.</t>

</section>
<section anchor="opaque-encap" title="Flow Bunching by Opaque Encapsulation">
<t>Where possible, FQ-CoDel will attempt to decapsulate packets before
matching on the header fields for the flow hashing. However, for some
encapsulation techniques, most notably encrypted VPNs, this is not
possible. If several flows are bunched into one such encapsulated
tunnel, they will be seen as one flow by the FQ-CoDel algorithm. This
means that they will share a queue and drop behaviour, so flows
inside the encapsulation will not benefit from the implicit
prioritisation of FQ-CoDel but will continue to benefit from the
reduced overall queue length from the CoDel algorithm operating on the
queue. In addition, when such an encapsulated bunch competes against
other flows, it will count as one flow and not assigned a share of the
bandwidth based on how many flows are inside the encapsulation.</t>

<t>Depending on the application, this may or may not be desirable
behaviour. In cases where it is not, changing FQ-CoDel's matching to not
be flow-based (as detailed in the previous subsection above) can be a
mitigation. Going forward, having some mechanism for opaque
encapsulations to express to the outer layer which flow a packet belongs
to could be a way to mitigate this. Naturally, care needs to be taken
when designing such a mechanism to ensure no new privacy and security
issues are raised by exposing information from inside the encapsulation
to the outside world. Keeping the extra information out of band and
dropping it before it hits the network could be one way to achieve this.</t>

</section>
<section anchor="low-priority-congestion-control-algorithms" title="Low-Priority Congestion Control Algorithms">

<t>In the presence of queue management schemes that limit latency under
load, low-priority congestion control algorithms such as Low Extra Delay
Background Transport (LEDBAT)
<xref target="RFC6817"/> (or, in general, algorithms that try to voluntarily use up
less than their fair share of bandwidth) experience little added
latency when the link is congested. Thus, they lack the signal to back
off that added latency previously afforded them. This effect is seen
with FQ-CoDel as well as with any effective AQM <xref target="GONG2014"/>.</t>

<t>As such, these delay-based algorithms tend to revert to loss-based
congestion control and will consume the fair share of bandwidth
afforded to them by the FQ-CoDel scheduler. However, low-priority
congestion control mechanisms may be able to take steps to continue to
be low priority, for instance, by taking into account the vastly reduced
level of delay afforded by an AQM or by using a coupled approach to
observing the behaviour of multiple flows.</t>

</section>
</section>
<section anchor="deployment-status" title="Deployment Status and Future Work">

<t>The FQ-CoDel algorithm as described in this document has been shipped as
part of the Linux kernel since version 3.5 (released on the 21st of
July, 2012), with the ce_threshold being added in version 4.2. The
algorithm has seen widespread testing in a variety of contexts and is
configured as the default queueing discipline in a number of mainline
Linux distributions (as of this writing, at least OpenWRT, Arch Linux, and
Fedora). In addition, a BSD implementation is available. All data resulting
from these trials have shown FQ-CoDel to be a massive improvement over the
previous default FIFO queue, and people are encouraged to turn it on.</t>

<t>Of course, there is always room for improvement, and this document has
listed some of the known limitations of the algorithm. As such, we
encourage further research into algorithm refinements and addressing of
limitations. One such effort has been undertaken by the bufferbloat community
in the form of the Cake queue management scheme <xref target="CAKE"/>. In addition to
this, we believe the following (non-exhaustive) list of issues to be
worthy of further enquiry:</t>

<t><list style="symbols">
  <t>Variations on the flow classification mechanism to fit different
notions of flows. For instance, an ISP might want to deploy
per-subscriber scheduling, while in other cases, several flows can
share a 5-tuple, as exemplified by the RTCWEB QoS recommendations
<xref target="WEBRTC-QOS"/>.</t>
  <t>Interactions between flow queueing and delay-based congestion control
algorithms and scavenger protocols.</t>
  <t>Other scheduling mechanisms to replace the DRR portion of the
algorithm, e.g., QFQ or WFQ.</t>
  <t>Sensitivity of parameters, most notably, the number of queues and the
CoDel parameters.</t>
</list></t>

</section>
<section anchor="security" title="Security Considerations">

<t>There are no specific security exposures associated with FQ-CoDel that
are not also present in current FIFO systems. On the contrary, some
vulnerabilities of FIFO systems are reduced with FQ-CoDel (e.g., simple
minded packet floods). However, some care is needed in the
implementation to ensure this is the case. These are included in the
description above, but we reiterate them here:</t>

<t><list style="symbols">
  <t>To prevent packets in the new queues from starving old queues, it is
important that when a queue on the list of new queues empties, it is
moved to <spanx style="emph">the end of</spanx> the list of old queues. This is described at the
end of <xref target="dequeue"/>.</t>

  <t>To prevent an attacker targeting a specific flow for a denial-of-service
  attack, the hash that maps packets to queues should not be
predictable. To achieve this, FQ-CoDel salts the hash, as described in
the beginning of <xref target="enqueue"/>. The size of the salt and the strength of
the hash function is obviously a trade-off between performance and
security. The Linux implementation uses a 32-bit random value as the
salt and a Jenkins hash function. This makes it possible to achieve
high throughput, and we consider it sufficient to ward off the most
obvious attacks.</t>
  <t>Packet fragments without a Layer 4 header can be hashed into different
bins than the first fragment with the header intact. This can cause
reordering and/or adversely affect the performance of the flow.
Keeping state to match the fragments to the beginning of the packet
or simply putting all packet fragments (including the first fragment
of each fragmented packet) into the same queue are two ways to
alleviate this.</t>
</list></t>

</section>


<section anchor="iana" title="IANA Considerations">

<t>This document does not require any IANA actions.</t>

</section>
  </middle>

  <back>

    <references title='Normative References'>


<?rfc include="reference.RFC.2119"?>
<?rfc include="reference.RFC.8174"?>

<!--draft-ietf-aqm-fq-implementation-05: I-D Now RFC 7806 -->

<?rfc include="reference.RFC.7806"?>


<!--draft-ietf-aqm-codel-03: partner doc in cluster  -->
<reference anchor='RFC8289' target="https://www.rfc-editor.org/info/rfc8289">
<front>
<title>Controlled Delay Active Queue Management</title>

<author initials='K' surname='Nichols' fullname='Kathleen Nichols'>
    <organization />
</author>

<author initials='V' surname='Jacobson' fullname='Van Jacobson'>
    <organization />
</author>

<author initials='A' surname='McGregor' fullname='Andrew McGregor' role="editor">
    <organization />
</author>

<author initials='J' surname='Iyengar' fullname='Janardhan Iyengar' role="editor">
    <organization />
</author>

<date month='December' year='2017' />

</front>

<seriesInfo name='RFC' value='8289' />
<seriesInfo name='DOI' value='10.17487/RFC8289' />
</reference>

    </references>

    <references title='Informative References'>

<?rfc include="reference.RFC.2003"?>
<?rfc include="reference.RFC.2890"?>
<?rfc include="reference.RFC.3168"?>
<?rfc include="reference.RFC.4213"?>
<?rfc include="reference.RFC.6817"?>

<!-- draft-ietf-tcpm-dctcp-01: I-D Updated to RFC 8257 -->
<?rfc include="reference.RFC.8257"?>


<!--draft-ietf-tsvwg-rtcweb-qos-15: I-D Version Updated to -18 -->

<reference anchor='WEBRTC-QOS'>
<front>
<title>DSCP Packet Markings for WebRTC QoS</title>

<author initials='P' surname='Jones' fullname='Paul Jones'>
    <organization />
</author>

<author initials='S' surname='Dhesikan' fullname='Subha Dhesikan'>
    <organization />
</author>

<author initials='C' surname='Jennings' fullname='Cullen Jennings'>
    <organization />
</author>

<author initials='D' surname='Druta' fullname='Dan Druta'>
    <organization />
</author>

<date month='August' year='2016' />

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-tsvwg-rtcweb-qos-18' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-tsvwg-rtcweb-qos-18.txt' />
</reference>




<reference anchor="BLOAT">
  <front>
    <title>Bufferbloat: Dark Buffers in the Internet</title>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization></organization>
    </author>
    <author initials="K." surname="Nichols" fullname="Kathleen Nichols"> 
    <organization></organization> 
    </author> 
    <date month="January" year="2012"/>
  </front>
  <seriesInfo name="Communications of the ACM," value="Volume 55, Issue 1"/>
  <seriesInfo name="DOI" value="10.1145/2063176.2063196"/>
</reference>

<reference anchor="CAKE" target="http://www.bufferbloat.net/projects/codel/wiki/Cake">
  <front>
    <title>Cake - Common Applications Kept Enhanced</title>
    <author >
      <organization></organization>
    </author>
    <date year=""/>
  </front>
</reference>

<reference anchor="BLOATWEB" target="https://www.bufferbloat.net">
  <front>
    <title>Bufferbloat</title>
    <author >
      <organization></organization>
    </author>
    <date year=""/>
  </front>
</reference>

<reference anchor="NS2" target="http://nsnam.sourceforge.net/wiki/index.php?title=Main_Page&amp;oldid=8076">
  <front>
    <title>ns-2</title>
    <author >
      <organization></organization>
    </author>
    <date month="December" year="2014"/>
  </front>
</reference>

<reference anchor="NS3" target="https://www.nsnam.org/mediawiki/index.php?title=Main_Page&amp;oldid=9883">
  <front>
    <title>ns-3</title>
    <author >
      <organization></organization>
    </author>
    <date month="February" year="2016"/>
  </front>
</reference>

<reference anchor="LINUXSRC" target="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/net/sched/sch_fq_codel.c">
  <front>
    <title>Linux Kernel Source Tree</title>
    <author >
      <organization></organization>
    </author>
    <date year=""/>
  </front>
</reference>

<reference anchor="BQL" target="https://lwn.net/Articles/454378/">
  <front>
    <title>bql: Byte Queue Limits</title>
    <author initials="T." surname="Herbert" fullname="Tom Herbert">
      <organization></organization>
    </author>
    <date year="2011" month="August"/>
  </front>
</reference>

<reference anchor="HTB" target="https://en.wikipedia.org/w/index.php?title=Token_bucket&amp;oldid=803574657">
  <front>
    <title>Token Bucket: Variations</title>
    <author >
      <organization>Wikipedia</organization>
    </author>
    <date month="October" year="2017"/>
  </front>
</reference>

<reference anchor="HFSC" target="http://conferences.sigcomm.org/sigcomm/1997/papers/p011.pdf">
  <front>
    <title>A Hierarchical Fair Service Curve Algorithm for Link-Sharing,
    Real-Time and Priority Services</title>
    <author initials="I." surname="Stoica" fullname="Ion Stoica">
      <organization></organization>
    </author>
    <author initials="H." surname="Zhang" fullname="Hui Zhang">
      <organization></organization>
    </author>
    <author initials="T.S." surname="Eugene Ng" fullname="T. S. Eugene Ng">
      <organization></organization>
    </author>
    <date month="September" year="1997"/>
  </front>
  <seriesInfo name="Proceedings" value="of ACM SIGCOMM"/>
<seriesInfo name='DOI' value='10.1145/263105.263175' />

</reference>

<reference anchor="DRR">
  <front>
    <title>Efficient Fair Queueing Using Deficit Round Robin</title>
    <author initials="M." surname="Shreedhar" fullname="M. Shreedhar">
      <organization></organization>
    </author>
    <author initials="G." surname="Varghese" fullname="George Varghese">
      <organization></organization>
    </author>
    <date year="1996" month="June"/>
  </front>
  <seriesInfo name="IEEE/ACM Transactions on Networking," value="Volume 4,
								Issue 3"/>
  <seriesInfo name="DOI" value="10.1109/90.502236"/>
</reference>

<reference anchor="DRRPP" target="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=875803">
  <front>
    <title>Deficits for Bursty Latency-Critical Flows: DRR++</title>
    <author initials="M.H." surname="MacGregor">
      <organization></organization>
    </author>
    <author initials="W." surname="Shi">
      <organization></organization>
    </author>
    <date month="September" year="2000"/>
  </front>
  <seriesInfo name="Proceedings" value="of the IEEE International
			       Conference on Networks 2000 (ICON 2000)"/>
  <seriesInfo name="DOI" value="10.1109/ICON.2000.875803"/>
</reference>

<reference anchor="SQF">
  <front>
    <title>On the Impact of TCP and Per-Flow Scheduling on Internet Performance</title>
    <author initials="G." surname="Carofiglio" fullname="G. Carofiglio">
      <organization>Telecom ParisTech</organization>
    </author>
    <author initials="L." surname="Muscariello" fullname="Luca Muscariello">
      <organization>Orange Labs</organization>
    </author>
    <date year="2011" month="August"/>
  </front>
  <seriesInfo name="IEEE/ACM Transactions on Networking," value="Volume 20,
								 Issue 2"/>
  <seriesInfo name="DOI" value="10.1109/TNET.2011.2164553"/>
</reference>

<reference anchor="CODEL" target="http://queue.acm.org/detail.cfm?id=2209336">
  <front>
    <title>Controlling Queue Delay</title>
    <author initials="K." surname="Nichols" fullname="Kathleen Nichols">
      <organization></organization>
    </author>
    <author initials="V." surname="Jacobson" fullname="Van Jacobson">
      <organization>Google, Inc</organization>
    </author>
    <date year="2012" month="May"/>
  </front>
<seriesInfo name="ACM Queue," value="Volume 10, Issue 5"/>
<seriesInfo name="DOI" value="10.1145/2208917.2209336"/>
</reference>


<reference anchor="GONG2014" target="https://www.sciencedirect.com/science/article/pii/S1389128614000188">
  <front>
    <title>Fighting the bufferbloat: On the coexistence of AQM and low priority congestion control</title>
    <author initials="Y." surname="Gong" fullname="Yixi Gong">
      <organization>Telecom ParisTech</organization>
    </author>
    <author initials="D." surname="Rossi" fullname="Dario Rossi">
      <organization>Telecom ParisTech</organization>
    </author>
    <author initials="C." surname="Testa" fullname="Claudio Testa">
      <organization>Telecom ParisTech</organization>
    </author>
    <author initials="S." surname="Valenti" fullname="Silvio Valenti">
      <organization>Telecom ParisTech</organization>
    </author>
    <author initials="D." surname="Taht" fullname="Dave Taht">
      <organization>TekLibre</organization>
    </author>
    <date year="2014" month="June"/>
  </front>
  <seriesInfo name="Elsevier Computer Networks," value="Volume 65"/>
  <seriesInfo name="DOI" value="10.1016/j.bjp.2014.01.009"/>
</reference>

<reference anchor="JENKINS" target="http://www.burtleburtle.net/bob/hash/doobs.html">
  <front>
    <title>A Hash Function for Hash Table Lookup</title>
    <author initials="B." surname="Jenkins" fullname="Bob Jenkins">
      <organization></organization>
    </author>
    <date />
  </front>
</reference>

<reference anchor="SFQ" target="http://perso.telecom-paristech.fr/~bonald/Publications_files/BMO2011.pdf">
  <front>
    <title>Stochastic Fairness Queueing</title>
    <author initials="P." surname="McKenney" fullname="Paul McKenney">
      <organization></organization>
    </author>
    <date month="June" year="1990"/>
  </front>
    <seriesInfo name="Proceedings of IEEE" value="INFOCOM"/>
    <seriesInfo name="DOI" value="10.1109/INFCOM.1990.91316"/>
</reference>

<reference anchor="QFQ" target="http://dl.acm.org/citation.cfm?id=2525552">
  <front>
    <title>QFQ: Efficient Packet Scheduling with Tight Guarantees</title>
    <author initials="F." surname="Checconi" fullname="Fabio Checconi">
      <organization></organization>
    </author>
    <author initials="L." surname="Rizzo" fullname="Luigi Rizzo">
      <organization></organization>
    </author>
    <author initials="P." surname="Valente" fullname="Paolo Valente">
      <organization></organization>
    </author>
    <date month="June" year="2013"/>
  </front>
  <seriesInfo name="IEEE/ACM Transactions on Networking (TON)," value="Volume
								      21,
								      Issue
								      3, pp. 802-816"/>
  <seriesInfo name="DOI" value="10.1109/TNET.2012.2215881"/>
</reference>

<reference anchor="WFQ" target="http://doi.acm.org/10.1145/75247.75248">
  <front>
    <title>Analysis and Simulation of a Fair Queueing Algorithm</title>
    <author initials="A." surname="Demers" fullname="A. Demers">
      <organization></organization>
    </author>
    <author initials="S." surname="Keshav" fullname="S. Keshav">
      <organization></organization>
    </author>
    <author initials="S." surname="Shenker" fullname="S. Shenker">
      <organization></organization>
    </author>
    <date year="1989" month="September"/>
  </front>
  <seriesInfo name="ACM SIGCOMM Computer Communication Review," value="Volume
								       19,
								       Issue
								       4, pp. 1-12"/>
<seriesInfo name="DOI" value="10.1145/75247.75248"/>
</reference>


    </references>

<section anchor="acknowledgements" title="Acknowledgements" numbered="no">
<t>Our deepest thanks to Kathie Nichols, Van Jacobson, and all the members of
the bufferbloat.net effort for all the help on developing and testing the
algorithm. In addition, our thanks to Anil Agarwal for his help with getting
the hash collision probabilities in this document right.</t>
</section>


  </back>
</rfc>

