<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
	<!ENTITY rfc2119 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
	<!ENTITY rfc5216 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5216.xml'>
	<!ENTITY rfc3748 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3748.xml'>
	<!ENTITY rfc4634 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4634.xml'>
	<!ENTITY rfc4282 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4282.xml'>
	<!ENTITY rfc4086 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4086.xml'>
	<!ENTITY rfc5226 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml'>
	<!ENTITY rfc2759 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2759.xml'>
	<!ENTITY rfc3454 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3454.xml'>
	<!ENTITY rfc4017 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4017.xml'>
	<!ENTITY rfc2409 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2409.xml'>
	<!ENTITY rfc4962 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4962.xml'>
	<!ENTITY rfc5869 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5869.xml'>
	<!ENTITY rfc5114 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5114.xml'>
	<!ENTITY rfc3766 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3766.xml'>
	<!ENTITY eapkey PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5247.xml'>
	<!ENTITY rfc4013 PUBLIC '' 
		'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4013.xml'>
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc rfcedstyle="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc number="5931" category="info" ipr="pre5378Trust200902">

	<!-- ***** FRONT MATTER ***** -->
	<front>

		<title abbrev="EAP Password">Extensible Authentication Protocol (EAP) Authentication Using&nbsp;Only&nbsp;a&nbsp;Password</title>

		<author fullname="Dan Harkins" initials="D.H." surname="Harkins">
			<organization>Aruba Networks</organization>
			<address>
				<postal>
					<street>1322 Crossman Avenue</street>
					<city>Sunnyvale</city>
					<region>CA</region>
					<code>94089-1113</code>
					<country>USA</country>
				</postal>
				<email>dharkins@arubanetworks.com</email>
			</address>
		</author>
		<author fullname="Glen Zorn" initials="G.Z." surname="Zorn">
			<organization>Network Zen</organization>
			<address>
				<postal>
					<street>1310 East Thomas Street</street>
					<street>#306</street>
					<city>Seattle</city>
					<region>WA</region>
					<code>98102</code>
					<country>USA</country>
				</postal>
				<phone>+1 (206) 377-9035</phone>
				<email>gwz@net-zen.net</email>
			</address>
		</author>
		<date month="August" year="2010"/>

		<keyword>Password Authenticated Key Exchange, Dictionary Attack, Authentication EAP</keyword>

		<abstract>
			<t>
      This memo describes an Extensible Authentication Protocol (EAP) method, EAP-pwd, which uses
      a shared password for authentication. The password may be a low-entropy one and may be drawn
      from some set of possible passwords, like a dictionary, which is
      available to an attacker. The underlying key exchange is resistant to active attack,
      passive attack, and dictionary attack.

      </t>
		</abstract>
	</front>
	<middle>
		<section title="Introduction">
			<section title="Background">
				<t>
       The predominant access method for the Internet today is that of a human using a username
       and password to authenticate to a computer enforcing access control. Proof of
       knowledge of the password authenticates the human and computer. 
       </t>
				<t>
       Typically these passwords are not stored on a user's computer for security reasons
       and must be entered each time the human desires network access. Therefore, the passwords
       must be ones that can be repeatedly entered by a human with a low probability of error.
       They will likely not possess high-entropy, and it may be assumed that an adversary with access
       to a dictionary will have the ability to guess a user's password. It is therefore
       desirable to have a robust authentication method that is secure even when used with
       a weak password in the presence of a strong adversary.
       </t>
				<t>
       EAP-pwd is an EAP method that addresses the problem of password-based authenticated
       key exchange -- using a possibly weak password for authentication to derive
       an authenticated and cryptographically strong shared secret. This problem
       was first described by Bellovin and Merritt in <xref target="BM92"/> and
       <xref target="BM93"/>. There have been a number of subsequent suggestions
       (<xref target="JAB96"/>, <xref target="LUC97"/>,
       <xref target="BMP00"/>, and others) for password-based authenticated
       key exchanges.
       </t>
	</section>
	<section title="Keyword Definitions">
  	  <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
             "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
              document are to be interpreted as described in <xref target="RFC2119">RFC 2119</xref>.</t>
	</section>
	<section anchor="requirements" title="Requirements">
	<t>
        Any protocol that claims to solve the problem of password-authenticated key
        exchange must be resistant to active, passive, and dictionary attack and have the quality of
	forward secrecy.  These characteristics are discussed further in the following sections.
	</t>
	<section title="Resistance to Passive Attack">
	<t>
	    A passive, or benign, attacker is one that merely relays messages back and
	    forth between the peer and server, faithfully, and without modification. 
	    The contents of the messages are available for inspection, but that is all.
	    To achieve resistance to passive attack, such an attacker must not be able
	    to obtain any information about
	    the password or anything about the resulting shared secret from watching
	    repeated runs of the protocol. Even if a passive attacker is able to learn
	    the password, she will not be able to determine any information about the
	    resulting secret shared by the peer and server.
	 </t>
	</section>
	<section title="Resistance to Active Attack">
	<t>
	  An active attacker is able to modify, add, delete, and replay messages sent
	  between protocol participants. For this protocol to be resistant to active attack,
	  the attacker must not be able to obtain any information about the password or
	  the shared secret by using any of its capabilities. In addition, the
	  attacker must not be able to fool a protocol participant into thinking that
	  the protocol completed successfully.
	  </t>
	<t>
	  It is always possible for an active attacker to deny delivery of a message 
	  critical in completing the exchange. This is no different than dropping all
	  messages and is not an attack against the protocol.
	  </t>
	</section>
	<section title="Resistance to Dictionary Attack">
	<t>
	  For this protocol to be resistant to dictionary attack, any advantage an adversary
	  can gain must be directly related to the number of interactions she makes with
	  an honest protocol participant and not through computation. The adversary will
	  not be able to obtain any information about the password except whether a single
	  guess from a single protocol run is correct or incorrect.
	  </t>
	</section>
	<section title="Forward Secrecy">
	<t>
	  Compromise of the password must not provide any information about the secrets
	  generated by earlier runs of the protocol.
	  </t>
	</section>
	</section>
	</section>
	<section title="Specification of EAP-pwd">
	<section anchor="notation" title="Notation">
				<t>
	The following notation is used in this memo:<list hangIndent="4" style="hanging">
		<t hangText="peer-ID">
 		  <vspace blankLines="0"/>The peer's identity, the peer NAI <xref target="RFC4282"/>. </t>
		<t hangText="server-ID">
			<vspace blankLines="0"/>A string that identifies the server to the peer. </t>
		<t hangText="password">
			<vspace blankLines="0"/>The password shared between the peer and server.  </t>
		<t hangText="y = H(x)">
			<vspace blankLines="0"/>The binary string x is given to a function H, which
				 produces a fixed-length output y. </t>
		<t hangText="a | b">
			<vspace blankLines="0"/> The concatenation of string a with string b. </t>
		<t hangText="[a]b">
			<vspace blankLines="0"/>  A string consisting of the single bit "a" 
				 repeated "b" times.</t>
		<t hangText="x mod y">
			<vspace blankLines="0"/>  The remainder of division of x by y. The
				result will be between 0 and y.</t>
		<t hangText="g^x mod p">
			<vspace blankLines="0"/> The multiplication of the value "g" with itself "x"
				times, modulo the value "p". </t>
		<t hangText="inv(Q)">
			<vspace blankLines="0"/>  The inverse of an element, Q, from a finite field. </t>
		<t hangText="len(x)">
			<vspace blankLines="0"/>  The length in bits of the string x. </t>
		<t hangText="chop(x, y)">
			<vspace blankLines="0"/> The reduction of string x, being at least y bits in length,
				 to y bits. </t>
		<t hangText="PRF(x,y)">
			<vspace blankLines="0"/> A pseudo-random
			   function that takes a
			   key, x, and variable-length data, y, and produces a fixed-length
			   output that cannot be distinguished (with a significant advantage)
			   from a random source. </t>
		<t hangText="LSB(x)">
			<vspace blankLines="0"/> Returns the least-significant bit of the bitstring "x".</t>
		<t hangText="Ciphersuite">
			<vspace blankLines="0"/> An encoding of a group
			      to use with EAP-pwd, the definition of function H, and a PRF, in that order. </t>
		<t hangText="MK">
			<vspace blankLines="0"/>The Master Key is generated by EAP-pwd. This is a
				high-entropy secret whose length depends on the random function used. </t>
		<t hangText="MSK">
			<vspace blankLines="0"/>The Master Session Key exported by EAP-pwd. This is a
				high-entropy secret 512 bits in length. </t>
		<t hangText="EMSK">
			<vspace blankLines="0"/>The Extended Master Session Key exported by
			      EAP-pwd. This is a high-entropy secret 512 bits in length. </t>
	</list>
	</t>
	</section>
	<section title="Discrete Logarithm Cryptography">
	<t>
	This protocol uses discrete logarithm cryptography to achieve authentication and
	key agreement (see <xref target="SP800-56A"/>). Each party to the exchange derives
	ephemeral keys with respect to a particular set of domain parameters
	(referred to here as a "group"). A group can be
	based on Finite Field Cryptography (FFC) or Elliptic Curve Cryptography (ECC).
	</t>
	<section title="Finite Field Cryptography" anchor="f_f_c">
	<t>
	  Domain parameters for the FFC groups used by EAP-pwd include:
	  <list style="symbols">
	    <t>A prime, p, determining a prime field GF(p), the integers modulo p.
	       The FFC group will be a subgroup of GF(p)*, the multiplicative group
	       of non-zero elements in GF(p). The group operation for FFC groups is
	       multiplication modulo p.
	    </t>
	    <t>An element, G, in GF(p)* which serves as a generator for the FFC group.
	       G is chosen such that its multiplicative order is a sufficiently large
	       prime divisor of ((p-1)/2).
	    </t>
	    <t>A prime, r, which is the multiplicative order of G, and thus also the
	       size of the cryptographic subgroup of GF(p)* that is generated by G.
	    </t>
	  </list>
	</t>
	<t>
	  An integer scalar, x, acts on an FFC group element, Y, via exponentiation
	  modulo p -- Y^x mod p.
	</t>
	<t>
	  The inverse function for an FFC group is defined such that the product of
	  an element and its inverse modulo the group prime equals one (1). In
	  other words,
	  <list hangIndent="4" style="empty">
	    <t>
	    (q * inv(q)) mod p = 1
	    </t>
	  </list>
	</t>
	<t>
	  EAP-pwd uses an IANA registry for the definition of groups. Some FFC groups
	  in this registry are based on safe primes and the order is not included in the domain
	  parameters. In this
	  case only, the order, r, MUST be computed as the prime minus one divided by two -- (p-1)/2.
	  If the definition of the group includes an order in its domain parameters, that value MUST be
	  used in this exchange when
	  an order is called for. If an FFC group definition does not have an order in its domain
	  parameters and it is not based on a safe prime, it MUST NOT be used with EAP-pwd.
	</t>
	</section>
	<section anchor="ec_definition" title="Elliptic Curve Cryptography">
	<t>
	  Domain parameters for the ECC groups used by EAP-pwd include:
	  <list style="symbols">
	    <t>A prime, p, determining a prime field GF(p). The cryptographic group will be a
	       subgroup of the full elliptic curve group that consists
	       of points on an elliptic
	       curve -- elements from GF(p) that satisfy the curve's equation -- together with
	       the "point at infinity" that serves as the identity element. The group operation
	       for ECC groups is addition of points on the elliptic curve.
	    </t>
	    <t>Elements a and b from GF(p) that define the curve's
	       equation. The point (x, y)
	       in GF(p) x GF(p) is on the elliptic curve if and only if (y^2 - x^3 - a*x - b) mod p
	       equals zero (0).
	    </t>
	    <t>A point, G, on the elliptic curve, which serves as a generator for the ECC group.
	       G is chosen such that its order, with respect to elliptic curve addition, is a
	       sufficiently large prime.
	    </t>
	    <t>A prime, r, which is the order of G, and thus is also the size of the cryptographic
	       subgroup that is generated by G.
	    </t>
	    <t>A co-factor, f, defined by the requirement that the size of the full elliptic
	      curve group (including the "point at infinity") is the product of f and r.
	    </t>
	  </list>
	</t>
	<t>
	  An integer scalar, x, acts on an ECC group element, Y, via repetitive addition (Y
	  is added to itself x times), also called point multiplication -- x * Y.
	</t>
	<t>
	  The inverse function for an ECC group is defined such that the sum of
	  an element and its inverse is the "point at infinity" (the identity for elliptic
	  curve point addition). In other words,
	  <list hangIndent="4" style="empty">
	    <t>
	    Q + inv(Q) = "O"
	    </t>
	  </list>
	</t>
	<t>
	  Only ECC groups over GF(p) can be used by EAP-pwd. ECC groups over GF(2^m)
          SHALL NOT be used by EAP-pwd. While such groups exist in the
	  IANA registry used by EAP-pwd, their use in EAP-pwd is not defined. In addition,
	  ECC groups with a co-factor greater than one (1) SHALL NOT be used by EAP-pwd.
	  At the time of publication, no such groups existed in the IANA registry used
	  by EAP-pwd.
	  </t>
	</section>
	</section>
	<section anchor="assumptions" title="Assumptions">
	<t>
	In order to see how the protocol addresses the requirements above (see
	<xref target="requirements"/>), it is necessary to
	state some assumptions under which the protocol can be evaluated. They are:
	<list hangIndent="4" style="numbers">
	  <t>Function H maps a binary string of indeterminate length onto a fixed binary
	    string that is x bits in length.
	    <list hangIndent="4" style="empty">
		<t>H: {0,1}^* --> {0,1}^x</t>
	    </list>
	  </t>
	  <t>Function H is a "random oracle" (see <xref target="RANDOR"/>). Given
	    knowledge of the input to H, an adversary is unable to distinguish the output
	    of H from a random data source.
	  </t>
	  <t>Function H is a one-way function. Given the output of H, it is computationally
	    infeasible for an adversary to determine the input.
	  </t>
	  <t>For any given input to function H, each of the 2^x possible outputs are
	    equally probable.
	  </t>
	  <t>The discrete logarithm problem for the chosen group is hard.
	    That is, given g, p, and y = g^x mod p, it is computationally infeasible to
	    determine x. Similarly, for an ECC group given the curve definition,
	    a generator G, and Y = x * G, it is computationally infeasible to determine x.
	  </t>
	  <t>There exists a pool of passwords from which the password shared by the peer
	    and server is drawn. This pool can consist of words from a dictionary, for
	    example. Each password in this pool has an equal probability
	    of being the shared password. All potential attackers have access to this
	    pool of passwords.
	  </t>
	</list>
	</t>
	</section>
	<section anchor="function_h" title="Instantiating the Random Function">
	<t>
	The protocol described in this memo uses a random function, H. &nbsp;As noted in
	<xref target="assumptions"/>, this is a "random oracle" as defined in
	<xref target="RANDOR"/>. 
	At first glance, one may view this as a hash function.
	As noted in <xref target="RANDOR"/>, though, hash functions are too structured
	to be used directly as a random oracle. But they can be used to instantiate
	the random oracle. 
	</t>
	<t>
	The random function, H, in this memo is instantiated by HMAC-SHA256 
	(see <xref target="RFC4634"/>) with a key whose length is 32 octets and whose
	value is zero. In other words,
	<list hangIndent="4" style="empty">
		<t>H(x) = HMAC-SHA-256([0]32, x)</t>
	</list>
	</t>
	</section>
	<section anchor="kdf" title="Key Derivation Function">
	<t>
	The keys output by this protocol, MSK and EMSK, are each 512 bits in length.
	The shared secret that results from the successful termination of this protocol
	is only 256 bits. Therefore, it is necessary to stretch the shared secret using a
	key derivation function (KDF).
	</t>
	<t>
	The KDF used in this protocol has a counter-mode with feedback construction using a
	generic pseudo-random function (PRF), according to <xref target="SP800-108"/>. The
	specific value of the PRF is specified along with the random function and
	group when the server sends the first EAP-pwd packet to the peer.
	</t>
	<t>
	The KDF takes a key to stretch, a label to bind into the key, and an indication
	of the desired length of the output in bits. It uses two internal variables, i and L,
	each of which is 16 bits in length and is represented in network order.
	Algorithmically, it is:
	<figure anchor="Key_Derivation_Function" title="Key Derivation Function">
						<artwork align="center"><![CDATA[
KDF(key, label, length) {
  i = 1
  L = length
  K(1) = PRF(key, i | label | L)
  res = K(1)
  while (len(res) < length)
  do
    i = i + 1
    K(i) = PRF(key, K(i-1) | i | label | L)
    res = res | K(i)
  done
  return chop(res, length)
}
    ]]></artwork>
	</figure>
	</t>
	</section>
	<section title="Random Numbers">
	<t>
        The security of EAP-pwd relies upon each side, the peer and server, producing
	quality secret random numbers. A poor random number chosen by either side in a
	single exchange can compromise the shared secret from that exchange and open
	up the possibility of dictionary attack.
	</t>
	<t>
	Producing quality random numbers without specialized hardware entails
	using a cryptographic mixing function (like a strong hash function) to
	distill entropy from multiple, uncorrelated sources of information and events.
	A very good discussion of this can be found in <xref target="RFC4086"/>.
	</t>
	</section>
	<section anchor="textproc" title="Representation and Processing of Input Strings">
	<section anchor="rep_id" title="Identity Strings">
	<t>
	The strings representing the server identity and peer identity MUST follow
	the requirements of <xref target="RFC4282"/> for Network Access Identifiers.
	This ensures a canonical representation of identities by both ends of the
	conversation prior to their use in EAP-pwd.
	</t>
	</section>
	<section anchor="rep_pwd" title="Passwords">
	<t>
	EAP-pwd requires passwords be input as binary strings. For the protocol to
	successfully terminate, each side must produce identical binary strings from
	the password. This imposes processing
	requirements on a password prior to its use.
	</t>
	<t>
	Three techniques for password pre-processing exist for EAP-pwd:
	<list hangIndent="4" style="symbols">
	  <t>
	    None: The input password string SHALL be treated as an ASCII string 
	    or a hexadecimal string with no treatment or normalization performed.
	    The output SHALL be the binary representation of the input string.
	  </t>
	  <t>
	    RFC 2759: The input password string SHALL be processed to produce the output
	    PasswordHashHash, as defined in <xref target="RFC2759"/>, including any
	    approved errata to <xref target="RFC2759"/>. This technique
	    is useful when the server does not have access to the plaintext password.
	  </t>
	  <t>
	    SASLprep: The input password string is processed according to the rules
	    of the <xref target="RFC4013"/> profile of <xref target="RFC3454"/>.
	    A password SHALL be considered a "stored string" per <xref target="RFC3454"/>,
	    and unassigned code points are therefore prohibited.
	    The output SHALL be the binary representation of the processed UTF-8 character
	    string. Prohibited output and unassigned codepoints encountered in SASLprep
	    pre-processing SHALL cause a failure of pre-processing, and the output
	    SHALL NOT be used with EAP-pwd.
	  </t>
	</list>
	</t>
	<t>
	Changing a password is out of scope of EAP-pwd, but due to the ambiguities in the
	way internationalized character strings are handled, 1) it SHOULD be done using
	SASLprep to ensure a canonical representation of the new password is stored on the
	server, and 2) subsequent invocations of EAP-pwd SHOULD use SASLprep to ensure that
	the client generates an identical binary string from the input password.
	</t>
	</section>
	</section>
	<section anchor="protocol" title="Protocol">
	<section anchor="overview" title="Overview">
	  <t>EAP is a two-party protocol spoken between an EAP peer and an authenticator.
	  For scaling purposes, the functionality of the authenticator that speaks EAP
	  is frequently broken out into a stand-alone EAP server. In this case, the EAP peer 
	  communicates with an EAP server through the authenticator, with the authenticator
	  merely being a passthrough.
	  </t>
	  <t>
	  An EAP method defines the specific authentication protocol being used by EAP. This
	  memo defines a particular method and therefore defines the messages sent between
	  the EAP server (or the "EAP server" functionality in an authenticator if it is
	  not broken out) and the EAP peer for the purposes of authentication and key derivation.
	  </t>
	</section>
	<section anchor="message_flows" title="Message Flows">
	  <t>
	  EAP-pwd defines three message exchanges: an Identity exchange, a Commit exchange,
	  and a Confirm exchange. A successful authentication is shown in
	  <xref target="successful_auth"/>.
	  </t>
	  <t>
	  The peer and server use the Identity exchange to discover each other's identities
	  and to agree upon a Ciphersuite to use in the subsequent exchanges;
	  in addition, the EAP Server uses the EAP-pwd-ID/Request message to inform the 
	  client of any password pre-processing that may be required. 
	  In the Commit
	  exchange, the peer and server exchange information to generate a shared key and
	  also to bind each other to a particular guess of the password. In the Confirm
	  exchange, the peer and server prove liveness and knowledge of the password by
	  generating and verifying verification data.
	  </t>
	  <figure anchor="successful_auth" title="A Successful EAP-pwd Exchange">
		<artwork align="center"><![CDATA[
   +--------+                                     +--------+
   |        |                  EAP-pwd-ID/Request |        |
   |  EAP   |<------------------------------------|  EAP   |
   |  peer  |                                     | server |
   |        | EAP-pwd-ID/Response                 |        |
   |        |------------------------------------>|        |
   |        |                                     |        |
   |        |              EAP-pwd-Commit/Request |        |
   |        |<------------------------------------|        |
   |        |                                     |        |
   |        | EAP-pwd-Commit/Response             |        |
   |        |------------------------------------>|        |
   |        |                                     |        |
   |        |             EAP-pwd-Confirm/Request |        |
   |        |<------------------------------------|        |
   |        |                                     |        |
   |        | EAP-pwd-Confirm/Response            |        |
   |        |------------------------------------>|        |
   |        |                                     |        |
   |        |          EAP-Success                |        |
   |        |<------------------------------------|        |
   +--------+                                     +--------+
  ]]></artwork>
	</figure>
	<t>
	  The components of the EAP-pwd-* messages are as follows:
	    <list hangIndent="4" style="hanging">
		<t hangText="EAP-pwd-ID/Request">
			<vspace blankLines="0"/> Ciphersuite, Token, 
					Password Processing Method, Server_ID</t>
		<t hangText="EAP-pwd-ID/Response">
			<vspace blankLines="0"/> Ciphersuite, Token, 
					Password Processing Method, Peer_ID</t>
		<t hangText="EAP-pwd-Commit/Request">
			<vspace blankLines="0"/> Scalar_S, Element_S</t>
		<t hangText="EAP-pwd-Commit/Response">
			<vspace blankLines="0"/> Scalar_P, Element_P</t>
		<t hangText="EAP-pwd-Confirm/Request">
			<vspace blankLines="0"/> Confirm_S</t>
		<t hangText="EAP-pwd-Confirm/Response">
			<vspace blankLines="0"/> Confirm_P</t>
	</list>
	</t>
	</section>
	<section anchor="fixing_pwe" title="Fixing the Password Element">
	  <t>
	  Once the EAP-pwd-ID exchange is completed, the peer and server use each
	  other's identities and the agreed upon ciphersuite to fix an element in the
	  negotiated group called the Password Element (PWE or pwe, for an element in
	  an ECC group or an FFC group, respectively). The resulting 
	  element must be selected in a deterministic fashion using the password but
	  must result in selection of an element that will not leak any 
	  information about the password to an attacker. 


	  From the point
	  of view of an
	  attacker who does not know the password, the Password Element will be a
	  random element in the negotiated group.
	  </t>
	  <t>
	  To properly fix the Password Element, both parties must have a common view
	  of the string "password". Therefore, if a password pre-processing algorithm was
	  negotiated during the EAP-pwd-ID exchange, the client MUST perform the specified
	  password pre-processing prior to fixing the Password Element.
	  </t>

	  <t>
	  Fixing the Password Element involves an iterative hunting-and-pecking
	  technique using the prime from the negotiated group's domain parameter set
	  and an ECC- or FFC-specific operation depending on the negotiated group.
	  </t>
	  <t>First, an 8-bit counter is set to the value one (1).  Then, the agreed-upon random function is used to generate a password seed from the identities
	    and the anti-clogging token from the EAP-pwd-ID exchange (see
	    <xref target="id-exchange"/>):
	    <list hangIndent="2" style="empty">
		<t>pwd-seed = H(token | peer-ID | server-ID | password | counter)</t>
	    </list>
	  </t>
	  <t>Then, the pwd-seed is expanded using the KDF from the agreed-upon Ciphersuite
	     out to the length of the prime:
	     <list hangIndent="2" style="empty">
		<t>pwd-value = KDF(pwd-seed, "EAP-pwd Hunting And Pecking", len(p))</t>
	     </list>
	  </t>
	  <t>
	    If the pwd-value is greater than or equal to the prime, p, the counter is
	    incremented, and a new pwd-seed is generated and the hunting-and-pecking
	    continues. If pwd-value is less than the prime, p, it is passed to the
	    group-specific operation which either returns the selected Password Element
	    or fails. 
	    If the
	    group-specific operation fails, the counter is incremented, a new pwd-seed
	    is generated, and the hunting-and-pecking continues. This process 
	    continues until the group-specific operation returns the Password Element.
	  </t>
	<section title="ECC Operation for PWE">
	  <t>
	    The group-specific operation for ECC groups uses
	    pwd-value, pwd-seed, and the equation for the curve to
	    produce the Password Element. First, pwd-value is used
	    directly as the x-coordinate, x, with the equation for the
	    elliptic curve, with parameters a and b from the domain
	    parameter set of the curve, to solve for a y-coordinate,
	    y.  If there is no solution to the quadratic equation,
	    this operation fails and the hunting-and-pecking process
	    continues.  If a solution is found, then an ambiguity
	    exists as there are technically two solutions to the
	    equation and pwd-seed is used to unambiguously select one
	    of them. If the low-order bit of pwd-seed is equal to the
	    low-order bit of y, then a candidate PWE is defined as the
	    point (x,&nbsp;y); if the low-order bit of pwd-seed
	    differs from the low-order bit of y, then a candidate PWE
	    is defined as the point (x, p - y), where p is the prime
	    over which the curve is defined. The candidate PWE becomes
	    PWE, and the hunting and pecking terminates successfully.
	    </t>
	    <t>
	    Algorithmically, the process looks like this:
	    <figure anchor="Fixing_ECC_PWE" title="Fixing PWE for ECC Groups">
		<artwork align="center"><![CDATA[
  found = 0
  counter = 1
  do {
    pwd-seed = H(token | peer-ID | server-ID | password | counter)
    pwd-value = KDF(pwd-seed, "EAP-pwd Hunting And Pecking", len(p))
    if (pwd-value < p) 
    then
      x = pwd-value
      if ( (y = sqrt(x^3 + ax + b)) != FAIL)
      then
        if (LSB(y) == LSB(pwd-seed))
        then
          PWE = (x, y)
        else
          PWE = (x, p-y)
        fi		        
        found = 1
      fi
    fi
    counter = counter + 1
  } while (found == 0)
	      ]]></artwork>
	      </figure>
		</t>
	</section>
	<section title="FFC Operation for pwe">
	<t>
	  The group-specific operation for FFC groups takes pwd-value, and the prime, p,
	  and order, r, from the group's domain parameter set (see <xref target="f_f_c"/> when
	  the order is not part of the defined domain parameter set) to directly produce a
	  candidate Password Element, pwe,
	  by exponentiating the pwd-value to the value ((p-1)/r) modulo the prime.
	  If the result is greater than one (1), the candidate pwe becomes
	  pwe, and the hunting and pecking terminates successfully.
	</t>
	    <t>
	    Algorithmically, the process looks like this:
	    <figure anchor="Fixing_FFC_PWE" title="Fixing PWE for FFC Groups">
		<artwork align="center"><![CDATA[
  found = 0
  counter = 1
  do {
    pwd-seed = H(token | peer-ID | server-ID | password | counter)
    pwd-value = KDF(pwd-seed, "EAP-pwd Hunting And Pecking", len(p))
    if (pwd-value < p) 
    then
      pwe = pwd-value ^ ((p-1)/r) mod p
      if (pwe > 1)
      then
        found = 1
      fi
    fi
    counter = counter + 1
  } while (found == 0)
	      ]]></artwork>
	      </figure>
		</t>

	</section>
	</section>
	<section anchor="message_construction" title="Message Construction">
	<t>
	  After the EAP-pwd Identity exchange, the construction of the components of 
	  subsequent messages depends on the type of group from the ciphersuite (ECC or FFC).
	  This section provides an overview of the authenticated key exchange.
	  For a complete description of message generation and
	  processing, see Sections
	  <xref target="commit-exchange" format="counter"/> and
	  <xref target="confirm-exchange" format="counter"/>.
	  </t>
	<section title="ECC Groups">
		<t>
	  Using the mapping function F() defined in <xref target="ec_definition"/> and
	    the group order r:
	      <figure>
	<artwork align="center"><![CDATA[
Server: EAP-pwd-Commit/Request
   - choose two random numbers, 1 < s_rand, s_mask < r
   - compute Scalar_S = (s_rand + s_mask) mod r
   - compute Element_S = inv(s_mask * PWE)

 Element_S and Scalar_S are used to construct EAP-pwd-Commit/Request

Peer: EAP-pwd-Commit/Response
   - choose two random numbers, 1 < p_rand, p_mask < r
   - compute Scalar_P = (p_rand + p_mask) mod r
   - compute Element_P = inv(p_mask * PWE)

 Element_P and Scalar_P are used to construct EAP-pwd-Commit/Response

Server: EAP-pwd-Confirm/Request
   - compute KS = (s_rand * (Scalar_P * PWE + Element_P))
   - compute ks = F(KS)
   - compute Confirm_S = H(ks | Element_S | Scalar_S | 
                           Element_P | Scalar_P | Ciphersuite)

 Confirm_S is used to construct EAP-pwd-Confirm/Request

Peer: EAP-pwd-Confirm/Response
   - compute KP = (p_rand * (Scalar_S * PWE + Element_S)), 
   - compute kp = F(KP)
   - compute Confirm_P = H(kp | Element_P | Scalar_P |
                           Element_S | Scalar_S | Ciphersuite)

 Confirm_P is used to construct EAP-pwd-Confirm/Response

The EAP Server computes the shared secret as:
  MK = H(ks | Confirm_P | Confirm_S)

The EAP Peer computes the shared secret as:
  MK = H(kp | Confirm_P | Confirm_S)

      ]]></artwork>
	</figure>
	</t>
	<t>
	  The MSK and EMSK are derived from MK per
	  <xref target="key_manage"/>.
	</t>
	</section>
	<section title="FFC Groups">
	  <t>
	    There is no mapping function, F(), required for an FFC group. Using
	    the order, r, for the group (see <xref target="f_f_c"/> when the order
	    is not part of the defined domain parameters):
	  </t>
	<t>
	<figure>
	<artwork align="center"><![CDATA[
Server: EAP-pwd-Commit/Request
   - choose two random numbers, 1 < s_rand, s_mask < r
   - compute Scalar_S = (s_rand + s_mask) mod r
   - compute Element_S = inv(pwe^s_mask mod p)

 Element_S and Scalar_S are used to construct EAP-pwd-Commit/Request

Peer: EAP-pwd-Commit/Response
   - choose random two numbers, 1 < p_rand, p_mask < r
   - compute Scalar_P = (p_rand + p_mask) mod r
   - compute Element_P = inv(pwe^p_mask mod p)

 Element_P and Scalar_P are used to construct EAP-pwd-Commit/Response

Server: EAP-pwd-Confirm/Request
   - compute ks = ((pwe^Scalar_P mod p) * Element_P)^s_rand mod p
   - compute Confirm_S = H(ks | Element_S | Scalar_S | 
                           Element_P | Scalar_P | Ciphersuite)

 Confirm_S is used to construct EAP-pwd-Confirm/Request

Peer: EAP-pwd-Confirm/Response
   - compute kp = ((pwe^Scalar_S mod p) * Element_S)^p_rand mod p
   - compute Confirm_P = H(kp | Element_P | Scalar_P |
                           Element_S | Scalar_S | Ciphersuite)

 Confirm_P is used to construct EAP-pwd-Confirm/Request

The EAP Server computes the shared secret as:
  MK = H(ks | Confirm_P | Confirm_S)

The EAP Peer computes the shared secret as:
  MK = H(kp | Confirm_P | Confirm_S)

      ]]></artwork>
	</figure>
	</t>
	<t>
	    The MSK and EMSK are derived from MK per <xref target="key_manage"/>.
        </t>
	</section>
	</section>
	<section anchor="message_processing" title="Message Processing">
		<section anchor="id-exchange" title="EAP-pwd-ID Exchange">
		<t>
		Although EAP provides an Identity method to determine
		the identity of the peer, the value in the Identity Response may have been truncated
		or obfuscated to provide privacy or decorated for routing purposes <xref target="RFC3748"/>,
		making it inappropriate for usage by the EAP-pwd method. Therefore, the EAP-pwd-ID exchange
		is defined for the purpose of exchanging identities between the peer and server. 
	    </t>
	<t>
	    The EAP-pwd-ID/Request contains the following quantities: 
	<list style="symbols">
		<t>a ciphersuite </t>
		<t>a representation of the server's identity per <xref target="rep_id"/></t>
		<t>an anti-clogging token</t>
		<t>a password pre-processing method</t>
	</list>
	</t>
	<t>
		The ciphersuite specifies the finite
	    cyclic group, random function, and PRF selected by the server for use in
	    the subsequent authentication exchange.
	    </t>
   	    <t>
	    The value 
	    of the anti-clogging token MUST be unpredictable and SHOULD NOT be from a source of
	    random entropy. The purpose of the anti-clogging token is to provide the
	    server an assurance that the peer constructing the EAP-pwd-ID/Response
	    is genuine and not part of a flooding attack. 
	    </t>
	    <t>
	    A password pre-processing method is communicated to ensure interoperability
	    by producing a canonical representation of the password string
	    between the peer and server (see <xref target="rep_pwd"/>).
	    </t>
	    <t>
	    The EAP-pwd-ID/Request is constructed according to <xref target="eap-pwd-id"/>
	    and is transmitted to the peer.
	    </t>
	    <t>
	    Upon receipt of an EAP-pwd-ID/Request, the peer determines 
	    whether the ciphersuite and pre-processing method are acceptable. If not, the peer MUST respond
	    with an EAP-NAK. If acceptable, the peer responds to the 
	    EAP-pwd-ID/Request with an EAP-pwd-ID/Response, constructed according
	    to <xref target="eap-pwd-id"/>, that
	    acknowledges the Ciphersuite, token, and pre-processing method and then adds
	    its identity. After sending the EAP-pwd-ID/Response, the peer has the
	    identity of the server (from the Request), its own identity
	    (it encoded in the Response), a password pre-processing algorithm,
	    and it can compute the Password Element as specified in <xref target="fixing_pwe"/>.
	    The Password Element is stored in state allocated for this exchange.
	    </t>
 	    <t>
	    The EAP-pwd-ID/Response acknowledges the Ciphersuite from the Request,
	    acknowledges the anti-clogging token from the Request providing a
	    demonstration of "liveness" on the part of the peer, 
	    and contains the identity of the peer. Upon receipt of the Response,
	    the server verifies that the Ciphersuite acknowledged by the peer is
	    the same as that sent in the Request and that the anti-clogging token added
	    by the  peer in the Response is the same as that sent in the Request. 

	    If Ciphersuites or anti-clogging tokens differ, the server
	    MUST respond with an EAP-Failure message. If the anti-clogging tokens
	    are the same, the server knows the peer is an active participant in the
	    exchange. If the Ciphersuites are the
	    same, the server now knows its
	    own identity (it encoded in the Request) and the peer's identity
	    (from the Response) and can compute the Password Element according
	    to <xref target="fixing_pwe"/>. The server stores
	    the Password Element in state it has allocated for this exchange.
	    The server then initiates an EAP-pwd-Commit exchange. 
	    </t>
	</section>
	<section anchor="commit-exchange" title="EAP-pwd-Commit Exchange">
	  <t>
	    The server begins the EAP-pwd-Confirm exchange by choosing two random numbers,
	    s_rand and s_mask,
	    between 1 and r (where r is described in <xref target="notation"/> according
	    to the group established in <xref target="id-exchange"/>) such that their
	    sum modulo r is greater than one (1).
	    It then computes Element_S and Scalar_S
	    as defined in <xref target="message_construction"/> and constructs
	    an EAP-pwd-Commit/Request according to <xref target="eap-pwd-commit"/>.
	    Element_S and Scalar_S are added to the state allocated
	    for this exchange, and the EAP-pwd-Commit/Request is transmitted to the peer.
	  </t>
	  <t>
	    Upon receipt of the EAP-pwd-Commit/Request, the peer validates the length
	    of the entire payload based upon the expected lengths of Element_S and
	    Scalar_S (which are fixed according to the length of the agreed-upon
	    group). If the length is incorrect, the peer MUST terminate the exchange.
	    If the length is correct, Element_S and Scalar_S are extracted from the
	    EAP-pwd-Commit/Request. Scalar_S is then checked to ensure it is between
	    1 and r, exclusive. If it is not, the peer MUST terminate the exchange.
	    If it is, Element_S MUST be validated depending on the type of group -- Element
	    validation for FFC groups is described in <xref target="ffc_commit"/>, and
	    Element validation for ECC groups is described in <xref target="ecc_commit"/>.
	    If validation is successful,
	    the peer chooses two random numbers, p_rand and p_mask, between 1 and r (where
	    r is described in <xref target="notation"/> according to the group established in
	    <xref target="id-exchange"/>) such that their sum modulo r is greater than one
	    (1), and computes Element_P and Scalar_P. &nbsp;Next, the peer computes kp from p_rand, Element_S, Scalar_S, and the Password
	    Element according to <xref target="message_construction"/>. If kp is 
	    the "identity element" -- the point at infinity for an ECC group or the value
	    one (1) for an FFC group -- the peer MUST terminate the exchange. If not,
	    the peer uses Element_P and Scalar_P to construct an EAP-pwd-Commit/Response
	    according to <xref target="eap-pwd-commit"/> and transmits the 
	    EAP-pwd-Commit/Response to the server. 
	  </t>
	  <t>
	    Upon receipt of the EAP-pwd-Commit/Response, the server validates the
	    length of the entire payload based upon the expected lengths of
	    Element_P and Scalar_P (which are fixed according to the agreed-upon
	    group). If the length is incorrect, the server MUST respond with
	    an EAP-Failure message, and
	    it MUST terminate the exchange and free up any state allocated. If
	    the length is correct, Scalar_P and Element_P are extracted
	    from the EAP-pwd-Commit/Response and compared to Scalar_S
	    and Element_S. &nbsp;If Scalar_P equals Scalar_S and Element_P equals Element_S, it indicates
	    a reflection attack and the server MUST respond with an EAP-failure and
	    terminate the exchange. If they differ, Scalar_P is checked to ensure it is
	    between 1 and r, exclusive. If not the server MUST respond with an
	    EAP-failure and terminate the exchange. If it is, Element_P is 
	    verified depending on the type of
	    group -- Element validation for FFC groups is described in 
	    <xref target="ffc_commit"/>, and Element validation for ECC groups is
	    described in <xref target="ecc_commit"/>. If validation is successful,
	    the server computes ks from s_rand, Element_P, Scalar_P,
	    and the Password Element according to <xref target="message_construction"/>.
	    If ks is the "identity element" -- the point at infinity for an ECC group
	    or the value one (1) for an FFC group -- the server MUST respond with an
	    EAP-failure and terminate the exchange. Otherwise, the server initiates
	    an EAP-pwd-Confirm exchange.
	    </t>
	    <section anchor="ffc_commit" title="Element Validation for FFC Groups">
	      <t>
	      A received FFC Element is valid if: 1) it is between one (1) and the prime, p,
	      exclusive; and 2) if modular exponentiation of the Element by the
	      group order, r, equals one (1). If either of these conditions are not
	      true the received Element is invalid.
	      </t>
	    </section>
	    <section anchor="ecc_commit" title="Element Validation for ECC Groups">
	      <t>
	      Validating a received ECC Element involves: 1) checking whether the two
	      coordinates, x and y, are both greater than zero (0) and less than the
	      prime defining the underlying field; and 2) checking whether the x- and
	      y-coordinates
	      satisfy the equation of the curve (that is, that they produce a valid
	      point on the curve that is not the point at infinity). If either of these
	      conditions are not met, the received Element is invalid; otherwise, the
	      Element is valid.
	      </t>
	    </section>
	</section>
	<section anchor="confirm-exchange" title="EAP-pwd-Confirm Exchange">
	  <t>
	    The server computes Confirm_S according to <xref target="message_construction"/>,
	    constructs an EAP-pwd-Confirm/Request according to 
	    <xref target="eap-pwd-confirm"/>, and sends it to
	    the peer.
	  </t>

	  <t>
	    Upon receipt of an EAP-pwd-Confirm/Request, the peer validates the
	    length of the entire payload based upon the expected length of
	    Confirm_S (whose length is fixed by the agreed-upon random function).
	    If the length is incorrect, the peer MUST terminate the exchange and
	    free up any state allocated. If
	    the length is correct, the peer verifies that Confirm_S is the
	    value it expects based on the value of kp. If the value of Confirm_S is
	    incorrect, the peer MUST terminate the exchange and free up any
	    state allocated.
	    If the value of Confirm_S is correct, the peer computes
	    Confirm_P, constructs an EAP-pwd-Confirm/Response according to
	    <xref target="eap-pwd-confirm"/>, and sends it
	    off to the server. The peer then computes MK (according to
	    <xref target="message_construction"/>) and the MSK and EMSK
	    (according to <xref target="key_manage"/>) and stores these keys
	    in state allocated for this exchange. The peer SHOULD export the
	    MSK and EMSK at this time in anticipation of a secure association
	    protocol by the lower layer to create session keys. Alternatively,
	    the peer can wait until an EAP-Success message from the server
	    before exporting the MSK and EMSK.
	  </t>

	  <t>
	    Upon receipt of an EAP-pwd-Confirm/Response, the server validates the
	    length of the entire payload based upon the expected length of
	    Confirm_P (whose length is fixed by the agreed-upon random function).
	    If the length is incorrect, the server MUST respond with an
	    EAP-Failure message, and
	    it MUST terminate the exchange and free up any state allocated. If
	    the length is correct, the server verifies that Confirm_P is the
	    value it expects based on the value of ks. If the value of Confirm_P
	    is incorrect, the
	    server MUST respond with an EAP-Failure message. If the value of
	    Confirm_P is correct, the server computes MK
	    (according to <xref target="message_construction"/>) and the MSK
	    and EMSK (according to <xref target="key_manage"/>). It exports
	    the MSK and EMSK and responds with an EAP-Success message. The
	    server SHOULD free up state allocated for this exchange.
	  </t>
	</section>
	</section>
	</section>
	<section anchor="key_manage" title="Management of EAP-pwd Keys">
	<t>
	  <xref target="RFC5247"/> recommends each EAP method define
	how to construct a Method-ID and Session-ID to identify a particular
	EAP session between a peer and server. This information is
	constructed thusly:
	<list hangIndent="4" style="empty">
		<t>Method-ID = H(Ciphersuite | Scalar_P | Scalar_S)</t>
		<t>Session-ID = Type-Code | Method-ID</t>
	</list>
	where Ciphersuite, Scalar_P, and Scalar_S are from the specific
	exchange being identified; H is the random function specified
	in the Ciphersuite; and, Type-Code is the code assigned
	for EAP-pwd, 52, represented as a single octet.
	</t>
	<t>
	The authenticated key exchange of EAP-pwd generates a shared and
	authenticated key, MK. The size of MK is dependent on the
	random function, H, asserted in the Ciphersuite. EAP-pwd must export
	two 512-bit keys, MSK and EMSK. Regardless of the value of
	len(MK), implementations MUST invoke the KDF defined
	in <xref target="kdf"/> to construct the MSK and EMSK. The
	MSK and EMSK are derived thusly:
	<list hangIndent="4" style="empty">
		<t>MSK | EMSK = KDF(MK, Session-ID, 1024)</t>
	</list>
	</t>
	<t>
	<xref target="RFC4962"/> mentions the importance of naming keys,
	particularly when key caching is being used. To facilitate such
	an important optimization, names are assigned thusly:
	<list hangIndent="4" style="symbols">
		<t>EMSK-name = Session-ID | 'E' | 'M'| 'S' | 'K'</t>
		<t>MSK-name = Session-ID | 'M'| 'S' | 'K'</t>
	</list>
	where 'E' is a single octet of value 0x45, 'M' is a single
	octet of value 0x4d, 'S' is a single octet of value 0x53,
	and 'K' is a single octet of value 0x4b.
	</t>
	<t>
	This naming scheme allows
	for key-management applications to quickly and accurately identify
	keys for a particular session or all keys of a particular type.
	</t>
	</section>
	<section anchor="mandatory" title="Mandatory-to-Implement Parameters">
	<t>
	For the purposes of interoperability, compliant EAP-pwd implementations
	SHALL support the following parameters:
	<list hangIndent="4" style="symbols">
		<t>Diffie-Hellman Group: group 19 defined in <xref target="RFC5114"/></t>
		<t>Random Function: defined in <xref target="function_h"/></t>
		<t>PRF: HMAC-SHA256 defined in <xref target="RFC4634"/></t>
		<t>Password Pre-Processing: none</t>
	</list>
	</t>
	</section>
	</section>
	<section anchor="packet_formats" title="Packet Formats">
	<t>
      </t>
	<section anchor="eap_pwd_header" title="EAP-pwd Header">
	<t>
	The EAP-pwd header has the following structure:
	</t>
	<t>
	<figure align="center" anchor="eap-pwd-header" title="EAP-pwd Header">
	<artwork align="center"><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Code      |  Identifier   |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type      |L|M|  PWD-Exch |         Total-Length          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             Data...                      
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          ]]></artwork>
	</figure>
	</t>
	<t>
	<list style="hanging">
	<t hangText="Code">
	  <vspace blankLines="1"/>
	    Either 1 (for Request) or 2 (for Response); see <xref target="RFC3748"/>.
	    </t>
	<t hangText="Identifier">
	  <vspace blankLines="1"/>
	    The Identifier field is one octet and aids in matching responses
	    with requests.  The Identifier field MUST be changed on each Request packet.
	  </t>
	<t hangText="Length">
	  <vspace blankLines="1"/>
	    The Length field is two octets and indicates the length of the EAP
	    packet including the Code, Identifier, Length, Type, and Data
	    fields.  Octets outside the range of the Length field should be
	    treated as Data Link Layer padding and MUST be ignored on
	    reception.
	    </t>

	<t hangText="Type">
 	  <vspace blankLines="1"/>52 - EAP-pwd
	    </t>
	<t hangText="L and M bits">
	  <vspace blankLines="1"/>
	    The L bit (Length included) is set to indicate the presence of the
	    two-octet Total-Length field, and MUST be set for the first
	    fragment of a fragmented EAP-pwd message or set of messages.       
	  <vspace blankLines="1"/>
	    The M bit (more fragments) is set on all but the last fragment. 
	</t>
	<t hangText="PWD-Exch">
	  <vspace blankLines="1"/>
	    The PWD-Exch field identifies the type of EAP-pwd payload encapsulated in the Data field.
	    This document defines the following values for the PWD-Exch field:
	    <list hangIndent="4" style="symbols">
		<t>0x00 : Reserved</t>
		<t>0x01 : EAP-pwd-ID exchange</t>
		<t>0x02 : EAP-pwd-Commit exchange</t>
		<t>0x03 : EAP-pwd-Confirm exchange</t>
	    </list>
	    All other values of the PWD-Exch field are unassigned.
	    </t>

		<t hangText="Total-Length">
		  <vspace blankLines="1"/>
	    The Total-Length field is two octets in length, and is present only
	    if the L bit is set.  This field provides the total length of the
	    EAP-pwd message or set of messages that is being fragmented.
	    </t>
	</list>
	</t>
	</section>
	<section title="EAP-pwd Payloads">
	<t>
	EAP-pwd payloads all contain the EAP-pwd header and encoded information.
	Encoded information is comprised of sequences of data. Payloads in the
	EAP-pwd-ID exchange also include a ciphersuite statement indicating what
	finite cyclic group to use, what cryptographic primitive to use for H,
	and what PRF to use for deriving keys.
	</t>
	<section anchor="eap-pwd-id" title="EAP-pwd-ID">
	<t>
	  The Group Description, Random Function, and PRF together, and
	  in that order, comprise the Ciphersuite included in the
	  calculation of the peer's and server's confirm messages.
	  </t>
	<t>
	<figure align="center" anchor="pwd-id-payload" title="EAP-pwd-ID Payload">
	<artwork align="center"><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       Group Description       | Random Func'n |      PRF      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             Token                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      Prep     |                  Identity...                    
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+          
          ]]></artwork>
	</figure>
	</t>
	<t>
	  The Group Description field value is taken from the IANA registry for
	  "Group Description" created
	  by <xref target="RFC2409">IKE</xref>.
	  </t>
	<t>
	  This document defines the following value for the Random Function field:
	  <list hangIndent="4" style="symbols">
		<t>0x01 : Function defined in this memo in <xref target="function_h"/></t>
	  </list>
	  The value 0x00 is reserved for private use between mutually consenting
	  parties. All other values of the Random Function field are unassigned.
	  </t>
	<t>
	  The PRF field has the following value:
	    <list hangIndent="4" style="symbols">
		<t>0x01 : HMAC-SHA256 <xref target="RFC4634"/></t>
	    </list>
	    The value 0x00 is reserved for private use between mutually consenting
	    parties. All other values of the PRF field are unassigned.
	  </t>
	<t>
	  The Token field contains an unpredictable value assigned by
	  the server in an EAP-pwd-ID/Request and acknowledged by the
	  peer in an EAP-pwd-ID/Response (see <xref target="message_processing"/>).
	  </t>
	<t>
	  The Prep field represents the password pre-processing technique (see
	  <xref target="rep_pwd"/>) to be used by
	  the client prior to generating the password seed (see <xref target="fixing_pwe"/>).
	  This document defines the following values for the Prep field:
	  <list hangIndent="4" style="symbols">
		<t>0x00 : None</t>
		<t>0x01 : RFC2759</t>
		<t>0x02 : SASLprep</t>
	  </list>
		All other values of the Prep field are unassigned.
	  </t>
	<t>
	  The Identity field depends on the tuple of PWD-Exch/Code.
	    <list hangIndent="4" style="symbols">
		<t>EAP-pwd-ID/Request :  Server_ID</t>
		<t>EAP-pwd-ID/Response : Peer_ID</t>
	    </list>
	  The length of the identity is computed from the Length field
	  in the EAP header.  
	  </t>
	</section>
	<section anchor="eap-pwd-commit" title="EAP-pwd-Commit">
	<t>
	<figure align="center" anchor="pwd-commit-payload" title="EAP-pwd-Commit Payload">
		<artwork align="center"><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                           Element                             ~
   |                                                               |
   ~                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               |                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               ~
   |                                                               |
   ~                            Scalar             +-+-+-+-+-+-+-+-+
   |                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          ]]></artwork>
	</figure>
	</t>
	<t>
	  The Element and Scalar fields depend on the tuple of PWD-Exch/Code.
	    <list hangIndent="4" style="symbols">
		<t>EAP-pwd-Commit/Request :  Element_S, Scalar_S</t>
		<t>EAP-pwd-Commit/Response : Element_P, Scalar_P</t>
	    </list>
	  The Element is encoded according to <xref target="encode_elements"/>.
	  The length of the Element is inferred by the finite cyclic
	  group from the agreed-upon Ciphersuite. The length of the scalar
	  can then be computed from the Length in the EAP header.
	  </t>
	</section>
	<section anchor="eap-pwd-confirm" title="EAP-pwd-Confirm">
	<t>
	<figure align="center" anchor="pwd-confirm-payload" title="EAP-pwd-Confirm Payload">
		<artwork align="center"><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                            Confirm                            ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          ]]></artwork>
	</figure>
	</t>
	<t>
	  The Confirm field depends on the tuple of PWD-Exch/Code.
	    <list hangIndent="4" style="symbols">
		<t>EAP-pwd-Confirm/Request :  Confirm_S</t>
		<t>EAP-pwd-Confirm/Response : Confirm_P</t>
	    </list>
	    The length of the Confirm field computed from the Length in
	    the EAP header.
	    </t>
	</section>
	</section>
	<section anchor="encode_elements" title="Representation of Group Elements and Scalars">
	<t>
	Payloads in the EAP-pwd-Commit exchange contain elements from the 
	agreed-upon finite cyclic cryptographic group (either an FCC group
	or an ECC group). To ensure interoperability, field elements and
	scalars MUST be represented in payloads in accordance with the
	requirements described below.
	</t>
	<section title="Elements in FFC Groups">
	  <t>
	  Elements in an FFC group MUST be represented (in binary form) as
	  unsigned integers that are strictly less than the prime, p, from
	  the group's domain parameter set. The binary representation of each
	  group element MUST have a bit length equal to the bit length of the
	  binary representation of p. This length requirement is enforced,
	  if necessary, by prepending the binary representation of the integer
	  with zeros until the required length is achieved.
	  </t>
	</section>
	<section title="Elements in ECC Groups">
	  <t>
	  Elements in an ECC group are points on the agreed-upon elliptic
	  curve. Each such element MUST be represented by the concatenation
	  of two components, an x-coordinate and
	  a y-coordinate. 
	  </t>
	  <t>
	  Each of the two components, the x-coordinate and the y-coordinate,
	  MUST be represented (in binary form) as an unsigned integer that
	  is strictly less than the prime, p, from the group's domain parameter
	  set. The binary representation of each component MUST have a bit
	  length equal to the bit length of the binary representation of p.
	  This length requirement is enforced, if necessary, by prepending 
	  the binary representation of the integer with zeros until the
	  required length is achieved.
	  </t>
	  <t>
	  Since the field element is represented in a payload by 
	  the x-coordinate followed by the y-coordinate, it follows that
	  the length of the element in the payload MUST be twice the bit length
	  of p. In other words, "compressed representation" is not used.
	  </t>
	</section>
	<section title="Scalars">
	  <t>
	  Scalars MUST be represented (in binary form) as unsigned integers
	  that are strictly less than r, the order of the generator of the 
	  agreed-upon cryptographic group. The binary representation of each
	  scalar MUST have a bit length equal to the bit length of the binary
	  representation of r. This requirement is enforced, if necessary, by
	  prepending the binary representation of the integer with zeros until
	  the required length is achieved.
	  </t>
	</section>
	</section>
	</section>
	<section anchor="fragmentation" title="Fragmentation">
	<t>
      EAP <xref target="RFC3748"/> is a request-response protocol. The server sends
      requests and the peer responds. These request and response messages are
      assumed to be limited to at most 1020 bytes. Messages in EAP-pwd can be larger than
      1020 bytes and therefore require support for fragmentation and reassembly.
      </t>
			<t>
      Implementations MUST establish a fragmentation threshold that indicates
      the maximum size of an EAP-pwd payload. When an implementation knows
      the maximum transmission unit (MTU) of its lower layer, it SHOULD calculate
      the fragmentation threshold from that value. In lieu of knowledge of the
      lower layer's MTU, the fragmentation threshold MUST be set to 1020 bytes.
      </t>
			<t>
      Since EAP is a simple ACK-NAK protocol, fragmentation support can be
      added in a simple manner.  In EAP, fragments that are lost or damaged
      in transit will be retransmitted, and since sequencing information is
      provided by the Identifier field in EAP, there is no need for a
      fragment offset field as is provided in IPv4.
      <vspace blankLines="1"/>
      EAP-pwd fragmentation support is provided through the addition of flags
      within the EAP-Response and EAP-Request packets, as well as a
      Total-Length field of two octets. Flags include the Length
      included (L) and More fragments (M) bits.  The L
      flag is set to indicate the presence of the two-octet Total-Length
      field, and MUST be set for the first fragment of a fragmented
      EAP-pwd message or set of messages. The M flag is set on all but the last
      fragment. The Total-Length field is
      two octets, and provides the total length of the EAP-pwd message or set
      of messages that is being fragmented; this simplifies buffer
      allocation. 
      <vspace blankLines="1"/>
      When an EAP-pwd peer receives an EAP-Request packet with the M bit
      set, it MUST respond with an EAP-Response with EAP-Type=EAP-pwd and
      no data.  This serves as a fragment ACK.  The EAP server MUST wait
      until it receives the EAP-Response before sending another fragment.
      In order to prevent errors in processing of fragments, the EAP server
      MUST increment the Identifier field for each fragment contained
      within an EAP-Request, and the peer MUST include this Identifier
      value in the fragment ACK contained within the EAP-Response.
      Retransmitted fragments will contain the same Identifier value.
      <vspace blankLines="1"/>
      Similarly, when the EAP server receives an EAP-Response with the M
      bit set, it MUST respond with an EAP-Request with EAP-Type=EAP-pwd
      and no data.  This serves as a fragment ACK. The EAP peer MUST wait
      until it receives the EAP-Request before sending another fragment.
      In order to prevent errors in the processing of fragments, the EAP
      server MUST increment the Identifier value for each fragment ACK
      contained within an EAP-Request, and the peer MUST include this
      Identifier value in the subsequent fragment contained within an EAP-
      Response.
      </t>
	</section>

	<section anchor="IANA" title="IANA Considerations">
	<t>
      This memo contains new numberspaces to be managed by IANA. The
      policies used to allocate numbers are described in <xref target="RFC5226"/>.
      IANA has allocated a new EAP method type for EAP-pwd (52).

      </t>
	<t>
      IANA has created new registries for PWD-Exch
      messages, random functions, PRFs, and password pre-processing methods 
      and has added the  
      message numbers, random function, PRF, and pre-processing methods
      specified in this memo to those registries, respectively.
      </t>
	<t>
      The following is the initial PWD-Exch message registry layout:
        <list hangIndent="4" style="symbols">
		<t>0x00 : Reserved </t>
		<t>0x01 : EAP-pwd-ID exchange</t>
		<t>0x02 : EAP-pwd-Commit exchange</t>
		<t>0x03 : EAP-pwd-Confirm exchange</t>
	</list>
      The PWD-Exch field is 6 bits long. The value 0x00 is reserved. All
      other values are available
      through assignment by IANA. IANA is instructed to assign values
      based on "IETF Review" (see <xref target="RFC5226"/>). 
      </t>
	<t>
      The following is the initial Random Function registry layout:
        <list hangIndent="4" style="symbols">
		<t>0x00 : Private Use</t>
		<t>0x01 : Function defined in this memo, <xref target="function_h"/></t>
	</list>

      The Random Function field is 8 bits long. The value 0x00 is for 
      Private Use between mutually consenting parties. All other values
      are available through assignment by IANA. IANA is instructed to
      assign values based on "Specification Required"
      (see <xref target="RFC5226"/>). 
      The Designated Expert performing the necessary review MUST
      ensure the random function has been cryptographically vetted.
      </t>
			<t>
      The following is the initial PRF registry layout:
        <list hangIndent="4" style="symbols">
		<t>0x00 : Private Use</t>
		<t>0x01 : HMAC-SHA256 as defined in <xref target="RFC4634"/></t>
	</list>
      The PRF field is 8 bits long. The value 0x00 is for Private Use between
      mutually consenting parties. All other values are available
      through assignment by IANA. 
      IANA is instructed to assign values
      based on "IETF Review" (see <xref target="RFC5226"/>).
      </t>
	<t>
      The following is the initial layout for the password pre-processing method registry:
        <list hangIndent="4" style="symbols">
		<t>0x00 : None</t>
		<t>0x01 : RFC2759</t>
		<t>0x02 : SASLprep</t>
	</list>
      The Prep field is 8 bits long, and all other values are available
      through assignment by IANA. 
      IANA is instructed to assign values
      based on "Specification Required" (see <xref target="RFC5226"/>).
      </t>
	</section>
	<section anchor="Security" title="Security Considerations">
	<t>
      In <xref target="requirements"/>, several security properties were presented
      that motivated the design of this protocol. This section will address how well
      they are met.
      </t>
	<section title="Resistance to Passive Attack">
	<t>
	A passive attacker will see Scalar_P, Element_P, Scalar_S, and Element_S. &nbsp;She
	can guess at passwords to compute the password element but will not know s_rand
	or p_rand and therefore will not be able to compute MK.
        </t>
	<t>
	The secret random value of the peer (server) is effectively hidden
	by adding p_mask (s_mask) to p_rand (s_rand) modulo the order of the group. If the
	order is "r", then there are approximately "r" distinct pairs of numbers that
	will sum to the value Scalar_P (Scalar_S). Attempting to guess the particular
	pair is just as difficult as guessing the secret random value p_rand (s_rand),
	the probability of a guess is 1/(r - i) after "i" guesses. For a large
	value of r, this exhaustive search technique is computationally infeasible.
	An attacker would do better by determining the discrete logarithm of Element_P
	(Element_S) using an algorithm like the baby-step giant-step
	algorithm (see
	<xref target="APPCRY"/>), which runs on the order of the square root of r group
	operations (e.g., a group with order 2^160 would require 2^80 exponentiations or
	point multiplications). 

	Based on the assumptions made on the finite cyclic group
	in <xref target="assumptions"/>, that is also computationally infeasible.
        </t>
	</section>
	<section title="Resistance to Active Attack">
	<t>
	An active attacker can launch her attack after an honest server has sent
	EAP-pwd-Commit/Request to an honest peer. This would result in the peer sending
	EAP-pwd-Commit/Response.
	In this case, the active attack has been reduced to that of a passive attacker
	since p_rand and s_rand will remain unknown. The active attacker could forge
	a value of Confirm_P (Confirm_S) and send it to the EAP server (EAP peer)
	in the hope that it will be accepted, but due to the assumptions on H made in 
	<xref target="assumptions"/>, that is computationally infeasible.
        </t>
	<t>
	The active attacker can launch her attack by forging EAP-pwd-Commit/Request and
	sending it to the peer. This will result in the peer responding with
	EAP-pwd-Commit/Response. The
	attacker can then attempt to compute ks, but since she doesn't know the
	password, this is infeasible. It can be shown that an attack by 
	forging an EAP-pwd-Commit/Response
	is an identical attack with equal infeasibility.
        </t>
			</section>
			<section title="Resistance to Dictionary Attack">
	<t>
	An active attacker can wait until an honest server sends EAP-pwd-Commit/Request
	and then forge EAP-pwd-Commit/Response and send it to the server. The server will
	respond with EAP-pwd-Confirm/Request. Now the attacker can attempt to 
	launch a dictionary attack. She can guess at potential passwords, compute the
	password element, and compute kp using her p_rand, Scalar_S, and Element_S from
	the EAP-pwd-Commit/Request
	and the candidate password element from her guess. She will know if her guess is correct
	when she is able to verify Confirm_S in EAP-pwd-Confirm/Request.
        </t>
	<t>
	But the attacker committed to a password guess with her forged EAP-pwd-Commit/Response
	when she computed Element_P. &nbsp;That value was used by the server
	in his computation of ks that was used when he constructed Confirm_S in EAP-pwd-Confirm/Request. Any guess of the
	password that differs from the one used in the forged EAP-pwd-Commit/Response could not be 
	verified as correct since the attacker has no way of knowing whether it is correct.
	She is able to make one guess and one guess only per attack. This means that any
	advantage she can gain -- guess a password, if it fails exclude it from the pool
	of possible passwords and try again -- is solely through interaction with an honest
	protocol peer.
        </t>
	<t>
	The attacker can commit to the guess with the forged EAP-pwd-Commit/Response and then run
	through  the dictionary, computing the password element and ks using her forged Scalar_P and
	Element_P. &nbsp;She will know she is correct if she can compute the same value for
	Confirm_S that the server produced in EAP-pwd-Confirm/Request. But this requires the attacker
	to know s_rand, which we noted above was not possible.
        </t>
	<t>
	The password element PWE/pwe is chosen using a method described in
	<xref target="fixing_pwe"/>. Since this is an element in the
	group, there exists
	a scalar value, q, such that:
	  <list hangIndent="4" style="empty">
		<t>PWE = q * G, for an ECC group</t>
		<t>pwe = g^q mod p, for an FFC group</t>
	  </list>
	Knowledge of q can be used to launch a dictionary attack. For the sake of brevity,
	the attack will be demonstrated assuming an ECC group. The attack works
	thusly:
	</t>
	<t>
	The attacker waits until an honest server sends an EAP-pwd-Commit/Request. The attacker
	then generates a random	Scalar_P and a random p_mask and
	computes Element_P = p_mask * G. &nbsp;The attacker sends the bogus Scalar_P and Element_P to the server and obtains
	Confirm_S in return. Note that the server is unable to detect that Element_P was
	calculated incorrectly.
	</t>
	<t>
	The attacker now knows that:
	  <list hangIndent="4" style="empty">
		<t>KS = (Scalar_P * q + p_mask) * s_rand * G</t>
	  </list>
	and
	  <list hangIndent="4" style="empty">
		<t>s_rand * G = Scalar_P * G - ((1/q) mod r * -Element_P)</t>
	  </list>
	Since Scalar_P, p_mask, G, and Element_P are all known, the attacker
	can run through the dictionary, make a password guess, compute PWE
	using the technique in Section 2.8.3, determine q, and then use the
	equations above to compute KS and see if it can verify Confirm_S.

	But to determine q
	for a candidate PWE, the attacker needs to perform a discrete logarithm that was
	assumed to be computationally infeasible in <xref target="assumptions"/>. Therefore,
	this attack is also infeasible.
	</t>
	<t>
	The best advantage an attacker can gain in a single active attack is to determine whether
	a single guess at the password was correct. Therefore, her advantage is solely through
	interaction and not computation, which is the definition for resistance to dictionary
	attack.
        </t>
	<t>
	Resistance to dictionary attack means that the attacker must launch an active attack
	to make a single guess at the password. If the size of the dictionary from which the
	password was extracted was D, and each password in the dictionary has an equal probability
	of being chosen, then the probability of success after a single guess is 1/D. After
	X guesses, and removal of failed guesses from the pool of possible passwords, the
	probability becomes 1/(D-X). As X grows, so does the probability of success. Therefore, it
	is possible
	for an attacker to determine the password through repeated brute-force, active, guessing
	attacks. This protocol does not presume to be secure against this, and implementations
	SHOULD ensure the size of D is sufficiently large to prevent this attack. Implementations
	SHOULD also take countermeasures -- for instance, refusing authentication attempts for a certain
	amount of time, after the number of failed authentication attempts reaches a certain
	threshold. No such threshold or amount of time is recommended in this memo.
        </t>
	</section>
	<section title="Forward Secrecy">
	<t>
	The MSK and EMSK are extracted from MK, which is derived from doing group operations
	with s_rand, p_rand, and the password element. The peer and server choose
	random values with each run of the protocol. So even if an attacker is able to learn
	the password, she will not know the random values used by either the peer or server
	from an earlier run and will therefore be unable to determine MK, or the MSK or EMSK.
	This is the definition of Forward Secrecy.
        </t>
	</section>
	<section anchor="group_strength" title="Group Strength">
	  <t>
	  The strength of the shared secret, MK, derived in <xref target="message_construction"/> 
	  depends on the effort needed to solve the discrete logarithm problem in the
	  chosen group. <xref target="RFC3766"/> has a good discussion on the strength
	  estimates of symmetric keys derived from discrete logarithm cryptography.
	  </t>
	  <t>
	  The mandatory-to-implement group defined in this memo is group 19, a group
	  from <xref target="RFC5114"/> based on Elliptic Curve Cryptography
	  (see <xref target="ec_definition"/>)
	  with a prime bit length of 256. This group was chosen because the current
	  best estimate of a symmetric key derived using this group is 128 bits, which
	  is the typical length of a key for the Advanced Encryption Standard
	  (<xref target="FIPS-197"/>). While it is possible to obtain a equivalent 
	  measure of strength using a group based on Finite Field Cryptography
	  (see <xref target="f_f_c"/>), it would require a much larger prime and
	  be more memory and compute intensive.
	  </t>
	</section>
	<section title="Random Functions">
	<t>
	The protocol described in this memo uses a function referred to as a "random
	oracle" (as defined in <xref target="RANDOR"/>). A significant amount of care
	must be taken to instantiate a random oracle out of handy cryptographic primitives.
	The random oracle used here is based on the notion of a "Randomness Extractor"
	from <xref target="RFC5869"/>.
        </t>
	<t>
	This protocol can use any properly instantiated random oracle. To ensure that 
	any new value for H will use a properly instantiated random oracle, IANA has been
	instructed (in <xref target="IANA"/>) to only allocate values from the Random
	Function registry after being vetted by an expert. 
	</t>
	<t>
	A few of the defined groups that can be used with this protocol have a
	security estimate (see <xref target="group_strength"/>) less than 128 bits,
	many do not though, and to prevent the random function from being the gating
	factor (or a target for attack), any new random function MUST map its input
	to a target of at least 128 bits and SHOULD map its input to a target of at
	least 256 bits.
	</t>
	</section>
		</section>
		<section anchor="security_claims" title="Security Claims">
			<t>
			<xref target="RFC3748"/> requires that documents describing new EAP methods clearly
		      articulate the security properties of the method. In addition, for use with 
		      wireless LANs, <xref target="RFC4017"/> mandates and recommends several of these.
		      The claims are:
	        <list hangIndent="4" style="letters">
			<t>mechanism: password.</t>
			<t>claims: <list hangIndent="4" style="symbols">
			<t>mutual authentication: the peer and server both authenticate each other
			  by proving possession of a shared password. This is REQUIRED by 
			  <xref target="RFC4017"/>. </t>
			<t>forward secrecy: compromise of the password does not reveal the
			  secret keys -- MK, MSK, or EMSK -- from earlier runs of the protocol. </t>

			<t>replay protection: an attacker is unable to replay messages from a 
			  previous exchange to either learn the password or a key derived by the
			  exchange. 

			  Similarly the attacker is unable to induce either the peer
			  or server to believe the exchange has successfully completed when it
			  hasn't. Reflection attacks are foiled because the server ensures that
			  the scalar and element supplied by the peer do not equal its own.
			</t>

			<t>key derivation: keys are derived by performing a group operation in
			  a finite cyclic group (e.g., exponentiation) using secret data contributed
			  by both the peer and server. An MSK and EMSK are derived from that
			  shared secret. This is REQUIRED by <xref target="RFC4017"/>
			</t>
			<t>dictionary attack resistance: this protocol is resistant to dictionary
			  attack because an attacker can only make one password guess
			  per active attack. The advantage gained by an attacker is through interaction
			  not through computation. This is REQUIRED by <xref target="RFC4017"/>.
			</t>
			<t>session independence: this protocol is resistant to active and passive
			  attack and does not enable compromise of subsequent or prior 
			  MSKs or EMSKs from either passive or active attack.
		  </t>
		<t>Denial-of-Service Resistance: it is possible for an attacker to
	  cause a server to allocate state and consume CPU cycles generating
	  Scalar_S and Element_S. 

	  Such an attack is gated, though, by the
	  requirement that the attacker first obtain connectivity through
	  a lower-layer protocol (e.g. 802.11 authentication followed by 802.11
	  association, or 802.3 "link-up") and respond to two EAP messages --the
	  EAP-ID/Request and the EAP-pwd-ID/Request. The EAP-pwd-ID exchange
	  further includes an anti-clogging token that provides a level of
	  assurance to the server that the peer is, at least, performing
	  a rudimentary amount of processing and not merely spraying packets.
	  This prevents distributed denial-of-service attacks and also 
	  requires the attacker to announce, and commit to, a lower-layer
	  identity, such as a MAC (Media Access Control) address.
	  </t>
		<t>Man-in-the-Middle Attack Resistance: this exchange is resistant to
	  active attack, which is a requirement for launching a man-in-the-middle
	  attack. This is REQUIRED by <xref target="RFC4017"/>.
	  </t>
		<t>shared state equivalence: upon completion of EAP-pwd, the peer and server
	  both agree on MK, MSK, EMSK, Method-ID, and Session-ID. The peer has
	  authenticated the server based on the Server-ID, and the server has
	  authenticated the peer based on the Peer-ID. This is due to the fact
	  that Peer-ID, Server-ID, and the shared password are all combined to
	  make the password element, which must be shared between the peer and
	  server for the exchange to complete. This is REQUIRED by <xref target="RFC4017"/>.
	  </t>
		<t>fragmentation: this protocol defines a technique for fragmentation and
		  reassembly in <xref target="fragmentation"/>.
	  </t>
		<t>resistance to "Denning-Sacco" attack: learning keys distributed from
	  an earlier run of the protocol, such as the MSK or EMSK, will not help
	  an adversary learn the password.</t>
	</list>
	</t>
	<t>key strength: the strength of the resulting key depends on the finite
           cyclic group chosen. See <xref target="group_strength"/>. This is
           REQUIRED by  <xref target="RFC4017"/>.
        </t>
	<t>key hierarchy: MSKs and EMSKs are derived from the MK using the KDF defined
           in <xref target="kdf"/> as described in <xref target="message_construction"/>.
        </t>
	<t>vulnerabilities (note that none of these are REQUIRED by <xref target="RFC4017"/>): 
        <list hangIndent="4" style="symbols">
	<t>protected ciphersuite negotiation: the ciphersuite offer made by the
	   server is not protected from tampering by an active attacker. Downgrade
	   attacks are prevented, though, since this is not a "negotiation" with
	   a list of acceptable ciphersuites. If a Ciphersuite was modified by an
	   active attacker it would result in a failure to confirm the message sent
	   by the other party, since the Ciphersuite is bound by each side into its
	   confirm message, and the protocol would fail as a result.
	   </t>
	<t>confidentiality: none of the messages sent in this protocol are encrypted.
	   </t>
	<t>integrity protection: messages in the EAP-pwd-Commit exchange are not
	   integrity protected.
	   </t>
	<t>channel binding: this protocol does not enable the exchange of integrity-protected
	   channel information that can be compared with values communicated
	   via out-of-band mechanisms.
	   </t>
	<t>fast reconnect: this protocol does not provide a fast-reconnect capability.
	   </t>
	<t>cryptographic binding: this protocol is not a tunneled EAP method and
	   therefore has no cryptographic information to bind.
	   </t>
	<t>identity protection: the EAP-pwd-ID exchange is not protected. An attacker
	   will see the server's identity in the EAP-pwd-ID/Request and see the
	   peer's identity in EAP-pwd-ID/Response.
	   </t>
	</list>
	</t>
	</list>
	</t>
	</section>
	<section anchor="Acknowledgements" title="Acknowledgements">
	<t>
      The authors would like to thank Scott Fluhrer for discovering the "password as
      exponent" attack that was possible in the initial version of this memo and for
      his very helpful suggestions on the techniques for fixing the PWE/pwe to prevent it.
      The authors would also like to thank Hideyuki Suzuki for his insight in discovering
      an attack against a previous version of the underlying key exchange protocol. 
      Special thanks to Lily Chen for helpful discussions on hashing into an elliptic
      curve and to Jin-Meng Ho for suggesting the countermeasures to 
      protect against a small sub-group attack. Rich Davis suggested the defensive
      checks to Commit messages, and his various comments greatly improved the quality
      of this memo and the underlying key exchange on which it is based. Scott
      Kelly suggested adding the anti-clogging token to the ID exchange to prevent
      distributed denial-of-service attacks. Dorothy Stanley provided valuable suggestions
      to improve the quality of this memo.  
      The fragmentation method used was taken from <xref target="RFC5216"/>.
      </t>
	</section>
	</middle>
	<!--  *****BACK MATTER ***** -->
	<back>

	<references title="Normative References">

      &rfc2119;
      &rfc3748;
      &rfc2759;
      &rfc3454;
      &rfc4634;
	  &rfc5226;
	  &rfc4282;
	  &rfc4013;

      <reference anchor="SP800-108">
	<front>
	  <title>Recommendations for Key Derivation Using Pseudorandom Functions</title>
		<author initials="L" surname="Chen">
			<organization>NIST</organization>
		</author>
		<date month="April" year="2008"/>
	</front>
	<seriesInfo name="NIST Special Publication" value="800&nbhy;108"/>
      </reference>

      <reference anchor="SP800-56A">
	<front>
	  <title>Recommendations for Pair-Wise Key Establishment Schemes Using Discrete Logarithm Cryptography</title>
		<author initials="E" surname="Barker">
			<organization>NIST</organization>
		</author>
		<author initials="D" surname="Johnson">
			<organization>NIST</organization>
		</author>
		<author initials="M" surname="Smid">
			<organization>NIST</organization>
		</author>
		<date month="March" year="2007"/>
	</front>
	<seriesInfo name="NIST Special Publication" value="800&nbhy;56A"/>
      </reference>
	</references>
	<references title="Informative References">

      <reference anchor="FIPS-197">
        <front>
	  <title>FIPS Pub 197: Advanced Encryption Standard (AES)</title>
	  <author>
	    <organization>National Institute of Standards and Technology</organization>
	  </author>
	  <date day="26" month="November" year="2001"/>	  
	</front>
      </reference>

      <reference anchor="APPCRY">
				<front>
					<title>Handbook of Applied Cryptography</title>
					<author initials="A" surname="Menezes">
						<organization/>
					</author>
					<author initials="P" surname="van Oorshot">
						<organization/>
					</author>
					<author initials="S" surname="Vanstone">
						<organization/>
					</author>
					<date year="1996"/>
				</front>
				<seriesInfo name="CRC Press Series on" value="Discrete Mathematics and Its Applications"/>
			</reference>
			<reference anchor="BM92">
				<front>
					<title>Encrypted Key Exchange: Password-Based Protocols Secure Against Dictionary Attack</title>
					<author initials="S" surname="Bellovin">
						<organization>Bell Laboratories</organization>
					</author>
					<author initials="M" surname="Merritt">
						<organization>Bell Laboratories</organization>
					</author>
					<date year="1992"/>
				</front>
				<seriesInfo name="Proceedings of the IEEE Symposium on Security and Privacy," value="Oakland"/>
			</reference>
			<reference anchor="BM93">
				<front>
					<title>
	    Augmented Encrypted Key Exchange: A Password-Based Protocol
	    Secure against Dictionary Attacks and Password File Compromise
	  </title>
					<author initials="S" surname="Bellovin">
						<organization>Bell Laboratories</organization>
					</author>
					<author initials="M" surname="Merritt">
						<organization>Bell Laboratories</organization>
					</author>
					<date year="1993"/>
				</front>
				<seriesInfo name="Proceedings of the 1st ACM Conference on Computer and Communication Security," value="ACM Press"/>
			</reference>
			<reference anchor="JAB96">
				<front>
					<title>Strong Password-Only Authenticated Key Exchange</title>
					<author initials="D" surname="Jablon">
						<organization>Integrity Sciences, Inc.</organization>
					</author>
					<date month="October" year="1996"/>
				</front>
				<seriesInfo name="ACM SIGCOMM Computer Communication Review" value="Volume 1, Issue 5"/>
			</reference>
			<reference anchor="LUC97">
				<front>
					<title>
	    Open Key Exchange: How to Defeat Dictionary Attacks Without Encrypting Public Keys
	  </title>
					<author initials="S" surname="Lucks">
						<organization>Institut f&uuml;r Numerische und Angewandte Mathematik, Georg-August-Universit&auml;t G&ouml;ttingen, Lotzestr.</organization>
					</author>
					<date year="1997"/>
				</front>
				<seriesInfo name="Proceedings of the Security Protocols Workshop, LNCS 1361," value="Springer-Verlag"/>
			</reference>
			<reference anchor="BMP00">
				<front>
					<title>Provably Secure Password Authenticated Key Exchange Using Diffie-Hellman</title>
					<author initials="V" surname="Boyko">
						<organization/>
					</author>
					<author initials="P" surname="MacKenzie">
						<organization/>
					</author>
					<author initials="S" surname="Patel">
						<organization/>
					</author>
					<date year="2000"/>
				</front>
				<seriesInfo name="Proceedings of Eurocrypt 2000, LNCS 1807" value="Springer-Verlag"/>
			</reference>
			<reference anchor="RANDOR">
				<front>
					<title>Random Oracles are Practical: A Paradigm for Designing Efficient Protocols</title>
					<author initials="M" surname="Bellare">
						<organization/>
					</author>
					<author initials="P" surname="Rogaway">
						<organization/>
					</author>
					<date year="1993"/>
				</front>
				<seriesInfo name="Proceedings of the 1st ACM Conference on Computer and Communication Security," value="ACM Press"/>
			</reference>

          &rfc5216;
	  &rfc4086;
	  &rfc2409;
	  &rfc4017;
	  &eapkey;
	  &rfc4962;
	  &rfc5869;
	  &rfc5114;
	  &rfc3766;
    </references>
	</back>
</rfc>
