<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc6838 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6838.xml'>
    <!ENTITY rfc3023 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3023.xml'>
    <!ENTITY rfc3324 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3324.xml'>
    <!ENTITY rfc3325 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3325.xml'>
    <!ENTITY rfc2648 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2648.xml'>
    <!ENTITY rfc3688 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3688.xml'>
    <!ENTITY rfc2141 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2141.xml'>
    <!ENTITY rfc4825 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4825.xml'>
    <!ENTITY rfc6665 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6665.xml'>
    <!ENTITY rfc3966 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3966.xml'>
    <!ENTITY rfc3261 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml'>
    <!ENTITY rfc4745 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4745.xml'>
    <!ENTITY rfc2119 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
    <!ENTITY rfc4412 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4412.xml'>
    <!ENTITY rfc5031 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5031.xml'>
    <!ENTITY rfc5390 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5390.xml'>
    <!ENTITY rfc6357 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6357.xml'>
    <!ENTITY ietf-soc-overload-control PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-soc-overload-control.xml'>
]>

<rfc submissionType="IETF" category="std" consensus="yes" ipr="trust200902" number="7200">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc compact="yes" ?>  
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc subcompact="no"?>
<?rfc rfcedstyle="yes"?> 

<front>
    <title abbrev="SIP Load-Control Event Package">
    A Session Initiation Protocol (SIP) Load-Control Event Package 
    </title> 
    <author initials='C.' surname="Shen" fullname='Charles Shen'>
        <organization abbrev="Columbia U.">
            Columbia University
        </organization>
        <address>
            <postal>
                <street>Department of Computer Science</street>
                <street>1214 Amsterdam Avenue, MC 0401</street>
                <city>New York</city>
                <region>NY </region>
                <code>10027</code>
                <country>USA</country>
            </postal>
            <phone>+1 212 854 3109</phone>
            <email>charles@cs.columbia.edu</email>
        </address>
    </author>
    
    <author initials='H.' surname="Schulzrinne" fullname='Henning Schulzrinne'>
        <organization abbrev="Columbia U.">
            Columbia University
        </organization>
        <address>
            <postal>
                <street>Department of Computer Science</street>
                <street>1214 Amsterdam Avenue, MC 0401</street>
                <city>New York</city>
                <region>NY </region>
                <code>10027</code>
                <country>USA</country>
            </postal>
            <phone>+1 212 939 7004</phone>
            <email>schulzrinne@cs.columbia.edu</email>
        </address>
    </author>

    <author initials='A.' surname="Koike" fullname='Arata Koike'>
        <organization abbrev="NTT">
            NTT Network Technology Labs 
        </organization>
        <address>
            <postal>
                <street>3-9-11 Midori-cho Musashino-shi</street>
                <city>Tokyo</city>
                <region></region>
                <code>180-8585</code>
                <country>Japan</country>
            </postal>
            <phone>+81 422 59 6099</phone>
            <email>koike.arata@lab.ntt.co.jp</email>
        </address>
    </author>
    <date month="April" year="2014"/>
    <workgroup>IETF SOC Working Group</workgroup>

<keyword>SIP, Overload Control, Server, Performance</keyword>



<abstract><t> This specification defines a load-control event package
    for the Session Initiation Protocol (SIP). It allows SIP entities
    to distribute load-filtering policies to other SIP entities in the
    network. The load-filtering policies contain rules to throttle
    calls from a specific user or based on their source or destination domain, telephone number prefix. The mechanism helps to prevent signaling overload and complements feedback-based SIP overload control efforts. </t> </abstract>


</front>

<middle>

<section anchor='sec:intro' title="Introduction">

    <t> SIP load-control mechanisms are needed to prevent congestion collapse <xref target="RFC6357"/> in cases of SIP server overload <xref target="RFC5390"/>. There are two types of load-control approaches. In the first approach, feedback control, SIP servers provide load limits to upstream servers, to reduce the incoming rate of all SIP requests <xref target="SIP-OVERLOAD"/>. These upstream servers then drop or delay incoming SIP requests. Feedback control is reactive and affects signaling messages that have already been issued by user agent clients. This approach works well when SIP proxy servers in the core networks (core proxy servers) or destination-specific SIP proxy servers in the edge networks (edge proxy servers) are overloaded. By their nature, they need to distribute rate, drop, or window information to all upstream SIP proxy servers and normally affect all calls equally, regardless of destination. </t> 

    <t> This specification proposes an additional, complementary load-control mechanism, called "load filtering". It is most applicable for situations where a traffic surge and its source/destination distribution can be predicted in advance. In those cases, network operators create load-filtering policies that indicate calls to specific destinations or from specific sources should be rate-limited or randomly dropped. These load-filtering policies are then distributed to SIP servers and possibly SIP user agents that are likely to generate calls to the affected destinations or from the affected sources. Load filtering works best if it prevents calls as close to the originating user agent clients as possible. The applicability of SIP load filtering can also be extended beyond overload control, e.g., to implement service level agreement commitments. </t> 

</section>

<section anchor='sec:term' title="Conventions">
    <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
        "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
        and "OPTIONAL" in this document are to be interpreted as
        described in <xref target="RFC2119"/>.</t>
</section>


<section anchor='sec:overview' title="SIP Load-Filtering Overview">

<section anchor='sec:filtercontent' title="Load-Filtering Policy Format">

   <t> Load-filtering policies are specified by sets of rules. Each rule contains both load-filtering conditions and actions. The load-filtering conditions define identities of the targets to be filtered (<xref target="sec:identity"/>). For example, there are two typical resource limits in a possible overload situation, i.e., human destination limits (number of call takers) and node capacity limits. The load-filtering targets in these two cases can be the specific callee numbers or the destination domain corresponding to the overload. Load-filtering conditions also indicate the specific message type to be matched (<xref target="sec:method"/>), with which target SIP entity the filtering policy is associated (<xref target="sec:targetsipentity"/>), and the period of time when the filtering policy should be activated and deactivated (<xref target="sec:validity"/>). Load-filtering actions describe the desired control functions such as
   keeping the request rate below a specified level (<xref target="sec:action"/>). </t>  

</section>

<section anchor='sec:filtercompute' title="Load-Filtering Policy Computation">

    <t>When computing the load-filtering policies, one needs to take into consideration information such as overload time, scope and network topology, as well as service policies. It is also important to make sure that there is no resource allocation loop and that server capacity is allocated in a way that both prevents overload and maximizes effective throughput (commonly called goodput). In some cases, in order to better utilize system resources, it may be preferable to employ an algorithm that dynamically computes the load-filtering policies based on currently observed server load status, rather than using a purely static filtering policy assignment. The computation algorithm for load-filtering policies is beyond the scope of this specification. </t>

</section>

    <section anchor='sec:operation' title="Load-Filtering Policy Distribution"> 

        <t> For distributing load-filtering policies, this specification defines the SIP event package for load control, which is an "instantiation" of the generic SIP event notification framework <xref target="RFC6665"/>. This specification also defines the XML schema of a load-control document (<xref target="sec:loadctrlformat"/>), which is used to encode load-filtering policies. </t> 

        <t> In order for load-filtering policies to be properly distributed, each capable SIP entity in the network subscribes to the SIP load-control event package of each SIP entity to which it sends signaling requests. A SIP entity that accepts subscription requests is called a "notifier" (<xref target="sec:ntfprocsub"/>). Subscription is initiated and maintained during normal server operation. The subscription of neighboring SIP entities needs to be persistent, as described in Sections 4.1 and 4.2 of <xref target="RFC6665"/>. The refresh procedure is described in <xref target="sec:ntfgenntf"/> below.  Subscribers may terminate the subscription if they have not received notifications for an extended time period, and can resubscribe if they determine that signaling  with the notifier becomes active again. </t>

        <t> An example architecture is shown in <xref target="fig:scenario"/> to illustrate SIP load-filtering policy distribution. This scenario consists of two networks belonging to Service Provider A and Service Provider B, respectively. Each provider's network is made up of two SIP core proxy servers and four SIP edge proxy servers. The core proxy servers and edge proxy servers of Service Provider A are denoted as CPa1 to CPa2 and EPa1 to EPa4; the core proxy servers and edge proxy servers of Service Provider B are denoted as CPb1 to CPb2 and EPb1 to EPb4. </t> 

<figure anchor="fig:scenario" title="Example Network Scenario Using SIP Load-Control Event Package Mechanism">
    <artwork>
   +-----------+   +-----------+   +-----------+   +-----------+
   |           |   |           |   |           |   |           |
   |   EPa1    |   |   EPa2    |   |   EPa3    |   |   EPa4    |
   |           |   |           |   |           |   |           |
   +-----------+   +-----------+   +-----------+   +-----------+
           \         /                    \          /
            \       /                      \        /
             \     /                        \      /
           +-----------+                  +-----------+
           |           |                  |           |
           |   CPa1    |------------------|   CPa2    |
           |           |                  |           |
           +-----------+                  +-----------+
                 |                              |     
   Service       |                              |
   Provider A    |                              |
                 |                              |
  =================================================================
                 |                              |
   Service       |                              |
   Provider B    |                              |
                 |                              |
           +-----------+                  +-----------+
           |           |                  |           |
           |   CPb1    |------------------|   CPb2    |
           |           |                  |           |
           +-----------+                  +-----------+
             /      \                        /     \
            /        \                      /       \
           /          \                    /         \
   +-----------+   +-----------+   +-----------+   +-----------+
   |           |   |           |   |           |   |           |
   |   EPb1    |   |   EPb2    |   |   EPb3    |   |   EPb4    |
   |           |   |           |   |           |   |           |
   +-----------+   +-----------+   +-----------+   +-----------+
    </artwork>
</figure>           

<t>During the initialization stage, the proxy servers first identify all their outgoing signaling neighbors and subscribe to them. Service providers can provision neighbors, or the proxy servers can incrementally learn who their neighbors are by inspecting signaling messages that they send and receive.  Assuming all signaling relationships in <xref target="fig:scenario"/> are bidirectional, after this initialization stage, each proxy server will be subscribed to all its neighbors. </t> 

         <t> Case I: EPa1 serves a TV program hotline and decides to limit the total number of incoming calls to the hotline to prevent an overload. To do so, EPa1 sends a notification to CPa1 with the specific hotline number, time of activation, and total acceptable call rate. Depending on the load-filtering policy computation algorithm, CPa1 may allocate the received total acceptable call rate among its neighbors, namely, EPa2, CPa2, and CPb1, and notify them about the resulting allocation along with the hotline number and the activation time. CPa2 and CPb1 may perform further allocation among their own neighbors and notify the corresponding proxy servers. This process continues until all edge proxy servers in the network have been informed about the event and have proper load-filtering policies
   configured. </t>

         <t> In the above case, the network entity where load-filtering policy is first introduced is the SIP server providing access to the resource that creates the overload situation. In other cases, the network entry point of introducing load-filtering policy could also be an entity that hosts this resource. For example, an operator may host an application server that performs toll-free-number ("800 number") translation services. The application server itself may be a SIP proxy server or a SIP Back-to-Back User Agent (B2BUA). If one of the toll-free numbers hosted at the application server creates the overload condition, the load-filtering policies can be introduced from the application server and then propagated to other SIP proxy servers in the network. </t>

         <t> Case II: A hurricane affects the region covered by CPb2, EPb3, and EPb4. All three of these SIP proxy servers are overloaded. The rescue team determines that outbound calls are more valuable than inbound calls in this specific situation. Therefore, EPb3 and EPb4 are configured with load-filtering policies to accept more outbound calls than inbound calls. CPb2 may be configured the same way or receive dynamically computed load-filtering policies from EPb3 and EPb4. Depending on the load-filtering policy computation algorithm, CPb2 may also send out notifications to its outside neighbors, namely CPb1 and CPa2, specifying a limit on the acceptable rate of inbound calls to CPb2's responsible domain. CPb1 and CPa2 may subsequently notify their neighbors about limiting the calls to CPb2's area. The same process could continue until all edge proxy servers are notified and have load-filtering policies configured.  </t>

    <t> Note that this specification does not define the provisioning interface between the party who determines the load-filtering policy and the network entry point where the policy is introduced. One of the options for the provisioning interface is the Extensible Markup Language (XML) Configuration Access Protocol (XCAP) <xref target="RFC4825"/>. </t>  

</section>

<section anchor='sec:netusage' title="Applicable Network Domains">

<t> This specification MUST be applied inside a "Trust Domain". The concept of a Trust Domain is similar to that defined in <xref target="RFC3324"/> and <xref target="RFC3325"/>. A Trust Domain, for the purpose of SIP load filtering, is a set of SIP entities such as SIP proxy servers that are trusted to exchange load-filtering policies defined in this specification. In the simplest case, a Trust Domain is a network of SIP entities belonging to a single service provider who deploys it and accurately knows the behavior of those SIP entities. Such simple Trust Domains may be joined to form larger Trust Domains by bilateral agreements between the service providers of the SIP entities. </t>
    


<t>The key requirement of a Trust Domain for the purpose of SIP load
   filtering is that the behavior of all SIP entities within a given
   Trust Domain is known to comply to the following set of
   specifications.</t>

<t> <list style="symbols">
    <t>SIP entities in the Trust Domain agree on the mechanisms used to secure the communication among SIP entities within the Trust Domain.</t>
    <t>SIP entities in the Trust Domain agree on the manner used to determine which SIP entities are part of the Trust Domain. </t>
    <t>SIP entities in the Trust Domain are compliant to SIP <xref target="RFC3261"/>.</t>
    <t>SIP entities in the Trust Domain are compliant to SIP-Specific Event Notification<xref target="RFC6665"/>.</t>
    <t>SIP entities in the Trust Domain are compliant to this
      specification.</t> 
    <t>SIP entities in the Trust Domain agree on what types of calls can be affected by this SIP
      load-filtering mechanism.  For example, &lt;call-identity&gt; condition
      elements  (<xref target="sec:identity"/>) &lt;one> and &lt;many> might be
      limited to describe within certain prefixes.
</t>
    <t>SIP entities in the Trust Domain agree on the destinations to which calls may be redirected
      when the "redirect" action (<xref target="sec:action"/>) is used. For example, the URI might have to match a given set of domains.</t>
</list> </t>

<t>SIP load filtering is only effective if all neighbors that are possible signaling sources participate and enforce the designated load-filtering policies. Otherwise, a single non-conforming neighbor could make all filtering efforts useless by pumping in excessive traffic to overload the server. Therefore, the SIP server that distributes load-filtering policies needs to take countermeasures towards any non-conforming neighbors. A simple method is to reject excessive requests with 503 "Service Unavailable" response messages as if they were obeying the rate. Considering the rejection costs, a more complicated but fairer method would be to allocate at the overloaded server the same amount of processing to the combination of both normal processing and rejection as the overloaded server would devote to processing requests for a conforming upstream SIP server. These approaches work as long as the total rejection cost does not overwhelm the entire server resources. In addition, SIP servers need to handle message prioritization properly while performing load filtering, which is described in <xref target="sec:subprocntf"/>. </t>



</section>
    
</section>

<section anchor='sec:loadctrleventpkt' title="Load-Control Event Package">

    <t> The SIP load-filtering mechanism defines a load-control event package for SIP based on <xref target="RFC6665"/>. </t>

<section anchor='sec:epname' title="Event Package Name">

    <t> The name of this event package is "load-control". This name is carried in the Event and Allow-Events header, as specified in <xref target="RFC6665"/>. </t>

</section>

<section anchor='sec:epparameter' title="Event Package Parameters">

    <t> No package-specific event header field parameters are defined for this event package.</t>

</section>

<section anchor='sec:subbody' title="SUBSCRIBE Bodies">
    
    <t> This specification does not define the content of SUBSCRIBE bodies.  Future specifications could define bodies for SUBSCRIBE messages, for example, to request specific types of load-control event notifications. </t>

    <t> A SUBSCRIBE request sent without a body implies the default subscription behavior as specified in <xref target="sec:ntfgenntf"/>.  </t>

</section>

<section anchor='sec:subduration' title="SUBSCRIBE Duration">
    
    <t> The default expiration time for a subscription to load-filtering policy is one hour. Since the desired expiration time may vary significantly for subscriptions among SIP entities with different signaling relationships, the subscribers and notifiers are RECOMMENDED to explicitly negotiate appropriate subscription duration when knowledge about the mutual signaling relationship is available. </t>

</section>

<section anchor='sec:ntfbody' title="NOTIFY Bodies">
    
  <t> The body of a NOTIFY request in this event package contains load-filtering policies. The format of the NOTIFY request body MUST be in one of the formats defined in the Accept header field of the SUBSCRIBE request or be the default format, as specified in <xref target="RFC6665"/>. The default data format for the NOTIFY request body of this event package is "application/load-control+xml" (defined in <xref target="sec:loadctrlformat"/>). This means that when a NOTIFY request body exists but no Accept header field is specified in a SUBSCRIBE request, the NOTIFY request body MUST contain content conforming to the "application/load-control+xml" format. </t> 

</section>

<section anchor='sec:ntfprocsub' title="Notifier Processing of SUBSCRIBE Requests">
    
    <t> The notifier accepts a new subscription or updates an existing subscription upon receiving a valid SUBSCRIBE request. </t> 

    <t> If the identity of the subscriber sending the SUBSCRIBE request is not allowed to receive load-filtering policies, the notifier MUST return a 403 "Forbidden" response. </t>

    <t> If none of the media types specified in the Accept header of the SUBSCRIBE request are supported, the notifier SHOULD return a 406 "Not Acceptable" response. </t>
    
</section>

<section anchor='sec:ntfgenntf' title="Notifier Generation of NOTIFY Requests">

  <t> A notifier MUST send a NOTIFY request with its current load-filtering policy to the subscriber upon successfully accepting or refreshing a subscription. If no load-filtering policy needs to be distributed when the subscription is received, the notifier SHOULD sent a NOTIFY request without a body to the subscriber. The content-type header field of this NOTIFY request MUST indicate the correct body format as if the body were present (e.g., "application/load-control+xml"). Notifiers are likely to send NOTIFY requests without a body when a subscription is initiated for the first time, e.g., when a SIP entity is just introduced, because there may be no planned events that require load filtering at that time. A notifier SHOULD generate NOTIFY requests each time the load-filtering policy changes, with the maximum notification rate not exceeding values defined in <xref target="sec:ratentf"/>. </t> 
</section>

<section anchor='sec:subprocntf' title="Subscriber Processing of NOTIFY Requests">

    <t> The subscriber is the load-filtering server that enforces load-filtering policies received from the notifier. The way subscribers process NOTIFY requests depends on the load-filtering policies conveyed in the notifications. Typically, load-filtering policies consist of rules specifying actions to be applied to requests matching certain conditions. A subscriber receiving a notification first installs these rules and then enforces corresponding actions on requests matching those conditions, for example, limiting the sending rate of call requests destined for a specific callee. </t>
    
    <t> In the case when load-filtering policies specify a future validity, it is possible that when the validity time arrives, the subscription to the specific notifier that conveyed the rules has expired. In this case, it is RECOMMENDED that the subscriber re-activate its subscription with the corresponding notifier. Regardless of whether or not this re-activation of subscription is successful, when the validity time is reached, the subscriber SHOULD enforce the corresponding rules. </t> 
 
    <t> Upon receipt of a NOTIFY request with a Subscription-State header field containing the value "terminated", the subscription status with the particular notifier will be terminated. Meanwhile, subscribers MUST also terminate previously received load-filtering policies from that notifier. </t>

    <t> The subscriber MUST discard unknown bodies. If the NOTIFY request contains several bodies, none of them being supported, it SHOULD unsubscribe unless it has knowledge that it will possibly receive NOTIFY requests with supported bodies from that notifier. A NOTIFY request without a body indicates that no load-filtering policies need to be updated. </t>
        
    <t> When the subscriber enforces load-filtering policies, it needs to prioritize requests and select those requests that need to be rejected or redirected. This selection is largely a matter of local policy. It is expected that the subscriber will follow local policy as long as the result in reduction of traffic is consistent with the overload algorithm in effect at that node. Accordingly, the normative behavior described in the next three paragraphs should be interpreted with the understanding that the subscriber will aim to preserve local policy to the fullest extent possible.</t> 

<t> <list style="symbols">
<t> The subscriber SHOULD honor the local policy for prioritizing SIP requests such as policies based on message type, e.g., INVITEs versus requests associated with existing sessions. </t>
<t> The subscriber SHOULD honor the local policy for prioritizing SIP requests based on the content of the Resource-Priority header (RPH, <xref target="RFC4412"/>). Specific (namespace.value) RPH contents may indicate high-priority requests that should be preserved as much as possible during overload. The RPH contents can also indicate a low-priority request that is eligible to be dropped during times of overload. </t> 
<t> The subscriber SHOULD honor the local policy for prioritizing SIP requests relating to emergency calls as identified by the sos URN <xref target="RFC5031"/> indicating an emergency request.</t>  


</list> </t>

<t> A local policy can be expected to combine both the SIP request type and the prioritization markings and SHOULD be honored when overload conditions prevail. </t>

</section>

<section anchor='sec:hdlfork' title="Handling of Forked Requests">

    <t> Forking is not applicable when this load-control event package mechanism is used within a single-hop distance between neighboring SIP entities. If communication scope of the load-control event package mechanism is among multiple hops, forking is also not expected to happen because the subscription request is addressed to a clearly defined SIP entity. However, in the unlikely case when forking does happen, the load-control event package only allows the first potential dialog-establishing message to create a dialog, as specified in Section 5.4.9 of <xref target="RFC6665"/>. </t>


</section>

<section anchor='sec:ratentf' title="Rate of Notifications">

    <t>The rate of notifications is unlikely to be of concern for this local control event package mechanism when it is used in a non-real-time mode for relatively static load-filtering policies.
Nevertheless, if a situation does arise in which a rather frequently
used load filtering policy update is needed, it is RECOMMENDED that
the notifier not generate notifications at a rate higher than once per
second in all cases, in order to avoid the NOTIFY request itself
overloading the system.</t>


</section>

<section anchor='sec:statedelta' title="State Delta">
        
    <t> It is likely that updates to specific load-filtering policies are made by changing only part of the policy parameters (e.g., acceptable request rate or percentage, but not matching identities). This will typically be because the utilization of a resource subject to overload depends upon dynamic unknowns such as holding time and the relative distribution of offered loads over subscribing SIP entities. The updates could originate manually or be determined automatically by an algorithm that dynamically computes the load-filtering policies (<xref target="sec:filtercompute"/>). Another factor that is usually not known precisely or needs to be computed automatically is the duration of the event requiring load filtering. Therefore, it would also be common for the validity to change frequently. </t>

    <t> This event package allows the use of state delta as in <xref target="RFC6665"/> to accommodate frequent updates of partial policy parameters. For each NOTIFY transaction in a subscription, a version number that increases by exactly one MUST be included in the NOTIFY request body when the body is present. When the subscriber receives a state delta, it associates the partial updates to the particular policy by matching the appropriate rule id (<xref target="sec:ruleex"/>). If the subscriber receives a NOTIFY request with a version number that is increased by more than one, it knows that it has missed a state delta and needs to ask for a full state snapshot. Therefore, the subscriber ignores that NOTIFY request containing the state delta, and resends a SUBSCRIBE request to force a NOTIFY request containing a complete state snapshot. </t>  

</section>

</section>

<section anchor='sec:loadctrlformat' title="Load-Control Document">

    <section anchor='sec:format' title="Format">

        <t> A load-control document is an XML document that describes the load-filtering policies. It inherits and enhances the common policy document defined in <xref target="RFC4745"/>. A common policy document contains a set of rules. Each rule consists of three parts: conditions, actions, and transformations. The conditions part is a set of expressions containing attributes such as identity, domain, and validity time information. Each expression evaluates to TRUE or FALSE. Conditions are matched on "equality" or "greater than" style comparison. There is no regular expression matching. Conditions are evaluated on receipt of an initial SIP request for a dialog or standalone transaction. If a request matches all conditions in a rule set, the action part and the transformation part are consulted to determine the "permission" on how to handle the request. Each action or transformation specifies a positive grant to the policy server to perform the resulting actions. Well-defined mechanism are available for combining actions and transformations obtained from more than one sources. </t>

    </section>

    <section anchor='sec:namespace' title="Namespace">

        <t> The namespace URI for elements defined by this specification is a Uniform Resource Namespace (URN) (<xref target="RFC2141"/>), using the namespace identifier "ietf" defined by <xref target="RFC2648"/> and extended by <xref target="RFC3688"/>. The URN is as follows: </t>
            
        <t> urn:ietf:params:xml:ns:load-control </t>

    </section>

    <section anchor='sec:condition' title="Conditions ">

        <t> <xref target="RFC4745"/> defines three condition elements: &lt;identity>, &lt;sphere>, and &lt;validity>. This specification defines new condition elements and reuses the &lt;validity> element. The &lt;sphere> element is not used. </t>

        <section anchor='sec:identity' title="Call Identity">

<t> Since the problem space of this specification is different from that of <xref target="RFC4745"/>, the <xref target="RFC4745"/> &lt;identity> element is not sufficient for use with load filtering. First, load filtering may be applied to different identities contained in a request, including identities of both the receiving entity and the sending entity. Second, the importance of authentication varies when different identities of a request are concerned. This specification defines new identity conditions that can accommodate the granularity of specific SIP identity header fields. The requirement for authentication depends on which field is to be matched. </t>

<t> The identity condition for load filtering is specified by the &lt;call&nbhy;identity> element and its sub-element &lt;sip>. The &lt;sip> element itself contains sub-elements representing SIP sending and receiving identity header fields: &lt;from>, &lt;to>, &lt;request-uri>, and &lt;p&nbhy;asserted&nbhy;identity>. All those sub-elements are of an extended form of the <xref target="RFC4745"/> &lt;identity> element. In addition to the sub-elements including &lt;one>, &lt;except>, and &lt;many> in the &lt;identity> element from <xref target="RFC4745"/>, the extended form adds two new sub-elements, namely, &lt;many-tel> and &lt;except-tel>, which will be explained later in this section.</t>


<t> The <xref target="RFC4745"/> &lt;one> and &lt;except> elements may contain an "id" attribute, which is the URI of a single entity to be included or excluded in the condition. When used in the &lt;from>, &lt;to>, &lt;request&nbhy;uri>, and &lt;p-asserted-identity> elements, this "id" value is the URI contained in the corresponding SIP header field, i.e., From, To, Request-URI, and P-Asserted-Identity. </t>

<t> When the &lt;call-identity> element contains multiple &lt;sip> sub-elements, the result is combined using logical OR. When the &lt;from>, &lt;to>, &lt;request-uri>, and &lt;p-asserted-identity> elements contain multiple &lt;one>, &lt;many>, or &lt;many-tel> sub-elements, the result is also combined using logical OR. When the &lt;many> sub-element further contains one or more &lt;except> sub-elements, or when the &lt;many-tel> sub-element further contains one or more &lt;except-tel> sub-elements, the result of each &lt;except> or &lt;except-tel> sub-element is combined using a logical OR, similar to that of the <xref target="RFC4745"/> &lt;identity> element. However, when the &lt;sip> element contains multiple &lt;from>, &lt;to>, &lt;request-uri>, and &lt;p-asserted-identity> sub-elements, the result is combined using logical AND. This allows the call identity to be specified by multiple fields of a SIP request simultaneously, e.g., both the From and the To header fields. </t>     

<t> The following shows an example of the &lt;call-identity> element, which matches call requests whose To header field contains the SIP URI "sip:alice@hotline.example.com" or the 'tel' URI "tel:+1-212-555-1234".</t>

<figure>
    <artwork>
            &lt;call-identity>
                &lt;sip>
                    &lt;to>
                        &lt;one id="sip:alice@hotline.example.com"/>
                        &lt;one id="tel:+1-212-555-1234"/>
                    &lt;/to>
                &lt;/sip>
            &lt;/call-identity>
    </artwork>
</figure>


<t> Before evaluating &lt;call-identity&gt; conditions, the subscriber shall convert URIs received in SIP header fields in canonical form as per <xref target="RFC3261"/>, except that the "phone-context" parameter shall not be removed, if present. </t>

<t> The <xref target="RFC4745"/> &lt;many> and &lt;except> elements may take a "domain" attribute. The "domain" attribute specifies a domain name to be matched by the domain part of the candidate identity. Thus, it allows matching a large and possibly unknown number of entities within a domain. The "domain" attribute works well for SIP URIs. </t>

<t> A URI identifying a SIP user, however, can also be a 'tel' URI. Therefore, a similar way to match a group of 'tel' URIs is needed. There are two forms of 'tel' URIs: for global numbers and local numbers. According to <xref target="RFC3966"/>, "All phone numbers MUST use the global form unless they cannot be represented as such...Local numbers MUST be tagged with a 'phone-context'". The global number 'tel' URIs start with a "+". The "phone-context" parameter of local numbers may be labeled as a global number or any number of its leading digits or a domain name. Both forms of the 'tel' URI make the resulting URI globally unique. </t>
                 
                <t> 'tel' URIs of global numbers can be grouped by prefixes consisting of any number of common leading digits. For example, a prefix formed by a country code or both the country and area code identifies telephone numbers within a country or an area. Since the length of the country and area code for different regions are different, the length of the number prefix also varies. This allows further flexibility such as grouping the numbers into sub-areas within the same area code. 'tel' URIs of local numbers can be grouped by the value of the "phone&nbhy;context" parameter. </t>   

<t> The &lt;many> and &lt;except> sub-elements in the &lt;identity> element of <xref target="RFC4745"/> do not allow additional attributes to be added directly. Redefining behavior of their existing "domain" attribute creates backward-compatibility issues. Therefore, this specification defines the &lt;many-tel> and &lt;except-tel> sub-elements that extend the <xref target="RFC4745"/> &lt;identity> element. Both of them have a "prefix" attribute for grouping 'tel' URIs, similar to the "domain" attribute for grouping SIP URIs in existing &lt;many> and &lt;except> sub-elements. For global numbers, the "prefix" attribute value holds any number of common leading digits, for example, "+1-212" for US phone numbers within area code "212" or "+1-212-854" for the organization with US area code "212" and local prefix "854". For local numbers, the "prefix" attribute value contains the "phone-context" parameter value. It should be noted that visual separators (such as the "-" sign) in 'tel' URIs are not used for URI comparison as per <xref target="RFC3966"/>. </t>   

    <t> The following example shows the use of the "prefix" attribute along with the "domain" attribute. It matches those requests calling to the number "+1-202-999-1234" but are not calling from a "+1-212" prefix or a SIP From URI domain of "manhattan.example.com". </t>

<figure>
    <artwork>
            &lt;call-identity>
                &lt;sip>
                    &lt;from>
                        &lt;many> 
                            &lt;except domain="manhattan.example.com"/>
                        &lt;/many>
                        &lt;many-tel>
                            &lt;except-tel prefix="+1-212"/>
                        &lt;/many-tel>
                    &lt;/from>
                    &lt;to>
                        &lt;one id="tel:+1-202-999-1234"/>
                    &lt;/to>
                &lt;/sip>
            &lt;/call-identity>
    </artwork>
</figure>

    </section>

<section anchor='sec:method' title='Method'>

   <t> The load created on a SIP server depends on the type of initial SIP requests for dialogs or standalone transactions. The &lt;method> element specifies the SIP method to which the load-filtering action applies. When this element is not included, the load-filtering actions are applicable to all applicable initial requests. These requests include INVITE, MESSAGE, REGISTER, SUBSCRIBE, OPTIONS, and PUBLISH. Non-initial requests, such as ACK, BYE, and CANCEL MUST NOT be subjected to load filtering. In addition, SUBSCRIBE requests are not filtered if the event-type header field indicates the event package defined in this specification. </t>

        <t> The following example shows the use of the &lt;method> element in the case the filtering actions should be applied to INVITE requests. </t>

<figure>
    <artwork>
  	    &lt;method>INVITE&lt;/method>
    </artwork>
</figure>

    </section>

<section anchor='sec:targetsipentity' title='Target SIP Entity'>

   <t> A SIP server that performs load-filtering may have multiple paths to route call requests matching the same set of call identity elements. In those situations, the SIP load-filtering server may desire to take advantage of alternative paths and only apply load-filtering actions to matching requests for the next-hop SIP entity that originated the corresponding load-filtering policy. To achieve that, the SIP load-filtering server needs to associate every load-filtering policy with its originating SIP entity. The &lt;target-sip-entity> element is defined for that purpose, and it contains the URI of the entity that initiated the load-filtering policy, which is generally the corresponding notifier. A notifier MAY include this element as part of the condition of its filtering policy being sent to the subscriber, as below. </t>
      
<figure>
    <artwork>
&lt;target-sip-entity>sip:biloxi.example.com&lt;/target-sip-entity>
    </artwork>
</figure>
      
<t> When a SIP load-filtering server receives a policy with a &lt;target&nbhy;sip&nbhy;entity> element, it SHOULD record it and take it into consideration when making load-filtering decisions. If the load-filtering server receives a load-filtering policy that does not contain a &lt;target-sip-entity> element, it MAY still record the URI of the load-filtering policy's originator as the &lt;target-sip-entity> information and consider it when making load-filtering decisions. </t>

<t> <list style="empty">

    <t> The following are two examples of using the &lt;target-sip-entity> element. </t>
    
    <t> Use case I: The network has user A connected to SIP Proxy 1 (SP1), user B connected to SIP Proxy 3 (SP3), SP1 and SP3 connected via SIP Proxy 2 (SP2), and SP2 connected to an Application Server (AS). Under normal load conditions, a call from A to B is routed along the following path: A-SP1-SP2-AS-SP3-B.&nbsp; The AS provides a nonessential service and can be bypassed in case of overload. Now let's assume that AS is overloaded and sends to SP2 a load-filtering policy requesting that 50% of all INVITE requests be dropped. SP2 can maintain AS as the &lt;target-sip-entity> for that policy so that it knows the 50% drop action is only applicable to call requests that must go through AS, without affecting those calls directly routed through SP3 to B. </t>
      
    <t> Use case II: A translation service for toll-free numbers is installed on two Application Servers, AS1 and AS2. User A is connected to SP1 and calls 800-1234-4529, which is translated by AS1 and AS2 into a regular E.164 number depending on, e.g., the caller's location. SP1 forwards INVITE requests with Request-URI = "800 number" to AS1 or AS2 based on a load-balancing strategy. As calls to 800-1234-4529 create a pre-overload condition in AS1, AS1 sends to SP1 a load-filtering policy requesting that 50% of calls towards 800-1234-4529 be rejected. In this case, SP1 can maintain AS1 as the &lt;target-sip-entity> for the rule, and only apply the load-filtering policy on incoming requests that are intended to be sent to AS1. Those requests that are sent to AS2, although matching the &lt;call-identity> of the filter, will not be affected. </t>

</list> </t>

    </section>

    <section anchor='sec:validity' title='Validity'>

        <t> A filtering policy is usually associated with a validity period condition. This specification reuses the &lt;validity> element of <xref target="RFC4745"/>, which specifies a period of validity time by pairs of &lt;from> and &lt;until> sub-elements. When multiple time periods are defined, the validity condition is evaluated to TRUE if the current time falls into any of the specified time periods. That is, it represents a logical OR operation across all validity time periods. </t>

        <t> The following example shows a &lt;validity> element specifying a valid period from 12:00 to 15:00 US Eastern Standard Time on 2008-05-31. </t> 

<figure>
    <artwork>
            &lt;validity>
                &lt;from>2008-05-31T12:00:00-05:00&lt;/from>
                &lt;until>2008-05-31T15:00:00-05:00&lt;/until>
            &lt;/validity>
    </artwork>
</figure>


    </section>

</section>

<section anchor='sec:action' title='Actions'>

  <t> The actions a load-filtering server takes on loads matching the load-filtering conditions are defined by the &lt;accept> element in the load-filtering policy, which includes any one of the three sub-elements &lt;rate>, &lt;percent>, and &lt;win>. The &lt;rate> element denotes an absolute value of the maximum acceptable request rate in requests per second; the &lt;percent> element specifies the relative percentage of incoming requests that should be accepted; the &lt;win> element describes the acceptable window size supplied by the receiver, which is applicable in window-based load-filtering. In static load-filtering policy configuration scenarios, using the &lt;rate> sub-element is RECOMMENDED because it is hard to enforce the percentage rate or window-based load filtering when incoming load from upstream or reactions from downstream are uncertain. (See <xref target="SIP-OVERLOAD"/> and <xref target="RFC6357"/> for more details on rate-based, loss-based, and window-based load control.)</t>

  <t> In addition, the &lt;accept> element takes an optional "alt-action" attribute that can be used to explicitly specify the desired action in case a request cannot be processed. The "alt-action" can take one of the following three values: "reject", "redirect", or "drop".</t> 
    
<t> <list style="symbols">
    
    <t>The "reject" action is the default value for "alt-action". It means that the load-filtering server will reject the request with a 503 "Service Unavailable" response message. </t>
    
    <t> The "redirect" action means redirecting the request to another target. When it is used, an "alt-target" attribute MUST be defined. The "alt-target" specifies one URI or a list of URIs where the request should be redirected. The server sends out the redirect URIs in a 300-class response message. </t>

    <t> The "drop" action means simply ignoring the request without doing anything, which can, in certain cases, help save processing capability during overload. For example, when SIP is running over a reliable transport such as TCP, the "drop" action does not send out the rejection response, neither does it close the transport connection. However, when running SIP over an unreliable transport such as UDP, using the "drop" action will create message retransmissions that further worsen the possible overload situation. Therefore, any "drop" action applied to an unreliable transport MUST be treated as if it were "reject". </t>

</list> </t>

    <t> The above "alt-action" processing can also be illustrated through the following pseudocode. </t>

<figure>
    <artwork>
        SWITCH "alt-action" 
          "redirect": "redirect" 
          "drop":
            IF unreliable-transport
              THEN treat as "reject"
            ELSE
              "drop"
          "reject": "reject" 
          default: "reject"
        END
    </artwork>
</figure>

<t> In the following &lt;actions> element example, the server accepts maximum of 100 call requests per second. The remaining calls are redirected to an answering machine. </t> 

<figure>
    <artwork>
        &lt;actions>
            &lt;accept alt-action="redirect" alt-target=
                    "sip:answer-machine@example.com">
                &lt;rate>100&lt;/rate>
            &lt;/accept>
        &lt;/actions>
    </artwork>
</figure>


    </section>


</section>



        <section anchor='sec:schema' title="XML Schema Definition for Load Control">

          <t> This section defines the XML schema for the load-control
          document. It extends the Common Policy schema in
          <xref target="RFC4745"/> in two ways. Firstly, it defines
          two mandatory attributes for the &lt;ruleset> element:
          "version" and "state". The "version" attribute allows the
          recipient of the notification to properly order
          them. Versions start at zero and increase by one for each new document sent to a subscriber within the same subscription. Versions MUST be representable using a non-negative 32-bit integer. The "state" attribute indicates whether the document contains a full load-filtering policy update or only state delta as partial update. Secondly, it defines new members of the &lt;conditions> and &lt;actions> elements. </t>

    <figure> 
    <artwork>
&lt;?xml version="1.0" encoding="UTF-8"?> 
&lt;xs:schema targetNamespace="urn:ietf:params:xml:ns:load-control" 
    xmlns:lc="urn:ietf:params:xml:ns:load-control" 
    xmlns:cp="urn:ietf:params:xml:ns:common-policy" 
    xmlns:xs="http://www.w3.org/2001/XMLSchema" 
    elementFormDefault="qualified" 
    attributedFormDefault="unqualified"> 

&lt;xs:import namespace="urn:ietf:params:xml:ns:common-policy"/>

&lt;!-- RULESET -->

&lt;xs:element name="ruleset">
  &lt;xs:complexType>
    &lt;xs:complexContent>
      &lt;xs:restriction base="xs:anyType">
        &lt;xs:sequence>
          &lt;xs:element name="rule" type="cp:ruleType"
          minOccurs="0" maxOccurs="unbounded"/>
        &lt;/xs:sequence>
      &lt;/xs:restriction>
    &lt;/xs:complexContent>
    &lt;xs:attribute name="version" type="xs:integer" use="required"/>
    &lt;xs:attribute name="state" use="required">
      &lt;xs:simpleType>
        &lt;xs:restriction base="xs:string">
          &lt;xs:enumeration value="full"/>
          &lt;xs:enumeration value="partial"/>
        &lt;/xs:restriction>
      &lt;/xs:simpleType>
    &lt;/xs:attribute> 
  &lt;/xs:complexType>
&lt;/xs:element>

&lt;!-- CONDITIONS -->

&lt;!-- CALL IDENTITY -->
&lt;xs:element name="call-identity" type="lc:call-identity-type"/>

&lt;!-- CALL IDENTITY TYPE -->
&lt;xs:complexType name="call-identity-type">
  &lt;xs:choice>
    &lt;xs:element name="sip" type="lc:sip-id-type"/>
    &lt;any namespace="##other" processContents="lax" minOccurs="0" 
    maxOccurs="unbounded"/>
  &lt;/xs:choice>
  &lt;anyAtrribute namespace="##other" processContents="lax"/>
&lt;/xs:complexType>

&lt;!-- SIP ID TYPE -->
&lt;xs:complexType name="sip-id-type">
  &lt;xs:sequence>
    &lt;element name="from" type="lc:identityType" minOccurs="0"/>
    &lt;element name="to" type="lc:identityType" minOccurs="0"/>
    &lt;element name="request-uri" type="lc:identityType" 
    minOccurs="0"/>
    &lt;element name="p-asserted-identity" type="lc:identityType" 
    minOccurs="0"/>
    &lt;any namespace="##other" processContents="lax" minOccurs="0" 
    maxOccurs="unbounded"/>
  &lt;/xs:sequence>
  &lt;anyAtrribute namespace="##other" processContents="lax"/>
&lt;/xs:complexType>

&lt;!-- IDENTITY TYPE -->
&lt;xs:complexType name="identityType">
  &lt;xs:complexContent>
    &lt;xs:restriction base="xs:anyType">
      &lt;xs:choice minOccurs="1" maxOccurs="unbounded">
        &lt;xs:element name="one" type="cp:oneType"/>
        &lt;xs:element name="many" type="lc:manyType"/>
        &lt;xs:element name="many-tel" type="lc:manyTelType"/>
        &lt;xs:any namespace="##other" processContents="lax"/>
      &lt;/xs:choice>
    &lt;/xs:restriction>
  &lt;/xs:complexContent>
&lt;/xs:complexType>

&lt;!-- MANY-TEL TYPE -->
&lt;xs:complexType name="manyTelType">
  &lt;xs:complexContent>
    &lt;xs:restriction base="xs:anyType">
      &lt;xs:choice minOccurs="0" maxOccurs="unbounded">
        &lt;xs:element name="except-tel" type="lc:exceptTelType"/>
        &lt;xs:any namespace="##other"
        minOccurs="0" processContents="lax"/>
      &lt;/xs:choice>
      &lt;xs:attribute name="prefix"
      use="optional" type="xs:string"/>
    &lt;/xs:restriction>
  &lt;/xs:complexContent>
&lt;/xs:complexType>

&lt;!-- EXCEPT-TEL TYPE -->
&lt;xs:complexType name="exceptTelType">
  &lt;xs:attribute name="prefix" type="xs:string" use="optional"/>
  &lt;xs:attribute name="id" type="xs:anyURI" use="optional"/>
&lt;/xs:complexType>

&lt;!-- METHOD -->
&lt;xs:element name="method" type="lc:method-type"/>

&lt;!-- METHOD TYPE -->
&lt;xs:simpleType name="method-type">
  &lt;xs:restriction base="xs:string">
    &lt;xs:enumeration value="INVITE"/>
    &lt;xs:enumeration value="MESSAGE"/>
    &lt;xs:enumeration value="REGISTER"/>
    &lt;xs:enumeration value="SUBSCRIBE"/>
    &lt;xs:enumeration value="OPTIONS"/>
    &lt;xs:enumeration value="PUBLISH"/>
  &lt;/xs:restriction>
&lt;/xs:simpleType>

&lt;!-- TARGET SIP ENTITY -->
&lt;xs:element name="target-sip-entity" type="xs:anyURI" minOccurs="0"/>

&lt;!-- ACTIONS -->
&lt;xs:element name="accept">
  &lt;xs:choice>
    &lt;element name="rate" type="xs:decimal" minOccurs="0"/>
    &lt;element name="win" type="xs:integer" minOccurs="0"/>
    &lt;element name="percent" type="xs:decimal" minOccurs="0"/>
    &lt;any namespace="##other" processContents="lax" minOccurs="0" 
    maxOccurs="unbounded"/>
  &lt;/xs:choice>
  &lt;xs:attribute name="alt-action" type="xs:string" default="reject"/>
  &lt;xs:attribute name="alt-target" type="lc:alt-target-type" 
  use="optional"/>
  &lt;anyAtrribute namespace="##other" processContents="lax"/>
&lt;/xs:element>

&lt;!-- ALT TARGET TYPE -->
&lt;xs:simpleType name="alt-target-type">
  &lt;xs:list itemType="xs:anyURI"/>
&lt;/xs:simpleType>

&lt;/xs:schema>
    </artwork>
    </figure>
        
    </section>


<section anchor='sec:security' title="Security Considerations">

    <t> Two primary security considerations arise from this
    specification. One is the distribution mechanism for the load
    filtering policy that is based on the SIP event
    notification framework, and the other
    is the enforcement mechanism for the load-filtering policy. </t>

    <t> Security considerations for SIP event package mechanisms are covered in Section 6 of <xref target="RFC6665"/>. A particularly relevant security concern for this event package is that if the notifiers can be spoofed, attackers can send fake notifications asking subscribers to throttle all traffic, leading to denial-of-service (DoS) attacks. Therefore, this SIP load-filtering mechanism MUST be used in a Trust Domain (<xref target="sec:netusage"/>). But if a legitimate notifier in the Trust Domain is itself compromised, additional mechanisms will be needed to detect the attack.</t>

    <t> Security considerations for load-filtering policy enforcement depends very much on the contents of the policy. This specification defines a possible match of the following SIP header fields in a load-filtering policy: &lt;from>, &lt;to>, &lt;request-uri>, and &lt;p&nbhy;asserted&nbhy;identity>. The exact requirement to authenticate and authorize these fields is up to the service provider. In general, if the identity field represents the source of the request, it SHOULD be authenticated and authorized; if the identity field represents the destination of the request, the authentication and authorization is optional. </t>  

    <t>In addition, the "redirect" action (<xref target="sec:action"/>) could facilitate a reflection denial-of-service attack. If 
 a number of SIP proxy servers in a Trust Domain are using UDP and
 configured to get their policies from a central server. An attacker
 spoofs the central server's address to send a number of NOTIFY bodies
 telling the proxy servers to redirect all calls to
 victim@outside-of-trust-domain.com. The proxy servers then redirect
 all calls to the victim, who then becomes a victim of Denial of Service attack and becomes inaccessiable from the Internet.  To address this type of threat, this specification requires that a Trust Domain agrees on what types of calls can be affected as well as on the destinations to which calls may be redirected, as in <xref target="sec:netusage"/>.</t>
    
</section>

<section anchor='sec:iana' title="IANA Considerations">

    <t> This specification registers a SIP event package, a new media type, a new XML namespace, and a new XML schema. </t>

    <section anchor='sec:pkgreg' title="Load-Control Event Package Registration">

        <t> This section registers an event package based on the registration procedures defined in <xref target="RFC6665"/>. </t>

        <t> Package name: load-control </t>

        <t> Type: package </t>

        <t> Published specification: This specification </t>

        <t> Person to contact: Charles Shen, charles@cs.columbia.edu </t>

    </section>


    <section anchor='sec:mimereg' title="application/load-control+xml Media Type Registration">

        <t> This section registers a new media type based on the procedures defined in <xref target="RFC6838"/> and guidelines in <xref target="RFC3023"/>. </t>

<t> Type name: application </t>

<t> Subtype name: load-control+xml </t>

<t> Required parameters: none </t>

<t> Optional parameters: Same as charset parameter of application/xml as specified in <xref target="RFC3023"/>. </t>

<t> Encoding considerations: Same as encoding considerations of application/xml as specified in <xref target="RFC3023"/>. </t>

<t> Security considerations: See Section 10 of <xref target="RFC3023"/> and <xref target="sec:security"/> of this specification. </t>

<t> Interoperability considerations: none </t>

<t> Published specification: This specification </t>

<t> Applications that use this media type: Applications that perform load control of SIP entities. </t>

<t> Fragment identifier considerations: Same as fragment identifier considerations of application/xml as specified in <xref target="RFC3023"/>. </t>

<t> Additional Information: </t>

<t> <list style="empty">
  <t> Deprecated alias names for this type: none </t>
  <t> Magic Number(s): none </t>
  <t> File Extension(s): .xml </t>
  <t> Macintosh file type code(s): "TEXT" </t>
</list> </t> 

<t> Person and email address for further information: Charles Shen, charles@cs.columbia.edu </t>

<t> Intended usage: COMMON </t>

<t> Restrictions on usage: none </t>

<t> Author: Charles Shen, Henning Schulzrinne, Arata Koike </t>

<t> Change controller: IESG </t>

<t> Provisional registration? (standards tree only): no </t>

    </section>

    <section anchor='sec:nsreg' title="URN Sub-Namespace Registration">
      <t> This section registers a new XML namespace, as per the guidelines in <xref target="RFC3688"/></t>

      <t> URI: The URI for this namespace is </t>

        <t> <list style="empty">
                 <t> urn:ietf:params:xml:ns:load-control</t>
        </list> </t>

            <t> Registrant Contact: IETF SOC Working Group &lt;sip-overload@ietf.org>, as designated by the IESG &lt;iesg@ietf.org> </t>
            <t> XML:</t>

<figure>
    <artwork>
BEGIN 
&lt;?xml version="1.0"?> 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.0//EN" 
             "http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd"> 
&lt;html xmlns="http://www.w3.org/1999/xhtml"> 
&lt;head> 
  &lt;meta http-equiv="content-type" 
    content="text/html;charset=iso-8859-1"/> 
  &lt;title>SIP Load-Control Namespace&lt;/title> 
&lt;/head> 
&lt;body> 
  &lt;h1>Namespace for SIP Load Control&lt;/h1> 
  &lt;h2>urn:ietf:params:xml:ns:load-control&lt;/h2> 
  &lt;p>See &lt;a href="http://www.rfc-editor.org/rfc/rfc7200.txt"> 
      RFC 7200&lt;/a>.&lt;/p> 
&lt;/body> 
&lt;/html> 
END 
         </artwork>
      </figure>

    </section>

    <section anchor='sec:schemareg' title="Load-Control Schema Registration">

        <t> URI: urn:ietf:params:xml:schema:load-control </t>

        <t> Registrant Contact: IETF SOC working group, Charles Shen (charles@cs.columbia.edu). </t>

        <t> XML: the XML schema contained in
        <xref target="sec:schema"/> has been registered.</t>
        <t> Its first line is </t>

        <t> &lt;?xml version="1.0" encoding="UTF-8"?> </t>

        <t> and its last line is </t>

        <t> &lt;/xs:schema> </t>

    </section>

</section>

<section anchor='sec:ack' title="Acknowledgements">

   <t> The authors would like to thank Jari Arkko, Richard Barnes, Stewart Bryant, Gonzalo Camarillo, Bruno Chatras, Benoit Claise, Spencer Dawkins, Martin Dolly, Keith Drage, Ashutosh Dutta, Donald Eastlake, Adrian Farrel, Stephen Farrell, Janet Gunn, Vijay Gurbani, Brian Haberman, Volker Hilt, Geoff Hunt, Carolyn Johnson, Hadriel Kaplan, Paul Kyzivat, Barry Leiba, Pearl Liang, Salvatore Loreto, Timothy Moran, Eric Noel, Parthasarathi R, Pete Resnick, Adam Roach, Dan Romascanu, Shida Schubert, Robert Sparks, Martin Stiemerling, Sean Turner, Phil Williams, and other members of the SOC and SIPPING working groups for many helpful comments. In particular, Bruno Chatras proposed the &lt;method> and &lt;target-sip-entity> condition elements along with many other text improvements. Janet Gunn provided detailed text suggestions including <xref target="sec:reqmatch"/>. Eric Noel suggested clarification on load-filtering policy distribution initialization process. Shida Schubert made many suggestions such as terminology usage. Phil Williams suggested adding support for delta updates. Ashutosh Dutta gave pointers to Public Switched Telephone Network (PSTN) references. Adam Roach suggested improvements
   related to RFC 6665 and offered other helpful clarifications.  Richard Barnes made many suggestions such as referencing the Trust Domain concept of RFCs 3324 and 3325, the use of a separate element for 'tel' URI grouping, and addressing the "redirect" action security threat. </t> 

</section> 




    </middle>

    <back>
        <references title='Normative References'>
        &rfc3261;
        &rfc6665;
        &rfc6838;
        &rfc4745;
        &rfc3023;
        &rfc2141;
        &rfc3688;
        &rfc2119;
        &rfc3966;
        </references>
        <references title='Informative References'>
        &rfc3324;
        &rfc3325;
        &rfc2648;
        &rfc4825;
        &rfc4412;
        &rfc5031;
        &rfc5390;

<!-- draft-ietf-soc-overload-control; Approved - announcement to be sent-->
<reference anchor='SIP-OVERLOAD'>
<front>
<title>Session Initiation Protocol (SIP) Overload Control</title>

<author initials='V' surname='Gurbani' fullname='Vijay Gurbani' role='editor'>
    <organization />
</author>

<author initials='V' surname='Hilt' fullname='Volker Hilt'>
    <organization />
</author>

<author initials='H' surname='Schulzrinne' fullname='Henning Schulzrinne'>
    <organization />
</author>

<date month='March' day='3' year='2014' />

<abstract><t>Overload occurs in Session Initiation Protocol (SIP) networks when SIP servers have insufficient resources to handle all SIP messages they receive.  Even though the SIP protocol provides a limited overload control mechanism through its 503 (Service Unavailable) response code, SIP servers are still vulnerable to overload.  This document defines the behaviour of SIP servers involved in overload control, and in addition, it specifies a loss-based overload scheme for SIP.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

        &rfc6357;
        <reference anchor="Q.1248.2" target="">
        <front>
            <title>Interface Recommendation for Intelligent Network Capability Set4:SCF-SSF interface</title>
            <author>
                <organization>ITU-T</organization>
            </author>
            <date month="July" year="2001" />
        </front>
        <seriesInfo name="Recommendation" value="Q.1248.2" />
        </reference>

        <reference anchor="E.412" target="">
        <front>
            <title>Network Management Controls</title>
            <author>
                <organization>ITU-T</organization>
            </author>
            <date month="January" year="2003" />
        </front>
        <seriesInfo name="Recommendation" value="E.412-2003" />
        </reference>

        <reference anchor="E.300SerSup3" target="">
        <front>
            <title>North American Precise Audible Tone Plan</title>
            <author>
                <organization>ITU-T</organization>
            </author>
            <date month="November" year="1988" />
        </front>
        <seriesInfo name="Recommendation E.300" value="Series Supplement 3" />
        </reference>

        </references>



<section anchor='sec:definition' title="Definitions">

<t> This specification reuses the definitions for "Event Package", "Notification", "Notifier", "Subscriber", and "Subscription" as in <xref target="RFC6665"/>. The following additional definitions are also used.</t>
  <t> <list style='hanging'>
  <t hangText="Load Filtering:"> A load-control mechanism that applies specific actions to selected loads (e.g., SIP requests) matching specific conditions. </t>
  <t hangText="Load-Filtering Policy:"> A set of zero or more load-filtering rules, also known as load-filtering rule set. </t> 
  <t hangText="Load-Filtering Rule:"> Conditions and actions to be applied for load filtering. </t>
  <t hangText="Load-Filtering Condition:"> Elements that describe how to select loads to apply load-filtering actions. This specification defines the &lt;call-identity>, &lt;method>, &lt;target-sip-identity>, and &lt;validity> condition elements (<xref target="sec:condition"/>). </t>
  <t hangText="Load-Filtering Action:">  An operation to be taken by a load-filtering server on loads that match the load-filtering conditions. This specification allows actions such as accept, reject, and redirect of loads (<xref target="sec:action"/>). </t>
  <t hangText="Load-Filtering Server:"> A server that performs load filtering. In the context of this specification, the load-filtering server is the subscriber, which receives load-filtering policies from the notifier and enforces those policies during load filtering. </t>
  <t hangText="Load-Control Document:"> An XML document that describes the load-filtering policies (<xref target="sec:loadctrlformat"/>). It inherits and enhances the common policy document defined in <xref target="RFC4745"/>. </t>
</list> </t>
</section>

<section anchor='sec:requirement' title="Design Requirements">

<t> The SIP load-filtering mechanism needs to satisfy the following requirements: </t>

<t> <list style="symbols">

<t> For simplicity, the solution should focus on a method for controlling SIP load, rather than a generic application-layer mechanism. </t>

<t> The load-filtering policy needs to be distributed efficiently to possibly a large subset of all SIP elements. </t>

<t> The solution should reuse existing SIP protocol mechanisms to reduce implementation and deployment complexity. </t>

<t> For predictable overload situations, such as holidays and mass calling events, the load-filtering policy should specify during what time it is to be applied, so that the information can be distributed ahead of time. </t>

<t> For destination-specific overload situations, the load-filtering policy should be able to describe the destination domain or the callee. </t>

<t> To address accidental and intentional high-volume call generators, the load-filtering policy should be able to specify the caller. </t>

<t> Caller and callee need to be specified as both SIP URIs and 'tel' URIs <xref target="RFC3966"/> in load-filtering policies. </t>

<t> It should be possible to specify particular information in the SIP headers (e.g., prefixes in telephone numbers) that allow load filtering over limited regionally focused overloads. </t>

<t> The solution should draw upon experiences from related PSTN mechanisms <xref target="Q.1248.2"/> <xref target="E.412"/> <xref target="E.300SerSup3"/> where applicable. </t>

<t> The solution should be extensible to meet future needs. </t>

</list> </t>

</section>

<section anchor='sec:reqmatch' title="Discussion of How This Specification Meets the Requirements of RFC 5390">

  <t> This section evaluates whether the load-control event package mechanism defined in this specification satisfies various SIP overload control requirements set forth by <xref target="RFC5390"/>. As mentioned in <xref target="sec:intro"/>, this specification complements other efforts in the overall SIP load-control solution space. Therefore, not all RFC 5390 requirements are found applicable to this specification. This specification categorizes the assessment results into Yes (the requirement is met), P/A (Partially Applicable), No (must be used in conjunction with another mechanism to meet the requirement), and N/A (Not Applicable). </t>

<t> <list style="empty">

<t> REQ 1:  The overload mechanism shall strive to maintain the overall useful throughput (taking into consideration the quality-of-service needs of the using applications) of a SIP server at reasonable levels, even when the incoming load on the network is far in excess of its capacity. The overall throughput under load is the ultimate measure of the value of an overload control mechanism. </t>

</list> </t>

<t> P/A.&nbsp; The goal of load filtering is to prevent overload or maintain overall goodput during the time of overload, but it is dependent on the predictions of the load and the computations as well as distribution of the filtering policies. If the load predictions or filtering policy computations are incorrect, or the filtering policy is not properly distributed, the mechanism will be less effective. On the other hand, if the load can be accurately predicted and filtering policies be computed and distributed appropriately, this requirement can be met.</t>

<t> <list style="empty">

        <t> REQ 2:  When a single network element fails, goes into overload, or suffers from reduced processing capacity, the mechanism should strive to limit the impact of this on other elements in the network.  This helps to prevent a small-scale failure from becoming a widespread outage. </t>

</list> </t>

<t> N/A if load-filtering policies are installed in advance and do not
   change during the potential overload period, P/A if load-filtering policies are dynamically adjusted. The algorithm to dynamically compute load-filtering policies is outside the scope of this specification, while the distribution of the updated filtering policies uses the event package mechanism of this specification. </t>

<t> <list style="empty">

        <t>   REQ 3:  The mechanism should seek to minimize the amount of configuration required in order to work.  For example, it is better to avoid needing to configure a server with its SIP message throughput, as these kinds of quantities are hard to determine. </t> 

</list> </t>

<t> No. This mechanism is entirely dependent on advance configuration, based on advance knowledge. In order to satisfy REQ 3, it should be used in conjunction with other mechanisms that are not based on advance configuration. </t>

<t> <list style="empty">

        <t>   REQ 4:  The mechanism must be capable of dealing with elements that do not support it, so that a network can consist of a mix of elements that do and don't support it.  In other words, the mechanism should not work only in environments where all elements support it.  It is reasonable to assume that it works better in such environments, of course.  Ideally, there should be incremental improvements in overall network throughput as increasing numbers of elements in the network support the mechanism. </t>

</list> </t>

<t> No. This mechanism is entirely dependent on the participation of all possible neighbors. In order to satisfy REQ 4, it should be used in conjunction with other mechanisms, some of which are described in <xref target="sec:netusage"/>.</t>

<t> <list style="empty">

        <t>   REQ 5:  The mechanism should not assume that it will only be deployed in environments with completely trusted elements. It should seek to operate as effectively as possible in environments where other elements are malicious; this includes preventing malicious elements from obtaining more than a fair share of service. </t>

</list> </t>

<t> No. This mechanism is entirely dependent on the non-malicious participation of all possible neighbors. In order to satisfy REQ 5, it should be used in conjunction with other mechanisms, some of which are described in <xref target="sec:netusage"/>. </t>

<t> <list style="empty">

        <t>   REQ 6:  When overload is signaled by means of a specific message, the message must clearly indicate that it is being sent because of overload, as opposed to other, non overload-based failure conditions.  This requirement is meant to avoid some of the problems that have arisen from the reuse of the 503 response code for multiple purposes.  Of course, overload is also signaled by lack of response to requests.  This requirement applies only to explicit overload signals. </t>

</list> </t>

<t> N/A.&nbsp; This mechanism signals anticipated overload, not actual overload. However, the signals in this mechanism are not used for any other purpose.</t>

<t> <list style="empty">

        <t> REQ 7:  The mechanism shall provide a way for an element to throttle the amount of traffic it receives from an upstream element.  This throttling shall be graded so that it is not all-or-nothing as with the current 503 mechanism.  This recognizes the fact that "overload" is not a binary state and that there are degrees of overload. </t>

</list> </t>
        
<t> Yes.  This event package allows rate-/loss-/window-based overload control options as discussed in <xref target="sec:action"/>. </t>

<t> <list style="empty">

        <t> REQ 8:  The mechanism shall ensure that, when a request was not processed successfully due to overload (or failure) of a downstream element, the request will not be retried on another element that is also overloaded or whose status is unknown.  This requirement derives from REQ 1. </t>

</list> </t>

        <t> N/A to the load-control event package mechanism itself. </t>


<t> <list style="empty">
        <t>   REQ 9:  That a request has been rejected from an overloaded element shall not unduly restrict the ability of that request to be submitted to and processed by an element that is not overloaded. This requirement derives from REQ 1. </t>

</list> </t>

<t> Yes.&nbsp; For example, load-filtering policy (<xref target="sec:filtercontent"/>) can include alternative forwarding destinations for rejected requests. </t>

<t> <list style="empty">

        <t>   REQ 10:  The mechanism should support servers that receive requests from a large number of different upstream elements, where the set of upstream elements is not enumerable. </t>

</list> </t>

<t> No. Because this mechanism requires advance configuration of specifically identified neighbors, it does not support environments where the number and identity of the upstream neighbors are not known in advance. In order to satisfy REQ 10, it should be used in conjunction with other mechanisms.</t>


<t> <list style="empty">
        <t>   REQ 11:  The mechanism should support servers that receive requests from a finite set of upstream elements, where the set of upstream elements is enumerable. </t>
  </list> </t>

  <t> Yes.&nbsp; See also answer to REQ 10. </t>


<t> <list style="empty">
        <t>   REQ 12:  The mechanism should work between servers in different domains. </t>
  </list> </t>

  <t> Yes.&nbsp; The load-control event package mechanism is not limited by domain boundaries. However, it is likely more applicable in intra-domain scenarios than in inter-domain scenarios due to security and other concerns (see also <xref target="sec:netusage"/>). </t>


<t> <list style="empty">
        <t>   REQ 13:  The mechanism must not dictate a specific algorithm for prioritizing the processing of work within a proxy during times of overload.  It must permit a proxy to prioritize requests based on any local policy, so that certain ones (such as a call for emergency services or a call with a specific value of the Resource-Priority header field <xref target="RFC4412"/>) are given preferential treatment, such as not being dropped, being given additional retransmission, or being processed ahead of others. </t>
  </list> </t>

  <t> P/A.&nbsp; This mechanism does not specifically address the prioritizing of work during times of overload. But it does not preclude any particular local policy. </t>

<t> <list style="empty">
        <t>   REQ 14:  The mechanism should provide unambiguous directions to clients on when they should retry a request and when they should not.  This especially applies to TCP connection establishment and SIP registrations, in order to mitigate against avalanche restart. </t>
  </list> </t>

  <t> N/A to the load-control event package mechanism itself. </t>


<t> <list style="empty">
        <t>  REQ 15:  In cases where a network element fails, is so overloaded that it cannot process messages, or cannot communicate due to a network failure or network partition, it will not be able to provide explicit indications of the nature of the failure or its levels of congestion.  The mechanism must properly function in these cases. </t>
  </list> </t>

  <t> P/A.&nbsp; Because the load-filtering policies are provisioned in advance, they are not affected by the overload or failure of other network elements. On the other hand, they may not, in those cases, be able to protect the overloaded network elements (see REQ 1). </t>


<t> <list style="empty">
        <t> REQ 16:  The mechanism should attempt to minimize the overhead of the overload control messaging. </t>
  </list> </t>

  <t> Yes.&nbsp; The standardized SIP event package mechanism <xref target="RFC6665"/> is used. </t>


<t> <list style="empty">
        <t> REQ 17:  The overload mechanism must not provide an avenue for malicious attack, including DoS and DDoS attacks. </t>
  </list> </t>

  <t> P/A.&nbsp; This mechanism does provide a potential avenue for malicious attacks. Therefore, the security mechanisms for SIP event packages, in general, <xref target="RFC6665"/> and <xref target="sec:security"/> of this specification should be used. </t>

<t> <list style="empty">
        <t> REQ 18:  The overload mechanism should be unambiguous about whether a load indication applies to a specific IP address, host, or URI, so that an upstream element can determine the load of the entity to which a request is to be sent. </t> 
  </list> </t>

  <t> Yes.&nbsp; The identity of load indication is covered in the load-filtering policy format definition in <xref target="sec:filtercontent"/>. </t>

<t> <list style="empty">
        <t> REQ 19:  The specification for the overload mechanism should give guidance on which message types might be desirable to process over others during times of overload, based on SIP-specific considerations.  For example, it may be more beneficial to process a SUBSCRIBE refresh with Expires of zero than a SUBSCRIBE refresh with a non-zero expiration (since the former reduces the overall amount of load on the element), or to process re-INVITEs over new INVITEs. </t>
  </list> </t>

        <t> N/A to the load-control event package mechanism itself. </t>

<t> <list style="empty">
        <t>   REQ 20:  In a mixed environment of elements that do and do not implement the overload mechanism, no disproportionate benefit shall accrue to the users or operators of the elements that do not implement the mechanism. </t>
  </list> </t>

  <t> No. This mechanism is entirely dependent on the participation of all possible neighbors. In order to satisfy REQ 20, it should be used in conjunction with other mechanisms, some of which are described in <xref target="sec:netusage"/>. </t>


<t> <list style="empty">
        <t> REQ 21:  The overload mechanism should ensure that the system remains stable.  When the offered load drops from above the overall capacity of the network to below the overall capacity, the throughput should stabilize and become equal to the offered load. </t>
  </list> </t>

  <t> N/A to the load-control event package mechanism itself. </t>

<t> <list style="empty">
        <t>   REQ 22:  It must be possible to disable the reporting of load information towards upstream targets based on the identity of those targets.  This allows a domain administrator who considers the load of their elements to be sensitive information, to restrict access to that information.  Of course, in such cases, there is no expectation that the overload mechanism itself will help prevent overload from that upstream target. </t>
  </list> </t>

  <t> N/A to the load-control event package mechanism itself. </t>

<t> <list style="empty">
        <t>  REQ 23:  It must be possible for the overload mechanism to work in cases where there is a load balancer in front of a farm of proxies. </t>
  </list> </t>

  <t> Yes.&nbsp; The load-control event package mechanism does not preclude its use in a scenario with server farms. </t> 


</section>
    <section anchor='sec:ruleex' title='Complete Examples'>

       
    <section anchor='sec:documents' title='Load-Control Document Examples'>

        <t> This section presents two complete examples of load-control documents valid with respect to the XML schema defined in <xref target="sec:schema"/>. </t>

        <t>The first example assumes that a set of hotlines are set up at "sip:alice@hotline.example.com" and "tel:+1-212-555-1234". The hotlines are activated from 12:00 to 15:00 US Eastern Standard Time on 2008-05-31. The goal is to limit the incoming calls to the hotlines to 100 requests per second. Calls that exceed the rate limit are explicitly rejected. </t> 
            
<figure>
    <artwork>
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;ruleset xmlns="urn:ietf:params:xml:ns:common-policy"
            xmlns:lc="urn:ietf:params:xml:ns:load-control"
            version="0" state="full">

    &lt;rule id="f3g44k1">
        &lt;conditions>
            &lt;lc:call-identity>
                &lt;lc:sip>
                    &lt;lc:to>
                        &lt;one id="sip:alice@hotline.example.com"/>
                        &lt;one id="tel:+1-212-555-1234"/>
                    &lt;/lc:to>
                &lt;/lc:sip>
            &lt;/lc:call-identity>
            &lt;method>INVITE&lt;/method>
            &lt;validity>
                &lt;from>2008-05-31T12:00:00-05:00&lt;/from>
                &lt;until>2008-05-31T15:00:00-05:00&lt;/until>
            &lt;/validity>
        &lt;/conditions>
        &lt;actions>
            &lt;lc:accept alt-action="reject">
                &lt;lc:rate>100&lt;/lc:rate>
            &lt;/lc:accept>
        &lt;/actions>

    &lt;/rule>
&lt;/ruleset>
    </artwork>
</figure>

<t>  The second example optimizes the usage of server resources during the three-day period following a hurricane. Incoming calls to the domain "sandy.example.com" or to call destinations with prefix "+1-212" will be limited to a rate of 100 requests per second, except for those calls originating from a particular rescue team domain "rescue.example.com". Outgoing calls from the hurricane domain or calls within the local domain are never limited. All calls that are throttled due to the rate limit will be forwarded to an answering machine with updated hurricane rescue information. </t>

<figure>
    <artwork>
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;ruleset xmlns="urn:ietf:params:xml:ns:common-policy"
    xmlns:lc="urn:ietf:params:xml:ns:load-control"
    version="1" state="full">

    &lt;rule id="f3g44k2">
        &lt;conditions>
            &lt;lc:call-identity>
                &lt;lc:sip>
                    &lt;lc:to>
                        &lt;many domain="sandy.example.com"/>
                        &lt;many-tel prefix="+1-212"/>
                    &lt;/lc:to>
                    &lt;lc:from>
                        &lt;many> 
                            &lt;except domain="sandy.example.com"/>
                            &lt;except domain="rescue.example.com"/>
                        &lt;/many>
                    &lt;/lc:from>
                &lt;/lc:sip>
            &lt;/lc:call-identity>
            &lt;method>INVITE&lt;/method>
            &lt;validity>
                &lt;from>2012-10-25T09:00:00+01:00&lt;/from>
                &lt;until>2012-10-28T09:00:00+01:00&lt;/until>
            &lt;/validity>
        &lt;/conditions>
        &lt;actions>
            &lt;lc:accept alt-action="redirect" alt-target=
                    "sip:sandy@update.example.com">
                &lt;lc:rate>100&lt;/lc:rate>
            &lt;/lc:accept>
        &lt;/actions>

    &lt;/rule>
&lt;/ruleset>
    </artwork>
</figure>

<t> Sometimes it may occur that multiple rules in a ruleset define actions that match the same methods, call identity and validity. In those cases, the "first-match-wins" principle is used. For example, in the following ruleset, the first rule requires all calls from the "example.com" domain to be rejected. Even though the rule following that one specifies that calls from "sip:alice@example.com" be redirected to a specific target "sip:eve@example.com", the calls from "sip:alice@example.com" will still be rejected because they have already been matched by the earlier rule. </t>   

<figure>
    <artwork>
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;ruleset xmlns="urn:ietf:params:xml:ns:common-policy"
    xmlns:lc="urn:ietf:params:xml:ns:load-control"
    version="1" state="full">

    &lt;rule id="f3g44k3">
        &lt;conditions>
            &lt;lc:call-identity>
                &lt;lc:sip>
                    &lt;lc:from>
                        &lt;many domain="example.com"/>
                    &lt;/lc:from>
                &lt;/lc:sip>
            &lt;/lc:call-identity>
            &lt;method>INVITE&lt;/method>
            &lt;validity>
                &lt;from>2013-7-2T09:00:00+01:00&lt;/from>
                &lt;until>2013-7-3T09:00:00+01:00&lt;/until>
            &lt;/validity>
        &lt;/conditions>
        &lt;actions>
            &lt;lc:accept alt-action="reject">
                &lt;lc:rate>0&lt;/lc:rate>
            &lt;/lc:accept>
        &lt;/actions>
    &lt;/rule>

    &lt;rule id="f3g44k4">
        &lt;conditions>
            &lt;lc:call-identity>
                &lt;lc:sip>
                    &lt;lc:from>
                        &lt;one id="sip:alice@example.com"/>
                    &lt;/lc:from>
                &lt;/lc:sip>
            &lt;/lc:call-identity>
            &lt;method>INVITE&lt;/method>
            &lt;validity>
                &lt;from>2013-7-2T09:00:00+01:00&lt;/from>
                &lt;until>2013-7-3T09:00:00+01:00&lt;/until>
            &lt;/validity>
        &lt;/conditions>
        &lt;actions>
            &lt;lc:accept alt-action="redirect" alt-target=
                    "sip:eve@example.com">
                &lt;lc:rate>0&lt;/lc:rate>
            &lt;/lc:accept>
        &lt;/actions>
    &lt;/rule>

&lt;/ruleset>
         </artwork>
      </figure>

   </section>

   <section anchor='sec:messageflow' title='Message Flow Examples'>
      
      <t> This section presents an example message flow of using the load-control event package mechanism defined in this specification. </t>

      <figure>
         <artwork>
   atlanta             biloxi
      | F1 SUBSCRIBE      |               
      |------------------>|                    
      | F2 200 OK         |                    
      |&lt;------------------|                    
      | F3 NOTIFY         |                    
      |&lt;------------------|                    
      | F4 200 OK         |                   
      |------------------>|    

   F1 SUBSCRIBE atlanta.example.com -> biloxi.example.com

      SUBSCRIBE sip:biloxi.example.com SIP/2.0
      Via: SIP/2.0/TCP atlanta.example.com;branch=z9hG4bKy7cjbu3
      From: sip:atlanta.example.com;tag=162ab5
      To: sip:biloxi.example.com
      Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com
      CSeq: 2012 SUBSCRIBE
      Contact: sip:atlanta.example.com
      Event: load-control
      Max-Forwards: 70
      Accept: application/load-control+xml
      Expires: 3600
      Content-Length: 0

   F2 200 OK   biloxi.example.com -> atlanta.example.com

      SIP/2.0 200 OK
      Via: SIP/2.0/TCP biloxi.example.com;branch=z9hG4bKy7cjbu3
        ;received=192.0.2.1
      To: &lt;sip:biloxi.example.com>;tag=331dc8
      From: &lt;sip:atlanta.example.com>;tag=162ab5
      Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com
      CSeq: 2012 SUBSCRIBE
      Expires: 3600
      Contact: sip:biloxi.example.com
      Content-Length: 0

   F3 NOTIFY  biloxi.example.com -> atlanta.example.com

      NOTIFY sip:atlanta.example.com SIP/2.0
      Via: SIP/2.0/TCP biloxi.example.com;branch=z9hG4bKy71g2ks
      From: &lt;sip:biloxi.example.com>;tag=331dc8
      To: &lt;sip:atlanta.example.com>;tag=162ab5
      Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com
      Event: load-control
      Subscription-State: active;expires=3599
      Max-Forwards: 70
      CSeq: 1775 NOTIFY
      Contact: sip:biloxi.example.com
      Content-Type: application/load-control+xml
      Content-Length: ...

      [Load-Control Document]

   F4 200 OK atlanta.example.com -> biloxi.example.com 

      SIP/2.0 200 OK
      Via: SIP/2.0/TCP atlanta.example.com;branch=z9hG4bKy71g2ks
        ;received=192.0.2.2
      From: &lt;sip:biloxi.example.com>;tag=331dc8
      To: &lt;sip:atlanta.example.com>;tag=162ab5
      Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com
      CSeq: 1775 NOTIFY
      Content-Length: 0
         </artwork>
      </figure>

   </section>

    </section>

    <section anchor='sec:relatedwork' title="Related Work">

        <section anchor='sec:rlpstn' title="Relationship to Load Filtering in PSTN"> 

            <t> It is known that an existing PSTN network also uses a load-filtering mechanism to prevent overload and the filtering policy configuration is done manually except in specific cases when the Intelligent Network architecture is used <xref target="Q.1248.2"/><xref target="E.412"/>. This specification defines a load-filtering mechanism based on the SIP event notification framework that allows automated filtering policy distribution in suitable environments. </t> 
                
            <t> PSTN overload control uses messages that specify an outgoing control list, call gap duration, and
   control duration <xref target="Q.1248.2"/><xref target="E.412"/>. These items correspond roughly to the identity, action, and time fields of the SIP load-filtering policy defined in this specification.  However, the load-filtering policy defined in this specification is much more generic and flexible as opposed to its PSTN counterpart. </t> 
                
            <t> Firstly, PSTN load filtering only applies to telephone numbers. The identity element of SIP load-filtering policy allows both SIP URI and telephone numbers (through 'tel' URI) to be specified. These identities can be arbitrarily grouped by SIP domains or any number of leading prefixes of the telephone numbers.  </t>
            
            <t> Secondly, the PSTN load-filtering action is usually limited to call gapping. The action field in SIP load-filtering policy allows more flexible possibilities such as rate throttle and others. </t>     

            <t> Thirdly, the duration field in PSTN load filtering specifies a value in seconds for the load-filtering duration only, and the allowed values are mapped into a value set. The time field in SIP load-filtering policy may specify not only a duration, but also a future activation time that could be especially useful for automating load filtering for predictable overloads. </t>
            
            <t> PSTN load filtering can be performed in both edge switches and transit switches; the SIP load filtering can also be applied in both edge proxy servers and core proxy servers, and even in capable user agents. </t> 

            <t> PSTN load filtering also has special accommodation for High Probability of Completion (HPC) calls, which would be similar to calls designated by the SIP Resource Priority Headers <xref target="RFC4412"/>. The SIP load-filtering mechanism also allows prioritizing the treatment of these calls by specifying favorable actions for them. </t>  

            <t> PSTN load filtering also provides an administrative option for routing failed call attempts to either a reorder tone <xref target="E.300SerSup3"/> indicating overload conditions or a special recorded announcement. A similar capability can be provided in the SIP load-filtering mechanism by specifying appropriate "alt-action" attribute in the SIP load-filtering action field. </t>
                
    </section>

        <section anchor='sec:rlfeedback' title="Relationship with Other IETF SIP Overload Control Efforts"> 

            <t> The load-filtering policies in this specification consist of identity, action, and time. The identity can range from a single specific user to an arbitrary user aggregate, domains, or areas. The user can be identified by either the source or the destination. When the user is identified by the source and a favorable action is specified, the result is, to some extent, similar to identifying a priority user based on authorized Resource Priority Headers <xref target="RFC4412"/> in the requests. Specifying a source user identity with an unfavorable action would cause an effect to some extent similar to an inverse SIP resource priority mechanism. </t>
                
            <t> The load-filtering policy defined in this specification is generic and expected to be applicable not only to the load-filtering mechanism but also to the feedback overload control mechanism in <xref target="SIP-OVERLOAD"/>. In particular, both mechanisms could use specific or wildcard identities for load control and could share well-known load-control actions. The time duration field in the load-filtering policy could also be used in both mechanisms. As mentioned in <xref target="sec:intro"/>, the load-filtering policy distribution mechanism and the feedback overload control mechanism address complementary areas in the overload control problem space. Load filtering is more proactive and focuses on distributing filtering policies towards the source of the traffic; the hop-by-hop feedback-based approach is reactive and reduces traffic already accepted by the network. Therefore, they could also make different use of the generic load-filtering policy components. For example, the load-filtering mechanism may use the time field in the filtering policy to specify not only a control duration but also a future activation time to accommodate a predicable overload such as the one caused by Mother's Day greetings or a viewer-voting program; the feedback-based control might not need to use the time field or might use the time field to specify an immediate load-control duration. </t>
                
    </section>

    </section>

    </back>

</rfc>

