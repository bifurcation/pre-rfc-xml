<?xml version="1.0" encoding="US-ASCII" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY % RFC0768 SYSTEM "reference.RFC.0768"  >
<!ENTITY % RFC0792 SYSTEM "reference.RFC.0792"  >
<!ENTITY % RFC1035 SYSTEM "reference.RFC.1035" >
<!ENTITY % RFC2119 SYSTEM "reference.RFC.2119" >
<!ENTITY % RFC2404 SYSTEM "reference.RFC.2404" >
<!ENTITY % RFC2408 SYSTEM "reference.RFC.2408" >
<!ENTITY % RFC2412 SYSTEM "reference.RFC.2412" >
<!ENTITY % RFC2434 SYSTEM "reference.RFC.2434" >
<!ENTITY % RFC2451 SYSTEM "reference.RFC.2451" >
<!ENTITY % RFC2460 SYSTEM "reference.RFC.2460" >
<!ENTITY % RFC2463 SYSTEM "reference.RFC.2463" >
<!ENTITY % RFC2536 SYSTEM "reference.RFC.2536" >
<!ENTITY % RFC2898 SYSTEM "reference.RFC.2898" >
<!ENTITY % RFC3110 SYSTEM "reference.RFC.3110" >
<!ENTITY % RFC3484 SYSTEM "reference.RFC.3484" >
<!ENTITY % RFC3513 SYSTEM "reference.RFC.3513" >
<!ENTITY % RFC3526 SYSTEM "reference.RFC.3526" >
<!ENTITY % RFC3602 SYSTEM "reference.RFC.3602" >
<!ENTITY % RFC3972 SYSTEM "reference.RFC.3972" >
<!ENTITY % RFC4034 SYSTEM "reference.RFC.4034" >
<!ENTITY % RFC4282 SYSTEM "reference.RFC.4282" >
<!ENTITY % RFC4306 SYSTEM "reference.RFC.4306" >
<!ENTITY % RFC4307 SYSTEM "reference.RFC.4307" >
<!ENTITY % RFC4423 SYSTEM "reference.RFC.4423" >
<!ENTITY % RFC4843 SYSTEM "reference.RFC.4843" >
]>


<?rfc toc="yes" ?>
<?rfc rfcedstyle="yes" ?>
<?rfc subcompact="no" ?>

<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>

<rfc number="5201" category="exp">
  <front>
    <title abbrev="Host Identity Protocol">
      Host Identity Protocol</title>

    <author initials="R." surname="Moskowitz"
      fullname="Robert Moskowitz">
      <organization abbrev="ICSAlabs">ICSAlabs, An Independent Division of Verizon Business Systems
      </organization>
      <address>
        <postal>
          <street>1000 Bent Creek Blvd, Suite 200</street>
          <city>Mechanicsburg</city>
          <region>PA</region>
          <country>USA</country>
        </postal>
        <email>rgm@icsalabs.com</email>
      </address>
    </author>

    <author initials="P." surname="Nikander"
      fullname="Pekka Nikander">
      <organization>Ericsson Research NomadicLab</organization>
      <address>
        <postal>
          <street />
          <city>JORVAS</city>
          <code>FIN-02420</code>
          <country>FINLAND</country>
        </postal>
        <phone>+358 9 299 1</phone>
        <email>pekka.nikander@nomadiclab.com</email>
      </address>
    </author>

    <author initials="P." surname="Jokela"
      fullname="Petri Jokela" role="editor">
      <organization>Ericsson Research NomadicLab</organization>
      <address>
        <postal>
          <street />
          <city>JORVAS</city>
          <code>FIN-02420</code>
          <country>FINLAND</country>
        </postal>
        <phone>+358 9 299 1</phone>
        <email>petri.jokela@nomadiclab.com</email>
      </address>
    </author>

    <author initials="T." surname="Henderson"
      fullname="Thomas R. Henderson">
      <organization>The Boeing Company</organization>
      <address>
        <postal>
          <street>P.O. Box 3707</street>
          <city>Seattle</city>
          <region>WA</region>
          <country>USA</country>
        </postal>
        <email>thomas.r.henderson@boeing.com</email>
      </address>
    </author>

    <date month="April" year="2008" />

    <area>Internet</area>

<keyword>HIP</keyword>

<note title="IESG Note">
<t>
The following issues describe IESG concerns about this document. The IESG
expects that these issues will be addressed when future versions of HIP
are designed.
</t>
<t>
This document doesn't currently define support for parameterized
(randomized) hashing in signatures, support for negotiation of a key
derivation function, or support for combined encryption modes.
</t>
<t>
HIP defines the usage of RSA in signing and encrypting
data. Current recommendations propose usage of, for example, RSA OAEP/PSS
for these operations in new protocols. Changing the algorithms to more
current best practice should be considered.
</t>
<t>
The current specification is currently using HMAC for message
authentication. This is considered to be acceptable for an experimental
RFC, but future versions must define a more generic method for message
authentication, including the ability for other MAC algorithms to be used.
</t>
<t>
SHA-1 is no longer a preferred hashing algorithm. This is noted also by
the authors, and it is understood that future, non-experimental versions
must consider more secure hashing algorithms.
</t>
<t>
HIP requires that an incoming packet's IP address be ignored. In
simple cases this can be done, but when there are security policies based
on incoming interface or IP address rules, the situation changes. The
handling of data needs to be enhanced to cover different types of network
and security configurations, as well as to meet local security policies.
</t>
</note>

    <abstract>

      <t>
        This memo specifies the details of the Host Identity Protocol
        (HIP).  HIP allows consenting hosts to securely establish and
        maintain shared IP-layer state, allowing separation of the
        identifier and locator roles of IP addresses, thereby enabling
        continuity of communications across IP address changes.  HIP is
        based on a Sigma-compliant Diffie-Hellman key exchange, using
        public key identifiers from a new Host Identity namespace for
        mutual peer authentication.  The protocol is designed to be
        resistant to denial-of-service (DoS) and man-in-the-middle
        (MitM) attacks. When used together with another suitable
        security protocol, such as the Encapsulated Security Payload (ESP),
        it provides integrity protection and optional encryption for
        upper-layer protocols, such as TCP and UDP. 
      </t>

    </abstract>

  </front>
  <middle>


    <section title="Introduction">


      <t>
        This memo specifies the details of the Host Identity Protocol
        (HIP).  A high-level description of the protocol and the
        underlying architectural thinking is available in the separate
        <xref target="RFC4423">HIP architecture
        description</xref>.  Briefly, the HIP architecture proposes an
        alternative to the dual use of IP addresses as "locators"
        (routing labels) and "identifiers" (endpoint, or host,
        identifiers).  In HIP, public cryptographic keys, of a
        public/private key pair, are used as Host Identifiers, to which
        higher layer protocols are bound instead of an IP address. By
        using public keys (and their representations) as host
        identifiers, dynamic changes to IP address sets can be directly
        authenticated between hosts, and if desired, strong
        authentication between hosts at the TCP/IP stack level can be
        obtained.
      </t>
      

      <t>
        This memo specifies the base HIP protocol ("base exchange") used
        between hosts to establish an IP-layer communications context,
        called HIP association, prior to communications.  It also
        defines a packet format and procedures for updating an active
        HIP association.  Other elements of the HIP architecture are
        specified in other documents, such as.
        <list style='symbols'>
          <t>
            "Using the Encapsulating Security Payload (ESP) Transport
            Format with the Host Identity Protocol (HIP)" <xref
            target="RFC5202" />: how to use
            the Encapsulating Security Payload (ESP) for integrity
            protection and optional encryption 
          </t>
          <t>
            "End-Host Mobility and Multihoming with the Host Identity
            Protocol" <xref target="RFC5206" />: how to support
            mobility and multihoming in HIP
            
          </t>
          <t>
            "Host Identity Protocol (HIP) Domain Name System (DNS)
            Extensions" <xref target="RFC5205" />: how to
            extend DNS to contain Host Identity information
          </t>
          <t>
            "Host Identity Protocol (HIP) Rendezvous Extension" <xref
            target="RFC5204" />: using a rendezvous mechanism
            to contact mobile HIP hosts
          </t>
        </list>
      </t>

      <section title="A New Namespace and Identifiers">

        <t>
          The Host Identity Protocol introduces a new namespace, the
          Host Identity namespace. Some ramifications of this new
          namespace are explained in the HIP architecture description
          <xref target="RFC4423" />.
        </t>

        <t>
          There are two main representations of the Host Identity, the
          full Host Identifier (HI) and the Host Identity Tag (HIT).
          The HI is a public key and directly represents the Identity.
          Since there are different public key algorithms that can be
          used with different key lengths, the HI is not good for use
          as a packet identifier, or as an index into the various
          operational tables needed to support HIP.  Consequently, a
          hash of the HI, the Host Identity Tag (HIT), becomes the
          operational representation.  It is 128 bits long and is used
          in the HIP payloads and to index the corresponding state in
          the end hosts.  The HIT has an important security property 
          in that it is self-certifying (see <xref target="HI" />).
        </t>

      </section>

      <section title="The HIP Base Exchange">
        
        <t>
          The HIP base exchange is a two-party cryptographic protocol
          used to establish communications context between hosts.  The
          base exchange is a Sigma-compliant <xref
          target="KRA03" /> four-packet exchange.  The first
          party is called the Initiator and the second party the
          Responder.  The four-packet design helps to make HIP DoS
          resilient.  The protocol exchanges Diffie-Hellman keys in
          the 2nd and 3rd packets, and authenticates the parties in
          the 3rd and 4th packets.  Additionally, the Responder starts
          a puzzle exchange in the 2nd packet, with the
          Initiator completing it in the 3rd packet before the
          Responder stores any state from the exchange.
        </t>

        <t>
          The exchange can use the Diffie-Hellman output to encrypt the
          Host Identity of the Initiator in the 3rd packet (although Aura, et
          al., <xref target="AUR03" /> notes that such operation may
          interfere with packet-inspecting middleboxes), or the Host
          Identity may instead be sent unencrypted.  The Responder's
          Host Identity is not protected.  It should be noted, however,
          that both the Initiator's and the Responder's HITs are
          transported as such (in cleartext) in the packets, allowing an
          eavesdropper with a priori knowledge about the parties to
          verify their identities.
       </t>

        <t>
          Data packets start to flow after the 4th packet.  The 3rd and
          4th HIP packets may carry a data payload in the future.
          However, the details of this are to be defined later as more
          implementation experience is gained.
        </t>
      
        <t>
          An existing HIP association can be updated using the update
          mechanism defined in this document, and when the association
          is no longer needed, it can be closed using the defined 
          closing mechanism. 
        </t>


        <t>
          Finally, HIP is designed as an end-to-end authentication and
          key establishment protocol, to be used with Encapsulated
          Security Payload (ESP) <xref target="RFC5202" /> and
          other end-to-end security protocols.  The base protocol does
          not cover all the fine-grained policy control found in
          Internet Key Exchange (IKE) <xref
          target="RFC4306" /> that allows IKE to support
          complex gateway policies.  Thus, HIP is not a replacement for
          IKE.
        </t>

      </section>

      <section title="Memo Structure">

        <t>
          The rest of this memo is structured as follows.  <xref
          target="terms" /> defines the central keywords, notation, and
          terms used throughout the rest of the document.  <xref
          target="HI" /> defines the structure of the Host Identity and
          its various representations.  <xref target="proto_overview" />
          gives an overview of the HIP base exchange protocol.
          Sections <xref
          target="sec-param-tlv" format="counter" /> and <xref target="packet_processing"
          format="counter" /> define the detail packet formats and rules for packet
          processing.  Finally, Sections <xref target="sec-policy" format="counter" />, <xref
          target="sec-considerations" format="counter" />, and
          <xref target="iana" format="counter" />
          discuss policy, security, and IANA considerations,
          respectively.
        </t>
      </section>
    </section>



    <section anchor="terms" title="Terms and Definitions">
      <section title="Requirements Terminology">
        
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
          NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
          "OPTIONAL" in this document are to be interpreted as described
          in <xref target="RFC2119">RFC 2119</xref>.
        </t>
      </section>

      <section anchor="notation" title="Notation">
        <t>
          <list style="hanging">
            <t hangText="[x] ">
              indicates that x is optional.
            </t>
            <t hangText="&#123;x&#125; ">
              indicates that x is encrypted.
            </t>
            <t hangText="X(y) ">
              indicates that y is a parameter of X.
            </t>
            <t hangText="&lt;x&gt;i ">
              indicates that x exists i times.
            </t>
            
            <t hangText="--&gt; ">
              signifies "Initiator to Responder" communication 
              (requests).
            </t>
            
            <t hangText="&lt;-- ">
              signifies "Responder to Initiator" communication 
              (replies).
            </t>
            
            <t hangText="| ">
              signifies concatenation of information-- e.g., X | Y is the
              concatenation of X with Y.
            </t>
            
            <t hangText="Ltrunc (SHA-1(), K) ">
              denotes the lowest order K bits of the 
              SHA-1 result.
            </t>
          </list>
        </t>
      </section>

      <section title="Definitions">
        <t>
          <list style="hanging">
            <t hangText="Unused Association Lifetime (UAL): ">
              Implementation-specific
              time for which, if no packet is sent or received for this time
              interval, a host MAY begin to tear down an active association.
            </t>
            
            <t hangText="Maximum Segment Lifetime (MSL): ">
              Maximum time that a TCP segment
              is expected to spend in the network. 
            </t>
            
            <t hangText="Exchange Complete (EC): ">
              Time that the host spends at the
              R2-SENT before it moves to ESTABLISHED state.  The time is n *
              I2 retransmission timeout, where n is about I2_RETRIES_MAX.
            </t>
            
            <t hangText="HIT Hash Algorithm: ">
              Hash algorithm used to generate a Host
              Identity Tag (HIT) from the Host Identity public key.
              Currently <xref target="FIPS95">SHA-1</xref> is used.
            </t>
            
            <t hangText="Responder's HIT Hash Algorithm (RHASH): ">
              Hash algorithm used for various hash calculations in this
              document.  The algorithm is the same as is used to
              generate the Responder's HIT.  RHASH is defined by the
              Orchid Context ID.  For HIP, the present RHASH algorithm
is defined in <xref target="gener_hit" />. A future version of HIP may define a
              new RHASH algorithm by defining a new Context ID.
            </t>
            
            <t hangText="Opportunistic mode: ">
              HIP base exchange where the Responder's HIT
              is not known a priori to the Initiator. 
            </t>
          </list>
        </t>
      </section>
      
    </section>

    <section anchor="HI" title="Host Identifier (HI) and Its Representations">
      
      <t>
        In this section, the properties of the Host Identifier and Host
        Identifier Tag are discussed, and the exact format for them is
        defined.  In HIP, the public key of an asymmetric key pair is used
        as the Host Identifier (HI).  Correspondingly, the host itself
        is defined as the entity that holds the private key from the key
        pair.  See the HIP architecture specification <xref
        target="RFC4423" /> for more details about the
        difference between an identity and the corresponding identifier.
      </t>

      <t>
        HIP implementations MUST support the Rivest Shamir Adelman
        (RSA/SHA1) <xref target="RFC3110" /> public key algorithm, and
        SHOULD support the Digital Signature Algorithm (DSA) <xref
        target="RFC2536" /> algorithm; other algorithms MAY be
        supported.
      </t>


      <t>
        A hashed encoding of the HI, the Host Identity Tag (HIT), is used in
        protocols to represent the Host Identity.  The HIT is 128 bits
        long and has the following three key properties: i) it is the
        same length as an IPv6 address and can be used in address-sized
        fields in APIs and protocols, ii) it is self-certifying (i.e.,
        given a HIT, it is computationally hard to find a Host Identity
        key that matches the HIT), and iii) the probability of HIT
        collision between two hosts is very low.
      </t>

      <t>
        Carrying HIs and HITs in the header of user data packets would
        increase the overhead of packets.  Thus, it is not expected that
        they are carried in every packet, but other methods are used to
        map the data packets to the corresponding HIs.  In some cases,
        this makes it possible to use HIP without any additional headers
        in the user data packets.  For example, if ESP is used to
        protect data traffic, the Security Parameter Index (SPI) carried
        in the ESP header can be used to map the encrypted data packet
        to the correct HIP association.
      </t>

                          
      <section anchor="HIT" title="Host Identity Tag (HIT)">

        <t>
          The Host Identity Tag is a 128-bit value -- a hashed
          encoding of the Host Identifier.  There are two advantages of
          using a hashed encoding over the actual Host Identity public
          key in protocols.  Firstly, its fixed length makes for easier
          protocol coding and also better manages the packet size cost
          of this technology.  Secondly, it presents a consistent format
          to the protocol whatever underlying identity technology is
          used.
        </t>

        <t>
          <xref target="RFC4843">RFC 4843</xref> specifies 128-bit 
	  hash-based identifiers, called Overlay Routable
          Cryptographic Hash Identifiers (ORCHIDs).  Their prefix,
          allocated from the IPv6 address block, is defined in <xref
          target="RFC4843" />.  The Host Identity Tag is a type of
          ORCHID, based on a SHA-1 hash of the Host Identity, as defined
          in Section 2 of <xref target="RFC4843" />.
        </t>

      </section>
      
      <section title="Generating a HIT from an HI" anchor="gener_hit">
        <t>
          The HIT MUST be generated according to the ORCHID generation
          method described in <xref target="RFC4843" />
          using a context ID value of 0xF0EF F02F BFF4 3D0F E793 0C3C
          6E61 74EA (this tag value has been generated randomly by the
          editor of this specification), and an input that encodes the Host
          Identity field (see <xref target="host-id" />) present in a
          HIP payload packet.  The hash algorithm SHA-1 has to be used
          when generating HITs with this context ID.  If a new ORCHID
          hash algorithm is needed in the future for HIT generation, a
          new version of HIP has to be specified with a new ORCHID
          context ID associated with the new hash algorithm.
        </t>


        <t>
          For Identities that are either RSA or Digital Signature
          Algorithm (DSA) public keys, this
          input consists of the public key encoding as specified in the
          corresponding DNSSEC document, taking the algorithm-specific
          portion of the RDATA part of the KEY RR.  There are currently
          only two defined public key algorithms: RSA/SHA1 and DSA.
          Hence, either of the following applies:
          <list style="empty">
            <t>
              The RSA public key is encoded as defined in <xref
              target="RFC3110" /> Section 2, taking the
              exponent length (e_len), exponent (e), and modulus (n)
              fields concatenated.  The length (n_len) of the modulus
              (n) can be determined from the total HI Length and the
              preceding HI fields including the exponent (e).  Thus, the
              data to be hashed has the same length as the HI.  The
              fields MUST be encoded in network byte order, as defined
              in <xref target="RFC3110" />.
            </t>
            <t>
              The DSA public key is encoded as defined in <xref
                target="RFC2536" /> Section 2, taking
              the fields T, Q, P, G, and Y, concatenated.  Thus,
              the data to be hashed is 1 + 20 + 3 * 64 + 3 * 8 * T
              octets long, where T is the size parameter as
              defined in <xref target="RFC2536" />.
              The size parameter T, affecting the field lengths,
              MUST be selected as the minimum value that is long
              enough to accommodate P, G, and Y. &nbsp;The fields MUST
              be encoded in network byte order, as defined in
              <xref target="RFC2536" />.
            </t>
          </list>
        </t>
        <t>
          In <xref target="app_generhit" />, the public key encoding
          process is illustrated using pseudo-code.
        </t>
        
      </section>

    </section>

    <section anchor="proto_overview" title="Protocol Overview">

      <t>
        The following material is an overview of the HIP protocol
        operation, and does not contain all details of the packet
        formats or the packet processing steps.  Sections <xref
          target="sec-param-tlv" format="counter" /> and <xref
          target="packet_processing" format="counter" /> describe in more detail the
        packet formats and packet processing steps, respectively,
        and are normative in case of any conflicts with this
        section.
      </t>

      <t>
        The protocol number 139 has been assigned by IANA to the Host
	Identity Protocol.  
      </t>

      <t>
        The <xref target="ssec-payload">HIP payload</xref> header could be
        carried in every IP datagram.  However, since HIP headers are
        relatively large (40 bytes), it is desirable to 'compress' the
        HIP header so that the HIP header only occurs in control
        packets used to establish or change HIP association state.
        The actual method for header 'compression' and for matching
        data packets with existing HIP associations (if any) is
        defined in separate documents, describing transport
        formats and methods.  All HIP implementations MUST implement,
        at minimum, the ESP transport format for HIP <xref
          target="RFC5202" />.
      </t>
      
      <section anchor="hip-base-exch" title="Creating a HIP Association">
        
        <t>
          By definition, the system initiating a HIP exchange is the
          Initiator, and the peer is the Responder.  This distinction is
          forgotten once the base exchange completes, and either party can
          become the Initiator in future communications.  
        </t>

        <t>
          The HIP base exchange serves to manage the establishment of
          state between an Initiator and a Responder.  The first packet,
          I1, initiates the exchange, and the last three packets, R1,
          I2, and R2, constitute an authenticated Diffie-Hellman <xref
          target="DIF76" /> key exchange for session key generation.
          During the Diffie-Hellman key exchange, a piece of keying
          material is generated.  The HIP association keys are drawn
          from this keying material.  If other cryptographic keys are
          needed, e.g., to be used with ESP, they are expected to be
          drawn from the same keying material.
        </t>

        <t>
          The Initiator first sends a trigger packet, I1, to the
          Responder.  The packet contains only the HIT of the Initiator
          and possibly the HIT of the Responder, if it is known.  Note
          that in some cases it may be possible to replace this trigger
          packet by some other form of a trigger, in which case the
          protocol starts with the Responder sending the R1 packet.
        </t>

        <t>
          The second packet, R1, starts the actual exchange.  It
          contains a puzzle -- a cryptographic challenge that the
          Initiator must solve before continuing the exchange.  The level
          of difficulty of the puzzle can be adjusted based on level of
          trust with the Initiator, current load, or other factors.  In
          addition, the R1 contains the initial Diffie-Hellman parameters
          and a signature, covering part of the message.  Some fields are
          left outside the signature to support pre-created R1s.  
        </t>
        <t>
          In the I2 packet, the Initiator must display the solution to
          the received puzzle.  Without a correct solution, the I2
          message is discarded.  The I2 also contains a Diffie-Hellman
          parameter that carries needed information for the
          Responder.  The packet is signed by the sender.
        </t>
        <t>
          The R2 packet finalizes the base exchange.  The packet is
          signed.
        </t>
        <t>
          The base exchange is illustrated below.  The term "key" refers
          to the Host Identity public key, and "sig" represents a signature
          using such a key.  The packets contain other parameters not shown
          in this figure.
        </t>

        <figure>
          <artwork>
    Initiator                              Responder

                 I1: trigger exchange
               --------------------------&gt;
                                           select precomputed R1
                 R1: puzzle, D-H, key, sig
               &lt;-------------------------
 check sig                                 remain stateless
 solve puzzle
               I2: solution, D-H, {key}, sig
               --------------------------&gt;
 compute D-H                               check puzzle
                                           check sig
                         R2: sig
               &lt;--------------------------
 check sig                                 compute D-H

          </artwork>
        </figure>


        <section anchor="hip-cookie" title="HIP Puzzle Mechanism">

          <t>
            The purpose of the HIP puzzle mechanism is to protect the
            Responder from a number of denial-of-service threats.  It
            allows the Responder to delay state creation until receiving
            I2.  Furthermore, the puzzle allows the Responder to use a
            fairly cheap calculation to check that the Initiator is
            "sincere" in the sense that it has churned CPU cycles in
            solving the puzzle.
          </t>

          <t>
            The puzzle mechanism has been explicitly designed to give
            space for various implementation options.  It allows a
            Responder implementation to completely delay session-specific
            state creation until a valid I2 is received.  In
            such a case, a correctly formatted I2 can be rejected only
            once the Responder has checked its validity by computing
            one hash function.  On the other hand, the design also
            allows a Responder implementation to keep state about
            received I1s, and match the received I2s against the
            state, thereby allowing the implementation to avoid the
            computational cost of the hash function.  The drawback of
            this latter approach is the requirement of creating state.
            Finally, it also allows an implementation to use other
            combinations of the space-saving and computation-saving
            mechanisms.
          </t>

          <t>
            The Responder can remain stateless and drop most spoofed I2s
            because puzzle calculation is based on the Initiator's Host
            Identity Tag.&nbsp; The idea is that the Responder has a (perhaps
            varying) number of pre-calculated R1 packets, and it selects
            one of these based on the information carried in I1.  When
            the Responder then later receives I2, it can verify that the
            puzzle has been solved using the Initiator's HIT.  This
            makes it impractical for the attacker to first exchange one
            I1/R1, and then generate a large number of spoofed I2s that
            seemingly come from different HITs.  The method does not
            protect from an attacker that uses fixed HITs, though.
            Against such an attacker a viable approach may be to create
            a piece of local state, and remember that the puzzle check
            has previously failed.  See <xref target="resp-cookie" />
            for one possible implementation.  Implementations SHOULD
            include sufficient randomness to the algorithm so that
            algorithmic complexity attacks become impossible <xref
            target="CRO03" />.
          </t>

          <t>
            The Responder can set the puzzle difficulty for Initiator,
            based on its level of trust of the Initiator.  Because the
            puzzle is not included in the signature calculation, the 
            Responder can use pre-calculated R1 packets and include the
            puzzle just before sending the R1 to the Initiator.  The
            Responder SHOULD use heuristics to determine when it is
            under a denial-of-service attack, and set the puzzle
            difficulty value K appropriately; see below. 
          </t>

        </section>

        <section title="Puzzle Exchange" anchor="puzzle_exchange">

          <t>
            The Responder starts the puzzle exchange when it receives an
            I1.  The Responder supplies a random number I, and requires
            the Initiator to find a number J. &nbsp;To select a proper J, the
            Initiator must create the concatenation of I, the HITs of
            the parties, and J, and take a hash over this concatenation
            using the RHASH algorithm.  The lowest order K bits of the
            result MUST be zeros.  The value K sets the difficulty of
            the puzzle.
          </t>

          <t>
            To generate a proper number J, the Initiator will have to
            generate a number of Js until one produces the hash target
            of zeros.  The Initiator SHOULD give up after exceeding the
            puzzle lifetime in the PUZZLE parameter (<xref
            target="sec-puzzle" />).  The Responder needs to re-create
            the concatenation of I, the HITs, and the provided J, and
            compute the hash once to prove that the Initiator did its
            assigned task.
          </t>

          <t>
            To prevent precomputation attacks, the Responder MUST
            select the number I in such a way that the Initiator cannot
            guess it.  Furthermore, the construction MUST allow the
            Responder to verify that the value was indeed selected by it
            and not by the Initiator.  See <xref target="resp-cookie" />
            for an example on how to implement this.
          </t>

          <t>
            Using the Opaque data field in an ECHO_REQUEST_SIGNED (<xref
            target="sec-echo-request-signed" />) or in an
            ECHO_REQUEST_UNSIGNED parameter (<xref
            target="sec-echo-request-unsigned" />), the Responder can
            include some data in R1 that the Initiator must copy
            unmodified in the corresponding I2 packet.  The Responder
            can generate the Opaque data in various ways; e.g., using
            some secret, the sent I, and possibly other related data.
            Using the same secret, the received I (from the I2), and the
            other related data (if any), the Receiver can verify that it
            has itself sent the I to the Initiator. The Responder MUST
            periodically change such a used secret.
          </t>

          <t>
            It is RECOMMENDED that the Responder generates a new puzzle
            and a new R1 once every few minutes.  Furthermore, it is
            RECOMMENDED that the Responder remembers an old puzzle at
            least 2*Lifetime seconds after the puzzle has been deprecated.
            These time values allow a slower Initiator to solve the
            puzzle while limiting the usability that an old,
            solved puzzle has to an attacker.
          </t>

          <t>
            NOTE: The protocol developers explicitly considered whether
            R1 should include a timestamp in order to protect the
            Initiator from replay attacks.  The decision was to NOT 
            include a timestamp.
          </t>

          <t>
            NOTE: The protocol developers explicitly considered whether
            a memory bound function should be used for the puzzle
            instead of a CPU-bound function.  The decision was not to
            use memory-bound functions.  At the time of the decision, the
            idea of memory-bound functions was relatively new and their
            IPR status were unknown.  Once there is more experience
            about memory-bound functions and once their IPR status is
            better known, it may be reasonable to reconsider this
            decision.
          </t>

        </section>

        <section anchor="auth_dh" 
          title="Authenticated Diffie-Hellman Protocol">
          
          <t>
            The packets R1, I2, and R2 implement a standard
            authenticated Diffie-Hellman exchange.  The Responder sends
            one or two public Diffie-Hellman keys and its public
            authentication key, i.e., its Host Identity, in R1.  The
            signature in R1 allows the Initiator to verify that the R1
            has been once generated by the Responder.  However, since it
            is precomputed and therefore does not cover all of the
            packet, it does not protect from replay attacks.
          </t>


          <t>
            When the Initiator receives an R1, it gets one or two public
            Diffie-Hellman values from the Responder.  If there are two
            values, it selects the value corresponding to the strongest
            supported Group ID  and computes the Diffie-Hellman session
            key (Kij).  It creates a HIP association using keying
            material from the session key (see <xref target="keymat"
            />), and may use the association to encrypt its public
            authentication key, i.e., Host Identity.  The resulting I2
            contains the Initiator's Diffie-Hellman key and its
            (optionally encrypted) public authentication key.  The
            signature in I2 covers all of the packet.
          </t>


          <t>
            The Responder extracts the Initiator Diffie-Hellman public
            key from the I2, computes the Diffie-Hellman session key,
            creates a corresponding HIP association, and
            decrypts the Initiator's public authentication key.  It can
            then verify the signature using the authentication key.
          </t>

          <t>
            The final message, R2, is needed to protect the Initiator
            from replay attacks.
          </t>

        </section>

        <section anchor="hip-replay" title="HIP Replay Protection">

          <t>
            The HIP protocol includes the following mechanisms to
            protect against malicious replays.  Responders are protected
            against replays of I1 packets by virtue of the stateless
            response to I1s with presigned R1 messages.  Initiators are
            protected against R1 replays by a monotonically increasing
            "R1 generation counter" included in the R1.  Responders are
            protected against replays or false I2s by the puzzle
            mechanism (<xref target="hip-cookie" /> above), and optional
            use of opaque data.  Hosts are protected against replays to
            R2s and UPDATEs by use of a less expensive HMAC verification
            preceding HIP signature verification.
          </t>

          <t>
            The R1 generation counter is a monotonically increasing
            64-bit counter that may be initialized to any value.  The
            scope of the counter MAY be system-wide but SHOULD be per
            Host Identity, if there is more than one local host
            identity.  The value of this counter SHOULD be kept across
            system reboots and invocations of the HIP base exchange.
            This counter indicates the current generation of puzzles.
            Implementations MUST accept puzzles from the current
            generation and MAY accept puzzles from earlier generations.
            A system's local counter MUST be incremented at least as
            often as every time old R1s cease to be valid, and SHOULD
            never be decremented, lest the host expose its peers to the
            replay of previously generated, higher numbered R1s.  The
            R1 counter SHOULD NOT roll over. 
          </t>

          <t>
            A host may receive more than one R1, either due to sending
            multiple I1s (<xref target="multi-i1" />) or due to a replay
            of an old R1.  When sending multiple I1s, an Initiator
            SHOULD wait for a small amount of time (a reasonable time
            may be 2 * expected RTT) after the first R1 reception
            to allow possibly multiple R1s to arrive, and it SHOULD
            respond to an R1 among the set with the largest R1
            generation counter.  If an Initiator is processing an R1 or
            has already sent an I2 (still waiting for R2) and it
            receives another R1 with a larger R1 generation counter, it
            MAY elect to restart R1 processing with the fresher R1, as
            if it were the first R1 to arrive.
          </t>

          <t>
            Upon conclusion of an active HIP association with another
            host, the R1 generation counter associated with the peer
            host SHOULD be flushed.  A local policy MAY override the
            default flushing of R1 counters on a per-HIT basis.  The
            reason for recommending the flushing of this counter is that
            there may be hosts where the R1 generation counter
            (occasionally) decreases; e.g., due to hardware failure.
          </t>
        </section>

        <section title="Refusing a HIP Exchange">
          
          <t>
            A HIP-aware host may choose not to accept a HIP exchange.  
            If the host's policy is to only be an Initiator, it 
            should begin its own HIP exchange.  A host MAY choose 
            to have such a policy
            since only the Initiator's HI is protected in the exchange.
            There is a risk of a race condition if each host's policy is
            to only be an Initiator, at which point the HIP 
            exchange will fail.
          </t>
          
          <t>
            If the host's policy does not permit it to enter into a HIP
            exchange with the Initiator, it should send an ICMP
            'Destination Unreachable, Administratively Prohibited'
            message.  A more complex HIP packet is not used here as it
            actually opens up more potential DoS attacks than a simple
            ICMP message.
          </t>
          
        </section>

        <section anchor="op_mode" title="HIP Opportunistic Mode">

          <t>
            It is possible to initiate a HIP negotiation even if the
            Responder's HI (and HIT) is unknown.  In this case, the
            connection initializing I1 packet contains NULL (all zeros)
            as the destination HIT.  This kind of connection setup is
            called opportunistic mode.
          </t>
          <t>
            There are both security and API issues involved with the
            opportunistic mode.
          </t>
          <t>
            Given that the Responder's HI is not known by the Initiator,
            there must be suitable API calls that allow the Initiator to
            request, directly or indirectly, that the underlying kernel 
            initiate the HIP base exchange solely based on locators.
            The Responder's HI will be tentatively available in the R1
            packet, and in an authenticated form once the R2 packet has
            been received and verified.  Hence, it could be communicated
            to the application via new API mechanisms.  However, with a
            backwards-compatible API the application sees only the
            locators used for the initial contact.  Depending on the
            desired semantics of the API, this can raise the following
            issues:
          </t>
          <t>
            <list style="symbols">
              <t>
                The actual locators may later change if an UPDATE
                message is used, even if from the API perspective the
                session still appears to be between specific
                locators. The locator update is still secure, however,
                and the session is still between the same nodes.
              </t>
              <t>
                Different sessions between the same locators may result
                in connections to different nodes, if the implementation
                no longer remembers which identifier the peer had in
                another session.  This is possible when the peer's
                locator has changed for legitimate reasons or when an
                attacker pretends to be a node that has the peer's
                locator.  Therefore, when using opportunistic mode, HIP
                MUST NOT place any expectation that the peer's HI
                returned in the R1 message matches any HI previously
                seen from that address.
                <vspace blankLines='1' />
                If the HIP implementation and application do not have the
                same understanding of what constitutes a session, this
                may even happen within the same session. For instance,
                an implementation may not know when HIP state can
                be purged for UDP-based applications.  
              </t>
              <t>
                As with all HIP exchanges, the handling of locator-based
                or interface-based policy is unclear for opportunistic
                mode HIP.  An application may make a connection to a
                specific locator because the application has knowledge
                of the security properties along the network to that
                locator.  If one of the nodes moves and the locators are
                updated, these security properties may not be
                maintained.  Depending on the security policy of the
                application, this may be a problem. This is an area of
                ongoing study.  As an example, there is work to create an
                API that applications can use to specify their security
                requirements in a similar context <xref
                target="IPsec-APIs" />.
              </t>
            </list>
          </t>
          <t>
            In addition, the following security considerations
            apply.  The generation counter mechanism will be less
            efficient in protecting against replays of the R1
            packet, given that the Responder can choose a replay
            that uses any HI, not just the one given in the I1
            packet.
          </t>
          <t>
            More importantly, the opportunistic exchange is
            vulnerable to man-in-the-middle attacks, because the
            Initiator does not have any public key information about
            the peer. To assess the impacts of this vulnerability,
            we compare it to vulnerabilities in current, non-HIP-capable
             communications.
          </t>
          <t>
            An attacker on the path between the two peers can insert
            itself as a man-in-the-middle by providing its own
            identifier to the Initiator and then initiating another
            HIP session towards the Responder. For this to be
            possible, the Initiator must employ opportunistic mode,
            and the Responder must be configured to accept a
            connection from any HIP-enabled node.
          </t>
          <t>
            An attacker outside the path will be unable to do so,
            given that it cannot respond to the messages in the base
            exchange.
          </t>
          <t>
            These properties are characteristic also of
            communications in the current Internet. A client
            contacting a server without employing end-to-end
            security may find itself talking to the server via a
            man-in-the-middle, assuming again that the server is
            willing to talk to anyone.
          </t>
          <t>
            If end-to-end security is in place, then the worst that
            can happen in both the opportunistic HIP and normal IP
            cases is denial-of-service; an entity on the path can
            disrupt communications, but will be unable to insert
            itself as a man-in-the-middle.
          </t>
          <t>
            However, once the opportunistic exchange has
            successfully completed, HIP provides integrity
            protection and confidentiality for the communications,
            and can securely change the locators of the endpoints.
          </t>
          <t>
            As a result, it is believed that the HIP opportunistic
            mode is at least as secure as current IP.
          </t>
        </section>
      </section>
      
      <section title="Updating a HIP Association">
        
        <t>
          A HIP association between two hosts may need to be updated
          over time.  Examples include the need to rekey expiring user
          data security associations, add new security associations, 
          or change IP addresses associated with hosts.  The UPDATE 
          packet
          is used for those and other similar purposes.  This document
          only specifies the UPDATE packet format and basic processing
          rules, with mandatory parameters.  The actual usage is defined in
          separate specifications.
        </t>
        
        <t>
          HIP provides a general purpose UPDATE packet, which can
          carry multiple HIP parameters, for updating the HIP state
          between two peers.  The UPDATE mechanism has the following
          properties:
          <list>
            <t>
              UPDATE messages carry a monotonically increasing
              sequence number and are explicitly acknowledged by the
              peer.  Lost UPDATEs or acknowledgments may be recovered
              via retransmission.  Multiple UPDATE messages may be
              outstanding under certain circumstances.
            </t>
            
            <t>
              UPDATE is protected by both HMAC and HIP_SIGNATURE
              parameters, since processing UPDATE signatures alone is
              a potential DoS attack against intermediate systems.
            </t>
            <t>
              UPDATE packets are explicitly acknowledged by the use of
              an acknowledgment parameter that echoes an individual
              sequence number received from the peer.  A single UPDATE
              packet may contain both a sequence number and one or
              more acknowledgment numbers (i.e., piggybacked
              acknowledgment(s) for the peer's UPDATE).
            </t>
            
          </list>
        </t>
        
        <t>
          The UPDATE packet is defined in <xref target="UPDATE" />.
        </t>
        
      </section>
      
      <section anchor="error_proc" title="Error Processing">
        <t>
          HIP error processing behavior depends on whether or not there
          exists an active HIP association.  In general, if
          a HIP association exists between the sender and receiver
          of a packet causing an error condition, the receiver
          SHOULD respond with a NOTIFY packet.  On the other hand,
          if there are no existing HIP associations between the
          sender and receiver, or the receiver cannot reasonably
          determine the identity of the sender, the receiver MAY
          respond with a suitable ICMP message; see <xref
            target="ICMP" /> for more details.
        </t>
        
        <t>
          The HIP protocol and state machine is designed to recover
          from one of the parties crashing and losing its state.  The
          following scenarios describe the main use cases covered by
          the design.
          
          <list>

            <t>No prior state between the two systems.
              <list>
                <t>
                  The system with data to send is the Initiator.  The
                  process follows the standard four-packet base
                  exchange, establishing the HIP association.
                </t>
              </list>
            </t>

            <t>
              The system with data to send has no state with the
              receiver, but the receiver has a residual HIP association.
              <list>
                <t>
                  The system with data to send is the Initiator.  The
                  Initiator acts as in no prior state, sending I1 and
                  getting R1.  When the Responder receives a valid I2,
                  the old association is 'discovered' and deleted, and
                  the new association is established.
                </t>
              </list>
            </t>


            <t>
              The system with data to send has a HIP association, but 
              the receiver does not.

              <list>
                <t>
                  The system sends data on the outbound user data
                  security association.  The receiver 'detects' the
                  situation when it receives a user data packet that it
                  cannot match to any HIP association.  
  The receiving host MUST discard this packet.</t>

<t>
  Optionally, the receiving host MAY send an ICMP packet, with the
  type Parameter Problem, to inform the sender that the HIP
  association does not exist (see Section 5.4), and it MAY initiate a
  new HIP negotiation.  However, responding with these optional
         mechanisms is implementation or policy dependent.
                </t>

              </list>
            </t>

          </list>
        </t>
      </section>

      <section anchor="state-machine" title="HIP State Machine">

        <t>
          The HIP protocol itself has little state.  In the HIP
          base exchange, there is an Initiator and a Responder.  Once
          the security associations (SAs) are established, this distinction is lost.  If the HIP
          state needs to be re-established, the controlling parameters
          are which peer still has state and which has a datagram to
          send to its peer.  The following state machine attempts to
          capture these processes.
        </t>

        <t>
          The state machine is presented in a single system view,
          representing either an Initiator or a Responder.  There is not
          a complete overlap of processing logic here and in the packet
          definitions.  Both are needed to completely implement HIP.
        </t>

        <t>
          Implementors must understand that the state machine, as
          described here, is informational.  Specific implementations
          are free to implement the actual functions differently.  <xref
          target="packet_processing" /> describes the packet processing
          rules in more detail.  This state machine focuses on the HIP
          I1, R1, I2, and R2 packets only.  Other states may be
          introduced by mechanisms in other specifications (such as
          mobility and multihoming).
        </t>

        <section anchor="states" title="HIP States">

<?rfc compact="no"?>

          <texttable align="left" title="HIP States" anchor="table_states">
            <ttcol width="30%" align="left">State</ttcol>
            <ttcol align="left">Explanation</ttcol>
            <c>UNASSOCIATED</c><c>State machine start</c>
            <c>I1-SENT</c><c> Initiating base exchange </c>
            <c>I2-SENT</c><c> Waiting to complete base exchange </c>
            <c>R2-SENT</c><c> Waiting to complete base exchange </c>
            <c>ESTABLISHED</c><c> HIP association established </c>
            <c>CLOSING</c><c> HIP association closing, no data can be sent</c>
            <c>CLOSED</c><c> HIP association closed, no data can be sent</c>
            <c>E-FAILED</c><c> HIP exchange failed </c>
          </texttable>

<?rfc compact="yes"?>

        </section>
        <section title="HIP State Processes">

<?rfc compact="no"?>

          <texttable align="left" title="UNASSOCIATED - Start state" anchor="table_unassociated">
            <preamble>System behavior in state UNASSOCIATED, <xref
            target="table_unassociated" />.</preamble>
            <ttcol width="30%" align="left">Trigger</ttcol>
            <ttcol align="left">Action</ttcol>
            <c>User data to send, requiring a new HIP association</c>
            <c>Send I1 and go to I1-SENT</c>
            <c>Receive I1</c>
            <c>Send R1 and stay at UNASSOCIATED</c>
            <c>Receive I2, process</c>
            <c>If successful, send R2 and go to R2-SENT</c>
            <c></c>
            <c>If fail, stay at UNASSOCIATED</c>
            <c>Receive user data for unknown HIP association</c>
            <c>Optionally send ICMP as defined in <xref target="ICMP" /> 
            and stay at UNASSOCIATED</c>
            <c>Receive CLOSE</c>
            <c>Optionally send ICMP Parameter Problem and stay at
            UNASSOCIATED</c>
            <c>Receive ANYOTHER</c>
            <c>Drop and stay at UNASSOCIATED</c>
            </texttable>

          <texttable align="left" title="I1-SENT - Initiating HIP" anchor="table_i1sent">
            <preamble>System behavior in state I1-SENT, <xref
                target="table_i1sent" />.</preamble>
            <ttcol width="30%" align="left">Trigger</ttcol>
            <ttcol align="left">Action</ttcol>
            <c>Receive I1</c>
            <c>If the local HIT is smaller than the peer HIT, drop I1 and 
            stay at I1-SENT</c>
            <c></c>
            <c>If the local HIT is greater than the peer HIT, send R1
            and stay at I1_SENT</c>
            <c>Receive I2, process</c>
            <c>If successful, send R2 and go to R2-SENT</c>
            <c></c>
            <c>If fail, stay at I1-SENT</c>
            <c>Receive R1, process</c>
            <c>If successful, send I2 and go to I2-SENT</c>
            <c></c>
            <c>If fail, stay at I1-SENT</c>
            <c>Receive ANYOTHER</c>
            <c>Drop and stay at I1-SENT</c>
            <c>Timeout, increment timeout counter</c>
            <c>If counter is less than I1_RETRIES_MAX, send I1 and stay at I1-SENT</c>
            <c></c>
            <c>If counter is greater than I1_RETRIES_MAX, go to E-FAILED</c>
            </texttable>


          <texttable align="left" title="I2-SENT - Waiting to finish HIP" anchor="table_i2sent">
            <preamble>System behavior in state I2-SENT, <xref
                target="table_i2sent" />.</preamble>
            <ttcol width="30%" align="left">Trigger</ttcol>
            <ttcol align="left">Action</ttcol>

            <c>Receive I1</c>
            <c>Send R1 and stay at I2-SENT</c>
            <c>Receive R1, process</c>
            <c>If successful, send I2 and cycle at I2-SENT</c>
            <c></c>
            <c>If fail, stay at I2-SENT</c>
            <c>Receive I2, process</c>
            <c>If successful and local HIT is smaller than the peer HIT, 
              drop I2 and stay at I2-SENT</c>
            <c></c>
            <c>If successful and local HIT is greater than the peer HIT, 
              send R2 and go to R2-SENT</c>
            <c></c>
            <c>If fail, stay at I2-SENT</c>
            <c>Receive R2, process</c>
            <c>If successful, go to ESTABLISHED</c>
            <c></c>
            <c>If fail, stay at I2-SENT</c>
            <c>Receive ANYOTHER</c>
            <c>Drop and stay at I2-SENT</c>
            <c>Timeout, increment timeout counter</c>
            <c>If counter is less than I2_RETRIES_MAX, send I2 and 
              stay at I2-SENT</c>
            <c></c>
            <c>If counter is greater than I2_RETRIES_MAX, go to E-FAILED</c>
            </texttable>

          <texttable align="left" title="R2-SENT - Waiting to finish HIP" anchor="table_r2sent">
            <preamble>System behavior in state R2-SENT, <xref
                target="table_r2sent" />.</preamble>
            <ttcol width="30%" align="left">Trigger</ttcol>
            <ttcol align="left">Action</ttcol>
            <c>Receive I1</c>
            <c>Send R1 and stay at R2-SENT</c>
            <c>Receive I2, process</c>
            <c>If successful, send R2 and cycle at R2-SENT</c>
            <c></c>
            <c>If fail, stay at R2-SENT</c>
            <c>Receive R1</c>
            <c>Drop and stay at R2-SENT</c>
            <c>Receive R2</c>
            <c>Drop and stay at R2-SENT</c>
            <c>Receive data or UPDATE</c>
            <c>Move to ESTABLISHED</c>
            <c>Exchange Complete Timeout</c>
            <c>Move to ESTABLISHED</c>
            </texttable>


          <texttable align="left" 
            title="ESTABLISHED - HIP association established" 
            anchor="table_established">
            <preamble>System behavior in state ESTABLISHED, <xref
                target="table_established" />.</preamble>
            <ttcol width="30%" align="left">Trigger</ttcol>
            <ttcol align="left">Action</ttcol>
            <c>Receive I1</c>
            <c>Send R1 and stay at ESTABLISHED</c>
            <c>Receive I2, process with puzzle and possible Opaque 
              data verification</c>
            <c>If successful, send R2, drop old HIP association, 
              establish a new HIP association, go to R2-SENT</c>
            <c></c>
            <c>If fail, stay at ESTABLISHED</c>
            <c>Receive R1</c>
            <c>Drop and stay at ESTABLISHED</c>
            <c>Receive R2</c>
            <c>Drop and stay at ESTABLISHED</c>
            <c>Receive user data for HIP association</c>
            <c>Process and stay at ESTABLISHED</c>
            <c>No packet sent/received during UAL minutes</c>
            <c>Send CLOSE and go to CLOSING</c>
            <c>Receive CLOSE, process</c>
            <c>If successful, send CLOSE_ACK and go to CLOSED</c>
            <c></c>
            <c>If fail, stay at ESTABLISHED</c>
            </texttable>

          <texttable align="left" title="CLOSING - HIP association has not been used for UAL minutes" anchor="table_closing">
            <preamble>System behavior in state CLOSING, <xref
                target="table_closing" />.</preamble>
            <ttcol width="30%" align="left">Trigger</ttcol>
            <ttcol align="left">Action</ttcol>
            <c>User data to send, requires the creation of another incarnation
            of the HIP association</c>
            <c>Send I1 and stay at CLOSING</c>
            <c>Receive I1</c>
            <c>Send R1 and stay at CLOSING</c>
            <c>Receive I2, process</c>
            <c>If successful, send R2 and go to R2-SENT</c>
            <c></c>
            <c>If fail, stay at CLOSING</c>
            <c>Receive R1, process</c>
            <c>If successful, send I2 and go to I2-SENT</c>
            <c></c>
            <c>If fail, stay at CLOSING</c>
            <c>Receive CLOSE, process</c>
            <c>If successful, send CLOSE_ACK, discard state and 
              go to CLOSED</c>
            <c></c>
            <c>If fail, stay at CLOSING</c>
            <c>Receive CLOSE_ACK, process</c>
            <c>If successful, discard state and go to UNASSOCIATED</c>
            <c></c>
            <c>If fail, stay at CLOSING</c>
            <c>Receive ANYOTHER</c>
            <c>Drop and stay at CLOSING</c>
            <c>Timeout, increment timeout sum, reset timer</c>
            <c>If timeout sum is less than UAL+MSL minutes, retransmit CLOSE
            and stay at CLOSING</c>
            <c></c>
            <c>If timeout sum is greater than UAL+MSL minutes, go 
              to UNASSOCIATED</c>
            </texttable>

          <texttable align="left" title="CLOSED - CLOSE_ACK sent, resending CLOSE_ACK if necessary"
            anchor="table_closed">
            <preamble>System behavior in state CLOSED, <xref
                target="table_closed" />.</preamble>
            <ttcol width="30%" align="left">Trigger</ttcol>
            <ttcol align="left">Action</ttcol>
            <c>Datagram to send, requires the creation of another incarnation
            of the HIP association</c>
            <c>Send I1, and stay at CLOSED</c>
            <c>Receive I1</c>
            <c>Send R1 and stay at CLOSED</c>
            <c>Receive I2, process</c>
            <c>If successful, send R2 and go to R2-SENT</c>
            <c></c>
            <c>If fail, stay at CLOSED</c>
            <c>Receive R1, process</c>
            <c>If successful, send I2 and go to I2-SENT</c>
            <c></c>
            <c>If fail, stay at CLOSED</c>
            <c>Receive CLOSE, process</c>
            <c>If successful, send CLOSE_ACK, stay at CLOSED</c>
            <c></c>
            <c>If fail, stay at CLOSED</c>
            <c>Receive CLOSE_ACK, process</c>
            <c>If successful, discard state and go to UNASSOCIATED</c>
            <c></c>
            <c>If fail, stay at CLOSED</c>
            <c>Receive ANYOTHER</c>
            <c>Drop and stay at CLOSED</c>
            <c>Timeout (UAL+2MSL)</c>
            <c>Discard state, and go to UNASSOCIATED</c>
          </texttable>

<?rfc needLines="10"?>

          <texttable align="left" title="E-FAILED - HIP failed to establish association with peer"
            anchor="table_efailed">
            <preamble>System behavior in state E-FAILED, <xref
                target="table_efailed" />.</preamble>
            <ttcol width="30%" align="left">Trigger</ttcol>
            <ttcol align="left">Action</ttcol>
            <c>Wait for implementation-specific time</c>
            <c>Go to UNASSOCIATED. Re-negotiation is possible after moving to 
            UNASSOCIATED state.</c>
          </texttable>

<?rfc compact="yes"?>

        </section>

                         
        <section anchor="hipstates" title="Simplified HIP State Diagram">
                         
          <t>            
            The following diagram shows the major state transitions.
            Transitions based on received packets implicitly assume that
            the packets are successfully authenticated or processed.
          </t>           

          <figure>       
            <artwork>    
                             +-+        +---------------------------+
        I1 received, send R1 | |        |                           |
                             | v        v                           |
         Datagram to send  +--------------+  I2 received, send R2   |
           +---------------| UNASSOCIATED |---------------+         |
   Send I1 |               +--------------+               |         |
           v                                              |         |
      +---------+  I2 received, send R2                   |         |
+----&gt;| I1-SENT |---------------------------------------+ |         |
|     +---------+                                       | |         |
|          |                 +------------------------+ | |         |
|          | R1 received,    | I2 received, send R2   | | |         |
|          v send I2         |                        v v v         |
|     +---------+            |                   +---------+        |
|  +-&gt;| I2-SENT |------------+                   | R2-SENT |&lt;----+  |
|  |  +---------+                                +---------+     |  |
|  |          |                                     |            |  |
|  |          |                                 data|            |  |
|  |receive   |                                   or|            |  |
|  |R1, send  |                           EC timeout| receive I2,|  |
|  |I2        |R2 received +--------------+         |     send R2|  |
|  |          +-----------&gt;| ESTABLISHED  |&lt;-------+|            |  |
|  |                       +--------------+                      |  |
|  |                         |    |     |  receive I2, send R2   |  |
|  |        recv+------------+    |     +------------------------+  |
|  |      CLOSE,|                 |                              |  |
|  |        send|   No packet sent|                              |  |
|  |   CLOSE_ACK|   /received for |                   timeout    |  |
|  |            |   UAL min, send |    +---------+&lt;-+ (UAL+MSL)  |  |
|  |            |           CLOSE +---&gt;| CLOSING |--+ retransmit |  |
|  |            |                      +---------+    CLOSE      |  |
+--|------------|----------------------+ | |  | |                |  |
   +------------|------------------------+ |  | +----------------+  |
   |            |              +-----------+  +------------------|--+
   |            +------------+ | receive CLOSE,   CLOSE_ACK      |  |
   |                         | | send CLOSE_ACK   received or    |  |
   |                         | |                  timeout        |  |
   |                         | |                  (UAL+MSL)      |  |
   |                         v v                                 |  |
   |                        +--------+  receive I2, send R2      |  |
   +------------------------| CLOSED |---------------------------+  |  
                            +--------+       /----------------------+
                              ^ |   \-------/  timeout (UAL+2MSL),
                              +-+              move to UNASSOCIATED
               CLOSE received, send CLOSE_ACK
                                             
            </artwork>                      
          </figure> 

        </section> 
      </section>
      
      <section title="User Data Considerations">
        
        <section title="TCP and UDP Pseudo-Header Computation for User Data">
          
          <t>
            When computing TCP and UDP checksums on user data packets
            that flow through sockets bound to HITs, the IPv6
            pseudo-header format <xref target="RFC2460" /> MUST be used,
            even if the actual addresses on the packet are IPv4 addresses.
            Additionally, the HITs MUST be used in the place of the IPv6
            addresses in the IPv6 pseudo-header.  Note that the
            pseudo-header for actual HIP payloads is computed
            differently; see <xref target="ssec-crc" />.
          </t>
          
        </section>
        
        
        <section title="Sending Data on HIP Packets">
          
          <t>
            A future version of this document may define how to include
            user data on various HIP packets.  However, currently the
            HIP header is a terminal header, and not followed by any
            other headers.
          </t>
        </section>
        
        <section title="Transport Formats">
          <t>
            The actual data transmission format, used for user data
            after the HIP base exchange, is not defined in this
            document.  Such transport formats and methods are described
            in separate specifications.  All HIP implementations MUST
            implement, at minimum, the ESP transport format for HIP
            <xref target="RFC5202" />.
          </t>
          <t>
            When new transport formats are defined, they get the type
            value from the HIP Transform type value space 2048-4095.
            The order in which the transport formats are presented in
            the R1 packet, is the preferred order.  The last of the
            transport formats MUST be ESP transport format, represented
            by the ESP_TRANSFORM parameter.
          </t>
        </section>
        
        <section anchor="reboot" title="Reboot and SA Timeout Restart of HIP">

          <t>
            Simulating a loss of state is a potential DoS attack.  The
            following process has been crafted to manage state recovery
            without presenting a DoS opportunity.
          </t>

          <t>
            If a host reboots or the HIP association times out, it has
            lost its HIP state.  If the host that lost state has a
            datagram to send to the peer, it simply restarts the HIP
            base exchange.  After the base exchange has completed, the
            Initiator can create a new SA and start sending data.  The
            peer does not reset its state until it receives a valid I2
            HIP packet.
          </t>
          
          <t>
            If a system receives a user data packet that cannot be
            matched to any existing HIP association, it is possible that
            it has lost the state and its peer has not.  It MAY send an
            ICMP packet with the Parameter Problem type, and with the pointer
            pointing to the referred HIP-related association
            information.  Reacting to such traffic depends on the
            implementation and the environment where the implementation
            is used.
          </t>

          <t>
            If the host, that apparently has lost its state, decides
            to restart the HIP base exchange, it sends an I1 packet to the 
            peer.  After the base exchange has been completed successfully, 
            the Initiator can create a new HIP association and the peer
            drops its old SA and creates a new one.
          </t>

        </section>
        
      </section>

      <section title="Certificate Distribution">
        
        <t>
          This document does not define how to use certificates
          or how to transfer them between hosts.  These functions are
expected to be
          defined in a future specification.  A parameter type value,
          meant to be used for carrying certificates, is reserved,
          though: CERT, Type 768; see <xref target="hippars" />.
        </t>
          
        </section>
      
    </section>
    
    
    
    <section anchor="sec-param-tlv" title="Packet Formats">
                                              
      <section anchor="ssec-payload" title="Payload Format">
                                              
        <t>                                   
          All HIP packets start with a fixed header.
        </t>                                  
                                              

        <figure>                              
          <artwork>

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Next Header   | Header Length |0| Packet Type |  VER. | RES.|1|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Checksum             |           Controls            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Sender's Host Identity Tag (HIT)               |
|                                                               |
|                                                               |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               Receiver's Host Identity Tag (HIT)              |
|                                                               |
|                                                               |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                        HIP Parameters                         /
/                                                               /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

          </artwork>
        </figure>

        <t>
          The HIP header is logically an IPv6 extension header.
          However, this document does not describe processing for Next
          Header values other than decimal 59, IPPROTO_NONE, the IPv6 'no
          next header' value.  Future documents MAY do so.  However,
          current implementations MUST ignore trailing data if an
          unimplemented Next Header value is received.
        </t>

        <t>
          The Header Length field contains the length of the HIP Header
          and HIP parameters in 8-byte units, excluding the first 8
          bytes.  Since all HIP headers MUST contain the sender's and
          receiver's HIT fields, the minimum value for this field is 4,
          and conversely, the maximum length of the HIP Parameters field
          is (255*8)-32 = 2008 bytes.  Note: this sets an additional
          limit for sizes of parameters included in the Parameters field,
          independent of the individual parameter maximum lengths.
        </t>

        <t>
          The Packet Type indicates the HIP packet type.  The individual
          packet types are defined in the relevant sections.  If a HIP
          host receives a HIP packet that contains an unknown packet
          type, it MUST drop the packet.
        </t>

        <t>
          The HIP Version is four bits.  The current version is 1.  The
          version number is expected to be incremented only if there are
          incompatible changes to the protocol.  Most extensions can be
          handled by defining new packet types, new parameter types, or
          new controls.
        </t>

        <t>
          The following three bits are reserved for future use.  They
          MUST be zero when sent, and they SHOULD be ignored when
          handling a received packet.  
        </t>

        <t>
          The two fixed bits in the header are reserved for potential
          SHIM6 compatibility <xref target="SHIM6-PROTO" />.
          For implementations adhering (only) to this specification,
          they MUST be set as shown when sending and MUST be ignored
          when receiving.  This is to ensure optimal forward
          compatibility.  Note that for implementations that implement
          other compatible specifications in addition to this
          specification, the corresponding rules may well be
          different.  For example, in the case that the forthcoming
          SHIM6 protocol happens to be compatible with this
          specification, an implementation that implements both this
          specification and the SHIM6 protocol may need to check these
          bits in order to determine how to handle the packet.
        </t>

        <t>The HIT fields are always 128 bits (16 bytes) long.</t>

        
        <section anchor="ssec-crc" title="Checksum">
          
          <t>
            Since the checksum covers the source and destination
            addresses in the IP header, it must be recomputed on
            HIP-aware NAT devices.
          </t>
          <t>
            If IPv6 is used to carry the HIP packet, the pseudo-header
            <xref target="RFC2460" /> contains the source and
            destination IPv6 addresses, HIP packet length in the
            pseudo-header length field, a zero field, and the HIP
            protocol number (see <xref target="proto_overview" />) 
            in the Next
            Header field.  The length field is in bytes and can be
            calculated from the HIP header length field: <spanx
            style="tt">(HIP Header Length + 1) * 8</spanx>.
          </t>

          <t>
            In case of using IPv4, the IPv4 UDP pseudo-header format
            <xref target="RFC0768" /> is used.  In the pseudo-header,
            the source and destination addresses are those used in the
            IP header, the zero field is obviously zero, the protocol is
            the HIP protocol number (see <xref 
              target="proto_overview" />),
            and the length is calculated as in the IPv6 case.
          </t>

        </section>

        <section title="HIP Controls">

          <t>
            The HIP Controls section conveys information about the
            structure of the packet and capabilities of the host.
          </t>

          <t>
            The following fields have been defined:

            <figure>
              <artwork>
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | | | | | | | | | | | | | | | |A|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              </artwork>
            </figure>

            <list style="hanging">


              <t hangText="A - Anonymous: ">If this is set, the sender's
                HI in this packet is anonymous, i.e., one not listed in a
                directory.  Anonymous HIs SHOULD NOT be stored.  This
                control is set in packets R1 and/or I2.  The peer
                receiving an anonymous HI may choose to refuse it.</t>

	      
            </list>

            The rest of the fields are reserved for future use and 
            MUST be set to zero on sent packets and ignored 
            on received packets.
          </t>

        </section>
        <section title="HIP Fragmentation Support">
    
          <t>
            A HIP implementation must support IP fragmentation/reassembly.  Fragment reassembly MUST be implemented in both
            IPv4 and IPv6, but fragment generation is REQUIRED to be
            implemented in IPv4 (IPv4 stacks and networks will usually
            do this by default) and RECOMMENDED to be implemented in
            IPv6. In IPv6 networks, the minimum MTU is larger, 1280
            bytes, than in IPv4 networks.  The larger MTU size is
            usually sufficient for most HIP packets, and therefore
            fragment generation may not be needed.  If a host expects to
            send HIP packets that are larger than the minimum IPv6 MTU,
            it MUST implement fragment generation even for IPv6.
          </t>
    
          <t>
            In IPv4 networks, HIP packets may encounter low MTUs along
            their routed path.  Since HIP does not provide a mechanism 
            to use multiple IP datagrams for a single HIP packet, 
            support for path MTU discovery does not bring any value to 
            HIP in IPv4 networks.  HIP-aware NAT devices MUST 
            perform any IPv4 reassembly/fragmentation.
          </t>
    
          <t>
            All HIP implementations have to be careful while employing a
            reassembly algorithm so that the algorithm is sufficiently
            resistant to DoS attacks.
          </t>
          <t>
            Because certificate chains can cause the packet to be
            fragmented and fragmentation can open implementation to
            denial-of-service attacks <xref target="KAU03" />, it
            is strongly recommended that the separate document
            specifying the certificate usage in the HIP Base Exchange
            defines the usage of "Hash and URL" formats rather than
            including certificates in exchanges.  With this, most
            problems related to DoS attacks with fragmentation can be
            avoided.
          </t>
        </section>


      </section>

      <section anchor="hippars" title="HIP Parameters">

        <t>
          The HIP Parameters are used to carry the public key associated
          with the sender's HIT, together with related security and
          other information.  They consist of ordered parameters, encoded 
          in TLV format.
        </t>


        <t>
          The following parameter types are currently defined.
        </t>

<?rfc compact="no"?>

        <texttable>
          <ttcol width="27%" align="left">TLV</ttcol>
          <ttcol width="5%" align="left">Type</ttcol>
          <ttcol width="14%" align="left">Length</ttcol>
          <ttcol align="left">Data</ttcol>
          <c>R1_COUNTER</c><c>128</c><c>12</c><c>System Boot Counter</c>
          <c>PUZZLE</c><c>257</c><c>12</c><c>K and Random #I</c>
          <c>SOLUTION</c><c>321</c><c>20</c><c>K, Random #I and puzzle
          solution J</c>
          <c>SEQ</c><c>385</c><c>4</c><c>Update packet ID number</c>
          <c>ACK</c><c>449</c><c>variable</c><c>Update packet ID number</c>
          <c>DIFFIE_HELLMAN</c><c>513</c><c>variable</c><c>public key</c>
          <c>HIP_TRANSFORM</c><c>577</c><c>variable</c><c>HIP Encryption
          and Integrity Transform</c>
          <c>ENCRYPTED</c><c>641</c><c>variable</c><c>Encrypted part of
          I2 packet</c>
          <c>HOST_ID</c><c>705</c><c>variable</c><c>Host Identity with
          Fully-Qualified Domain FQDN (Name) or Network Access Identifier (NAI)</c>
          <c>CERT</c><c>768</c><c>variable</c><c>HI Certificate; used 
          to transfer certificates. Usage is not currently defined, but it
          will be specified in a separate document once needed.</c>
          <c>NOTIFICATION</c><c>832</c><c>variable</c><c>Informational
            data</c>
          <c>ECHO_REQUEST_SIGNED</c><c>897</c><c>variable</c><c>Opaque
            data to be echoed back; under signature</c>
          <c>ECHO_RESPONSE_SIGNED</c><c>961</c><c>variable</c><c>Opaque data
            echoed back; under signature</c>
          <c>HMAC</c><c>61505</c><c>variable</c><c>HMAC-based message
            authentication code, with key material from HIP_TRANSFORM</c>
          <c>HMAC_2</c><c>61569</c><c>variable</c><c>HMAC based message
            authentication code, with key material from HIP_TRANSFORM. 
            Compared to HMAC, the HOST_ID parameter is included in HMAC_2
            calculation.</c>
          <c>HIP_SIGNATURE_2</c><c>61633</c><c>variable</c><c>Signature 
            of the R1 packet</c>
          <c>HIP_SIGNATURE</c><c>61697</c><c>variable</c><c>Signature 
            of the packet</c>
          <c>ECHO_REQUEST_UNSIGNED</c><c>63661</c><c>variable</c><c>Opaque
            data to be echoed back; after signature</c>
          <c>ECHO_RESPONSE_UNSIGNED</c><c>63425</c><c>variable</c><c>Opaque
            data echoed back; after signature</c>
        </texttable>

<?rfc compact="yes"?>

        <t>
          Because the ordering (from lowest to highest) of HIP
          parameters is strictly enforced (see <xref target="tlvformat"
          />), the parameter type values for existing parameters have
          been spaced to allow for future protocol extensions.
          Parameters numbered between 0-1023 are used in HIP handshake
          and update procedures and are covered by
          signatures. Parameters numbered between 1024-2047 are
          reserved. Parameters numbered between 2048-4095 are used for
          parameters related to HIP transform types.  Parameters
          numbered between 4096 and (2^16 - 2^12) 61439 are reserved.
          Parameters numbered between 61440-62463 are used for
          signatures and signed MACs.  Parameters numbered between
          62464-63487 are used for parameters that fall outside of the
          signed area of the packet.  Parameters numbered between
          63488-64511 are used for rendezvous and other relaying
          services.  Parameters numbered between 64512-65535 are
          reserved.
        </t>
        <section anchor="tlvformat" title="TLV Format">

          <t>
            The TLV-encoded parameters are described in the following
            subsections.  The type-field value also describes the order
            of these fields in the packet, except for type values from
            2048 to 4095 which are reserved for new transport forms.
            The parameters MUST be included in the packet such that
            their types form an increasing order.  If the parameter can
            exist multiple times in the packet, the type value may be
            the same in consecutive parameters.  If the order does not
            follow this rule, the packet is considered to be malformed
            and it MUST be discarded.
          </t>

          <t>
            Parameters using type values from 2048 up to 4095 are
            transport formats.  Currently, one transport format is
            defined: the ESP transport format <xref
            target="RFC5202" />.  The order of these
            parameters does not follow the order of their type value,
            but they are put in the packet in order of preference.
            The first of the transport formats it the most preferred,
            and so on.
          </t>

          <t>
            All of the TLV parameters have a length (including Type and
            Length fields), which is a multiple of 8 bytes.  When needed,
            padding MUST be added to the end of the parameter so that
            the total length becomes a multiple of 8 bytes.  This rule
            ensures proper alignment of data.  Any added padding bytes
            MUST be zeroed by the sender, and their values SHOULD NOT be
            checked by the receiver.
          </t>
          <t>
            Consequently, the Length field indicates the length of the
            Contents field (in bytes).  The total length of the TLV
            parameter (including Type, Length, Contents, and Padding) is
            related to the Length field according to the following
            formula:
          </t>

          <t>
            Total Length = 11 + Length - (Length + 3) % 8;
          </t>
<t>where % is the modulo operator</t>

          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type            |C|             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   /                          Contents                             /
   /                                               +-+-+-+-+-+-+-+-+
   |                                               |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type         Type code for the parameter. 16 bits long, C-bit  
                being part of the Type code.
     C          Critical.  One if this parameter is critical, and
                MUST be recognized by the recipient, zero otherwise.
                The C bit is considered to be a part of the Type
                field.  Consequently, critical parameters are always
                odd and non-critical ones have an even value.
   Length       Length of the Contents, in bytes.
   Contents     Parameter specific, defined by Type
   Padding      Padding, 0-7 bytes, added if needed
            </artwork>
          </figure>

          <t>
            Critical parameters MUST be recognized by the recipient.  If
            a recipient encounters a critical parameter that it does not
            recognize, it MUST NOT process the packet any further.  It
            MAY send an ICMP or NOTIFY, as defined in <xref
            target="error_proc" />.
          </t>

          <t>
            Non-critical parameters MAY be safely ignored.  If a
            recipient encounters a non-critical parameter that it does
            not recognize, it SHOULD proceed as if the parameter was not
            present in the received packet.
          </t>
        </section>

        <section title="Defining New Parameters">

          <t>
            Future specifications may define new parameters as needed.
            When defining new parameters, care must be taken to ensure
            that the parameter type values are appropriate and leave
            suitable space for other future extensions.  One must
            remember that the parameters MUST always be arranged in 
            increasing order by Type code, thereby limiting the
            order of parameters (see <xref target="tlvformat" />).
          </t>

          <t>
            The following rules must be followed when defining new
            parameters.

            <list style="numbers">

              <t>
                The low-order bit C of the Type code is used to
                distinguish between critical and non-critical
                parameters.
              </t>

              <t>
                A new parameter may be critical only if an old recipient
                ignoring it would cause security problems.  In general,
                new parameters SHOULD be defined as non-critical, and
                expect a reply from the recipient.
              </t>

              <t>
                If a system implements a new critical parameter, it MUST
                provide the ability to set the associated feature
                off, such that the critical parameter is not sent at
                all.  The configuration option must be well documented.
                Implementations operating in a mode adhering to this
                specification MUST disable the sending of new critical
                parameters.  In other words, the management interface
                MUST allow vanilla standards-only mode as a default
                configuration setting, and MAY allow new critical
                payloads to be configured on (and off).
              </t>

              <t>
                See <xref target="iana" /> for allocation rules
                regarding Type codes.
              </t>

            </list>
          </t>
        </section>
        <section anchor="r1_counter" title="R1_COUNTER">
          <figure>
            <artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Reserved, 4 bytes                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                R1 generation counter, 8 bytes                 |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type           128
   Length         12
   R1 generation
     counter      The current generation of valid puzzles

            </artwork>
          </figure>
          <t>
            The R1_COUNTER parameter contains a 64-bit unsigned integer
            in network-byte order, indicating the current generation of
            valid puzzles.  The sender is supposed to increment this
            counter periodically.  It is RECOMMENDED that the counter
            value is incremented at least as often as old PUZZLE values
            are deprecated so that SOLUTIONs to them are no longer
            accepted.
          </t>

          <t>
            The R1_COUNTER parameter is optional.  It SHOULD be included
            in the R1 (in which case, it is covered by the signature),
            and if present in the R1, it MAY be echoed (including the
            Reserved field verbatim) by the Initiator in the I2.
          </t>
        </section>


        <section anchor="sec-puzzle" title="PUZZLE">
          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  K, 1 byte    |    Lifetime   |        Opaque, 2 bytes        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Random #I, 8 bytes                       |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type           257
   Length         12
   K              K is the number of verified bits
   Lifetime       puzzle lifetime 2^(value-32) seconds
   Opaque         data set by the Responder, indexing the puzzle
   Random #I      random number

            </artwork>
          </figure>
          <t>
            Random #I is represented as a 64-bit integer, K and Lifetime
            as 8-bit integers, all in network byte order.
          </t>

          <t>
            The PUZZLE parameter contains the puzzle difficulty K and a
            64-bit puzzle random integer #I. &nbsp;The Puzzle Lifetime
            indicates the time during which the puzzle solution is
            valid, and sets a time limit that should not be exceeded by
            the Initiator while it attempts to solve the puzzle.  The
            lifetime is indicated as a power of 2 using the formula
            2^(Lifetime-32) seconds.  A puzzle MAY be augmented with an
            ECHO_REQUEST_SIGNED or an ECHO_REQUEST_UNSIGNED parameter
            included in the R1; the contents of the echo request are
            then echoed back in the ECHO_RESPONSE_SIGNED or in the
            ECHO_RESPONSE_UNSIGNED, allowing the Responder to use the
            included information as a part of its puzzle processing.
          </t>

          <t>
            The Opaque and Random #I field are not covered by the
            HIP_SIGNATURE_2 parameter.
          </t>
        </section>

        <section title="SOLUTION">
          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | K, 1 byte     |   Reserved    |        Opaque, 2 bytes        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Random #I, 8 bytes                       |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Puzzle solution #J, 8 bytes                   |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type               321
   Length             20
   K                  K is the number of verified bits
   Reserved           zero when sent, ignored when received
   Opaque             copied unmodified from the received PUZZLE 
                      parameter
   Random #I          random number
   Puzzle solution #J random number
            </artwork>
          </figure>
          <t>
            Random #I and Random #J are represented as 64-bit integers,
            K as an 8-bit integer, all in network byte order.
          </t>
          <t>
            The SOLUTION parameter contains a solution to a puzzle.  It
            also echoes back the random difficulty K, the Opaque field,
            and the puzzle integer #I.
          </t>
        </section>

        <section anchor="diffie_hellman" title="DIFFIE_HELLMAN">
          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Group ID    |      Public Value Length      | Public Value  /
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   /                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Group ID    |      Public Value Length      | Public Value  /
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   /                               |            padding            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type           513
   Length         length in octets, excluding Type, Length, and 
                  padding
   Group ID       defines values for p and g
   Public Value   length of the following Public Value in octets
     Length          
   Public Value   the sender's public Diffie-Hellman key
            </artwork>
          </figure>

          <t>The following Group IDs have been defined:</t>
          <figure>
            <artwork>
   Group                            Value
   Reserved                         0
   384-bit group                    1
   OAKLEY well-known group 1        2
   1536-bit MODP group              3
   3072-bit MODP group              4
   6144-bit MODP group              5
   8192-bit MODP group              6
            </artwork>
          </figure>

		  <t>
			The MODP Diffie-Hellman groups are defined in <xref
			target="RFC3526" />.  The OAKLEY well-known group 1 is
			defined in <xref target="oakley1" />.
	      </t>

          <t>
            The sender can include at most two different Diffie-Hellman
            public values in the DIFFIE_HELLMAN parameter.  This gives
            the possibility, e.g., for a server to provide a weaker
            encryption possibility for a PDA host that is not powerful
            enough.  It is RECOMMENDED that the Initiator, receiving
            more than one public value, selects the stronger one, if it
            supports it.
          </t>

          <t>
            A HIP implementation MUST implement Group IDs 1 and 3. The
            384-bit group can be used when lower security is enough
            (e.g., web surfing) and when the equipment is not powerful
            enough (e.g., some PDAs).  It is REQUIRED that the default
            configuration allows Group ID 1 usage, but it is RECOMMENDED
            that applications that need stronger security turn Group ID
            1 support off.  Equipment powerful enough SHOULD implement
            also Group ID 5.  The 384-bit group is defined in <xref
            target="384-bit-group" />.
          </t>

          <t>
            To avoid unnecessary failures during the base exchange,
            the rest of the groups SHOULD be implemented in hosts where
            resources are adequate.
          </t>

        </section>

        <section anchor="hip_transform" title="HIP_TRANSFORM">
          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            Suite ID #1        |          Suite ID #2          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            Suite ID #n        |             Padding           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type           577
   Length         length in octets, excluding Type, Length, and 
                  padding
   Suite ID       defines the HIP Suite to be used
                  </artwork>
            </figure>
         
          <t>
            The following Suite IDs are defined (<xref
              target="RFC4307" />,<xref
              target="RFC2451" />):</t>

          <figure>
            <artwork>
      Suite ID                          Value

      RESERVED                          0
      AES-CBC with HMAC-SHA1            1
      3DES-CBC with HMAC-SHA1           2
      3DES-CBC with HMAC-MD5            3
      BLOWFISH-CBC with HMAC-SHA1       4
      NULL-ENCRYPT with HMAC-SHA1       5
      NULL-ENCRYPT with HMAC-MD5        6
            </artwork>
          </figure>


          <t>
            The sender of a HIP_TRANSFORM parameter MUST make sure that
            there are no more than six (6) HIP Suite IDs in one
            HIP_TRANSFORM parameter.  Conversely, a recipient MUST be
            prepared to handle received transport parameters that
            contain more than six Suite IDs by accepting the first six
            Suite IDs and dropping the rest.  The limited number of
            transforms sets the maximum size of HIP_TRANSFORM parameter.
            As the default configuration, the HIP_TRANSFORM parameter
            MUST contain at least one of the mandatory Suite IDs.  There
            MAY be a configuration option that allows the administrator
            to override this default.
          </t>
          <t>
            The Responder lists supported and desired Suite IDs in order
            of preference in the R1, up to the maximum of six
            Suite IDs. The Initiator MUST choose only one of the
            corresponding Suite IDs.  That Suite ID will be used for
            generating the I2.
          </t>
          <t>
            Mandatory implementations: AES-CBC with HMAC-SHA1 and
            NULL-ENCRYPTION with HMAC-SHA1.
          </t>
        </section>
        <section anchor="host-id" title="HOST_ID">
          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          HI Length            |DI-type|      DI Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Host Identity                         /
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   /                               |         Domain Identifier     /
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   /                                               |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type              705
   Length            length in octets, excluding Type, Length, and
                     Padding
   HI Length         length of the Host Identity in octets
   DI-type           type of the following Domain Identifier field
   DI Length         length of the FQDN or NAI in octets
   Host Identity     actual Host Identity
   Domain Identifier the identifier of the sender
            </artwork>
          </figure>

          <t>
            The Host Identity is represented in <xref target="RFC4034">
              RFC 4034</xref> format.  The algorithms used
            in RDATA format are the following:
          </t>

          <figure>
            <artwork>
      Algorithms       Values

      RESERVED         0
      DSA              3 [RFC2536] (RECOMMENDED)
      RSA/SHA1         5 [RFC3110] (REQUIRED)
            </artwork>
          </figure>

          <t>The following DI-types have been defined:</t>
          <figure>
            <artwork>
       Type                    Value
       none included           0
       FQDN                    1
       NAI                     2


       FQDN            Fully Qualified Domain Name, in binary format.
       NAI             Network Access Identifier
            </artwork>
          </figure>
          <t>
            The format for the FQDN is defined in <xref target="RFC1035">
              RFC 1035</xref> Section 3.1.  The format for NAI is defined in <xref target="RFC4282" />
          </t>
          <t>
            If there is no Domain Identifier, i.e., the DI-type field
            is zero, the DI Length field is set to zero as well.
          </t>
          
        </section>
        
        <section anchor="HMAC" title="HMAC">
          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   |                             HMAC                              |
   /                                                               /
   /                               +-------------------------------+
   |                               |            Padding            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type           61505
   Length         length in octets, excluding Type, Length, and
                  Padding
   HMAC           HMAC computed over the HIP packet, excluding the
                  HMAC parameter and any following parameters, such
                  as HIP_SIGNATURE, HIP_SIGNATURE_2, 
                  ECHO_REQUEST_UNSIGNED, or ECHO_RESPONSE_UNSIGNED.
                  The checksum field MUST be set to zero and the HIP 
                  header length in the HIP common header MUST be 
                  calculated not to cover any excluded parameters 
                  when the HMAC is calculated.  The size of the 
                  HMAC is the natural size of the hash computation 
                  output depending on the used hash function. 
            </artwork>
          </figure>

          <t>The HMAC calculation and verification process is presented
            in <xref target="hmac-processing" />.</t>


        </section>
        <section anchor="HMAC_2" title="HMAC_2">
          <t>The parameter structure is the same as in <xref
          target="HMAC" />.  The fields are:</t>
          <figure>
            <artwork>
   Type           61569
   Length         length in octets, excluding Type, Length, and
                  Padding
   HMAC           HMAC computed over the HIP packet, excluding the
                  HMAC parameter and any following parameters such
                  as HIP_SIGNATURE, HIP_SIGNATURE_2, 
                  ECHO_REQUEST_UNSIGNED, or ECHO_RESPONSE_UNSIGNED, 
                  and including an additional sender's HOST_ID 
                  parameter during the HMAC calculation.  The 
                  checksum field MUST be set to zero and the HIP 
                  header length in the HIP common header MUST be 
                  calculated not to cover any excluded parameters 
                  when the HMAC is calculated.  The size of the 
                  HMAC is the natural size of the hash computation
                  output depending on the used hash function. 
            </artwork>
          </figure>

          <t>The HMAC calculation and verification process is presented
            in <xref target="hmac-processing" />.</t>


        </section>

        <section anchor="hip-signature" title="HIP_SIGNATURE">
          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    SIG alg    |                  Signature                    /
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   /                               |             Padding           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type           61697
   Length         length in octets, excluding Type, Length, and 
                  Padding
   SIG alg        signature algorithm
   Signature      the signature is calculated over the HIP packet,
                  excluding the HIP_SIGNATURE parameter and any
                  parameters that follow the HIP_SIGNATURE parameter.
                  The checksum field MUST be set to zero, and the HIP
                  header length in the HIP common header MUST be
                  calculated only to the beginning of the 
                  HIP_SIGNATURE parameter when the signature is 
                  calculated.
            </artwork>
          </figure>

          <t>
            The signature algorithms are defined in <xref
            target="host-id" />.  The signature in the Signature field
            is encoded using the proper method depending on the
            signature algorithm (e.g., according to <xref
            target="RFC3110"/> in case of RSA/SHA1, or according to
            <xref target="RFC2536" /> in case of DSA).
          </t>

          <t>
            The HIP_SIGNATURE calculation and verification process is
            presented in <xref target="sig-processing" />.
          </t>


        </section>

        <section anchor="HIP_SIGNATURE_2" title="HIP_SIGNATURE_2">
          <t>The parameter structure is the same as in <xref
          target="hip-signature" />.  The fields are:</t>

          <figure>
            <artwork>
   Type           61633
   Length         length in octets, excluding Type, Length, and 
                  Padding
   SIG alg        signature algorithm
   Signature      Within the R1 packet that contains the HIP_SIGNATURE_2
                  parameter, the Initiator's HIT, the checksum
                  field, and the Opaque and Random #I fields in the
                  PUZZLE parameter MUST be set to zero while
                  computing the HIP_SIGNATURE_2 signature.  Further,
                  the HIP packet length in the HIP header MUST be
                  adjusted as if the HIP_SIGNATURE_2 was not in the
                  packet during the signature calculation, i.e., the
                  HIP packet length points to the beginning of
                  the HIP_SIGNATURE_2 parameter during signing and
                  verification.
            </artwork>
          </figure>

          <t>
   Zeroing the Initiator's HIT makes it possible to create R1 packets
   beforehand, to minimize the effects of possible DoS attacks.  Zeroing
   the Random #I and Opaque fields within the PUZZLE parameter allows
   these fields to be populated dynamically on precomputed R1s.
          </t>

          <t>
            Signature calculation and verification follows the process
            in <xref target="sig-processing" />.
          </t>

        </section>
        <section title="SEQ">
          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            Update ID                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type           385
   Length         4
   Update ID      32-bit sequence number
            </artwork>
          </figure>

          <t>
            The Update ID is an unsigned quantity, initialized by a host
            to zero upon moving to ESTABLISHED state.  The Update ID has
            scope within a single HIP association, and not across
            multiple associations or multiple hosts.  The Update ID is
            incremented by one before each new UPDATE that is sent by
            the host; the first UPDATE packet originated by a host
            has an Update ID of 0.
          </t>

        </section>

        <section title="ACK">
          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       peer Update ID                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type            449
   Length          variable (multiple of 4)
   peer Update ID  32-bit sequence number corresponding to the
                   Update ID being ACKed.

            </artwork>
          </figure>

          <t>
            The ACK parameter includes one or more Update IDs that
            have been received from the peer.  The Length field
            identifies the number of peer Update IDs that are present

            in the parameter.
          </t>

        </section>

        <section title="ENCRYPTED">
          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Reserved                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                              IV                               /
   /                                                               /
   /                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               /
   /                        Encrypted data                         /
   /                                                               /
   /                               +-------------------------------+
   /                               |            Padding            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type           641
   Length         length in octets, excluding Type, Length, and 
                  Padding
   Reserved       zero when sent, ignored when received
   IV             Initialization vector, if needed, otherwise
                  nonexistent.  The length of the IV is inferred from 
                  the HIP transform.
   Encrypted      The data is encrypted using an encryption algorithm 
     data         as defined in HIP transform.
            </artwork>
          </figure>

<t>
  The ENCRYPTED parameter encapsulates another parameter, the encrypted
  data, which holds one or more HIP parameters in block encrypted form.
</t>

<t>
  Consequently, the first fields in the encapsulated parameter(s) are
  Type and Length of the first such parameter, allowing the contents to
  be easily parsed after decryption.
</t>

<t>
  The field labelled "Encrypted data" consists of the output of one or
  more HIP parameters concatenated together that have been passed
  through an encryption algorithm.  Each of these inner parameters is
  padded according to the rules of <xref target="tlvformat"/> for padding individual
  parameters.  As a result, the concatenated parameters will be a block
  of data that is 8-byte aligned.
</t>

<t>
  Some encryption algorithms require that the data to be encrypted must
  be a multiple of the cipher algorithm block size.  In this case, the
  above block of data MUST include additional padding, as specified by
  the encryption algorithm.  The size of the extra padding is selected
  so that the length of the unencrypted data block is a multiple of the
  cipher block size.  The encryption algorithm may specify padding bytes
  other than zero; for example, AES [FIPS01] uses the PKCS5 padding
  scheme (see section 6.1.1 of <xref target="RFC2898"/>) where the remaining n bytes to
  fill the block each have the value n. This yields an "unencrypted
  data" block that is transformed to an "encrypted data" block by the
  cipher suite.  This extra padding added to the set of parameters to
  satisfy the cipher block alignment rules is not counted in HIP TLV
  length fields, and this extra padding should be removed by the cipher
  suite upon decryption.
</t>

<t>
  Note that the length of the cipher suite output may be smaller or
  larger than the length of the set of parameters to be encrypted,
  since the encryption process may compress the data or add additional
  padding to the data.
</t>

<t>
  Once this encryption process is completed, the Encrypted data field
  is ready for inclusion in the Parameter.  If necessary, additional
  Padding for 8-byte alignment is then added according to the rules of
  <xref target="tlvformat"/>.
</t>
        </section>

        <section anchor="notify" title="NOTIFICATION">

          <t>
            The NOTIFICATION parameter is used to transmit informational
            data, such as error conditions and state transitions, to a
            HIP peer.  A NOTIFICATION parameter may appear in the NOTIFY
            packet type.  The use of the NOTIFICATION parameter in other
            packet types is for further study.
          </t>

          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Reserved             |      Notify Message Type      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               /
   /                   Notification Data                           /
   /                                               +---------------+
   /                                               |     Padding   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type           832
   Length         length in octets, excluding Type, Length, and 
                  Padding
   Reserved       zero when sent, ignored when received
   Notify Message specifies the type of notification
     Type
   Notification   informational or error data transmitted in addition
     Data         to the Notify Message Type.  Values for this field 
                  are type specific (see below).
   Padding        any Padding, if necessary, to make the parameter a 
                  multiple of 8 bytes.
            </artwork>
          </figure>
          <t>
            Notification information can be error messages specifying
            why an SA could not be established.  It can also be status
            data that a process managing an SA database wishes to
            communicate with a peer process.  The table below lists the
            Notification messages and their corresponding values.
          </t>

          <t>
            To avoid certain types of attacks, a Responder SHOULD avoid
            sending a NOTIFICATION to any host with which it has not
            successfully verified a puzzle solution.
          </t>

          <t>
            Types in the range 0-16383 are intended for reporting
            errors and in the range 16384-65535 for other status
            information.  An implementation that receives a NOTIFY
            packet with a NOTIFICATION error parameter in response to a
            request packet (e.g., I1, I2, UPDATE) SHOULD assume that
            the corresponding request has failed entirely.  Unrecognized
            error types MUST be ignored except that they SHOULD be
            logged.
          </t>

          <t>
            Notify payloads with status types MUST be ignored if not
            recognized.
          </t>

          <figure>
            <artwork>
   NOTIFICATION PARAMETER - ERROR TYPES     Value
   ------------------------------------     -----

   UNSUPPORTED_CRITICAL_PARAMETER_TYPE        1

      Sent if the parameter type has the "critical" bit set and the
      parameter type is not recognized.  Notification Data contains
      the two-octet parameter type.

   INVALID_SYNTAX                             7

      Indicates that the HIP message received was invalid because
      some type, length, or value was out of range or because the 
      request was rejected for policy reasons.  To avoid a denial-
      of-service attack using forged messages, this status may only be 
      returned for packets whose HMAC (if present) and SIGNATURE have
      been verified.  This status MUST be sent in response to any 
      error not covered by one of the other status types, and should 
      not contain details to avoid leaking information to someone 
      probing a node.  To aid debugging, more detailed error 
      information SHOULD be written to a console or log.

   NO_DH_PROPOSAL_CHOSEN                     14

      None of the proposed group IDs was acceptable.

   INVALID_DH_CHOSEN                         15

      The D-H Group ID field does not correspond to one offered
      by the Responder.

   NO_HIP_PROPOSAL_CHOSEN                    16

      None of the proposed HIP Transform crypto suites was
      acceptable.

   INVALID_HIP_TRANSFORM_CHOSEN              17

      The HIP Transform crypto suite does not correspond to
      one offered by the Responder.

   AUTHENTICATION_FAILED                     24

      Sent in response to a HIP signature failure, except when
      the signature verification fails in a NOTIFY message.

   CHECKSUM_FAILED                           26

      Sent in response to a HIP checksum failure.

   HMAC_FAILED                               28

      Sent in response to a HIP HMAC failure.

   ENCRYPTION_FAILED                         32

      The Responder could not successfully decrypt the
      ENCRYPTED parameter.

   INVALID_HIT                               40

      Sent in response to a failure to validate the peer's
      HIT from the corresponding HI.

   BLOCKED_BY_POLICY                         42

      The Responder is unwilling to set up an association
      for some policy reason (e.g., received HIT is NULL
      and policy does not allow opportunistic mode).

   SERVER_BUSY_PLEASE_RETRY                  44

      The Responder is unwilling to set up an association as it is
      suffering under some kind of overload and has chosen to shed load
      by rejecting the Initiator's request.  The Initiator may retry;
      however, the Initiator MUST find another (different) puzzle
      solution for any such retries.  Note that the Initiator may need
      to obtain a new puzzle with a new I1/R1 exchange.

   NOTIFY MESSAGES - STATUS TYPES           Value
   ------------------------------           -----

   I2_ACKNOWLEDGEMENT                        16384

      The Responder has an I2 from the Initiator but had to queue the I2
      for processing.  The puzzle was correctly solved and the Responder
      is willing to set up an association but currently has a number of
      I2s in the processing queue.  R2 will be sent after the I2 has
      been processed.
              </artwork>
            </figure>

        </section>

        <section anchor="sec-echo-request-signed" title="ECHO_REQUEST_SIGNED">

          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Opaque data (variable length)                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type         897
   Length       variable
   Opaque data  opaque data, supposed to be meaningful only to the
                node that sends ECHO_REQUEST_SIGNED and receives a 
                corresponding ECHO_RESPONSE_SIGNED or 
                ECHO_RESPONSE_UNSIGNED.
            </artwork>
          </figure>
          <t>
            The ECHO_REQUEST_SIGNED parameter contains an opaque blob of
            data that the sender wants to get echoed back in the
            corresponding reply packet.
          </t>

          <t>
            The ECHO_REQUEST_SIGNED and corresponding echo response
            parameters MAY be used for any purpose where a node wants
            to carry some state in a request packet and get it back in
            a response packet.  The ECHO_REQUEST_SIGNED is covered by
            the HMAC and SIGNATURE.  A HIP packet can contain only one
            ECHO_REQUEST_SIGNED or ECHO_REQUEST_UNSIGNED parameter.
            The ECHO_REQUEST_SIGNED parameter MUST be responded to
            with a corresponding echo response.  ECHO_RESPONSE_SIGNED
            SHOULD be used, but if it is not possible, e.g., due to a
            middlebox-provided response, it MAY be responded to with an
            ECHO_RESPONSE_UNSIGNED.
          </t>


        </section>

        <section anchor="sec-echo-request-unsigned" 
          title="ECHO_REQUEST_UNSIGNED">

          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Opaque data (variable length)                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type         63661
   Length       variable
   Opaque data  opaque data, supposed to be meaningful only to the
                node that sends ECHO_REQUEST_UNSIGNED and receives a 
                corresponding ECHO_RESPONSE_UNSIGNED.
            </artwork>
          </figure>
          <t>
            The ECHO_REQUEST_UNSIGNED parameter contains an opaque blob
            of data that the sender wants to get echoed back in the
            corresponding reply packet.
          </t>

          <t>
            The ECHO_REQUEST_UNSIGNED and corresponding echo response
            parameters MAY be used for any purpose where a node wants to
            carry some state in a request packet and get it back in a
            response packet.  The ECHO_REQUEST_UNSIGNED is not covered
            by the HMAC and SIGNATURE.  A HIP packet can contain one or
            more ECHO_REQUEST_UNSIGNED parameters.  It is possible that
            middleboxes add ECHO_REQUEST_UNSIGNED parameters in HIP
            packets passing by.  The sender has to create the Opaque
            field so that it can later identify and remove the
            corresponding ECHO_RESPONSE_UNSIGNED parameter.
          </t>
          <t>
            The ECHO_REQUEST_UNSIGNED parameter MUST be responded to with
            an ECHO_RESPONSE_UNSIGNED parameter.
          </t>
        </section>

        <section anchor="echo_response_signed" 
          title="ECHO_RESPONSE_SIGNED">
          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Opaque data (variable length)                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type         961
   Length       variable
   Opaque data  opaque data, copied unmodified from the
                ECHO_REQUEST_SIGNED or ECHO_REQUEST_UNSIGNED
                parameter that triggered this response.
            </artwork>
          </figure>
          <t>
            The ECHO_RESPONSE_SIGNED parameter contains an opaque blob
            of data that the sender of the ECHO_REQUEST_SIGNED wants to
            get echoed back.  The opaque data is copied unmodified from
            the ECHO_REQUEST_SIGNED parameter.
          </t>
          <t>
            The ECHO_REQUEST_SIGNED and ECHO_RESPONSE_SIGNED parameters
            MAY be used for any purpose where a node wants to carry some
            state in a request packet and get it back in a response
            packet.  The ECHO_RESPONSE_SIGNED is covered by the HMAC and
            SIGNATURE.
          </t>
        </section>
        <section anchor="echo_response_unsigned" 
          title="ECHO_RESPONSE_UNSIGNED">
          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Opaque data (variable length)                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type         63425
   Length       variable
   Opaque data  opaque data, copied unmodified from the 
                ECHO_REQUEST_SIGNED or ECHO_REQUEST_UNSIGNED
                parameter that triggered this response.
            </artwork>
          </figure>
          <t>
            The ECHO_RESPONSE_UNSIGNED parameter contains an opaque blob
            of data that the sender of the ECHO_REQUEST_SIGNED or
            ECHO_REQUEST_UNSIGNED wants to get echoed back.  The opaque
            data is copied unmodified from the corresponding echo request
            parameter.
          </t>
          <t>
            The echo request and ECHO_RESPONSE_UNSIGNED parameters MAY
            be used for any purpose where a node wants to carry some
            state in a request packet and get it back in a response
            packet.  The ECHO_RESPONSE_UNSIGNED is not covered by the
            HMAC and SIGNATURE. 
          </t>
        </section>

      </section>

      <section title="HIP Packets">
        
        <t>
          There are eight basic HIP packets (see <xref
          target="table_hip_packets" />).  Four are for the HIP base
          exchange, one is for updating, one is for sending
          notifications, and two are for closing a HIP association.
        </t>

<?rfc compact="no"?>

        <texttable title="HIP packets and packet type numbers" 
          anchor="table_hip_packets">
          <ttcol width="25%" align="center">Packet type</ttcol>
          <ttcol align="left">Packet name</ttcol>
          <c>1</c><c>I1 - the HIP Initiator Packet</c>
          <c>2</c><c>R1 - the HIP Responder Packet</c>
          <c>3</c><c>I2 - the Second HIP Initiator Packet</c>
          <c>4</c><c>R2 - the Second HIP Responder Packet</c>
          <c>16</c><c>UPDATE - the HIP Update Packet</c>
          <c>17</c><c>NOTIFY - the HIP Notify Packet</c>
          <c>18</c><c>CLOSE - the HIP Association Closing Packet</c>
          <c>19</c><c>CLOSE_ACK - the HIP Closing Acknowledgment Packet</c>
        </texttable>
        
<?rfc compact="yes"?>

        <t>Packets consist of the fixed header as described in <xref
        target="ssec-payload" />, followed by the parameters.  The
        parameter part, in turn, consists of zero or more TLV-coded
        parameters.</t>
        
        <t>In addition to the base packets, other packet types will be
          defined later in separate specifications.  For example, support
          for mobility and multi-homing is not included in this
          specification.</t>
        
        <t>
          See <xref target="notation">Notation</xref> for used operations. 
        </t>
        <t>
          In the future, an OPTIONAL upper-layer payload MAY follow the
          HIP header.  The Next Header field in the header indicates if
          there is additional data following the HIP header.  The HIP
          packet, however, MUST NOT be fragmented.  This limits the size
          of the possible additional data in the packet.
        </t>

        <section anchor="I1" title="I1 - the HIP Initiator Packet">
          
          <t>The HIP header values for the I1 packet:</t>
          
          <figure>
            <artwork>
   Header:
     Packet Type = 1
     SRC HIT = Initiator's HIT
     DST HIT = Responder's HIT, or NULL

   IP ( HIP () )
            </artwork>
          </figure>
          
          <t>The I1 packet contains only the fixed HIP header.</t>
          
          <t>Valid control bits: none</t>
          
          <t>
            The Initiator gets the Responder's HIT either from a DNS
            lookup of the Responder's FQDN, from some other repository,
            or from a local table.  If the Initiator does not know the
            Responder's HIT, it may attempt to use opportunistic mode by
            using NULL (all zeros) as the Responder's HIT.  See also
            <xref target="op_mode">"HIP Opportunistic Mode"</xref>.
          </t>


          <t>
            Since this packet is so easy to spoof even if it were
            signed, no attempt is made to add to its generation or
            processing cost.
          </t>
          
          <t>
            Implementations MUST be able to handle a storm of received
            I1 packets, discarding those with common content that arrive
            within a small time delta.
          </t>

          
          
        </section>
        
        <section anchor="R1" title="R1 - the HIP Responder Packet">
          
          <t>The HIP header values for the R1 packet:</t>
          
          <figure>
            <artwork>
   Header:
     Packet Type = 2
     SRC HIT = Responder's HIT
     DST HIT = Initiator's HIT

   IP ( HIP ( [ R1_COUNTER, ]
              PUZZLE,
              DIFFIE_HELLMAN,
              HIP_TRANSFORM,
              HOST_ID,
              [ ECHO_REQUEST_SIGNED, ]
              HIP_SIGNATURE_2 )
              &lt;, ECHO_REQUEST_UNSIGNED &gt;i)
            </artwork>
          </figure>
          
          <t>Valid control bits: A</t>

          <t>If the Responder's HI is an anonymous one, the A control MUST
            be set.</t>
          
          <t>
            The Initiator's HIT MUST match the one received in I1.  If the
            Responder has multiple HIs, the Responder's HIT used MUST match
            Initiator's request.  If the Initiator used opportunistic
            mode, the Responder may select freely among its HIs.  See also
            <xref target="op_mode">"HIP Opportunistic Mode"</xref>. 
          </t>
          
          <t>
            The R1 generation counter is used to determine the currently
            valid generation of puzzles.  The value is increased
            periodically, and it is RECOMMENDED that it is increased at
            least as often as solutions to old puzzles are no longer
            accepted.
          </t>
          
          <t>
            The Puzzle contains a Random #I and the difficulty K. &nbsp;The
            difficulty K indicates the number of lower-order bits, in
            the puzzle hash result, that must be
            zeros; see <xref target="puzzle_exchange"/>.  The Random #I is not covered by the
            signature and must be zeroed during the signature calculation,
            allowing the sender to select and set the #I into a precomputed
            R1 just prior sending it to the peer.
          </t>

          <t>
            The Diffie-Hellman value is ephemeral, and one value SHOULD
            be used only for one connection.  Once the Responder has
            received a valid response to an R1 packet, that
            Diffie-Hellman value SHOULD be deprecated.  Because it is
            possible that the Responder has sent the same Diffie-Hellman
            value to different hosts simultaneously in corresponding R1
            packets, those responses should also be accepted.  However,
            as a defense against I1 storms, an implementation MAY
            propose, and re-use if not avoidable, the same
            Diffie-Hellman value for a period of time, for example, 15
            minutes.  By using a small number of different puzzles for a
            given Diffie-Hellman value, the R1 packets can be
            precomputed and delivered as quickly as I1 packets arrive.
            A scavenger process should clean up unused Diffie-Hellman values
            and puzzles.
          </t>


          <t>
            Re-using Diffie-Hellman public keys opens up the potential
            security risk of more than one Initiator ending up with
            the same keying material (due to faulty random number
            generators).  Also, more than one Initiator using the same
            Responder public key half may lead to potentially
            easier cryptographic attacks and to imperfect
            forward security.
          </t>
          <t>
            However, these risks involved in re-using the same key are
            statistical; that is, the authors are not aware of any mechanism
            that would allow manipulation of the protocol so that the
            risk of the re-use of any given Responder Diffie-Hellman
            public key would differ from the base probability.
            Consequently, it is RECOMMENDED that implementations avoid
            re-using the same D-H key with multiple Initiators, but
            because the risk is considered statistical and not known to
            be manipulable, the implementations MAY re-use a key in
            order to ease resource-constrained implementations and to
            increase the probability of successful communication with
            legitimate clients even under an I1 storm.  In particular,
            when it is too expensive to generate enough precomputed
            R1 packets to supply each potential Initiator with a
            different D-H key, the Responder MAY send the
            same D-H key to several Initiators, thereby
            creating the possibility of multiple legitimate Initiators
            ending up using the same Responder-side public key.
            However, as soon as the Responder knows that it will use a
            particular D-H key, it SHOULD stop offering it.
            This design is aimed to allow resource-constrained
            Responders to offer services under I1 storms and to
            simultaneously make the probability of D-H key
            re-use both statistical and as low as possible.
          </t>
          <t>
            If a future version of this protocol is considered, we
            strongly recommend that these issues be studied again.
            Especially, the current design allows hosts to become
            potentially more vulnerable to a statistical,
            low-probability problem during I1 storm attacks than what
            they are if no attack is taking place; whether this is
            acceptable or not should be reconsidered in the light of any
            new experience gained.
          </t>
          <t>
            The HIP_TRANSFORM contains the encryption and integrity
            algorithms supported by the Responder to protect the HI
            exchange, in the order of preference.  All implementations MUST
            support the AES <xref target="RFC3602" /> with HMAC-SHA-1-96
            <xref target="RFC2404" />.
          </t>

          <t>
            The ECHO_REQUEST_SIGNED and ECHO_REQUEST_UNSIGNED contains
            data that the sender wants to receive unmodified in the
            corresponding response packet in the ECHO_RESPONSE_SIGNED or
            ECHO_RESPONSE_UNSIGNED parameter.  
          </t>
          
          <t>
            The signature is calculated over the whole HIP envelope,
            after setting the Initiator's HIT, header checksum, as well as
            the Opaque field and the Random #I in the PUZZLE parameter
            temporarily to zero, and excluding any parameters that
            follow the signature, as described in <xref
            target="HIP_SIGNATURE_2" />.  This allows the Responder to
            use precomputed R1s.  The Initiator SHOULD validate this
            signature.  It SHOULD check that the Responder's HI received
            matches with the one expected, if any.
          </t>
          
        </section>
        
        <section anchor="I2" title="I2 - the Second HIP Initiator Packet">
          
          <t>The HIP header values for the I2 packet:</t>
          
          <figure>
            <artwork>
   Header:
     Type = 3
     SRC HIT = Initiator's HIT
     DST HIT = Responder's HIT

   IP ( HIP ( [R1_COUNTER,]
              SOLUTION,
              DIFFIE_HELLMAN,
              HIP_TRANSFORM,
              ENCRYPTED { HOST_ID } or HOST_ID,
              [ ECHO_RESPONSE_SIGNED ,]
              HMAC,
              HIP_SIGNATURE
              &lt;, ECHO_RESPONSE_UNSIGNED&gt;i ) )
            </artwork>
          </figure>
          
          <t>
            Valid control bits: A
          </t>
          
          
          <t>
            The HITs used MUST match the ones used previously.
          </t>
          
          <t>
            If the Initiator's HI is an anonymous one, the A control
            MUST be set.
          </t>
          
          <t>
            The Initiator MAY include an unmodified copy of the
            R1_COUNTER parameter received in the corresponding R1
            packet into the I2 packet.
          </t>
          
          <t>
            The Solution contains the Random #I from R1 and the
            computed #J. &nbsp;The low-order K bits of the RHASH(I | ... |
            J) MUST be zero.
          </t>
          
          <t>
            The Diffie-Hellman value is ephemeral.  If precomputed, a
            scavenger process should clean up unused Diffie-Hellman
            values.  The Responder may re-use Diffie-Hellman values
            under some conditions as specified in <xref target="R1" />.
          </t>
          
          <t>
            The HIP_TRANSFORM contains the single encryption and
            integrity transform selected by the Initiator, that will
            be used to protect the HI exchange. The chosen transform
            MUST correspond to one offered by the Responder in the R1.
            All implementations MUST support the AES transform <xref
            target="RFC3602" />.
          </t>

          <t>
            The Initiator's HI MAY be encrypted using the
            HIP_TRANSFORM encryption algorithm.  The keying material
            is derived from the Diffie-Hellman exchanged as defined in
            <xref target="keymat" />.
          </t>

          <t>
            The ECHO_RESPONSE_SIGNED and ECHO_RESPONSE_UNSIGNED contain
            the unmodified Opaque data copied from the corresponding
            echo request parameter. 
          </t>
          
          <t>
            The HMAC is calculated over the whole HIP envelope, excluding any
            parameters after the HMAC, as described in <xref
              target="hmac-processing" />.  The Responder MUST validate the
            HMAC.
          </t>
          
          <t>
            The signature is calculated over the whole HIP envelope, excluding
            any parameters after the HIP_SIGNATURE, as described in <xref
              target="hip-signature" />.  The Responder MUST validate this
            signature.  It MAY use either the HI in the packet or the HI
            acquired by some other means.
          </t>
          
          
        </section>
        
        <section anchor="R2" title="R2 - the Second HIP Responder Packet">
          
          <t>The HIP header values for the R2 packet:</t>
          
          <figure>
            <artwork>
   Header:
     Packet Type = 4
     SRC HIT = Responder's HIT
     DST HIT = Initiator's HIT

   IP ( HIP ( HMAC_2, HIP_SIGNATURE ) )

            </artwork>
          </figure>
          
          <t>Valid control bits: none</t>
          
          <t>
            The HMAC_2 is calculated over the whole HIP envelope, with
            Responder's HOST_ID parameter concatenated with the HIP
            envelope.  The HOST_ID parameter is removed after the HMAC
            calculation.  The procedure is described in <xref
            target="hmac-processing" />.
          </t>
          <t>
            The signature is calculated over the whole HIP envelope. 
          </t>
          <t>
            The Initiator MUST validate both the HMAC and the signature.
          </t>
          
        </section>

        <section anchor="UPDATE" title="UPDATE - the HIP Update Packet">
          
          <t>Support for the UPDATE packet is MANDATORY.</t>
          
          <t>The HIP header values for the UPDATE packet:</t>
          
          <figure>
            <artwork>
   Header:
     Packet Type = 16
     SRC HIT = Sender's HIT
     DST HIT = Recipient's HIT

   IP ( HIP ( [SEQ, ACK, ] HMAC, HIP_SIGNATURE ) )
            </artwork>
          </figure>

          <t>Valid control bits: None</t>
          
          <t>
            The UPDATE packet contains mandatory HMAC and HIP_SIGNATURE
            parameters, and other optional parameters.
          </t>
          <t>
            The UPDATE packet contains zero or one SEQ parameter.  The
            presence of a SEQ parameter indicates that the receiver
            MUST ACK the UPDATE.  An UPDATE that does not contain a SEQ
            parameter is simply an ACK of a previous UPDATE and itself
            MUST NOT be ACKed.
          </t>
          <t>
            An UPDATE packet contains zero or one ACK parameters.  The
            ACK parameter echoes the SEQ sequence number of the UPDATE
            packet being ACKed.  A host MAY choose to ACK more than one
            UPDATE packet at a time; e.g., the ACK may contain the last
            two SEQ values received, for robustness to ACK loss.
            ACK values are not cumulative; each received unique SEQ
            value requires at least one corresponding ACK value in reply.
            Received ACKs that are redundant are ignored.
          </t>
          <t>
            The UPDATE packet may contain both a SEQ and an ACK parameter.
            In this case, the ACK is being piggybacked on an outgoing
            UPDATE.  In general, UPDATEs carrying SEQ SHOULD be ACKed
            upon completion of the processing of the UPDATE.  A host
            MAY choose to hold the UPDATE carrying ACK for a short
            period of time to allow for the possibility of piggybacking
            the ACK parameter, in a manner similar to TCP delayed
            acknowledgments.
          </t>
          <t>
            A sender MAY choose to forgo reliable transmission of a
            particular UPDATE (e.g., it becomes overcome by events).
            The semantics are such that the receiver MUST acknowledge
            the UPDATE, but the sender MAY choose to not care about
            receiving the ACK.
          </t>
          <t>
            UPDATEs MAY be retransmitted without incrementing SEQ.
            If the same subset of parameters is included in multiple
            UPDATEs with different SEQs, the host MUST ensure that the
            receiver's processing of the parameters multiple times will
            not result in a protocol error.
          </t>

        </section>
        
        
        <section title="NOTIFY - the HIP Notify Packet">
          
          <t>
            The NOTIFY packet is OPTIONAL.  The NOTIFY packet MAY be
            used to provide information to a peer.  Typically, NOTIFY is
            used to indicate some type of protocol error or negotiation
            failure.  NOTIFY packets are unacknowledged.  The receiver
            can handle the packet only as informational, and SHOULD NOT
            change its HIP state (<xref target="states" />) based purely
            on a received NOTIFY packet.
          </t>

          <t>The HIP header values for the NOTIFY packet:</t>
          
          <figure>
            <artwork>
   Header:
     Packet Type = 17
     SRC HIT = Sender's HIT
     DST HIT = Recipient's HIT, or zero if unknown

   IP ( HIP (&lt;NOTIFICATION&gt;i, [HOST_ID, ] HIP_SIGNATURE) )
            </artwork>
          </figure>

          <t>Valid control bits: None</t>

          <t>The NOTIFY packet is used to carry one or more NOTIFICATION
          parameters.</t>
        </section>
        
        <section anchor="CLOSE" 
          title="CLOSE - the HIP Association Closing Packet">
          <t>The HIP header values for the CLOSE packet:</t>
          
          <figure>
            <artwork>

   Header:
     Packet Type = 18
     SRC HIT = Sender's HIT
     DST HIT = Recipient's HIT

   IP ( HIP ( ECHO_REQUEST_SIGNED, HMAC, HIP_SIGNATURE ) )
            </artwork>
          </figure>
          <t>Valid control bits: none</t>
          
          <t>
            The sender MUST include an ECHO_REQUEST_SIGNED used to
            validate CLOSE_ACK received in response, and both an HMAC
            and a signature (calculated over the whole HIP envelope).
          </t>
          
          <t>
            The receiver peer MUST validate both the HMAC and the
            signature if it has a HIP association state, and MUST reply
            with a CLOSE_ACK containing an ECHO_RESPONSE_SIGNED
            corresponding to the received ECHO_REQUEST_SIGNED.
          </t>
          
        </section>
        
      
        <section anchor="CLOSE_ACK" 
          title="CLOSE_ACK - the HIP Closing Acknowledgment Packet">
          
          <t>
            The HIP header values for the CLOSE_ACK packet:
          </t>
          <figure>
            <artwork>
   Header:
     Packet Type = 19
     SRC HIT = Sender's HIT
     DST HIT = Recipient's HIT

   IP ( HIP ( ECHO_RESPONSE_SIGNED, HMAC, HIP_SIGNATURE ) )
            </artwork>
          </figure>
          
          <t>Valid control bits: none</t>
          
          <t>
            The sender MUST include both an HMAC and signature (calculated
            over the whole HIP envelope).
          </t>
          
          <t>
            The receiver peer MUST validate both the HMAC and the
            signature.
          </t>
        </section>
        
      </section>
      


      <section anchor="ICMP" title="ICMP Messages">
        <t>
          When a HIP implementation detects a problem with an incoming
          packet, and it either cannot determine the identity of the
          sender of the packet or does not have any existing HIP
          association with the sender of the packet, it MAY respond
          with an ICMP packet.  Any such replies MUST be rate-limited
          as described in <xref target="RFC2463" />.  In most cases,
          the ICMP packet will have the Parameter Problem type (12 for
          ICMPv4, 4 for ICMPv6), with the Pointer field pointing to
          the field that caused the ICMP message to be generated.
        </t>

        <section title="Invalid Version">

          <t>
            If a HIP implementation receives a HIP packet that has an
            unrecognized HIP version number, it SHOULD respond,
            rate-limited, with an ICMP packet with type Parameter
            Problem, the Pointer pointing to the VER./RES. byte in the
            HIP header.
          </t>

        </section>

        <section
          title="Other Problems with the HIP Header and Packet Structure">

          <t>
            If a HIP implementation receives a HIP packet that has other
            unrecoverable problems in the header or packet format, it
            MAY respond, rate-limited, with an ICMP packet with type
            Parameter Problem, the Pointer pointing to the field that
            failed to pass the format checks.  However, an
            implementation MUST NOT send an ICMP message if the checksum
            fails; instead, it MUST silently drop the packet.
          </t>

        </section>


        <section title="Invalid Puzzle Solution">

          <t>
            If a HIP implementation receives an I2 packet that has an
            invalid puzzle solution, the behavior depends on the
            underlying version of IP.  If IPv6 is used, the
            implementation SHOULD respond with an ICMP packet with type
            Parameter Problem, the Pointer pointing to the beginning of
            the Puzzle solution #J field in the SOLUTION payload in the
            HIP message.
          </t>

          <t>
            If IPv4 is used, the implementation MAY respond with an ICMP
            packet with the type Parameter Problem, copying enough of
            bytes from the I2 message so that the SOLUTION parameter
            fits into the ICMP message, the Pointer pointing to the
            beginning of the Puzzle solution #J field, as in the IPv6
            case.  Note, however, that the resulting ICMPv4 message
            exceeds the typical ICMPv4 message size as defined in <xref
              target="RFC0792" />.
          </t>

        </section>

        <section anchor="non-existing-hip" 
          title="Non-Existing HIP Association">
          
          <t>
            If a HIP implementation receives a CLOSE or UPDATE
            packet, or any other packet whose handling requires an
            existing association, that has either a Receiver or Sender
            HIT that does not match with any existing HIP association,
            the implementation MAY respond, rate-limited, with an ICMP
            packet with the type Parameter Problem, and with the Pointer pointing
            to the beginning of the first HIT that does not match.
          </t>
          <t>
            A host MUST NOT reply with such an ICMP if it receives any
            of the following messages: I1, R2, I2, R2, and
            NOTIFY.  When introducing new packet types, a specification
            SHOULD define the appropriate rules for sending or not
            sending this kind of ICMP reply.
          </t>
        </section>

      </section>

    </section>


    <section anchor="packet_processing" title="Packet Processing">

      <t>
        Each host is assumed to have a single HIP protocol
        implementation that manages the host's HIP associations and
        handles requests for new ones.  Each HIP association is governed
        by a conceptual state machine, with states defined above in
        <xref target="state-machine" />.  The HIP implementation can
        simultaneously maintain HIP associations with more than one
        host.  Furthermore, the HIP implementation may have more than
        one active HIP association with another host; in this case, HIP
        associations are distinguished by their respective HITs.  It is
        not possible to have more than one HIP association between any
        given pair of HITs.  Consequently, the only way for two hosts to
        have more than one parallel association is to use different
        HITs, at least at one end.
      </t>

      <t>
        The processing of packets depends on the state of the HIP
        association(s) with respect to the authenticated or apparent
        originator of the packet.  A HIP implementation determines
        whether it has an active association with the originator of the
        packet based on the HITs.  In the case of user data carried in
        a specific transport format, the transport format document specifies 
        how the incoming packets are matched with the active associations.
      </t>
      
      <section title="Processing Outgoing Application Data">
        
        <t>
          In a HIP host, an application can send application-level data
          using an identifier specified via the underlying API.  The API
          can be a backwards-compatible API (see <xref
          target="HIP-APP" />), using identifiers
          that look similar to IP addresses, or a completely new API,
          providing enhanced services related to Host Identities.
          Depending on the HIP implementation, the identifier provided
          to the application may be different; for example, it can be a HIT or
          an IP address.
        </t>
        <t>
          The exact format and method for transferring the data from the
          source HIP host to the destination HIP host is defined in the
          corresponding transport format document.  The actual data is
          transferred in the network using the appropriate source and
          destination IP addresses.  
        </t>

        <t>
          In this document, conceptual processing rules are defined only
          for the base case where both hosts have only single usable IP
          addresses; the multi-address multi-homing case will be
          specified separately.
        </t>
        
        <t>
          The following conceptual algorithm describes the steps that 
          are required for handling outgoing datagrams destined to a HIT.  

          <list style="numbers">
            
            <t>
              If the datagram has a specified source address, it MUST
              be a HIT.  If it is not, the implementation MAY replace
              the source address with a HIT.  Otherwise, it MUST drop the
              packet.
            </t>
            
            <t>
              If the datagram has an unspecified source address, the
              implementation must choose a suitable source HIT for the
              datagram. 
            </t>
            
            <t>
              If there is no active HIP association with the given &lt;source, destination&gt; HIT pair, one must be created by
              running the base exchange.  While waiting for the base
              exchange to complete, the implementation SHOULD queue at
              least one packet per HIP association to be formed, and it MAY
              queue more than one.
            </t>
            
            <t>
              Once there is an active HIP association for the given
              &lt;source, destination&gt; HIT pair, the outgoing
              datagram is passed to transport handling.  The possible
              transport formats are defined in separate documents, of which
              the ESP transport format for HIP is mandatory for all HIP
              implementations. 
            </t>
            
            <t>
              Before sending the packet, the HITs in the datagram are
              replaced with suitable IP addresses.  For IPv6, the rules
              defined in <xref target="RFC3484" /> SHOULD be followed.
              Note that this HIT-to-IP-address conversion step MAY also
              be performed at some other point in the stack, e.g.,
              before wrapping the packet into the output format.
            </t>

          </list>
        </t>
        
      </section>

      <section title="Processing Incoming Application Data">

        <t>
          The following conceptual algorithm describes the incoming
          datagram handling when HITs are used at the receiving host as
          application-level identifiers.  More detailed steps for
          processing packets are defined in corresponding transport
          format documents.
        </t>
        <t>
        
        <list style="numbers">

            <t>
              The incoming datagram is mapped to an existing HIP
              association, typically using some information from the
              packet.  For example, such mapping may be based on the ESP
              Security Parameter Index (SPI).
            </t>
            
            <t>
              The specific transport format is unwrapped, in a way
              depending on the transport format, yielding a packet that
              looks like a standard (unencrypted) IP packet.  If
              possible, this step SHOULD also verify that the packet was
              indeed (once) sent by the remote HIP host, as identified
              by the HIP association.  
              <vspace blankLines='1' />

              Depending on the used transport mode, the verification
              method can vary. While the HI (as well as HIT) is used as
              the higher-layer identifier, the verification method has
              to verify that the data packet was sent by a node identity
              and that the actual identity maps to this particular
              HIT. When using ESP transport format <xref
              target="RFC5202" />, the verification is
              done using the SPI value in the data packet to find the
              corresponding SA with associated HIT and key, and
              decrypting the packet with that associated key.
            </t>

            <t>
              The IP addresses in the datagram are replaced with the 
              HITs associated with the HIP association.  Note that this
              IP-address-to-HIT conversion step MAY also be performed
              at some other point in the stack.
            </t>
            
            <t>
              The datagram is delivered to the upper layer.
              When demultiplexing the datagram, the right upper-layer socket
              is based on the HITs.
            </t>

          </list>
        </t>

      </section>

      <section title="Solving the Puzzle">
        <t>
          This subsection describes the puzzle-solving details. 
        </t>
        <t>    
          In R1, the values I and K are sent in network byte order.
          Similarly, in I2, the values I and J are sent in network byte
          order.  The hash is created by concatenating, in
          network byte order, the following data, in the following
          order and using the RHASH algorithm:
          
          <list>
            
            <t>
              64-bit random value I, in network byte order, as
              appearing in R1 and I2.
            </t>
            
            <t>
              128-bit Initiator's HIT, in network byte order, as
              appearing in the HIP Payload in R1 and I2.
            </t>
            
            <t>
              128-bit Responder's HIT, in network byte order, as
              appearing in the HIP Payload in R1 and I2.
            </t>
            
            <t>
              64-bit random value J, in network byte order, as
              appearing in I2.
            </t>
            
          </list>
          
          In order to be a valid response puzzle, the K low-order bits
          of the resulting RHASH digest must be zero.
        </t>
        
        <t>
          Notes:
          
          <list>
            
            <t>
              i) The length of the data to be hashed is 48 bytes.
            </t>
            
            <t>
              ii) All the data in the hash input MUST be in network 
              byte order.
            </t>
            
            <t>
              iii) The order of the Initiator's and Responder's HITs are
              different in the R1 and I2 packets; see <xref
                target="ssec-payload" />.  Care must be taken to copy
              the values in the right order to the hash input.
            </t>
            
          </list>
        </t>
        
        <t>
          The following procedure describes the processing steps 
          involved, assuming that the Responder chooses to 
          precompute the R1 packets:
        </t>
        <t>
          <list style="hanging">
            
            <t hangText="Precomputation by the Responder:">
              <vspace blankLines="0" />
              Sets up the puzzle difficulty K.
              <vspace blankLines="0" />
              Creates a signed R1 and caches it.
              <vspace blankLines="0" />
            </t>
            
            <t hangText="Responder:">
              <vspace blankLines="0" />
              Selects a suitable cached R1.
              <vspace blankLines="0" />
              Generates a random number I.
              <vspace blankLines="0" />
              Sends I and K in an R1.
              <vspace blankLines="0" />
              Saves I and K for a Delta time.
              <vspace blankLines="0" />
            </t>
            
            <t hangText="Initiator:">
              
              <vspace blankLines="0" />
              Generates repeated attempts to solve the puzzle
              until a matching J is found:
              
              <vspace blankLines="0" />
              Ltrunc( RHASH( I | HIT-I | HIT-R | J ), K ) == 0
              <vspace blankLines="0" />
              Sends I and J in an I2.
              <vspace blankLines="1" />
            </t>
            
            <t hangText="Responder:">
              <vspace blankLines="0" />
              Verifies that the received I is a saved one.
              <vspace blankLines="0" />
              Finds the right K based on I.
              <vspace blankLines="0" />
              Computes V := Ltrunc( RHASH( I | HIT-I | HIT-R | J ), K )
              <vspace blankLines="0" />
              Rejects if V != 0
              <vspace blankLines="0" />
              Accept if V == 0
              <vspace blankLines="0" />
            </t>
          </list>
          
          
        </t>
        </section>

      <section title="HMAC and SIGNATURE Calculation and Verification">
        <t>
          The following subsections define the actions for processing
          HMAC, HIP_SIGNATURE and HIP_SIGNATURE_2 parameters.
        </t>

        <section anchor="hmac-processing" title="HMAC Calculation">

          <t>
            The following process applies both to the HMAC and HMAC_2
            parameters.  When processing HMAC_2, the difference is that the
            HMAC calculation includes a pseudo HOST_ID field containing
            the Responder's information as sent in the R1 packet
            earlier. 
          </t>
          <t>
            Both the Initiator and the Responder should take some care
            when verifying or calculating the HMAC_2. Specifically, the
            Responder should preserve other parameters than the HOST_ID
            when sending the R2. Also, the Initiator has to preserve the
            HOST_ID exactly as it was received in the R1 packet.
          </t>
          <t>
            The scope of the calculation for HMAC and HMAC_2 is:
          </t>
          <figure>
            <artwork>
HMAC: { HIP header | [ Parameters ] }
            </artwork>
          </figure>
          <t>
            where Parameters include all HIP parameters of the
            packet that is being calculated with Type values from 1
            to (HMAC's Type value - 1) and exclude parameters with
            Type values greater or equal to HMAC's Type value.
          </t>
          <t>
            During HMAC calculation, the following applies:
            <list style="symbols">
              <t>
                In the HIP header, the Checksum field is set to zero.
              </t>
              <t>
                In the HIP header, the Header Length field value is calculated
                to the beginning of the HMAC parameter.
              </t>
            </list>
          </t>
          <t>
            Parameter order is described in <xref target="tlvformat"
              />.
          </t>
          <figure>
            <artwork>
HMAC_2: { HIP header | [ Parameters ] | HOST_ID }
            </artwork>
          </figure>
          <t>
            where Parameters include all HIP parameters for the packet
            that is being calculated with Type values from 1 to
            (HMAC_2's Type value - 1) and exclude parameters with Type
            values greater or equal to HMAC_2's Type value.
          </t>
          <t>          
            During HMAC_2 calculation, the following applies:
            <list style="symbols">
              <t>
                In the HIP header, the Checksum field is set to zero.
              </t>
              <t>
                In the HIP header, the Header Length field value is
                calculated to the beginning of the HMAC_2 parameter and
                added to the length of the concatenated HOST_ID
                parameter length.
              </t>
              <t>
                HOST_ID parameter is exactly in the form it was received
                in the R1 packet from the Responder.
              </t>
            </list>
          </t>
          <t>
            Parameter order is described in <xref target="tlvformat"
              />, except that the HOST_ID parameter in this calculation is
            added to the end.
          </t>
          <t>
            The HMAC parameter is defined in <xref target="HMAC" /> and
            the HMAC_2 parameter in <xref target="HMAC_2" />.  The HMAC
            calculation and verification process (the process applies
            both to HMAC and HMAC_2 except where HMAC_2 is mentioned
            separately) is as follows:
          </t>

          <t>Packet sender:
            <list style="numbers">
              <t>
                Create the HIP packet, without the HMAC, HIP_SIGNATURE,
                HIP_SIGNATURE_2, or any other parameter with greater Type
                value than the HMAC parameter has.
              </t>
              <t>In case of HMAC_2 calculation, add a HOST_ID (Responder)
                parameter to the end of the packet.</t>
              <t>
                Calculate the Header Length field in the HIP header
                including the added HOST_ID parameter in case of HMAC_2.
              </t>
              <t>
                Compute the HMAC using either HIP-gl or HIP-lg integrity
                key retrieved from KEYMAT as defined in <xref
                target="keymat" />.
              </t>
              <t>
                In case of HMAC_2, remove the HOST_ID parameter from the
                packet.
              </t>
              <t>
                Add the HMAC parameter to the packet and any parameter
                with greater Type value than the HMAC's (HMAC_2's) that
                may follow, including possible HIP_SIGNATURE or
                HIP_SIGNATURE_2 parameters
              </t>
              <t>Recalculate the Length field in the HIP header.</t>
            </list>
          </t>

          <t>Packet receiver:
            <list style="numbers">
              <t>Verify the HIP header Length field.</t>

              <t>
                Remove the HMAC or HMAC_2 parameter, as well as all
                other parameters that follow it with greater Type value
                including possible HIP_SIGNATURE or HIP_SIGNATURE_2
                fields, saving the contents if they will be needed
                later.
              </t>
              <t>
                In case of HMAC_2, build and add a HOST_ID parameter
                (with Responder information) to the packet. The HOST_ID
                parameter should be identical to the one previously
                received from the Responder.
              </t>
              <t>
                Recalculate the HIP packet length in the HIP header and
                clear the Checksum field (set it to all zeros).  In case
                of HMAC_2, the length is calculated with the added
                HOST_ID parameter.
              </t>
              <t>
                Compute the HMAC using either HIP-gl or HIP-lg integrity
                key as defined in <xref target="keymat" /> and verify it
                against the received HMAC.
              </t>
              <t>
                Set Checksum and Header Length field in the HIP header to
                original values.
              </t>

              <t>
                In case of HMAC_2, remove the HOST_ID parameter from the
                packet before further processing.
              </t>
            </list>
          </t>

        </section>

        <section anchor="sig-processing" title="Signature Calculation">

          <t>
            The following process applies both to the HIP_SIGNATURE and
            HIP_SIGNATURE_2 parameters.  When processing
            HIP_SIGNATURE_2, the only difference is that instead of
            HIP_SIGNATURE parameter, the HIP_SIGNATURE_2 parameter is
            used, and the Initiator's HIT and PUZZLE Opaque and Random
            #I fields are cleared (set to all zeros) before computing
            the signature.  The HIP_SIGNATURE parameter is defined in
            <xref target="hip-signature" /> and the HIP_SIGNATURE_2
            parameter in <xref target="HIP_SIGNATURE_2" />.
          </t>
          <t>
            The scope of the calculation for HIP_SIGNATURE and
            HIP_SIGNATURE_2 is:
          </t>
          <figure>
            <artwork>
HIP_SIGNATURE: { HIP header | [ Parameters ] } 
            </artwork>
          </figure>
          <t>
            where Parameters include all HIP parameters for the packet
            that is being calculated with Type values from 1 to
            (HIP_SIGNATURE's Type value - 1).
          </t>
          <t>
            During signature calculation, the following apply: 
            <list style="symbols">
              <t>
                In the HIP header, the Checksum field is set to zero.
              </t>
              <t>
                In the HIP header, the Header Length field value is
                calculated to the beginning of the HIP_SIGNATURE
                parameter.
              </t>
            </list>
          </t>
          <t>
            Parameter order is described in <xref target="tlvformat" />.
          </t>
            
          <figure>
            <artwork>
HIP_SIGNATURE_2: { HIP header | [ Parameters ] }
            </artwork>
          </figure>
          <t>
            where Parameters include all HIP parameters for the packet
            that is being calculated with Type values from 1 to
            (HIP_SIGNATURE_2's Type value - 1).
          </t>
          <t>
            During signature calculation, the following apply:
            <list style="symbols">
              <t>
                In the HIP header, the Initiator's HIT field and Checksum fields
                are set to zero.
              </t>
              <t>
                In the HIP header, the Header Length field value is
                calculated to the beginning of the HIP_SIGNATURE_2
                parameter.
              </t>
              <t>
                PUZZLE parameter's Opaque and Random #I fields are set
                to zero.
              </t>
            </list>
          </t>
          <t>
            Parameter order is described in <xref target="tlvformat" />.
          </t>
          <t>
            Signature calculation and verification process (the process
            applies both to HIP_SIGNATURE and HIP_SIGNATURE_2 except
            in the
            case where HIP_SIGNATURE_2 is separately mentioned):
          </t>

          <t>Packet sender:
            <list style="numbers">
              <t>
                Create the HIP packet without the HIP_SIGNATURE
                parameter or any parameters that follow the
                HIP_SIGNATURE parameter.
              </t>
              <t>
                Calculate the Length field and zero the Checksum field
                in the HIP header.  In case of HIP_SIGNATURE_2, set
                Initiator's HIT field in the HIP header as well as PUZZLE
                parameter's Opaque and Random #I fields to zero.
              </t>

              <t>
                Compute the signature using the private key corresponding
                to the Host Identifier (public key).
              </t>
              <t>
                Add the HIP_SIGNATURE parameter to the packet.
              </t>
              <t>
                Add any parameters that follow the HIP_SIGNATURE
                parameter.
              </t>
              <t>
                Recalculate the Length field in the HIP header, and
                calculate the Checksum field.
              </t>
            </list>
          </t>

          <t>Packet receiver:
            <list style="numbers">
              <t>Verify the HIP header Length field.</t>

              <t>
                Save the contents of the HIP_SIGNATURE parameter and any
                parameters following the HIP_SIGNATURE parameter and
                remove them from the packet.
              </t>

              <t>
                Recalculate the HIP packet Length in the HIP header and
                clear the Checksum field (set it to all zeros).  In case
                of HIP_SIGNATURE_2, set Initiator's HIT field in HIP
                header as well as PUZZLE parameter's Opaque and Random
                #I fields to zero.
              </t>
              <t>
                Compute the signature and verify it against the received
                signature using the packet sender's Host Identifier (public
                key).
              </t>
              <t>
                Restore the original packet by adding removed parameters
                (in step 2) and resetting the values that were set to
                zero (in step 3).
              </t>
            </list>
          </t>

          <t>
            The verification can use either the HI received from a HIP
            packet, the HI from a DNS query, if the FQDN has been
            received in the HOST_ID packet, or one received by some
            other means.
          </t>


        </section>
        
      </section>
      <section anchor="keymat" title="HIP KEYMAT Generation">
        
        <t>
          HIP keying material is derived from the Diffie-Hellman session
          key, Kij, produced during the HIP base exchange (<xref
          target="auth_dh" />).  The Initiator has Kij during the
          creation of the I2 packet, and the Responder has Kij once it
          receives the I2 packet.  This is why I2 can already contain
          encrypted information. </t>
        
        <t>The KEYMAT is derived by feeding Kij and the HITs into the
          following operation; the | operation denotes concatenation.</t>
        
        <figure>
          <artwork>
 KEYMAT = K1 | K2 | K3 | ...
       where

 K1   = RHASH( Kij | sort(HIT-I | HIT-R) | I | J | 0x01 )
 K2   = RHASH( Kij | K1 | 0x02 )
 K3   = RHASH( Kij | K2 | 0x03 )
 ...
 K255 = RHASH( Kij | K254 | 0xff )
 K256 = RHASH( Kij | K255 | 0x00 )
 etc.
          </artwork>
        </figure>
        
        <t>
          Sort(HIT-I | HIT-R) is defined as the network byte order
          concatenation of the two HITs, with the smaller HIT preceding the
          larger HIT, resulting from the numeric comparison of the two HITs
          interpreted as positive (unsigned) 128-bit integers in network
          byte order.
        </t>
        
        <t>
          I and J values are from the puzzle and its solution that were
          exchanged in R1 and I2 messages when this HIP association was
          set up.  Both hosts have to store I and J values for the HIP
          association for future use.
        </t>

        <t>
          The initial keys are drawn sequentially in the order that is
          determined by the numeric comparison of the two HITs, with
          comparison method described in the previous paragraph.  HOST_g
          denotes the host with the greater HIT value, and HOST_l the
          host with the lower HIT value.
        </t>
        
        <t>The drawing order for initial keys:
          
          <list>
            <t>HIP-gl encryption key for HOST_g's outgoing HIP packets</t>
            <t>HIP-gl integrity (HMAC) key for HOST_g's outgoing HIP
              packets</t>
            <t>HIP-lg encryption key (currently unused) for HOST_l's
              outgoing HIP packets</t>
            <t>HIP-lg integrity (HMAC) key for HOST_l's outgoing HIP
              packets</t>
          </list>
        </t>
        
        <t>The number of bits drawn for a given algorithm is the
          "natural" size of the keys.  For the mandatory algorithms, the
          following sizes apply:
          <list style="hanging">
            <t hangText="AES">128 bits</t>
            <t hangText="SHA-1">160 bits</t>
            <t hangText="NULL">0 bits</t>
          </list>
        </t>
        <t>
