<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc subcompact="no"?>


<rfc number="5572" category="exp">
  <front>
    <title abbrev="Tunnel Setup Protocol (TSP)">
IPv6 Tunnel Broker with the Tunnel Setup Protocol (TSP)</title>
    <author initials="M." surname="Blanchet" fullname="Marc Blanchet">
      <organization>Viagenie</organization>
  <address>
         <postal>
         <street>2600 boul. Laurier, suite 625</street>
          <city>Quebec</city>
          <region>QC</region>
          <code>G1V 4W1</code>
        <country>Canada</country>
      </postal>
        <phone>+1-418-656-9254</phone>
        <email>Marc.Blanchet@viagenie.ca</email>
</address>
</author>
  <author initials="F." surname="Parent" fullname="Florent Parent">
  <organization>Beon Solutions</organization>
  <address>
    <postal>
        <street></street>
      <city>Quebec</city>
      <region>QC</region>
      <code></code>
      <country>Canada</country>
    </postal>
    <phone>+1 418 265 7357</phone>
    <email>Florent.Parent@beon.ca</email>
  </address>
  </author>
  <date month="January" year="2010" />
<area>Operations</area>
<keyword>IPv6</keyword>
<keyword>Tunnel</keyword>
<keyword>Transition</keyword>
<keyword>TSP</keyword>


<abstract>
<t>A tunnel broker with the Tunnel Setup Protocol (TSP) enables the
establishment of tunnels of various inner protocols, such as IPv6 or
IPv4, inside various outer protocols packets, such as IPv4, IPv6, or
UDP over IPv4 for IPv4 NAT traversal. The control protocol (TSP) is
used by the tunnel client to negotiate the tunnel with the broker.  A
mobile node implementing TSP can be connected to both IPv4 and IPv6
networks whether it is on IPv4 only, IPv4 behind a NAT, or on IPv6
only.  A tunnel broker may terminate the tunnels on remote tunnel
servers or on itself.  This document describes the TSP within
the model of the tunnel broker model.
</t>
  </abstract>

<note title="IESG Note">
<t>  The content of this RFC was at one time considered by the IETF,
     and therefore it may resemble a current IETF work in progress or a
     published IETF work.  This RFC is not a candidate for any level of
     Internet Standard.  The IETF disclaims any knowledge of the
     fitness of this RFC for any purpose and in particular notes that
     the decision to publish is not based on IETF review for such
     things as security, congestion control, or inappropriate
     interaction with deployed protocols.  The RFC Editor has chosen to
     publish this document at its discretion.  Readers of this RFC
     should exercise caution in evaluating its value for implementation
     and deployment.  See RFC 3932 for more information.</t>
</note>
</front>
<middle>
  <section title="Introduction">
      <t>
This document first describes the TSP framework, the protocol details,
and the different profiles used. It then describes the applicability
of TSP in different environments, some of which were described in the
v6ops scenario documents.
    </t>

<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref
target="RFC2119" />.
</t>
  </section>
   <section title="Description of the TSP Framework">
    <t>
Tunnel Setup Protocol (TSP) is a signaling protocol to set up tunnel
parameters between two tunnel endpoints. TSP is implemented as a tiny
client code in the requesting tunnel endpoint.  The other endpoint
is the server that will set up the tunnel service. TSP uses XML <xref
target="W3C.REC-xml-2004" /> basic messaging over TCP or UDP.
The use of XML gives extensibility and easy option processing.
</t>
<t>
TSP negotiates tunnel parameters between the two tunnel
endpoints. Parameters that are always negotiated are:
</t>
<t>
  <list style="symbols">
    <t>
Authentication of the users, using any kind of authentication
mechanism (through Simple Authentication and Security Layer (SASL) <xref target="RFC4422" />) including
anonymous
</t>
<t>Tunnel encapsulation:
<list>
  <t>
    IPv6 over IPv4 tunnels <xref target="RFC4213"></xref>
  </t>
  <t>
    IPv4 over IPv6 tunnels <xref target="RFC2473"></xref>
  </t>
  <t>
    IPv6 over UDP-IPv4 tunnels for NAT traversal
  </t>
</list>
</t>
<t>
  IP address assignment for the tunnel endpoints
</t>
        <t>
DNS registration of the IP endpoint address (AAAA)
</t>
  </list>
<t>
  Other tunnel parameters that may be negotiated are:
</t>
  <list style="symbols">
<t>
Tunnel keep-alive
</t>
<t>
IPv6 prefix assignment when the client is a router
</t>
        <t>
DNS delegation of the inverse tree, based on the IPv6 prefix assigned
</t>
        <t>
Routing protocols
</t>
   
      </list>
</t>
      <t>
The tunnel encapsulation can be explicitly specified by the client, or
can be determined during the TSP exchange by the broker. The latter is used to
detect the presence of NAT in the path and select IPv6 over UDP-IPv4
encapsulation.
</t>
<t>
The TSP connection can be established between two nodes, where each
node can control a tunnel endpoint.  
</t>
    <t>
The nodes involved in the framework are:

<list style="numbers">
    <t>the TSP client</t>
    <t>the client tunnel endpoint</t>
    <t>the TSP server</t>
    <t>the server tunnel endpoint</t>

  </list>

1,3, and 4 form the tunnel broker model <xref target="RFC3053" />,
where 3 is the tunnel broker and 4 is the tunnel server (<xref
target="Broker_Model" />). The tunnel broker may control one or many
tunnel servers. </t>
<t>
In its simplest model, one node is the client configured as a tunnel
endpoint (1 and 2 on the same node), and the second node is the server
configured as the other tunnel endpoint (3 and 4 on the same node). This
model is shown in
<xref target="Server_Model"/>:
</t>
<figure anchor="Broker_Model" title="Tunnel Setup Protocol Used on Tunnel Broker Model">
<artwork>
                           _______________
                          | TUNNEL BROKER |--&gt; Databases (DNS)
                          |               |
                          |  TSP          |
                          | SERVER        |
                          |_______________|
                              |     |
         __________           |     |          ________
        |           |         |     |         |        |
        |   TSP     |--[TSP]--      +---------|        |
        |  CLIENT   |                         | TUNNEL |--[NETWORK]--
[HOST]--|           |&lt;==[CONFIGURED TUNNEL]==&gt;| SERVER |
        |___________|                         |        |
                                              |________|
</artwork>
</figure>
<figure anchor="Server_Model" title="Tunnel Setup Protocol Used on Tunnel Server Model">

<artwork>
         ___________                           ________
        |           |                         |  TSP   |
        |   TSP     |-----------[TSP]---------| SERVER |
        |  CLIENT   |                         |        |--[NETWORK]--
[HOST]--|           |&lt;==[CONFIGURED TUNNEL]==&gt;| TUNNEL |
        |___________|                         | SERVER |
                                              |________|
</artwork>
</figure>

<t>
From the point of view of an operating system, TSP is implemented as a
client application that is able to configure network parameters of
the operating system.
</t>
<section title="NAT Discovery">
  <t>
TSP is also used to discover if a NAT is in the path. In this
discovery mode, the client sends a TSP message over UDP, containing
its tunnel request information (such as its source IPv4 address) to
the TSP server. The TSP server compares the IPv4 source address of the
packet with the address in the TSP message. If they differ, one or
many IPv4 NATs are in the path.
</t>
  <t>
If an IPv4 NAT is discovered, then IPv6 over UDP-IPv4 tunnel encapsulation is
selected. Once the TSP signaling is done, the tunnel is established over the
same UDP channel used for TSP, so the same NAT address-port mapping is used
for both the TSP session and the IPv6 traffic.  If no IPv4 NAT is detected in
the path by the TSP server, then IPv6 over IPv4 encapsulation is used.
</t>
        <t>A keep-alive mechanism is also included to keep the NAT
mapping active.</t>

<t>The IPv4 NAT discovery builds the most effective tunnel for all
cases, including in a dynamic situation where the client moves.
</t>
      </section>
             <section title="Any Encapsulation">
        <t>
TSP is used to negotiate IPv6 over IPv4 tunnels, IPv6 over UDP-IPv4
tunnels, and IPv4 over IPv6 tunnels.  IPv4 over IPv6 tunnels is used
in the Dual-Stack Transition Mechanism (DSTM) together with TSP <xref
target="DSTM"/>.
</t>
      </section>
  <section title="Mobility">
        <t>
When a node moves to a different IP network (i.e., change of its IPv4
address when doing IPv6 over IPv4 encapsulation), the TSP client
reconnects automatically to the broker to re-establish the tunnel
(keep-alive mechanism). On the IPv6 layer, if the client uses user
authentication, the same IPv6 address and prefix are kept and
re-established, even if the IPv4 address or tunnel encapsulation type
changes.
</t>
      </section>
    </section>
    <section title="Advantages of TSP">
      <t>
        <list style="symbols">
          <t>
Tunnels established by TSP are static tunnels, which are more secure
than automated tunnels <xref target="RFC3964" />; no third-party relay
required.
          </t>
<t>
Stability of the IP address and prefix, enabling applications needing
stable address to be deployed and used. For example, when tunneling
IPv6, there is no dependency on the underlying IPv4 address.
</t>
          <t>
Prefix assignment supported. Can use provider address space.
</t>
          <t>
Signaling protocol flexible and extensible (XML, SASL)
          </t>
          <t>
One solution to many encapsulation techniques: IPv6 in IPv4, IPv4 in IPv6, IPv6
over UDP over IPv4. Can be extended to other encapsulation types, such
as IPv6 in IPv6.
</t>
          <t>
Discovery of IPv4 NAT in the path, establishing the most optimized
tunneling technique depending on the discovery.
</t>

        </list>
</t>
</section>
<section title="Protocol Description">
  <section title="Terminology">
    <t>
<list style="hanging">
        <t hangText="Tunnel Broker:">
In a tunnel broker model, the broker is taking charge of all
communication between tunnel servers (TSs) and tunnel clients
(TCs). Tunnel clients query brokers for a tunnel and the broker finds a
suitable tunnel server, asks the tunnel server to set up the tunnel, and
sends the tunnel information to the tunnel Client.
</t>
        <t hangText="Tunnel Server:">
Tunnel servers are providing the specific tunnel service to a tunnel
client. It can receive the tunnel request from a tunnel broker (as in
the tunnel broker model) or directly from the tunnel client. The
tunnel server is the tunnel endpoint.
</t>
        <t hangText="Tunnel Client:">
The tunnel client is the entity that needs a tunnel for a particular
service or connectivity. A tunnel client can be either a host or a
router. The tunnel client is the other tunnel endpoint.
</t>


<t hangText="v6v4:">
  IPv6-over-IPv4 tunnel encapsulation
</t>
<t hangText="v6udpv4:">
  IPv6-over-UDP-over-IPv4 tunnel encapsulation
</t>
<t hangText="v4v6:">
  IPv4-over-IPv6 tunnel encapsulation
</t>
      </list>
</t>
</section>
<section title="Topology">
<t>
The following diagrams describe typical TSP scenarios. The goal is to establish
a tunnel between tunnel client and tunnel server.
</t>
</section>
<section title="Overview">
<t>
  The Tunnel Setup Protocol is initiated from a client node to a
  tunnel broker. The Tunnel Setup Protocol has three phases:
</t>
<t>  
  <list style="hanging">
    <t hangText="Authentication phase:">
      The Authentication phase is when the tunnel broker/server
      advertises its capability to a tunnel client and when a tunnel
      client authenticate to the broker/server.
    </t>
    <t hangText="Command phase:">
      The command phase is where the client requests or updates a
      tunnel.
    </t>
    <t hangText="Response phase:">
      The response phase is where the tunnel client receives the
      request response from the tunnel broker/server, and the client
      accepts or rejects the tunnel offered.
    </t>
  </list>
</t>
<t>
For each command sent by a tunnel client, there is an expected response
from the server.
</t>

<t>
After the response phase is completed, a tunnel is established as
requested by the client. If requested, periodic keep-alive packets can
be sent from the client to the server.
          </t>

          <figure anchor="Message_sequence" title="Tunnel Setup Protocol Exchange">
            <artwork>
        tunnel                              tunnel
        client                              broker
          +|         Send version              +
          ||---------------------------------&gt; || 
          ||         Send capabilities         ||
          ||&lt;--------------------------------- +| Authentication
          ||         SASL authentication       || phase
          ||&lt;--------------------------------&gt; || 
 TSP      ||         Authentication OK         ||
 signaling||&lt;--------------------------------- +
          ||         Tunnel request            || Command 
          ||---------------------------------&gt; || phase
          ||         Tunnel response           +  
          ||&lt;--------------------------------- || Response 
          ||         Tunnel acknowledge        || phase
          ||---------------------------------&gt; +
          +|                                   |
          ||         Tunnel established        |
 Data     ||===================================|
 phase    ||                                   |
          +|           (keep-alive)            |



            </artwork>
          </figure>

</section>
<section title="TSP Signaling">

<t>
  The following sections describe in detail the TSP and the
  different phases in the TSP signaling.
</t>

<section title="Signaling Transport">
<t>
  TSP signaling can be transported over TCP or UDP, and over IPv4 or
  IPv6. The tunnel client selects the transport according to the
  tunnel encapsulation being requested.

 <xref
  target="TSP_transport_table" /> shows the transport used for TSP
  signaling with possible tunnel encapsulation requested. 
</t>
<t>
TSP signaling over UDP/v4 MUST be used if a v6 over UDP over IPv4
(v6udpv4) tunnel is to be requested (e.g., for NAT traversal).
</t>
<t>


          <figure anchor="TSP_transport_table" title="TSP Signaling Transport">
            <artwork>
    Tunnel 
    Encapsulation   Valid       Valid
    Requested       Transport   Address family
    ------------------------------------------
    v6anyv4         TCP UDP     IPv4
    v6v4            TCP UDP     IPv4
    v6udpv4             UDP     IPv4
    v4v6            TCP UDP     IPv6

            </artwork>
          </figure>

</t>
<t>
  Note that the TSP framework allows for other type of encapsulation
  to be defined, such as IPv6 over Generic Routing Encapsulation (GRE) or IPv6 over IPv6.
</t>
<section title="TSP Signaling over TCP">
<t>
  TSP over TCP is sent over port number 3653 (IANA assigned). TSP
  data used during signaling is detailed in the next sections.

<figure anchor="TCP_control_phase_packet" title="Tunnel Setup Protocol Packet Format (TCP)">
<artwork>

                   +------+-----------+----------+
                   |  IP  | TCP       | TSP data |
                   |      | port 3653 |          |
                   +------+-----------+----------+
                   where IP is IPv4 or IPv6
</artwork>
</figure>

</t>
</section>
<section title="TSP Signaling over UDP/v4" anchor="udpv4_signaling">
<t>
  While TCP provides the connection-oriented and reliable data
  delivery features required during the TSP signaling session, UDP
  does not offer any reliability. This reliability is added inside the
  TSP session as an extra header at the beginning of the UDP payload.


<figure anchor="UDP_control_phase_packet" title="Tunnel Setup Protocol Packet Format (UDP)" >
<artwork>
                +------+-----------+------------+----------+
                | IPv4 | UDP       | TSP header | TSP data |
                |      | port 3653 |            |          |
                +------+-----------+------------+----------+
</artwork>
</figure>
</t>
<t>

The algorithm used to add reliability to TSP packets sent over UDP is
described in Section 22.5 of <xref target="UNP" />.
  
<figure anchor="TSP_header" title="TSP Header for Reliable UDP">
<artwork>

   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |  0xF  |                 Sequence Number                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                            Timestamp                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                            TSP data                           |
  ...

</artwork>
</figure>

<list style="hanging">
  <t>The 4-bit field (0-3) is set to 0xF. This marker is used by
  the tunnel broker to identify a TSP signaling packet that is sent
  after an IPv6 over UDP is established. This is explained in <xref target="v6udpv4_establishment" /> </t>
  <t hangText="Sequence Number:">
    28-bit field. Set by the tunnel client. Value is increased by one for
    every new packet sent to the tunnel broker. The return packet from
    the broker contains the unaltered sequence number.</t>
  <t hangText="Timestamp:">
    32-bit field. Set by the tunnel client. Generated from the client
    local-time value. The return packet from the broker contains the
    unaltered timestamp.
  </t>
  <t hangText="TSP data:">
    Same as in the TCP/v4 case. Content described in later sections.
  </t>
</list>

</t>
<t>
  The TSP client builds its UDP packet as described above and sends it
  to the tunnel broker. When the tunnel broker responds, the same
  values for the sequence number and timestamp MUST be sent back to
  the client. The TSP client can use the timestamp to determine the
  retransmission timeout (current time minus the packet
  timestamp). The client SHOULD retransmit the packet when the
  retransmission timeout is reached. The retransmitted packet MUST use
  the same sequence number as the original packet so that the server
  can detect duplicate packets. The client SHOULD use exponential
  backoff when retransmitting packets to avoid network congestion.
</t>
</section>
</section>
<section title="Authentication Phase">
  <t>
    The authentication phase has 3 steps:
  </t>
            <t>
              <list style="symbols">
                <t>Client's protocol version identification</t>
                <t>Server's capability advertisement</t>
                <t>Client authentication</t>
              </list>
            </t>
            <t>
              When a TCP or UDP session is established to a tunnel
              broker, the tunnel client sends the current protocol
              version it is supporting.  The version number syntax is:
            </t>
            <t>
              <list style="empty">
                <t> VERSION=2.0.0 CR LF</t>
              </list>  
            </t>

            <t>
Version 2.0.0 is the version number of this specification. Version 1.0.0 was
defined in earlier documents.
	    </t>
	    <t>
If the server doesn't support the protocol version, it sends an error message
and closes the session. The server can optionally send a server list that may
support the protocol version of the client.
            </t>
            <figure anchor="NotSupported_1" title="Example of Unsupported Client Version">
              <preamble>Example of an unsupported client version (without a server list):</preamble>
              <artwork>
      -- Successful TCP Connection --
      C:VERSION=0.1 CR LF
      S:302 Unsupported client version CR LF
      -- Connection closed --
              </artwork>
            </figure>
            <figure anchor="NotSupported_2" title="Example of Unsupported Client Version, with Server Redirection">
              <preamble>Example of a version not supported (with a server list):</preamble>
              <artwork>
      -- Successful TCP Connection --
      C:VERSION=1.1 CR LF
      S:1302 Unsupported client version CR LF
        &lt;tunnel action="list" type="broker"&gt;
           &lt;broker&gt;
              &lt;address type="ipv4"&gt;1.2.3.4&lt;/address&gt;
           &lt;/broker&gt;
           &lt;broker&gt;
              &lt;address type="dn"&gt;ts1.isp1.com&lt;/address&gt;
           &lt;/broker&gt;
        &lt;/tunnel&gt;
      -- Connection closed --
              </artwork>
            </figure>
            <t>
If the server supports the version sent by the client, then the server sends a
list of the capabilities supported for authentication and tunnels.
            </t>
            <t>
              <list style="empty">
                <t>CAPABILITY TUNNEL=V6V4 TUNNEL=V6UDPV4
                AUTH=ANONYMOUS AUTH=PLAIN AUTH=DIGEST-MD5 CR LF</t>
              </list>
            </t>
            <t>
Tunnel types must be registered with IANA and their profiles are defined in
<xref target="IANA"/>. Authentication is done using <xref
target="RFC4422">SASL</xref>.  Each authentication mechanism should be a
registered SASL mechanism. Description of such mechanisms is not in the scope
of this document.
</t>
<t>
The tunnel client can then choose to close the session if none of the
capabilities fit its needs. If the tunnel client chooses to continue,
it authenticates to the server using one of the advertised mechanisms
using SASL. If the authentication fails, the server sends an error
message and closes the session.
</t>
<t>
  The example in <xref target="Failed_Auth"/> shows a failed
  authentication where the tunnel client requests an anonymous
  authentication that is not supported by the server.
</t>
<t>
  Note that linebreaks and indentation within a "C:" or "S:" are
  editorial and not part of the protocol.
</t>
            <figure anchor="Failed_Auth" title="Example of Failed Authentication">
              <artwork>
-- Successful TCP Connection --
C:VERSION=2.0.0 CR LF
S:CAPABILITY TUNNEL=V6V4 AUTH=DIGEST-MD5 CR LF
C:AUTHENTICATE ANONYMOUS CR LF
S:300 Authentication failed CR LF
              </artwork>
            </figure>
<t>
<xref target="Successful_Auth"/> shows a successful anonymous
authentication.
</t>
            <figure anchor="Successful_Auth" title="Successful Anonymous Authentication">
              <artwork>
-- Successful TCP Connection --
C:VERSION=2.0.0 CR LF
S:CAPABILITY TUNNEL=V6V4 TUNNEL=V6UDPV4 AUTH=ANONYMOUS AUTH=PLAIN 
  AUTH=DIGEST-MD5 CR LF
C:AUTHENTICATE ANONYMOUS CR LF
S:200 Success CR LF
              </artwork>
            </figure>
<t>
  Digest-MD5 authentication with SASL follows <xref target="RFC2831"
  />. <xref target="Digest_success"/> shows a successful digest-MD5
  SASL authentication.

</t>
<figure anchor="Digest_success" title="Successful Digest-MD5 Authentication">
  <artwork>
-- Successful TCP Connection --
C:VERSION=2.0.0 CR LF
S:CAPABILITY TUNNEL=V6V4 TUNNEL=V6UDPV4 AUTH=ANONYMOUS AUTH=PLAIN 
  AUTH=DIGEST-MD5 CR LF
C:AUTHENTICATE DIGEST-MD5 CR LF
S:cmVhbG09aGV4b3Msbm9uY2U9MTExMzkwODk2OCxxb3A9YXV0aCxhbGdvcml0aG09bWQ
  1LXNlc3MsY2hhcnNldD11dGY4
C:Y2hhcnNldD11dGY4LHVzZXJuYW1lPSJ1c2VybmFtZTEiLHJlYWxtPSJoZXhvcyIsbm9
  uY2U9IjExMTM5MDg5NjgiLG5jPTAwMDAwMDAxLGNub25jZT0iMTExMzkyMzMxMSIsZG
  lnZXN0LXVyaT0idHNwL2hleG9zIixyZXNwb25zZT1mOGU0MmIzYzUwYzU5NzcxODUzZ
  jYyNzRmY2ZmZDFjYSxxb3A9YXV0aA==
S:cnNwYXV0aD03MGQ1Y2FiYzkyMzU1NjhiZTM4MGJhMmM5MDczODFmZQ==
S:200 Success CR LF
  </artwork>
</figure>
<t>
  The base64-decoded version of the SASL exchange is:
</t>
	    <figure>
<artwork>
S:realm="hexos",nonce="1113908968",qop="auth",algorithm=md5-sess,
  charset=utf8
C:charset=utf8,username="username1",realm="hexos",nonce="1113908968",
  nc=00000001,cnonce="1113923311",digest-uri="tsp/hexos",
  response=f8e42b3c50c59771853f6274fcffd1ca,qop=auth
S:rspauth=70d5cabc9235568be380ba2c907381fe
</artwork>
            </figure>

            <t>
Once the authentication succeeds, the server sends a success return
code and the protocol enters the Command phase.
            </t>
</section>
<section title="Command and Response Phase" anchor="cmd_response_phase">
  <t>
    The Command phase is where the tunnel client sends a tunnel request
    or a tunnel update to the server. In this phase, commands are sent
    as XML messages. The first line is a "Content-length" directive
    that indicates the size of the following XML message. When the
    server sends a response, the first line is the "Content-length"
    directive, the second is the return code, and third one is the XML
    message, if any. The "Content-length" is calculated from the first
    character of the return code line to the last character of the XML
    message, inclusively.
  </t>
  <t>
    Spaces can be inserted freely.
  </t>
  <figure anchor="command_response_sequence" title="Example of a Command/Response Sequence">
    <artwork>
      -- UDP session established --
      C:VERSION=2.0.0 CR LF
      S:CAPABILITY TUNNEL=V6V4 TUNNEL=V6UDPV4 AUTH=ANONYMOUS 
        AUTH=PLAIN AUTH=DIGEST-MD5 CR LF
      C:AUTHENTICATE ANONYMOUS CR LF
      S:200 Success CR LF
      
      C:Content-length: 205 CR LF
      &lt;tunnel action="create" type="v6udpv4"&gt;
       &lt;client&gt;
        &lt;address type="ipv4"&gt;192.0.2.135&lt;/address&gt;
      &lt;keepalive interval="30"&gt;&lt;/keepalive&gt; 
      &lt;/client&gt;
      &lt;/tunnel&gt; CR LF
      
      S:Content-length: 501 CR LF
      200 Success CR LF
      &lt;tunnel action="info" type="v6udpv4" lifetime="604800"&gt;
        &lt;server&gt;
          &lt;address type="ipv4"&gt;192.0.2.115&lt;/address&gt;
          &lt;address type="ipv6"&gt;
          2001:db8:8000:0000:0000:0000:0000:38b2
          &lt;/address&gt;
        &lt;/server&gt;
        &lt;client&gt;
          &lt;address type="ipv4"&gt;192.0.2.135&lt;/address&gt;
          &lt;address type="ipv6"&gt;
          2001:db8:8000:0000:0000:0000:0000:38b3
          &lt;/address&gt;
          &lt;keepalive interval="30"&gt;
            &lt;address type="ipv6"&gt;
            2001:db8:8000:0000:0000:0000:0000:38b2
            &lt;/address&gt;
          &lt;/keepalive&gt;
        &lt;/client&gt;
      &lt;/tunnel&gt; CR LF
      
      C:Content-length: 35 CR LF
      &lt;tunnel action="accept"&gt;&lt;/tunnel&gt; CR LF

              </artwork>
            </figure>

<t>
  The example in <xref target="command_response_sequence" /> shows a
  client requesting an anonymous v6udpv4 tunnel, indicating that a
  keep-alive packet will be sent every 30 seconds. The tunnel broker
  responds with the tunnel parameters and indicates its acceptance of
  the keep-alive period (<xref target="keepalive" />).
 Finally, the
  client sends an accept message to the server.
</t>
<t>
  Once the accept message has been sent, the server and client
  configure their tunnel endpoint based on the negotiated tunnel
  parameters.
</t>
</section>
</section>
<section title="Tunnel Establishment">
<section title="IPv6-over-IPv4 Tunnels">  
  <t>
    Once the TSP signaling is complete, a tunnel can be established
    on the tunnel server and client node. If a v6v4 tunnel has been
    negotiated, then an IPv6-over-IPv4 tunnel <xref target="RFC4213"
    /> is established using the operating system tunneling
    interface. On the client node, this is accomplished by the TSP
    client calling the appropriate OS commands or system calls.
  </t>
</section>
<section title="IPv6-over-UDP Tunnels" anchor="v6udpv4_establishment">
<t>
  If a v6udpv4 tunnel is configured, the same source/destination
  address and port used during the TSP signaling are used to configure
  the v6udpv4 tunnel. If a NAT is in the path between the TSP client
  and the tunnel broker, the TSP signaling session will have created a UDP
  state in the NAT. By reusing the same UDP socket parameters to
  transport IPv6, the traffic will flow across the NAT using the same
  state.

<figure anchor="IPv6_over_UDP" title="IPv6 Transport over UDP">
<artwork>
                +------+-----------+--------+
                | IPv4 | UDP       |  IPv6  |
                | hdr. | port 3653 |        |
                +------+-----------+--------+
</artwork>
</figure>
</t>
  <t>
    At any time, a client may re-establish a TSP signaling
    session. The client disconnects the current tunnel and starts a
    new TSP signaling session as described in <xref
    target="udpv4_signaling" />.  If a NAT is present and the new TSP
    session uses the same UDP mapping in the NAT as for the tunnel,
    the tunnel broker will need to disconnect the client tunnel before
    the client can establish a new TSP session.
  </t>
</section>

</section>
<section title="Tunnel Keep-Alive" anchor="keepalive">
  <t>
    A TSP client may select to send periodic keep-alive messages to
    the server in order to maintain its tunnel connectivity. This
    allows the client to detect network changes and enable automatic
    tunnel re&nbhy;establishment. In the case of IPv6-over-UDP tunnels,
    periodic keep-alive messages can help refresh the connection state in a NAT
    if such a device is in the tunnel path.
  </t>

  <t>
    For IPv6-over-IPv4 and IPv6-over-UDP tunnels, the keep-alive
    message is an ICMPv6 echo request <xref target="RFC4443"/> sent
    from the client to the tunnel server. The IPv6 destination address
    of the echo message MUST be the address from the 'keepalive'
    element sent in the tunnel response during the TSP signaling
    (<xref target="cmd_response_phase" />). The echo message is sent
    over the configured tunnel.
  </t>
  <t>
    The tunnel server responds to the ICMPv6 echo requests and can
    keep track of which tunnel is active. Any client traffic can also
    be used to verify if the tunnel is active. This can be used by the
    broker to disconnect tunnels that are no longer in use.
  </t>
  <t>
  The broker can send a different keep-alive interval from the value
  specified in the client request. The client MUST conform to the
  broker-specified keep-alive interval. The client SHOULD apply a
  random "jitter" value to avoid synchronization of keep-alive
  messages from many clients to the server <xref target="FJ93"/>. This
  is achieved by using an interval value in the range of [0.75T -
  T], where T is the keep-alive interval specified by the server.

</t>
</section>
<section title="XML Messaging">
<t>
  This section describes the XML messaging used in the TSP signaling
  during the command and response phase. The XML elements and
  attributes are listed in the DTD (<xref target="DTD_section"/>).
</t>
  <section title="Tunnel">
    <t>
      The client and server use the tunnel token with an action
      attribute. Valid actions for this profile are: 'create',
      'delete', 'info', 'accept', and 'reject'.
<list style="hanging">
<t hangText="create:">
  action used to request a new tunnel or update an existing
  tunnel. Sent by the tunnel client.
</t>
<t hangText="delete:">
  action used to remove an existing tunnel from the server. Sent by
  the tunnel client.
</t>
<t hangText="info:">
  action used to request current properties of an existing
  tunnel. This action is also used by the tunnel broker to send tunnel
  parameters following a client 'create' action.
</t>
<t hangText="accept:">
  action used by the client to acknowledge the server that the tunnel
  parameters are accepted. The client will establish a tunnel.
</t>
<t hangText="reject:">
  action used by the client to signal the server that the tunnel
  parameters offered are rejected and no tunnel will be established.
</t>
             
</list>
    </t>
<t>
  The tunnel 'lifetime' attribute is set by the tunnel broker and
  specifies the lifetime of the tunnel in minutes. The lifetime is an
  administratively set value. When a tunnel lifetime has expired, it is
  disconnected on the tunnel server.
</t>
    <t>
      The 'tunnel' message contains three elements:
    </t>
    <t>
      <list style="hanging">
        <t hangText="&lt;client&gt;: ">Client's information</t>
        <t hangText="&lt;server&gt;: ">Server's information</t>
        <t hangText="&lt;broker&gt;: ">List of other servers</t>
      </list>
    </t>
  </section>
  <section title="Client Element">
    <t>
      The 'client' element contains 3 sub-elements: 'address', 'router',
      and 'keepalive'. These elements are used to describe the client
      request and will be used by the server to create the appropriate
      tunnel. The client element is the only element sent by a client.
    </t>
    <t>
      The 'address' element is used to identify the client IP endpoint
      of the tunnel. When tunneling over IPv4, the client MUST send
      only its IPv4 address to the server. When tunneling over IPv6,
      the client MUST only send its IPv6 address to the server.
    </t>
    <t>
      The broker then returns the assigned IPv6 or IPv4 address
      endpoint and domain name inside the 'client' element when the
      tunnel is created or updated. If supported by the broker, the
      'client' element MAY contain the registered DNS name for the
      address endpoint assigned to the client.
    </t>
    <t>
      Optionally, a client MAY send a 'router' element to ask for
      a prefix delegation.
    </t>
    <t>
      Optionally, a client MAY send a 'keepalive' element that
      contains the keep-alive time interval requested by the client.
    </t>
  </section>
  <section title="Server Element">
    <t>
      The 'server' element contains two elements: 'address' and
      'router'. These elements are used to describe the server's
      tunnel endpoint. The 'address' element is used to provide both
      IPv4 and IPv6 addresses of the server's tunnel endpoint, while
      the 'router' element provides information for the routing method
      chosen by the client.
    </t>
  </section>
  <section title="Broker Element">
    <t>
      The 'broker' element is used by a tunnel broker to provide an
      alternate list of brokers to a client in the case where the
      server is not able to provide the requested tunnel.
    </t>
    <t>
      The 'broker' element contains an 'address' element or a series of 'address' elements.

<!-- [rfced] Does the above convey the meaning intended by "series of element(s)"? -->
    </t>
  </section>
</section>
</section>
<section title="Tunnel Request Examples">
  <t>This section presents multiple examples of requests.</t>
  <section title="Host Tunnel Request and Reply">
    <t>
      A simple tunnel request consist of a 'tunnel' element that
      contains only an 'address' element. The tunnel action is
      'create', specifying a 'v6v4' tunnel encapsulation type. The
      response sent by the tunnel broker is an 'info' action. Note
      that the registered Fully-Qualified Domain Name (FQDN) of the assigned client IPv6 address is
      also returned to the tunnel client.
</t>
      <figure anchor="SimpleRequest" title="Simple Tunnel Request Made by a Client">
        <artwork>
      -- Successful TCP Connection --
      C:VERSION=2.0.0 CR LF
      S:CAPABILITY TUNNEL=V6V4 AUTH=ANONYMOUS CR LF
      C:AUTHENTICATE ANONYMOUS CR LF
      S:200 Authentication successful CR LF
      C:Content-length: 123 CR LF
        &lt;tunnel action="create" type="v6v4"&gt;
           &lt;client&gt;
               &lt;address type="ipv4"&gt;1.1.1.1&lt;/address&gt;
           &lt;/client&gt;
        &lt;/tunnel&gt; CR LF
      S: Content-length: 234 CR LF
         200 OK CR LF
         &lt;tunnel action="info" type="v6v4" lifetime="1440"&gt;
           &lt;server&gt;
              &lt;address type="ipv4"&gt;192.0.2.114&lt;/address&gt;
              &lt;address type="ipv6"&gt;
              2001:db8:c18:ffff:0000:0000:0000:0000
              &lt;/address&gt;
           &lt;/server&gt;
           &lt;client&gt;
              &lt;address type="ipv4"&gt;1.1.1.1&lt;/address&gt;
              &lt;address type="ipv6"&gt;
              2001:db8:c18:ffff::0000:0000:0000:0001
              &lt;/address&gt;
              &lt;address type="dn"&gt;userid.domain&lt;/address&gt;
           &lt;/client&gt;
         &lt;/tunnel&gt; CR LF
      C: Content-length: 35 CR LF
         &lt;tunnel action="accept"&gt;&lt;/tunnel&gt; CR LF
            </artwork>
      </figure>
  </section>
  <section title="Router Tunnel Request with a /48 Prefix Delegation and Reply">
    <t>
      A tunnel request with a prefix consists of a 'tunnel' element that
      contains an 'address' element and a 'router' element. The 'router'
      element also contains the 'dns_server' element that is used to
      request a DNS delegation of the assigned IPv6 prefix. The
      'dns_server' element lists the IP address of the DNS servers to
      be registered for the reverse-mapping zone.
    </t>
      <figure anchor="StaticRequest" title="Tunnel Request with Prefix and DNS Delegation">
        <preamble>Tunnel request with prefix and static
        routes.</preamble>
        <artwork>
C: Content-length: 234 CR LF
   &lt;tunnel action="create" type="v6v4"&gt;
    &lt;client&gt;
     &lt;address type="ipv4"&gt;192.0.2.9&lt;/address&gt;
     &lt;router&gt;
      &lt;prefix length="48"/&gt;
      &lt;dns_server&gt;
       &lt;address type="ipv4"&gt;192.0.2.5&lt;/address&gt;
       &lt;address type="ipv4"&gt;192.0.2.4&lt;/address&gt;
       &lt;address type="ipv6"&gt;2001:db8::1&lt;/address&gt;
      &lt;/dns_server&gt;
     &lt;/router&gt;
    &lt;/client&gt;
   &lt;/tunnel&gt; CR LF
S: Content-length: 234 CR LF
   200 OK CR LF
   &lt;tunnel action="info" type="v6v4" lifetime="1440"&gt;
    &lt;server&gt;
     &lt;address type="ipv4"&gt;192.0.2.114&lt;/address&gt;
     &lt;address type="ipv6"&gt;
     2001:db8:c18:ffff:0000:0000:0000:0000
     &lt;/address&gt;
    &lt;/server&gt;
    &lt;client&gt;
     &lt;address type="ipv4"&gt;192.0.2.9&lt;/address&gt;
     &lt;address type="ipv6"&gt;
     2001:db8:c18:ffff::0000:0000:0000:0001
     &lt;/address&gt;
     &lt;address type="dn"&gt;userid.domain&lt;/address&gt;
     &lt;router&gt;
      &lt;prefix length="48"&gt;2001:db8:c18:1234::&lt;/prefix&gt;
      &lt;dns_server&gt;
       &lt;address type="ipv4"&gt;192.0.2.5&lt;/address&gt;
       &lt;address type="ipv4"&gt;192.0.2.4&lt;/address&gt;
       &lt;address type="ipv6"&gt;2001:db8::1&lt;/address&gt;
      &lt;/dns_server&gt;
     &lt;/router&gt;
    &lt;/client&gt;
   &lt;/tunnel&gt; CR LF
C: Content-length: 35 CR LF
   &lt;tunnel action="accept"&gt;&lt;/tunnel&gt; CR LF
        </artwork>
      </figure>
  </section>

  <section title="IPv4 over IPv6 Tunnel Request">
    <t>This is similar to the previous 'create' action, but with the
    tunnel type is set to 'v4v6'.
    
    </t>
    <figure anchor="SimpleTunnel" title="Simple Tunnel Request Made by a Client">
      <artwork>
        
          -- Successful TCP Connection --
          C:VERSION=1.0 CR LF
          S:CAPABILITY TUNNEL=V4V6 AUTH=DIGEST-MD5 AUTH=ANONYMOUS
            CR LF
          C:AUTHENTICATE ANONYMOUS CR LF
          S:OK Authentication successful CR LF
          C:Content-length: 228 CR LF
            &lt;tunnel action="create" type="v4v6"&gt;
               &lt;client&gt;
                   &lt;address type="ipv6"&gt;
                   2001:db8:0c18:ffff:0000:0000:0000:0001
                   &lt;/address&gt;
               &lt;/client&gt;
            &lt;/tunnel&gt; CR LF
            </artwork>
          </figure>
          <t>
If the allocation request is accepted, the broker will acknowledge the
allocation to the client by sending a 'tunnel' element with the
attribute 'action' set to 'info', 'type' set to 'v4v6' and the
'lifetime' attribute set to the period of validity or lease time of
the allocation. The 'tunnel' element contains 'server' and 'client'
elements.
          </t>
          <figure anchor="IPv4_over_IPv6" title="IPv4 over IPv6 Tunnel Response">
            <artwork>
              
          S: Content-length: 370 CR LF
             200 OK CR LF
             &lt;tunnel action="info" type="v4v6" lifetime="1440"&gt;
               &lt;server&gt;
                  &lt;address type="ipv4" length="30"&gt;
                  192.0.2.2
                  &lt;/address&gt;
                  &lt;address type="ipv6"&gt;
                  2001:db8:c18:ffff:0000:0000:0000:0002
                  &lt;/address&gt;
               &lt;/server&gt;
               &lt;client&gt;
                  &lt;address type="ipv4" length="30"&gt;
                  192.0.2.1
                  &lt;/address&gt;
                  &lt;address type="ipv6"&gt;
                  2001:db8:c18:ffff::0000:0000:0000:0001
                  &lt;/address&gt;
               &lt;/client&gt;
             &lt;/tunnel&gt; CR LF
            </artwork>
          </figure>
          <t>
            In DSTM <xref target="DSTM"/>
            terminology, the DSTM server is the TSP broker and the Tunnel Endpoint (TEP)
            is the tunnel server.
          </t>
        </section>
        <section title="NAT Traversal Tunnel Request">
          <t>  
When a client is capable of both IPv6 over IPv4 and IPv6 over UDP over
IPv4 encapsulation, it can request the broker, by using the "v6anyv4"
tunnel mode, to determine if it is behind a NAT and to send the
appropriate tunnel encapsulation mode as part of the response. The
client can also explicitly request an IPv6 over UDP over IPv4 tunnel
by specifying "v6udpv4" in its request.
          </t>
<t>
  In the following example, the client informs the broker that it
  requests to send keep-alives every 30 seconds. In its response, the
  broker accepted the client-suggested keep-alive interval, and the
  IPv6 destination address for the keep-alive packets is specified.

          <figure anchor="Tunnel_Request" title="Tunnel Request Using v6anyv4 Mode">
            <artwork>
              
  C:VERSION=2.0.0 CR LF
  S:CAPABILITY TUNNEL=V6V4 TUNNEL=V6UDPV4 AUTH=DIGEST-MD5 CR LF
  C:AUTHENTICATE ... CR LF
  S:200 Authentication successful CR LF
  C:Content-length: ... CR LF
    &lt;tunnel action="create" type="v6anyv4"&gt;
       &lt;client&gt;
           &lt;address type="ipv4"&gt;10.1.1.1&lt;/address&gt;
           &lt;keepalive interval="30"&gt;&lt;/keepalive&gt;
       &lt;/client&gt;
    &lt;/tunnel&gt; CR LF
  S: Content-length: ... CR LF
     200 OK CR LF
     &lt;tunnel action="info" type="v6udpv4" lifetime="1440"&gt;
       &lt;server&gt;
          &lt;address type="ipv4"&gt;192.0.2.114&lt;/address&gt;
          &lt;address type="ipv6"&gt;
          2001:db8:c18:ffff:0000:0000:0000:0002
          &lt;/address&gt;
       &lt;/server&gt;
       &lt;client&gt;
          &lt;address type="ipv4"&gt;10.1.1.1&lt;/address&gt;
          &lt;address type="ipv6"&gt;
          2001:db8:c18:ffff::0000:0000:0000:0003
          &lt;/address&gt;
          &lt;keepalive interval="30"&gt;
             &lt;address type="ipv6"&gt;
             2001:db8:c18:ffff:0000:0000:0000:0002
             &lt;/address&gt;
          &lt;/keepalive&gt;
       &lt;/client&gt;
     &lt;/tunnel&gt; CR LF
            </artwork>
          </figure>
</t>
        </section>
</section>

<section title="Applicability of TSP in Different Networks">
<t>
This section describes the applicability of TSP in different networks.
</t>
<section title="Provider Networks with Enterprise Customers">
<t>
In a provider network where IPv4 is dominant, a tunneled
infrastructure can be used to provide IPv6 services to the enterprise
customers, before a full IPv6 native infrastructure is built.  In
order to start deploying in a controlled manner and to give enterprise
customers a prefix, the TSP framework is used.  The TSP server can be
in the core, in the aggregation points or in the Points of Presence (PoPs) to offer the
service to the customers. IPv6 over IPv4 encapsulation can be used. If
the customers are behind an IPv4 NAT, then IPv6 over UDP-IPv4
encapsulation can be used.  TSP can be used in combination with other
techniques.
</t>
</section>
<section title="Provider Networks with Home/Small Office Customers">
<t>
In a provider network where IPv4 is dominant, a tunneled
infrastructure can be used to provide IPv6 services to the home/small
office customers, before a full IPv6 native infrastructure is built.
The small networks such as Home/Small offices have a non-upgradable
gateway with NAT. TSP with NAT traversal is used to offer IPv6
connectivity and a prefix to the internal network.
</t>
<t>
Automation of the prefix assignment and DNS delegation, done by TSP,
is a very important feature for a provider in order to substantially
decrease support costs. The provider can use the same Authentication, Authorization, and Accounting (AAA) database
that is used to authenticate the IPv4 broadband users.  Customers can
deploy home IPv6 networks without any intervention of the provider
support people.
</t>
<t>
With the NAT discovery function of TSP, providers can use the same TSP
infrastructure for both NAT and non-NAT parts of the network.
</t>
</section>
<section title="Enterprise Networks">
<t>
In an enterprise network where IPv4 is dominant, a tunneled
infrastructure can be used to provide IPv6 services to the IPv6
islands (hosts or networks) inside the enterprise, before a full IPv6
native infrastructure is built <xref target="RFC4057" />. TSP can be
used to give IPv6 connectivity, prefix, and routing for the
islands. This gives the enterprise a fully controlled deployment of
IPv6 while maintaining automation and permanence of the IPv6
assignments to the islands.
</t>
</section>
<section title="Wireless Networks">
<t>
In a wireless network where IPv4 is dominant, hosts and networks move
and change IPv4 address. TSP enables the automatic re-establishment of
the tunnel when the IPv4 address changes.
</t>
<t>
In a wireless network where IPv6 is dominant, hosts and networks
move. TSP enables the automatic re-establishment of the IPv4 over IPv6
tunnel.
</t>
</section>
<section title="Unmanaged Networks">
<t>
An unmanaged network is where no network manager or staff is available
to configure network devices <xref target="RFC3904" />.  TSP is
particularly useful in this context where automation of all necessary
information for the IPv6 connectivity is handled by TSP: tunnel
endpoint parameters, prefix assignment, DNS delegation, and routing.
</t>
<t>
An unmanaged network may (or may not) be behind a NAT. With the NAT
discovery function, TSP works automatically in both cases.
</t>
</section>
<section title="Mobile Hosts and Mobile Networks">
<t>
Mobile hosts are common and used. Laptops moving from wireless, wired
in an office, home, etc., are examples.  They often have IPv4 connectivity,
but not necessarily IPv6. The TSP framework enables the mobile hosts to
have IPv6 connectivity wherever they are, by having the TSP client
send updated information of the new environment to the TSP server,
when a change occurs. Together with NAT discovery and traversal, the
mobile host can always be IPv6 connected wherever it is.
</t>
<t>
Mobile here means only the change of IPv4 address. Mobile-IP mechanisms
and fast hand-off take care of additional constraints in mobile
environments.
</t>

<t>
Mobile networks share the applicability of the mobile hosts. Moreover,
in the TSP framework, they also keep their prefix assignment and can
control the routing. NAT discovery can also be used.
</t>
</section>
</section>
<section title="IANA Considerations" anchor="IANA">
<t>
A tunnel type registry has been created by IANA. The following strings
are defined in this document:

</t>
<t><list style="symbols">
<t>"v6v4" for IPv6 in IPv4 encapsulation (using IPv4 protocol 41)</t>
<t>"v6udpv4" for IPv6 in UDP in IPv4 encapsulation</t>
<t>"v6anyv4" for IPv6 in IPv4 or IPv6 in UDP in IPv4 encapsulation</t>
<t>"v4v6" for IPv4 in IPv6 encapsulation</t>
</list>
</t>
<t>
Registration of a new tunnel type can be obtained on a first come,
first served policy <xref target="RFC5226" />. A new registration
should provide a point of contact, the tunnel type string, and a brief
description on the applicability.
</t>
<t>IANA assigned 3653 as the TSP port number.</t>

</section>
<section title="Security Considerations">
<t>
Authentication of the TSP session uses the SASL <xref target="RFC4422"
/> framework, where the authentication mechanism is negotiated between
the client and the server. The framework uses the level of
authentication needed for securing the session, based on the policies.
</t>
<t>
Static tunnels are created when the TSP negotiation is
terminated. Static tunnels are not open gateways and exhibit less
security issues than automated tunnels. Static IPv6 in IPv4 tunnel
security considerations are described in <xref target="RFC4213" />.
</t>
<t>
  In order to help ensure that the traffic is traceable to its correct
  source network, a tunnel server implementation should allow ingress
  filtering on the user tunnel <xref target="RFC3704" />.
</t>

<t>
A customer A behind a NAT can use a large number of (private) IPv4
addresses and/or source ports and request multiple v6udpv4
tunnels. That would quickly saturate the tunnel server capacity. The
tunnel broker implementation should offer a way to throttle and limit
the number of tunnel established to the same IPv4 address.
</t>
</section>
<section title="Conclusion">
<t>
The Tunnel Setup Protocol (TSP) is applicable in many environments,
such as: providers, enterprises, wireless, unmanaged networks, mobile
hosts, and networks. TSP gives the two tunnel endpoints the ability
to negotiate tunnel parameters, as well as prefix assignment, DNS
delegation and routing in an authenticated session. It also provides an
IPv4 NAT discovery function by using the most effective encapsulation.
It also supports the IPv4 mobility of the nodes.
</t>
</section>
<section title="Acknowledgements">
  <t>
    This document is the merge of many previous documents about TSP. Octavio
    Medina has contributed to an earlier document (IPv4 in IPv6). Thanks
    to the following people for comments on improving and clarifying
    this document: Pekka Savola, Alan Ford, Jeroen Massar, and
    Jean-Francois Tremblay.</t>
</section>

</middle>
<back>
<references title='Normative References'>


<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>

<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.

</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='ftp://ftp.isi.edu/in-notes/rfc2119.txt' />
<format type='HTML' octets='17491' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>


<reference anchor='RFC4422'>

<front>
<title>Simple Authentication and Security Layer (SASL)</title>
<author initials='A.' surname='Melnikov' fullname='A. Melnikov'>
<organization /></author>
<author initials='K.' surname='Zeilenga' fullname='K. Zeilenga'>
<organization /></author>
<date year='2006' month='June' />
<abstract>
<t>The Simple Authentication and Security Layer (SASL) is a framework for providing authentication and data security services in connection-oriented protocols via replaceable mechanisms. It provides a structured interface between protocols and mechanisms. The resulting framework allows new protocols to reuse existing mechanisms and allows old protocols to make use of new mechanisms. The framework also provides a protocol for securing subsequent protocol exchanges within a data security layer.&lt;/t>&lt;t> This document describes how a SASL mechanism is structured, describes how protocols include support for SASL, and defines the protocol for carrying a data security layer over a connection. In addition, this document defines one SASL mechanism, the EXTERNAL mechanism.&lt;/t>&lt;t> This document obsoletes RFC 2222. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4422' />
<format type='TXT' octets='73206' target='ftp://ftp.isi.edu/in-notes/rfc4422.txt' />
</reference>

<reference anchor='RFC2831'>

<front>
<title>Using Digest Authentication as a SASL Mechanism</title>
<author initials='P.' surname='Leach' fullname='P. Leach'>
<organization /></author>
<author initials='C.' surname='Newman' fullname='C. Newman'>
<organization /></author>
<date year='2000' month='May' />
<abstract>
<t>This specification defines how HTTP Digest Authentication can be used as a SASL mechanism for any protocol that has a SASL (Simple Authentication and Security Layer) profile. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='2831' />

<format type='TXT' octets='58124' target='ftp://ftp.isi.edu/in-notes/rfc2831.txt' />
</reference>

<reference anchor='RFC4443'>

<front>
<title>Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification</title>
<author initials='A.' surname='Conta' fullname='A. Conta'>
<organization /></author>
<author initials='S.' surname='Deering' fullname='S. Deering'>
<organization /></author>
<author initials='M.' surname='Gupta' fullname='M. Gupta'>
<organization /></author>
<date year='2006' month='March' />
<abstract>
<t>This document describes the format of a set of control messages used in ICMPv6 (Internet Control Message Protocol).  ICMPv6 is the Internet Control Message Protocol for Internet Protocol version 6 (IPv6). [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4443' />
<format type='TXT' octets='48969' target='ftp://ftp.isi.edu/in-notes/rfc4443.txt' />
</reference>

<reference anchor='W3C.REC-xml-2004'>
  <front>
    <title>Extensible Markup Language (XML) 1.0 (Third Edition)</title>
    <author initials='F' surname='Yergeau' fullname='Francois Yergeau'>
      <organization />
    </author>
    <author initials='J' surname='Paoli' fullname='Jean Paoli'>
      <organization />
    </author>
    <author initials='C' surname='Sperberg-McQueen' fullname='C. M. Sperberg-McQueen'>
      <organization />
    </author>
    <author initials='T' surname='Bray' fullname='Tim Bray'>
      <organization />
    </author>
    <author initials='E' surname='Maler' fullname='Eve Maler'>
      <organization />
    </author>
    <date month='February' day='4' year='2004' />
  </front>
  <seriesInfo name='W3C REC' value='REC-xml-20040204' />
  <format type='HTML' target='http://www.w3.org/TR/2004/REC-xml-20040204' />
</reference>


<reference anchor='RFC4213'>

<front>
<title>Basic Transition Mechanisms for IPv6 Hosts and Routers</title>
<author initials='E.' surname='Nordmark' fullname='E. Nordmark'>
<organization /></author>
<author initials='R.' surname='Gilligan' fullname='R. Gilligan'>
<organization /></author>
<date year='2005' month='October' />
</front>

<seriesInfo name='RFC' value='4213' />
<format type='TXT' octets='58575' target='ftp://ftp.isi.edu/in-notes/rfc4213.txt' />
</reference>


<reference anchor='RFC2473'>

<front>
<title abbrev='Generic Packet Tunneling in IPv6'>Generic Packet Tunneling in IPv6 Specification</title>
<author initials='A.' surname='Conta' fullname='Alex Conta'>
<organization>Lucent Technologies Inc.</organization>
<address>
<postal>
<street>300 Baker Ave</street>
<city>Concord</city>
<region>MA</region>

<code>01742-2168</code>
<country>USA</country></postal>
<phone>+1 978 287 2842</phone>
<email>aconta@lucent.com</email></address></author>
<author initials='S.' surname='Deering' fullname='Stephen Deering'>
<organization>Cisco Systems</organization>
<address>
<postal>
<street>170 West Tasman Dr</street>
<city>San Jose</city>

<region>CA</region>
<code>95132-1706</code>
<country>USA</country></postal>
<phone>+1-408-527-8213</phone>
<email>deering@cisco.com</email></address></author>
<date year='1998' month='December' />
<area>Internet</area>
<keyword>encapsulate</keyword>
<keyword>internet protocol version 6</keyword>

<keyword>IPv6</keyword>
<keyword>tunnel</keyword>
<abstract>
<t>
   This document defines the model and generic mechanisms for IPv6
   encapsulation of Internet packets, such as IPv6 and IPv4.  The model
   and mechanisms can be applied to other protocol packets as well, such
   as AppleTalk, IPX, CLNP, or others.
</t></abstract></front>

<seriesInfo name='RFC' value='2473' />
<format type='TXT' octets='77956' target='ftp://ftp.isi.edu/in-notes/rfc2473.txt' />
<format type='HTML' octets='93015' target='http://xml.resource.org/public/rfc/html/rfc2473.html' />
<format type='XML' octets='84253' target='http://xml.resource.org/public/rfc/xml/rfc2473.xml' />
</reference>

</references>
<references title='Informative References'>


<reference anchor='RFC3704'>

<front>
<title>Ingress Filtering for Multihomed Networks</title>
<author initials='F.' surname='Baker' fullname='F. Baker'>
<organization /></author>
<author initials='P.' surname='Savola' fullname='P. Savola'>
<organization /></author>
<date year='2004' month='March' />
<abstract>
<t>BCP 38, RFC 2827, is designed to limit the impact of distributed denial of service attacks, by denying traffic with spoofed addresses access to the network, and to help ensure that traffic is traceable to its correct source network.  As a side effect of protecting the Internet against such attacks, the network implementing the solution also protects itself from this and other attacks, such as spoofed management access to networking equipment.  There are cases when this may create problems, e.g., with multihoming.  This document describes the current ingress filtering operational mechanisms, examines generic issues related to ingress filtering, and delves into the effects on multihoming in particular.  This memo updates RFC 2827.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='84' />

<seriesInfo name='RFC' value='3704' />
<format type='TXT' octets='35942' target='ftp://ftp.isi.edu/in-notes/rfc3704.txt' />
</reference>

<reference anchor='RFC5226'>

<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='T.' surname='Narten' fullname='T. Narten'>
<organization /></author>
<author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'>
<organization /></author>
<date year='2008' month='May' />
<abstract>
<t>Many protocols make use of identifiers consisting of constants and other well-known values. Even after a protocol has been defined and deployment has begun, new values may need to be assigned (e.g., for a new option type in DHCP, or a new encryption or authentication transform for IPsec). To ensure that such quantities have consistent values and interpretations across all implementations, their assignment must be administered by a central authority. For IETF protocols, that role is provided by the Internet Assigned Numbers Authority (IANA).&lt;/t>&lt;t> In order for IANA to manage a given namespace prudently, it needs guidelines describing the conditions under which new values can be assigned or when modifications to existing values can be made. If IANA is expected to play a role in the management of a namespace, IANA must be given clear and concise instructions describing that role. This document discusses issues that should be considered in formulating a policy for assigning values to a namespace and provides guidelines for authors on the specific text that must be included in documents that place demands on IANA.&lt;/t>&lt;t> This document obsoletes RFC 2434. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='26' />
<seriesInfo name='RFC' value='5226' />
<format type='TXT' octets='66160' target='ftp://ftp.isi.edu/in-notes/rfc5226.txt' />
</reference>


<reference anchor='RFC3964'>

<front>
<title>Security Considerations for 6to4</title>
<author initials='P.' surname='Savola' fullname='P. Savola'>
<organization /></author>
<author initials='C.' surname='Patel' fullname='C. Patel'>
<organization /></author>
<date year='2004' month='December' />
<abstract>
<t>The IPv6 interim mechanism 6to4 (RFC3056) uses automatic IPv6-over-IPv4 tunneling to interconnect IPv6 networks.  The architecture includes 6to4 routers and 6to4 relay routers, which accept and decapsulate IPv4 protocol-41 ("IPv6-in-IPv4") traffic from any node in the IPv4 internet.  This characteristic enables a number of security threats, mainly Denial of Service.  It also makes it easier for nodes to spoof IPv6 addresses.  This document discusses these issues in more detail and suggests enhancements to alleviate the problems.  This memo provides information for the Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='3964' />

<format type='TXT' octets='83360' target='ftp://ftp.isi.edu/in-notes/rfc3964.txt' />
</reference>

<reference anchor='RFC3053'>

<front>
<title>IPv6 Tunnel Broker</title>
<author initials='A.' surname='Durand' fullname='A. Durand'>
<organization /></author>
<author initials='P.' surname='Fasano' fullname='P. Fasano'>
<organization /></author>
<author initials='I.' surname='Guardini' fullname='I. Guardini'>
<organization /></author>
<author initials='D.' surname='Lento' fullname='D. Lento'>
<organization /></author>
<date year='2001' month='January' />
<abstract>

<t>The motivation for the development of the tunnel broker model is to help early IPv6 adopters to hook up to an existing IPv6 network (e.g., the 6bone) and to get stable, permanent IPv6 addresses and DNS names.  The concept of the tunnel broker was first presented at Orlando's IETF in December 1998.  Two implementations were demonstrated during the Grenoble IPng &amp;amp; NGtrans interim meeting in February 1999.  This memo provides information for the Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='3053' />
<format type='TXT' octets='27336' target='ftp://ftp.isi.edu/in-notes/rfc3053.txt' />
</reference>



<reference anchor='DSTM'>
<front>
<title>Dual Stack IPv6 Dominant Transition Mechanism</title>

<author initials='J' surname='Bound' fullname='Jim Bound'><organization /></author>
<author initials='L' surname='Toutain' fullname='Laurent Toutain'><organization /></author>
<author initials='JL' surname='Richier' fullname='Jean-Luc Richier'><organization /></author>

<date month='October' day='17' year='2005' />

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

<reference anchor='RFC4057'>

<front>
<title>IPv6 Enterprise Network Scenarios</title>
<author initials='J.' surname='Bound' fullname='J. Bound'>
<organization /></author>
<date year='2005' month='June' />
<abstract>
<t>This document describes the scenarios for IPv6 deployment within enterprise networks.  It defines a small set of basic enterprise scenarios and includes pertinent questions to allow enterprise administrators to further refine their deployment scenarios.  Enterprise deployment requirements are discussed in terms of coexistence with IPv4 nodes, networks and applications, and in terms of basic network infrastructure requirements for IPv6 deployment.  The scenarios and requirements described in this document will be the basis for further analysis to determine what coexistence techniques and mechanisms are needed for enterprise IPv6 deployment.  The results of that analysis will be published in a separate document.  This memo provides information for the Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='4057' />
<format type='TXT' octets='33454' target='ftp://ftp.isi.edu/in-notes/rfc4057.txt' />
</reference>


<reference anchor='RFC3904'>

<front>
<title>Evaluation of IPv6 Transition Mechanisms for Unmanaged Networks</title>
<author initials='C.' surname='Huitema' fullname='C. Huitema'>
<organization /></author>
<author initials='R.' surname='Austein' fullname='R. Austein'>
<organization /></author>
<author initials='S.' surname='Satapati' fullname='S. Satapati'>
<organization /></author>
<author initials='R.' surname='van der Pol' fullname='R. van der Pol'>
<organization /></author>
<date year='2004' month='September' />
<abstract>

<t>This document analyzes issues involved in the transition of "unmanaged networks" from IPv4 to IPv6.  Unmanaged networks typically correspond to home networks or small office networks.  A companion paper analyzes out the requirements for mechanisms needed in various transition scenarios of these networks to IPv6.  Starting from this analysis, we evaluate the suitability of mechanisms that have already been specified, proposed, or deployed.  This memo provides information for the Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='3904' />
<format type='TXT' octets='46844' target='ftp://ftp.isi.edu/in-notes/rfc3904.txt' />
</reference>


<reference anchor="UNP">
<front>
<title>Unix Network Programming, 3rd edition</title>
<author initials="R." surname="Stevens" fullname="W. Richard Stevens">
<organization/>
</author>
<author initials="B." surname="Fenner" fullname="Bill Fenner">
<organization/>
</author>
<author initials="A." surname="Rudoff" fullname="Andrew M. Rudoff">
<organization/>
</author>
<date year="2004"/>
</front>
<seriesInfo name="Addison Wesley" value="ISBN 0-13-141155-1"/>
</reference>
<reference anchor="FJ93">
  <front>
    <title>The Synchronization of Periodic Routing Messages</title>
    <author initials="S." surname="Floyd" fullname="Sally Floyd">
      <organization>Lawrence Berkeley Laboratory</organization>
    </author>
    <author initials="V." surname="Jacobson" fullname="Van Jacobson">
      <organization>Lawrence Berkeley Laboratory</organization>
    </author>
    <date year="1993" month="September"/>
  </front>
  <seriesInfo name="Proceedings of ACM" value="SIGCOMM"/>
</reference>

</references>

<section title="The TSP DTD" anchor="DTD_section">
<figure anchor="DTD" title="TSP DTD">
<artwork>
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE tunnel  [
&lt;!ELEMENT tunnel (server?,client?,broker?)&gt;
  &lt;!ATTLIST tunnel action 
               (create|delete|info|accept|reject) #REQUIRED &gt;
  &lt;!ATTLIST tunnel type 
               (v6v4|v4v6|v6anyv4|v6udpv4) #REQUIRED &gt;
  &lt;!ATTLIST tunnel lifetime CDATA "1440"    &gt;

&lt;!ELEMENT server        (address+,router?)&gt;

&lt;!ELEMENT client        (address+,router?)&gt;

&lt;!ELEMENT broker        (address+)&gt;

&lt;!ELEMENT router        (prefix?,dns_server?)&gt;

&lt;!ELEMENT dns_server    (address+)&gt;

&lt;!ELEMENT prefix        (#PCDATA)&gt;
  &lt;!ATTLIST prefix length CDATA #REQUIRED&gt;

&lt;!ELEMENT address       (#PCDATA)&gt;
  &lt;!ATTLIST address type (ipv4|ipv6|dn) #REQUIRED&gt;
  &lt;!ATTLIST address length CDATA ""&gt;

&lt;!ELEMENT keepalive (address?)&gt;
  &lt;!ATTLIST keepalive interval CDATA #REQUIRED&gt;
]&gt;
</artwork>
</figure>
</section>

<section title="Error Codes">

<t>
Error codes are sent as a numeric value followed by a text message
describing the code, similar to SMTP. The codes are sent from the
broker to the client. The currently defined error codes are shown
below. Upon receiving an error, the client will display the
appropriate message to the user.
</t>

<t>
New error messages may be defined in the future. For interoperability
purpose, the error code range to use should be from 300 to 599.
</t>

<t>
The reply code 200 is used to inform the client that an action
successfully completed. For example, this reply code is used in
response to an authentication request and a tunnel creation request.
</t>
<t>
  The server may redirect the client to another broker. The details on
  how these brokers are known or discovered is beyond the scope of
  this document. When a list of tunnel brokers follows the error code
  as a referral service, then 1000 is added to the error code.
</t>
<t>
The predefined values are:
</t>
<t>
<list style="hanging" hangIndent="4">
  <t hangText="200 Success:">
  Successful operation.</t>
<t hangText="300 Authentication failed:">
     Invalid userid, password, or authentication mechanism.</t>
<t hangText="301 No more tunnels available:">
     The server has reached its capacity limit.</t>
<t hangText="302 Unsupported client version:">
     The client version is not supported by the server.</t>
<t hangText="303 Unsupported tunnel type:">
     The server does not provide the requested tunnel type.</t>
<t hangText="310 Server side error:">
  Undefined server error.
</t>
<t hangText="500 Invalid request format or specified length:">
  The received request has invalid syntax or is truncated.
</t>
<t hangText="501 Invalid IPv4 address:">
  The IPv4 address specified by the client is invalid.
</t>
<t hangText="502 Invalid IPv6 address:">
  The IPv6 address specified by the client is invalid.
</t>
<t hangText="506 IPv4 address already used for existing tunnel:">
An IPv6-over-IPv4 tunnel already exists using the same IPv4 address
endpoints.
</t>
<t hangText="507 Requested prefix length cannot be assigned:">
The requested prefix length cannot be allocated on the server.
</t>
<t hangText="521 Request already in progress:">
The client tunnel request is being processed by the server. Temporary
error.
</t>
<t hangText="530 Server too busy:">
Request cannot be processed, insufficient resources. Temporary error.
</t>

</list>
</t>
</section>

</back>
</rfc>
