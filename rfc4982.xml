<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes" ?>
<?rfc compact="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc subcompact="no"?>
<rfc number="4982" updates="3972" category="std">
<front>
<title abbrev="Multiple Hash Support in CGAs">
Support for Multiple Hash Algorithms in Cryptographically Generated Addresses (CGAs)
</title>
<author initials="M." surname="Bagnulo" fullname="Marcelo Bagnulo">
<organization abbrev="UC3M">
Universidad Carlos III de Madrid
</organization>
<address>
<postal>
<street>Av. Universidad 30</street>
<city>Leganes</city>
<region>Madrid</region>
<code>28911</code>
<country>SPAIN</country>					
</postal>
<phone>34 91 6249500</phone>
<email>marcelo@it.uc3m.es</email>
<uri>http://www.it.uc3m.es</uri>
</address>
</author>
 
<author initials="J." surname="Arkko" fullname="Jari Arkko">
<organization abbrev="Ericsson">
Ericsson
</organization>
<address>
<postal>
<city>Jorvas</city>
<code>02420</code>
<country>Finland</country>					
</postal>
<email>jari.arkko@ericsson.com</email>
</address>
</author>

<date month="July" year="2007"/>

<!-- [rfced] Please insert any keywords (beyond those that appear in the title) for use on http://www.rfc-editor.org/search.html. -->
<keyword>example</keyword>

<abstract>
<t> 
This document analyzes the implications of recent attacks on commonly 
used hash functions on Cryptographically Generated Addresses (CGAs) 
and updates the CGA specification to support multiple hash algorithms.
</t>
</abstract>
</front>

<middle>
<section title="Introduction">
<t>

Recent attacks to currently used hash functions have motivated a 
considerable amount of concern in the Internet community. The 
recommended approach <xref target="RFC4270" /> <xref target="bellovin" /> to deal with this issue 
is first to analyze the impact of these attacks on the different 
Internet protocols that use hash functions and second to make sure 
that the different Internet protocols that use hash functions are 
capable of migrating to an alternative (more secure) hash function 
without a major disruption in the Internet operation.
</t>
<t>
This document performs such analysis for the Cryptographically 
Generated Addresses (CGAs) defined in <xref target="cga" />. The first 
conclusion of the analysis is that the security of the protocols 
using CGAs is not affected by the recently available attacks 
against hash functions. The second conclusion of the analysis is 
that the hash function used is hard coded in the CGA specification. 
This document updates the CGA specification <xref target="cga" /> to enable the 
support of alternative hash functions. In order to do so, this 
document creates a new registry managed by IANA to register the 
different hash algorithms used in CGAs.
</t>

</section>

<section title="Terminology">
<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119  <xref target="RFC2119" />.
</t>
</section>

<section title="Impact of Collision Attacks in CGAs">
<t>
Recent advances in cryptography have resulted in simplified 
attacks against the collision-free property of certain commonly 
used hash functions <xref target="RFC4270" /> <xref target="bellovin" />, including SHA-1 that 
is the hash function used by CGAs <xref target="cga" />. The result is that it 
is possible to obtain two messages, M1 and M2, that have the same 
hash value with much less than 2^(L/2) attempts. We will next 
analyze the impact of such attacks in the currently proposed 
usages of CGAs.
</t>
<t>
As we understand it, the attacks against the collision-free 
property of a hash function mostly challenge the application 
of such hash functions, for the provision of non-repudiation 
capabilities. This is because an attacker would be capable 
to create two different messages that result in the same hash 
value and it can then present any of the messages 
interchangeably (for example after one of them has been signed 
by the other party involved in the transaction). However, it 
must be noted that both messages must be generated by the same 
party.
</t>
<t>
As far as we understand, current usages of CGAs does not 
include the provision of non-repudiation capabilities, so 
attacks against the collision-free property of the hash 
function do not enable any useful attack against CGA-based 
protocols. 
</t>
<t>
Current usages of the CGAs are basically oriented to prove 
the ownership of a CGA and then bind it to alternative 
addresses that can be used to reach the original CGA. 
This type of application of the CGA include:
<list style='symbols'>
  <t>The application of CGAs to protect the shim6 protocol <xref target="7" />. 
  In this case, CGAs are used as identifiers for the established 
  communications. CGA features are used to prove that the owner of 
  the identifier is the one that is providing the alternative 
  addresses that can be used to reach the initial identifier. 
  This is achieved by signing the list of alternative addresses 
  available in the multihomed host with the private key of the CGA.</t>
  <t>The application of CGAs to secure the IPv6 mobility support 
  protocol <xref target="RFC3775" /> as proposed in <xref target="9"/>. In this case, the CGAs 
  are used as Home Addresses and they are used to prove that the 
  owner of the Home Address is the one creating the binding with 
  the new Care-off Address. Similarly to the previous case, this 
  is achieved by signing the Binding Update message carrying the 
  Care-off Address with the private key of the CGA.</t>
  <t>The application of CGA to Secure Neighbour Discovery <xref target="RFC3971" />. 
  In this case, the CGA features are used to prove the address 
  ownership, so that it is possible to verify that the owner of 
  the IP address is the one that is providing the layer 2 address 
  information. This is achieved by signing the layer 2 address 
  information with the private key of the CGA.</t>
</list>
</t>
<t>Essentially, all the current applications of CGAs rely on CGAs 
to protect a communication between two peers from third party 
attacks and not to provide protection from the peer itself. 
Attacks against the collision-free property of the hash functions 
suppose that one of the parties is generating two messages with 
the same hash value in order to launch an attack against its 
communicating peer. Since CGAs are not currently used to providing 
this type of protection, it is then natural that no additional 
attacks are enabled by a weaker collision resistance of the 
hash function. 
</t>
</section>

<section title="Options for Multiple Hash Algorithm Support in CGAs">
<t>CGAs, as currently defined in <xref target="cga" />, are intrinsically bound 
to the SHA-1 hash algorithm and no other hash function is supported.
</t>
<t>
Even though the attacks against the collision-free property of 
the hash functions do not result in new vulnerabilities in 
the current applications of CGAs, it seems wise to enable multiple 
hash function support in CGAs. This is mainly for two reasons: 
first, potential future applications of the CGA technology may be 
susceptible to attacks against the collision-free property of 
SHA-1. Supporting alternative hash functions would
allow applications that have stricter requirements on the collision-free 
property to use CGAs. Second, one lesson learned from the recent  
attacks against hash functions is that it is possible that one 
day we need to start using alternative hash functions because of 
successful attacks against other properties of the commonly used 
hash functions. Therefore, it seems wise to modify protocols 
in general and the CGAs in particular to support this transition 
to alternative hash functions as easy as possible.
</t>

<section title="Where to Encode the Hash Function?">
<t>
The next question we need to answer is where to encode the 
hash function that is being used. There are several options that can be considered:
</t>
<t>
One option would be to include the hash function used as an input 
to the hash function. This basically means to create an extension 
to the CGA Parameter Data Structure, as defined in <xref target="RFC4581" />, that 
codifies the hash function used. The problem is that this approach 
is vulnerable to bidding down attacks or downgrading attacks as 
defined in <xref target="bellovin" />. This means that even if a strong hash function is used, an attacker could
find a CGA Parameter Data Structure that uses a weaker function but results
in an equal hash value. This happens when the original hash function H1 and
CGA Parameters Data Structure indicating H1 result in value X,
and another hash function H2 and CGA Parameters Data Structure
indicating H2 also result in the same value X. 
</t>
<t>
In other words, the downgrading attack would work as follows: 
suppose that Alice generates a CGA CGA_A using the strong hash 
function HashStrong and using a CGA Parameter Data Structure 
CGA_PDS_A. The selected hash function HashStrong is encoded as 
an extension field in the CGA_PDS_A. Suppose that by using a brute
force attack, an attacker X finds an alternative CGA 
Parameter Data Structure CGA_PDS_X whose hash value, by using a 
weaker hash function, is CGA_A. At this point, the 
attacker can pretend to be the owner of CGA_A and the stronger hash 
function has not provided additional protection.
</t>
<t>
The conclusion from the previous analysis is that the hash function 
used in the CGA generation must be encoded in the address itself. 
Since we want to support several hash functions, we will likely 
need at least 2 or 3 bits for this.
</t>
<t>
One option would be to use more bits from the hash bits of the 
interface identifier. However, the problem with this approach is that the 
resulting CGA is weaker because less hash information is encoded 
in the address. In addition, since those bits are currently used 
as hash bits, it is impossible to make this approach backward 
compatible with existent implementations.</t>

<t> Another option would 
be to use the "u" and the "g" bits to encode this information, 
but this is probably not such a good idea since those bits 
have been honoured so far in all interface identifier generation 
mechanisms, which allow them to be used for the original purpose 
(for instance we can still create a global registry for unique 
interface identifiers). Finally, another option is to encode the 
hash value used in the Sec bits. The Sec bits are used to 
artificially introduce additional difficulty in the CGA 
generation process in order to provide additional protection 
against brute force attacks. The Sec bits have been designed 
in a way that the lifetime of CGAs are extended, when it is 
feasible to attack 59-bits long hash values. However, this 
is not the case today, so in general CGA will have a Sec 
value of 000. The proposal is to encode in the Sec bits, 
not only information about brute force attack protection 
but also to encode the hash function used to generate the 
hash. So for instance, the Sec value 000 would mean that the 
hash function used is SHA-1 and the 0 bits of hash2 (as 
defined in RFC 3972) must be 0. Sec value of 001 could be 
that the hash function used is SHA-1 and the 16 bits of 
hash2 (as defined in RFC 3972) must be zero. However, the 
other values of Sec could mean that an alternative hash 
function needs to be used and that a certain amount of bits 
of hash2 must be zero. The proposal is not to define any 
concrete hash function to be used for other Sec values, since 
it is not yet clear that we need to do so nor is it clear 
which hash function should be selected.  
</t>
<t>
Note that since there are only 8 Sec values, it may be necessary
to reuse Sec values when we run out of unused Sec values.
The scenario where such an approach makes sense is where there are some Sec 
values that are no longer being used because the resulting security has become 
weak. In this case, where the usage of the Sec value has long 
been abandoned, it would be possible to reassign the Sec values. However, this 
must be a last resource option, since it may affect interoperability. This is because two 
implementations using different meanings of a given Sec value would not be able 
to interoperate properly (i.e., if an old implementation receives a CGA  
generated with the new meaning of the Sec value, it will fail and the same for
a new implementation receiving a CGA generated with the old meaning of the Sec 
value). In case the approach of reassigning a Sec value 
is followed, a long time is required between the deprecation of the old 
value and the reassignment in order to prevent misinterpretation of the 
value by old implementations.
</t>

<t>
An erroneous interpretation of a reused Sec value, 
both on the CGA owner's side and the CGA verifier's side, would
have the following result, CGA verification would fail in the worst case and both
nodes would have to revert to unprotected IPv6 addresses.  This can
happen only with obsolete CGA parameter sets, which would be considered
insecure anyway. In any case, an implementation must not
simultaneously support two different meanings of a Sec value. 
</t>

</section>
</section>

<section title="CGA Generation Procedure">
<t>
The SEC registry defined in the IANA considerations section of this document 
contains entries for the different Sec values. Each of these entries points to
an RFC that defines the CGA generation procedure that MUST be used when 
generating CGAs with the associated Sec value.
</t>
<t>It should be noted that the CGA generation procedure may be changed by the
new procedure not only in terms of the hash function used but also in other 
aspects, e.g., longer Modifier values may be required if the number of 0s 
required in hash2 exceed the currently defined bound of 112 bits. 
The new procedure (which
potentially involves a longer Modifier value) would be described in the
RFC pointed to by the corresponding Sec registry entry.
</t>
<t>
In addition, the RFC that defines the CGA generation procedure for a Sec value 
MUST explicitly define the minimum key length acceptable for CGAs with that Sec value. 
This is to provide a coherent protection both in the hash and the public key
techniques.
</t>

</section>
<section title="IANA Considerations">
<t>
This document defines a new registry entitled "CGA SEC" 
for the Sec field defined in RFC 3972 <xref target="cga" /> that has been created and is maintained by IANA. The values in this name space are 3-bit unsigned integers.
</t>
<t>	
	Initial values for the CGA Extension Type field are
        given below; future assignments are to be made through 
	Standards Action <xref target="RFC2434" />.
	Assignments consist of a name, the value, and the RFC number 
	where the CGA generation procedure is defined.
</t>
<t>
The following initial values are assigned in this document:

<figure>
        <artwork>
       Name        | Value |  RFCs
-------------------+-------+------------
SHA-1_0hash2bits   |   000 | 3972, 4982
SHA-1_16hash2bits  |   001 | 3972, 4982
SHA-1_32hash2bits  |   010 | 3972, 4982
 </artwork>
    </figure>
</t>   
</section>

<section title="Security Considerations">
<t>
This document is about security issues and, in particular,
about protection against potential attacks against hash functions.
</t>
</section>
<section title="Acknowledgements">

<t> Russ Housley, James Kempf, Christian Vogt, Pekka Nikander, and Henrik Levkowetz reviewed and provided comments about 
this document. </t>

<t>Marcelo Bagnulo worked on this document while visiting Ericsson Research 
Laboratory Nomadiclab.
</t>
</section>




</middle>

<back>

<references title='Normative References'>

<reference anchor="RFC2119">

	<front>

	<title abbrev="RFC Key Words">
Key words for use in RFCs to Indicate Requirement Levels
</title>

	<author initials="S." surname="Bradner" fullname="Scott Bradner">
<organization>Harvard University</organization>

	<address>

	<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street>
</postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email>
</address>
</author>
<date year="1997" month="March"/>
<area>General</area>
<keyword>keyword</keyword>

	<abstract>

	<t>

   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:


	<list>

	<t>

      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.
</t>
</list>
</t>

	<t>

   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t>
</abstract>
</front>
<seriesInfo name="BCP" value="14"/>
<seriesInfo name="RFC" value="2119"/>
<format type="TXT" octets="4723" target="ftp://ftp.isi.edu/in-notes/rfc2119.txt"/>
<format type="HTML" octets="16553" target="http://xml.resource.org/public/rfc/html/rfc2119.html"/>
<format type="XML" octets="5703" target="http://xml.resource.org/public/rfc/xml/rfc2119.xml"/>
</reference>


<reference anchor='cga'>
<front>
<title>Cryptographically Generated Addresses (CGA)</title>

<author initials='T' surname='Aura' fullname='Tuomas Aura'>
    <organization />
</author>

<date month='March' year='2005' />

<abstract><t>This document describes a method for binding a public signature key to an IPv6 address in the Secure Neighbor Discovery (SEND) protocol. Cryptographically Generated Addresses (CGA) are IPv6 addresses where the interface identifier is generated by computing a cryptographic one-way hash function from a public key and auxiliary parameters. The binding between the public key and the address can be verified by re-computing the hash value and by comparing the hash with the interface identifier. Messages sent from an IPv6 address can be protected by attaching the public key and auxiliary parameters and by signing the message with the corresponding private key. The protection works without a certification authority or other security infrastructure.</t></abstract>

</front>

<seriesInfo name='RFC' value='3972' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/RFC3972.txt' />
</reference>


<reference anchor="RFC4581">

	<front>

	<title>
Cryptographically Generated Addresses (CGA) Extension Field Format
</title>

	<author initials="M." surname="Bagnulo" fullname="M. Bagnulo">
<organization/>
</author>

	<author initials="J." surname="Arkko" fullname="J. Arkko">
<organization/>
</author>
<date year="2006" month="October"/>

	<abstract>

	<t>
<p>This document defines a Type-Length-Value format for Cryptographically Generated Address (CGA) Extensions. This document updates RFC 3972. [STANDARDS TRACK]</p>
</t>
</abstract>
</front>
<seriesInfo name="RFC" value="4581"/>
<format type="TXT" octets="7636" target="ftp://ftp.isi.edu/in-notes/rfc4581.txt"/>
</reference>


<reference anchor="RFC3971">

	<front>
<title>SEcure Neighbor Discovery (SEND)</title>

	<author initials="J." surname="Arkko" fullname="J. Arkko">
<organization/>
</author>

	<author initials="J." surname="Kempf" fullname="J. Kempf">
<organization/>
</author>

	<author initials="B." surname="Zill" fullname="B. Zill">
<organization/>
</author>

	<author initials="P." surname="Nikander" fullname="P. Nikander">
<organization/>
</author>
<date year="2005" month="March"/>
</front>
<seriesInfo name="RFC" value="3971"/>
<format type="TXT" octets="123372" target="ftp://ftp.isi.edu/in-notes/rfc3971.txt"/>
</reference>



</references>



<references title='Informative References'>

<reference anchor='RFC2434'>

<front>
<title abbrev='Guidelines for IANA Considerations'>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='T.' surname='Narten' fullname='Thomas Narten'>
<organization>IBM Corporation</organization>
<address>
<postal>
<street>3039 Cornwallis Ave.</street>
<street>PO Box 12195 - BRQA/502</street>
<street>Research Triangle Park</street>
<street>NC 27709-2195</street></postal>
<phone>919-254-7798</phone>
<email>narten@raleigh.ibm.com</email></address></author>
<author initials='H.T.' surname='Alvestrand' fullname='Harald Tveit Alvestrand'>
<organization>Maxware</organization>
<address>
<postal>
<street>Pirsenteret</street>
<street>N-7005 Trondheim</street>
<country>Norway</country></postal>
<phone>+47 73 54 57 97</phone>
<email>Harald@Alvestrand.no</email></address></author>
<date month='October' year='1998' />
<area>General</area>
<keyword>Internet Assigned Numbers Authority</keyword>
<keyword>IANA</keyword>
<abstract>
<t>
   Many protocols make use of identifiers consisting of constants and
   other well-known values. Even after a protocol has been defined and
   deployment has begun, new values may need to be assigned (e.g., for a
   new option type in DHCP, or a new encryption or authentication
   algorithm for IPSec).  To insure that such quantities have consistent
   values and interpretations in different implementations, their
   assignment must be administered by a central authority. For IETF
   protocols, that role is provided by the Internet Assigned Numbers
   Authority (IANA).
</t>
<t>
   In order for the IANA to manage a given name space prudently, it
   needs guidelines describing the conditions under which new values can
   be assigned. If the IANA is expected to play a role in the management
   of a name space, the IANA must be given clear and concise
   instructions describing that role.  This document discusses issues
   that should be considered in formulating a policy for assigning
   values to a name space and provides guidelines to document authors on
   the specific text that must be included in documents that place
   demands on the IANA.
</t></abstract></front>

<seriesInfo name='BCP' value='26' />
<seriesInfo name='RFC' value='2434' />
<format type='TXT' octets='25092' target='ftp://ftp.isi.edu/in-notes/rfc2434.txt' />
<format type='HTML' octets='39811' target='http://xml.resource.org/public/rfc/html/rfc2434.html' />
<format type='XML' octets='26924' target='http://xml.resource.org/public/rfc/xml/rfc2434.xml' />
</reference>


<reference anchor="RFC4270">

	<front>

	<title>
Attacks on Cryptographic Hashes in Internet Protocols
</title>

	<author initials="P." surname="Hoffman" fullname="P. Hoffman">
<organization/>
</author>

	<author initials="B." surname="Schneier" fullname="B. Schneier">
<organization/>
</author>
<date year="2005" month="November"/>
</front>
<seriesInfo name="RFC" value="4270"/>
<format type="TXT" octets="26641" target="ftp://ftp.isi.edu/in-notes/rfc4270.txt"/>
</reference>

<reference anchor="7">

	<front>
<title>Multihoming L3 Shim Approach</title>

	<author initials="E" surname="Nordmark" fullname="Erik Nordmark">
<organization/>
</author>

	<author initials="M" surname="Bagnulo" fullname="Marcelo Bagnulo">
<organization/>
</author>
<date month="July" year="2005"/>

	<abstract>

	<t>
This document specifies a particular approach to IPv6 multihoming. The approach is based on using a multihoming shim placed between the IP endpoint sublayer and the IP routing sublayer, and, at least initially, using routable IP locators as the identifiers visible above the shim layer. The approach does not introduce a "stack name" type of identifier, instead it ensures that all upper layer protocols can operate unmodified in a multihomed setting while still seeing a stable IPv6 address. This document does not specify the mechanism for authenticating and authorizing the "rehoming" - this is specified in the HBA document. Nor does it specify the messages used to establish multihoming state. The document does not even specify the packet format used for the data packets. Instead it discusses the issue of receive side demultiplexing and the different tradeoffs. The resolution of this issue will affect the packet format for the data packets.
</t>
</abstract>
</front>
<seriesInfo name="Work in" value="Progress"/>
<format type="TXT" target="http://www.ietf.org/internet-drafts/draft-ietf-shim6-l3shim-00.txt"/>
</reference>

<reference anchor="RFC3775">

	<front>
<title>Mobility Support in IPv6</title>

	<author initials="D." surname="Johnson" fullname="D. Johnson">
<organization/>
</author>

	<author initials="C." surname="Perkins" fullname="C. Perkins">
<organization/>
</author>

	<author initials="J." surname="Arkko" fullname="J. Arkko">
<organization/>
</author>
<date year="2004" month="June"/>
</front>
<seriesInfo name="RFC" value="3775"/>
<format type="TXT" octets="393514" target="ftp://ftp.isi.edu/in-notes/rfc3775.txt"/>
</reference>


<reference anchor="9">

	<front>

	<title>
Applying Cryptographically Generated Addresses and Credit-Based Authorization to Mobile IPv6
</title>

	<author initials="J" surname="Arkko" fullname="Jari Arkko">
<organization/>
</author>
<date month="June" year="2006"/>

	<abstract>

	<t>
This memo suggests a new and enhanced route optimization security mechanism for Mobile IPv6. The primary motivation for this new mechanism is the reduction of signaling load and handoff delay. The performance improvement achieved is elimination of all signaling while not moving, and most of the per-movement signaling can be done when payload traffic flow has already been moved.
</t>
</abstract>
</front>
<seriesInfo name="Work in" value="Progress"/>
<format type="TXT" target="http://www.ietf.org/internet-drafts/draft-arkko-mipshop-cga-cba-03.txt"/>
</reference>


<!--Bellovin, S. and E. Rescorla, "Deploying a New Hash Algorithm", NDSS
'06, February 2006. -->

<reference anchor='bellovin'>

<front>
<title>Deploying a New Hash Algorithm</title>
<author initials='S.' surname='Bellovin' fullname='S. Bellovin'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>


<date year='2006' month='February' /></front>
<seriesInfo name="NDSS" value="'06"/>

<format type='' octets='' target='' />
</reference>
</references>

</back>
</rfc>


