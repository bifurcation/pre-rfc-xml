<?xml version="1.0" encoding="US-ASCII"?>
	 
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY rfc2119 PUBLIC ''
       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc1034 PUBLIC ''
       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1034.xml">
<!ENTITY rfc1035 PUBLIC ''
       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1035.xml">
<!ENTITY rfc3490 PUBLIC ''
       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3490.xml">
<!ENTITY rfc3491 PUBLIC ''
       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3491.xml">
<!ENTITY rfc3492 PUBLIC ''
       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3492.xml">
<!ENTITY rfc3454 PUBLIC ''
       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3454.xml">
<!ENTITY rfc3743 PUBLIC ''
       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3743.xml">
<!ENTITY rfc4290 PUBLIC ''
       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4290.xml">
<!ENTITY rfc4690 PUBLIC ''
       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4690.xml">
<!ENTITY rfc2782 PUBLIC ''
       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2782.xml">
<!ENTITY rfc2136 PUBLIC ''
       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2136.xml">
<!ENTITY rfc3986 PUBLIC ''
       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY rfc3987 PUBLIC ''
       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3987.xml">
<!ENTITY rfc0810 PUBLIC ''
       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0810.xml">
<!ENTITY rfc4952 PUBLIC ''
       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4952.xml">
<!ENTITY rfc2671 PUBLIC ''
       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2671.xml">

]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>


<?rfc strict="no" ?>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>  
<?rfc rfcedstyle="yes" ?>
<?rfc subcompact="no" ?>
<?rfc comments='no' ?>
<?rfc inline='yes' ?>  
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc editing="no" ?>


<rfc number="5891" ipr="pre5378Trust200902"
     	 obsoletes="3490, 3491" updates="3492" category="std">

  <!-- ***** FRONT MATTER ***** -->

  <front>
	<title abbrev="IDNA2008 Protocol">
	   Internationalized Domain Names in Applications (IDNA)
	   Protocol
	</title>

    <author fullname="John C Klensin" initials="J.C."
			 surname="Klensin">
	     <!--  role="editor" still doesn't work with -12 -->
	   
      <organization/>
      <address>
        <postal>
          <street>1770 Massachusetts Ave, Ste 322</street>
          <city>Cambridge</city> <region>MA</region>
          <code>02140</code>
          <country>USA</country>
        </postal>
        <phone>+1 617 245 1457</phone>
        <email>john+ietf@jck.com</email>
      </address>
	  </author>
  
    <date month="July" year="2010" />
		<keyword>idn</keyword>
    <keyword>ASCII</keyword>
	<keyword>characters</keyword>
    <keyword>domain name</keyword>
    <keyword>Internationalization</keyword>

<!-- [rfced] Please note that after you have approved the document,
post-xml2rfc changes will be made to update the header and
boilerplate as described in RFC 5741.
-->

    <abstract>
	   <t>This document is the revised protocol definition for Internationalized Domain Names (IDNs).  The
		rationale for changes, the relationship to the older
		specification, and important terminology are provided in other
		documents.  This document specifies the protocol mechanism, called
		Internationalized Domain Names in Applications (IDNA), for
		registering and looking up IDNs in a way that does not require
		changes to the DNS itself.  IDNA is only meant for processing domain
		names, not free text.</t>
	</abstract>
</front>
<middle>
   <section title="Introduction">
	  <t>This document supplies the protocol definition for
		 Internationalized 
		  Domain Names (IDNs).  Essential definitions and terminology for
		  understanding this document and a road map of the collection
		  of documents that make up IDNA2008 appear
		  in the Definitions document <xref target="RFC5890"></xref>.
		  <xref target="MajorChange"/> discusses the relationship
		  between this 
		  specification and the earlier version of IDNA (referred to
		  here as "IDNA2003").  The rationale for these
		  changes, along with considerable explanatory material and
		  advice to zone administrators who support IDNs, is provided
		  in the Rationale document
		  <xref target="RFC5894"></xref>.</t>
            <!-- [JcK] comma before the xref removed -- didn't belong
                    there -->

	  <t> IDNA works by allowing applications to use certain
		 <xref target="ASCII">ASCII</xref>
		 string labels (beginning with a special prefix) to represent
		 non-ASCII name labels.
		 Lower-layer protocols need not be aware of this; therefore,
		IDNA does not change any infrastructure.  In
		particular, IDNA does not depend on any changes to DNS servers,
		resolvers, or DNS protocol elements, because the ASCII name service
		provided by the existing DNS can be used for IDNA.</t>

   <t> IDNA applies only to a specific subset of DNS labels.  The base DNS
	  standards <xref target="RFC1034"/> <xref target="RFC1035"/>
	  and their various updates specify how to combine labels into
	  fully-qualified domain names and parse labels out of those
	  names.</t>

   <t> This document describes two separate protocols, one for IDN
	  registration (<xref target="Registration"/>) and one for 
	  IDN lookup (<xref target="Lookup"/>).  These two protocols
	  share some terminology, reference data, and operations.</t>
   
	   
</section>

<section title="Terminology"  anchor="terminology">>
   <t> Terminology used as part of the definition of IDNA appears
	  in a separate Definitions document <xref target="RFC5890"></xref>.
	  It is worth noting that some
	  of this terminology overlaps with, and is consistent with, that
	  used in Unicode or other character set standards and
	  the DNS.  Readers of this document are assumed to be familiar with 
	  the associated Definitions document mentioned above and with the DNS-specific
	  terminology in <xref target="RFC1034">RFC 1034</xref>. </t>
      <!-- [JcK] supplying a citation for the same term twice in the
       same paragraph just doesn't make editorial sense -->

   <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in
      this document are to be interpreted as described in 
      <xref target="RFC2119">BCP 14, RFC 2119</xref>.</t>
</section>

   <section title="Requirements and Applicability">
	  <section title="Requirements" anchor="Requirements">
		 <t>IDNA makes the following requirements:
			<list style="numbers">

          <t>Whenever a domain name is put into an an IDNA-unaware domain
<!-- [rfced] From email regarding RFC 5894:
<obscenity/> (not directed at you).  Yes, let's get rid of
"IDN-unaware".  "IDNA-unaware" feels awkward to me.  If it does
to you too, it might be worthwhile rewriting the relevant
sentences to say, e.g., "not IDNA-aware".   But I consider that
a stylistic matter and will leave it to your discretion.

Please note that we have changed the text above from "IDN-unaware" to
"IDNA-unaware" because seems to have been introduced as a term in RFC 5890. -->

			 name slot (see <xref target="terminology"/> and
			 <xref target="RFC5890">the Definitions document</xref>), 
it MUST contain only
			 ASCII characters (i.e., its labels must be either
			 A-labels or 
			 NR-LDH labels), unless the DNS application is not subject
			 to historical recommendations for "hostname"-style names 
			 (see <xref target="RFC1034">RFC 1034</xref> and
			 <xref target="DNS-RRs"/>).</t>
   
     <t>Labels MUST be compared using equivalent forms: either
		 both A-label forms or both U-label forms.  Because A-labels and
		 U-labels can be transformed into each other without loss of
		 information, these comparisons are equivalent.  A
		 pair of A-labels MUST be compared as case-insensitive ASCII
		 (as with all comparisons of ASCII DNS labels).  U-labels
		 MUST be compared as-is, without case folding or other 
<!-- [rfced] You provided:
    case folding (the corresponding operation is named
       CaseFold or toCaseFold, depending on its precise use
       but, where a generic operation is intended rather than
       the specific Unicode operation, I've used "case-folded
       strings" and the equivalent to establish a generic
       adjectival form)

We have changed "case-folding" to "case folding" in the text above.  Please
verify that this is correct. -->

		 intermediate steps.  Note that it is not necessary to validate
		 labels in order to compare them and that successful
		 comparison does not imply validity.  In many cases, not
		 limited to comparison,
		 validation may be important for other reasons and SHOULD be
		 performed.</t>
	 <t> Labels being registered MUST conform to the requirements of
		<xref target="Registration"/>.  Labels being looked up and the
		lookup process MUST conform to the requirements
		of <xref target="Lookup"/>.</t>
   </list></t>
   </section>

   <section title="Applicability">
	  <t>IDNA applies to all domain names in all domain name slots in
		 protocols except where it is explicitly excluded.  It does
		 not apply to domain name slots that do not use the
		 LDH syntax rules as described in the
		 Definitions document <xref target="RFC5890"/>.</t>

      <t>Because it uses the DNS, IDNA applies to many protocols that
		 were specified before it was designed.
		 IDNs occupying domain name slots in those
		 older protocols MUST be in A-label form until and unless
		 those protocols and their implementations are explicitly
		 upgraded to be aware of IDNs and to accept the U-label form.
		 IDNs actually
		 appearing in DNS queries or responses MUST be A-labels.</t>
	  <t>IDNA-aware protocols and implementations MAY accept U-labels,
		 A-labels, or both as those particular protocols specify.</t>
	  <t>IDNA is not defined for extended label types
		 (see <xref target="RFC2671">RFC 2671</xref>, Section 3).
		 </t>

   <section title="DNS Resource Records" anchor="DNS-RRs">
	  <t>IDNA applies only to domain names in the NAME and RDATA
		 fields of DNS resource records whose CLASS is IN.  See 
		 <xref target="RFC1035">the DNS specification</xref> for precise
		 definitions of these terms.</t> 

      <t>The application of IDNA to DNS resource records depends
		 entirely on the CLASS of the record, and not on the TYPE
		 except as noted below.  This will remain true, even as new
		 TYPEs are defined, unless a new TYPE defines TYPE-specific
		 rules.  Special naming conventions for SRV records (and
		 "underscore labels" more generally) are incompatible with
		 IDNA coding as discussed in
		 <xref target="RFC5890">the Definitions document</xref>, especially Section
		 2.3.2.3. <cref>?? Section number.</cref>
		 Of course, underscore labels may be part of a domain that
		 uses IDN labels at higher levels in the tree.</t>     
</section>

 <section title="Non-Domain-Name Data Types Stored in the DNS">
	<t>Although IDNA enables the representation of non-ASCII characters in
   domain names, that does not imply that IDNA enables the
   representation of non-ASCII characters in other data types that are
   stored in domain names, specifically in the RDATA field for types
   that have structured RDATA format.  For example, an email address
   local part is  stored in a domain name in the RNAME field as part
   of the RDATA of an SOA record (hostmaster@example.com would be 
   represented as hostmaster.example.com).  IDNA does not
    update the existing email standards, which allow only ASCII
    characters in local parts.  Even though work is in
   progress to define internationalization for email
   addresses <xref target="RFC4952"/>, changes to the email
   address part of the
   SOA RDATA would require action in, or updates to, other standards, specifically
   those that specify the format of the SOA RR.</t>
</section>
</section>
</section>


    <section title="Registration Protocol" anchor="Registration">
	   <t>This section defines the model for registering an IDN.
		  The model is implementation independent; any sequence
		  of steps that produces exactly the same result for all
		  labels is considered a valid implementation.</t>
	   <t> Note that, while the registration (this section) and
		  lookup protocols (<xref target="Lookup"/>) are very similar
		  in most respects, 
		  they are not identical, and implementers should carefully follow
		  the steps described in this specification.</t>

	<section title="Input to IDNA Registration"
			anchor="NewInput1">
		<t>Registration processes, especially processing by entities
		   (often called "registrars") who deal with registrants before the
		   request actually reaches the zone manager ("registry")
		   are outside the scope of this definition and may differ significantly depending
		   on local needs.  By the time a string enters the IDNA
		   registration process as described in this specification, it
		   MUST be in Unicode and in Normalization Form C
		   (NFC <xref target="Unicode-UAX15"/>).  Entities responsible
		   for zone files ("registries") MUST accept only the exact
		   string for which registration is requested, free of any
		   mappings or local adjustments.   They MAY accept that input
		   in any of three forms:
		   <list style="numbers">
			  <t>As a pair of A-label and U-label.</t>
			  <t>As an A-label only.</t>
			  <t>As a U-label only.</t>
		   </list></t>
		   <t>The first two of these forms are RECOMMENDED because the
		   use of A-labels avoids any possibility of ambiguity.  The
		   first is normally preferred over the second because it
		   permits further verification of user intent
		   (see <xref target="NewInput3Format"/>).</t>  
	</section>
    <section title="Permitted Character and Label Validation"
			anchor="NewInput3">
	   <section title="Input Format" anchor="NewInput3Format">
		<t>If both the U-label and A-label forms are
		   available, the registry MUST ensure that the A-label form
		   is in lowercase, perform a
		   conversion to a U-label, perform the steps and tests
		   described below on that U-label, and then verify that the
		   A-label produced by 
		   the step in <xref target="NewInput7"/> matches the one
		   provided as input.  In addition, the U-label that was
		   provided as input and the one obtained by conversion
		   of the A-label MUST match exactly.  If, for some reason,
		   these tests fail, the
		   registration MUST be rejected.</t>
		<t>If only an A-label was provided and the conversion to a
		   U-label is not performed, the registry MUST still verify that the
		   A-label is superficially valid, i.e., that it does not
		   violate any of the rules
		   of <xref target="RFC3492">Punycode encoding</xref> such as
   <!-- [JcK] the earlier form, 'Punycode [] encoding', made
     the sentence very hard to parse and follow.  And,
     strictly speaking, the citation is to the encoding that
     is called by the name 'Punycode', not to the name, so the
     change is correct at the hair-splitting level.  -->
		   the prohibition on trailing hyphen-minus, appearance of
		   non-basic characters before the delimiter, and so on.
		   Strings that appear to be A-labels (e.g., they start with
		   "xn--") and strings that are supplied to the registry in a
		   context (such as a field in a form to be filled out)
		   reserved for A-labels, but that are not valid A-labels as 
		   described in this paragraph, MUST NOT be placed in DNS
		   zones that support IDNA.</t>
		<t>If only an A-label is provided, the conversion to a
			U-label is not performed, and the superficial tests
			described in the previous paragraph are performed,
			registration procedures MAY, and usually will, bypass
			the tests and actions in the balance of
			<xref target="NewInput3"/>  and in Sections
			<xref target="NewInput6" format="counter"/>  and
			<xref target="NewInput7" format="counter"/>. </t>


		</section>
		  
	   <section title="Rejection of Characters That Are Not Permitted">
		<t> The candidate Unicode string MUST NOT contain characters
		   that appear
		   in the "DISALLOWED" and "UNASSIGNED" lists specified in
		  <xref target="RFC5892">the Tables document</xref>.</t>
	</section>

	<section title="Label Validation" anchor="NewInput5">
	   <t> The proposed label (in the form of a Unicode string, i.e.,
		  a string that at least superficially appears to be a
		  U-label) is then examined using tests that  
		  require examination of more than one character.  
<!-- [rfced] Please note the text above was changed to avoid it from reading as 
though the label was performing tests. 

The original text is as follows:
   The proposed label (in the form of a Unicode string, i.e., a string
   that at least superficially appears to be a U-label) is then
   examined, performing tests that require examination of more than one
   character.
 -->

Character
		  order is considered to be the on-the-wire order, not the
		  display order.</t>
	   <section
		title="Hyphen Restrictions" anchor="hyphenRestr">
		  <t>The Unicode string MUST NOT contain "--" (two consecutive
			 hyphens) in the third and fourth character positions and
			 MUST NOT start or end with a "-" (hyphen).</t>
	   </section>
	   <section title="Leading Combining Marks"
			   anchor="CombiningMarks">
		  <t>The Unicode string MUST NOT begin with a combining mark
			 or combining character 
			 (see <xref target="Unicode">The Unicode Standard, Section
				2.11</xref> for an exact definition).</t>
		  </section>
	   <section title="Contextual Rules">
		  <t>The Unicode string MUST NOT contain any characters whose
			 validity is context-dependent, unless the validity is
			 positively confirmed by a contextual rule.  To check
			 this, each code point marked as CONTEXTJ or CONTEXTO in
			 <xref target="RFC5892">the Tables document</xref> MUST have a non-null
			 rule.  If such a code point is missing a rule, the label is 
             <!-- [JcK] Bad antecedent -- the code point isn't
			     invalid, the label is. -->
			 invalid.  If the rule exists but the result of applying
			 the rule is negative or inconclusive, the proposed label
			 is invalid. </t>  <!-- Alexey 20091227: drop 'or
		  inconclusive' ??? -->
		  </section>
	   <section
		title="Labels Containing Characters Written Right to Left">
		  <t> If the proposed label contains any characters that are
			 written from right to left, it MUST meet the Bidi
			 criteria <xref target="RFC5893"/>.</t> 
		  </section>
	   </section>
	   <section title="Registration Validation Requirements">
		  <t>Strings that contain at least one non-ASCII character,
			 have been produced by the steps above,  
			 whose contents pass all of the tests in
			 <xref target="NewInput5"/>, and are 63 or fewer
			 characters long in
			 ASCII-compatible encoding (ACE) form (see <xref target="NewInput7"/>), are U-labels.</t> 
		  <t> To summarize, tests are made
			in <xref target="NewInput3"/> for invalid characters, 
		    invalid combinations of characters, for labels that are
		    invalid even if the characters they contain are valid
		    individually, and for labels that do not conform to the
			restrictions for strings containing right-to-left
			characters.</t> 
	</section>
	</section>

	<section title="Registry Restrictions" anchor="NewInput6">
	   <t>In addition to the rules and tests above, there are many
		  reasons why a registry could reject a label.  Registries at
		  all levels of the DNS, not just the top level, are expected
		  to establish
		  policies about label registrations. Policies are likely to
		  be informed by the local languages and the scripts that are
		  used to write them and may depend on many
		  factors including what characters are in the label (for
		  example, a label may be rejected based on other labels
		  already registered).
		  See <xref target="RFC5894">the Rationale document</xref>, Section 3.2,
		  for a discussion and recommendations about registry
		  policies.</t> 
	   <t>The string produced by the steps
		  in <xref target="NewInput3"/> is checked and processed as  
		   appropriate to local registry restrictions. Application of
		   those registry restrictions may result in
		   the rejection of some labels or the application of special
		   restrictions to others.</t>
	 </section>
	<section title="Punycode Conversion" anchor="NewInput7">
	   <t> The resulting U-label is converted to an A-label
		  (defined in
		  Section 2.3.2.1 of <xref target="RFC5890">the Definitions document</xref>).
		  <cref>?? Insert section number</cref>
		  The A-label is the 
		  encoding of the U-label according to the Punycode
		  algorithm <xref target="RFC3492"/> with the ACE prefix
		  "xn--" added at the beginning of the string.  The resulting
		  string must, of course, conform to the length limits imposed
		  by the DNS.
		  This document does not update or alter the Punycode
		  algorithm specified in RFC 3492 in any way.  RFC 3492
		  does make a non-normative reference to the information
		  about the value and construction of the ACE prefix that
		  appears "in RFC 3490 or
		  <xref target="RFC3491">Nameprep</xref>". For consistency
		  and reader convenience, IDNA2008 effectively updates that
		  reference to point to this document. That change does not
		  alter the prefix itself.  The prefix, "xn--", is the same
		  in both sets of documents.</t>
	   <t>With the exception of the maximum string length test on
		  Punycode output, the failure conditions identified in the
		  Punycode encoding  
		  procedure cannot occur if the input is a U-label as
		  determined by the steps in Sections <xref target="NewInput1" format="counter"/>
		  through <xref target="NewInput6" format="counter"/> above.</t>
	</section>
	<section title="Insertion in the Zone" anchor="NewInput8">
	   <t> The label is registered in the DNS by inserting the
		  A-label into a zone.</t> 
	</section>
	</section>

	<section title="Domain Name Lookup Protocol"
			anchor="Lookup">
	   <t> Lookup is different from registration and
		  different tests are applied on the client.   Although some
		  validity checks are necessary to avoid serious problems with
		  the protocol, <!-- (see <xref target="NewOutput3"/>ff.), --> the
		  lookup-side tests are more permissive and rely
		  on the assumption that names that are present in the DNS are
		  valid.   That assumption is, however, a weak one because the
		  presence of wildcards in the DNS might cause a string that
		  is not actually registered in the DNS to be successfully
		  looked up.</t>
   <section title="Label String Input" anchor="NewOutput1">
	  <t>The user supplies a string in the local character set,
		 for example, by typing it, clicking on it, or copying and
		 pasting it from a resource identifier, e.g.,
		 a Uniform Resource Identifier (URI) <xref target="RFC3986"/>
		 or an Internationalized Resource Identifier (IRI) <xref target="RFC3987"/>,
		 from which the domain name is extracted.
		 <!-- [JcK] ??? See question and alternatives in cover note
[rfced] We went with option 1 from your mail.
		 -->

		 Alternately, some process not directly involving the
		 user may read the string from a file or obtain it in some
		 other way.   Processing in this step and the one specified in
		 <!-- [JcK] ??? "that specified" or "the one specified"???
		    Your choice 
[rfced] We went with "the one specified."
-->
		 <xref target="NewOutput2"/> are local matters, 
		 to be accomplished prior to actual invocation of IDNA.</t> 
   </section>
   <section title="Conversion to Unicode"
		   anchor="NewOutput2"> 
	  <t> The string is converted from the local character set into
	   Unicode, if it is not already in Unicode.
	   Depending on local needs, this conversion may involve mapping
	   some characters into other characters as well as coding
	   conversions.  Those issues are discussed in the mapping-related
	   sections (Sections 4.2, 4.4, 6, and 7.3) 
	   <cref>?? Supply section numbers.</cref>
	   of <xref target="RFC5894">the Rationale document</xref> and in
	   the separate <xref target="IDNA2008-Mapping">Mapping document</xref>. 
       <!-- [JcK] original order was 'Those issues are discussed in
            [IDNA2008-Mapping] and in the mapping-related sections
	        (Sections 4.4, 6, and 7.3) of the Rationale document
	        [RFC5894].' -->
	   The result MUST be a Unicode string in NFC form.</t>
   </section>

<!-- toNFC was here, but removed in -04c after extended discussion -->

   <section title="A-label Input" anchor="A-label-Input">
	  <t>If the input to this procedure appears to be an A-label
		 (i.e., it starts in "xn--", interpreted case-insensitively),
		 the lookup application MAY 
		 attempt to convert it to a U-label, first ensuring that the
		 A-label is entirely in lowercase (converting it to 
		 lowercase if necessary), and apply the tests of
		 <xref target="NewOutput3"/> and the conversion of
		 <xref target="NewOutput6"/> to that form.
		 If the label is converted to Unicode (i.e., to U-label form)
		 using the Punycode decoding algorithm, then the processing
		 specified in those two sections MUST be performed, and the
		 label MUST be rejected if the resulting label is not
		 identical to the original.
		 See Section 8.1 of <xref target="RFC5894">the Rationale document</xref>
		 <cref>?? Check section number "Processing non-ASCII strings"</cref>
		 for additional discussion on this topic.</t>
	  <t>Conversion from the A-label and testing that the result is a
		 U-label SHOULD be performed
		 if the domain name will later be presented to the user in
		 native character form (this requires that the lookup
		 application be IDNA-aware).  If those steps are not
		 performed, the lookup process SHOULD at least test to
		 determine that the string is actually an A-label, examining
		 it for the invalid formats specified in the Punycode decoding
		 specification. 
		 Applications that are not
		 IDNA-aware will obviously omit that testing; others MAY treat
		 the string as opaque to avoid the additional processing at
		 the expense of providing less protection and information to
		 users.</t>
   </section>
   
   <section title="Validation and Character List Testing"
		   anchor="NewOutput3">
	  <t> As with the registration procedure described in
		 <xref target="Registration"/>, the Unicode string is checked 
		 to verify that all characters that appear in it are valid as
		 input to IDNA lookup processing.  As discussed above and in
		 <xref target="RFC5894">the Rationale document</xref>,
		 the lookup check is more liberal than the registration
		 one.  Labels that have not been fully evaluated for
		 conformance to the applicable rules are referred to as
		 "putative" labels as discussed in Section 2.3.2.1 of
		 <xref target="RFC5890">the Definitions document</xref>.
		 <cref>??? Insert section number</cref>
		 Putative labels with any of the following characteristics
		 MUST be rejected prior to DNS lookup:
		 <list style="symbols">
			<t>Labels that are not in NFC 
			   <xref target="Unicode-UAX15"/>.</t>
			<t>Labels containing "--" (two consecutive hyphens) in
			   the third and fourth character positions.</t>
			<t>Labels whose first character is a combining mark (see
			   <xref target="Unicode">The Unicode Standard, Section
				2.11</xref>).</t>
			<t>Labels containing prohibited code points, i.e., those
			   that are assigned to the "DISALLOWED" category 
			   of <xref target="RFC5892">the Tables document</xref>.</t>
			<t>Labels containing code points that are identified
			   in the Tables document as
			   <!-- [JcK] Citation removed.  Repeating it when it
			      appears with an identical base text two lines
			      previously (or even in consecutive paragraphs)
			      is distracting at best -->
			   "CONTEXTJ", i.e., requiring exceptional contextual
			   rule processing on lookup, but that do not conform to
			   those rules.  Note that this implies that a rule must be
			   defined, not null: a character that requires a
			   contextual rule but for which the rule is null is
			   treated in this step as having failed to conform to the
			   rule.</t> 
			<t>Labels containing code points that are identified
			   in the Tables document as "CONTEXTO", but
			   for which no such rule appears in the table of rules.
			   Applications 
			   resolving DNS names or carrying out equivalent
			   operations are not required to test contextual rules
			   for "CONTEXTO" characters, only to verify that a rule
			   is defined (although they MAY make such tests to
			   provide better protection or give better information
			   to the user).</t>  
			<t>Labels containing code points that are unassigned in
			   the version of 
			   Unicode being used by the application, i.e., in  <!-- the
			   "Unassigned" Unicode category or --> the UNASSIGNED
			   category of the Tables document.
			<vspace blankLines="1"/>
			   This requirement means that the application must use
			   a list of unassigned characters that is matched to
			   the version of Unicode that is being used for the
			   other requirements in this section. It is not
			   required that the application know which version of
			   Unicode is being used; that information might be part
			   of the operating environment in which the application
			   is running.</t>
			</list></t>

		 <t>In addition, the application SHOULD apply the following
			test.
			<list style="symbols">
			   <t>Verification that the string is compliant with the
				  requirements for right-to-left characters specified
				  in <xref target="RFC5893">the Bidi document</xref>.</t>
			   </list>
			This test may be omitted in special circumstances,
			such as when the lookup application knows that the
			conditions are enforced elsewhere, because an attempt to
			look up and resolve such strings will almost certainly
			lead to a DNS 
			lookup failure except when wildcards are present in the
			zone.  However, applying the test is likely to
			give much better information about the reason for a lookup
			failure -- information that may be usefully passed to the
			user when that is feasible -- than DNS resolution failure
			information
			alone. <!--  In any event, lookup applications should avoid
			attempting to resolve
			labels that are invalid under that test. --> </t>

		 <t>For all other strings, the lookup application MUST rely on the
			presence or absence of labels in the DNS to determine the
			validity of those labels and the validity of the characters they
			contain. If they are registered, they are presumed to
			be valid; if they are not, their possible validity is not
			relevant.
		    While a lookup application may reasonably issue warnings
			about strings it believes may be problematic,
			applications that decline to process a string 
			that conforms to the rules above (i.e., does not look
			it up in the DNS) are not in conformance with this
			protocol.</t>   
   </section>

   <section title="Punycode Conversion"  anchor="NewOutput6">
	  <t>The string that has now been validated for lookup is
		 converted to ACE form by applying the Punycode algorithm to
		 the string and then adding the ACE prefix.</t>
   </section>
   <section title="DNS Name Resolution"  anchor="NewOutput7">
	  <t> The A-label resulting from the conversion in
		 <xref target="NewOutput6"/> or supplied directly
		 (see <xref target="A-label-Input"/>) is combined with other
		 labels as needed to form a fully-qualified domain name that
		 is then looked up in
		 the DNS, using normal DNS resolver procedures.  The lookup
		 can obviously either succeed (returning information) or
		 fail.</t>
   </section>
   </section>

<section title="Security Considerations" anchor="Security">
   <t>Security Considerations for this version of IDNA are described in
	  <xref target="RFC5890"> the Definitions document</xref>, except for the
	  special issues associated with right-to-left scripts and
	  characters.  The latter are discussed in
	  <xref target="RFC5893">the Bidi document</xref>.</t>
   <t>In order to avoid intentional
	  or accidental attacks from labels that might be confused with
	  others, special problems in rendering, and so on, the IDNA
	  model requires that registries exercise care and thoughtfulness
	  about what labels they choose to permit.  That issue is
	  discussed in <xref target="NewInput6"/> of this document which,
	  in turn, points to a somewhat more extensive discussion in
      <xref target="RFC5894">the Rationale document</xref>.</t>
</section>

<section title="IANA Considerations">
   <t>IANA actions for this version of IDNA are specified in
	  <xref target="RFC5892">the Tables document</xref> and discussed informally in
	  <xref target="RFC5894">the Rationale document</xref>.  The components of IDNA
	  described in this document do not require any IANA
	  actions.</t> 
   </section>

    <section title="Contributors">
	   <t>While the listed editor held the pen, the original versions
		  of this document
		  represent the joint work and conclusions of an ad hoc
		  design team consisting of the editor and, in
		  alphabetic order, Harald Alvestrand, Tina Dam, Patrik
		  Faltstrom, and Cary Karp.  This document draws significantly
		  on the original version of IDNA <xref target="RFC3490"/>
		  both conceptually and for specific text.   This
		  second-generation version would not have been possible
		  without the work that went into that first version and
		  especially the contributions of its
		  authors Patrik Faltstrom, Paul Hoffman, and Adam Costello.
		  While Faltstrom was actively involved in the creation of
		  this version, Hoffman and Costello were not and should not
		  be held responsible for any errors or omissions.</t>
	   </section>

<section title="Acknowledgments">
   <t> This revision to IDNA would have been impossible without the
	  accumulated experience since RFC 3490 was published and
	  resulting comments and complaints of many people in the IETF,
	  ICANN, and other communities (too many people to list 
	  here).  Nor would it have been possible without RFC 3490 itself
	  and the efforts of the Working Group that defined it.  Those
	  people whose contributions are acknowledged in RFC 3490,
	  <xref target="RFC4690">RFC 4690</xref>, and
	  <xref target="RFC5894">the Rationale document</xref> were particularly
	  important.</t>
      <!-- [JcK] ??? In parallel with  "no citation for RFC 3490
         because it has been cited enough" and the very informal
         nature of the Acknowledgments Section, I think the citation
         should probably be removed from "the Rationale document".  If
         you agree, take it out 
[rfced] this was addressed separately in email regarding RFC 5894.
-->  
   <t>Specific textual changes were incorporated into this document
	  after suggestions from the other contributors,
	  Stephane Bortzmeyer, Vint Cerf, Lisa Dusseault, 
	  Paul Hoffman,  Kent Karlsson, James Mitchell,
	  Erik van der Poel, Marcos Sanz, Andrew Sullivan, Wil Tan,
	  Ken Whistler, Chris Wright, and other WG participants and
	  reviewers including
	  Martin Duerst, James Mitchell, Subramanian Moonesamy,
	  Peter Saint-Andre, Margaret Wasserman, and Dan Winship who
	  caught specific errors and recommended corrections.
	  Special thanks are due to Paul Hoffman for permission to 
	  extract material from his document to form the basis
	  for <xref target="MajorChange"/>.</t> 
   </section>

</middle>

<back>
   <references title="Normative References">
	  &rfc2119;
	  &rfc3492;   <!-- Punycode -->
	  &rfc1034;   <!-- DNS base -->
	  &rfc1035;

	<reference anchor="RFC5890">
  <front>
	<title abbrev="IDNA Definitions">
	   Internationalized Domain Names for Applications (IDNA):
	   Definitions and Document Framework
	</title>
    <author fullname="John C Klensin" initials="J.C."
			 surname="Klensin" >
      <organization/>
      <address>
        <postal>
          <street>1770 Massachusetts Ave, Ste 322</street>
          <city>Cambridge</city> <region>MA</region>
          <code>02140</code>
          <country>USA</country>
        </postal>
        <phone>+1 617 245 1457</phone>
        <!-- facsimile phone number and URI if appropriate -->
        <email>john+ietf@jck.com</email>
      </address>
    </author>
    <date month="July"  year="2010" />
	</front>
<seriesInfo name='RFC' value='5890' />
	</reference>
	  


<!--draft-ietf-idnabis-bidi -->
<reference anchor='RFC5893'>
<front>
<title>Right-to-Left Scripts for Internationalized Domain Names for Applications (IDNA)</title>

<author initials='H' surname='Alvestrand' fullname='Harald Alvestrand' role="editor">
    <organization />
</author>

<author initials='C' surname='Karp' fullname='Cary Karp'>
    <organization />
</author>

<date month='July' year='2010' />

<abstract><t>The use of right-to-left scripts in internationalized domain names has presented several challenges.  This memo proposes a new BIDI rule for IDNA labels, based on the encountered problems with some scripts, and some shortcomings in the 2003 IDNA BIDI criterion.</t></abstract>

</front>

<seriesInfo name='RFC' value='5893' />

</reference>

<!--draft-ietf-idnabis-tables -->
<reference anchor='RFC5892'>
<front>
<title>The Unicode Code Points and Internationalized Domain Names for
Applications (IDNA)</title>

<author initials='P' surname='Faltstrom' fullname='Patrik Faltstrom' role="editor">
    <organization />
</author>

<date month='July' year='2010' />

<abstract><t>This document specifies rules for deciding whether a code point, considered in isolation or in context, is a candidate for inclusion in an Internationalized Domain Name (IDN).  It is part of the specification of Internationalizing Domain Names in Applications 2008 (IDNA2008).</t></abstract>

</front>

<seriesInfo name='RFC' value='5892' />

</reference>	  	  
		 
	   <reference anchor="Unicode-UAX15"
				  target="http://www.unicode.org/reports/tr15/">
		  <front>
		  <title>Unicode Standard Annex #15: Unicode Normalization
			 Forms</title>
		<author>
		<organization>The Unicode Consortium</organization>
		<address />
		</author>
		<date year="2009" month="September" />
	  <!-- [rfced] The date was updated to match what appears at the URL
provided above. --> 
		</front>		     
		  </reference>

   </references>

<references title="Informative References">

   &rfc4690;		<!-- IDNA problems -->
   &rfc3986;		<!-- URI -->
   &rfc3987;		<!-- IRI -->
   &rfc3490;		<!-- IDNA2003 -->
   &rfc3491;		<!-- Nameprep -->
   &rfc4952;		<!-- EAI framework -->
   &rfc2671;		<!-- EDNS0 -->

<!-- Removed as unused
      &rfc2136;		... DNS update -->



<!--draft-ietf-idnabis-mappings  -->
<reference anchor='IDNA2008-Mapping'>
<front>
<title>Mapping Characters in Internationalized Domain Names for Applications (IDNA)</title>

<author initials='P' surname='Resnick' fullname='Pete Resnick'>
    <organization />
</author>

<author initials='P' surname='Hoffman' fullname='Paul Hoffman'>
    <organization />
</author>

<date month='April' year='2010' />

<abstract><t>In the original version of the Internationalized Domain Names in Applications (IDNA) protocol, any Unicode code points taken from user input were mapped into a set of Unicode code points that "make sense", which were then encoded and passed to the domain name system (DNS).  The current version of IDNA presumes that the input to the protocol comes from a set of "permitted" code points, which it then encodes and passes to the DNS, but does not specify what to do with the result of user input.  This document describes the actions that can be taken by an implementation between user input and passing permitted code points to the new IDNA protocol.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

<!--draft-ietf-idnabis-rationale -->
 <reference anchor='RFC5894'>
<front>
<title>Internationalized Domain Names for Applications (IDNA): Background, Explanation, and Rationale</title>

<author initials='J' surname='Klensin' fullname='John Klensin'>
    <organization />
</author>

<date month='July' year='2010' />

<abstract><t>Several years have passed since the original protocol for Internationalized Domain Names (IDNs) was completed and deployed. During that time, a number of issues have arisen, including the need to update the system to deal with newer versions of Unicode.  Some of these issues require tuning of the existing protocols and the tables on which they depend.  This document provides an overview of a revised system and provides explanatory material for its components.</t></abstract>

</front>

<seriesInfo name='RFC' value='5894' />

</reference>

  <reference anchor="Unicode">
                        <front>
          <title abbrev="Unicode 5.0">
                 The Unicode Standard, Version 5.0
                         </title>
                <author>
                <organization>The Unicode Consortium</organization>
                <address />
                </author>
                <date year="2007" />
                </front>
                <annotation>Boston, MA, USA: Addison-Wesley.
                   ISBN 0-321-48091-0.  This printed reference has now been
                   updated online to reflect additional codepoints.  For
                   codepoints, the reference at the time this document was
                   published is to Unicode 5.2.</annotation>
                  </reference>

<reference anchor='ASCII'>
        <front>
          <title>USA Code for Information Interchange</title>
          <author>
            <organization abbrev="ANSI">
              American National Standards Institute
                (formerly United States of America Standards Institute)
	    </organization>
          </author>
          <date year="1968"/>
        </front>
      <seriesInfo name="ANSI" value="X3.4-1968" />
      <annotation>ANSI X3.4-1968 has been replaced by newer
	  versions with slight modifications, but the 1968 version
	  remains definitive for the Internet. </annotation>
      </reference>

<!--[rfced] [JcK] Please note that the following reference entries have no corresponding citations in the text.  Please let us know where citations should be placed or if these entries should be deleted from the references section:

RFC 2181  [JcK] removed. Artifact of the separation of Defs from
	  Protocol
RFC 1123  [JcK]  as above. removed.
ASCII     [JcK] fixed - cited where used

-->
	  
</references>


<!--   Appendices -->

	<section title="Summary of Major Changes from IDNA2003"
			anchor="MajorChange">
	   <t>
  <list style="numbers">
   <t>Update base character set from Unicode 3.2 to Unicode version
        agnostic.</t>
   <t>Separate the definitions for the "registration" and "lookup"
        activities.</t>
   <t>Disallow symbol and punctuation characters except where special
        exceptions are necessary.</t>
   <t>Remove the mapping and normalization steps from the protocol and
        have them, instead, done by the applications themselves, possibly
        in a local fashion, before invoking the protocol.</t>
   <t>Change the way that the protocol specifies which characters are
        allowed in labels from "humans decide what the table of
        code points contains" to "decision about code points are based on
        Unicode properties plus a small exclusion list created by
        humans".</t>

<!--[rfced] Please note that neither of the above texts appear in this document.  -->
<!-- [JcK] That is correct.  Those quotation marks identify concepts
	    being summarized and captioned, not quotations for any
	    specific text.  Of course, if they were quotations from
	    specific text (in this document or otherwise), that text would
	    be cited.   Note that this usage is fairly conventional.
	    Remembering that we do not have the option of setting in italics,
	    see _Chicago_ (13th ed and others) at 6.60ff, particularly
	    6.65.  Or see the extended discussion and many examples in
	    Fowler and Fowler. -->

   <t>Introduce the new concept of characters that can be used only in
        specific contexts.</t>
   <t>Allow typical words and names in languages such as Dhivehi
        and Yiddish to be expressed.</t>
   <t>Make bidirectional domain names (delimited strings of labels,
        not just labels standing on their own) display in a less
        surprising fashion, whether they appear in obvious domain
		name contexts or as part of running text in paragraphs.</t>
   <t>Remove the dot separator from the mandatory part of the
	  protocol.</t> 
   <t>Make some currently valid labels that are not actually IDNA
	  labels invalid.</t> 
  </list>
  </t>
 </section>

</back>
</rfc>
