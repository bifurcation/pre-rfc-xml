<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<?rfc rfcedstyle="yes" ?>
<rfc submissionType="IETF" consensus="yes" category="info" number="6287" ipr="trust200902">
  <front>
    <title abbrev="OCRA">OCRA: OATH Challenge-Response Algorithm </title>

    <author fullname="David M'Raihi" initials="D." surname="M'Raihi">
      <organization>Verisign, Inc.</organization>

      <address>
        <postal>
          <street>487 E. Middlefield Road</street>

          <city>Mountain View</city>

          <region>CA</region>

          <code>94043</code>

          <country>USA</country>
        </postal>

        <email>davidietf@gmail.com</email>
      </address>
    </author>


    <author fullname="Johan Rydell" initials="J." surname="Rydell">
      <organization>Portwise, Inc.</organization>

    <address>
        <postal>
          <street>275 Hawthorne Ave, Suite 119</street>

          <city>Palo Alto</city>

          <region>CA</region>

          <code>94301</code>

          <country>USA</country>
        </postal>

        <email>johanietf@gmail.com</email>
      </address>
    </author>

    <author fullname="Siddharth Bajaj" initials="S." surname="Bajaj">
      <organization>Symantec Corp.</organization>

      <address>
        <postal>
          <street>350 Ellis Street</street>

          <city>Mountain View</city>

          <region>CA</region>

          <code>94043</code>

          <country>USA</country>
        </postal>

        <email>siddharthietf@gmail.com</email>
      </address>
    </author>

    <author fullname="Salah Machani" initials="S." surname="Machani">
      <organization>Diversinet Corp.</organization>

    <address>
        <postal>
          <street>2225 Sheppard Avenue East, Suite 1801</street>

          <city>Toronto</city>

          <region>Ontario</region>

          <code>M2J 5C2</code>

          <country>Canada</country>
        </postal>

        <email>smachani@diversinet.com</email>
      </address>
    </author>

    <author fullname="David Naccache" initials="D." surname="Naccache">
      <organization>Ecole Normale Superieure</organization>

      <address>
        <postal>
          <street>ENS DI, 45 rue d'Ulm</street>

          <city>Paris</city>

          <region></region>

          <code>75005</code>

          <country>France</country>
        </postal>

        <email>david.naccache@ens.fr</email>
      </address>
    </author>


    <date  month="June" year="2011" />

    <area>General</area>

    <workgroup>Internet Engineering Task Force</workgroup>


    <abstract>

    <t>This document describes an algorithm for challenge-response
    authentication developed by the Initiative for Open Authentication (OATH).
    The specified mechanisms leverage the HMAC-based One-Time Password (HOTP) algorithm
    and offer one-way and mutual authentication, 
    and electronic signature capabilities.</t>

    </abstract>

  </front>

  <middle>
    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="Section-Introduction" title="Introduction">

    <t>The Initiative for Open Authentication (OATH) <xref target="OATH"></xref> has identified several
    use cases and scenarios that require an asynchronous variant
    to accommodate users who do not want to maintain a synchronized
    authentication system. A commonly accepted method for this
    is to use a challenge-response scheme.
    </t>
    <t>
    Such a challenge-response mode of authentication is widely adopted in
    the industry. Several vendors already offer software applications
    and hardware devices implementing challenge-response -- but each of
    those uses vendor-specific proprietary algorithms. For the benefits
    of users there is a need for a standardized challenge-response
    algorithm that allows multi-sourcing of token purchases and
    validation systems to facilitate the democratization of strong
    authentication.
    </t>
    <t>
   Additionally, this specification describes the means to create
   symmetric key-based short 'electronic signatures'.  Such signatures are
   variants of challenge-response mode where the data to be signed
   becomes the challenge or is used to derive the challenge. Note that 
   the term 'electronic signature' and 'signature' are used interchangeably 
   in this document.  </t>


    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="terms" title="Notation and Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref target="RFC2119"></xref>.</t>
    </section>

    <section anchor="Algorithm Requirements" title="Algorithm Requirements">

    <t>This section presents the main requirements that drove this
    algorithm design. A lot of emphasis was placed on flexibility and
    usability, under the constraints and specificity of the HMAC-based One-Time Password (HOTP)
    algorithm <xref target="RFC4226"></xref> and hardware token capabilities. </t>

    <t>R1 - The algorithm MUST support challenge-response-based authentication. </t>

    <t>R2 - The algorithm MUST be capable of supporting symmetric key-based short electronic signatures. Essentially, this is a variation of
    challenge-response where the challenge is derived from the data
    that needs to be signed. </t>

    <t>R3 - The algorithm MUST be capable of supporting server
    authentication, whereby the user can verify that he/she is talking
    to a trusted server. </t>

    <t>R4 - The algorithm SHOULD use HOTP <xref target="RFC4226"/>
    as a key building block. </t>

    <t>R5 - The length and format of the input challenge SHOULD be
    configurable. </t>

    <t>R6 - The output length and format of the generated response SHOULD
    be configurable. </t>

    <t>R7 - The challenge MAY be generated with integrity checking (e.g.,
    parity bits). This will allow tokens with pin pads to perform
    simple error checking when the user enters the challenge value into
    a token. </t>

    <t>R8 - There MUST be a unique secret (key) for each token/soft token
    that is shared between the token and the authentication server. The
    keys MUST be randomly generated or derived using a key derivation
    algorithm. </t>

    <t>R9 - The algorithm MAY enable additional data attributes such as a
    timestamp or session information to be included in the computation.
    These data inputs MAY be used individually or all together. </t>

    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="Section-OCRA-Background" title="OCRA Background">

    <t>OATH introduced the HOTP algorithm as a first open, freely
    available building block towards strengthening authentication for
    end-users in a variety of applications. One-time passwords are very
    efficient at solving specific security issues thanks to the dynamic
    nature of OTP computations. </t>

    <t>After carefully analyzing different use cases, OATH came to the
    conclusion that providing for extensions to the HOTP algorithms was
    important. A very natural extension is to introduce a challenge
    mode for computing HOTP values based on random questions. Equally
    beneficial is being able to perform mutual authentication between
    two parties, or short-signature computation for authenticating
    transaction to improve the security of e-commerce applications. </t>

        <!-- ////////////////////////////////////////////////////////////////////////////////// -->

        <section anchor="Section-HOTP" title="HOTP Algorithm">

        <t>The HOTP algorithm, as defined in <xref target="RFC4226"/>, is based on an
        increasing counter value and a static symmetric key known only to
        the prover and verifier parties. </t>

        <t>
        As a reminder:
        </t>

        <figure align="center">
        <artwork> HOTP(K,C) = Truncate(HMAC-SHA1(K,C))
        </artwork>
        </figure>

        <t>
        where Truncate represents the function that converts an HMAC-SHA-1
        value into an HOTP value.
        </t>

        <t>
        We refer the reader to <xref target="RFC4226"/> for the full description and
        further details on the rationale and security analysis of HOTP.
        </t>

        <t>
        The present document describes the different variants based on similar
        constructions as HOTP.
        </t>
        </section>

    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="OCRA-Definition" title="Definition of OCRA">

    <t>
    The OATH Challenge-Response Algorithm (OCRA) is a generalization of HOTP with variable data inputs not
    solely based on an incremented counter and secret key values.
    </t>
    <t>
    The definition of OCRA requires a cryptographic function, a key K
    and a set of DataInput parameters. This section first formally
    introduces OCRA and then introduces the definitions
    and default values recommended for all parameters.
    </t>
    <t>
    In a nutshell,
    </t>

    <figure align="center">
    <artwork> OCRA = CryptoFunction(K, DataInput)
    </artwork>
    </figure>

    <t>
    where:
    </t>

    <t><list style="symbols">
    <t>K: a shared secret key known to both parties</t>

    <t>DataInput: a structure that contains the concatenation of the
    various input data values defined in details in section 5.1</t>
    <t>CryptoFunction: this is the function performing the OCRA
    computation from the secret key K and the DataInput material;</t>

    </list> CryptoFunction is described in details in <xref target="Section-CryptoFunction"/></t>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

        <section anchor="Section-DataInput" title="DataInput Parameters">

        <t>
        This structure is the concatenation over byte array of the
        OCRASuite value as defined in section 6 with the different
        parameters used in the computation, save for the secret key K.
        </t>

        <t>DataInput = {OCRASuite | 00 | C | Q | P | S | T} where: </t>
            <t><list style="symbols">
            <t>OCRASuite is a value representing the suite of operations to
            compute an OCRA response</t>
            <t>00 is a byte value used as a separator</t>
            <t>C is an unsigned 8-byte counter value processed high-order bit
            first, and MUST be synchronized between all parties; It loops
            around from "{Hex}0" to "{Hex}FFFFFFFFFFFFFFFF" and then starts
            over at "{Hex}0". Note that 'C' is optional for all OCRA modes 
            described in this document.</t>
            <t>Q, mandatory, is a 128-byte list of (concatenated) challenge
            question(s) generated by the parties; if Q is less than 128
             bytes, then it should be padded with zeroes to the right</t>
            <t>P is a hash (SHA-1 <xref target="RFC3174"></xref>, SHA-256 and 
             SHA-512 <xref target="SHA2"></xref> are supported) value of
             PIN/password that is known to all parties during the execution
             of the algorithm; the length of P will depend on the hash
             function that is used</t>

            <t>S is a UTF-8 <xref target="RFC3629" /> encoded string of length up to 512 bytes that
             contains information about the current session; the length of
             S is defined in the OCRASuite string</t>
            <t>T is an 8-byte unsigned integer in big-endian order (i.e., network byte
      order) representing the number of time-steps (seconds, minutes,
      hours, or days depending on the specified granularity) since
      midnight UTC of January 1, 1970 <xref target="UT" />.  More specifically, if the OCRA
      computation includes a timestamp T, you should first convert your
      current local time to UTC time; you can then derive the UTC time
      in the proper format (i.e., seconds, minutes, hours, or days elapsed
      from epoch time); the size of the time-step is specified in the
      OCRASuite string as described in <xref target="SectionData" /></t>
             </list></t>

        <t>
        When computing a response, the concatenation order is always the
        following:
        </t>

        <figure align="center">
        <artwork>
            <t>C |</t>
            <t>OTHER-PARTY-GENERATED-CHALLENGE-QUESTION |</t>
            <t>YOUR-GENERATED-CHALLENGE-QUESTION |</t>
            <t>P| S | T</t>
        </artwork>
        </figure>

        <t>
        If a value is empty (i.e., a certain input is not used in the
        computation) then the value is simply not represented in the
        string.
        </t>

        <t>
        The counter on the token or client MUST be incremented every time a
        new computation is requested by the user. The server's counter
        value MUST only be incremented after a successful OCRA
        authentication.
        </t>

        </section>

        <!-- ////////////////////////////////////////////////////////////////////////////////// -->

        <section anchor="Section-CryptoFunction" title="CryptoFunction">

        <t>
        The default CryptoFunction is HOTP-SHA1-6, i.e., the default mode of
        computation for OCRA is HOTP with the default 6-digit dynamic
        truncation and a combination of DataInput values as the message to
        compute the HMAC-SHA1 digest.
        </t>

        <t>
        We denote t as the length in decimal digits of the truncation output. 
        For instance, if t = 6, then the output of the truncation is a 6-digit (decimal) 
        value.
        </t>

        <t> We define the HOTP family of functions as an extension to HOTP:</t>

        <t><list style = "numbers">
        <t>HOTP-H-t: these are the different possible truncated versions of
          HOTP, using the dynamic truncation method for extracting an HOTP
          value from the HMAC output</t>
        <t>We will denote HOTP-H-t as the realization of an HOTP function
          that uses an HMAC function with the hash function H, and the
          dynamic truncation as described in <xref target="RFC4226"></xref>
          to extract a t-digit value</t>
        <t>t=0 means that no truncation is performed and the full HMAC value
          is used for authentication purposes</t>
        </list></t>

        <t> We list the following preferred modes of computation, where *
        denotes the default CryptoFunction:</t>

        <t><list style ="symbols">
        <t> HOTP-SHA1-4: HOTP with SHA-1 as the hash function for HMAC
        and a dynamic truncation to a 4-digit value; this mode is not
        recommended in the general case, but it can be useful when a very
        short authentication code is needed by an application</t>
        <t> HOTP-SHA1-6: HOTP with SHA-1 as the hash function for HMAC
        and a dynamic truncation to a 6-digit value</t>
        <t> HOTP-SHA1-8: HOTP with SHA-1 as the hash function for HMAC
        and a dynamic truncation to an 8-digit value</t>
        <t> HOTP-SHA256-6: HOTP with SHA-256 as the hash function for
        HMAC and a dynamic truncation to a 6-digit value</t>
        <t>HOTP-SHA512-6: HOTP with SHA-512 as the hash function for
        HMAC and a dynamic truncation to a 6-digit value</t>
        </list></t>

        <t> This table summarizes all possible values for the CryptoFunction:</t>

        <texttable anchor="CryptoFunctionTable" title="CryptoFunction Table">
            <ttcol align="center">Name</ttcol>
            <ttcol align="center">HMAC Function Used</ttcol>
            <ttcol align="center">Size of Truncation (t)</ttcol>

        <c>HOTP-SHA1-t</c>
        <c>HMAC-SHA1</c>
        <c>0 (no truncation), 4-10</c>

        <c>HOTP-SHA256-t</c>
        <c>HMAC-SHA256</c>
        <c>0 (no truncation), 4-10</c>

        <c>HOTP-SHA512-t</c>
        <c>HMAC-SHA512</c>
        <c>0 (no truncation), 4-10</c>

        </texttable>

        </section>

    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="Section-OCRASuite" title="The OCRASuite">

    <t>
    An OCRASuite value is a text string that captures one mode of
    operation for OCRA, completely specifying the various
    options for that computation. An OCRASuite value is represented as
    follows:
    </t>

    <figure align ="center">
    <artwork><![CDATA[
<Algorithm>:<CryptoFunction>:<DataInput>
    ]]>
    </artwork>
    </figure>

    <t>
    The OCRASuite value is the concatenation of three sub-components
    that are described below. Some example OCRASuite strings are described in 
    <xref target="SectionExamples" />.
    </t>
    <t>
    The client and server need to agree on one or two values of
    OCRASuite. These values may be agreed upon at the time of token provisioning
    or, for more sophisticated client-server interactions, these values
    may be negotiated for every transaction.
    </t>
<t>The provisioning of OCRA keys and related metadata such as OCRASuite is 
   out of scope for this document. <xref target="RFC6030" /> specifies one key container 
   specification that facilitates provisioning of such data between the 
   client and the server.</t>
    <t>
    Note that for Mutual Challenge-Response or Signature with Server
    Authentication modes, the client and server will need to agree on
    two values of OCRASuite -- one for server computation and another
    for client computation.
    </t>


        <section anchor="SectionAlgorithm" title="Algorithm">

        <t>Description: Indicates the version of OCRA. </t>
        <t>Values: OCRA-v where v represents the version number (e.g., 1, 2). This document specifies version 1 of OCRA. </t>
        </section>

        <section anchor="SectionCryptoFunction" title="CryptoFunction">

        <t>Description: Indicates the function used to compute OCRA values</t>
        <t>Values: Permitted values are described in <xref target="Section-CryptoFunction" />.</t>
        </section>

        <section anchor="SectionData" title="DataInput">
        <t> Description: This component of the OCRASuite string captures the
        list of valid inputs for that computation; [] indicates a value is
        optional:</t>

        <t>[C] | QFxx | [PH | Snnn | TG] : Challenge-Response computation</t>
        <t>[C] | QFxx | [PH | TG]        : Plain Signature computation</t>


        <t> Each input that is used for the computation is represented by a
        single letter (except Q), and they are separated by a hyphen. </t>

        <t> The input for challenge is further qualified by the formats
        supported by the client for challenge question(s). Supported values
        can be: </t>

            <texttable anchor="ChallengeFormatTable" title="Challenge Format Table">
                <ttcol align="center">Format (F)</ttcol>
                <ttcol align="center">Up to Length (xx)</ttcol>

                <c>A (alphanumeric)</c>
                <c>04-64</c>

                <c>N (numeric)</c>
                <c>04-64</c>

                <c>H (hexadecimal)</c>
                <c>04-64</c>

            </texttable>

        <t>The default challenge format is N08, numeric and up to 8 digits.</t>

        <t> The input for P is further qualified by the hash function used for
        the PIN/password. Supported values for hash function can be: </t>

        <t>Hash function (H) - SHA1, SHA256, SHA512. </t>

        <t> The default hash function for P is SHA1.</t>

        <t> The input for S is further qualified by the length of the session
        data in bytes. The client and server could agree to any length but
        the typical values are:</t>
        <t> Length (nnn) - 064, 128, 256, and 512.</t>
        <t> The default length is 064 bytes. </t>

        <t>The input for timestamps is further qualified by G, size of the
        time-step. G can be specified in number of seconds, minutes, or
        hours:</t>

        <texttable anchor="ChallengeTimeStepSizeTable" title="Time-step Size Table">
            <ttcol align="center">Time-Step Size (G)</ttcol>
            <ttcol align="center">Examples</ttcol>

            <c>[1-59]S</c>
            <c>number of seconds, e.g., 20S</c>

            <c>[1-59]M</c>
            <c>number of minutes, e.g., 5M</c>

            <c>[0-48]H</c>
            <c>number of hours, e.g., 24H</c>
        </texttable>

        <t>Default value for G is 1M, i.e., time-step size is one minute and
        the T represents the number of minutes since epoch time <xref target="UT" />.</t>

        </section>

        <section anchor="SectionExamples" title="OCRASuite Examples">
        <t>Here are some examples of OCRASuite strings:</t>

        <list style="symbols">
        <t>"OCRA-1:HOTP-SHA512-8:C-QN08-PSHA1" means version 1 of OCRA
        with HMAC-SHA512 function, truncated to an 8-digit
        value, using the counter, a random challenge, and a SHA1 digest of
        the PIN/password as parameters. It also indicates that the client
        supports only numeric challenge up to 8 digits in length</t>
        <t>"OCRA-1:HOTP-SHA256-6:QA10-T1M" means version 1 of OCRA
        with HMAC-SHA256 function, truncated to a 6-digit
        value, using a random alphanumeric challenge up to 10 characters
        in length and a timestamp in number of minutes since epoch time</t>
        <t>"OCRA-1:HOTP-SHA1-4:QH8-S512" means version 1 of OCRA
        with HMAC-SHA1 function, truncated to a 4-digit value, using a
        random hexadecimal challenge up to 8 nibbles and a session value
        of 512 bytes</t>
        </list>

        </section>

   </section>

   <section anchor="SectionModes" title="Algorithm Modes for Authentication">

   <t> This section describes the typical modes in which the above defined
   computation can be used for authentication.</t>

   <section anchor="SectionOneWay" title="One-Way Challenge-Response">

   <t>A challenge-response is a security mechanism in which the verifier
   presents a question (challenge) to the prover, who must provide a
   valid answer (response) to be authenticated.</t>

   <t>To use this algorithm for a one-way challenge-response, the
   verifier will communicate a challenge value (typically randomly
   generated) to the prover. The prover will use the challenge in the
   computation as described above. The prover then communicates the
   response to the verifier to authenticate.</t>

   <t>Therefore in this mode, the typical data inputs will be:</>
   <list style="empty">
   <t>C - Counter, optional.</t>
   <t>Q - Challenge question, mandatory, supplied by the verifier.</t>
   <t>P - Hashed version of PIN/password, optional. </t>
   <t>S - Session information, optional. </t>
   <t>T - Timestamp, optional.</t>
   </list></t>

   <t>The diagram below shows the message exchange between the client
   (prover) and the server (verifier) to complete a one-way challenge-
   response authentication.</t>

   <t>It is assumed that the client and server have a pre-shared key K
   that is used for the computation.</t>


    <figure align="center">
    <artwork><![CDATA[
 CLIENT                                   SERVER
(PROVER)                                 VERIFIER)
   |                                        |
   |   Verifier sends challenge to prover   |
   |   Challenge = Q                        |
   |<---------------------------------------|
   |                                        |
   |   Prover Computes Response             |
   |   R = OCRA(K, {[C] | Q | [P | S | T]}) |
   |   Prover sends Response = R            |
   |--------------------------------------->|
   |                                        |
   |  Verifier Validates Response           |
   |  If Response is valid, Server sends OK |
   |  If Response is not,  Server sends NOK |
   |<---------------------------------------|
   |                                        |
    ]]></artwork>
    </figure>

    </section>

    <section anchor="SectionMutualCR" title="Mutual Challenge-Response">

    <t>Mutual challenge-response is a variation of one-way challenge-
    response where both the client and server mutually authenticate
    each other. </t>

    <t>To use this algorithm, the client will first send a random client-
    challenge to the server. The server computes the server-response
    and sends it to the client along with a server-challenge.</t>

    <t>The client will first verify the server-response to be assured that
    it is talking to a valid server. It will then compute the client-
    response and send it to the server to authenticate. The server
    verifies the client-response to complete the two-way authentication
    process. </t>

    <t>In this mode there are two computations: client-response and
    server-response. There are two separate challenge questions,
    generated by both parties. We denote these challenge questions Q1
    and Q2. <t>

    <t>Typical data inputs for server-response computation will be:</t>
    <list style="empty">
    <t>C  - Counter, optional. </t>
    <t>QC - Challenge question, mandatory, supplied by the client. </t>
    <t>QS - Challenge question, mandatory, supplied by the server. </t>
    <t>S  - Session information, optional. </t>
    <t>T  - Timestamp, optional. </t>
    </list></t>

    <t>Typical data inputs for client-response computation will be:  </t>
    <list style="empty">
    <t>C  - Counter, optional. </t>
    <t>QS - Challenge question, mandatory, supplied by the server. </t>
    <t>QC - Challenge question, mandatory, supplied by the client. </t>
    <t>P  - Hashed version of PIN/password, optional. </t>
    <t>S  - Session information, optional. </t>
    <t>T  - Timestamp, optional. </t>
    </list></t>

    <t>The following diagram shows the messages that are exchanged between
    the client and the server to complete a two-way mutual challenge-
    response authentication. </t>

    <t>It is assumed that the client and server have a pre-shared key K
    (or pair of keys if using dual-key mode of computation) that is
    used for the computation. </t>

    <figure align="center">
    <artwork><![CDATA[
 CLIENT                                             SERVER
(PROVER)                                          (VERIFIER)
   |                                                  |
   |   1. Client sends client-challenge               |
   |   QC = Client-challenge                          |
   |------------------------------------------------->|
   |                                                  |
   |   2. Server computes server-response             |
   |      and sends server-challenge                  |
   |   RS = OCRA(K, [C] | QC | QS | [S | T])          |
   |   QS = Server-challenge                          |
   |   Response = RS, QS                              |
   |<-------------------------------------------------|
   |                                                  |
   |   3. Client verifies server-response             |
   |      and computes client-response                |
   |   OCRA(K, [C] | QC | QS | [S | T]) != RS -> STOP |
   |   RC = OCRA(K, [C] | QS | QC | [P | S | T])      |
   |   Response = RC                                  |
   |------------------------------------------------->|
   |                                                  |
   |   4. Server verifies client-response             |
   |   OCRA(K, [C] | QS | QC | [P|S|T]) != RC -> STOP |
   |   Response = OK                                  |
   |<-------------------------------------------------|
   |                                                  |
    ]]></artwork>
    </figure>

    </section>

    <section anchor="SectionSignature" title="Algorithm Modes for Signature">

    <t>In this section we describe the typical modes in which the above
    defined computation can be used for electronic signatures.</t>

        <section anchor="SectionPlain" title="Plain Signature">

        <t>To use this algorithm in plain signature mode, the server will
        communicate a signature-challenge value to the client (signer). The
        signature-challenge is either the data to be signed or derived from
        the data to be signed using a hash function, for example. </t>

        <t>The client will use the signature-challenge in the computation as
        described above. The client then communicates the signature value
        (response) to the server to authenticate. </t>

        <t>Therefore in this mode, the data inputs will be:</t>
        <list style="empty">
        <t>C - Counter, optional.</t>
        <t>QS - Signature-challenge, mandatory, supplied by the server. </t>
        <t>P - Hashed version of PIN/password, optional. </t>
        <t>T - Timestamp, optional. </t>
        </list>

        <t>The picture below shows the messages that are exchanged between the
        client (prover) and the server (verifier) to complete a plain
        signature operation. </t>

        <t>It is assumed that the client and server have a pre-shared key K
        that is used for the computation.</t>

        <figure align="center">
        <artwork><![CDATA[
 CLIENT                                     SERVER
(PROVER)                                  (VERIFIER)
   |                                           |
   |    Verifier sends signature-challenge     |
   |    Challenge = QS                         |
   |<------------------------------------------|
   |                                           |
   |    Client Computes Response               |
   |    SIGN = OCRA(K, [C] | QS | [P | T])     |
   |    Response = SIGN                        |
   |------------------------------------------>|
   |                                           |
   |    Verifier Validates Response            |
   |    Response = OK                          |
   |<------------------------------------------|
   |                                           |
        ]]></artwork>
        </figure>

        </section>

        <section anchor="SectionSignServerAuth" title="Signature with Server Authentication">

        <t> This mode is a variation of the plain signature mode where the
        client can first authenticate the server before generating a
        electronic signature. </t>

        <t>To use this algorithm, the client will first send a random client-
        challenge to the server. The server computes the server-response
        and sends it to the client along with a signature-challenge. </t>

        <t>The client will first verify the server-response to authenticate
        that it is talking to a valid server. It will then compute the
        signature and send it to the server. </t>

        <t>In this mode there are two computations: client-signature and
        server-response. </t>

        <t>Typical data inputs for server-response computation will be: </t>
        <list style="empty">
        <t>C - Counter, optional. </t>
        <t>QC - Challenge question, mandatory, supplied by the client.  </t>
        <t>QS - Signature-challenge, mandatory, supplied by the server. </t>
        <t>T - Timestamp, optional. </t>
        </list>

        <t>Typical data inputs for client-signature computation will be: </t>
        <list style="empty">
        <t>C - Counter, optional. </t>
        <t>QC - Challenge question, mandatory, supplied by the client. </t>
        <t>QS - Signature-challenge, mandatory, supplied by the server. </t>
        <t>P - Hashed version of PIN/password, optional. </t>
        <t>T - Timestamp, optional. </t>
        </list>

        <t>The diagram below shows the messages that are exchanged between the
        client and the server to complete a signature with server
        authentication transaction. </t>

        <t>It is assumed that the client and server have a pre-shared key K
        (or pair of keys if using dual-key mode of computation) that is
        used for the computation. </t>

        <figure align="center">
        <artwork><![CDATA[
 CLIENT                                              SERVER
(PROVER)                                            VERIFIER)
   |                                                   |
   |    1. Client sends client-challenge               |
   |    QC = Client-challenge                          |
   |-------------------------------------------------->|
   |                                                   |
   |    2. Server computes server-response             |
   |       and sends signature-challenge               |
   |    RS = OCRA(K, [C] | QC | QS | [T])              |
   |    QS = signature-challenge                       |
   |    Response = RS, QS                              |
   |<--------------------------------------------------|
   |                                                   |
   |    3. Client verifies server-response             |
   |       and computes signature                      |
   |    OCRA(K, [C] | QC | QS | [T]) != RS -> STOP     |
   |    SIGN = OCRA( K, [C] | QS | QC | [P | T])       |
   |    Response = SIGN                                |
   |-------------------------------------------------->|
   |                                                   |
   |    4. Server verifies Signature                   |
   |    OCRA(K, [C] | QS | QC | [P|T]) != SIGN -> STOP |
   |    Response = OK                                  |
   |<--------------------------------------------------|
   |                                                   |
        ]]></artwork>
        </figure>

        </section>

        </section>

    </section>


    <section anchor="SectionSecurityConsiderations" title="Security Considerations">

    <t>
    Any algorithm is only as secure as the application and the
    authentication protocols that implement it. Therefore, this section
    discusses the critical security requirements that our choice of
    algorithm imposes on the authentication protocol and validation
    software.
    </t>

        <section anchor="SectionSecAna" title="Security Analysis of OCRA">

        <t>The security and strength of this algorithm depend on the
        properties of the underlying building block HOTP, which is a
        construction based on HMAC <xref target="RFC2104"></xref>
        using SHA-1 <xref target="RFC3174"></xref> (or SHA-256 or SHA-512 
        <xref target="SHA2"></xref>) as the hash function. </t>

        <t>The conclusion of the security analysis detailed in <xref target="RFC4226"></xref>
        is that, for all practical purposes, the outputs of the dynamic
        truncation on distinct counter inputs are uniformly and
        independently distributed strings. </t>

        <t>The analysis demonstrates that the best possible attack against the
        HOTP function is the brute force attack. </t>

        </section>

        <section anchor="SectionImplementations" title="Implementation Considerations">

        <t>IC1 - In the authentication mode, the client MUST support two-factor authentication, i.e., the communication and verification of
        something you know (secret code such as a password, pass phrase,
        PIN code, etc.) and something you have (token).  The secret code is
        known only to the user and usually entered with the Response value
        for authentication purpose (two-factor authentication).
        Alternatively, instead of sending something you know to the server,
        the client may use a hash of the password or PIN code in the
        computation itself, thus implicitly enabling two-factor
        authentication. </t>

        <t>IC2 - Keys SHOULD be of the length of the CryptoFunction output to
        facilitate interoperability. </t>

        <t>IC3 - Keys SHOULD be chosen at random or using a cryptographically
        strong pseudo-random generator properly seeded with a random value.
        We RECOMMEND following the recommendations in <xref target="RFC4086"></xref>
        for all pseudo-random and random generations. The pseudo-random numbers
        used for generating the keys SHOULD successfully pass the
        randomness test specified in <xref target="CN"></xref>. </t>

        <t>IC4 - Challenge questions SHOULD be 20-byte values and MUST be at
        least t-byte values where t stands for the digit-length of the OCRA
        truncation output. </t>

        <t>IC5 - On the client side, the keys SHOULD be embedded in a tamper-resistant device or securely implemented in a software application.
        Additionally, by embedding the keys in a hardware device, you also
        have the advantage of improving the flexibility (mobility) of the
        authentication system. </t>

        <t>IC6 - All the communications SHOULD take place over a secure
        channel, e.g., SSL/TLS <xref target="RFC5246"></xref>, IPsec connections. </t>

        <t>IC7 - OCRA, when used in mutual authentication mode or
        in signature with server authentication mode, MAY use dual-key mode
        --  i.e., there are two keys that are shared between the client and
        the server. One shared key is used to generate the server response
        on the server side and to verify it on the client side. The other
        key is used to create the response or signature on the client side
        and to verify it on the server side.  </t>

        <t>IC8 - We recommend that implementations MAY use the session
        information, S, as an additional input in the computation. For
        example, S could be the session identifier from the TLS session.
        This will mitigate against certain types of man-in-the-middle
        attacks. However, this will introduce the additional dependency
        that first of all the prover needs to have access to the session
        identifier to compute the response and the verifier will need
        access to the session identifier to verify the response. 
        <xref target ="RFC5056"/> contains a relevant discussion of using
        Channel Bindings to Secure Channels.</t>

        <t>IC9 - In the signature mode, whenever the counter or time (defined
        as optional elements) are not used in the computation, there might
        be a risk of replay attack and the implementers should carefully
        consider this issue in the light of their specific application
        requirements and security guidelines. The server SHOULD also
        provide whenever possible a mean for the client (if able) to verify
        the validity of the signature challenge. </t>

        <t>IC10 - We also RECOMMEND storing the keys securely in the
        validation system, and more specifically, encrypting them using
        tamper-resistant hardware encryption and exposing them only when
        required: for example, the key is decrypted when needed to verify
        an OCRA response, and re-encrypted immediately to limit exposure in
        the RAM for a short period of time.  The key store MUST be in a
        secure area, to avoid as much as possible direct attack on the
        validation system and secrets database. Particularly, access to the
        key material should be limited to programs and processes required
        by the validation system only. </t>

        </section>

  </section>



  <section anchor="SectionConclusion" title="Conclusion">

  <t> This document  introduced several variants of HOTP for challenge-
  response-based authentication and short signature-like
  computations. </t>

  <t> The OCRASuite provides for an easy integration and support of
  different flavors within an authentication and validation system. </t>

  <t> Finally, OCRA should enable mutual authentication both in connected
  and off-line modes, with the support of different response sizes
  and mode of operations. </t>

  </section>

  <section anchor="SectionAck" title="Acknowledgements">

  <t> We would like to thank Jeff Burstein, Shuh Chang, Oanh Hoang,
  Philip Hoyer, Jon Martinsson, Frederik Mennes, Mingliang Pei,
  Jonathan Tuliani, Stu Vaeth, Enrique Rodriguez, and Robert
  Zuccherato for their comments and suggestions to improve this 
  document. </t>

  </section>

  </middle>


  <back>
    <references title="Normative References">

<reference anchor='RFC2104'>

<front>
<title abbrev='HMAC'>HMAC: Keyed-Hashing for Message Authentication</title>
<author initials='H.' surname='Krawczyk' fullname='Hugo Krawczyk'>
<organization>IBM, T.J. Watson Research Center</organization>
<address>
<postal>
<street>P.O.Box 704</street>
<city>Yorktown Heights</city>
<region>NY</region>
<code>10598</code>
<country>US</country></postal>
<email>hugo@watson.ibm.com</email></address></author>
<author initials='M.' surname='Bellare' fullname='Mihir Bellare'>
<organization>University of California at San Diego, Dept of Computer Science and Engineering</organization>
<address>
<postal>
<street>9500 Gilman Drive</street>
<street>Mail Code 0114</street>
<city>La Jolla</city>
<region>CA</region>
<code>92093</code>
<country>US</country></postal>
<email>mihir@cs.ucsd.edu</email></address></author>
<author initials='R.' surname='Canetti' fullname='Ran Canetti'>
<organization>IBM T.J. Watson Research Center</organization>
<address>
<postal>
<street>P.O.Box 704</street>
<city>Yorktown Heights</city>
<region>NY</region>
<code>10598</code>
<country>US</country></postal>
<email>canetti@watson.ibm.com</email></address></author>
<date year='1997' month='February' />
<abstract>
<t>This document describes HMAC, a mechanism for message authentication using cryptographic hash functions. HMAC can be used with any iterative cryptographic hash function, e.g., MD5, SHA-1, in combination with a secret shared key.  The cryptographic strength of HMAC depends on the properties of the underlying hash function.</t></abstract></front>

<seriesInfo name='RFC' value='2104' />
<format type='TXT' octets='22297' target='ftp://ftp.isi.edu/in-notes/rfc2104.txt' />
</reference>



<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='ftp://ftp.isi.edu/in-notes/rfc2119.txt' />
<format type='HTML' octets='17491' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>




<reference anchor='RFC3629'>

<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'>
<organization /></author>
<date year='2003' month='November' />
<abstract>
<t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract></front>

<seriesInfo name='STD' value='63' />
<seriesInfo name='RFC' value='3629' />
<format type='TXT' octets='33856' target='ftp://ftp.rfc-editor.org/in-notes/rfc3629.txt' />
</reference>



<reference anchor='RFC3174'>

<front>
<title>US Secure Hash Algorithm 1 (SHA1)</title>
<author initials='D.' surname='Eastlake' fullname='D. Eastlake'>
<organization /></author>
<author initials='P.' surname='Jones' fullname='P. Jones'>
<organization /></author>
<date year='2001' month='September' />
<abstract>
<t>The purpose of this document is to make the SHA-1 (Secure Hash Algorithm 1) hash algorithm conveniently available to the Internet community.  This memo provides information for the Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='3174' />
<format type='TXT' octets='35525' target='ftp://ftp.rfc-editor.org/in-notes/rfc3174.txt' />
</reference>



<reference anchor='RFC4086'>

<front>
<title>Randomness Requirements for Security</title>
<author initials='D.' surname='Eastlake' fullname='D. Eastlake'>
<organization /></author>
<author initials='J.' surname='Schiller' fullname='J. Schiller'>
<organization /></author>
<author initials='S.' surname='Crocker' fullname='S. Crocker'>
<organization /></author>
<date year='2005' month='June' />
<abstract>
<t>Security systems are built on strong cryptographic algorithms that foil pattern analysis attempts. However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities. The use of pseudo-random processes to generate secret quantities can result in pseudo-security. A sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.&lt;/t>&lt;t> Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult. This document points out many pitfalls in using poor entropy sources or traditional pseudo-random number generation techniques for generating such quantities. It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose. It provides suggestions to ameliorate the problem when a hardware solution is not available, and it gives examples of how large such quantities need to be for some applications. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='106' />
<seriesInfo name='RFC' value='4086' />
<format type='TXT' octets='114321' target='ftp://ftp.rfc-editor.org/in-notes/rfc4086.txt' />
</reference>



<reference anchor='RFC4226'>

<front>
<title>HOTP: An HMAC-Based One-Time Password Algorithm</title>
<author initials='D.' surname='M&apos;Raihi' fullname='D. M&apos;Raihi'>
<organization /></author>
<author initials='M.' surname='Bellare' fullname='M. Bellare'>
<organization /></author>
<author initials='F.' surname='Hoornaert' fullname='F. Hoornaert'>
<organization /></author>
<author initials='D.' surname='Naccache' fullname='D. Naccache'>
<organization /></author>
<author initials='O.' surname='Ranen' fullname='O. Ranen'>
<organization /></author>
<date year='2005' month='December' />
<abstract>
<t>This document describes an algorithm to generate one-time password values, based on Hashed Message Authentication Code (HMAC). A security analysis of the algorithm is presented, and important parameters related to the secure deployment of the algorithm are discussed. The proposed algorithm can be used across a wide range of network applications ranging from remote Virtual Private Network (VPN) access, Wi-Fi network logon to transaction-oriented Web applications.&lt;/t>&lt;t> This work is a joint effort by the OATH (Open AuTHentication) membership to specify an algorithm that can be freely distributed to the technical community. The authors believe that a common and shared algorithm will facilitate adoption of two-factor authentication on the Internet by enabling interoperability across commercial and open-source implementations. This memo provides information for the Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='4226' />
<format type='TXT' octets='77117' target='ftp://ftp.rfc-editor.org/in-notes/rfc4226.txt' />
</reference>


      <reference anchor="SHA2" target="http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf">
        <front>
        <title>FIPS PUB 180-3: Secure Hash Standard (SHS)</title>
          <author>
            <organization>NIST</organization>
          </author>   
          <date month="October" year="2008" />
        </front>
      </reference>

    </references>

    <references title="Informative References">


      <reference anchor="CN" target="http://www.gemplus.com/smart/rd/publications/pdf/CN99maur.pdf">
        <front>
        <title>An accurate evaluation of Maurer's universal test</title>

          <author initials="J.S." surname="Coron">
            <organization>University of Luxembourg</organization>
          </author>

          <author initials="D." surname="Naccache">
            <organization>ENS</organization>
          </author>

          <date month="February" year="1999" />
        </front>
        <seriesInfo name="LNCS" value="1556" />
      </reference>

     <reference anchor="OATH" target="http://www.openauthentication.org/about">
        <front>
        <title>OATH Vision</title>
          <author>
            <organization>Initiative for Open Authentication</organization>
          </author>
        </front>
    </reference>



<reference anchor='RFC5056'>

<front>
<title>On the Use of Channel Bindings to Secure Channels</title>
<author initials='N.' surname='Williams' fullname='N. Williams'>
<organization /></author>
<date year='2007' month='November' />
<abstract>
<t>The concept of channel binding allows applications to establish that the two end-points of a secure channel at one network layer are the same as at a higher layer by binding authentication at the higher layer to the channel at the lower layer. This allows applications to delegate session protection to lower layers, which has various performance benefits.&lt;/t>&lt;t> This document discusses and formalizes the concept of channel binding to secure channels. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5056' />
<format type='TXT' octets='49995' target='ftp://ftp.rfc-editor.org/in-notes/rfc5056.txt' />
</reference>



<reference anchor='RFC5246'>

<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<date year='2008' month='August' />
<abstract>
<t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5246' />
<format type='TXT' octets='222395' target='ftp://ftp.rfc-editor.org/in-notes/rfc5246.txt' />
</reference>


     <reference anchor="UT" target="http://en.wikipedia.org/wiki/Unix_time">
        <front>
        <title>Unix time</title>
          <author>
            <organization>Wikipedia</organization>
          </author>
        </front>

    </reference>


<reference anchor='RFC6030'>

<front>
<title>Portable Symmetric Key Container (PSKC)</title>
<author initials='P.' surname='Hoyer' fullname='P. Hoyer'>
<organization /></author>
<author initials='M.' surname='Pei' fullname='M. Pei'>
<organization /></author>
<author initials='S.' surname='Machani' fullname='S. Machani'>
<organization /></author>
<date year='2010' month='October' />
<abstract>
<t>This document specifies a symmetric key format for the transport and provisioning of symmetric keys to different types of crypto modules.  For example, One-Time Password (OTP) shared secrets or symmetric cryptographic keys to strong authentication devices.  A standard key transport format enables enterprises to deploy best-of-breed solutions combining components from different vendors into the same infrastructure. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='6030' />
<format type='TXT' octets='123974' target='ftp://ftp.rfc-editor.org/in-notes/rfc6030.txt' />
</reference>




   </references>


    <!-- ////////////////////////////////////////////////////////////////////////////////// -->


    <section anchor="Section-Reference-Impl" title="Reference Implementation">
        <figure>
        <preamble/>
        <artwork><![CDATA[


<CODE BEGINS>

/**
   Copyright (c) 2011 IETF Trust and the persons identified as
   authors of the code. All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, is permitted pursuant to, and subject to the license
   terms contained in, the Simplified BSD License set forth in Section
   4.c of the IETF Trust's Legal Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info).
 */

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.math.BigInteger;

/**
 * This an example implementation of OCRA. 
 * Visit www.openauthentication.org for more information.
 * 
 * @author Johan Rydell, PortWise
 */
public class OCRA {

    private OCRA() {}

    /**
     * This method uses the JCE to provide the crypto
     * algorithm.
     * HMAC computes a Hashed Message Authentication Code with the
     * crypto hash algorithm as a parameter.
     *
     * @param crypto     the crypto algorithm (HmacSHA1, HmacSHA256, 
     * 					 HmacSHA512)
     * @param keyBytes   the bytes to use for the HMAC key
     * @param text       the message or text to be authenticated.
     */

    private static byte[] hmac_sha1(String crypto, 
                     byte[] keyBytes, byte[] text){
        Mac hmac = null;
        try {
            hmac = Mac.getInstance(crypto);
            SecretKeySpec macKey =
                new SecretKeySpec(keyBytes, "RAW");
            hmac.init(macKey);
            return hmac.doFinal(text);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }	


    private static final int[] DIGITS_POWER
    // 0 1  2   3    4     5      6       7        8                 
    = {1,10,100,1000,10000,100000,1000000,10000000,100000000 };

    /**
     * This method converts HEX string to Byte[]
     *
     * @param hex   the HEX string
     * 
     * @return      A byte array  
     */
    private static byte[] hexStr2Bytes(String hex){
        // Adding one byte to get the right conversion
        // values starting with "0" can be converted
        byte[] bArray = new BigInteger("10" + hex,16).toByteArray();	

        // Copy all the REAL bytes, not the "first"
        byte[] ret = new byte[bArray.length - 1];
        System.arraycopy(bArray, 1, ret, 0, ret.length);
        return ret;
    }


    /**
     * This method generates an OCRA HOTP value for the given
     * set of parameters.
     *
     * @param ocraSuite	   the OCRA Suite
     * @param key          the shared secret, HEX encoded
     * @param counter 	   the counter that changes on a per use  
     *                     basis, HEX encoded 
     * @param question     the challenge question, HEX encoded
     * @param password 	   a password that can be used, HEX encoded
     * @param sessionInformation Static information that identifies  
     *                     the current session, Hex encoded
     * @param timeStamp    a value that reflects a time 
     * 
     * @return A numeric String in base 10 that includes
     * {@link truncationDigits} digits 
     */
    static public String generateOCRA(String ocraSuite,
            String key,
            String counter,
            String question,
            String password,
            String sessionInformation,
            String timeStamp){
		
        int codeDigits = 0;
        String crypto = "";
        String result = null;
        int ocraSuiteLength = (ocraSuite.getBytes()).length;
        int counterLength = 0;
        int questionLength = 0;
        int passwordLength = 0;
        int sessionInformationLength = 0;
        int timeStampLength = 0;
		
        // The OCRASuites components
        String CryptoFunction = ocraSuite.split(":")[1];
        String DataInput = ocraSuite.split(":")[2];


        if(CryptoFunction.toLowerCase().indexOf("sha1") > 1) 
            crypto = "HmacSHA1";
        if(CryptoFunction.toLowerCase().indexOf("sha256") > 1) 
            crypto = "HmacSHA256";
        if(CryptoFunction.toLowerCase().indexOf("sha512") > 1) 
            crypto = "HmacSHA512";

        // How many digits should we return
        codeDigits = Integer.decode(CryptoFunction.substring(
                CryptoFunction.lastIndexOf("-")+1));

        // The size of the byte array message to be encrypted
        // Counter
        if(DataInput.toLowerCase().startsWith("c")) {
            // Fix the length of the HEX string
            while(counter.length() < 16)
                counter = "0" + counter;
            counterLength=8;
        }
        // Question - always 128 bytes
        if(DataInput.toLowerCase().startsWith("q") ||
                (DataInput.toLowerCase().indexOf("-q") >= 0)) {
            while(question.length() < 256)
                question = question + "0";
            questionLength=128;
        }

        // Password - sha1
        if(DataInput.toLowerCase().indexOf("psha1") > 1){
            while(password.length() < 40)
                password = "0" + password;
            passwordLength=20;
        }
		
        // Password - sha256
        if(DataInput.toLowerCase().indexOf("psha256") > 1){
            while(password.length() < 64)
                password = "0" + password;
            passwordLength=32;
        }
		
        // Password - sha512
        if(DataInput.toLowerCase().indexOf("psha512") > 1){
            while(password.length() < 128)
                password = "0" + password;
            passwordLength=64;
        }

        // sessionInformation - s064
        if(DataInput.toLowerCase().indexOf("s064") > 1){
            while(sessionInformation.length() < 128)
                sessionInformation = "0" + sessionInformation;
            sessionInformationLength=64;
        }
		
        // sessionInformation - s128
        if(DataInput.toLowerCase().indexOf("s128") > 1){
            while(sessionInformation.length() < 256)
                sessionInformation = "0" + sessionInformation;
            sessionInformationLength=128;
        }
		
        // sessionInformation - s256
        if(DataInput.toLowerCase().indexOf("s256") > 1){
            while(sessionInformation.length() < 512)
                sessionInformation = "0" + sessionInformation;
            sessionInformationLength=256;
        }
		
        // sessionInformation - s512
        if(DataInput.toLowerCase().indexOf("s512") > 1){
            while(sessionInformation.length() < 1024)
                sessionInformation = "0" + sessionInformation;
            sessionInformationLength=512;
        }

        // TimeStamp
        if(DataInput.toLowerCase().startsWith("t") ||
                (DataInput.toLowerCase().indexOf("-t") > 1)){
            while(timeStamp.length() < 16)
                timeStamp = "0" + timeStamp;
            timeStampLength=8;
        }

        // Remember to add "1" for the "00" byte delimiter
        byte[] msg = new byte[ocraSuiteLength +
                      counterLength +
                      questionLength + 
                      passwordLength + 
                      sessionInformationLength + 
                      timeStampLength +
                      1];


        // Put the bytes of "ocraSuite" parameters into the message
        byte[] bArray = ocraSuite.getBytes();
        System.arraycopy(bArray, 0, msg, 0, bArray.length);

        // Delimiter
        msg[bArray.length] = 0x00;

        // Put the bytes of "Counter" to the message
        // Input is HEX encoded
        if(counterLength > 0 ){
            bArray = hexStr2Bytes(counter);
            System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1, 
                    bArray.length);
        }


        // Put the bytes of "question" to the message
        // Input is text encoded
        if(questionLength > 0 ){
            bArray = hexStr2Bytes(question);
            System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 + 
                    counterLength, bArray.length);
        }

        // Put the bytes of "password" to the message
        // Input is HEX encoded
        if(passwordLength > 0){
            bArray = hexStr2Bytes(password);
            System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 + 
                    counterLength +    questionLength, bArray.length);
        }

        // Put the bytes of "sessionInformation" to the message
        // Input is text encoded
        if(sessionInformationLength > 0 ){
            bArray = hexStr2Bytes(sessionInformation);
            System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 + 
                    counterLength +	questionLength + 
                    passwordLength, bArray.length);
        }

        // Put the bytes of "time" to the message
        // Input is text value of minutes
        if(timeStampLength > 0){
            bArray = hexStr2Bytes(timeStamp);
            System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 + 
                    counterLength + questionLength + 
                    passwordLength + sessionInformationLength, 
                    bArray.length);
        }

        bArray = hexStr2Bytes(key);

        byte[] hash = hmac_sha1(crypto, bArray, msg);

        // put selected bytes into result int
        int offset = hash[hash.length - 1] & 0xf;

        int binary =
            ((hash[offset] & 0x7f) << 24) | 
            ((hash[offset + 1] & 0xff) << 16) | 
            ((hash[offset + 2] & 0xff) << 8) | 
            (hash[offset + 3] & 0xff);

        int otp = binary % DIGITS_POWER[codeDigits];

        result = Integer.toString(otp);
        while (result.length() < codeDigits) {
            result = "0" + result;
        }
        return result;
    }
}

<CODE ENDS>

            ]]></artwork>
            <postamble/>
    </figure>

    </section>

    <?rfc needLines="42" ?>

    <section anchor="Section-Test-Implementation" title="Test Vectors Generation">

    <figure>
        <preamble/>
        <artwork><![CDATA[




<CODE BEGINS>

/**
   Copyright (c) 2011 IETF Trust and the persons identified as
   authors of the code. All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, is permitted pursuant to, and subject to the license
   terms contained in, the Simplified BSD License set forth in Section
   4.c of the IETF Trust's Legal Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info).
 */

import java.math.BigInteger;
import java.util.*;
import java.text.DateFormat;
import java.text.SimpleDateFormat;

public class TestOCRA {

public static String asHex (byte buf[]) {
    StringBuffer strbuf = new StringBuffer(buf.length * 2);
    int i;

    for (i = 0; i < buf.length; i++) {
        if (((int) buf[i] & 0xff) < 0x10)
            strbuf.append("0");
        strbuf.append(Long.toString((int) buf[i] & 0xff, 16));
    }
    return strbuf.toString();
}

/**
 * @param args
 */
public static void main(String[] args) {

    String ocra = "";
    String seed = "";
    String ocraSuite = "";
    String counter = "";
    String password = "";
    String sessionInformation = "";
    String question = "";
    String qHex = "";
    String timeStamp = "";

    // PASS1234 is SHA1 hash of "1234"
    String PASS1234 = "7110eda4d09e062aa5e4a390b0a572ac0d2c0220";

    String SEED = "3132333435363738393031323334353637383930";
    String SEED32 = "31323334353637383930313233343536373839" +
        "30313233343536373839303132";
    String SEED64 = "31323334353637383930313233343536373839" +
        "3031323334353637383930313233343536373839" +
        "3031323334353637383930313233343536373839" +
        "3031323334";
    int STOP = 5;

    Date myDate = Calendar.getInstance().getTime();
    BigInteger b = new BigInteger("0");
    String sDate = "Mar 25 2008, 12:06:30 GMT";

    try{
        DateFormat df =
            new SimpleDateFormat("MMM dd yyyy, HH:mm:ss zzz");
        myDate = df.parse(sDate);
        b = new BigInteger("0" + myDate.getTime());
        b = b.divide(new BigInteger("60000"));


        System.out.println("Time of \"" + sDate + "\" is in");
        System.out.println("milli sec: " + myDate.getTime());
        System.out.println("minutes: " + b.toString());
        System.out.println("minutes (HEX encoded): "
            + b.toString(16).toUpperCase());
        System.out.println("Time of \"" + sDate
            + "\" is the same as this localized");
        System.out.println("time, \""
            + new Date(myDate.getTime()) + "\"");

        System.out.println();
        System.out.println("Standard 20Byte key: " +
            "3132333435363738393031323334353637383930");
        System.out.println("Standard 32Byte key: " +
            "3132333435363738393031323334353637383930");
        System.out.println("                     " +
            "313233343536373839303132");
        System.out.println("Standard 64Byte key: 313233343536373839" 
            + "3031323334353637383930");
        System.out.println("                     313233343536373839" 
            + "3031323334353637383930");
        System.out.println("                     313233343536373839" 
            + "3031323334353637383930");
        System.out.println("                     31323334");

        System.out.println();
        System.out.println("Plain challenge response");
        System.out.println("========================");
        System.out.println();

        ocraSuite = "OCRA-1:HOTP-SHA1-6:QN08";
        System.out.println(ocraSuite);
        System.out.println("=======================");
        seed = SEED;
        counter = "";
        question = "";
        password = "";
        sessionInformation = "";
        timeStamp = "";
        for(int i=0; i < 10; i++){
            question = "" + i + i + i + i + i + i + i + i;
            qHex = new String((new BigInteger(question,10))
                       .toString(16)).toUpperCase();
            ocra = OCRA.generateOCRA(ocraSuite,seed,counter,
                           qHex,password,
                           sessionInformation,timeStamp);
             System.out.println("Key: Standard 20Byte  Q: "
                    + question + "  OCRA: " + ocra);
        }
        System.out.println();

        ocraSuite = "OCRA-1:HOTP-SHA256-8:C-QN08-PSHA1";
        System.out.println(ocraSuite);
        System.out.println("=================================");
        seed = SEED32;
        counter = "";
        question = "12345678";
        password = PASS1234;
        sessionInformation = "";
        timeStamp = "";
        for(int i=0; i < 10; i++){
            counter = "" + i;
            qHex = new String((new BigInteger(question,10))
                       .toString(16)).toUpperCase();
            ocra = OCRA.generateOCRA(ocraSuite,seed,counter,
                       qHex,password,sessionInformation,timeStamp);
            System.out.println("Key: Standard 32Byte  C: "
                         + counter + "  Q: "
                         + question + "  PIN(1234): ");
            System.out.println(password + "  OCRA: " + ocra);
        }
        System.out.println();

        ocraSuite = "OCRA-1:HOTP-SHA256-8:QN08-PSHA1";
        System.out.println(ocraSuite);
        System.out.println("===============================");
        seed = SEED32;
        counter = "";
        question = "";
        password = PASS1234;
        sessionInformation = "";
        timeStamp = "";
        for(int i=0; i < STOP; i++){
            question = "" + i + i + i + i + i + i + i + i;

            qHex = new String((new BigInteger(question,10))
                        .toString(16)).toUpperCase();
            ocra = OCRA.generateOCRA(ocraSuite,seed,counter,
                     qHex,password,sessionInformation,timeStamp);
            System.out.println("Key: Standard 32Byte  Q: "
                        + question + "  PIN(1234): ");
            System.out.println(password + "  OCRA: " + ocra);
        }
        System.out.println();

        ocraSuite = "OCRA-1:HOTP-SHA512-8:C-QN08";
        System.out.println(ocraSuite);
        System.out.println("===========================");
        seed = SEED64;
        counter = "";
        question = "";
        password = "";
        sessionInformation = "";
        timeStamp = "";
        for(int i=0; i < 10; i++){
            question = "" + i + i + i + i + i + i + i + i;
            qHex = new String((new BigInteger(question,10))
                        .toString(16)).toUpperCase();
            counter = "0000" + i;
            ocra = OCRA.generateOCRA(ocraSuite,seed,counter,
                     qHex,password,sessionInformation,timeStamp);
            System.out.println("Key: Standard 64Byte  C: "
                     + counter + "  Q: "
                     + question + "  OCRA: " + ocra);
        }
        System.out.println();

        ocraSuite = "OCRA-1:HOTP-SHA512-8:QN08-T1M";
        System.out.println(ocraSuite);
        System.out.println("=============================");
        seed = SEED64;
        counter = "";
        question = "";
        password = "";
        sessionInformation = "";
        timeStamp = b.toString(16);
        for(int i=0; i < STOP; i++){
            question = "" + i + i + i + i + i + i + i + i;
            counter = "";
            qHex = new String((new BigInteger(question,10))
                        .toString(16)).toUpperCase();
            ocra = OCRA.generateOCRA(ocraSuite,seed,counter,
                     qHex,password,sessionInformation,timeStamp);

            System.out.println("Key: Standard 64Byte  Q: "
                        + question +"  T: "
  	                  + timeStamp.toUpperCase()
                        + "  OCRA: " + ocra);
        }
        System.out.println();

        System.out.println();
        System.out.println("Mutual Challenge Response");
        System.out.println("=========================");
        System.out.println();

        ocraSuite = "OCRA-1:HOTP-SHA256-8:QA08";
        System.out.println("OCRASuite (server computation) = "
                           + ocraSuite);
        System.out.println("OCRASuite (client computation) = "
                           + ocraSuite);
        System.out.println("===============================" +
            "===========================");
        seed = SEED32;
        counter = "";
        question = "";
        password = "";
        sessionInformation = "";
        timeStamp = "";
        for(int i=0; i < STOP; i++){
            question = "CLI2222" + i + "SRV1111" + i;
            qHex = asHex(question.getBytes());
            ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,
                         password,sessionInformation,timeStamp);
            System.out.println(
                     "(server)Key: Standard 32Byte  Q: "
                     + question + "  OCRA: "
                     + ocra);
            question = "SRV1111" + i + "CLI2222" + i;
            qHex = asHex(question.getBytes());
            ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,
                         password,sessionInformation,timeStamp);
            System.out.println(
                     "(client)Key: Standard 32Byte  Q: "
                     + question + "  OCRA: "
                     + ocra);
        }
        System.out.println();

        String ocraSuite1 = "OCRA-1:HOTP-SHA512-8:QA08";
        String ocraSuite2 = "OCRA-1:HOTP-SHA512-8:QA08-PSHA1";
        System.out.println("OCRASuite (server computation) = "
                           + ocraSuite1);
        System.out.println("OCRASuite (client computation) = "
                           + ocraSuite2);
        System.out.println("===============================" +
            "=================================");
        ocraSuite = "";
        seed = SEED64;
        counter = "";
        question = "";
        password = "";
        sessionInformation = "";
        timeStamp = "";
        for(int i=0; i < STOP; i++){
            ocraSuite = ocraSuite1;
            question = "CLI2222" + i + "SRV1111" + i;
            qHex = asHex(question.getBytes());
            password = "";
            ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,
                         password,sessionInformation,timeStamp);
            System.out.println(
                        "(server)Key: Standard 64Byte  Q: "
                        + question + "  OCRA: "
                        + ocra);
            ocraSuite = ocraSuite2;
            question = "SRV1111" + i + "CLI2222" + i;
            qHex = asHex(question.getBytes());
            password = PASS1234;
            ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,
                         password,sessionInformation,timeStamp);
            System.out.println("(client)Key: Standard 64Byte  Q: "
                         + question);
            System.out.println("P: " + password.toUpperCase()
                         + "  OCRA: " + ocra);
        }
        System.out.println();

        System.out.println();
        System.out.println("Plain Signature");
        System.out.println("===============");
        System.out.println();
        ocraSuite = "OCRA-1:HOTP-SHA256-8:QA08";
        System.out.println(ocraSuite);
        System.out.println("=========================");
        seed = SEED32;
        counter = "";
        question = "";
        password = "";
        sessionInformation = "";
        timeStamp = "";
        for(int i=0; i < STOP; i++){
            question = "SIG1" + i + "000";
            qHex = asHex(question.getBytes());
            ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,
                         password,sessionInformation,timeStamp);
            System.out.println(
                    "Key: Standard 32Byte  Q(Signature challenge): "
                    + question);
            System.out.println("   OCRA: " + ocra);
        }
        System.out.println();

        ocraSuite = "OCRA-1:HOTP-SHA512-8:QA10-T1M";
        System.out.println(ocraSuite);
        System.out.println("=============================");
        seed = SEED64;
        counter = "";
        question = "";
        password = "";
        sessionInformation = "";
        timeStamp = b.toString(16);
        for(int i=0; i < STOP; i++){
            question = "SIG1" + i + "00000";
            qHex = asHex(question.getBytes());
            ocra = OCRA.generateOCRA(ocraSuite,seed,counter,
                         qHex,password,sessionInformation,timeStamp);
            System.out.println(
                    "Key: Standard 64Byte  Q(Signature challenge): "
                    + question);
            System.out.println("   T: "
                    + timeStamp.toUpperCase() + "  OCRA: "
                    + ocra);
        }

    }catch (Exception e){
	      System.out.println("Error : " + e);
    }
}
}
<CODE ENDS>

            ]]></artwork>
            <postamble/>
    </figure>

    </section>

    <?rfc needLines="42" ?>


    <section anchor="Section-Test-Vectors" title="Test Vectors">
      <t>This section provides test values that can be used for the OCRA
      interoperability test.</t>


    Time of (Mar 25 2008, 12:06:30 GMT) is in
    (millis): 1206446790000 (min): 20107446 (HEX): 132d0b6
    Time of (Mar 25 2008, 12:06:30 GMT) is the same as this localized
    time: Tue Mar 25 05:06:30 PDT 2008

    <t>
    Standard 20Byte key:
    </t>
    <t>
    3132333435363738393031323334353637383930
    </t>
    <t>
    Standard 32Byte key:
    </t>
    <t>
    3132333435363738393031323334353637383930313233343536373839303132
    </t>
    <t>
    Standard 64Byte key:
    </t>
    <t>
    31323334353637383930313233343536373839303132333435363738393031323334353637383930313233343536373839303132333435363738393031323334
    </t>

    <t>PIN (1234) SHA1 hash value:</t>
    <t>7110eda4d09e062aa5e4a390b0a572ac0d2c0220</t>


    <section anchor="SectionPlainChallenge" title="One-Way Challenge Response">


    <texttable title="OCRA-1:HOTP-SHA1-6:QN08">
        <ttcol align="center">Key</ttcol>
        <ttcol align="center">Q</ttcol>
        <ttcol align="center">OCRA Value</ttcol>

    <c>Standard 20Byte</c>
    <c>00000000</c>
    <c>237653</c>

    <c>Standard 20Byte</c>
    <c>11111111</c>
    <c>243178</c>

    <c>Standard 20Byte</c>
    <c>22222222</c>
    <c>653583</c>

    <c>Standard 20Byte</c>
    <c>33333333</c>
    <c>740991</c>

    <c>Standard 20Byte</c>
    <c>44444444</c>
    <c>608993</c>

    <c>Standard 20Byte</c>
    <c>55555555</c>
    <c>388898</c>

    <c>Standard 20Byte</c>
    <c>66666666</c>
    <c>816933</c>

    <c>Standard 20Byte</c>
    <c>77777777</c>
    <c>224598</c>

    <c>Standard 20Byte</c>
    <c>88888888</c>
    <c>750600</c>

    <c>Standard 20Byte</c>
    <c>99999999</c>
    <c>294470</c>

    </texttable>

    <texttable title="OCRA-1:HOTP-SHA256-8:C-QN08-PSHA1">
        <ttcol align="center">Key</ttcol>
        <ttcol align="center">C</ttcol>
        <ttcol align="center">Q</ttcol>
        <ttcol align="center">OCRA Value</ttcol>

    <c>Standard 32Byte</c>
    <c>0</c>
    <c>12345678</c>
    <c>65347737</c>

    <c>Standard 32Byte</c>
    <c>1</c>
    <c>12345678</c>
    <c>86775851</c>

    <c>Standard 32Byte</c>
    <c>2</c>
    <c>12345678</c>
    <c>78192410</c>

    <c>Standard 32Byte</c>
    <c>3</c>
    <c>12345678</c>
    <c>71565254</c>

    <c>Standard 32Byte</c>
    <c>4</c>
    <c>12345678</c>
    <c>10104329</c>

    <c>Standard 32Byte</c>
    <c>5</c>
    <c>12345678</c>
    <c>65983500</c>

    <c>Standard 32Byte</c>
    <c>6</c>
    <c>12345678</c>
    <c>70069104</c>

    <c>Standard 32Byte</c>
    <c>7</c>
    <c>12345678</c>
    <c>91771096</c>

    <c>Standard 32Byte</c>
    <c>8</c>
    <c>12345678</c>
    <c>75011558</c>

    <c>Standard 32Byte</c>
    <c>9</c>
    <c>12345678</c>
    <c>08522129</c>

    </texttable>

    <texttable title="OCRA-1:HOTP-SHA256-8:QN08-PSHA1">
        <ttcol align="center">Key</ttcol>
        <ttcol align="center">Q</ttcol>
        <ttcol align="center">OCRA Value</ttcol>

    <c>Standard 32Byte</c>
    <c>00000000</c>
    <c>83238735</c>

    <c>Standard 32Byte</c>
    <c>11111111</c>
    <c>01501458</c>

    <c>Standard 32Byte</c>
    <c>22222222</c>
    <c>17957585</c>

    <c>Standard 32Byte</c>
    <c>33333333</c>
    <c>86776967</c>

    <c>Standard 32Byte</c>
    <c>44444444</c>
    <c>86807031</c>

    </texttable>

    <texttable title="OCRA-1:HOTP-SHA512-8:C-QN08">
        <ttcol align="center">Key</ttcol>
        <ttcol align="center">C</ttcol>
        <ttcol align="center">Q</ttcol>
        <ttcol align="center">OCRA Value</ttcol>


    <c>Standard 64Byte</c>
    <c>00000</c>
    <c>00000000</c>
    <c>07016083</c>

    <c>Standard 64Byte</c>
    <c>00001</c>
    <c>11111111</c>
    <c>63947962</c>

    <c>Standard 64Byte</c>
    <c>00002</c>
    <c>22222222</c>
    <c>70123924</c>

    <c>Standard 64Byte</c>
    <c>00003</c>
    <c>33333333</c>
    <c>25341727</c>

    <c>Standard 64Byte</c>
    <c>00004</c>
    <c>44444444</c>
    <c>33203315</c>

    <c>Standard 64Byte</c>
    <c>00005</c>
    <c>55555555</c>
    <c>34205738</c>

    <c>Standard 64Byte</c>
    <c>00006</c>
    <c>66666666</c>
    <c>44343969</c>

    <c>Standard 64Byte</c>
    <c>00007</c>
    <c>77777777</c>
    <c>51946085</c>

    <c>Standard 64Byte</c>
    <c>00008</c>
    <c>88888888</c>
    <c>20403879</c>

    <c>Standard 64Byte</c>
    <c>00009</c>
    <c>99999999</c>
    <c>31409299</c>

    </texttable>

    <texttable title="OCRA-1:HOTP-SHA512-8:QN08-T1M">
        <ttcol align="center">Key</ttcol>
        <ttcol align="center">Q</ttcol>
        <ttcol align="center">T</ttcol>
        <ttcol align="center">OCRA Value</ttcol>


    <c>Standard 64Byte</c>
    <c>00000000</c>
    <c>132d0b6</c>
    <c>95209754</c>

    <c>Standard 64Byte</c>
    <c>11111111</c>
    <c>132d0b6</c>
    <c>55907591</c>

    <c>Standard 64Byte</c>
    <c>22222222</c>
    <c>132d0b6</c>
    <c>22048402</c>

    <c>Standard 64Byte</c>
    <c>33333333</c>
    <c>132d0b6</c>
    <c>24218844</c>

    <c>Standard 64Byte</c>
    <c>44444444</c>
    <c>132d0b6</c>
    <c>36209546</c>

    </texttable>


    </section>


    <section anchor="SectionMutualChallenge" title="Mutual Challenge-Response">

    </section>

    <t>
    OCRASuite (server computation) = OCRA-1:HOTP-SHA256-8:QA08
    </t>
    <t>
    OCRASuite (client computation) = OCRA-1:HOTP-SHA256-8:QA08
    </t>

    <texttable title="Server -- OCRA-1:HOTP-SHA256-8:QA08">
        <ttcol align="center">Key</ttcol>
        <ttcol align="center">Q</ttcol>
        <ttcol align="center">OCRA Value</ttcol>

        <c>Standard 32Byte</c>
        <c>CLI22220SRV11110</c>
        <c>28247970</c>

        <c>Standard 32Byte</c>
        <c>CLI22221SRV11111</c>
        <c>01984843</c>

        <c>Standard 32Byte</c>
        <c>CLI22222SRV11112</c>
        <c>65387857</c>

        <c>Standard 32Byte</c>
        <c>CLI22223SRV11113</c>
        <c>03351211</c>

        <c>Standard 32Byte</c>
        <c>CLI22224SRV11114</c>
        <c>83412541</c>

    </texttable>


    <texttable title="Client -- OCRA-1:HOTP-SHA256-8:QA08">
        <ttcol align="center">Key</ttcol>
        <ttcol align="center">Q</ttcol>
        <ttcol align="center">OCRA Value</ttcol>

        <c>Standard 32Byte</c>
        <c>SRV11110CLI22220</c>
        <c>15510767</c>

        <c>Standard 32Byte</c>
        <c>SRV11111CLI22221</c>
        <c>90175646</c>

        <c>Standard 32Byte</c>
        <c>SRV11112CLI22222</c>
        <c>33777207</c>

        <c>Standard 32Byte</c>
        <c>SRV11113CLI22223</c>
        <c>95285278</c>

        <c>Standard 32Byte</c>
        <c>SRV11114CLI22224</c>
        <c>28934924</c>

    </texttable>

    <?rfc needLines="28" ?>


    <t>
    OCRASuite (server computation) = OCRA-1:HOTP-SHA512-8:QA08
    </t>
    <t>
    OCRASuite (client computation) = OCRA-1:HOTP-SHA512-8:QA08-PSHA1
    </t>

    <texttable title="Server -- OCRA-1:HOTP-SHA512-8:QA08">
        <ttcol align="center">Key</ttcol>
        <ttcol align="center">Q</ttcol>
        <ttcol align="center">OCRA Value</ttcol>

        <c>Standard 64Byte</c>
        <c>CLI22220SRV11110</c>
        <c>79496648</c>

        <c>Standard 64Byte</c>
        <c>CLI22221SRV11111</c>
        <c>76831980</c>

        <c>Standard 64Byte</c>
        <c>CLI22222SRV11112</c>
        <c>12250499</c>

        <c>Standard 64Byte</c>
        <c>CLI22223SRV11113</c>
        <c>90856481</c>

        <c>Standard 64Byte</c>
        <c>CLI22224SRV11114</c>
        <c>12761449</c>

    </texttable>

    <texttable title="Client -- OCRA-1:HOTP-SHA512-8:QA08-PSHA1">
        <ttcol align="center">Key</ttcol>
        <ttcol align="center">Q</ttcol>
        <ttcol align="center">OCRA Value</ttcol>

        <c>Standard 64Byte</c>
        <c>SRV11110CLI22220</c>
        <c>18806276</c>

        <c>Standard 64Byte</c>
        <c>SRV11111CLI22221</c>
        <c>70020315</c>

        <c>Standard 64Byte</c>
        <c>SRV11112CLI22222</c>
        <c>01600026</c>

        <c>Standard 64Byte</c>
        <c>SRV11113CLI22223</c>
        <c>18951020</c>

        <c>Standard 64Byte</c>
        <c>SRV11114CLI22224</c>
        <c>32528969</c>

    </texttable>

    <section anchor="SectionPlainSignature" title="Plain Signature">

    <t> In this mode of operation, Q represents the signature challenge.</t>

    <texttable title="OCRA-1:HOTP-SHA256-8:QA08">
        <ttcol align="center">Key</ttcol>
        <ttcol align="center">Q</ttcol>
        <ttcol align="center">OCRA Value</ttcol>

        <c>Standard 32Byte</c>
        <c>SIG10000</c>
        <c>53095496</c>

        <c>Standard 32Byte</c>
        <c>SIG11000</c>
        <c>04110475</c>

        <c>Standard 32Byte</c>
        <c>SIG12000</c>
        <c>31331128</c>

        <c>Standard 32Byte</c>
        <c>SIG13000</c>
        <c>76028668</c>

        <c>Standard 32Byte</c>
        <c>SIG14000</c>
        <c>46554205</c>

    </texttable>

    <texttable title=" OCRA-1:HOTP-SHA512-8:QA10-T1M">
        <ttcol align="center">Key</ttcol>
        <ttcol align="center">Q</ttcol>
        <ttcol align="center">T</ttcol>
        <ttcol align="center">OCRA Value</ttcol>

        <c>Standard 64Byte</c>
        <c>SIG1000000</c>
        <c>132d0b6</c>
        <c>77537423</c>

        <c>Standard 64Byte</c>
        <c>SIG1100000</c>
        <c>132d0b6</c>
        <c>31970405</c>

        <c>Standard 64Byte</c>
        <c>SIG1200000</c>
        <c>132d0b6</c>
        <c>10235557</c>

        <c>Standard 64Byte</c>
        <c>SIG1300000</c>
        <c>132d0b6</c>
        <c>95213541</c>

        <c>Standard 64Byte</c>
        <c>SIG1400000</c>
        <c>132d0b6</c>
        <c>65360607</c>

    </texttable>

    </section>


    </section>
</back>
</rfc>
