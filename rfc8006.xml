<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="std" number="8006" ipr="trust200902" submissionType="IETF"
     consensus="yes">

  <front>
    <title abbrev="CDN Interconnection Metadata">Content Delivery Network
    Interconnection (CDNI) Metadata</title>

    <author fullname="Ben Niven-Jenkins" initials="B" surname="Niven-Jenkins">
      <organization>Nokia</organization>
      <address>
        <postal>
          <street>3 Ely Road</street>
          <city>Milton</city>
          <region>Cambridge</region>
          <code>CB24 6DD</code>
          <country>United Kingdom</country>
        </postal>
        <email>ben.niven-jenkins@nokia.com</email>
      </address>
    </author>

    <author fullname="Rob Murray" initials="R" surname="Murray">
      <organization>Nokia</organization>
      <address>
        <postal>
          <street>3 Ely Road</street>
          <city>Milton</city>
          <region>Cambridge</region>
          <code>CB24 6DD</code>
          <country>United Kingdom</country>
        </postal>
        <email>rob.murray@nokia.com</email>
      </address>
    </author>

    <author fullname="Matt Caulfield" initials="M" surname="Caulfield">
      <organization>Cisco Systems</organization>
      <address>
        <postal>
          <street>1414 Massachusetts Avenue</street>
          <city>Boxborough</city>
          <region>MA</region>
          <code>01719</code>
          <country>United States of America</country>
        </postal>
        <phone>+1-978-936-9307</phone>
        <email>mcaulfie@cisco.com</email>
      </address>
    </author>

    <author fullname="Kevin J. Ma" initials="K.J." surname="Ma">
      <organization>Ericsson</organization>
      <address>
        <postal>
          <street>43 Nagog Park</street>
          <city>Acton</city>
          <region>MA</region>
          <code>01720</code>
          <country>United States of America</country>
        </postal>
        <phone>+1 978-844-5100</phone>
        <email>kevin.j.ma@ericsson.com</email>
      </address>
    </author>

    <date month="December" year="2016"/>

    <keyword>CDN</keyword>
    <keyword>cascaded CDN</keyword>
    <keyword>cascading CDNs</keyword>
    <keyword>content acquisition</keyword>
    <keyword>content delegation</keyword>
    <keyword>request delegation</keyword>
    <keyword>acquisition protocol</keyword>
    <keyword>delivery restriction</keyword>
    <keyword>delivery policy</keyword>
    <keyword>policy enforcement</keyword>
    <keyword>delivery protocol</keyword>
    <keyword>content expiration</keyword>
    <keyword>geo-fencing</keyword>
    <keyword>geofencing</keyword>
    <keyword>geo fencing</keyword>
    <keyword>geo-blocking</keyword>
    <keyword>geoblocking</keyword>
    <keyword>geo blocking</keyword>
    <keyword>footprint</keyword>
    <keyword>cache control</keyword>

    <abstract>
      <t>The Content Delivery Network Interconnection (CDNI) Metadata
      interface enables interconnected Content Delivery Networks (CDNs) to
      exchange content distribution metadata in order to enable content
      acquisition and delivery. The CDNI Metadata associated with a piece of
      content provides a downstream CDN with sufficient information for the
      downstream CDN to service content requests on behalf of an upstream CDN.
      This document describes both a base set of CDNI Metadata and the
      protocol for exchanging that metadata.</t>
    </abstract>

  </front>

  <middle>
    <section title="Introduction">
      <t>Content Delivery Network Interconnection (CDNI) <xref
      target="RFC6707"/> enables a downstream Content Delivery Network (dCDN)
      to service content requests on behalf of an upstream CDN (uCDN).</t>

      <t>The CDNI Metadata interface (MI) is discussed
      in <xref target="RFC7336"/> along with four other interfaces that
      can be used to compose a CDNI solution (the CDNI Control interface,
      the CDNI Request Routing Redirection interface,
      the CDNI Footprint &amp; Capabilities Advertisement interface (FCI),
      and the CDNI Logging interface). <xref target="RFC7336"/> describes
      each interface and the relationships between them. The
      requirements for the CDNI Metadata interface are specified in
      <xref target="RFC7337"/>.</t>

      <t>The CDNI Metadata associated with a piece of content (or with a set
      of content) provides a dCDN with sufficient information for servicing
      content requests on behalf of a uCDN, in accordance with the policies
      defined by the uCDN.</t>

      <t>This document defines a CDNI Metadata interface that enables a
      dCDN to obtain CDNI Metadata from a uCDN so that the dCDN can properly
      process and respond to:</t>

      <t><list style="symbols">
          <t>Redirection requests received over the CDNI Request Routing
          Redirection interface <xref
          target="RFC7975"/>.</t>

          <t>Content requests received directly from User Agents.</t>
        </list></t>

      <t>Specifically, this document defines:</t>

      <t><list style="symbols">
          <t>A data structure for mapping content requests and redirection
          requests to CDNI Metadata objects (Sections&nbsp;<xref
          target="data-model" format="counter"/> and
          <xref target="structural-objects" format="counter"/>).</t>

          <t>An initial set of CDNI GenericMetadata objects (<xref
          target="property-objects"/>).</t>

          <t>An HTTP web service for the transfer of CDNI Metadata (<xref
          target="metadata-interface"/>).</t>
        </list></t>

      <section anchor="terminology" title="Terminology">
        <t>This document reuses the terminology defined in <xref
        target="RFC6707"/>.</t>

        <t>Additionally, the following terms are used throughout this document
        and are defined as follows:<list style="symbols">
            <t>Object - a collection of properties.</t>

            <t>Property - a key and value pair where the key is a property
            name and the value is the property value or another object.</t>
          </list>This document uses the phrase "[Object] A contains [Object]
        B" for simplicity when a strictly accurate phrase would be "[Object] A
        contains or references (via a Link object) [Object] B".</t>

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref>.</t>

      </section>

      <section title="Supported Metadata Capabilities">
        <t>Only the metadata for a small set of initial capabilities is
        specified in this document. This set provides the minimum amount of
        metadata for basic CDN interoperability while still meeting the
        requirements set forth by <xref target="RFC7337"/>.</t>

        <t>The following high-level functionality can be configured via the
        CDNI Metadata objects specified in <xref
        target="abstract-metadata-description"/>:</t>

        <t><list style="symbols">
            <t>Acquisition Source: Metadata for allowing a dCDN to fetch
            content from a uCDN.</t>

            <t>Delivery Access Control: Metadata for restricting (or
            permitting) access to content based on any of the following
            factors:<list style="symbols">
                <t>Location</t>

                <t>Time window</t>

                <t>Delivery protocol</t>
              </list></t>
          </list><list style="symbols">
            <t>Delivery Authorization: Metadata for authorizing dCDN
            User Agent requests.</t>

            <t>Cache Control: Metadata for controlling cache behavior of the
            dCDN.</t>
          </list></t>

        <t>The metadata encoding described by this document is extensible in
        order to allow for future additions to this list.</t>

        <t>The set of metadata specified in this document covers the
        initial capabilities above.  It is only intended to support CDNI
        for the delivery of content by a dCDN using HTTP/1.1
        <xref target="RFC7230"/> and for a dCDN to be able to acquire content
        from a uCDN using either HTTP/1.1 or HTTP/1.1 over Transport Layer
        Security (TLS) <xref target="RFC2818"/>.</t>

        <t>Supporting CDNI for the delivery of content using
        unencrypted HTTP/2 <xref target="RFC7540"/> (as well as for a dCDN
        to acquire content using unencrypted HTTP/2 or HTTP/2 over TLS)
        requires the registration of these protocol names in the
        "CDNI Metadata Protocol Types" registry
        (<xref target="ProtocolReg"/>).</t>

        <t>Delivery of content using HTTP/1.1 over TLS or HTTP/2 over
        TLS SHOULD follow the guidelines set forth in <xref target="RFC7525"/>.
        Offline configuration of TLS parameters between CDNs is
        beyond the scope of this document.</t>
      </section>
    </section>

    <section title="Design Principles">
      <t>The CDNI Metadata interface was designed to achieve the following
      objectives:</t>

      <t><list style="numbers">
          <t>Cacheability of CDNI Metadata objects;</t>

          <t>Deterministic mapping from redirection requests and content
          requests to CDNI Metadata properties;</t>

          <t>Support for DNS redirection as well as application-specific
          redirection (for example, HTTP redirection);</t>

          <t>Minimal duplication of CDNI Metadata; and</t>

          <t>Leveraging of existing protocols.</t>
        </list></t>

      <t>Cacheability can decrease the latency of acquiring metadata while
      maintaining its freshness and can therefore decrease the latency of serving
      content requests and redirection requests, without sacrificing accuracy.
      The CDNI Metadata interface uses HTTP and its existing caching
      mechanisms to achieve CDNI Metadata cacheability.</t>

      <t>Deterministic mapping from content to metadata properties eliminates
      ambiguity and ensures that policies are applied consistently by all
      dCDNs.</t>

      <t>Support for both HTTP and DNS redirection ensures that the CDNI
      Metadata
      meets the same design principles for both HTTP-based and DNS-based
      redirection schemes.</t>

      <t>Minimal duplication of CDNI Metadata improves storage efficiency
      in the CDNs.</t>

      <t>Leveraging existing protocols avoids reinventing common mechanisms
      such as data structure encoding (by leveraging I-JSON (Internet JSON)
      <xref target="RFC7493"/>) and data transport (by leveraging HTTP <xref
      target="RFC7230"/>).</t>
    </section>

    <section anchor="data-model" title="CDNI Metadata Object Model">
      <t>The CDNI Metadata object model describes a data structure for mapping
      redirection requests and content requests to metadata properties.
      Metadata properties describe how to acquire content from a uCDN,
      authorize access to content, and deliver content from a dCDN. The object
      model relies on the assumption that these metadata properties can be
      grouped based on the hostname of the content and subsequently on the
      resource path (URI) of the content. The object model associates a set of
      CDNI Metadata properties with a hostname to form a default set of
      metadata properties for content delivered on behalf of that hostname.
      That default set of metadata properties can be overridden by properties
      that apply to specific paths within a URI.</t>

      <t>Different hostnames and URI paths will be associated with different
      sets of CDNI Metadata properties in order to describe the required
      behavior when a dCDN Surrogate or request router is processing User
      Agent requests for content at that hostname and URI path. As a result of
      this structure, significant commonality could exist between the CDNI
      Metadata properties specified for different hostnames, different URI
      paths within a hostname, and different URI paths on different hostnames.
      For example, the definition of which User Agent IP addresses should be
      grouped together into a single network or geographic
      location is likely to be common for a number of different hostnames;
      although a uCDN is likely to have several different policies
      configured to express geo-blocking rules, it is likely that a
      single geo-blocking policy could be applied to multiple hostnames
      delivered through the CDN.</t>

      <t>In order to enable the CDNI Metadata for a given hostname and
      URI path to be decomposed into reusable sets of CDNI Metadata properties,
      the CDNI Metadata interface splits the CDNI Metadata into separate
      objects. Efficiency is improved by enabling a single CDNI Metadata
      object (that is shared across hostnames and/or URI paths) to be retrieved
      and stored by a dCDN once, even if it is referenced by the CDNI Metadata
      for multiple hostnames and/or URI paths.</t>

      <t>Important Note: Any CDNI Metadata object A that contains another CDNI
      Metadata object B can 
      include a Link object specifying a URI that can be
      used to retrieve object B, 
      instead of embedding object B within object A.
      The remainder of this document uses the phrase
      "[Object] A contains [Object] B" for simplicity when a strictly accurate
      phrase would be "[Object] A contains or references (via a Link object)
      [Object] B". It is generally a deployment choice for the uCDN
      implementation to decide when to embed CDNI Metadata objects
      and when to reference separate resources via Link objects.</t>

      <t><xref target="hostindex-intro"/> introduces a high-level description
      of the HostIndex, HostMatch, HostMetadata, PathMatch, PatternMatch, and
      PathMetadata objects, and describes the relationships between them.</t>

      <t><xref target="other-objects-intro"/> introduces a high-level
      description of the CDNI GenericMetadata object, which represents the
      level at which CDNI Metadata override occurs between HostMetadata and
      PathMetadata objects.</t>

      <t><xref target="abstract-metadata-description"/> describes in detail
      the specific CDNI Metadata objects and properties specified by this
      document that can be contained within a CDNI GenericMetadata
      object.</t>

      <section anchor="hostindex-intro"
               title="HostIndex, HostMatch, HostMetadata, PathMatch, PatternMatch, and PathMetadata Objects">
        <t>The relationships between the HostIndex, HostMatch, HostMetadata,
        PathMatch, PatternMatch, and PathMetadata objects are described in
        <xref target="metadata-model-figure-top"/>.</t>

        <figure anchor="metadata-model-figure-top"
                title="Relationships between CDNI Metadata Objects
(Diagram&nbsp;Representation)">
          <artwork><![CDATA[
+---------+      +---------+      +------------+
|HostIndex+-(*)->|HostMatch+-(1)->|HostMetadata+-------(*)------+
+---------+      +---------+      +------+-----+                |
                                         |                      |
                                        (*)                     |
                                         |                      V
--> Contains or references               V         *****************
(1) One and only one                +---------+    *GenericMetadata*
(*) Zero or more               +--->|PathMatch|    *     Objects   *
                               |    +----+---++    *****************
                               |         |   |                  ^
                              (*)       (1) (1) +------------+  |
                               |         |   +->|PatternMatch|  |
                               |         V      +------------+  |
                               |  +------------+                |
                               +--+PathMetadata+-------(*)------+
                                  +------------+
]]></artwork>
        </figure>

        <t>A HostIndex object (see <xref target="HostIndex"/>)
        contains an array
        of HostMatch objects (see <xref target="HostMatch"/>) that contain
        hostnames (and/or IP addresses) for which content requests might be
        delegated to the dCDN. The HostIndex is the starting point for
        accessing the uCDN CDNI Metadata data store. It enables the dCDN to
        deterministically discover which CDNI Metadata objects it requires
        in order to deliver a given piece of content.</t>

        <t>The HostIndex links hostnames (and/or IP addresses) to HostMetadata
        objects (see <xref target="HostMetadata"/>) via HostMatch objects. A
        HostMatch object defines a hostname (or IP address) to match against a
        requested host and contains a HostMetadata object.</t>

        <t>HostMetadata objects contain the default
        GenericMetadata objects (see <xref target="generic-metadata"/>)
        required to serve content for that host. When looking up CDNI
        Metadata, the dCDN looks up the requested hostname (or IP address)
        against the HostMatch entries in the HostIndex; from there,
        it can find HostMetadata, which describes the default metadata
        properties for each host as well as PathMetadata objects
        (see <xref target="PathMetadata"/>), via
        PathMatch objects (see <xref target="PathMatch"/>). PathMatch objects
        define patterns, contained inside PatternMatch objects (see <xref
        target="PatternMatch"/>), to match against the requested URI
        path. PatternMatch objects contain the pattern strings and
        flags that describe the URI path to which a PathMatch applies.
        PathMetadata objects contain the GenericMetadata objects
        that apply to content requests matching the defined URI
        path pattern.  PathMetadata properties override properties
        previously defined in HostMetadata or less&nbhy;specific PathMatch
        paths.  PathMetadata objects can contain additional PathMatch
        objects to recursively define more&nbhy;specific URI paths to which
        GenericMetadata properties might be applied.</t>

        <t>A GenericMetadata object contains individual CDNI Metadata objects
        that define the specific policies and attributes needed to properly
        deliver the associated content. For example, a GenericMetadata object
        could describe the source from which a CDN can acquire a piece of
        content. The GenericMetadata object is an atomic unit that can be
        referenced by HostMetadata or PathMetadata objects.</t>

        <t>For example, if "example.com" is a content provider, a HostMatch
        object could include an entry for "example.com" with the URI of the
        associated HostMetadata object. The HostMetadata object for
        "example.com" describes the metadata properties that apply to
        "example.com" and could contain PathMatches for
        "example.com&wj;/movies/*" and "example.com/music/*", which
        in turn reference corresponding PathMetadata objects that
        contain the properties for those more&nbhy;specific URI paths. The
        PathMetadata object for "example.com/movies/*" describes the
        properties that apply to that URI path.  It could also contain a
        PathMatch object for "example.com/movies/hd/*", which would
        reference the corresponding PathMetadata object for the
        "example.com/movies/hd/" path prefix.</t>

        <t>The relationships in <xref target="metadata-model-figure-top"/> are
        also represented in tabular format in <xref
        target="metadata-model-table"/> below.</t>

<?rfc compact="no"?>
        <texttable anchor="metadata-model-table"
            title="Relationships between CDNI Metadata Objects
(Table Representation)">
          <ttcol>Data Object</ttcol>
          <ttcol>Objects it contains or references</ttcol>

          <c>HostIndex</c>
          <c>0 or more HostMatch objects.</c>

          <c>HostMatch</c>
          <c>1 HostMetadata object.</c>

          <c>HostMetadata</c>
          <c>0 or more PathMatch objects.  0 or more GenericMetadata
          objects.</c>

          <c>PathMatch</c>
          <c>1 PatternMatch object.  1 PathMetadata object.</c>

          <c>PatternMatch</c>
          <c>Does not contain or reference any other objects.</c>

          <c>PathMetadata</c>
          <c>0 or more PathMatch objects.  0 or more GenericMetadata
          objects.</c>
        </texttable>
<?rfc compact="yes"?>

      </section>

      <section anchor="other-objects-intro"
               title="Generic CDNI Metadata Objects">
        <t>The HostMetadata and PathMetadata objects contain other CDNI
        Metadata objects that contain properties that describe how User Agent
        requests for content should be processed -- for example, where to
        acquire the content from, authorization rules that should be applied,
        geo&nbhy;blocking restrictions, and so on. Each such CDNI Metadata
        object is a specialization of a CDNI GenericMetadata object. The
        GenericMetadata object abstracts the basic information required for
        metadata override and metadata distribution, from the specifics of
        any given property (i.e., property semantics, enforcement options,
        etc.).</t>

        <t>The GenericMetadata object defines the properties contained
        within it as well as whether or not the properties are
        "mandatory-to-enforce". If the dCDN does not understand or
        support a mandatory-to-enforce property, the dCDN MUST NOT serve
        the content. If the property is not mandatory-to-enforce, then
        that GenericMetadata object can be safely ignored and the
        content request can be processed in accordance with the rest of
        the CDNI Metadata.</t>

        <t>Although a CDN MUST NOT serve content to a User Agent if a
        mandatory&nbhy;to&nbhy;enforce property cannot be enforced, it could
        still be safe to redistribute that metadata (the
        "safe&nbhy;to&nbhy;redistribute" property) to another
        CDN without modification. For example, in
        the cascaded CDN case, a transit CDN (tCDN) could convey
        mandatory&nbhy;to&nbhy;enforce metadata to a dCDN.
        For metadata that does not require customization or translation (i.e.,
        metadata that is safe&nbhy;to&nbhy;redistribute), the data
        representation received off the wire MAY be stored and redistributed
        without being understood or supported by the tCDN. However, for
        metadata that requires translation, transparent redistribution of the
        uCDN metadata values might not be appropriate. Certain metadata can be
        safely, though perhaps not optimally, redistributed unmodified. For
        example, a source acquisition address might not be optimal if
        transparently redistributed, but it might still work.</t>

        <t>Redistribution safety MUST be specified for each
        GenericMetadata property.
        If a CDN does not understand or support a given GenericMetadata
        property that is not safe-to-redistribute, the CDN MUST set the
        "incomprehensible" flag to true for that GenericMetadata object
        before redistributing the metadata. The
        "incomprehensible" flag signals to a dCDN that the metadata was not
        properly transformed by the tCDN. A CDN MUST NOT attempt to use
        metadata that has been marked as "incomprehensible" by a uCDN.</t>

        <t>tCDNs MUST NOT change the value of mandatory-to-enforce
        or safe&nbhy;to&nbhy;redistribute when propagating metadata to a dCDN.
        Although a tCDN can set the value of "incomprehensible" to true,
        a tCDN MUST&nbsp;NOT change the value of "incomprehensible" from
        true to false.</t>

        <t><xref target="tcdn-actions"/> describes the action to be taken by a
        tCDN for the different combinations of mandatory-to-enforce
        ("MtE") and safe&nbhy;to&nbhy;redistribute ("StR") properties when
        the tCDN either does or does not understand the metadata in
        question:</t>

<?rfc compact="no"?>
        <texttable anchor="tcdn-actions"
                   title="Action to Be Taken by a tCDN for the Different Combinations of MtE and StR Properties">
          <ttcol>MtE</ttcol>

          <ttcol>StR</ttcol>

          <ttcol>Metadata Understood by tCDN</ttcol>

          <ttcol>Action</ttcol>

          <c>False</c>

          <c>True</c>

          <c>True</c>

          <c>Can serve and redistribute.</c>

          <c>False</c>

          <c>True</c>

          <c>False</c>

          <c>Can serve and redistribute.</c>

          <c>False</c>

          <c>False</c>

          <c>False</c>

          <c>Can serve.  MUST set "incomprehensible" to true when
          redistributing.</c>

          <c>False</c>

          <c>False</c>

          <c>True</c>

          <c>Can serve.  Can redistribute after transforming the
          metadata (if the CDN knows how to do so safely); otherwise, MUST set
          "incomprehensible" to true when redistributing.</c>

          <c>True</c>

          <c>True</c>

          <c>True</c>

          <c>Can serve and redistribute.</c>

          <c>True</c>

          <c>True</c>

          <c>False</c>

          <c>MUST NOT serve but can redistribute.</c>

          <c>True</c>

          <c>False</c>

          <c>True</c>

          <c>Can serve.  Can redistribute after transforming the
          metadata (if the CDN knows how to do so safely); otherwise, MUST set
          "incomprehensible" to true when redistributing.</c>

          <c>True</c>

          <c>False</c>

          <c>False</c>

          <c>MUST NOT serve.  MUST set "incomprehensible" to true when
          redistributing.</c>
        </texttable>
<?rfc compact="yes"?>

        <t><xref target="dcdn-actions"/> describes the action to be taken by a
        dCDN for the different combinations of mandatory-to-enforce
        and "incomprehensible" (Incomp) properties, when the dCDN either does
        or does not understand the metadata in question:</t>

<?rfc compact="no"?>
        <texttable anchor="dcdn-actions"
                   title="Action to Be Taken by a dCDN for the Different Combinations of MtE and Incomp Properties">
          <ttcol>MtE</ttcol>
          <ttcol>Incomp</ttcol>
          <ttcol>Metadata Understood by dCDN</ttcol>
          <ttcol>Action</ttcol>

          <c>False</c>
          <c>False</c>
          <c>True</c>
          <c>Can serve.</c>

          <c>False</c>
          <c>True</c>
          <c>True</c>
          <c>Can serve but MUST NOT interpret/apply any metadata
          marked as "incomprehensible".</c>

          <c>False</c>
          <c>False</c>
          <c>False</c>
          <c>Can serve.</c>

          <c>False</c>
          <c>True</c>
          <c>False</c>
          <c>Can serve but MUST NOT interpret/apply any metadata
          marked as "incomprehensible".</c>

          <c>True</c>
          <c>False</c>
          <c>True</c>
          <c>Can serve.</c>

          <c>True</c>
          <c>True</c>
          <c>True</c>
          <c>MUST NOT serve.</c>

          <c>True</c>
          <c>False</c>
          <c>False</c>
          <c>MUST NOT serve.</c>

          <c>True</c>
          <c>True</c>
          <c>False</c>
          <c>MUST NOT serve.</c>
        </texttable>
<?rfc compact="yes"?>

        <t/>
      </section>

      <section anchor="metadata-inheritance"
               title="Metadata Inheritance and Override">
        <t>In the metadata object model, a HostMetadata object can contain
        multiple PathMetadata objects (via PathMatch objects). Each
        PathMetadata object can in turn contain other PathMetadata objects.
        HostMetadata and PathMetadata objects form an inheritance tree where
        each node in the tree inherits or overrides the property values set by
        its parent.</t>

        <t>GenericMetadata objects of a given type override all
        GenericMetadata objects of the same type previously defined by any
        parent object in the tree. GenericMetadata objects of a given type
        previously defined by a parent object in the tree are inherited when
        no object of the same type is defined by the child object. For
        example, if HostMetadata for the host "example.com" contains
        GenericMetadata objects of types LocationACL and TimeWindowACL
        (where "ACL" means "Access Control List") while a PathMetadata object
        that applies to "example.com/movies/*" defines an
        alternate GenericMetadata object of type TimeWindowACL, then: <list
            style="symbols">
            <t>The TimeWindowACL defined in the PathMetadata would override
            the TimeWindowACL defined in the HostMetadata for all User Agent
            requests for content under "example.com/movies/", and</t>

            <t>The LocationACL defined in the HostMetadata would be inherited
            for all User Agent requests for content under
            "example.com/movies/".</t>
          </list></t>

        <t>A single HostMetadata or PathMetadata object MUST NOT contain
        multiple GenericMetadata objects of the same type. If an array of
        GenericMetadata contains objects of duplicate types, the receiver MUST
        ignore all but the first object of each type.</t>
      </section>
    </section>

    <section anchor="abstract-metadata-description"
             title="CDNI Metadata Objects">
      <t><xref target="structural-objects"/> provides the definitions of each
      metadata object type introduced in <xref target="data-model"/>. These
      metadata objects are described as structural metadata objects, as they
      provide the structure for host and URI path-based inheritance and
      identify which GenericMetadata objects apply to a given User Agent
      content request.</t>

      <t><xref target="property-objects"/> provides the definitions for a base
      set of core metadata objects that can be contained within a
      GenericMetadata object. These metadata objects govern how User Agent
      requests for content are handled. GenericMetadata objects can contain
      other GenericMetadata objects as properties; these can be referred to as
      sub-objects. As with all CDNI Metadata objects, the
      value of the GenericMetadata sub&nbhy;objects can be either a complete
      serialized representation of the sub-object or a Link object that
      contains a URI that can be dereferenced to retrieve the complete
      serialized representation of the property sub-object.</t>

      <t><xref target="extensibility"/> discusses the ability to extend the
      base set of GenericMetadata objects specified in this document with
      additional standards-based or vendor-specific GenericMetadata objects
      that might be defined in the future in separate documents.</t>

      <t>dCDNs and tCDNs MUST support the parsing of all CDNI Metadata objects
      specified in this document. A dCDN does not have to implement the
      underlying functionality represented by non-structural GenericMetadata
      objects (though that might restrict the content that a given dCDN
      will be able to serve). &nbsp;uCDNs as generators of CDNI Metadata only
      need to support generating the CDNI Metadata that they need in order
      to express the policies required by the content they are describing.
      See <xref target="Encoding"/> for more details on the
      specific encoding rules for CDNI Metadata objects.</t>

      <t>Note: In the following sections, the term "mandatory-to-specify" is
      used to convey which properties MUST be included for a given structural
      or GenericMetadata object. When mandatory-to-specify is specified as
      "Yes" for an individual property, it means that if the
      object containing that property is included in a metadata response, then
      the mandatory-to-specify property MUST also be included (directly or by
      reference) in the response. For example, a HostMatch property object
      without a host to match against does not make sense; therefore, the
      "host" property is mandatory-to-specify inside a HostMatch object.</t>

      <section anchor="structural-objects"
               title="Definitions of the CDNI Structural Metadata Objects">
        <t>The subsections below describe the structural objects
        introduced in <xref target="hostindex-intro"/>.</t>

        <section anchor="HostIndex" title="HostIndex">
          <t>The HostIndex object is the entry point into the CDNI Metadata
          hierarchy. It contains an array of HostMatch objects. An incoming
          content request is checked against the hostname (or IP address)
          specified by each of the listed HostMatch objects to find the
          HostMatch object that applies to the request.</t>

          <t><list style="empty">
              <t>Property: hosts<list style="empty">
                  <t>Description: Array of HostMatch objects. Hosts (HostMatch
                  objects) MUST be evaluated in the order they appear, and the
                  first HostMatch object that matches the content request
                  being processed MUST be used.</t>

                  <t>Type: Array of HostMatch objects</t>

                  <t>Mandatory-to-Specify: Yes.</t>
                </list></t>
            </list></t>

          <t>Example HostIndex object containing two HostMatch objects, where
          the first HostMatch object is embedded and the second HostMatch
          object is referenced:</t>

          <figure>
            <artwork><![CDATA[{
  "hosts": [
    {
      <Properties of embedded HostMatch object>
    },
    {
      "type": "MI.HostMatch",
      "href": "https://metadata.ucdn.example/hostmatch1234"
    }
  ]
}]]></artwork>
          </figure>
        </section>

        <section anchor="HostMatch" title="HostMatch">
          <t>The HostMatch object contains a hostname or IP address to match
          against content requests. The HostMatch object also contains a
          HostMetadata object to apply if a match is found.</t>

          <t><list style="empty">
              <t>Property: host<list style="empty">
                  <t>Description: Hostname or IP address and optional
                  port to match against the requested host, i.e., the 
                  host and port as described in <xref target="RFC3986"/>.
                  In order for a hostname or IP address in a content request
                  to match the hostname or IP address in the
                  "host" property, the value from the content request when
                  converted to lowercase MUST be identical to the
                  value of the "host" property when converted to lowercase.
                  All implementations MUST support IPv4 addresses
                  encoded as specified by the "IPv4address" rule in
                  Section&nbsp;3.2.2 of <xref target="RFC3986"/>. IPv6
                  addresses MUST be encoded in one of the IPv6 address
                  formats specified in <xref target="RFC5952"/>,
                  although receivers MUST support all IPv6 address
                  formats specified in <xref target="RFC4291"/>. 
                  Hostnames MUST conform to the Domain Name System
                  (DNS) syntax defined in <xref target="RFC1034"/> 
                  and <xref target="RFC1123"/>. Internationalized
                  Domain Names (IDNs) must first be transformed to
                  the A-label form <xref target="RFC5890"/>
                  as per <xref target="RFC5891"/>.</t>

                  <t>Type: Endpoint</t>

                  <t>Mandatory-to-Specify: Yes.</t>
                </list></t>
            </list> <list style="empty">
              <t>Property: host-metadata<list style="empty">
                  <t>Description: CDNI Metadata to apply when delivering
                  content that matches this host.</t>

                  <t>Type: HostMetadata</t>

                  <t>Mandatory-to-Specify: Yes.</t>
                </list></t>
            </list></t>

          <t>Example HostMatch object with an embedded HostMetadata
          object:</t>

          <figure>
            <artwork><![CDATA[{
  "host": "video.example.com",
  "host-metadata": {
    <Properties of embedded HostMetadata object>
  }
}
]]></artwork>
          </figure>

          <t/>

          <t>Example HostMatch object referencing (via a Link object; see
          <xref target="Link"/>) a HostMetadata object:</t>

          <figure>
            <artwork><![CDATA[{
  "host": "video.example.com",
  "host-metadata": {
    "type": "MI.HostMetadata",
    "href": "https://metadata.ucdn.example/host1234"
  }
}
]]></artwork>
          </figure>
        </section>

        <section anchor="HostMetadata" title="HostMetadata">
          <t>A HostMetadata object contains the CDNI Metadata properties for
          content served for a particular host (defined in the HostMatch
          object) and possibly child PathMatch objects.</t>

          <t><list style="empty">
              <t>Property: metadata<list style="empty">
                  <t>Description: Array of host-related metadata.</t>

                  <t>Type: Array of GenericMetadata objects</t>

                  <t>Mandatory-to-Specify: Yes.</t>
                </list></t>
            </list> <list style="empty">
              <t>Property: paths<list style="empty">
                  <t>Description: Path-specific rules. Path patterns
                  (PathMatch objects) MUST be evaluated in the order they
                  appear, and the first (and only the first)
                  PathMatch object that matches the content request
                  being processed MUST be used.</t>

                  <t>Type: Array of PathMatch objects</t>

                  <t>Mandatory-to-Specify: No. Default is that there
                  are no more&nbhy;specific paths to evaluate (i.e., an
                  empty list).</t>
                </list></t>
            </list></t>

          <t>Example HostMetadata object containing a number of embedded
          GenericMetadata objects that will describe the default metadata for
          the host and an embedded PathMatch object that contains a
          path for which metadata exists that overrides the default metadata
          for the host:</t>

          <figure>
            <artwork><![CDATA[{
  "metadata": [
    {
      <Properties of first embedded GenericMetadata object>
    },
    {
      <Properties of second embedded GenericMetadata object>
    },

 ... 

    {
      <Properties of Nth embedded GenericMetadata object>
    }
  ],
  "paths": [
    {
      <Properties of embedded PathMatch object>
    }
  ]
}]]></artwork>
          </figure>
        </section>

        <section anchor="PathMatch" title="PathMatch">
          <t>A PathMatch object contains a PatternMatch
          object with a path to match against a resource's URI path,
          as well as how to handle URI query parameters.  The
          PathMatch object also contains a PathMetadata object with
          GenericMetadata to apply if the resource's URI matches the 
          pattern within the PatternMatch object.</t>

          <t><list style="empty">
              <t>Property: path-pattern<list style="empty">
                  <t>Description: Pattern to match against the requested
                  resource's&nbsp;URI.</t>

                  <t>Type: PatternMatch</t>

                  <t>Mandatory-to-Specify: Yes.</t>
                </list></t>
            </list> <list style="empty">
              <t>Property: path-metadata<list style="empty">
                  <t>Description: CDNI Metadata to apply when delivering
                  content that matches the associated PatternMatch.</t>

                  <t>Type: PathMetadata</t>

                  <t>Mandatory-to-Specify: Yes.</t>
                </list></t>
            </list></t>

          <t>Example PathMatch object referencing the PathMetadata object to
          use for URIs that match the case-sensitive URI path pattern
          "/movies/*" (contained within an embedded PatternMatch object):</t>

          <figure>
            <artwork><![CDATA[{
  "path-pattern": {
    "pattern": "/movies/*",
    "case-sensitive": true
  },
  "path-metadata": {
      "type": "MI.PathMetadata",
      "href": "https://metadata.ucdn.example/host1234/pathDCE"
  }
}
]]></artwork>
          </figure>
        </section>

        <section anchor="PatternMatch" title="PatternMatch">
          <t>A PatternMatch object contains the pattern string and flags that
          describe the pattern expression.</t>

          <t><list style="empty">
              <t>Property: pattern<list style="empty">
                  <t>Description: A pattern for matching against the
                  URI path, i.e., against the path-absolute
                  <xref target="RFC3986"/>. The pattern can contain
                  the wildcards "*" and "?", where "*" matches any
                  sequence of pchar <xref target="RFC3986"/> or "/"
                  characters (including the empty string)
                  and "?" matches exactly one pchar character. The
                  three literals "$", "*", and "?" MUST be
                  escaped as "$$", "$*", and "$?" (where "$" is the
                  designated escape character). All other characters
                  are treated as literals.</t>

                  <t>Type: String</t>

                  <t>Mandatory-to-Specify: Yes.</t>
                </list></t>
            </list> <list style="empty">
              <t>Property: case-sensitive<list style="empty">
                  <t>Description: Flag indicating whether or not
                  case-sensitive matching should be used.  Note:
                  Case insensitivity applies to ALPHA characters in
                  the URI path prior to percent-decoding 
                  <xref target="RFC3986"/>.</t>

                  <t>Type: Boolean</t>

                  <t>Mandatory-to-Specify: No. Default is case-insensitive
                  match (i.e., a value of False).</t>
                </list></t>
            </list></t>

          <t>Example PatternMatch object that matches the case-sensitive URI
          path pattern "/movies/*":</t>

          <figure>
            <artwork><![CDATA[{
  "pattern": "/movies/*",
  "case-sensitive": true
}
]]></artwork>
          </figure>

        </section>

        <section anchor="PathMetadata" title="PathMetadata">
          <t>A PathMetadata object contains the CDNI Metadata properties for
          content requests that match against the associated URI path (defined
          in a PathMatch object).</t>

          <t>Note that if DNS-based redirection is employed, then a dCDN will
          be unable to evaluate any metadata at the PathMetadata level or
          below because only the hostname of the content request is available
          at Request Routing time. &nbsp;dCDNs SHOULD still process all
          PathMetadata for the host before responding to the redirection
          request to detect if any unsupported metadata is specified.
          If any metadata not supported by the dCDN is marked as
          mandatory-to-enforce, the dCDN SHOULD NOT accept the content
          redirection request, in order to avoid receiving content requests
          that it will not be able to satisfy/serve.</t>

          <t><list style="empty">
              <t>Property: metadata<list style="empty">
                  <t>Description: Array of path-related metadata.</t>

                  <t>Type: Array of GenericMetadata objects</t>

                  <t>Mandatory-to-Specify: Yes.</t>
                </list></t>
            </list> <list style="empty">
              <t>Property: paths<list style="empty">
                  <t>Description: Path-specific rules. Path patterns
                  (PathMatch objects) MUST be evaluated in the order they
                  appear, and the first (and only the first)
                  PathMatch object that matches the content request
                  being processed MUST be used.</t>

                  <t>Type: Array of PathMatch objects</t>

                  <t>Mandatory-to-Specify: No. Default is that there
                  are no more&nbhy;specific paths to evaluate (i.e., an
                  empty list).</t>
                </list></t>
            </list></t>

          <t>Example PathMetadata object containing a number of embedded
          GenericMetadata objects that describe the metadata to apply for the
          URI path defined in the parent PathMatch object, as well as
          a more&nbhy;specific PathMatch object.</t>

          <figure>
            <artwork><![CDATA[{
  "metadata": [
    {
      <Properties of first embedded GenericMetadata object>
    },
    {
      <Properties of second embedded GenericMetadata object>
    },

 ... 

    {
      <Properties of Nth embedded GenericMetadata object>
    }
  ],
  "paths": [
    {
      <Properties of embedded PathMatch object>
    }
  ]
}]]></artwork>
          </figure>
        </section>

        <section anchor="generic-metadata" title="GenericMetadata">
          <t>A GenericMetadata object is a wrapper for managing individual
          CDNI Metadata properties in an opaque manner.</t>

          <t><list style="empty">
              <t>Property: generic-metadata-type<list style="empty">
                  <t>Description: Case-insensitive CDNI Metadata object
                  type.</t>

                  <t>Type: String containing the CDNI Payload Type 
                  <xref target="RFC7736"/> of the object
                  contained in the generic-metadata-value property
                  (see <xref target="metadata-payload-types-table"/>).</t>

                  <t>Mandatory-to-Specify: Yes.</t>
                </list></t>
            </list> <list style="empty">
              <t>Property: generic-metadata-value<list style="empty">
                  <t>Description: CDNI Metadata object.</t>

                  <t>Type: Format/Type is defined by the value of the
                  generic&nbhy;metadata&nbhy;type property above.
                  Note:&nbsp;generic&nbhy;metadata&nbhy;values MUST NOT name
                  any properties "href" (see <xref target="Link"/>).</t>

                  <t>Mandatory-to-Specify: Yes.</t>
                </list></t>
            </list> <list style="empty">
              <t>Property: mandatory-to-enforce<list style="empty">
                  <t>Description: Flag identifying whether or not the
                  enforcement of the property metadata is required.</t>

                  <t>Type: Boolean</t>

                  <t>Mandatory-to-Specify: No. Default is to treat metadata as
                  mandatory-to-enforce (i.e., a value of True).</t>
                </list></t>
            </list> <list style="empty">
              <t>Property: safe-to-redistribute<list style="empty">
                  <t>Description: Flag identifying whether or not the property
                  metadata can be safely redistributed without
                  modification.</t>

                  <t>Type: Boolean</t>

                  <t>Mandatory-to-Specify: No. Default is to allow transparent
                  redistribution (i.e., a value of True).</t>
                </list></t>
            </list> <list style="empty">
              <t>Property: incomprehensible<list style="empty">
                  <t>Description: Flag identifying whether or not any CDN in
                  the chain of delegation has failed to understand and/or
                  failed to properly transform this metadata object. Note:
                  This flag only applies to metadata objects whose
                  safe-to-redistribute property has a value of False.</t>

                  <t>Type: Boolean</t>

                  <t>Mandatory-to-Specify: No. Default is comprehensible
                  (i.e., a value of False).</t>
                </list></t>
            </list></t>

          <t>Example GenericMetadata object containing a metadata object that
          applies to the applicable URI path and/or host (within a parent
          PathMetadata and/or HostMetadata object, respectively):</t>

          <figure>
            <artwork><![CDATA[{
  "mandatory-to-enforce": true,
  "safe-to-redistribute": true,
  "incomprehensible": false,
  "generic-metadata-type": <CDNI Payload Type of this metadata object>,
  "generic-metadata-value":
    {
      <Properties of this metadata object>
    }
}]]></artwork>
          </figure>
        </section>
      </section>

      <section anchor="property-objects"
               title="Definitions of the Initial Set of CDNI GenericMetadata Objects">
        <t>The objects defined below are intended to be used in the
        GenericMetadata object's generic-metadata-value field as defined in
        <xref target="generic-metadata"/>, and their generic-metadata-type
        property MUST be set to the appropriate CDNI Payload Type as
        defined in <xref target="metadata-payload-types-table"/>.</t>

        <section anchor="SourceMetadata" title="SourceMetadata">
          <t>Source metadata provides the dCDN with information
          about content acquisition, i.e., how to contact a uCDN Surrogate
          or an origin server to obtain the content to be served. The
          sources are not necessarily the actual origin servers operated by
          the Content Service Provider (CSP) but might be a set of
          Surrogates in the uCDN.</t>

          <t><list style="empty">
              <t>Property: sources<list style="empty">
                  <t>Description: Sources from which the dCDN can acquire
                  content, listed in order of preference.</t>

                  <t>Type: Array of Source objects (see <xref
                  target="Source"/>)</t>

                  <t>Mandatory-to-Specify: No. Default is to use
                  static configuration, out-of-band from the
                  CDNI Metadata interface.</t>
                </list></t>
            </list></t>

          <t>Example SourceMetadata object (which contains two Source objects)
          that describes which servers the dCDN should use for acquiring
          content for the applicable URI path and/or host:</t>

          <figure>
            <artwork><![CDATA[{
  "generic-metadata-type": "MI.SourceMetadata",
  "generic-metadata-value":
    {
      "sources": [
        {
          "endpoints": [
            "a.service123.ucdn.example",
            "b.service123.ucdn.example"
            ],
          "protocol": "http/1.1"
        },
        {
          "endpoints": ["origin.service123.example"],
          "protocol": "http/1.1"
        }
      ]
    }
}]]></artwork>
          </figure>

          <t/>

          <section anchor="Source" title="Source">
            <t>A Source object describes the source to be used by the dCDN for
            content acquisition (e.g., a Surrogate within the uCDN or an
            alternate origin server), the protocol to be used, and any
            authentication method to be used when contacting that source.</t>

            <t>Endpoints within a Source object MUST be treated as
            equivalent/equal.  A uCDN can specify an array of sources,
            ordered by preference, within a SourceMetadata object. Then,
            for each Source object ranked by preference, a uCDN can
            specify an array of endpoints that are equivalent (e.g., a pool of
            servers that are not behind a load balancer).</t>

            <t><list style="empty">
                <t>Property: acquisition-auth<list style="empty">
                    <t>Description: Authentication method to use when
                    requesting content from this source.</t>

                    <t>Type: Auth (see <xref target="Auth"/>)</t>

                    <t>Mandatory-to-Specify: No. Default is no authentication
                    required.</t>
                  </list></t>
              </list> <list style="empty">
                <t>Property: endpoints<list style="empty">
                    <t>Description: Origins from which the dCDN can acquire
                    content. If multiple endpoints are specified, they are
                    all equal, i.e., the list is not ordered by preference.</t>

                    <t>Type: Array of Endpoint objects (see <xref
                    target="Endpoint"/>)</t>

                    <t>Mandatory-to-Specify: Yes.</t>
                  </list></t>
              </list> <list style="empty">
                <t>Property: protocol<list style="empty">
                    <t>Description: Network retrieval protocol to use when
                    requesting content from this source.</t>

                    <t>Type: Protocol (see <xref target="Protocol"/>)</t>

                    <t>Mandatory-to-Specify: Yes.</t>
                  </list></t>
              </list></t>

            <t>Example Source object that describes a pair of endpoints
            (servers) the dCDN can use for acquiring content for the
            applicable host and/or URI path:</t>

            <figure>
              <artwork><![CDATA[{
  "endpoints": [
    "a.service123.ucdn.example",
    "b.service123.ucdn.example"
  ],
  "protocol": "http/1.1"
}]]></artwork>
            </figure>

            <t/>
          </section>
        </section>

        <section anchor="LocationACL" title="LocationACL Metadata">
          <t>LocationACL metadata defines which locations a User Agent needs
          to be in, in order to be able to receive the associated content.</t>

          <t>A LocationACL that does not include a "locations" property results
          in an action of "allow all", meaning that delivery can be performed
          regardless of the User Agent's location; otherwise, a CDN
          MUST take the action from the first
          footprint to match against the User Agent's location.
          If two or more footprints overlap, the first
          footprint that matches against the User Agent's location determines
          the action a CDN MUST take. If the "locations" property is included
          but is empty or if none of the listed footprints match the User
          Agent's location, then the result is an action of "deny".</t>

          <t>Although the LocationACL, TimeWindowACL (see <xref
          target="TimeWindowACL"/>), and ProtocolACL (see <xref
          target="ProtocolACL"/>) are independent GenericMetadata objects,
          they can provide conflicting information to a dCDN, e.g., a content
          request that is simultaneously allowed based on the LocationACL and
          denied based on the TimeWindowACL. The dCDN MUST use the logical AND
          of all ACLs (where "allow" is true and "deny" is false) to determine
          whether or not a request should be allowed.</t>

          <t><list style="empty">
              <t>Property: locations<list style="empty">
                  <t>Description: ACL that allows or denies (blocks)
                  delivery based on the User Agent's location.</t>

                  <t>Type: Array of LocationRule objects (see <xref
                  target="LocationRule"/>)</t>

                  <t>Mandatory-to-Specify: No. Default is to allow all
                  locations.</t>
                </list></t>
            </list></t>

          <t>Example LocationACL object that allows the dCDN to deliver
          content to any location / IP address:</t>

          <figure>
            <artwork><![CDATA[{
  "generic-metadata-type": "MI.LocationACL",
  "generic-metadata-value":
    {
    }
}]]></artwork>
          </figure>

          <t>Example LocationACL object (which contains a LocationRule object
          that in turn contains a Footprint object) that only allows the dCDN
          to deliver content to User Agents in the USA:</t>

          <figure>
            <artwork><![CDATA[{
  "generic-metadata-type": "MI.LocationACL",
  "generic-metadata-value":
    {
      "locations": [
        {
          "action": "allow",
          "footprints": [
            {
              "footprint-type": "countrycode",
              "footprint-value": ["us"]
            }
          ]
        }
      ]
    }
}]]></artwork>
          </figure>

          <t/>

          <section anchor="LocationRule" title="LocationRule">
            <t>A LocationRule contains or references an array of Footprint
            objects and the corresponding action.</t>

            <t><list style="empty">
                <t>Property: footprints<list style="empty">
                    <t>Description: Array of footprints to which the rule
                    applies.</t>

                    <t>Type: Array of Footprint objects (see <xref
                    target="Footprint"/>)</t>

                    <t>Mandatory-to-Specify: Yes.</t>
                  </list></t>
              </list> <list style="empty">
                <t>Property: action<list style="empty">
                    <t>Description: Defines whether the rule specifies
                    locations to allow or deny.</t>

                    <t>Type: Enumeration [allow|deny] encoded as a lowercase
                    string</t>

                    <t>Mandatory-to-Specify: No. Default is "deny".</t>
                  </list></t>
              </list></t>

            <t>Example LocationRule object (which contains a Footprint object)
            that allows the dCDN to deliver content to clients in the USA:</t>

            <figure>
              <artwork><![CDATA[{
  "action": "allow",
  "footprints": [
    {
      "footprint-type": "countrycode",
      "footprint-value": ["us"]
    }
  ]
}]]></artwork>
            </figure>
          </section>

          <section anchor="Footprint" title="Footprint">
            <t>A Footprint object describes the footprint to which a
            LocationRule can be applied, e.g., an IPv4 address range or a
            geographic location.</t>

            <t><list style="empty">
                <t>Property: footprint-type<list style="empty">
                    <t>Description: Registered footprint type (see
                    <xref target="FootprintReg"/>). The footprint
                    types specified by this document are "ipv4cidr"
                    (IPv4CIDR; see <xref target="IPv4CIDR"/>), "ipv6cidr"
                    (IPv6CIDR; see <xref target="IPv6CIDR"/>), "asn"
                    (Autonomous System Number; see <xref target="ASN"/>), and
                    "countrycode" (Country Code; see <xref
                    target="CountryCode"/>).</t>

                    <t>Type: Lowercase string</t>

                    <t>Mandatory-to-Specify: Yes.</t>
                  </list></t>
              </list> <list style="empty">
                <t>Property: footprint-value<list style="empty">
                    <t>Description: Array of footprint values conforming to the
                    specification associated with the registered footprint
                    type.  Footprint values can be simple strings
                    (e.g., IPv4CIDR, IPv6CIDR, ASN, and Country Code);
                    however, other Footprint objects can be defined in the
                    future, along with a more complex encoding
                    (e.g., GPS coordinate tuples).</t>

                    <t>Type: Array of footprints</t>

                    <t>Mandatory-to-Specify: Yes.</t>
                  </list></t>
              </list></t>

            <t>Example Footprint object describing a footprint covering the
            USA:</t>

            <figure>
              <artwork><![CDATA[{
  "footprint-type": "countrycode",
  "footprint-value": ["us"]
}]]></artwork>
            </figure>

            <t/>

            <t>Example Footprint object describing a footprint covering the IP
            address ranges 192.0.2.0/24 and 198.51.100.0/24:</t>

            <figure>
              <artwork><![CDATA[{
  "footprint-type": "ipv4cidr",
  "footprint-value": ["192.0.2.0/24", "198.51.100.0/24"]
}]]></artwork>
            </figure>

            <t/>

            <t>Example Footprint object describing a footprint covering the IP
            address ranges 2001:db8::/32:</t>

            <figure>
              <artwork><![CDATA[{
  "footprint-type": "ipv6cidr",
  "footprint-value": ["2001:db8::/32"]
}]]></artwork>
            </figure>

            <t/>

            <t>Example Footprint object describing a footprint covering the
            autonomous system 64496:</t>

            <figure>
              <artwork><![CDATA[{
  "footprint-type": "asn",
  "footprint-value": ["as64496"]
}]]></artwork>
            </figure>
          </section>
        </section>

        <section anchor="TimeWindowACL" title="TimeWindowACL">
          <t>TimeWindowACL metadata defines time-based restrictions.</t>

          <t>A TimeWindowACL that does not include a "times" property results
          in an action of "allow all", meaning that delivery can be performed
          regardless of the time of the User Agent's request;
          otherwise, a CDN MUST take the action from
          the first window to match against the current time.
          If two or more windows overlap, the first window that
          matches against the current time determines the action a CDN MUST
          take. If the "times" property is included but is empty or if none of
          the listed windows match the current time, then the result is an
          action of "deny".</t>

          <t>Although the LocationACL (see <xref
          target="LocationACL"/>), TimeWindowACL, and ProtocolACL (see <xref
          target="ProtocolACL"/>) are
          independent GenericMetadata objects, they can provide conflicting
          information to a dCDN, e.g., a content request that is
          simultaneously allowed based on the LocationACL and denied based on
          the TimeWindowACL. The dCDN MUST use the logical AND of all ACLs
          (where "allow" is true and "deny" is false) to determine whether or
          not a request should be allowed.</t>

          <t><list style="empty">
              <t>Property: times<list style="empty">
                  <t>Description: ACL that allows or denies (blocks)
                  delivery based on the time of a User Agent's request.</t>

                  <t>Type: Array of TimeWindowRule objects (see <xref
                  target="TimeWindowRule"/>)</t>

                  <t>Mandatory-to-Specify: No. Default is to allow all time
                  windows.</t>
                </list></t>
            </list></t>

          <t>Example TimeWindowACL object (which contains a TimeWindowRule
          object that in turn contains a TimeWindow object) that only allows
          the dCDN to deliver content to clients between 09:00 01/01/2000
          UTC and 17:00 01/01/2000 UTC:</t>

          <figure>
            <artwork><![CDATA[{
  "generic-metadata-type": "MI.TimeWindowACL",
  "generic-metadata-value":
    {
      "times": [
        {
          "action": "allow",
          "windows": [
            {
              "start": 946717200,
              "end": 946746000
            }
          ]
        }
      ]
    }
}]]></artwork>
          </figure>

          <section anchor="TimeWindowRule" title="TimeWindowRule">
            <t>A TimeWindowRule contains or references an array of TimeWindow
            objects and the corresponding action.</t>

            <t><list style="empty">
                <t>Property: windows<list style="empty">
                    <t>Description: Array of time windows to which the rule
                    applies.</t>

                    <t>Type: Array of TimeWindow objects (see <xref
                    target="TimeWindow"/>)</t>

                    <t>Mandatory-to-Specify: Yes.</t>
                  </list></t>
              </list> <list style="empty">
                <t>Property: action<list style="empty">
                    <t>Description: Defines whether the rule specifies time
                    windows to allow or deny.</t>

                    <t>Type: Enumeration [allow|deny] encoded as a lowercase
                    string</t>

                    <t>Mandatory-to-Specify: No. Default is "deny".</t>
                  </list></t>
              </list></t>

            <t>Example TimeWindowRule object (which contains a TimeWindow
            object) that only allows the dCDN to deliver content to clients
            between 09:00 01/01/2000 UTC and 17:00 01/01/2000 UTC:</t>

            <figure>
              <artwork><![CDATA[{
  "action": "allow",
  "windows": [
    {
      "start": 946717200,
      "end": 946746000
    }
  ]
}]]></artwork>
            </figure>
          </section>

          <section anchor="TimeWindow" title="TimeWindow">
            <t>A TimeWindow object describes a time range that can be applied
            by a TimeWindowACL, e.g., start 946717200 (i.e., 09:00
            01/01/2000 UTC), end: 946746000 (i.e., 17:00 01/01/2000
            UTC).</t>

            <t><list style="empty">
                <t>Property: start<list style="empty">
                    <t>Description: The start time of the window.</t>

                    <t>Type: Time (see <xref target="Time"/>)</t>

                    <t>Mandatory-to-Specify: Yes.</t>
                  </list></t>
              </list> <list style="empty">
                <t>Property: end<list style="empty">
                    <t>Description: The end time of the window.</t>

                    <t>Type: Time (see <xref target="Time"/>)</t>

                    <t>Mandatory-to-Specify: Yes.</t>
                  </list></t>
              </list></t>

            <t>Example TimeWindow object that describes a time window from
            09:00 01/01/2000 UTC to 17:00 01/01/2000 UTC:</t>

            <figure>
              <artwork><![CDATA[{
  "start": 946717200,
  "end": 946746000
}
]]></artwork>
            </figure>
          </section>
        </section>

        <section anchor="ProtocolACL" title="ProtocolACL Metadata">
          <t>ProtocolACL metadata defines delivery protocol restrictions.</t>

          <t>A ProtocolACL that does not include a protocol-acl property
          results in an action of "allow all", meaning that delivery can be
          performed regardless of the protocol in the User Agent's request;
          otherwise, a CDN MUST take the action from the first protocol
          to match against the request protocol. If two or more request
          protocols overlap, the first protocol that matches the request
          protocol determines the action a CDN MUST take. If the protocol-acl
          property is included but is empty or if none of the listed protocols
          match the request protocol, then the result is an action of
          "deny".</t>

          <t>Although the LocationACL (see <xref
          target="LocationACL"/>), TimeWindowACL (see <xref
          target="TimeWindowACL"/>), and ProtocolACL are
          independent GenericMetadata objects, they can provide conflicting
          information to a dCDN, e.g., a content request that is
          simultaneously allowed based on the ProtocolACL and denied based on
          the TimeWindowACL. The dCDN MUST use the logical AND of all ACLs
          (where "allow" is true and "deny" is false) to determine whether or
          not a request should be allowed.</t>

          <t><list style="empty">
              <t>Property: protocol-acl<list style="empty">
                  <t>Description: ACL that allows or denies (blocks)
                  delivery based on delivery protocol.</t>

                  <t>Type: Array of ProtocolRule objects (see <xref
                  target="ProtocolRule"/>)</t>

                  <t>Mandatory-to-Specify: No. Default is to allow all
                  protocols.</t>
                </list></t>
            </list></t>

          <t>Example ProtocolACL object (which contains a ProtocolRule object)
          that only allows the dCDN to deliver content using HTTP/1.1:</t>

          <figure>
            <artwork><![CDATA[{
  "generic-metadata-type": "MI.ProtocolACL",
  "generic-metadata-value":
    {
      "protocol-acl": [
        {
          "action": "allow",
          "protocols": ["http/1.1"]
        }
      ]
    }
}]]></artwork>
          </figure>

          <section anchor="ProtocolRule" title="ProtocolRule">
            <t>A ProtocolRule contains or references an array of Protocol
            objects and the corresponding action.</t>

            <t><list style="empty">
                <t>Property: protocols<list style="empty">
                    <t>Description: Array of protocols to which the rule
                    applies.</t>

                    <t>Type: Array of Protocol objects (see <xref
                    target="Protocol"/>)</t>

                    <t>Mandatory-to-Specify: Yes.</t>
                  </list></t>
              </list> <list style="empty">
                <t>Property: action<list style="empty">
                    <t>Description: Defines whether the rule specifies
                    protocols to allow or deny.</t>

                    <t>Type: Enumeration [allow|deny] encoded as a lowercase
                    string</t>

                    <t>Mandatory-to-Specify: No. Default is "deny".</t>
                  </list></t>
              </list></t>

            <t>Example ProtocolRule object (which contains a Protocol object)
            that allows the dCDN to deliver content using HTTP/1.1:</t>

            <figure>
              <artwork><![CDATA[{
  "action": "allow",
  "protocols": ["http/1.1"]
}
]]></artwork>
            </figure>
          </section>
        </section>

        <section anchor="DeliveryAuthorization"
                 title="DeliveryAuthorization Metadata">
          <t>Delivery authorization defines authorization methods for the
          delivery of content to User Agents.</t>

          <t><list style="empty">
              <t>Property: delivery-auth-methods<list style="empty">
                  <t>Description: Options for authorizing content requests.
                  Delivery for a content request is authorized if any one
                  of the authorization methods in the list is satisfied
                  for that request.</t>

                  <t>Type: Array of Auth objects (see <xref
                  target="Auth"/>)</t>

                  <t>Mandatory-to-Specify: No. Default is no authorization
                  required.</t>
                </list></t>
            </list></t>

          <t>Example DeliveryAuthorization object (which contains
          an Auth object):</t>

          <figure>
            <artwork><![CDATA[{
  "generic-metadata-type": "MI.DeliveryAuthorization",
  "generic-metadata-value":
    {
      "delivery-auth-methods": [
        {
          "auth-type": <CDNI Payload Type of this Auth object>,
          "auth-value":
          {
            <Properties of this Auth object>
          }
        }
      ]
    }
}]]></artwork>
          </figure>
        </section>

        <section anchor="Cache" title="Cache">
          <t>A Cache object describes the cache control parameters to be
          applied to the content by intermediate caches.</t>

          <t>Cache keys are generated from the URI of the content
          request <xref target="RFC7234"/>.  In some cases, a CDN or
          content provider might want certain path segments or query
          parameters to be excluded from the cache key generation.
          The Cache object provides guidance on what parts of the
          path and query string to include.</t> 

          <t><list style="empty">
              <t>Property: exclude-path-pattern<list style="empty">
                  <t>Description: A pattern for matching against the 
                  URI path, i.e., against the path-absolute
                  <xref target="RFC3986"/>. The pattern can contain
                  the wildcards "*" and "?", where "*" matches any
                  sequence of pchar <xref target="RFC3986"/> or "/"
                  characters (including the empty string)
                  and "?" matches exactly one pchar character. The
                  three literals "$", "*", and "?" MUST be
                  escaped as "$$", "$*", and "$?" (where "$" is the
                  designated escape character). All other characters
                  are treated as literals. Cache key generation MUST
                  only include the portion of the path-absolute that
                  matches the wildcard portions of the pattern.
                  Note: Inconsistency between the PatternMatch pattern
                  (<xref target="PatternMatch"/>) and the
                  exclude&nbhy;path&nbhy;pattern can result in inefficient
                  caching.</t>

                  <t>Type: String</t>

                  <t>Mandatory-to-Specify: No. Default is to use the
                  full URI path&nbhy;absolute to generate the cache key.</t>
                </list></t>
            </list> <list style="empty">
              <t>Property: include-query-strings<list style="empty">
                  <t>Description: Allows a Surrogate to specify the
                  URI query string parameters <xref target="RFC3986"/>
                  to include when comparing the requested URI against
                  the URIs in its cache for equivalence. Matching
                  query parameters MUST be case insensitive. If all
                  query parameters should be ignored, then the list MUST be
                  specified and MUST be empty.  If a query parameter
                  appears multiple times in the query string, each
                  instance value MUST be aggregated prior to
                  comparison.  For consistent cache key generation,
                  query parameters SHOULD be evaluated in the order
                  specified in this array.</t>

                  <t>Type: Array of strings</t>

                  <t>Mandatory-to-Specify: No. Default is to consider all query
                  string parameters when comparing URIs.</t>
                </list></t>
            </list></t>

          <t>Example Cache object that instructs the dCDN to use the
          full URI path and ignore all query parameters:</t>

          <figure>
            <artwork><![CDATA[{
  "generic-metadata-type": "MI.Cache",
  "generic-metadata-value":
  {
    "include-query-strings": []
  }
}
]]></artwork>
          </figure>

          <t/>

          <t>Example Cache object that instructs the dCDN to exclude
          the "CDNX" path prefix and only
          include the (case-insensitive) query parameters named
          "mediaid" and "providerid":</t>

          <figure>
            <artwork><![CDATA[{
  "generic-metadata-type": "MI.Cache",
  "generic-metadata-value":
  {
    "exclude-path-pattern": "/CDNX/*",
    "include-query-strings": ["mediaid", "providerid"]
  }
}
]]></artwork>
          </figure>

          <t>Example Cache object that instructs the dCDN to exclude
          the "CDNX" path prefix but includes all query parameters:</t>

          <figure>
            <artwork><![CDATA[{
  "generic-metadata-type": "MI.Cache",
  "generic-metadata-value":
  {
    "exclude-path-pattern": "/CDNX/*"
  }
}
]]></artwork>
          </figure>
        </section>

        <section anchor="Auth" title="Auth">
          <t>An Auth object defines authentication and authorization methods
          to be used during content acquisition and content delivery,
          respectively.</t>

          <t>Note: This document does not define any Auth methods.
          Individual Auth methods are being defined separately (e.g.,
          URI Signing <xref target="CDNI-URI-SIGNING"/>).
          The GenericMetadata object that contains Auth objects
          is defined herein for convenience and so as not to be
          specific to any particular Auth method.</t>

          <t><list style="empty">
              <t>Property: auth-type<list style="empty">
                  <t>Description: Auth type (The CDNI Payload Type 
                  <xref target="RFC7736"/> of the GenericMetadata
                  object contained in the auth-value property).</t>

                  <t>Type: String</t>

                  <t>Mandatory-to-Specify: Yes.</t>
                </list></t>
            </list> <list style="empty">
              <t>Property: auth-value<list style="empty">
                  <t>Description: An object conforming to the specification
                  associated with the Auth type.</t>

                  <t>Type: GenericMetadata object</t>

                  <t>Mandatory-to-Specify: Yes.</t>
                </list></t>
            </list></t>

          <t>Example Auth object:</t>

          <figure>
            <artwork><![CDATA[{
  "generic-metadata-type": "MI.Auth",
  "generic-metadata-value":
  {
    "auth-type": <CDNI Payload Type of this Auth object>,
    "auth-value":
      {
        <Properties of this Auth object>
      }
  }
}
]]></artwork>
          </figure>

        </section>

        <section anchor="Grouping" title="Grouping">
          <t>A Grouping object identifies a group of content to which a
          given asset belongs.</t>

          <t><list style="empty">
              <t>Property: ccid<list style="empty">
                  <t>Description: Content Collection IDentifier for an
                  application-specific purpose such as logging aggregation.</t>

                  <t>Type: String</t>

                  <t>Mandatory-to-Specify: No. Default is not to apply
                  any grouping.</t>
                </list></t>
            </list></t>

          <t>Example Grouping object that specifies a Content Collection
          IDentifier for the content associated with
          the Grouping object's parent HostMetadata and PathMetadata:</t>

          <figure>
            <artwork><![CDATA[{
  "generic-metadata-type": "MI.Grouping",
  "generic-metadata-value":
  {
    "ccid": "ABCD"
  }
}
]]></artwork>
          </figure>
        </section>
      </section>

      <section anchor="simple-data-types"
               title="CDNI Metadata Simple Data Type Descriptions">
        <t>This section describes the simple data types that are used for
        properties of CDNI Metadata objects.</t>

        <section anchor="Link" title="Link">
          <t>A Link object can be used in place of any of the objects
          described above. Link objects can be used to avoid
          duplication if the same metadata information is repeated within the
          metadata tree. When a Link object replaces another object, its
          "href" property is set to the URI of the resource and its
          "type" property is set to the CDNI Payload Type of the object
          it is replacing.</t>

          <t>dCDNs can detect the presence of a Link object
          by detecting the presence of a property named "href"
          within the object. This means that GenericMetadata types MUST NOT
          contain a property named "href" because doing so would conflict with
          the ability for dCDNs to detect Link objects being used to reference
          a GenericMetadata object.</t>

          <t><list style="empty">
              <t>Property: href<list style="empty">
                  <t>Description: The URI of the addressable object being
                  referenced.</t>

                  <t>Type: String</t>

                  <t>Mandatory-to-Specify: Yes.</t>
                </list></t>
            </list> <list style="empty">
              <t>Property: type<list style="empty">
                  <t>Description: The CDNI Payload Type of the object being referenced.</t>

                  <t>Type: String</t>

                  <t>Mandatory-to-Specify: No. If the container
                  specifies the type (e.g., the HostIndex object
                  contains an array
                  of HostMatch objects, so a Link object in the list of
                  HostMatch objects must reference a HostMatch), then
                  it is not necessary to explicitly specify a type.</t>
                </list></t>
            </list></t>

          <t>Example Link object referencing a HostMatch object:</t>

          <figure>
            <artwork><![CDATA[{
  "type": "MI.HostMatch",
  "href": "https://metadata.ucdn.example/hostmatch1234"
}
]]></artwork>
          </figure>

          <t/>

          <t>Example Link object referencing a HostMatch object,
          without an explicit type, inside a HostIndex object:</t>

          <figure>
            <artwork><![CDATA[{
  "hosts": [
    {
      <Properties of embedded HostMatch object>
    },
    {
      "href": "https://metadata.ucdn.example/hostmatch1234"
    }
  ]
}
]]></artwork>
          </figure>

          <section anchor="LinkLoop" title="Link Loop Prevention">
            <t>When following a link, CDNI Metadata clients SHOULD
            verify that the CDNI Payload Type of the object retrieved
            matches the expected CDNI Payload Type, as indicated by
            the Link object or containing property.  For GenericMetadata objects, type
            checks will prevent self-references; however, incorrect
            linking can result in circular references for
            structural metadata objects, specifically PathMatch and
            PathMetadata objects (<xref target="metadata-model-figure-top"/>).
            To prevent circular references, CDNI Metadata clients
            SHOULD verify that no duplicate links occur for PathMatch
            or PathMetadata objects.</t>
          </section>
        </section>

        <section anchor="Protocol" title="Protocol">
          <t>Protocol objects are used to specify protocols
          (from the "CDNI Metadata Protocol Types" registry; see
          <xref target="ProtocolReg"/>) for
          content acquisition or delivery.</t>

          <t>Type: String</t>

          <t>Example:</t>

          <figure>
            <artwork><![CDATA["http/1.1"]]></artwork>
          </figure>
        </section>

        <section anchor="Endpoint" title="Endpoint">
          <t>A hostname (with optional port) or an IP address
          (with optional port).</t>

          <t>All implementations MUST support IPv4 addresses encoded as
          specified by the "IPv4address" rule in Section&nbsp;3.2.2 of <xref
          target="RFC3986"/>. IPv6 addresses MUST be encoded in one of the
          IPv6 address formats specified in <xref target="RFC5952"/>,
          although receivers MUST support all IPv6 address formats
          specified in <xref target="RFC4291"/>. Hostnames MUST conform
          to the Domain Name System (DNS) syntax defined
          in <xref target="RFC1034"/> and <xref target="RFC1123"/>.
          Internationalized Domain Names (IDNs) must first be transformed to
          the A-label form <xref target="RFC5890"/>
          as per <xref target="RFC5891"/>.</t>

          <t>Type: String</t>

          <t>Example hostname:</t>

          <figure>
            <artwork><![CDATA["metadata.ucdn.example"]]></artwork>
          </figure>

          <t/>

          <t>Example IPv4 address:</t>

          <figure>
            <artwork><![CDATA["192.0.2.1"]]></artwork>
          </figure>

          <t/>

          <t>Example IPv6 address (with port number):</t>

          <figure>
            <artwork><![CDATA["[2001:db8::1]:81"]]></artwork>
          </figure>
        </section>

        <section anchor="Time" title="Time">
          <t>A time value expressed in seconds since the UNIX epoch
          (i.e., zero hours, zero minutes, zero seconds, on January 1,
          1970) Coordinated Universal Time (UTC) <xref target="POSIX"/>.</t>

          <t>Type: Integer</t>

          <t>Example time representing 09:00:00 01/01/2000 UTC:</t>

          <figure>
            <artwork><![CDATA[946717200]]></artwork>
          </figure>
        </section>

        <section anchor="IPv4CIDR" title="IPv4CIDR">
          <t>An IPv4address Classless Inter-Domain Routing (CIDR) block
          encoded as specified by the "IPv4address" rule in
          Section&nbsp;3.2.2 of <xref target="RFC3986"/>
          followed by a "/" followed by an unsigned integer representing the
          leading bits of the routing prefix (i.e., IPv4 CIDR notation). Single
          IP addresses can be expressed as&nbsp;/32.</t>

          <t>Type: String</t>

          <t>Example IPv4CIDR:</t>

          <figure>
            <artwork><![CDATA["192.0.2.0/24"]]></artwork>
          </figure>
        </section>

        <section anchor="IPv6CIDR" title="IPv6CIDR">
          <t>An IPv6address CIDR block encoded in one of the IPv6 address
          formats specified in <xref target="RFC5952"/> followed by a "/"
          followed by an unsigned integer representing the leading bits of the
          routing prefix (i.e., IPv6 CIDR notation). Single IP addresses can be
          expressed as /128.</t>

          <t>Type: String</t>

          <t>Example IPv6CIDR:</t>

          <figure>
            <artwork><![CDATA["2001:db8::/32"]]></artwork>
          </figure>
        </section>

        <section anchor="ASN" title="ASN">
          <t>An ASN value encoded as a string consisting of the characters "as"
          (in lowercase) followed by the ASN <xref target="RFC6793"/>.</t>

          <t>Type: String</t>

          <t>Example ASN:</t>

          <figure>
            <artwork><![CDATA["as64496"]]></artwork>
          </figure>
        </section>

        <section anchor="CountryCode" title="Country Code">
          <t>An ISO 3166-1 alpha-2 code <xref target="ISO3166-1"/> in
          lowercase.</t>

          <t>Type: String</t>

          <t>Example Country Code representing the USA:</t>

          <figure>
            <artwork><![CDATA["us"]]></artwork>
          </figure>
        </section>
      </section>
    </section>

    <section anchor="metadata-capabilities" title="CDNI Metadata Capabilities">
      <t>CDNI Metadata is used to convey information pertaining to content
      delivery from the uCDN to the dCDN. For optional metadata, it can be
      useful for the uCDN to know, prior to delegating any content requests
      to a given dCDN, if that dCDN supports the underlying functionality
      described by the metadata. If some metadata is
      mandatory&nbhy;to&nbhy;enforce and the dCDN does not support it,
      any delegated requests for content that requires that metadata will
      fail. The uCDN will likely want to avoid delegating those requests
      to that dCDN. Likewise, for any metadata that might be assigned
      optional values, it could be useful for the uCDN to know, prior to
      delegating any content requests to a given dCDN, which values
      that dCDN supports. If the optional value assigned to a given piece
      of content's metadata is not supported by the dCDN, any delegated
      requests for that content can fail, so again the uCDN is likely to
      want to avoid delegating those requests to that&nbsp;dCDN.</t>

      <t>The CDNI Footprint &amp; Capabilities Advertisement interface (FCI)
      provides a means of advertising capabilities from the dCDN to the
      uCDN <xref target="RFC8008"/>. Support for optional metadata types
      and values can be advertised using the FCI.</t>
    </section>

    <section anchor="metadata-interface" title="CDNI Metadata Interface">
      <t>This section specifies an interface to enable a dCDN to retrieve CDNI
      Metadata objects from a uCDN.</t>

      <t>The interface can be used by a dCDN to retrieve CDNI Metadata objects
      in either of two ways:</t>

      <t><list style="symbols">
          <t>Dynamically, as required by the dCDN to process received
          requests -- for example, in response to a query from a uCDN over
          the CDNI Request Routing Redirection interface (RI) <xref
          target="RFC7975"/> or in response to receiving a
          request for content from a User Agent.</t>

          <t>In advance of being required -- for example, in the case of
          pre&nbhy;positioned CDNI Metadata acquisition, initiated through
          the "CDNI Control interface / Triggers" (CI/T) interface
          <xref target="RFC8007"/>.</t>
        </list></t>

      <t>The CDNI Metadata interface is built on the principles of HTTP web
      services. In particular, this means that requests and responses over the
      interface are built around the transfer of representations of
      hyperlinked resources. A resource in the context of the CDNI Metadata
      interface is any object in the object model (as described in
      Sections&nbsp;<xref target="data-model" format="counter"/> and <xref
      target="abstract-metadata-description" format="counter"/>).</t>

      <t>CDNI Metadata servers (i.e., servers in the uCDN) are free to assign
      whatever structure they desire to the URIs for CDNI Metadata objects,
      and CDNI Metadata clients MUST NOT make any assumptions regarding the
      structure of CDNI Metadata URIs or the mapping between CDNI Metadata
      objects and their associated URIs. Any URIs present in the
      examples in this document are purely illustrative and are not intended
      to impose a definitive structure on CDNI Metadata interface
      implementations.</t>

      <section title="Transport">
        <t>The CDNI Metadata interface uses HTTP as the underlying protocol
        transport <xref target="RFC7230"/>.</t>

        <t>The HTTP method in the request defines the operation the request
        would like to perform. A server implementation of the CDNI Metadata
        interface MUST support the HTTP GET and HEAD methods.</t>

        <t>The corresponding HTTP response returns the status of the operation
        in the HTTP status code and returns the current representation of the
        resource (if appropriate) in the response body. HTTP responses
        that contain a response body SHOULD include an entity&nbhy;tag (ETag)
        to enable validation of cached versions of returned resources.</t>

        <t>As the CDNI Metadata interface builds on top of HTTP, CDNI Metadata
        server implementations MAY make use of any HTTP feature when
        implementing the CDNI Metadata interface; for example, a CDNI Metadata
        server MAY make use of HTTP's caching mechanisms to indicate that the
        returned response/representation can be reused without
        re&nbhy;contacting the CDNI Metadata server.</t>
      </section>

      <section title="Retrieval of CDNI Metadata Resources">
        <t>In the general case, a CDNI Metadata server makes CDNI Metadata
        objects available via unique URIs; thus, in order to retrieve
        CDNI Metadata, a CDNI Metadata client (i.e., a client in
        the dCDN) first makes an HTTP GET request
        for the URI of the HostIndex, which provides an array of hostnames
        for which the uCDN can delegate content delivery to the dCDN.</t>

        <t>In order to retrieve the CDNI Metadata for a particular request, the
        CDNI Metadata client processes the received HostIndex object and finds
        the corresponding HostMetadata entry (by matching the hostname in the
        request against the hostnames listed in the HostMatch objects). If the
        HostMetadata is linked (rather than embedded), the CDNI Metadata
        client then makes an HTTP GET request for the URI specified in the
        "href" property of the Link object, which points to the
        HostMetadata object itself.</t>

        <t>In order to retrieve the most specific metadata for a particular
        request, the CDNI Metadata client inspects the HostMetadata for
        references to more&nbhy;specific PathMetadata objects (by matching
        the URI path in the request against the path-pattern property items
        in any PathMatch objects listed in the HostMetadata object). If
        a PathMetadata object is found to match (and is linked rather than
        embedded), the CDNI Metadata client makes another HTTP GET request for the
        PathMetadata. Each PathMetadata object can also include references to
        additional more&nbhy;specific metadata. If this is the case, the
        CDNI Metadata client continues requesting PathMatch and PathMetadata
        objects recursively. The CDNI Metadata client repeats this approach of
        processing metadata objects and retrieving (via HTTP GETs) any linked
        objects until it has all the metadata objects it requires in order to
        process the redirection request from the uCDN or the content request
        from a User Agent.</t>

        <t>In cases where a dCDN is not able to retrieve the entire set of
        CDNI Metadata associated with a User Agent request, or it has
        retrieved that metadata but it is stale according to standard
        HTTP caching rules and cannot be revalidated -- for example, because
        the uCDN is unreachable or returns an HTTP 4xx or 5xx status in
        response to some or all of the dCDN's CDNI Metadata requests -- the
        dCDN MUST NOT serve the requested content.</t>

        <t>Where a dCDN is interconnected with multiple uCDNs, the dCDN needs
        to determine which uCDN's CDNI Metadata interface should be used to handle a
        particular User Agent request.</t>

        <t>When HTTP redirection (e.g., HTTP 302 redirects) is
        being used between CDNs, it is expected that the dCDN will be able to
        determine the uCDN that redirected a particular request from
        information contained in the received request (e.g., via the URI).
        With knowledge of which uCDN routed the request, the dCDN can choose
        the correct uCDN from which to obtain the HostIndex. Note that the
        HostIndexes served by each uCDN can be unique.</t>

        <t>In the case of DNS redirection, there is not always sufficient
        information carried in the DNS request from User Agents to determine
        the uCDN that redirected a particular request (e.g., when content from
        a given host is redirected to a given dCDN by more than one uCDN);
        therefore, dCDNs will have to apply local policy when deciding which
        uCDN's CDNI Metadata interface to use.</t>
      </section>

      <section title="Bootstrapping">
        <t>The URI for the HostIndex object of a given uCDN needs to be
        configured in the dCDN. All other objects/resources
        are then discoverable from the HostIndex object by following any links
        in the HostIndex object, and through the referenced HostMetadata and
        PathMetadata objects and their GenericMetadata sub-objects.</t>

        <t>Manual configuration of the URI for the HostIndex object is
        outside the scope of this document.</t>
      </section>

      <section anchor="Encoding" title="Encoding">
        <t>CDNI Metadata objects MUST be encoded as I-JSON objects <xref
        target="RFC7493"/> containing a dictionary of (key,value) pairs where
        the keys are the property names and the values are the associated
        property values.</t>

        <t>The keys of the dictionary are the names of the properties
        associated with the object and are therefore dependent on the specific
        object being encoded (i.e., dependent on the CDNI Payload Type of the
        returned resource). Likewise, the values associated with each property
        (dictionary key) are dependent on the specific object being encoded
        (i.e., dependent on the CDNI Payload Type of the returned resource).</t>

        <t>Dictionary keys (properties) in I-JSON are case sensitive. By
        convention, any dictionary key (property) defined by this document (for
        example, the names of CDNI Metadata object properties) MUST be
        lowercase.</t>
      </section>

      <section anchor="extensibility" title="Extensibility">
        <t>The set of GenericMetadata objects can be extended with additional
        (standards-based or vendor-specific) metadata objects through the
        specification of new GenericMetadata objects. The GenericMetadata
        object defined in <xref target="generic-metadata"/> specifies a
        type&nbsp;field and a type-specific value field that allow any
        metadata to be included in either the HostMetadata or
        PathMetadata arrays.</t>

        <t>As with the initial GenericMetadata types defined in <xref
        target="property-objects"/>, future GenericMetadata types MUST specify
        the information necessary for constructing and decoding the
        GenericMetadata object.</t>

        <t>Any document that defines a new GenericMetadata type MUST:</t>

        <t><list style="numbers">
            <t>Register the CDNI Payload Type 
            <xref target="RFC7736"/> used to identify the new GenericMetadata
            type being specified.</t>

            <t>Define the set of properties associated with the new
            GenericMetadata object. GenericMetadata
            MUST NOT contain a property named "href" because doing so would
            conflict with the ability to detect Link objects
            (see <xref target="Link"/>).</t>

            <t>For each property, define a name, description, type, and
            whether or not the property is mandatory-to-specify.</t>

            <t>Describe the semantics of the new type, including its purpose,
            and provide a use case to which it applies, including an example
            encoded in I-JSON.</t>

            <t>Describe the security and privacy consequences, for
            both the User Agent and the CDNs, of the new
            GenericMetadata object.</t>

            <t>Describe any relation to, conflict with, or obsolescence of
            other existing CDNI Metadata objects.</t>
          </list></t>

        <t>Note: In the case of vendor-specific extensions,
        vendor-identifying CDNI Payload Type names will decrease the
        possibility of GenericMetadata type collisions.
        It is RECOMMENDED that any vendor&nbhy;specific extensions use
        vendor&nbhy;identifying CDNI Payload Type names.</t>
      </section>

      <section title="Metadata Enforcement">
        <t>At any given time, the set of GenericMetadata types supported by
        the uCDN might not match the set of GenericMetadata types supported by
        the dCDN.</t>

        <t>In cases where a uCDN sends metadata containing a
        GenericMetadata type that a dCDN does not support, the dCDN MUST
        enforce the semantics of the mandatory-to-enforce property. If
        a dCDN does not understand or is unable to perform the functions
        associated with any mandatory-to-enforce metadata, the dCDN
        MUST NOT service any requests for the corresponding content.</t>

        <t>Note: Ideally, uCDNs would not delegate content requests to a dCDN
        that does not support the mandatory-to-enforce metadata associated
        with the content being requested. However, even if the uCDN has
        a&nbsp;priori knowledge of the metadata supported by the dCDN
        (e.g., via the FCI or through out-of-band negotiation between
        CDN operators), metadata support can fluctuate or be inconsistent
        (e.g., due to miscommunication, misconfiguration, or temporary
        outage). Thus, the dCDN MUST always evaluate all metadata associated
        with redirection and content requests and reject any requests
        where mandatory&nbhy;to&nbhy;enforce metadata associated with
        the content cannot be enforced.</t>
      </section>

      <section title="Metadata Conflicts">
        <t>It is possible that new metadata definitions will obsolete or
        conflict with existing GenericMetadata (e.g., a future revision of the
        CDNI Metadata interface could redefine the Auth GenericMetadata object
        or a custom vendor extension could implement an alternate Auth metadata
        option). If multiple metadata (e.g., MI.Auth.v2, vendor1.Auth, and
        vendor2.Auth) all conflict with an existing GenericMetadata object
        (i.e., MI.Auth) and all are marked as mandatory-to-enforce, it could
        be ambiguous as to which metadata should be applied, especially in the
        case of overlapping functionality.</t>

        <t>As described in <xref target="metadata-inheritance"/>, metadata
        override only applies to metadata objects of the same exact type
        found in HostMetadata and nested PathMetadata structures. The CDNI
        Metadata interface does not support enforcement of dependencies
        between different GenericMetadata types. It is the responsibility of the CSP
        and the CDN operators to ensure that metadata assigned to a given
        piece of content do not conflict.</t>

        <t>Note: Because metadata is inherently ordered in HostMetadata and
        PathMetadata arrays, as well as in the PathMatch hierarchy,
        multiple conflicting metadata types MAY be used; however, metadata
        hierarchies SHOULD ensure that independent PathMatch root objects are
        used to prevent ambiguous or conflicting metadata definitions.</t>
      </section>

      <section title="Versioning">
        <t>The version of CDNI Metadata objects is conveyed inside the
        CDNI Payload Type that is included in either (1)&nbsp;the HTTP
        Content-Type header (for example, "Content-Type: application/cdni;
        ptype=MI.HostIndex" when retrieved via a link) or (2)&nbsp;in the
        link type (<xref target="Link"/>), generic-metadata-type
        (<xref target="generic-metadata"/>), or auth&nbhy;type
        (<xref target="Auth"/>) properties in the JSON payload.
        The CDNI Payload Type uniquely identifies the
        specification defining that object, including any relation to,
        conflicts with, or obsolescence of other metadata.  There is
        no explicit version mapping requirement; however, for ease of
        understanding, metadata creators SHOULD make new versions of
        metadata easily visible via the CDNI Payload Type, e.g., by
        appending a version string.  Note: A version string is
        optional on the first version (e.g., MI.HostIndex) but could
        be added for subsequent versions (MI.HostIndex.v2,
        MI.HostIndex.v3, etc.).</t> 

        <t>Except when referenced by a Link object, nested metadata
        objects (i.e., structural metadata below the HostIndex;
        and Source, LocationRule, TimeWindowRule, ProtocolRule, Footprint,
        and TimeWindow objects) can be serialized into a
        JSON payload without explicit CDNI Payload Type information.
        The type is inferred from the outer structural metadata,
        GenericMetadata, or Auth object CDNI Payload Type.  To avoid
        ambiguity when revising nestable metadata objects, any
        outer metadata object(s) MUST be reversioned and allocated new
        CDNI Payload Type(s) at the same time.  For example, the
        MI.HostIndex object defined in this document contains an array
        of MI.HostMatch objects, each of which in turn contains a
        MI.HostMetadata object.  If a new MI.HostMetadata.v2 object
        were required, the outer MI.HostIndex and MI.HostMatch
        objects would need to be revised, e.g., to MI.HostIndex.v2 and
        MI.HostMatch.v2, respectively.  Similarly, if a new
        MI.TimeWindowRule.v2 object were required, the outer
        MI.TimeWindowACL object would need to be revised, e.g., to
        MI.TimeWindowACL.v2; however, the MI.TimeWindowRule.v2 object could
        still contain MI.TimeWindow objects, if so specified.</t>

        <t>HTTP requests sent to a metadata server SHOULD include
        an Accept header with the CDNI Payload Type of the expected object.
        Metadata clients can specify multiple CDNI Payload Types
        in the Accept header; for example, if a metadata client is capable of
        processing two different versions of the same type of object (defined
        by different CDNI Payload Types), it might decide to include both
        in the Accept header.</t>
      </section>

      <section anchor="media-types" title="Media Types">
        <t>All CDNI Metadata objects use the media type 
        "application/cdni". The CDNI Payload Type for each object then
        contains the object name of that object as defined by this document,
        prefixed with "MI.". <xref target="metadata-payload-types-table"/>
        lists the CDNI Payload Types for the metadata objects (resources)
        specified in this document.</t>

        <texttable anchor="metadata-payload-types-table"
                   title="CDNI Payload Types for CDNI Metadata Objects">
          <ttcol>Data Object</ttcol>
          <ttcol>CDNI Payload Type</ttcol>

          <c>HostIndex</c>
          <c>MI.HostIndex</c>

          <c>HostMatch</c>
          <c>MI.HostMatch</c>

          <c>HostMetadata</c>
          <c>MI.HostMetadata</c>

          <c>PathMatch</c>
          <c>MI.PathMatch</c>

          <c>PatternMatch</c>
          <c>MI.PatternMatch</c>

          <c>PathMetadata</c>
          <c>MI.PathMetadata</c>

          <c>SourceMetadata</c>
          <c>MI.SourceMetadata</c>

          <c>Source</c>
          <c>MI.Source</c>

          <c>LocationACL</c>
          <c>MI.LocationACL</c>

          <c>LocationRule</c>
          <c>MI.LocationRule</c>

          <c>Footprint</c>
          <c>MI.Footprint</c>

          <c>TimeWindowACL</c>
          <c>MI.TimeWindowACL</c>

          <c>TimeWindowRule</c>
          <c>MI.TimeWindowRule</c>

          <c>TimeWindow</c>
          <c>MI.TimeWindow</c>

          <c>ProtocolACL</c>
          <c>MI.ProtocolACL</c>

          <c>ProtocolRule</c>
          <c>MI.ProtocolRule</c>

          <c>DeliveryAuthorization</c>
          <c>MI.DeliveryAuthorization</c>

          <c>Cache</c>
          <c>MI.Cache</c>

          <c>Auth</c>
          <c>MI.Auth</c>

          <c>Grouping</c>
          <c>MI.Grouping</c>
        </texttable>

        <t/>
      </section>

      <section title="Complete CDNI Metadata Example">
        <t>A dCDN requests the HostIndex and receives the following object
        with a CDNI Payload Type of "MI.HostIndex":</t>

        <figure>
          <artwork><![CDATA[{
  "hosts": [
    {
      "host": "video.example.com",
      "host-metadata": {
        "type": "MI.HostMetadata",
        "href": "https://metadata.ucdn.example/host1234"
      }
    },
    {
      "host": "images.example.com",
      "host-metadata": {
        "type": "MI.HostMetadata",
        "href": "https://metadata.ucdn.example/host5678"
      }
    }
  ]
}]]></artwork>
        </figure>

        <t>If the incoming request has a Host header with "video.example.com",
        then the dCDN would fetch the HostMetadata object from
        "https://metadata.ucdn.example/host1234" expecting a
        CDNI Payload Type of "MI.HostMetadata":</t>

        <figure>
          <artwork><![CDATA[{
  "metadata": [
    {
      "generic-metadata-type": "MI.SourceMetadata",
      "generic-metadata-value": {
        "sources": [
          {
            "endpoint": ["acq1.ucdn.example"],
            "protocol": "http/1.1"
          },
          {
            "endpoint": ["acq2.ucdn.example"],
            "protocol": "http/1.1"
          }
        ]
      }
    },
    {
      "generic-metadata-type": "MI.LocationACL",
      "generic-metadata-value": {
        "locations": [
          {
            "footprints": [
              {
                "footprint-type": "ipv4cidr",
                "footprint-value": ["192.0.2.0/24"]
              },
              {
                "footprint-type": "ipv6cidr",
                "footprint-value": ["2001:db8::/32"]
              },
              {
                "footprint-type": "countrycode",
                "footprint-value": ["us"]
              },
              {
                "footprint-type": "asn",
                "footprint-value": ["as64496"]
              }
            ],
            "action": "deny"
          }
        ]
      }
    },
    {
      "generic-metadata-type": "MI.ProtocolACL",
      "generic-metadata-value": {
        "protocol-acl": [
          {
            "protocols": [
              "http/1.1"
            ],
            "action": "allow"
          }
        ]
      }
    }
  ],
  "paths": [
    {
      "path-pattern": {
        "pattern": "/videos/trailers/*"
      },
      "path-metadata": {
        "type": "MI.PathMetadata",
        "href": "https://metadata.ucdn.example/host1234/pathABC"
      }
    },
    {
      "path-pattern": {
        "pattern": "/videos/movies/*"
      },
      "path-metadata": {
        "type": "MI.PathMetadata",
        "href": "https://metadata.ucdn.example/host1234/pathDEF"
      }
    }
  ]
}]]></artwork>
        </figure>

        <t>Suppose that the path of the requested resource matches the
        "/videos&wj;/movies/*" pattern; the next metadata requested
        would be for "https://metadata.ucdn.example/host1234/pathDEF" with an
        expected CDNI Payload Type of "MI.PathMetadata":</t>

        <figure>
          <artwork><![CDATA[{
  "metadata": [],
  "paths": [
    {
      "path-pattern": {
        "pattern": "/videos/movies/hd/*"
      },
      "path-metadata": {
        "type": "MI.PathMetadata",
        "href": 
          "https://metadata.ucdn.example/host1234/pathDEF/path123"
      }
    }
  ]
}]]></artwork>
        </figure>

        <t>Finally, if the path of the requested resource also matches the
        "/videos/movies/hd/*" pattern, the dCDN would also fetch the following
        object from "https://metadata.ucdn.example/host1234/pathDEF/path123"
        with a CDNI Payload Type of "MI.PathMetadata":</t>

        <figure>
          <artwork><![CDATA[{
  "metadata": [
    {
      "generic-metadata-type": "MI.TimeWindowACL",
      "generic-metadata-value": {
        "times": [
          "windows": [
            {
              "start": "1213948800",
              "end": "1478047392"
            }
          ],
          "action": "allow"
        ]
      }
    }
  ]
}]]></artwork>
        </figure>

        <t>The final set of metadata that applies to the requested
        resource includes a SourceMetadata, a LocationACL, a ProtocolACL,
        and a TimeWindowACL.</t>

      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">

      <section anchor="IANA.payload" title="CDNI Payload Types">

        <t>This document requests the registration of the following
        entries under the "CDNI Payload Types" registry hosted by IANA:</t>

        <texttable>
          <ttcol align="left">Payload Type</ttcol>
          <ttcol align="left">Specification</ttcol>

          <c>MI.HostIndex</c>
          <c>RFC 8006</c>

          <c>MI.HostMatch</c>
          <c>RFC 8006</c>

          <c>MI.HostMetadata</c>
          <c>RFC 8006</c>

          <c>MI.PathMatch</c>
          <c>RFC 8006</c>

          <c>MI.PatternMatch</c>
          <c>RFC 8006</c>

          <c>MI.PathMetadata</c>
          <c>RFC 8006</c>

          <c>MI.SourceMetadata</c>
          <c>RFC 8006</c>

          <c>MI.Source</c>
          <c>RFC 8006</c>

          <c>MI.LocationACL</c>
          <c>RFC 8006</c>

          <c>MI.LocationRule</c>
          <c>RFC 8006</c>

          <c>MI.Footprint</c>
          <c>RFC 8006</c>

          <c>MI.TimeWindowACL</c>
          <c>RFC 8006</c>

          <c>MI.TimeWindowRule</c>
          <c>RFC 8006</c>

          <c>MI.TimeWindow</c>
          <c>RFC 8006</c>

          <c>MI.ProtocolACL</c>
          <c>RFC 8006</c>

          <c>MI.ProtocolRule</c>
          <c>RFC 8006</c>

          <c>MI.DeliveryAuthorization</c>
          <c>RFC 8006</c>

          <c>MI.Cache</c>
          <c>RFC 8006</c>

          <c>MI.Auth</c>
          <c>RFC 8006</c>

          <c>MI.Grouping</c>
          <c>RFC 8006</c>
        </texttable>

        <section anchor="IANA.payload.HostIndex" title="CDNI MI HostIndex Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish HostIndex MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="HostIndex"/></t>
        </section>
        <section anchor="IANA.payload.HostMatch" title="CDNI MI HostMatch Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish HostMatch MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="HostMatch"/></t>
        </section>
        <section anchor="IANA.payload.HostMetadata" title="CDNI MI HostMetadata Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish HostMetadata MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="HostMetadata"/></t>
        </section>
        <section anchor="IANA.payload.PathMatch" title="CDNI MI PathMatch Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish PathMatch MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="PathMatch"/></t>
        </section>
        <section anchor="IANA.payload.PatternMatch" title="CDNI MI PatternMatch Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish PatternMatch MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="PatternMatch"/></t>
        </section>
        <section anchor="IANA.payload.PathMetadata" title="CDNI MI PathMetadata Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish PathMetadata MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="PathMetadata"/></t>
        </section>
        <section anchor="IANA.payload.SourceMetadata" title="CDNI MI SourceMetadata Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish SourceMetadata MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="SourceMetadata"/></t>
        </section>
        <section anchor="IANA.payload.Source" title="CDNI MI Source Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish Source MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="Source"/></t>
        </section>
        <section anchor="IANA.payload.LocationACL" title="CDNI MI LocationACL Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish LocationACL MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="LocationACL"/></t>
        </section>
        <section anchor="IANA.payload.LocationRule" title="CDNI MI LocationRule Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish LocationRule MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="LocationRule"/></t>
        </section>
        <section anchor="IANA.payload.Footprint" title="CDNI MI Footprint Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish Footprint MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="Footprint"/></t>
        </section>
        <section anchor="IANA.payload.TimeWindowACL" title="CDNI MI TimeWindowACL Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish TimeWindowACL MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="TimeWindowACL"/></t>
        </section>
        <section anchor="IANA.payload.TimeWindowRule" title="CDNI MI TimeWindowRule Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish TimeWindowRule MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="TimeWindowRule"/></t>
        </section>
        <section anchor="IANA.payload.TimeWindow" title="CDNI MI TimeWindow Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish TimeWindow MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="TimeWindow"/></t>
        </section>
        <section anchor="IANA.payload.ProtocolACL" title="CDNI MI ProtocolACL Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish ProtocolACL MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="ProtocolACL"/></t>
        </section>
        <section anchor="IANA.payload.ProtocolRule" title="CDNI MI ProtocolRule Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish ProtocolRule MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="ProtocolRule"/></t>
        </section>
        <section anchor="IANA.payload.DeliveryAuthorization" title="CDNI MI DeliveryAuthorization Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish DeliveryAuthorization MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="DeliveryAuthorization"/></t>
        </section>
        <section anchor="IANA.payload.Cache" title="CDNI MI Cache Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish Cache MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="Cache"/></t>
        </section>
        <section anchor="IANA.payload.Auth" title="CDNI MI Auth Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish Auth MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="Auth"/></t>
        </section>
        <section anchor="IANA.payload.Grouping" title="CDNI MI Grouping Payload Type">
          <t>Purpose: The purpose of this Payload Type is to
          distinguish Grouping MI objects (and any associated capability
          advertisement)</t>
          <t>Interface: MI/FCI</t>
          <t>Encoding: see <xref target="Grouping"/></t>
        </section>

      </section>

      <section anchor="FootprintReg"
               title="&quot;CDNI Metadata Footprint Types&quot; Registry">
        <t>IANA has created a new "CDNI Metadata Footprint
        Types" subregistry in the "Content Delivery Network
        Interconnection (CDNI) Parameters" registry. The "CDNI
        Metadata Footprint Types" namespace defines the valid
        Footprint object type values used by the Footprint object described
        in <xref target="Footprint"/>. Additions to the
        "CDNI Metadata Footprint Types" namespace
        conform to the Specification Required policy as defined in <xref
        target="RFC5226"/>. The Designated Expert will verify that new type
        definitions do not duplicate existing type definitions and prevent
        gratuitous additions to the namespace. New registrations are
        required to provide a clear description of how to interpret
        new footprint types.</t>

        <t>The following table defines the initial values for the
        "CDNI Metadata Footprint Types" registry:</t>

        <texttable>
          <ttcol align="left">Footprint Type</ttcol>
          <ttcol align="left">Description</ttcol>
          <ttcol align="left">Specification</ttcol>

          <c>ipv4cidr</c>
          <c>IPv4 CIDR address block</c>
          <c>RFC 8006</c>

          <c>ipv6cidr</c>
          <c>IPv6 CIDR address block</c>
          <c>RFC 8006</c>

          <c>asn</c>
          <c>Autonomous System Number (ASN)</c>
          <c>RFC 8006</c>

          <c>countrycode</c>
          <c>ISO 3166-1 alpha-2 code</c>
          <c>RFC 8006</c>
        </texttable>

      </section>

      <section anchor="ProtocolReg"
               title="&quot;CDNI Metadata Protocol Types&quot; Registry">
        <t>IANA has created a new "CDNI Metadata Protocol
        Types" subregistry in the "Content Delivery Network
        Interconnection (CDNI) Parameters" registry. The "CDNI
        Metadata Protocol Types" namespace defines the valid Protocol
        object values (<xref target="Protocol"/>) used by the
        SourceMetadata and ProtocolACL objects. Additions to the Protocol
        namespace conform to the Specification Required policy as
        defined in <xref target="RFC5226"/>, where the specification
        defines the Protocol Type and the protocol to which it is
        associated. The Designated Expert will
        verify that new protocol definitions do not duplicate
        existing protocol definitions and prevent gratuitous additions
        to the namespace.</t>

        <t>The following table defines the initial Protocol values
        corresponding to the HTTP and HTTPS protocols:</t>

<?rfc compact="no"?>
        <texttable>
          <ttcol align="left">Protocol Type</ttcol>
          <ttcol align="left">Description</ttcol>
          <ttcol align="left">Type Specification</ttcol>
          <ttcol align="left">Protocol Specifications</ttcol>

          <c>http/1.1</c>
          <c>Hypertext Transfer Protocol -- HTTP/1.1</c>
          <c>RFC 8006</c>
          <c>RFC 7230</c>

          <c>https/1.1</c>
          <c>HTTP/1.1 over TLS</c>
          <c>RFC 8006</c>
          <c>RFC 7230, RFC 2818</c>
        </texttable>
<?rfc compact="yes"?>


      </section>
    </section>

    <section anchor="Security" title="Security Considerations">

      <section anchor="SecurityAuthentication" title="Authentication and Integrity">
        <t>A malicious metadata server, proxy server, or attacker
        impersonating an authentic uCDN CDNI Metadata interface without
        being detected could provide false metadata to a dCDN
        that either:</t>

        <t><list style="symbols">
            <t>Denies service for one or more pieces of content to one or more
            User Agents; </t>

            <t>Directs dCDNs to contact malicious origin servers instead of
            the actual origin servers, so that malware or slanderous
            alternate content may be substituted for legitimate content; or</t>

            <t>Removes delivery restrictions (e.g., LocationACL,
            TimeWindowACL, ProtocolACL, or Auth metadata), allowing
            access to content that would otherwise be denied and thus
            possibly violating license restrictions and incurring
            unwarranted delivery costs.</t>
          </list></t>

        <t>Unauthorized access to metadata could also enable a malicious
        metadata client to continuously issue metadata requests in order
        to overload a uCDN's metadata server or servers.</t>

        <t>Unauthorized access to metadata could further result in
        leakage of private information. A malicious metadata client
        could request metadata in order to gain access to origin
        servers, as well as information pertaining to content restrictions.</t>

        <t>An implementation of the CDNI Metadata interface MUST use mutual
        authentication and message authentication codes to prevent
        unauthorized access to, and undetected modification of, metadata (see
        <xref target="SecurityImplementation"/>).</t>
      </section>

      <section anchor="SecurityConfidentiality" title="Confidentiality and Privacy">
        <t>Unauthorized viewing of metadata could result in leakage of private
        information. Content provider origin and policy information is
        conveyed through the CDNI Metadata interface. A third party
        could intercept metadata transactions in order to gain access
        to origin servers, as well as information pertaining to
        content restrictions and usage patterns.</t>

        <t>Note: The distribution of metadata by a uCDN to dCDNs could
        introduce privacy concerns for some content providers, e.g.,
        dCDNs accepting content requests for a content provider's
        content might be able to obtain additional information and
        usage patterns relating to the users of a content provider's
        services. Content providers with concerns about divulging
        information to dCDNs can instruct their uCDN partners not to
        use CDNI when delivering their content.</t>

        <t>An implementation of the CDNI Metadata interface MUST use strong
        encryption to prevent unauthorized interception or monitoring
        of metadata (see <xref target="SecurityImplementation"/>).</t>
      </section>

      <section anchor="SecurityImplementation" title="Securing the CDNI Metadata Interface">
        <t>An implementation of the CDNI Metadata interface MUST support TLS
        transport as per <xref target="RFC2818"/> and <xref
        target="RFC7230"/>.</t>

        <t>TLS MUST be used by the server side (uCDN) and the
        client side (dCDN) of the CDNI Metadata interface, including
        authentication of the remote end, unless alternate methods are
        used for ensuring the security of the information in the CDNI
        Metadata interface requests and responses (such as setting up
        an IPsec tunnel between the two CDNs or using a physically
        secured internal network between two CDNs that are owned by
        the same corporate entity).</t>

        <t>The use of TLS for transport of the CDNI Metadata interface
        messages allows the dCDN and uCDN to authenticate each other.</t>

        <t>Once the dCDN and uCDN have mutually authenticated each other,
        TLS allows:<list style="symbols">
            <t>The dCDN and uCDN to authorize each other (to ensure that
            they are transmitting/receiving CDNI Metadata requests and
            responses from an authorized CDN);</t>

            <t>CDNI Metadata interface requests and responses to be
            transmitted with confidentiality; and</t>

            <t>The integrity of the CDNI Metadata interface requests and
            responses to be protected during the exchange.</t>
          </list></t>

        <t>When TLS is used, the general TLS usage guidance in <xref
        target="RFC7525"/> MUST be followed.</t>
      </section>
    </section>

  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.1034"?>
      <?rfc include="reference.RFC.1123"?>
      <?rfc include="reference.RFC.2119"?>
      <?rfc include="reference.RFC.3986"?>
      <?rfc include="reference.RFC.4291"?>
      <?rfc include="reference.RFC.5226"?>
      <?rfc include="reference.RFC.5890"?>
      <?rfc include="reference.RFC.5891"?>
      <?rfc include="reference.RFC.5952"?>
      <?rfc include="reference.RFC.6707"?>
      <?rfc include="reference.RFC.7525"?>
      <?rfc include="reference.RFC.7230"?>

      <reference anchor="ISO3166-1">
        <front>
          <title>Codes for the representation of names of countries and their subdivisions -- Part 1: Country codes</title>
          <author>
            <organization abbrev="ISO">The International Organization for Standardization</organization>
          </author>
          <date year="2013"/>
        </front>
        <seriesInfo name="ISO" value="3166-1:2013"/>
      </reference>

      <reference anchor="POSIX">
        <front>
          <title>Information Technology Portable Operating System Interface (POSIX) Part 1: System Application Program Interface (API) [C Language]</title>
          <author>
            <organization abbrev="IEEE">Institute of Electrical and Electronics Engineers</organization>
          </author>
          <date year="1990"/>
        </front>
        <seriesInfo name="IEEE" value="P1003.1"/>
      </reference>

      <?rfc include="reference.RFC.7493"?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.2818"?>
      <?rfc include="reference.RFC.6793"?>
      <?rfc include="reference.RFC.7234"?>
      <?rfc include="reference.RFC.7336"?>
      <?rfc include="reference.RFC.7337"?>
      <?rfc include="reference.RFC.7736"?>
      <?rfc include="reference.RFC.7540"?>
      <?rfc include="reference.RFC.7975"?>

<!-- draft-ietf-cdni-control-triggers -->
<reference anchor='RFC8007' target="http://www.rfc-editor.org/info/rfc8007">
<front>
<title>Content Delivery Network Interconnection (CDNI) Control Interface / Triggers</title>
<author initials='R' surname='Murray' fullname='Rob Murray'>
    <organization />
</author>
<author initials='B' surname='Niven-Jenkins' fullname='Ben Niven-Jenkins'>
    <organization />
</author>
<date month='December' year='2016' />
</front>
<seriesInfo name="RFC" value="8007"/>
<seriesInfo name="DOI" value="10.17487/RFC8007"/>
</reference>

<!-- draft-ietf-cdni-footprint-capabilities-semantics -->
<reference anchor='RFC8008' target="http://www.rfc-editor.org/info/rfc8008">
<front>
<title>Content Delivery Network Interconnection (CDNI) Request Routing:
Footprint and Capabilities Semantics</title>
<author initials='J' surname='Seedorf' fullname='Jan Seedorf'>
    <organization />
</author>
<author initials='J' surname='Peterson' fullname='Jon Peterson'>
    <organization />
</author>
<author initials='S' surname='Previdi' fullname='Stefano Previdi'>
    <organization />
</author>
<author initials='R' surname='van Brandenburg' fullname='Ray van Brandenburg'>
    <organization />
</author>
<author initials='K' surname='Ma' fullname='Kevin Ma'>
    <organization />
</author>
<date month='December' year='2016' />
</front>
<seriesInfo name="RFC" value="8008"/>
<seriesInfo name="DOI" value="10.17487/RFC8008"/>
</reference>

<!-- draft-ietf-cdni-uri-signing (AD is watching) -->
<reference anchor='CDNI-URI-SIGNING'>
<front>
<title>URI Signing for CDN Interconnection (CDNI)</title>
<author initials='R' surname='van Brandenburg' fullname='Ray van Brandenburg'>
    <organization />
</author>
<author initials='K' surname='Leung' fullname='Kent Leung'>
    <organization />
</author>
<author initials='P' surname='Sorber' fullname='Phil Sorber'>
    <organization />
</author>
<author initials='M' surname='Miller' fullname='Matthew Miller'>
    <organization />
</author>
<date month='October' year='2016' />
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-cdni-uri-signing-10' />
</reference>

    </references>

    <section anchor="Acknowledgments" title="Acknowledgments" numbered="no">
      <t>The authors would like to thank David Ferguson, Francois Le Faucheur,
      Jan Seedorf, and Matt Miller for their valuable comments and input to
      this document.</t>
    </section>

    <section anchor="Contributors" title="Contributors" numbered="no">
      <t>The authors would also like to thank Grant Watson and
      Kent Leung for their contributions to this document.</t>
    </section>

  </back>

</rfc>
