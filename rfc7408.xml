<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

  <!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
  <!ENTITY RFC3654 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3654.xml">
  <!ENTITY RFC3746 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3746.xml">
  <!ENTITY RFC5657 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5657.xml">
  <!ENTITY I-D.narten-iana-considerations-rfc2434bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.narten-iana-considerations-rfc2434bis.xml">
  <!ENTITY RFC7121 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7121.xml">
  <!ENTITY RFC5812 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5812.xml">
  <!ENTITY RFC5810 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5810.xml">
  <!ENTITY RFC5811 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5811.xml">
  <!ENTITY RFC3688 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3688.xml">  
  <!ENTITY RFC7258 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7258.xml">  
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc rfcedstyle="yes"?>
<?rfc compact="yes"?>  
<?rfc subcompact="no"?>


<rfc number="7408" category="std" submissionType="IETF" consensus="yes" ipr="trust200902" updates="5812">


  <!-- ***** FRONT MATTER ***** -->
  <front>

    <title abbrev="ForCES Model Extension">Forwarding and Control Element Separation
    (ForCES) Model Extension</title>


    <author fullname="Evangelos Haleplidis" initials="E.H." surname="Haleplidis">
      <organization>University of Patras</organization>
      <address>
        <postal>
          <street>Department of Electrical and Computer Engineering</street>
          <city>Patras</city>
          <region/>
          <code>26500</code>
          <country>Greece</country>
        </postal>
        <email>ehalep@ece.upatras.gr</email>
      </address>
    </author>

    <date month="November" year="2014"/>
    <area>Routing</area>
    <workgroup>Internet Engineering Task Force</workgroup>

    <keyword>ForCES</keyword>
    <keyword>Model</keyword>
    <keyword>Extension</keyword>


    <abstract>
      <t>This memo extends the Forwarding and Control Element Separation
      (ForCES) model defined in RFC 5812
      and updates that RFC to allow complex data types for metadata, optional
      default values for data types, and
      optional access types for structures. It also fixes an issue with Logical
      Functional Block (LFB) inheritance and
      introduces two new features: a new event condition called eventBecomesEqualTo
      and LFB properties. The changes
      introduced in this memo do not alter the protocol and retain backward
      compatibility with older LFB models.</t>
    </abstract>

  </front>
  <middle>
    <section title="Introduction">
            <t>The <xref target="RFC5812">ForCES model</xref> presents a
	    formal way to define Forwarding Element (FE) Logical Functional
	    Blocks (LFBs) using the eXtensible Markup Language (XML). <xref
	    target="RFC5812"/> was published several years before this document, and
	    experience with its use has demonstrated the need to add new
	    modeling concepts
	    and change existing ones. </t>

      <t>Specifically, this document updates the ForCES model <xref
      target="RFC5812"/> to allow <xref target="cdm">complex data types for
      metadata</xref>, <xref target="dvd">optional default values for
      data types</xref>, and <xref target="ats">optional access types for
      structures</xref>. It also fixes an issue with <xref target="LFBCI">LFB class
      inheritance</xref>. Additionally, the document introduces two new
      features: a new event condition named <xref target="bet">eventBecomesEqualTo</xref>
      and <xref target="LFBp">LFB properties</xref>.</t> 

      <t>These extensions are an update to the <xref target="RFC5812">ForCES
      model</xref> and do not require any changes to the <xref
      target="RFC5810">ForCES protocol</xref> as they are simply changes to
      the schema definition. Additionally, backward compatibility is ensured as
      XML libraries produced with the earlier schema are still valid with the
      new one. In order for XML libraries produced by the new schema to be
      compatible with existing ForCES implementations, the XML libraries MUST
      NOT include any of the features described in this document.</t>

      <t>Extensions to the schema and excerpts of the schema include the tags
      &lt;!-- Extension RFC 7408 --&gt; and  &lt;!-- /Extension RFC 7408
      --&gt;, which designate the beginning and ending of extension text
      specified by this document in respect to the schema in the original <xref
      target="RFC5812">ForCES model</xref>.</t>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref target="RFC2119"/>.</t>
      </section>
      <section title="Terminology">
      <t> This document uses the terminology defined in the ForCES model 
    <xref target="RFC5812"/>.  In particular, the reader is expected to be familiar
     with the following terms:</t>
        <t>
          <list style="hanging">
            <t>FE Model</t>
            <t>LFB (Logical Functional Block) Class (or type)</t>
            <t>LFB Instance</t>
            <t>LFB Model</t>
            <t>Element</t>
            <t>Attribute</t>
            <t>LFB Metadata</t>
            <t>ForCES Component</t>
            <t>LFB Class Library</t>
          </list>
        </t>
      </section>
    </section>
  <section title="ForCES Model Extensions">
    <section title="Complex Data Types for Metadata" anchor="cdm">
      <t>Section 4.6 ("&lt;metadataDefs&gt; Element for Metadata Definitions") of the <xref
      target="RFC5812">ForCES model</xref> limits the data type use in metadata
      to only atomic types. <xref target="InitMetaDef"></xref> shows the XML
      schema excerpt where only typeRef and atomic are allowed for a metadata
      definition.</t>


        <figure title="Initial metadataDefsType Definition in the Schema" anchor="InitMetaDef">
          <artwork align="left"><![CDATA[
  <xsd:complexType name="metadataDefsType">
    <xsd:sequence>
      <xsd:element name="metadataDef" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element ref="synopsis"/>
            <xsd:element name="metadataID" type="xsd:integer"/>
            <xsd:element ref="description" minOccurs="0"/>
            <xsd:choice>
              <xsd:element name="typeRef" type="typeRefNMTOKEN"/>
              <xsd:element name="atomic" type="atomicType"/>
            </xsd:choice>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
]]></artwork>
        </figure>

      <t>However, there are cases where complex metadata are used in the
      datapath: for example, two simple use cases are described in version
      1.1.0 (and subsequent versions) of the <xref
      target="OpenFlowSpec1.1">OpenFlow Switch Specification</xref>:</t>

      <t><list style="numbers">
        <t>The Action Set metadata is an array of actions descriptors, which
	traverses the processing pipeline along with the packet data.</t>

        <t>When a packet is received from a controller, it may be accompanied
	by a list of actions, as metadata, to be performed on it prior to
	being sent on the processing pipeline. This list of actions is also an
	array.</t>

        </list></t>
      <t>With the extension shown in <xref target="NewMetaDef"></xref>,
      complex data types are also allowed, specifically structs and arrays as
      metadata. The key declarations are required to check for validity of
      content keys in arrays and componentIDs in structs.</t>

        <figure title="New metadataDefsType Definition in the Schema" anchor="NewMetaDef">
          <artwork align="left"><![CDATA[
  <xsd:complexType name="metadataDefsType">
    <xsd:sequence>
      <xsd:element name="metadataDef" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element ref="synopsis"/>
            <xsd:element name="metadataID" type="xsd:integer"/>
            <xsd:element ref="description" minOccurs="0"/>
            <xsd:choice>
              <xsd:element name="typeRef" type="typeRefNMTOKEN"/>
              <xsd:element name="atomic" type="atomicType"/>
              <!-- Extension RFC 7408 -->
              <xsd:element name="array" type="arrayType">
                <xsd:key name="contentKeyID1">
                  <xsd:selector xpath="lfb:contentKey"/>
                  <xsd:field xpath="@contentKeyID"/>
                </xsd:key>
              </xsd:element>
              <xsd:element name="struct" type="structType">
                <xsd:key name="structComponentID1">
                  <xsd:selector xpath="lfb:component"/>
                  <xsd:field xpath="@componentID"/>
                </xsd:key>
              </xsd:element>
              <!-- /Extension RFC 7408 -->
            </xsd:choice>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
]]></artwork>
        </figure>
    </section>
    <section title="Optional Default Values for Data Types" anchor="dvd">
      <t>In the original schema, default values can only be defined for
      data types defined inside LFB components and not inside structures or
      arrays. Therefore, default values for data types that are constantly being
      reused, e.g., counters with default value of 0, have to be constantly
      respecified. Additionally, data types inside complex data types cannot be
      defined with a default value, e.g., a counter inside a struct that has a
      default value of 0.</t>

      <t>This extension allows the option to add default values to
      data types. These data types can then be referenced as simple components
      or within complex data types such as structs. A simple use case would be
      to have a struct component where one of the components is a counter
      with a default value of zero. To achieve that, the counter must
      first be defined as a data type with the required default value and then
      referenced in the struct. Default values MUST adhere the following
      formal restrictions:</t>

      <t><list style="numbers">
        <t>Default values MUST be ignored if the data type is not an atomic or
	a base data type.</t>

        <t>When a data type X with default value A is referenced from a
	data type Y with a default value B, the default value of the data type
	that references overrides the referenced default value, e.g., in this
	case, Y's default value will be B.</t>

        <t>Default values of LFB components override any default value
	specified from the dataTypeDef definition.</t>

        <t>Default values of data types referenced in capabilities or metadata
	MUST be ignored.</t>

      </list>
      </t>
      <t>This extension simply adds to the definition of
      dataTypeDefsType in the XML schema shown in <xref
      target="InitTypeDecl"></xref> to
      allow default values for dataTypeDefsType. The new definition is shown
      in <xref target="NewTypeDecl"></xref>.</t>

        <figure title="Initial Excerpt of dataTypeDefsType Definition in the Schema" anchor="InitTypeDecl">
          <artwork align="left"><![CDATA[
  <xsd:complexType name="dataTypeDefsType">
    <xsd:sequence>
      <xsd:element name="dataTypeDef" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element name="derivedFrom" type="xsd:NMTOKEN" 
               minOccurs="0"/>
            <xsd:element ref="synopsis"/>
            <xsd:element ref="description" minOccurs="0"/>
            <xsd:group ref="typeDeclarationGroup"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
]]></artwork>
        </figure>
        <figure title="New Excerpt of dataTypeDefsType Definition in the Schema" anchor="NewTypeDecl">
          <artwork align="left"><![CDATA[
  <xsd:complexType name="dataTypeDefsType">
    <xsd:sequence>
      <xsd:element name="dataTypeDef" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element name="derivedFrom" type="xsd:NMTOKEN" 
               minOccurs="0"/>
            <xsd:element ref="synopsis"/>
            <xsd:element ref="description" minOccurs="0"/>
            <xsd:group ref="typeDeclarationGroup"/>
            <!-- Extension RFC 7408 -->
            <xsd:element name="defaultValue" type="xsd:token" 
               minOccurs="0"/>
            <!-- /Extension RFC 7408 -->
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
]]></artwork>
        </figure>
        <t>Examples of using default values is depicted in <xref target="TypeDeclExample"></xref>.</t>
        <figure title="Example of Optional Default Values" anchor="TypeDeclExample">
          <artwork align="left"><![CDATA[
  <dataTypeDef>
    <name>ZeroCounter</name>
    <synopsis>A counter with default 0</synopsis>
    <typeRef>uint32</typeRef>
    <defaultValue>0</defaultValue>
  </dataTypeDef>
  <dataTypeDef>
    <name>CounterValues</name>
    <synopsis>Example default values in struct</synopsis>
    <struct>
      <component componentID="1">
        <name>GoodPacketCounter</name>
        <synopsis>A counter for good packets</synopsis>
        <typeRef>ZeroCounter</typeRef>
      </component>
      <component componentID="2">
        <name>BadPacketCounter</name>
        <synopsis>A counter for bad packets</synopsis>
        <typeRef>ZeroCounter</typeRef>
      </component>
    </struct>
  </dataTypeDef>
]]></artwork>
        </figure>
    </section>
    <section title="Optional Access Types for Structs" anchor="ats">
      <t>In the original schema, the access type can only be defined on
      components of an LFB and not on components within structs or
      arrays. That means that when it is a struct data type, it is not possible
      to fine-tune access type per component within the struct. A simple use
      case would be to have a read-write struct component where one of the
      components is a counter with an access type that could be read-reset or
      read-only, e.g., a read-reset or a read-only counter inside a
      struct.</t>

      <t>This extension allows the definition of the access type for a struct
      component either in the data type definitions or in the LFB component
      definitions.</t>

      <t>When optional access types for components within a struct are defined,
      the access types for these components MUST override the access type of the
      struct. For example, if a struct has an access type of read-write but has
      a component that is a read-only counter, the counter's access type MUST
      be read-only.</t>

      <t>Per <xref target="RFC5812"></xref>, the access type for a component
      in a capability is always read-only. If an access type is provided for a
      component in a capability, the access type MUST be ignored. Similarly, if
      an access type is provided for a struct in a metadata, the access type
      MUST be ignored.</t>

      <t>This extension alters the definition of the struct in the XML schema
      from the initial definition shown in <xref target="StructInitial"></xref> to
      the new shown in <xref
      target="StructNew"></xref>.</t>


        <figure title="Initial XML for the Struct Definition in the Schema" anchor="StructInitial">
          <artwork align="left"><![CDATA[
  <xsd:complexType name="structType">
    <xsd:sequence>
      <xsd:element name="derivedFrom" type="typeRefNMTOKEN" 
        minOccurs="0"/>
      <xsd:element name="component" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element ref="synopsis"/>
            <xsd:element ref="description" minOccurs="0"/>
            <xsd:element name="optional" minOccurs="0"/>
            <xsd:group ref="typeDeclarationGroup"/>
          </xsd:sequence>
          <xsd:attribute name="componentID" type="xsd:unsignedInt"
           use="required"/>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
]]></artwork>
        </figure>
        <figure title="New XML for the Struct Definition in the Schema" anchor="StructNew">
          <artwork align="left"><![CDATA[
  <xsd:complexType name="structType">
    <xsd:sequence>
      <xsd:element name="derivedFrom" type="typeRefNMTOKEN" 
        minOccurs="0"/>
      <xsd:element name="component" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element ref="synopsis"/>
            <xsd:element ref="description" minOccurs="0"/>
            <xsd:element name="optional" minOccurs="0"/>
            <xsd:group ref="typeDeclarationGroup"/>
          </xsd:sequence>
          <!-- Extension RFC 7408 -->
          <xsd:attribute name="access" use="optional" 
            default="read-write">
            <xsd:simpleType>
              <xsd:list itemType="accessModeType"/>
            </xsd:simpleType>
          </xsd:attribute>
          <!-- /Extension RFC 7408 -->
          <xsd:attribute name="componentID" type="xsd:unsignedInt" 
            use="required"/>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
]]></artwork>
        </figure>
        <t>An example of using optional access types for structs is depicted in <xref target="StructExample"></xref>.</t>
        <figure title="Example of Optional Access Types for Struct" anchor="StructExample">
          <artwork align="left"><![CDATA[
   <component componentID="1" access="read-write">
      <name>PacketFlows</name>
      <synopsis>Packet Flows, match and counter</synopsis>
      <struct>
       <component componentID="1">
         <name>FlowMatch</name>
         <synopsis>Flow Match</synopsis>
         <typeRef>MatchType</typeRef>
       </component>
       <component componentID="2" access="read-only">
         <name>MatchCounter</name>
         <synopsis>Packets matching the flow match</synopsis>
         <typeRef>ZeroCounter</typeRef>
       </component>
     </struct>
   </component>
        ]]></artwork>
        </figure>
      </section>

    <section title="New Event Condition: eventBecomesEqualTo" anchor="bet">

      <t>This extension adds one more event condition in the model schema,
      eventBecomesEqualTo. 
eventBecomesEqualTo is different from eventGreaterThan and
eventLessThan because the event is triggered when the value is exactly
that of the eventBecomesEqualTo threshold.
This event condition is particularly useful when
      there is a need to monitor one or more states of an LFB or the FE. For
      example, in the <xref target="RFC7121">Control Element High Availability (CEHA) document</xref>,
      it may be useful for the master CE to know which backup CEs have
      just become associated in order to connect to them and begin
      synchronizing the state of the FE. The master CE could always poll for
      such information, but getting such an event will speed up the process, and
      the event may be useful in other cases as well for monitoring state.</t>

      <t>The event MUST be triggered only when the value of the targeted component becomes equal to the event condition value. Implementations MUST NOT generate subsequent events while the targeted component's value remains equal to the event condition's value.</t>
      <t>eventBecomesEqualTo is appended to the schema as shown in <xref
      target="EqualToDecl"></xref>.</t>


        <figure title="New Excerpt of eventBecomesEqualTo Event Condition Definition in the Schema" anchor="EqualToDecl">
          <artwork align="left"><![CDATA[
  <xsd:element name="eventBecomesEqualTo"
    substitutionGroup="eventCondition"/>
]]></artwork>
        </figure>
      <t>It can become useful for the CE to be notified when the state has
      changed once the eventBecomesEqualTo event has been triggered, e.g., the CE
      may need to know when a backup CE has lost association. Such an event
      can be generated either by defining a second event on the same
      component (namely, an eventChanged) or by simply reusing eventBecomesEqualTo
      and using event properties (in particular, eventHysteresis). We append the
      following definition to the eventHysteresis defined in Section 4.8.5.2
      of <xref target="RFC5812"></xref>, with V being the hysteresis
      value:</t>

      <t><list style="symbols">
        <t>For an eventBecomesEqualTo condition, after the last
	notification, a new eventBecomesEqualTo notification MUST be
	generated only one time once the value has changed by +/- V.</t>

      </list></t>
      <t>For example, using the value of 1 for V will, in effect, create a
      singular event that will notify the CE that the value has changed by at
      least 1.</t>

      <t>A developer of a CE should consider using count or time filtering to
      avoid being overrun by messages, e.g., in the case of rapid state
      changes.</t>

    </section>
    <section title="LFB Properties" anchor="LFBp">
    <t>The previous model definition specifies properties for components of
    LFBs. Experience has shown that, at least for debug reasons, it would be
    useful to have statistics per LFB instance to monitor sent and received
    messages and errors in communication between a CE and FE. These properties
    are read-only.</t>

    <t>In order to avoid ambiguity on protocol path semantics, this document
    specifies that the LFB componentID 0 specifically MUST refer to LFB
    properties and ID 0 MUST NOT be used for any component definition. This
    disallowance is backward compatible as no known LFB definition uses an LFB
    componentID 0. Any command with a path starting from LFB componentID 0
    refers to LFB properties. Figures <xref target="Comp0Initial" format="counter"
    /> and <xref target="Comp0New" format="counter" /> illustrate the change in the XML schema that
    disallows
    usage of LFB componentID 0:</t>

    <figure title="Initial XML for LFB componentIDs" anchor="Comp0Initial">
          <artwork align="left"><![CDATA[
   <xsd:attribute name="componentID" type="xsd:unsignedInt"
    use="required">
]]></artwork>
        </figure>
        <figure title="New XML to Disallow Usage of LFB componentID 0" anchor="Comp0New">
          <artwork align="left"><![CDATA[
   <!-- Extension added restriction to componentID -->
   <xsd:attribute name="componentID" use="required">
     <xsd:simpleType>
       <xsd:restriction base="xsd:unsignedInt">
         <xsd:minExclusive value="0"/>
       </xsd:restriction>
     </xsd:simpleType>
   </xsd:attribute>
   <!-- End of extension -->
]]></artwork>
        </figure>
    <t>The following data type definitions are to be used as properties for LFB instances.</t>
    <t>
      <figure title="Properties for LFB Instances" anchor="PropofLFBInst">
        <artwork><![CDATA[
   <dataTypeDef>
      <name>LFBProperties</name>
      <synopsis>LFB Properties definition</synopsis>
      <struct>
         <component componentID="1">
            <name>PacketsSentToCE</name>
            <synopsis>Packets sent to CE</synopsis>
            <typeRef>uint32</typeRef>
         </component>
         <component componentID="2">
            <name>SentErrorPacketsToCE</name>
            <synopsis>Error Packets sent to CE</synopsis>
            <typeRef>uint32</typeRef>
         </component>
         <component componentID="3">
            <name>BytesSentToCE</name>
            <synopsis>Bytes sent to CE</synopsis>
            <typeRef>uint32</typeRef>
         </component>
         <component componentID="4">
            <name>SentErrorBytesToCE</name>
            <synopsis>Error Bytes sent to CE</synopsis>
            <typeRef>uint32</typeRef>
         </component>
         <component componentID="5">
            <name>PacketsReceivedFromCE</name>
            <synopsis>Packets received from CE</synopsis>
            <typeRef>uint32</typeRef>
         </component>
         <component componentID="6">
            <name>ReceivedErrorPacketsFromCE</name>
            <synopsis>Error Packets received from CE</synopsis>
            <typeRef>uint32</typeRef>
         </component>
         <component componentID="7">
            <name>BytesReceivedFromCE</name>
            <synopsis>Bytes received from CE</synopsis>
            <typeRef>uint32</typeRef>
         </component>
         <component componentID="8">
            <name>ReceivedErrorBytesFromCE</name>
            <synopsis>Error Bytes received from CE</synopsis>
            <typeRef>uint32</typeRef>
         </component>
      </struct>
   </dataTypeDef>        ]]>
        </artwork>
      </figure>
    </t>    
    </section> 
    <section title="LFB Class Inheritance" anchor="LFBCI">
      <t>The <xref target="RFC5812">ForCES model</xref> allows inheritance for
      LFB classes. However, the XML schema defines only the LFB class from
      which an LFB class inherits. Recent implementations have identified an
      issue where ambiguity rises when different versions of the parent LFB
      class exist. This document augments the derivedFrom part of the LFB
      class definition with an optional version attribute when the derivedFrom
      field is used.</t>

      <t>Having the version attribute as optional was a decision based on the
      need to maintain backward compatibility with the XML schema defined in
      <xref target="RFC5812"></xref>. However, if the version is omitted, then
      derivedFrom will always specify the first version of the parent LFB
      class, which usually is version 1.0.</t>

      <t>This extension alters the definition of derivedFrom in the XML
      schema from
the initial definition shown in <xref target="InheritInitial"></xref> to the new
shown in <xref
      target="InheritNew"></xref>.</t>

        <figure title="Initial XML for LFB Class Inheritance" anchor="InheritInitial">
          <artwork align="left"><![CDATA[
   <xsd:element name="derivedFrom" minOccurs="0"/>]]></artwork>
        </figure>
        <figure title="New XML for LFB Class Inheritance" anchor="InheritNew">
          <artwork align="left"><![CDATA[
   <xsd:element name="derivedFrom" minOccurs="0">
     <xsd:complexType>
       <xsd:simpleContent>
         <xsd:extension base="xsd:NMTOKEN">
           <xsd:attribute name="version" 
             type="versionType" use="optional"/>
         </xsd:extension>
       </xsd:simpleContent>
     </xsd:complexType>
   </xsd:element>
]]></artwork>
        </figure>
        <t>An example of the use of the version attribute is given in <xref target="InheritExample"></xref>.</t>
        <figure title="Example of Use of New XML for LFB Class Inheritance" anchor="InheritExample">
          <artwork align="left"><![CDATA[
   <derivedFrom version="1.0">EtherPHYCop</derivedFrom>
]]></artwork>
			</figure>
    </section>
    <section title="Enhancing XML Validation" anchor="EXV">
      <t>As specified earlier, this is not an extension but an enhancement of
      the schema to provide additional validation rules. This includes adding
      new key declarations to provide uniqueness as defined by the <xref
      target="RFC5812">ForCES model</xref>. Such validations work only
      within the same XML file.</t>

      <t>This document introduces the following validation rules that did not exist in the original schema in <xref target="RFC5812"></xref>:</t>
      <t><list style="numbers">
        <t>Each metadataID must be unique.</t>
        <t>LFBClassIDs must be unique.</t>
        <t>componentID, capabilityID, and Event baseID must be unique per LFB.</t>
        <t>eventIDs must be unique per LFB.</t>
        <t>Special values in atomic data types must be unique per atomic data type.</t>
      </list></t>
    </section>
  </section>
  <section title="XML Extension Schema for LFB Class Library Documents">
  <t>This section includes the new XML schema. Note that the namespace number
  has been updated from 1.0 to 1.1.</t>

<t>
The extensions described in this document are backwards compatible 
in terms of the operation of the ForCES protocol.  In terms of the 
XML, any definitions that were valid under the old namespace are 
valid under the new namespace.  It is to be noted that any auxiliary 
tools that are processing XML definitions written under both 
namespaces will need to be able to understand both.
</t>
      <t>
        <figure title="ForCES LFB XML Schema" align="left">
          <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
   xmlns="urn:ietf:params:xml:ns:forces:lfbmodel:1.1" 
   xmlns:lfb="urn:ietf:params:xml:ns:forces:lfbmodel:1.1"
   targetNamespace="urn:ietf:params:xml:ns:forces:lfbmodel:1.1"
   elementFormDefault="qualified" attributeFormDefault="unqualified">
   <xsd:annotation>
      <xsd:documentation xml:lang="en">
         Schema for Defining LFB Classes and associated types 
         (frames, data types for LFB attributes, and metadata).
      </xsd:documentation>
   </xsd:annotation>
   <xsd:element name="description" type="xsd:string"/>
   <xsd:element name="synopsis" type="xsd:string"/>
   <!-- Document root element: LFBLibrary -->
   <xsd:element name="LFBLibrary">
      <xsd:complexType>
         <xsd:sequence>
            <xsd:element ref="description" minOccurs="0"/>
            <xsd:element name="load" type="loadType"
               minOccurs="0" maxOccurs="unbounded"/>
            <xsd:element name="frameDefs" type="frameDefsType"
               minOccurs="0"/>
            <xsd:element name="dataTypeDefs" type="dataTypeDefsType"
               minOccurs="0"/>
            <xsd:element name="metadataDefs" type="metadataDefsType"
               minOccurs="0"/>
            <xsd:element name="LFBClassDefs" type="LFBClassDefsType"
               minOccurs="0"/>
         </xsd:sequence>
         <xsd:attribute name="provides" type="xsd:Name"
            use="required"/>
      </xsd:complexType>
      <!-- Uniqueness constraints -->
      <xsd:key name="frame">
         <xsd:selector xpath="lfb:frameDefs/lfb:frameDef"/>
         <xsd:field xpath="lfb:name"/>
      </xsd:key>
      <xsd:key name="dataType">
         <xsd:selector xpath="lfb:dataTypeDefs/lfb:dataTypeDef"/>
         <xsd:field xpath="lfb:name"/>
      </xsd:key>
      <xsd:key name="metadataDef">
         <xsd:selector xpath="lfb:metadataDefs/lfb:metadataDef"/>
         <xsd:field xpath="lfb:name"/>
      </xsd:key>
      <xsd:key name="metadataDefID">
         <xsd:selector xpath="lfb:metadataDefs/lfb:metadataDef"/>
         <xsd:field xpath="lfb:metadataID"/>
      </xsd:key>
      <xsd:key name="LFBClassDef">
         <xsd:selector xpath="lfb:LFBClassDefs/lfb:LFBClassDef"/>
         <xsd:field xpath="lfb:name"/>
      </xsd:key>
      <xsd:key name="LFBClassDefID">
         <xsd:selector xpath="lfb:LFBClassDefs/lfb:LFBClassDef"/>
         <xsd:field xpath="@LFBClassID"/>
      </xsd:key>
   </xsd:element>
   <xsd:complexType name="loadType">
      <xsd:attribute name="library" type="xsd:Name" use="required"/>
      <xsd:attribute name="location" type="xsd:anyURI"
         use="optional"/>
   </xsd:complexType>
   <xsd:complexType name="frameDefsType">
      <xsd:sequence>
         <xsd:element name="frameDef" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN"/>
                  <xsd:element ref="synopsis"/>
                  <xsd:element ref="description"
                     minOccurs="0"/>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="dataTypeDefsType">
      <xsd:sequence>
         <xsd:element name="dataTypeDef" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN"/>
                  <xsd:element name="derivedFrom" type="xsd:NMTOKEN"
                     minOccurs="0"/>
                  <xsd:element ref="synopsis"/>
                  <xsd:element ref="description"
                     minOccurs="0"/>
                  <xsd:group ref="typeDeclarationGroup"/>
                  <!-- Extension RFC 7408 -->
                  <xsd:element name="defaultValue" type="xsd:token" 
                     minOccurs="0"/>
                  <!-- /Extension RFC 7408 -->
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <!-- Predefined (built-in) atomic data-types are: char, uchar, 
   int16, uint16, int32, uint32, int64, uint64, string[N], string,
   byte[N], boolean, octetstring[N], float32, float64 -->
   <xsd:group name="typeDeclarationGroup">
      <xsd:choice>
         <xsd:element name="typeRef" type="typeRefNMTOKEN"/>
         <xsd:element name="atomic" type="atomicType"/>
         <xsd:element name="array" type="arrayType">
            <!-- Extension RFC 7408 -->
            <!-- declare keys to have unique IDs -->
            <xsd:key name="contentKeyID">
               <xsd:selector xpath="lfb:contentKey"/>
               <xsd:field xpath="@contentKeyID"/>
            </xsd:key>
            <!-- /Extension RFC 7408 -->
         </xsd:element>
         <xsd:element name="struct" type="structType">
            <!-- Extension RFC 7408 -->
            <!-- key declaration to make componentIDs
              unique in a struct -->
            <xsd:key name="structComponentID">
               <xsd:selector xpath="lfb:component"/>
               <xsd:field xpath="@componentID"/>
            </xsd:key>
            <!-- /Extension RFC 7408 -->
         </xsd:element>
         <xsd:element name="union" type="structType"/>
         <xsd:element name="alias" type="typeRefNMTOKEN"/>
      </xsd:choice>
   </xsd:group>
   <xsd:simpleType name="typeRefNMTOKEN">
      <xsd:restriction base="xsd:token">
         <xsd:pattern value="\c+"/>
         <xsd:pattern value="string\[\d+\]"/>
         <xsd:pattern value="byte\[\d+\]"/>
         <xsd:pattern value="octetstring\[\d+\]"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="atomicType">
      <xsd:sequence>
         <xsd:element name="baseType" type="typeRefNMTOKEN"/>
         <xsd:element name="rangeRestriction" 
           type="rangeRestrictionType" minOccurs="0"/>
         <xsd:element name="specialValues" type="specialValuesType"
            minOccurs="0">
            <!-- Extension RFC 7408 -->
            <xsd:key name="SpecialValue">
               <xsd:selector xpath="specialValue"/>
               <xsd:field xpath="@value"/>
            </xsd:key>
            <!-- /Extension RFC 7408 -->
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="rangeRestrictionType">
      <xsd:sequence>
         <xsd:element name="allowedRange" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:attribute name="min" type="xsd:integer"
                  use="required"/>
               <xsd:attribute name="max" type="xsd:integer"
                  use="required"/>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="specialValuesType">
      <xsd:sequence>
         <xsd:element name="specialValue" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN"/>
                  <xsd:element ref="synopsis"/>
               </xsd:sequence>
               <xsd:attribute name="value" type="xsd:token"/>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="arrayType">
      <xsd:sequence>
         <xsd:group ref="typeDeclarationGroup"/>
         <xsd:element name="contentKey" minOccurs="0"
            maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="contentKeyField"
                     type="xsd:string" maxOccurs="unbounded"/>
               </xsd:sequence>
               <xsd:attribute name="contentKeyID" type="xsd:integer"
                  use="required"/>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
      <xsd:attribute name="type" use="optional" default="variable-size">
         <xsd:simpleType>
            <xsd:restriction base="xsd:string">
               <xsd:enumeration value="fixed-size"/>
               <xsd:enumeration value="variable-size"/>
            </xsd:restriction>
         </xsd:simpleType>
      </xsd:attribute>
      <xsd:attribute name="length" type="xsd:integer"
         use="optional"/>
      <xsd:attribute name="maxLength" type="xsd:integer"
         use="optional"/>
   </xsd:complexType>
   <xsd:complexType name="structType">
      <xsd:sequence>
         <xsd:element name="derivedFrom" type="typeRefNMTOKEN"
            minOccurs="0"/>
         <xsd:element name="component" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN"/>
                  <xsd:element ref="synopsis"/>
                  <xsd:element ref="description"
                     minOccurs="0"/>
                  <xsd:element name="optional" minOccurs="0"/>
                  <xsd:group ref="typeDeclarationGroup"/>
               </xsd:sequence>
               <!-- Extension RFC 7408 -->
               <xsd:attribute name="access" use="optional"
                  default="read-write">
                  <xsd:simpleType>
                     <xsd:list itemType="accessModeType"/>
                  </xsd:simpleType>
               </xsd:attribute>
               <!-- Extension RFC 7408 -->
               <xsd:attribute name="componentID" type="xsd:unsignedInt"
                  use="required"/>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="metadataDefsType">
      <xsd:sequence>
         <xsd:element name="metadataDef" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN"/>
                  <xsd:element ref="synopsis"/>
                  <xsd:element name="metadataID" type="xsd:integer"/>
                  <xsd:element ref="description"
                     minOccurs="0"/>
                  <xsd:choice>
                     <xsd:element name="typeRef" type="typeRefNMTOKEN"/>
                     <xsd:element name="atomic" type="atomicType"/>
                     <!-- Extension RFC 7408 -->
                     <xsd:element name="array" type="arrayType">
                        <!--declare keys to have unique IDs -->
                        <xsd:key name="contentKeyID1">
                           <xsd:selector xpath="lfb:contentKey"/>
                           <xsd:field xpath="@contentKeyID"/>
                        </xsd:key>
                        <!-- /Extension RFC 7408 -->
                     </xsd:element>
                     <xsd:element name="struct" type="structType">
                        <!-- Extension RFC 7408 -->
                        <!-- key declaration to make componentIDs
                           unique in a struct -->
                        <xsd:key name="structComponentID1">
                           <xsd:selector xpath="lfb:component"/>
                           <xsd:field xpath="@componentID"/>
                        </xsd:key>
                        <!-- /Extension RFC 7408 -->
                     </xsd:element>
                  </xsd:choice>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="LFBClassDefsType">
      <xsd:sequence>
         <xsd:element name="LFBClassDef" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN"/>
                  <xsd:element ref="synopsis"/>
                  <xsd:element name="version" type="versionType"/>
                  <xsd:element name="derivedFrom" minOccurs="0">
                    <xsd:complexType>
                      <xsd:simpleContent>
                        <xsd:extension base="xsd:NMTOKEN">
                          <xsd:attribute name="version" 
                            type="versionType" use="optional"/>
                        </xsd:extension>
                      </xsd:simpleContent>
                    </xsd:complexType>
                  </xsd:element>
                  <xsd:element name="inputPorts"
                   type="inputPortsType" minOccurs="0"/>
                  <xsd:element name="outputPorts"
                   type="outputPortsType" minOccurs="0"/>
                  <xsd:element name="components" 
                   type="LFBComponentsType" minOccurs="0"/>
                  <xsd:element name="capabilities"
                   type="LFBCapabilitiesType" minOccurs="0"/>
                  <xsd:element name="events" type="eventsType"
                     minOccurs="0"/>
                  <xsd:element ref="description"
                     minOccurs="0"/>
               </xsd:sequence>
               <xsd:attribute name="LFBClassID" type="xsd:unsignedInt"
                  use="required"/>
            </xsd:complexType>
            <!-- Key constraint to ensure unique attribute names 
            within a class: -->
            <xsd:key name="components">
               <xsd:selector xpath="lfb:components/lfb:component"/>
               <xsd:field xpath="lfb:name"/>
            </xsd:key>
            <xsd:key name="capabilities">
               <xsd:selector xpath="lfb:capabilities/lfb:capability"/>
               <xsd:field xpath="lfb:name"/>
            </xsd:key>
            <xsd:key name="events">
               <xsd:selector xpath="lfb:events/lfb:event"/>
               <xsd:field xpath="lfb:name"/>
            </xsd:key>
            <xsd:key name="eventsIDs">
               <xsd:selector xpath="lfb:events/lfb:event"/>
               <xsd:field xpath="@eventID"/>
            </xsd:key>
            <xsd:key name="componentIDs">
               <xsd:selector xpath="lfb:components/lfb:component"/>
               <xsd:field xpath="@componentID"/>
            </xsd:key>
            <xsd:key name="capabilityIDs">
               <xsd:selector xpath="lfb:capabilities/lfb:capability"/>
               <xsd:field xpath="@componentID"/>
            </xsd:key>
            <xsd:key name="ComponentCapabilityComponentIDUniqueness">
               <xsd:selector
                  xpath="lfb:components/lfb:component|
                  lfb:capabilities/lfb:capability|lfb:events"/>
               <xsd:field xpath="@componentID|@baseID"/>
            </xsd:key>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:simpleType name="versionType">
      <xsd:restriction base="xsd:NMTOKEN">
         <xsd:pattern value="[1-9][0-9]*\.([1-9][0-9]*|0)"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="inputPortsType">
      <xsd:sequence>
         <xsd:element name="inputPort" type="inputPortType"
            maxOccurs="unbounded"/>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="inputPortType">
      <xsd:sequence>
         <xsd:element name="name" type="xsd:NMTOKEN"/>
         <xsd:element ref="synopsis"/>
         <xsd:element name="expectation" type="portExpectationType"/>
         <xsd:element ref="description" minOccurs="0"/>
      </xsd:sequence>
      <xsd:attribute name="group" type="xsd:boolean"
         use="optional" default="0"/>
   </xsd:complexType>
   <xsd:complexType name="portExpectationType">
      <xsd:sequence>
         <xsd:element name="frameExpected" minOccurs="0">
            <xsd:complexType>
               <xsd:sequence>
                  <!-- ref must refer to a name of a defined 
                    frame type -->
                  <xsd:element name="ref" type="xsd:string"
                     maxOccurs="unbounded"/>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="metadataExpected" minOccurs="0">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded">
                  <!--ref must refer to a name of a defined metadata-->
                  <xsd:element name="ref" type="metadataInputRefType"/>
                  <xsd:element name="one-of"
                     type="metadataInputChoiceType"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="metadataInputChoiceType">
      <xsd:choice minOccurs="2" maxOccurs="unbounded">
         <!-- ref must refer to a name of a defined metadata -->
         <xsd:element name="ref" type="xsd:NMTOKEN"/>
         <xsd:element name="one-of" type="metadataInputChoiceType"/>
         <xsd:element name="metadataSet" type="metadataInputSetType"/>
      </xsd:choice>
   </xsd:complexType>
   <xsd:complexType name="metadataInputSetType">
      <xsd:choice minOccurs="2" maxOccurs="unbounded">
         <!-- ref must refer to a name of a defined metadata -->
         <xsd:element name="ref" type="metadataInputRefType"/>
         <xsd:element name="one-of" type="metadataInputChoiceType"/>
      </xsd:choice>
   </xsd:complexType>
   <xsd:complexType name="metadataInputRefType">
      <xsd:simpleContent>
         <xsd:extension base="xsd:NMTOKEN">
            <xsd:attribute name="dependency" use="optional"
               default="required">
               <xsd:simpleType>
                  <xsd:restriction base="xsd:string">
                     <xsd:enumeration value="required"/>
                     <xsd:enumeration value="optional"/>
                  </xsd:restriction>
               </xsd:simpleType>
            </xsd:attribute>
            <xsd:attribute name="defaultValue" type="xsd:token"
               use="optional"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:complexType name="outputPortsType">
      <xsd:sequence>
         <xsd:element name="outputPort" type="outputPortType"
            maxOccurs="unbounded"/>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="outputPortType">
      <xsd:sequence>
         <xsd:element name="name" type="xsd:NMTOKEN"/>
         <xsd:element ref="synopsis"/>
         <xsd:element name="product" type="portProductType"/>
         <xsd:element ref="description" minOccurs="0"/>
      </xsd:sequence>
      <xsd:attribute name="group" type="xsd:boolean"
         use="optional" default="0"/>
   </xsd:complexType>
   <xsd:complexType name="portProductType">
      <xsd:sequence>
         <xsd:element name="frameProduced" minOccurs="0">
            <xsd:complexType>
               <xsd:sequence>
                  <!-- ref must refer to a name of a defined
                     frame type -->
                  <xsd:element name="ref" type="xsd:NMTOKEN"
                     maxOccurs="unbounded"/>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="metadataProduced" minOccurs="0">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded">
                  <!-- ref must refer to a name of a
                     defined metadata -->
                  <xsd:element name="ref"
                     type="metadataOutputRefType"/>
                  <xsd:element name="one-of"
                     type="metadataOutputChoiceType"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="metadataOutputChoiceType">
      <xsd:choice minOccurs="2" maxOccurs="unbounded">
         <!-- ref must refer to a name of a defined metadata -->
         <xsd:element name="ref" type="xsd:NMTOKEN"/>
         <xsd:element name="one-of" type="metadataOutputChoiceType"/>
         <xsd:element name="metadataSet" type="metadataOutputSetType"/>
      </xsd:choice>
   </xsd:complexType>
   <xsd:complexType name="metadataOutputSetType">
      <xsd:choice minOccurs="2" maxOccurs="unbounded">
         <!-- ref must refer to a name of a defined metadata -->
         <xsd:element name="ref" type="metadataOutputRefType"/>
         <xsd:element name="one-of" type="metadataOutputChoiceType"/>
      </xsd:choice>
   </xsd:complexType>
   <xsd:complexType name="metadataOutputRefType">
      <xsd:simpleContent>
         <xsd:extension base="xsd:NMTOKEN">
            <xsd:attribute name="availability" use="optional"
               default="unconditional">
               <xsd:simpleType>
                  <xsd:restriction base="xsd:string">
                     <xsd:enumeration value="unconditional"/>
                     <xsd:enumeration value="conditional"/>
                  </xsd:restriction>
               </xsd:simpleType>
            </xsd:attribute>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:complexType name="LFBComponentsType">
      <xsd:sequence>
         <xsd:element name="component" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN"/>
                  <xsd:element ref="synopsis"/>
                  <xsd:element ref="description"
                     minOccurs="0"/>
                  <xsd:element name="optional" minOccurs="0"/>
                  <xsd:group ref="typeDeclarationGroup"/>
                  <xsd:element name="defaultValue" type="xsd:token" 
                     minOccurs="0"/>
               </xsd:sequence>
               <xsd:attribute name="access" use="optional"
                  default="read-write">
                  <xsd:simpleType>
                     <xsd:list itemType="accessModeType"/>
                  </xsd:simpleType>
               </xsd:attribute>
               <!-- Extension added restriction to componentID -->
               <xsd:attribute name="componentID" use="required">
                  <xsd:simpleType>
                     <xsd:restriction base="xsd:unsignedInt">
                        <xsd:minExclusive value="0"/>
                     </xsd:restriction>
                  </xsd:simpleType>
               </xsd:attribute>
               <!-- End of extension -->
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:simpleType name="accessModeType">
      <xsd:restriction base="xsd:NMTOKEN">
         <xsd:enumeration value="read-only"/>
         <xsd:enumeration value="read-write"/>
         <xsd:enumeration value="write-only"/>
         <xsd:enumeration value="read-reset"/>
         <xsd:enumeration value="trigger-only"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="LFBCapabilitiesType">
      <xsd:sequence>
         <xsd:element name="capability" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN"/>
                  <xsd:element ref="synopsis"/>
                  <xsd:element ref="description"
                     minOccurs="0"/>
                  <xsd:element name="optional" minOccurs="0"/>
                  <xsd:group ref="typeDeclarationGroup"/>
               </xsd:sequence>
               <xsd:attribute name="componentID" type="xsd:integer"
                  use="required"/>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="eventsType">
      <xsd:sequence>
         <xsd:element name="event" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN"/>
                  <xsd:element ref="synopsis"/>
                  <xsd:element name="eventTarget" 
                    type="eventPathType"/>
                  <xsd:element ref="eventCondition"/>
                  <xsd:element name="eventReports"
                   type="eventReportsType" minOccurs="0"/>
                  <xsd:element ref="description"
                     minOccurs="0"/>
               </xsd:sequence>
               <xsd:attribute name="eventID" type="xsd:integer"
                  use="required"/>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
      <xsd:attribute name="baseID" type="xsd:integer"
         use="optional"/>
   </xsd:complexType>
   <!-- the substitution group for the event conditions -->
   <xsd:element name="eventCondition" abstract="true"/>
   <xsd:element name="eventCreated"
    substitutionGroup="eventCondition"/>
   <xsd:element name="eventDeleted"
    substitutionGroup="eventCondition"/>
   <xsd:element name="eventChanged"
    substitutionGroup="eventCondition"/>
   <xsd:element name="eventGreaterThan"
    substitutionGroup="eventCondition"/>
   <xsd:element name="eventLessThan"
    substitutionGroup="eventCondition"/>
   <!-- Extension RFC 7408 -->
   <xsd:element name="eventBecomesEqualTo"
      substitutionGroup="eventCondition"/>
   <!-- /Extension RFC 7408 -->
   <xsd:complexType name="eventPathType">
      <xsd:sequence>
         <xsd:element ref="eventPathPart" maxOccurs="unbounded"/>
      </xsd:sequence>
   </xsd:complexType>
   <!-- the substitution group for the event path parts -->
   <xsd:element name="eventPathPart" type="xsd:string"
      abstract="true"/>
   <xsd:element name="eventField" type="xsd:string"
      substitutionGroup="eventPathPart"/>
   <xsd:element name="eventSubscript" type="xsd:string"
      substitutionGroup="eventPathPart"/>
   <xsd:complexType name="eventReportsType">
      <xsd:sequence>
         <xsd:element name="eventReport" type="eventPathType"
            maxOccurs="unbounded"/>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:simpleType name="booleanType">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="0"/>
         <xsd:enumeration value="1"/>
      </xsd:restriction>
   </xsd:simpleType>
</xsd:schema>
 ]]></artwork>
        </figure>
      </t>
  </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>IANA has registered a new XML namespace, as per the guidelines in <xref target="RFC3688">RFC 3688</xref>.</t>

   <t>URI: The URI for this namespace is:
   <list> <t>urn:ietf:params:xml:ns:forces:lfbmodel:1.1</t></list></t>

   <t>Registrant Contact: IESG</t>

   <t>XML: none, this is an XML namespace</t>

    </section>

    <section anchor="Security" title="Security Considerations">
    <t>This specification adds only a few constructs to the initial model
    defined in <xref target="RFC5812"/>, namely, a new event, some new
    properties, and a way to define optional access types and complex
    metadata. In addition, this document addresses and clarifies an issue with
    the inheritance model by introducing the version of the derivedFrom LFB
    class. These constructs and the update to the inheritance model do not change the
    nature of the initial model.</t>

      <t>Thus, the security considerations defined in <xref target="RFC5812"/>
      apply to this specification as well, as the changes proposed here are
      simply constructs to write XML library definitions, as <xref
      target="RFC5812"/> does. These changes, as well as the clarification of the
      inheritance issue of the initial model, have no effect on the security
      semantics of the protocol.</t>

      <t>In regard to pervasive monitoring (PM), as discussed in <xref
      target="RFC7258"/>, this specification defines ways to expose more
      complex information (namely, metadata) exchanged between LFBs and between
      CEs and FEs and a new event. These changes have very little or no effect
      in terms of making PM simpler or more effective to an attacker who
      controls the LFBs. The new metadata might make for slightly more elegant
      PM, but does not enable any new ways to (ab)use LFBs for PM. The
      same applies for the new event.</t>

      <t>Finally, this document does not provide any protocol specification
      and, as such, does not specify how information will be transmitted
      between respective entities. Thus, PM mitigation for a passive attacker
      that simply wants to eavesdrop on the information exchanged is out of the
      scope of this document.</t>

      
    </section>
  </middle>



  <back>

    <references title="Normative References">


<reference anchor='RFC5810' target='http://www.rfc-editor.org/info/rfc5810'>

<front>
<title>Forwarding and Control Element Separation (ForCES) Protocol Specification</title>
<author initials='A.' surname='Doria' fullname='A. Doria'>
<organization /></author>
<author initials='J.' surname='Hadi Salim' fullname='J. Hadi Salim'>
<organization /></author>
<author initials='R.' surname='Haas' fullname='R. Haas'>
<organization /></author>
<author initials='H.' surname='Khosravi' fullname='H. Khosravi'>
<organization /></author>
<author initials='W.' surname='Wang' fullname='W. Wang'>
<organization /></author>
<author initials='L.' surname='Dong' fullname='L. Dong'>
<organization /></author>
<author initials='R.' surname='Gopal' fullname='R. Gopal'>
<organization /></author>
<author initials='J.' surname='Halpern' fullname='J. Halpern'>
<organization /></author>
<date year='2010' month='March' />
</front>
<seriesInfo name='RFC' value='5810' />
<format type='TXT' octets='239754' target='http://www.rfc-editor.org/rfc/rfc5810.txt' />
</reference>



<reference anchor='RFC5812' target='http://www.rfc-editor.org/info/rfc5812'>
<front>
<title>Forwarding and Control Element Separation (ForCES) Forwarding Element Model</title>
<author initials='J.' surname='Halpern' fullname='J. Halpern'>
<organization /></author>
<author initials='J.' surname='Hadi Salim' fullname='J. Hadi Salim'>
<organization /></author>
<date year='2010' month='March' />
</front>
<seriesInfo name='RFC' value='5812' />
<format type='TXT' octets='301491' target='http://www.rfc-editor.org/rfc/rfc5812.txt' />
</reference>



<reference anchor='RFC7121' target='http://www.rfc-editor.org/info/rfc7121'>
<front>
<title>High Availability within a Forwarding and Control Element Separation (ForCES) Network Element</title>
<author initials='K.' surname='Ogawa' fullname='K. Ogawa'>
<organization /></author>
<author initials='W.' surname='Wang' fullname='W. Wang'>
<organization /></author>
<author initials='E.' surname='Haleplidis' fullname='E. Haleplidis'>
<organization /></author>
<author initials='J.' surname='Hadi Salim' fullname='J. Hadi Salim'>
<organization /></author>
<date year='2014' month='February' />
</front>
<seriesInfo name='RFC' value='7121' />
<format type='TXT' octets='62599' target='http://www.rfc-editor.org/rfc/rfc7121.txt' />
</reference>



<reference anchor='RFC2119' target='http://www.rfc-editor.org/info/rfc2119'>
<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
</front>
<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='http://www.rfc-editor.org/rfc/rfc2119.txt' />
<format type='HTML' octets='17970' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>



<reference anchor='RFC3688' target='http://www.rfc-editor.org/info/rfc3688'>
<front>
<title>The IETF XML Registry</title>
<author initials='M.' surname='Mealling' fullname='M. Mealling'>
<organization /></author>
<date year='2004' month='January' />
</front>
<seriesInfo name='BCP' value='81' />
<seriesInfo name='RFC' value='3688' />
<format type='TXT' octets='17325' target='http://www.rfc-editor.org/rfc/rfc3688.txt' />
</reference>



<reference anchor='RFC7258' target='http://www.rfc-editor.org/info/rfc7258'>
<front>
<title>Pervasive Monitoring Is an Attack</title>
<author initials='S.' surname='Farrell' fullname='S. Farrell'>
<organization /></author>
<author initials='H.' surname='Tschofenig' fullname='H. Tschofenig'>
<organization /></author>
<date year='2014' month='May' />
</front>
<seriesInfo name='BCP' value='188' />
<seriesInfo name='RFC' value='7258' />
<format type='TXT' octets='13396' target='http://www.rfc-editor.org/rfc/rfc7258.txt' />
</reference>

    </references>

    <references title="Informative References">


      <reference anchor="OpenFlowSpec1.1"
		 target="https://www.opennetworking.org/images/stories/downloads/sdn-resources/onf-specifications/openflow/openflow-spec-v1.1.0.pdf">
        <front>
          <title>OpenFlow Switch Specification</title>
          <author>
            <organization>ONF</organization>
          </author>
          <date month="February" year="2011"></date>
        </front>
      </reference>

    </references>



  <section anchor="Acknowledgements" title="Acknowledgements">
    <t>The author would like to acknowledge Joel Halpern, Jamal Hadi Salim, and
    Dave Hood for their comments and discussion that helped shape this
    document for the better. Special acknowledgements to Joel Halpern for
    resolving the issue with the default values, Adrian Farrel for his AD
    review, Ben Campbell for his Gen-ART review, and Tom Yu for his security
    review, all of which improved the quality of this document. Additionally,
    reviews and comments by the following members of the IESG shaped the final version of this
    document: Stephen Farrel, Barry Leiba, and Ted
    Lemon. Finally, the author would like to acknowledge Julian Reschke for
    input regarding the namespace change
    issue and Joel
    Halpern for helping to resolve it.</t>

  </section>


  </back>
</rfc>
