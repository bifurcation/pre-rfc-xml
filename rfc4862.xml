<?xml version="1.0"? encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc toc="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes"?>

<rfc number="4862" category="std" obsoletes="2462">
<front>

<title abbrev="IPv6 Stateless Address Autoconfiguration">
  IPv6 Stateless Address Autoconfiguration
 </title>
 <author initials="S" surname="Thomson" fullname="Susan Thomson">
  <organization abbrev="Cisco">Cisco Systems</organization>
  <address>
   <email>sethomso@cisco.com</email>
  </address>
 </author>

 <author initials="T" surname="Narten" fullname="Thomas Narten">
  <organization abbrev="IBM">IBM Corporation</organization>
  <address>
   <postal>
    <street>P.O. Box 12195</street>
    <city>Research Triangle Park</city> <region>NC</region> <code>27709-2195</code>
    <country>USA</country>
    </postal>
   <phone>+1 919-254-7798</phone>
   <email>narten@us.ibm.com</email>
   
  </address>
 </author>

 <author initials="T" surname="Jinmei" fullname="Tatuya Jinmei">
  <organization abbrev="Toshiba">Corporate Research & Development Center,
  Toshiba Corporation</organization>
  <address>
   <postal>
    <street>1 Komukai Toshiba-cho, Saiwai-ku</street>
    <city>Kawasaki-shi</city> <region>Kanagawa</region> <code>212-8582</code>
    <country>Japan</country>
   </postal>
   <phone>+81 44-549-2230</phone>
   <email>jinmei@isl.rdc.toshiba.co.jp</email>
  </address>
 </author>

 <date month="September" year="2007" />

 <area>Internet</area>
 <workgroup>IETF IPv6 Working Group</workgroup>

<!-- [rfced] Please insert additional keywords (beyond those that appear in
the title) for use on http://www.rfc-editor.org/search.html. -->
<!-- [TJ] I don't think of additional keywords. -->

 <keyword>IPv6</keyword>
 <keyword>stateless address autoconfiguration</keyword>
 <keyword>duplicate address detection</keyword>


 <abstract>
  <t>
   This document specifies the steps a host takes in deciding how to
   autoconfigure its interfaces in IP version 6.
   The autoconfiguration process includes generating a link-local address,
   generating global addresses via stateless address
   autoconfiguration, and the Duplicate Address Detection procedure to
   verify the uniqueness of the addresses on a link.
 </t>
 </abstract>
</front>

<middle>
<section title="Introduction">
<t>
   This document specifies the steps a host takes in deciding how to
   autoconfigure its interfaces in IP version 6 (IPv6).
   The autoconfiguration process includes generating a link-local address,
   generating global addresses via stateless address
   autoconfiguration, and the Duplicate Address Detection procedure to
   verify the uniqueness of the addresses on a link.
</t>

<t>
   The IPv6 stateless autoconfiguration mechanism requires no manual
   configuration of hosts, minimal (if any) configuration of routers,
   and no additional servers.  The stateless mechanism allows a host to
   generate its own addresses using a combination of locally available
   information and information advertised by routers. Routers advertise
   prefixes that identify the subnet(s) associated with a link, while
   hosts generate an "interface identifier" that uniquely identifies an
   interface on a subnet. An address is formed by combining the two. In
   the absence of routers, a host can only generate link-local
   addresses. However, link-local addresses are sufficient for allowing
   communication among nodes attached to the same link.
</t>

<t>
   The stateless approach is used when a site is not particularly
   concerned with the exact addresses hosts use, so long as they are
   unique and properly routable.
   On the other hand,
   Dynamic Host Configuration Protocol for IPv6 (DHCPv6)
   <xref target="RFC3315" />
   is used when a site requires tighter control over exact address
   assignments.
   Both stateless address autoconfiguration and DHCPv6 
   may be used simultaneously.
</t>

<t>
   IPv6 addresses are leased to an interface for a fixed (possibly
   infinite) length of time. Each address has an associated lifetime
   that indicates how long the address is bound to an interface. When a
   lifetime expires, the binding (and address) become invalid and the
   address may be reassigned to another interface elsewhere in the
   Internet. To handle the expiration of address bindings gracefully, an
   address goes through two distinct phases while assigned to an
   interface. Initially, an address is "preferred", meaning that its use
   in arbitrary communication is unrestricted. Later, an address becomes
   "deprecated" in anticipation that its current interface binding will
   become invalid. While an address is in a deprecated state, its use is
   discouraged, but not strictly forbidden.  New communication (e.g.,
   the opening of a new TCP connection) should use a preferred address
   when possible.  A deprecated address should be used only by
   applications that have been using it and would have difficulty
   switching to another address without a service disruption.
</t>

<?rfc needLines="4"?>
<t>
   To ensure that all configured addresses are likely to be unique on a
   given link, nodes run a "duplicate address detection" algorithm on
   addresses before assigning them to an interface.  The Duplicate
   Address Detection algorithm is performed on all addresses,
   independently of whether they are obtained via stateless
   autoconfiguration or DHCPv6.
   This document defines the Duplicate Address Detection algorithm.
</t>

<t>
   The autoconfiguration process specified in this document applies only
   to hosts and not routers. Since host autoconfiguration uses
   information advertised by routers, routers will need to be configured
   by some other means. However, it is expected that routers will
   generate link-local addresses using the mechanism described in this
   document. In addition, routers are expected to successfully pass the
   Duplicate Address Detection procedure described in this document on
   all addresses prior to assigning them to an interface.
</t>

<t>
   <xref target="terminology" /> provides definitions for terminology
   used throughout this
   document.
   <xref target="goals" /> describes the design goals that lead to the
   current autoconfiguration procedure.
   <xref target="overview" /> provides an overview
   of the protocol, while
   <xref target="spec" /> describes the protocol in detail.
</t>
</section>

<section anchor="terminology" title="Terminology">

<list style="hanging">
  <!--  <vspace blankLines='1' />  -->
  <!-- [TJ] Note to the editor: "vspace" was added to address format issues
  (bug?) in an older version of xml2rfc when the base I-D was written.
  It seems we don't need this any more.  So all unnecessary
  occurrences of "vspace" below are removed.
    -->
  <t hangText="IP -">Internet Protocol Version 6.
  The terms IPv4 and IPv6 are used
  only in contexts where necessary to avoid ambiguity.
  </t>
  <t hangText="node -">a device that implements IP.
  </t>
  <t hangText="router -">a node that forwards IP packets not
  explicitly addressed to itself.
  </t>
  <t hangText="host -">any node that is not a router.</t>
  <t hangText="upper layer -">a protocol layer immediately above IP.
  Examples are transport protocols such as TCP and UDP, control
  protocols such as ICMP, routing protocols such as OSPF, and Internet
  or lower-layer protocols being "tunneled" over (i.e., encapsulated in) IP
  such as IPX, AppleTalk, or IP itself.
  </t>
  <t hangText="link -">
  a communication facility or medium over which nodes can
  communicate at the link layer, i.e., the layer immediately below
  IP.  Examples are Ethernets (simple or bridged); PPP links;
  X.25, Frame Relay, or ATM networks; and Internet (or higher)
  layer "tunnels", such as tunnels over IPv4 or IPv6 itself.
  The protocol described in this document will be used on all types of
  links unless specified otherwise
  in the link-type-specific document describing how to operate IP on the
  link in line with <xref target="RFC4861"></xref>.
  </t>
  <t hangText="interface -"> a node's attachment to a link.</t>
  <t hangText="packet -">an IP header plus payload.</t>
  <t hangText="address -">an IP-layer identifier for an interface or a set of
        interfaces.</t>
  <t hangText="unicast address -">an identifier for a single
  interface. A packet sent
        to a unicast address is delivered to the interface identified by
        that address.</t>
  <t hangText="multicast address -">an identifier for a set of
  interfaces (typically
        belonging to different nodes). A packet sent to a multicast
        address is delivered to all interfaces identified by that
        address.</t>
  <t hangText="anycast address -">an identifier for a set of
  interfaces (typically belonging to different nodes).
	A packet sent to an anycast
        address is delivered to one of the interfaces identified by that
        address (the "nearest" one, according to the routing protocol's
        measure of distance).
	See <xref target="RFC4291" />.</t>
  <t hangText="solicited-node multicast address -">
  a multicast address to which Neighbor Solicitation messages are
  sent.
  The algorithm for computing the address is given in
  <xref target="RFC4291" />.
  </t>
  <t hangText="link-layer address -">
  a link-layer identifier for an interface.
        Examples include IEEE 802 addresses for Ethernet links and E.164
        addresses for Integrated Services Digital Network (ISDN) links.</t>
  <t hangText="link-local address -">
  an address having link-only scope that can be
        used to reach neighboring nodes attached to the same link.  All
        interfaces have a link-local unicast address.</t>
  <t hangText="global address -">an address with unlimited scope.</t>
  <t hangText="communication -">
  any packet exchange among nodes that requires that
        the address of each node used in the exchange remain the same
        for the duration of the packet exchange.  Examples are a TCP
        connection or a UDP request-response.</t>
  <t hangText="tentative address -">
  an address whose uniqueness on a link is being
        verified, prior to its assignment to an interface.  A tentative
        address is not considered assigned to an interface in the usual
        sense. An interface discards received packets addressed to a
        tentative address, but accepts Neighbor Discovery packets
        related to Duplicate Address Detection for the tentative
        address.</t>
  <t hangText="preferred address -">
  an address assigned to an interface whose use by
        upper-layer protocols is unrestricted. Preferred addresses may
        be used as the source (or destination) address of packets sent
        from (or to) the interface.</t>
  <t hangText="deprecated address -">
  An address assigned to an interface whose use is
        discouraged, but not forbidden.  A deprecated address should no
        longer be used as a source address in new communications, but
        packets sent from or to deprecated addresses are delivered as
        expected.  A deprecated address may continue to be used as a
        source address in communications where switching to a preferred
        address causes hardship to a specific upper-layer activity
        (e.g., an existing TCP connection).</t>
  <t hangText="valid address -">
  a preferred or deprecated address. A valid address
        may appear as the source or destination address of a packet, and
        the Internet routing system is expected to deliver packets sent
        to a valid address to their intended recipients.</t>
  <t hangText="invalid address -">
  an address that is not assigned to any interface. A
        valid address becomes invalid when its valid lifetime expires.
        Invalid addresses should not appear as the destination or source
        address of a packet. In the former case, the Internet routing
        system will be unable to deliver the packet; in the latter case,
        the recipient of the packet will be unable to respond to
  it.</t>
  <t hangText="preferred lifetime -">
  the length of time that a valid address is
        preferred (i.e., the time until deprecation). When the preferred
        lifetime expires, the address becomes deprecated.</t>
  <t hangText="valid lifetime -">
  the length of time an address remains in the valid
        state (i.e., the time until invalidation). The valid lifetime
        must be greater than or equal to the preferred lifetime.  When
        the valid lifetime expires, the address becomes invalid.</t>
  <t hangText="interface identifier -">
  a link-dependent identifier for an interface
  that is (at least) unique per link <xref target="RFC4291"></xref>.
  Stateless address autoconfiguration combines an interface identifier
  with a prefix to form an address.
  From address autoconfiguration's perspective, an interface
  identifier is a bit string of known length.
  The exact length of an interface identifier and the way it is created
  is defined in a separate link-type specific document that covers
  issues related to the transmission of IP over a particular link
  type (e.g., <xref target="RFC2464" />).
  Note that the address architecture <xref target="RFC4291"></xref>
  also defines the length of the interface identifiers for some set of
  addresses, but the two sets of definitions must be consistent.
  In many cases, the identifier will be derived from the
  interface's link-layer address.
  </t>
</list>

<section title="Requirements">
<t>
   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this
   document, are to be interpreted as described in
   <xref target="RFC2119" />.
</t>
<t>
   Note that this document intentionally limits the use of the keywords
   to the protocol specification (<xref target="spec" />).
</t>
</section>
</section>

<section anchor="goals" title="Design Goals">

<t>
   Stateless autoconfiguration is designed with the following goals in
   mind:
</t>

<list style="symbols">
  <t> Manual configuration of individual machines before connecting
      them to the network should not be required. Consequently, a
      mechanism is needed that allows a host to obtain or create
      unique addresses for each of its interfaces. Address
      autoconfiguration assumes that each interface can provide a
      unique identifier for that interface (i.e., an "interface
      identifier").  In the simplest case, an interface identifier
      consists of the interface's link-layer address. An interface
      identifier can be combined with a prefix to form an address.</t>
  <t> Small sites consisting of a set of machines attached to a single
        link should not require the presence of a DHCPv6 server or
        router as a prerequisite for communicating.  Plug-and-play
        communication is achieved through the use of link-local
        addresses.  Link-local addresses have a well-known prefix that
        identifies the (single) shared link to which a set of nodes
        attach. A host forms a link-local address by appending an
        interface identifier to the link-local prefix.</t>
  <t> A large site with multiple networks and routers should not
        require the presence of a DHCPv6 server for address configuration.
        In order to generate global addresses, hosts must
        determine the prefixes that identify the subnets to which they
        attach.  Routers generate periodic Router Advertisements that
        include options listing the set of active prefixes on a link.</t>
  <t> Address configuration should facilitate the graceful renumbering
        of a site's machines. For example, a site may wish to renumber
        all of its nodes when it switches to a new network service
        provider.  Renumbering is achieved through the leasing of
        addresses to interfaces and the assignment of multiple addresses
        to the same interface.  Lease lifetimes provide the mechanism
        through which a site phases out old prefixes.  The assignment of
        multiple addresses to an interface provides for a transition
        period during which both a new address and the one being phased
        out work simultaneously.</t>
</list>
</section>

<section anchor="overview" title="Protocol Overview">
<t> This section provides an overview of the typical steps that take
   place when an interface autoconfigures itself.  Autoconfiguration is
   performed only on multicast-capable links and begins when a
   multicast-capable interface is enabled, e.g., during system startup.
   Nodes (both hosts and routers) begin the autoconfiguration process by
   generating a link-local address for the interface.
   A link-local
   address is formed by appending an identifier of the interface to the
   well-known link-local prefix <xref target="RFC4291" />.
   </t>

<t> Before the link-local address can be assigned to an interface and
   used, however, a node must attempt to verify that this "tentative"
   address is not already in use by another node on the link.
   Specifically, it sends a Neighbor Solicitation message containing the
   tentative address as the target. If another node is already using
   that address, it will return a Neighbor Advertisement saying so. If
   another node is also attempting to use the same address, it will send
   a Neighbor Solicitation for the target as well. The exact number of
   times the Neighbor Solicitation is (re)transmitted and the delay time
   between consecutive solicitations is link-specific and may be set by
   system management.</t>

<t> If a node determines that its tentative link-local address is not
   unique, autoconfiguration stops and manual configuration of the
   interface is required.  To simplify recovery in this case, it should
   be possible for an administrator to supply an alternate interface
   identifier that overrides the default identifier in such a way that
   the autoconfiguration mechanism can then be applied using the new
   (presumably unique) interface identifier.  Alternatively, link-local
   and other addresses will need to be configured manually.</t>

<t> Once a node ascertains that its tentative link-local address is
   unique, it assigns the address to the interface. At this point, the node has
   IP-level connectivity with neighboring nodes.  The remaining
   autoconfiguration steps are performed only by hosts; the
   (auto)configuration of routers is beyond the scope of this document.</t>

<t>
   The next phase of autoconfiguration involves obtaining a Router
   Advertisement or determining that no routers are present.
   If routers are present, they will send Router Advertisements that
   specify what sort of autoconfiguration a host can do.
   Note that the DHCPv6 service for address configuration may still be
   available even if no routers are present.
</t>

<t> Routers send Router Advertisements periodically, but the delay
   between successive advertisements will generally be longer than a
   host performing autoconfiguration will want to wait
   <xref target="RFC4861"></xref>.
   To obtain an advertisement quickly, a host sends one or more Router
   Solicitations to the all-routers multicast group.
</t>

<t> Router Advertisements also contain zero or more Prefix Information
   options that contain information used by stateless address
   autoconfiguration to generate global addresses.  It
   should be noted that a host may use both stateless address
   autoconfiguration and DHCPv6 simultaneously.  One Prefix
   Information option field, the "autonomous address-configuration
   flag", indicates whether or not the option even applies to stateless
   autoconfiguration.  If it does, additional option fields contain a
   subnet prefix, together with lifetime values, indicating how long
   addresses created from the prefix remain preferred and valid.</t>

<t> Because routers generate Router Advertisements periodically, hosts
   will continually receive new advertisements. Hosts process the
   information contained in each advertisement as described above,
   adding to and refreshing information received in previous
   advertisements.</t>

<t>By default, all addresses should be tested for uniqueness prior to
   their assignment to an interface for safety.
   The test should individually be performed on all
   addresses obtained manually, via stateless address
   autoconfiguration, or via DHCPv6.
   To accommodate sites that believe the overhead of performing Duplicate
   Address Detection outweighs its benefits, the use of Duplicate
   Address Detection can be disabled through the administrative setting
   of a per-interface configuration flag.</t>

<t> To speed the autoconfiguration process, a host may generate its
   link-local address (and verify its uniqueness) in parallel with
   waiting for a Router Advertisement. Because a router may delay
   responding to a Router Solicitation for a few seconds, the total time
   needed to complete autoconfiguration can be significantly longer if
   the two steps are done serially.</t>

  <section title="Site Renumbering">
  <t> Address leasing facilitates site renumbering by providing a mechanism
   to time-out addresses assigned to interfaces in hosts.  At present,
   upper-layer protocols such as TCP provide no support for changing
   end-point addresses while a connection is open. If an end-point
   address becomes invalid, existing connections break and all

<?rfc needLines="3"?>
   communication to the invalid address fails.  Even when applications
   use UDP as a transport protocol, addresses must generally remain the
   same during a packet exchange.</t>

   <t> Dividing valid addresses into preferred and deprecated categories
   provides a way of indicating to upper layers that a valid address may
   become invalid shortly and that future communication using the
   address will fail, should the address's valid lifetime expire before
   communication ends.  To avoid this scenario, higher layers should use
   a preferred address (assuming one of sufficient scope exists) to
   increase the likelihood that an address will remain valid for the
   duration of the communication.  It is up to system administrators to
   set appropriate prefix lifetimes in order to minimize the impact of
   failed communication when renumbering takes place.  The deprecation
   period should be long enough that most, if not all, communications
   are using the new address at the time an address becomes
   invalid.</t>

   <t> The IP layer is expected to provide a means for upper layers
   (including applications) to select the most appropriate source
   address given a particular destination and possibly other
   constraints.  An application may choose to select the source address
   itself before starting a new communication or may leave the address
   unspecified, in which case, the upper networking layers will use the
   mechanism provided by the IP layer to choose a suitable address on
   the application's behalf.</t>

   <t> Detailed address selection rules are beyond the scope of this
   document and are described in <xref target="RFC3484" />.</t>
  </section>
</section>

<section anchor="spec" title="Protocol Specification">

   <t>
   Autoconfiguration is performed on a per-interface basis on
   multicast-capable interfaces.  For multihomed hosts,
   autoconfiguration is performed independently on each interface.
   Autoconfiguration applies primarily to hosts, with two exceptions.
   Routers are expected to generate a link-local address using the
   procedure outlined below.
   In addition, routers perform Duplicate
   Address Detection on all addresses prior to assigning them to an
   interface.
   </t>

  <section title="Node Configuration Variables">
  <t> A node MUST allow the following autoconfiguration-related variable to
   be configured by system management for each multicast-capable
   interface:
   </t>

   <list style="hanging">

<?rfc needLines="6"?>
   <t hangText="DupAddrDetectTransmits">
   The number of consecutive Neighbor Solicitation
                     messages sent while performing Duplicate Address
                     Detection on a tentative address. A value of zero
                     indicates that Duplicate Address Detection is not
                     performed on tentative addresses. A value of one
                     indicates a single transmission with no follow-up
                     retransmissions.
   <vspace blankLines="1" />
   Default: 1, but may be overridden by a link-type
                     specific value in the document that covers issues
                     related to the transmission of IP over a particular
                     link type (e.g., <xref target="RFC2464" />).
		     <vspace blankLines="1" />
		     Autoconfiguration also assumes the presence of the
                     variable RetransTimer as defined in
		     <xref target="RFC4861" />.
                     For autoconfiguration purposes, RetransTimer
                     specifies the delay between consecutive Neighbor
                     Solicitation transmissions performed during
                     Duplicate Address Detection (if
                     DupAddrDetectTransmits is greater than 1), as well
                     as the time a node waits after sending the last
                     Neighbor Solicitation before ending the Duplicate
                     Address Detection process.
  </t>
  </list>
  </section>

  <section title="Autoconfiguration-Related Structures">
   <t> Beyond the formation of a link-local address and use of Duplicate
   Address Detection, how routers (auto)configure their interfaces is
   beyond the scope of this document.</t>

  <t> A host maintains a list of addresses together with their
   corresponding lifetimes.
   The address list contains both autoconfigured addresses and those
   configured manually.</t>

  </section>

  <section anchor="linklocal" title="Creation of Link-Local Addresses">
  <t> A node forms a link-local address whenever an interface becomes
   enabled.  An interface may become enabled after any of the
   following
   events:</t>

  <list style="hanging">
  <t hangText="-"> The interface is initialized at system startup time.</t>
  <t hangText="-"> The interface is reinitialized after a temporary interface
        failure or after being temporarily disabled by system
        management.</t>
  <t hangText="-"> The interface attaches to a link for the first
  time.
  This includes the case where the attached link is dynamically
  changed due to a change of the access point of wireless networks.
  </t>
  <t hangText="-"> The interface becomes enabled by system management after
        having been administratively
        disabled.</t>
  </list>

  <t>
  A link-local address is formed by combining the well-known
  link-local prefix FE80::0 <xref target="RFC4291" /> (of appropriate length) with an
  interface identifier as follows:

  <list style="numbers">
  <t> The left-most 'prefix length' bits of the address are those
  of the link-local prefix.
  </t>
  <t>
  The bits in the address to the right of the link-local prefix are
  set to all zeroes.
  </t>
  <t>
  If the length of the interface identifier is N bits, the right-most
  N bits of the address are replaced by the interface identifier.
  </t>
  </list>
  
   If the sum of the link-local prefix length and N is larger than 128,
   autoconfiguration fails and manual configuration is required.
   The length of the interface identifier is defined in a
   separate link-type-specific document, which should also be
   consistent with the address architecture
   <xref target="RFC4291"></xref>
   (see <xref target="terminology" />).
   These documents will carefully define the length so that link-local
   addresses can be autoconfigured on the link.

   </t>

   <t>
   A link-local address has an infinite preferred and valid lifetime;
   it is never timed out.
   </t>

  </section>

  <section anchor="dad" title="Duplicate Address Detection">

  <t>
  Duplicate Address Detection MUST be performed on all unicast addresses
  prior to assigning them to an interface, regardless of whether they
  are obtained through stateless autoconfiguration, DHCPv6, or manual
  configuration,
  with the following exceptions:
  </t>

<list style="hanging">
  <t hangText="-">
  An interface whose DupAddrDetectTransmits variable is set to zero
  does not perform Duplicate Address Detection.
  </t>
  <t hangText="-">
  Duplicate Address Detection MUST NOT be performed on anycast
  addresses (note that anycast addresses cannot syntactically be
  distinguished from unicast addresses).
  </t>
  <t hangText="-">
  Each individual unicast address SHOULD be tested for uniqueness.
  Note that there are implementations deployed that only perform
  Duplicate Address Detection for the link-local address and skip
  the test for the global address that uses the same interface
  identifier as that of the link-local address.
<!-- [rfced] Please clarify.  Did you intend
"skip the test for whether the global address uses the same interface
  identifier..." or "skip the test for the global address that uses 
the same interface identifier..." ?
-->
<!-- [TJ] the latter (fixed in the text) -->
  Whereas this document does not invalidate such implementations, this
  kind of "optimization" is NOT RECOMMENDED, and new implementations
  MUST NOT do that optimization.
  This optimization came from the assumption that all of an
  interface's addresses are generated from the same identifier.
  However, the assumption does actually not stand; new types of
  addresses have been introduced where the interface identifiers are
  not necessarily the same for all unicast addresses on a single
  interface <xref target="RFC4941" /> <xref target="RFC3972" />.
  Requiring that Duplicate Address Detection be performed for all unicast
  addresses will make the algorithm robust for the current and
  future special interface identifiers.
  </t>
</list>

  <t> The procedure for detecting duplicate addresses uses Neighbor
   Solicitation and Advertisement messages as described below. If a
   duplicate address is discovered during the procedure, the address
   cannot be assigned to the interface. If the address is derived from
   an interface identifier, a new identifier will need to be assigned to
   the interface, or all IP addresses for the interface will need to be
   manually configured.  Note that the method for detecting duplicates
   is not completely reliable, and it is possible that duplicate
   addresses will still exist (e.g., if the link was partitioned while
   Duplicate Address Detection was performed).</t>

  <t> An address on which the Duplicate Address Detection procedure is
   applied is said to be tentative until the procedure has completed
   successfully.  A tentative address is not considered "assigned to an
   interface" in the traditional sense. That is, the interface must
   accept Neighbor Solicitation and Advertisement messages containing
   the tentative address in the Target Address field, but processes such
   packets differently from those whose Target Address matches an
   address assigned to the interface. Other packets addressed to the
   tentative address should be silently discarded.
   Note that the "other packets" include Neighbor Solicitation
   and Advertisement messages that have the tentative (i.e., unicast)
   address as the IP destination address and contain the tentative
   address in the Target Address field.
   Such a case should not happen in normal operation, though, since
   these messages are multicasted in the Duplicate Address Detection
   procedure. 
   </t>

  <t> It should also be noted that Duplicate Address Detection must be
   performed prior to assigning an address to an interface in order to
   prevent multiple nodes from using the same address simultaneously.
   If a node begins using an address in parallel with Duplicate Address
   Detection, and another node is already using the address, the node
   performing Duplicate Address Detection will erroneously process
   traffic intended for the other node, resulting in such possible
   negative consequences as the resetting of open TCP connections.</t>

<?rfc needLines="6"?>
  <t> The following subsections describe specific tests a node performs to
   verify an address's uniqueness.  An address is considered unique if
   none of the tests indicate the presence of a duplicate address within
   RetransTimer milliseconds after having sent DupAddrDetectTransmits
   Neighbor Solicitations. Once an address is determined to be unique,
   it may be assigned to an interface.</t>

     <section title="Message Validation">
     <t> A node MUST silently discard any Neighbor Solicitation or
   Advertisement message that does not pass the validity checks
   specified in <xref target="RFC4861" />.
   A Neighbor Solicitation or Advertisement message that passes these
   validity checks is called a valid solicitation or valid
   advertisement, respectively.</t>

     </section>

     <section title="Sending Neighbor Solicitation Messages">
     <t> Before sending a Neighbor Solicitation, an interface MUST join the
   all-nodes multicast address and the solicited-node multicast address
   of the tentative address.
   The former ensures that the node receives
   Neighbor Advertisements from other nodes already using the address;
   the latter ensures that two nodes attempting to use the same address
   simultaneously should detect each other's presence.
   </t>

   <t> To check an address, a node sends DupAddrDetectTransmits Neighbor
   Solicitations, each separated by RetransTimer milliseconds. The
   solicitation's Target Address is set to the address being checked,
   the IP source is set to the unspecified address, and the IP
   destination is set to the solicited-node multicast address of the
   target address.</t>

   <t>
   If the Neighbor Solicitation is going to be the first message 
   sent from an interface after interface (re)initialization, the node
   SHOULD delay joining the solicited-node multicast address by a
   random delay between 0 and MAX_RTR_SOLICITATION_DELAY as specified in
   <xref target="RFC4861" />.
   This serves to alleviate congestion when many nodes start up on the
   link at the same time, such as after a power failure, and may help
   to avoid race conditions when more than one node is trying to
   solicit for the same address at the same time.
   </t>

   <t>
   Even if the Neighbor Solicitation is not going to be the first
   message sent, the node SHOULD delay joining the solicited-node
   multicast address by a random delay between 0 and
   MAX_RTR_SOLICITATION_DELAY if the address being checked is configured
   by a router advertisement message sent to a multicast address.
   The delay will avoid similar congestion when multiple nodes are going to
   configure addresses by receiving the same single multicast router
   advertisement.
   </t>

   <t>
   Note that when a node joins a multicast address, it typically sends
   a Multicast Listener Discovery (MLD) report message
   <xref target="RFC2710"></xref>
   <xref target="RFC3810"></xref>
   for the multicast address.
   In the case of Duplicate Address Detection,
   the MLD report message is required in order to inform MLD-snooping
   switches, rather than routers, to forward multicast packets.
   In the above description, the delay for joining the multicast address
   thus means delaying transmission of the corresponding MLD report
   message.
   Since the MLD specifications do not request a random delay
   to avoid race conditions, just delaying Neighbor Solicitation would
   cause congestion by the MLD report messages.
   The congestion would then prevent the MLD-snooping switches from
   working correctly and, as a result, prevent Duplicate Address
   Detection from working.
   The requirement to include the delay for the MLD report in this case
   avoids this scenario.
   <xref target="RFC3590" /> also talks about
   some interaction issues between Duplicate Address Detection and
   MLD, and specifies which source address
   should be used for the MLD report in this case.
   </t>
   <t>
   In order to improve the robustness of the
   Duplicate Address Detection algorithm, an interface MUST receive and
   process datagrams sent to the all-nodes multicast address or
   solicited-node multicast address of the tentative address during
   the delay period.
   This does not necessarily conflict with the requirement that joining the
   multicast group be delayed.
   In fact, in some cases it is possible for a node to start listening
   to the group during the delay period before MLD report transmission.
   It should be noted, however, that in some link-layer environments,
   particularly with MLD-snooping switches, no multicast reception
   will be available until the MLD report is sent.
   </t>

     </section>

     <section title="Receiving Neighbor Solicitation Messages">
     <t> On receipt of a valid Neighbor Solicitation message on an interface,
   node behavior depends on whether or not the target address is tentative.
   If the target address is not tentative (i.e., it is assigned to
   the receiving interface), the solicitation is processed as described
   in <xref target="RFC4861" />.
   If the target address is tentative, and the source
   address is a unicast address, the solicitation's sender is performing
   address resolution on the target; the solicitation should be silently
   ignored.
   Otherwise, processing takes place as described below. In
   all cases, a node MUST NOT respond to a Neighbor Solicitation for a
   tentative address.</t>

     <t> If the source address of the Neighbor Solicitation is the unspecified
   address, the solicitation is from a node performing Duplicate Address
   Detection. If the solicitation is from another node, the tentative
   address is a duplicate and should not be used (by either node). If
   the solicitation is from the node itself (because the node loops back
   multicast packets), the solicitation does not indicate the presence
   of a duplicate address.</t>

     <t> Implementer's Note: many interfaces provide a way for upper layers to
   selectively enable and disable the looping back of multicast packets.
   The details of how such a facility is implemented may prevent
   Duplicate Address Detection from working correctly.
   See <xref target="loopback"></xref> for further discussion.</t>

     <t> The following tests identify conditions under which a tentative
   address is not unique:</t>

     <list style="hanging">
     <t hangText="-"> If a Neighbor Solicitation for a tentative address is
        received before one is sent, the tentative address is a
        duplicate.  This condition occurs when two nodes run Duplicate
        Address Detection simultaneously, but transmit initial
        solicitations at different times (e.g., by selecting different
        random delay values before joining the solicited-node
        multicast address and transmitting an initial solicitation).</t>
     <t hangText="-"> If the actual number of Neighbor Solicitations
        received exceeds
        the number expected based on the loopback semantics (e.g., the
        interface does not loop back the packet, yet one or more
        solicitations was received), the tentative address is a
        duplicate. 
       This condition occurs when two nodes run Duplicate
        Address Detection simultaneously and transmit solicitations at
        roughly the same time.</t>
     </list>
     </section>

     <section title="Receiving Neighbor Advertisement Messages">

     <t> On receipt of a valid Neighbor Advertisement message on an
       interface, node behavior depends on whether the target address is
       tentative or matches a unicast or anycast address assigned to the
       interface:

  <list style="numbers">
  <t> If the target address is tentative, the tentative
    address is not unique.
  </t>
  <t> If the target address matches a unicast address assigned to the
    receiving interface, it would possibly indicate that the
    address is a duplicate but it has not been detected by the
    Duplicate Address Detection procedure (recall that Duplicate
    Address Detection is not completely reliable).  How to handle
    such a case is beyond the scope of this document.
  </t>
  <t> Otherwise, the advertisement is processed as described
    in <xref target="RFC4861" />.
  </t>
  </list>
  </t>
   </section>

     <section title="When Duplicate Address Detection Fails">
     <t>
     A tentative address that is determined to be a duplicate as described
     above MUST NOT be assigned to an interface, and the node SHOULD log a
     system management error.
     </t>

<?rfc needLines="5"?>
     <t>
     If the address is a link-local address formed from an interface
     identifier based on the hardware address, which is supposed to be
     uniquely assigned (e.g., EUI-64 for an Ethernet interface), IP
     operation on the interface SHOULD be disabled.
     By disabling IP operation, the node will then:
     <list style="hanging">
     <t hangText="-">
     not send any IP packets from the interface,
     </t>
     <t hangText="-">
     silently drop any IP packets received on the
     interface, and
     </t>
     <t hangText="-">
     not forward any IP packets to the interface (when acting as a
     router or processing a packet with a Routing header).
     </t>
     </list>
     In this case, the IP address duplication probably means 
     duplicate hardware addresses are in use, and trying to recover
     from it by configuring another IP address will not result in a
     usable network.
     In fact, it probably makes things worse by creating problems that
     are harder to diagnose than just disabling network operation on the
     interface; the user will see a partially working
     network where some things work, and other things do not.
     </t>
     <t>
     On the other hand, if the duplicate link-local address is not
     formed from an interface identifier based on the hardware
     address, which is supposed to be uniquely assigned, IP operation
     on the interface MAY be continued.
     </t>
     <t>
     Note: as specified in <xref target="terminology" />, "IP" means
     "IPv6" in the above description.
     While the background rationale about hardware address is
     independent of particular network protocols, its effect on
     other protocols is beyond the scope of this document.
     </t>
     </section>
  </section>

  <section title="Creation of Global Addresses">
  <t> Global addresses are formed by appending an interface
   identifier to a prefix of appropriate length.
   Prefixes are obtained
   from Prefix Information options contained in Router Advertisements.
   Creation of global addresses as described in this section SHOULD be
   locally configurable.
   However, the processing described below MUST be enabled
   by default.</t>

    <section title="Soliciting Router Advertisements">
    <t> Router Advertisements are sent periodically to the all-nodes
   multicast address.
   To obtain an advertisement quickly, a host sends
   out Router Solicitations as described in
   <xref target="RFC4861" />.
   </t>

    </section>

<?rfc needLines="7"?>
    <section title="Absence of Router Advertisements">
    <t>
       Even if a link has no routers, the DHCPv6 service to obtain
       addresses may still be available, and hosts may want to use the
       service.
       From the perspective of autoconfiguration, a link has no routers if no
       Router Advertisements are received after having sent a small number
       of Router Solicitations as described in
       <xref target="RFC4861" />.
    </t>

    <t>
    Note that it is possible that there is no router on the link in this
    sense, but there is a node that has the ability to forward
    packets.
    In this case, the forwarding node's address must be manually
    configured in hosts to be able to send packets off-link, since the
    only mechanism to configure the default router's address
    automatically is the one using Router Advertisements.
    <!-- 
      Note that it is possible that there is no router on the link in this
      sense but is a node that has the ability to forward packets.
      In this case, hosts must be manually configured about the
      forwarding node's address to be able to send packets off-link,
      since sending router advertisements is the only mechanism to
      configure the default router's address automatically.
    -->
    </t>
    </section>

     <section anchor="rtadv" title="Router Advertisement Processing">
     <t> For each Prefix-Information option in the Router
     Advertisement:</t>
     <list style="hanging">
     <t hangText=" a)"> If the Autonomous flag is not set, silently ignore the
       Prefix Information
       option.</t>
     <t hangText=" b)"> If the prefix is the link-local prefix,
     silently ignore the
       Prefix Information option.</t>
     <t hangText=" c)"> If the preferred lifetime is greater than the
     valid lifetime,
       silently ignore the Prefix Information option. A node MAY wish to
       log a system management error in this case.</t>
     <t hangText=" d)"> If the prefix advertised is not equal to the
     prefix of an address configured by stateless autoconfiguration
     already in the list of addresses associated with the interface
     (where "equal" means the
     two prefix lengths are the same and the first prefix-length bits
     of the prefixes are identical), and if the Valid Lifetime
     is not 0, form an
       address (and add it to the list) by combining the advertised
       prefix with an interface identifier of the link as follows:
     <artwork>
   |            128 - N bits               |       N bits           |
   +---------------------------------------+------------------------+
   |            link prefix                |  interface identifier  |
   +----------------------------------------------------------------+
     </artwork>
     </t>
     <t>
      If the sum of the prefix length and interface identifier length
      does not equal 128 bits, the Prefix Information option MUST be
      ignored.
      An implementation MAY wish to log a system management
      error in this case.
      The length of the interface identifier is
      defined in a separate link-type specific document, which should
      also be consistent with the address architecture
      <xref target="RFC4291"></xref>
      (see <xref target="terminology" />).
      <vspace blankLines='1' />
      It is the responsibility of the system administrator to ensure
      that the lengths of prefixes contained in Router Advertisements
      are consistent with the length of interface identifiers for that
      link type.
      It should be noted, however, that this does not mean
      the advertised prefix length is meaningless.
      In fact, the advertised length has non-trivial meaning for on-link
      determination in <xref target="RFC4861" /> where
      the sum of the prefix length and the interface identifier length
      may not be equal to 128.
      Thus, it should be safe to validate the advertised prefix length
      here, in order to detect and avoid a configuration error
      specifying an invalid prefix length in the context of address
      autoconfiguration.
      <vspace blankLines='1' />
      Note that a future revision of the address architecture
      <xref target="RFC4291"></xref> and a future link-type-specific
      document, which will still be consistent with each
      other, could potentially allow for an interface identifier of
      length other than the value defined in the current documents.
      Thus, an implementation should not assume a particular
      constant.
      Rather, it should expect any lengths of interface identifiers.
      <vspace blankLines='1' />
      If an address is formed successfully and the address is not yet
      in the list, the host adds it to the
      list of addresses assigned to the interface, initializing its
      preferred and valid lifetime values from the Prefix Information
      option.
      Note that the check against the prefix performed at the
      beginning of this step cannot always detect the address conflict
      in the list.
      It could be possible that an address
      already in the list, configured either manually or by DHCPv6,
      happens to be identical to the newly created address,
      whereas such a case should be atypical.
     </t>
     <t hangText=" e)"> If the advertised prefix is equal to the prefix of
     an address configured by stateless autoconfiguration in the list,
     the preferred lifetime
     of the address is reset to the Preferred Lifetime in the received
     advertisement.
     The specific action to perform for the valid lifetime of the address
     depends on the Valid Lifetime in the received advertisement and
     the remaining time to the valid lifetime expiration of the
     previously autoconfigured address.
     We call the remaining time "RemainingLifetime" in the following
     discussion:
       <list style="numbers">
       <t> If the received Valid Lifetime is greater than 2 hours or greater
          than RemainingLifetime, set the valid lifetime of the
          corresponding address to the advertised Valid Lifetime.</t>
       <t> If RemainingLifetime is less than or equal to 2 hours,
          ignore the Prefix Information option with regards to the
          valid lifetime, unless the Router
          Advertisement from which this option was obtained has been
          authenticated
	  (e.g., via Secure Neighbor Discovery <xref target="RFC3971"></xref>).
	  If the Router Advertisement was authenticated, the valid lifetime
	  of the corresponding address should be set to the Valid
          Lifetime in the received option.</t>
       <t> Otherwise, reset the valid lifetime of the corresponding
          address to 2 hours.</t>
       </list>
       The above rules address a specific denial-of-service attack in
       which a bogus advertisement could contain prefixes with very
       small Valid Lifetimes. Without the above rules, a single
       unauthenticated advertisement containing bogus Prefix Information
       options with short Valid Lifetimes could cause all of a node's
       addresses to expire prematurely. The above rules ensure that
       legitimate advertisements (which are sent periodically) will
       "cancel" the short Valid Lifetimes before they actually take effect.
     <vspace blankLines='1' />
     Note that the preferred lifetime of the corresponding address
     is always reset to the Preferred Lifetime in the received Prefix
     Information option, regardless of whether the valid lifetime is
     also reset or ignored.
     The difference comes from the fact that the possible attack for
     the preferred lifetime is relatively minor.
     Additionally, it is even undesirable to ignore the preferred
     lifetime when a
     valid administrator wants to deprecate a particular address by
     sending a short preferred lifetime (and the valid lifetime is ignored by
     accident).
     </t>
     </list>
     </section>

     <section anchor="lifetime" title="Address Lifetime Expiry">
     <t>
     A preferred address becomes deprecated when its preferred lifetime
     expires.
     A deprecated address SHOULD continue to be used as a
     source address in existing communications, but SHOULD NOT be used
     to initiate new communications if an alternate (non-deprecated)
     address of sufficient scope can easily be used instead.
     </t>
     <t>
     Note that the feasibility of initiating new communication using a
     non-deprecated address may be an application-specific decision, as
     only the application may have knowledge about whether the (now)
     deprecated address was (or still is) in use by the application.
     For example, if an application explicitly specifies that the protocol
     stack use a deprecated address as a source address, the
     protocol stack must accept that;
     the application might request it because that IP address is used
     in higher-level communication and there might be a
     requirement that the multiple connections in such a grouping use
     the same pair of IP addresses.

<!-- [rfced] Please check that the change above from 
"is used for in higher-level communication" to 
"is used in higher-level communication" is correct. -->
<!-- [TJ] that's correct. -->
     </t>
     <t>
     IP and higher layers (e.g., TCP, UDP) MUST continue to accept and
     process datagrams destined to a deprecated address as normal since
     a deprecated address is still a valid address for the
     interface.
     In the case of TCP, this means TCP SYN segments sent to
     a deprecated address are responded to using the deprecated address
     as a source address in the corresponding SYN-ACK (if the
     connection would otherwise be allowed).
     </t>
     <t>
     An implementation MAY prevent any new communication from using a
     deprecated address, but system management MUST have the ability
     to disable such a facility, and the facility MUST be disabled by
     default.
     </t>

     <t>
     Other subtle cases should also be noted about source address
     selection.
     For example, the above description does not clarify which address
     should be used between a deprecated, smaller-scope address and a
     non-deprecated, sufficient scope address.
<!-- [rfced] Could "enough" be replaced with "sufficient"? -->
<!-- [TJ] yes.  changed. -->
     The details of the address selection including this case are
     described in <xref target="RFC3484" /> and are beyond the scope of
     this document.
     </t>

     <t> An address (and its association with an interface) becomes invalid
   when its valid lifetime expires.  An invalid address MUST NOT be used
   as a source address in outgoing communications and MUST NOT be
   recognized as a destination on a receiving interface.</t>
     </section>
  </section>

  <section title="Configuration Consistency">
  <t> It is possible for hosts to obtain address information using
   both stateless autoconfiguration and DHCPv6
   since both may be enabled at the same time.
   It is also possible that the values of other
   configuration parameters, such as MTU size and hop limit, will be
   learned from both Router Advertisements and DHCPv6.
   If the same configuration information is
   provided by multiple sources, the value of this information should be
   consistent. However, it is not considered a fatal error if
   information received from multiple sources is inconsistent.
   Hosts accept the union of all information received via Neighbor
   Discovery and DHCPv6.
   </t>
   <t>
   If inconsistent information is learned from different sources, an
   implementation may want to give information learned securely
   precedence over information learned without protection.
   For instance, Section 8 of <xref target="RFC3971" /> discusses how
   to deal with information learned through Secure Neighbor Discovery
   conflicting with information learned through plain Neighbor
   Discovery.
   The same discussion can apply to the
   preference between information learned through plain Neighbor
   Discovery and information learned via secured DHCPv6, and so on.
   </t>
   <t>
   In any case, if there is no security difference, the most recently
   obtained values SHOULD have precedence over information learned
   earlier.
   </t>
  </section>

  <section title="Retaining Configured Addresses for Stability">
  <t>
  An implementation that has stable storage may want to retain
  addresses in the storage when the addresses were
  acquired using stateless address autoconfiguration.
  Assuming the lifetimes used are reasonable, this technique implies
  that a temporary outage (less than the valid lifetime) of a router will
  never result in losing a global address of the node even if the 
  node were to reboot.
  When this technique is used, it should also be noted that the
  expiration times of the preferred and valid lifetimes must be
  retained, in order to prevent the use of an address after it has
  become deprecated or invalid.
  </t>
  <t>
  Further details on this kind of extension are beyond the scope of
  this document.
  </t>
  </section>

</section>

<section anchor="security" title="Security Considerations">
<t> Stateless address autoconfiguration allows a host to connect to a
   network, configure an address, and start communicating with other
   nodes without ever registering or authenticating itself with the
   local site.  Although this allows unauthorized users to connect to
   and use a network, the threat is inherently present in the
   Internet architecture. Any node with a physical attachment to
   a network can generate an address (using a variety of ad hoc
   techniques) that provides connectivity.</t>

<t>
   The use of stateless address autoconfiguration and Duplicate
   Address Detection opens up the possibility of several denial-of-service
    attacks.
   For example, any node can respond to Neighbor Solicitations for a
   tentative address, causing the other node to reject the address as
   a duplicate.
   A separate document <xref target="RFC3756"></xref> discusses
   details about these attacks, which can be addressed with the Secure
   Neighbor Discovery protocol <xref target="RFC3971"></xref>.
   It should also be noted that <xref target="RFC3756"></xref>
   points out that the use of IP security is not always feasible depending
   on network environments.
   </t>
</section>


<section title="Acknowledgements">
<t>Thomas Narten and Susan Thompson were the authors of RFCs 1971 and
   2462.  For this revision of the RFC, Tatuya Jinmei was the sole
   editor.</t>

<t>The authors would like to thank the members of both the IPNG
   (which is now IPV6) and
   ADDRCONF working groups for their input. In particular, thanks to Jim
   Bound, Steve Deering, Richard Draves, and Erik Nordmark.  Thanks also
   goes to John Gilmore for alerting the WG of the "0 Lifetime Prefix
   Advertisement" denial-of-service attack vulnerability; this document
   incorporates changes that address this vulnerability.
</t>

<t>
A number of people have contributed to identifying issues on a
previous version of this document and to proposing resolutions to the
issues, on which this version is based.
In addition to those listed above, the contributors include
Jari Arkko,
James Carlson,
Brian E. Carpenter,
Gregory Daley,
Elwyn Davies,
Ralph Droms,
Jun-ichiro Itojun Hagino,
Christian Huitema,
Suresh Krishnan,
Soohong Daniel Park,
Markku Savela,
Pekka Savola,
Hemant Singh,
Bernie Volz,
Margaret Wasserman, and
Vlad Yasevich.
</t>
</section>

</middle>

<back>
<references title="Normative References">

<!-- 
  <?rfc include="reference.RFC.2402" ?>
 -->
  <?rfc include="reference.RFC.2464" ?>
  <?rfc include="reference.RFC.2119" ?>
  <?rfc include="reference.RFC.4291" ?>
<!--   reference.I-D.ietf-ipv6-2461bis.xml = RFC 4861 -->
<reference anchor='RFC4861'>
<front>
<title>Neighbor Discovery for IP version 6 (IPv6)</title>

<author initials='T' surname='Narten' fullname='Thomas Narten'>
    <organization />
</author>
<author initials='E' surname='Nordmark' fullname='Erik Nordmark'>
    <organization />
</author>
<author initials='W' surname='Simpson' fullname='William Allen Simpson'>
    <organization />
</author>
<author initials='H' surname='Soliman' fullname='Hesham Soliman'>
    <organization />
</author>

<date month='September' year='2007' />
<!-- [TJ] note to the editor: this should be updated -->

<abstract><t>This document specifies the Neighbor Discovery protocol for IP Version 6. IPv6 nodes on the same link use Neighbor Discovery to discover each other's presence, to determine each other's link-layer addresses, to find routers and to maintain reachability information about the paths to active neighbors.</t></abstract>

</front>

<seriesInfo name='RFC' value='4861'/>
</reference>

</references>

<references title="Informative References">

  <?rfc include="reference.RFC.3315" ?>
  <!-- 
  <?rfc include="reference.RFC.3736" ?>
 -->
  <?rfc include="reference.RFC.3484" ?>
  <!-- 
  <?rfc include="reference.RFC.3041" ?>
 -->
<reference anchor='RFC4941'>
<front>
<title>Privacy Extensions for Stateless Address Autoconfiguration in IPv6</title>

<author initials='T' surname='Narten' fullname='Thomas Narten'>
    <organization />
</author>
<author initials='R' surname='Draves' fullname='Richard Draves'>
    <organization />
</author>
<author initials='S' surname='Krishnan' fullname='Suresh Krishnan'>
    <organization />
</author>

<date month='September' year='2007' />
<!-- [TJ] note to the editor: this should be updated -->

</front>

<seriesInfo name='RFC' value='4941'/>
</reference>
  <?rfc include="reference.RFC.3972" ?>
  <?rfc include="reference.RFC.2710" ?>
  <?rfc include="reference.RFC.3810" ?>
  <?rfc include="reference.RFC.3590" ?>
  <?rfc include="reference.RFC.3971" ?>
  <?rfc include="reference.RFC.3756" ?>
  <?rfc include="reference.RFC.1112" ?>

 <reference anchor="IEEE802.11">
  <front>
   <title>Wireless LAN Medium Access Control (MAC) and Physical
   Layer (PHY) Specifications
   </title>
   <author>
   <organization>IEEE</organization>
   </author>
   <date month="August" year="1999" />
  </front>
  <seriesInfo name="ANSI/IEEE STd"
  value="802.11" />
 </reference>

</references>

<vspace blankLines="100"/> <!-- insert page break-->

<section anchor="loopback"
 title="Loopback Suppression and Duplicate Address Detection">
<t>
   Determining whether a received multicast solicitation was looped back
   to the sender or actually came from another node is implementation-
   dependent.  A problematic case occurs when two interfaces attached to
   the same link happen to have the same identifier and link-layer
   address, and they both send out packets with identical contents at
   roughly the same time (e.g., Neighbor Solicitations for a tentative
   address as part of Duplicate Address Detection messages). Although a
   receiver will receive both packets, it cannot determine which packet
   was looped back and which packet came from the other node simply by
   comparing packet contents (i.e., the contents are identical). In this
   particular case, it is not necessary to know precisely which packet
   was looped back and which was sent by another node; if one receives
   more solicitations than were sent, the tentative address is a
   duplicate. However, the situation may not always be this
   straightforward.
</t>

<t>
   The IPv4 multicast specification
   <xref target="RFC1112" /> recommends that the
   service interface provide a way for an upper-layer protocol to
   inhibit local delivery of packets sent to a multicast group that the
   sending host is a member of. Some applications know that there will
   be no other group members on the same host, and suppressing loopback
   prevents them from having to receive (and discard) the packets they
   themselves send out.  A straightforward way to implement this
   facility is to disable loopback at the hardware level (if supported
   by the hardware), with packets looped back (if requested) by
   software.  On interfaces in which the hardware itself suppresses
   loopbacks, a node running Duplicate Address Detection simply counts
   the number of Neighbor Solicitations received for a tentative address
   and compares them with the number expected. If there is a mismatch,
   the tentative address is a duplicate.
</t>

<t>
   In those cases where the hardware cannot suppress loopbacks, however,
   one possible software heuristic to filter out unwanted loopbacks is
   to discard any received packet whose link-layer source address is the
   same as the receiving interface's.
   There is even a link-layer specification that requires that any
   such packets be discarded <xref target="IEEE802.11" />.
   Unfortunately, use of that criteria also results in the discarding
   of all packets sent by another node using the same link-layer
   address.
   Duplicate Address
   Detection will fail on interfaces that filter received packets in
   this manner:

   <list style="symbols">
   <t> If a node performing Duplicate Address Detection discards
       received packets that have the same source link-layer address as
       the receiving interface, it will also discard packets from other
       nodes that also use the same link-layer address, including Neighbor
       Advertisement and Neighbor Solicitation messages required to
       make Duplicate Address Detection work correctly.
       This particular problem can be avoided by temporarily disabling the
       software suppression of loopbacks while a node performs
       Duplicate Address Detection, if it is possible to
       disable the suppression.</t>
   <t> If a node that is already using a particular IP address discards
       received packets that have the same link-layer source address as
       the interface, it will also discard Duplicate Address
       Detection-related Neighbor Solicitation messages sent by another
       node that also use the same link-layer address.
       Consequently, Duplicate Address Detection will fail, and the
       other node will configure a non-unique address.
       Since it is generally impossible
       to know when another node is performing Duplicate Address
       Detection, this scenario can be avoided only if software
       suppression of loopback is permanently disabled.</t>
   </list>
</t>

<t>
   Thus, to perform Duplicate Address Detection correctly in the case
   where two interfaces are using the same link-layer address, an
   implementation must have a good understanding of the interface's
   multicast loopback semantics, and the interface cannot discard
   received packets simply because the source link-layer address is the
   same as the interface's.
   It should also be noted that a link-layer specification can conflict
   with the condition necessary to make Duplicate Address Detection work.
</t>
</section>


<section title="Changes since RFC 1971">

<list style="symbols">
<t> Changed document to use term "interface identifier" rather than
     "interface token" for consistency with other IPv6 documents.</t>
<t> Clarified definition of deprecated address to make clear it is OK
     to continue sending to or from deprecated addresses.</t>
<t> Added rules to <xref target="rtadv" /> Router Advertisement processing to
     address potential denial-of-service attack when prefixes are
     advertised with very short Lifetimes.</t>
<t> Clarified wording in <xref target="lifetime" /> to make clear that
     all upper
     layer protocols must process (i.e., send and receive) packets sent
     to deprecated addresses.</t>
</list>
</section>

<vspace blankLines="100"/> <!-- insert page break-->
<section title="Changes since RFC 2462">

<t>
Major changes that can affect existing implementations:
</t>

<list style="symbols">
  <t> Specified that a node performing Duplicate Address Detection
      delay joining the solicited-node multicast group, not just delay
      sending Neighbor Solicitations, explaining the detailed reason.</t>
  <t>
  Added a requirement for a random delay before sending Neighbor
  Solicitations for Duplicate Address Detection if the address being
  checked is configured by a multicasted Router Advertisements.
  </t>
  <t>
  Clarified that on failure of Duplicate Address Detection,
  IP network operation should be disabled and that the rule should
  apply when the hardware address is supposed to be unique.
  </t>
</list >

<t>
Major clarifications:
</t>

<list style="symbols">
  <t>
  Clarified how the length of interface identifiers should be determined,
  described the relationship with the prefix length advertised in
  Router Advertisements, and avoided using a particular length
  hard-coded in this document.
  </t>
  <t>
  Clarified the processing of received neighbor advertisements while
  performing Duplicate Address Detection.
  </t>
  <t>
  Removed the text regarding the M and O flags, considering
  the maturity of implementations and operational experiences.
  ManagedFlag and OtherConfigFlag were removed accordingly.
  (Note that this change does not mean the use of these flags is
  deprecated.)
  </t>
  <t>
  Avoided the wording of "stateful configuration", which is known to
  be quite confusing, and simply used "DHCPv6" wherever appropriate.
  </t>
  <t>
  Recommended to perform Duplicate Address Detection for all unicast
  addresses more strongly, considering a variety of different
  interface identifiers, while keeping care of existing implementations.
  </t>
  <t> Clarified wording in <xref target="lifetime" /> to make clear
  that a deprecated address specified by an application can be used
  for any communication.</t>
  <t>
  Clarified the prefix check described in <xref target="rtadv" />
  using more appropriate terms and that the check is done against the
  prefixes of addresses configured by stateless autoconfiguration.
  </t>
  <t> Changed the references to the IP security Authentication Header to
  references to RFC 3971 (Secure Neighbor Discovery).
  Also revised the Security Considerations section with a reference to
  RFC 3756.</t>
  <t>
  Added a note when an implementation uses stable storage for
  autoconfigured addresses.
  </t>
  <t>
  Added consideration about preference between inconsistent
  information sets, one from a secured source and the other learned without
  protection.
  </t>
</list>

<t>
Other miscellaneous clarifications:
</t>

<list style="symbols">
  <t> Removed references to site-local and revised wording around the
  keyword.</t>
  <t> Removed redundant code in denial-of-service protection in
  <xref target="rtadv" />.</t>
  <t> Clarified that a unicasted Neighbor Solicitation or
  Advertisement should be discarded while performing Duplicate Address
  Detection.</t>
  <t> Noted in <xref target="linklocal" /> that an interface can be
   considered as becoming enabled when a wireless access point changes.
  </t>
</list>

</section>


</back>
<vspace blankLines="100"/> <!-- insert page break-->
</rfc>
