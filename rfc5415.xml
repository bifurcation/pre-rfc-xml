<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" 
<?rfc toc="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc symrefs="yes"?>
<rfc number='5415' ipr="full3978" category="std">
<?rfc toc="yes"?>
<front>
    <title abbrev="CAPWAP Protocol Specification">Control And Provisioning of Wireless Access Points (CAPWAP) Protocol Specification</title>

   <author initials="P.C." surname="Calhoun" fullname="Pat R. Calhoun" role='editor'>
     <organization>Cisco Systems, Inc.</organization>
     <address>
       <postal>
         <street>170 West Tasman Drive</street>
         <city>San Jose</city> <region>CA</region> <code>95134</code>
       </postal>
       <phone>+1 408-902-3240</phone>
       <email>pcalhoun@cisco.com</email>
     </address>
   </author>

   <author initials="M.M." surname="Montemurro" fullname="Michael P. Montemurro" role='editor'>
     <organization>Research In Motion</organization>
     <address>
       <postal>
         <street>5090 Commerce Blvd</street>
         <city>Mississauga</city> <region>ON</region> <country>Canada</country> <code>L4W 5M4</code>
       </postal>
       <phone>+1 905-629-4746 x4999</phone>
       <email>mmontemurro@rim.com</email>
     </address>
   </author>

   <author initials="D.S." surname="Stanley" fullname="Dorothy Stanley" role='editor'>
     <organization>Aruba Networks</organization>
     <address>
       <postal>
         <street>1322 Crossman Ave</street>
         <city>Sunnyvale</city> <region>CA</region> <code>94089</code>
       </postal>
       <phone>+1 630-363-1389</phone>
       <email>dstanley@arubanetworks.com</email>
     </address>
   </author>

   <date month="March" year="2009" />
   <area>Operations and Management</area>
   <workgroup>Network Working Group</workgroup>
   <keyword>LWAPP</keyword>
   <keyword>CAPWAP</keyword>
   <keyword>802.11</keyword>
   <keyword>IEEE</keyword>
   <keyword>Wireless LAN</keyword>
   <keyword>WiFi</keyword>
   <keyword>Access Point</keyword>
   <keyword>Access Controller</keyword>
   <keyword>Wireless Termination Point</keyword>

<note title="">
<t>
 This document may contain material from IETF Documents or IETF
 Contributions published or made publicly available before November 10,
 2008. The person(s) controlling the copyright in some of this material
 may not have granted the IETF Trust the right to allow modifications
 of such material outside the IETF Standards Process.  Without
 obtaining an adequate license from the person(s) controlling the
 copyright in such materials, this document may not be modified outside
 the IETF Standards Process, and derivative works of it may not be
 created outside the IETF Standards Process, except to format it for
 publication as an RFC or to translate it into languages other than
 English.
</t>
</note>
   <abstract>


	  <t>This specification defines the Control And Provisioning of
	  Wireless Access Points (CAPWAP) Protocol, meeting the objectives defined
	  by the CAPWAP Working Group in RFC 4564. The CAPWAP protocol is designed
	  to be flexible, allowing it to be used for a variety of wireless
	  technologies. This document describes the base CAPWAP protocol, while
	  separate binding extensions will enable its use with additional wireless
	  technologies.</t>

   </abstract>
  </front>
  <middle>
   <section title="Introduction">
		<t>This document describes the CAPWAP protocol, a standard,
		interoperable protocol that enables an Access Controller (AC) to manage
		a collection of Wireless Termination Points (WTPs). The CAPWAP protocol
		is defined to be independent of Layer 2 (L2) technology, and meets the objectives in
		"Objectives for Control and Provisioning of Wireless Access Points
		(CAPWAP)" <xref target="RFC4564"></xref>.</t>

		<t>The emergence of centralized IEEE 802.11 Wireless Local Area Network
		(WLAN) architectures, in which simple IEEE 802.11 WTPs are managed by an
		Access Controller (AC), suggested that a standards-based, interoperable
		protocol could radically simplify the deployment and management of
		wireless networks.  WTPs require a set of dynamic management and control
		functions related to their primary task of connecting the wireless and
		wired mediums. Traditional protocols for managing WTPs are either manual
		static configuration via HTTP, proprietary Layer 2-specific or
		non-existent (if the WTPs are self-contained).  An IEEE 802.11 binding
		is defined in <xref target="RFC5416">
		</xref> to support use of the CAPWAP protocol with IEEE 802.11 WLAN
		networks.</t>

		<t>CAPWAP assumes a network configuration consisting of multiple WTPs
		communicating via the Internet Protocol (IP) to an AC. WTPs are viewed
		as remote radio frequency (RF) interfaces controlled by the AC. The CAPWAP protocol
		supports two modes of operation: Split and Local MAC
		(medium access control). In Split MAC mode,
		all L2 wireless data and management frames are encapsulated via the
		CAPWAP protocol and exchanged between the AC and the WTP. As shown in
		<xref target="CAPWAP-Architecture-SM"> </xref>, the wireless frames
		received from a mobile device, which is referred to in this
		specification as a Station (STA), are directly encapsulated by the WTP
		and forwarded to the AC.</t>

       <figure anchor="CAPWAP-Architecture-SM" title="Representative CAPWAP
	   Architecture for Split MAC">
           <artwork>
           +-+         wireless frames        +-+
           | |--------------------------------| |
           | |              +-+               | |
           | |--------------| |---------------| |
           | |wireless PHY/ | |     CAPWAP    | |
           | | MAC sublayer | |               | |
           +-+              +-+               +-+
           STA              WTP                AC
           </artwork>
       </figure>

	 <t>The Local MAC mode of operation allows for the data frames to be either
	 locally bridged or tunneled as 802.3 frames. The latter implies that the
	 WTP performs the 802.11 Integration function. In either case, the L2 wireless
	 management  frames are processed locally by the WTP and then forwarded to
	 the AC. <xref target="CAPWAP-Architecture-LM"> </xref> shows the Local
	 MAC mode, in which a station transmits a wireless frame
	 that is encapsulated in an 802.3 frame and forwarded to the AC.</t>

       <figure anchor="CAPWAP-Architecture-LM" title="Representative CAPWAP
	   Architecture for Local MAC">
           <artwork>
           +-+wireless frames +-+ 802.3 frames +-+
           | |----------------| |--------------| |
           | |                | |              | |
           | |----------------| |--------------| |
           | |wireless PHY/   | |     CAPWAP   | |
           | | MAC sublayer   | |              | |
           +-+                +-+              +-+
           STA                WTP               AC
           </artwork>
       </figure>

	   <t>Provisioning WTPs with security credentials and managing which WTPs
	   are authorized to provide service are traditionally handled by
	   proprietary solutions. Allowing these functions to be performed from a
	   centralized AC in an interoperable fashion increases manageability and
	   allows network operators to more tightly control their wireless network
	   infrastructure. </t>

	 <section title="Goals">

         <t>The goals for the CAPWAP protocol are listed below:</t>

        <list style="hanging">
		<t hangText="1.">To centralize the authentication and policy enforcement functions for a
		wireless network. The AC may also provide centralized bridging, forwarding, and encryption of user traffic.
		Centralization of these functions will enable reduced cost and higher efficiency by applying
		the capabilities of network processing silicon to the wireless network, as in wired LANs.</t>

		<t hangText="2."> To enable shifting of the higher-level protocol processing
		from the WTP. This leaves the time-critical applications of wireless control and access in the WTP,
		making efficient use of the computing power available 
		in WTPs, which are subject to severe cost pressure.</t>

		<t hangText="3.">To provide an extensible protocol that is not bound to
		a specific wireless technology. Extensibility is provided via a generic
		encapsulation and transport mechanism, enabling the CAPWAP protocol to
		be applied to many access point types in the future, via a specific
		wireless binding.</t>
        </list>

         <t>The CAPWAP protocol concerns itself solely with the interface
		 between the WTP and the AC. Inter-AC and station-to-AC communication 
		 are strictly outside the scope of this document.</t>

	</section>

      <section title="Conventions Used in This Document">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
		"SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in
		this document are to be interpreted as described in <xref target="RFC2119">
		RFC 2119</xref>.</t>
      </section> <!-- Conventions used in this document -->
      
      	<section anchor="Contributing Authors" title="Contributing Authors">
	<t>This section lists and acknowledges the authors of significant text and concepts included in this
	specification. </t>


		<t>The CAPWAP Working Group selected the Lightweight Access Point
		Protocol (LWAPP) <xref target="LWAPP"></xref> to be 
		used as the basis of the CAPWAP protocol specification. The following 
		people are authors of the LWAPP document: 

</t>
<artwork>
   Bob O'Hara
   Email: bob.ohara@computer.org

   Pat Calhoun, Cisco Systems, Inc.
   170 West Tasman Drive, San Jose, CA  95134
   Phone: +1 408-902-3240, Email: pcalhoun@cisco.com
		
   Rohit Suri, Cisco Systems, Inc.
   170 West Tasman Drive, San Jose, CA  95134
   Phone: +1 408-853-5548, Email: rsuri@cisco.com

   Nancy Cam Winget, Cisco Systems, Inc.
   170 West Tasman Drive, San Jose, CA  95134
   Phone: +1 408-853-0532, Email: ncamwing@cisco.com

   Scott Kelly, Aruba Networks
   1322 Crossman Ave, Sunnyvale, CA 94089
   Phone: +1  408-754-8408, Email: skelly@arubanetworks.com

   Michael Glenn Williams, Nokia, Inc.
   313 Fairchild Drive, Mountain View, CA  94043
   Phone: +1 650-714-7758, Email: Michael.G.Williams@Nokia.com

   Sue Hares, Green Hills Software
   825 Victors Way, Suite 100, Ann Arbor, MI  48108
   Phone: +1 734 222 1610, Email: shares@ndzh.com
</artwork>
		
<t>Datagram Transport Layer Security (DTLS) <xref target="RFC4347"></xref> is
used as the security solution for the CAPWAP protocol. The following people are
authors of significant DTLS-related text included in this document: 
</t>		

<artwork>
   Scott Kelly, Aruba Networks
   1322 Crossman Ave, Sunnyvale, CA 94089
   Phone: +1  408-754-8408
   Email: skelly@arubanetworks.com
		
   Eric Rescorla, Network Resonance
   2483 El Camino Real, #212,Palo Alto CA, 94303
   Email: ekr@networkresonance.com
</artwork>

<t>The concept of using DTLS to secure the CAPWAP protocol was part of the
Secure Light Access Point Protocol (SLAPP) proposal
<xref target="SLAPP"></xref>. The following people are
authors of the SLAPP proposal:

 </t>		
		
<artwork>
   Partha Narasimhan, Aruba Networks
   1322 Crossman Ave, Sunnyvale, CA  94089
   Phone: +1 408-480-4716
   Email: partha@arubanetworks.com

   Dan Harkins
   Trapeze Networks
   5753 W. Las Positas Blvd, Pleasanton, CA  94588
   Phone: +1-925-474-2212
   EMail: dharkins@trpz.com

   Subbu Ponnuswamy, Aruba Networks
   1322 Crossman Ave, Sunnyvale, CA  94089
   Phone: +1 408-754-1213
   Email: subbu@arubanetworks.com
</artwork>

<t>The following individuals contributed significant security-related
text to the document <xref target="RFC5418"/>:
</t> 
<artwork>
   T. Charles Clancy, Laboratory for Telecommunications Sciences,
   8080 Greenmead Drive, College Park, MD 20740
   Phone: +1 240-373-5069, Email: clancy@ltsnet.net

   Scott Kelly, Aruba Networks
   1322 Crossman Ave, Sunnyvale, CA 94089
   Phone: +1  408-754-8408, Email: scott@hyperthought.com
</artwork>

	</section> <!-- Contributing Authors -->


  	<section anchor="Terminology" title="Terminology">
		<t>Access Controller (AC): The network entity  that provides WTP 
		access to the network infrastructure in the data plane, control plane,
   		management plane, or a combination therein.</t>

		<t>CAPWAP Control Channel: A bi-directional flow defined by the AC IP
		Address, WTP IP Address, AC control port, WTP control port, and the
		transport-layer protocol (UDP or UDP-Lite) over which CAPWAP Control
		packets are sent and received.</t>

		<t>CAPWAP Data Channel: A bi-directional flow defined by the AC IP
		Address, WTP IP Address, AC data port, WTP data port, and the
		transport-layer protocol (UDP or UDP-Lite) over which CAPWAP Data
		packets are sent and received.</t>

		<t>Station (STA): A device that contains an interface to a wireless
		medium (WM).</t>
		
		<t> Wireless Termination Point (WTP): The physical or network entity that
   		contains an RF antenna and wireless Physical Layer (PHY) to transmit and receive station
   		traffic for wireless access networks.</t>

    	<t>This document uses additional terminology defined in
		<xref target="RFC3753"></xref>.</t>

	</section> <!-- Terminology -->

	</section> <!-- Introduction -->

    <section title="Protocol Overview" anchor="Protocol-Overview">
		<t>The CAPWAP protocol is a generic protocol defining AC and WTP control
		and data plane communication via a CAPWAP protocol transport mechanism.
		CAPWAP Control messages, and optionally CAPWAP Data messages, are
		secured using Datagram Transport Layer Security (DTLS)
		<xref target="RFC4347"></xref>. DTLS is a standards-track IETF protocol
		based upon TLS. The underlying security-related protocol mechanisms of
		TLS have been successfully deployed for many years. </t>

    	<t>The CAPWAP protocol transport layer carries two types of payload,
		CAPWAP Data messages and CAPWAP Control messages. CAPWAP Data messages
		encapsulate forwarded wireless frames.  CAPWAP protocol Control messages
		are management messages exchanged between a WTP and an AC. The CAPWAP
		Data and Control packets are sent over separate UDP ports. Since both
		data and control packets can exceed the Maximum Transmission Unit (MTU)
		length, the payload of a CAPWAP Data or Control message can be
		fragmented. The fragmentation behavior is defined in
		<xref target="CAPWAP Transport"></xref>.</t>

        <t>The CAPWAP Protocol begins with a Discovery phase. The WTPs send a
		Discovery Request message, causing any Access Controller (AC) receiving
		the message to respond with a Discovery Response message.  From the
		Discovery Response messages received, a WTP selects an AC with which to
		establish a secure DTLS session. In order to establish the secure DTLS
		connection, the WTP will need some amount of pre-provisioning, which
		is specified in <xref target="CAPWAP Pre-Provisioning"></xref>.
		CAPWAP protocol messages will be fragmented to the maximum length
		discovered to be supported by the network.</t>

        <t>Once the WTP and the AC have completed DTLS session establishment, a
		configuration exchange occurs in which both devices agree on version
		information. During this exchange, the WTP may receive provisioning 
		settings. The WTP is then enabled for operation.</t>

        <t>When the WTP and AC have completed the version and provision exchange
		and the WTP is enabled, the CAPWAP protocol is used to encapsulate the
		wireless data frames sent between the WTP and AC.  The CAPWAP protocol
		will fragment the L2 frames if the size of the encapsulated wireless
		user data (Data) or protocol control (Management) frames causes the
		resulting CAPWAP protocol packet to exceed the MTU supported between the
		WTP and AC.  Fragmented CAPWAP packets are reassembled to reconstitute
		the original encapsulated payload. MTU Discovery and Fragmentation are 
		described in <xref target="CAPWAP Transport"></xref>.</t>

        <t>The CAPWAP protocol provides for the delivery of commands from the AC
		to the WTP for the management of stations that are communicating with
		the WTP.  This may include the creation of local data structures in the
		WTP for the stations and the collection of statistical information about
		the communication between the WTP and the stations.  The CAPWAP protocol
		provides a mechanism for the AC to obtain statistical information
		collected by the WTP.</t>

        <t>The CAPWAP protocol provides for a keep-alive feature that preserves the 
		communication channel between the WTP and AC. If the AC fails to appear
		alive, the WTP will try to discover a new AC.</t>

	<section title="Wireless Binding Definition" anchor="Wireless Binding Definition">
		<t>The CAPWAP protocol is independent of a specific WTP radio
		technology, as well its associated wireless link layer protocol.
		Elements of the CAPWAP protocol are designed to accommodate
		the specific needs of each wireless technology in a standard way.
		Implementation of the CAPWAP protocol for a particular wireless
		technology MUST follow the binding requirements defined for that
		technology. </t>

		<t>When defining a binding for wireless technologies, the authors MUST
		include any necessary definitions for technology-specific messages
		and all technology-specific message elements for those messages.  At a
		minimum, a binding MUST provide:</t>
		<list style="hanging">
			<t hangText="1.">The definition for a binding-specific
			Statistics message element, carried in the WTP Event Request
			message.</t>
			<t hangText="2.">A message element carried in the Station
			Configuration Request message to configure station information on the WTP.</t>
			<t hangText="3.">A WTP Radio Information message element carried
			in the Discovery, Primary Discovery, and Join Request and Response messages, 
			indicating the binding-specific radio types
			supported at the WTP and AC.</t>
		</list>

		<t>If technology-specific message elements are required for any of the
		existing CAPWAP messages defined in this specification, they MUST also
		be defined in the technology binding document.</t>

        <t>The naming of binding-specific message elements MUST begin with the
        name of the technology type, e.g., the binding for IEEE 802.11,
        provided in <xref target="RFC5416"> </xref>,
		begins with "IEEE 802.11".</t>

		<t>The CAPWAP binding concept MUST also be used in any future specifications
		that add functionality to either the base CAPWAP protocol specification,
		or any published CAPWAP binding specification. A separate WTP
		Radio Information message element MUST be created to
		properly advertise support for the specification. This mechanism allows
		for future protocol extensibility, while providing the necessary
		capabilities advertisement, through the WTP Radio Information message
		element, to ensure WTP/AC interoperability.</t>

	</section> <!-- Wireless Bindings Definition -->


<section anchor="CAPWAP-Session-Establishment-Overview"
    title="CAPWAP Session Establishment Overview" >
	<t>This section describes the session establishment process message
	exchanges between a CAPWAP WTP and AC. The annotated ladder diagram shows
	the AC on the right, the WTP on the left, and assumes the use of
	certificates for DTLS authentication.  The CAPWAP protocol state machine is
	described in detail in <xref target="CAPWAP State Machine Definition"></xref>.
	Note that DTLS allows certain messages to be aggregated into a single frame,
	which is denoted via an asterisk in
	<xref target="CAPWAP Control Protocol Exchange"></xref>.</t>

	<figure anchor="CAPWAP Control Protocol Exchange"
	   title="CAPWAP Control Protocol Exchange">
	<artwork>
        ============                         ============
            WTP                                   AC
        ============                         ============
         [----------- begin optional discovery ------------]

                        Discover Request 
              ------------------------------------>
                        Discover Response
              &lt;------------------------------------

         [----------- end optional discovery ------------]

                   (-- begin DTLS handshake --)

                          ClientHello
              ------------------------------------>
                   HelloVerifyRequest (with cookie)
              &lt;------------------------------------


                     ClientHello (with cookie)
              ------------------------------------>
                             ServerHello,
                             Certificate,
                             ServerHelloDone*
              &lt;------------------------------------

             (-- WTP callout for AC authorization --)

                     Certificate (optional),
                      ClientKeyExchange,
                  CertificateVerify (optional),
                      ChangeCipherSpec,
                          Finished*
              ------------------------------------>

             (-- AC callout for WTP authorization --)

                      ChangeCipherSpec,
                          Finished*
              &lt;------------------------------------

             (-- DTLS session is established now --)

                           Join Request
              ------------------------------------>
                           Join Response
              &lt;------------------------------------
                   [-- Join State Complete --]

                (-- assume image is up to date --)

                   Configuration Status Request
              ------------------------------------>
                   Configuration Status Response
              &lt;------------------------------------
                 [-- Configure State Complete --]

                    Change State Event Request
              ------------------------------------>
                    Change State Event Response
              &lt;------------------------------------
                [-- Data Check State Complete --]

                     (-- enter RUN state --)
 
                                :
                                :

                           Echo Request
              ------------------------------------>
                          Echo Response
              &lt;------------------------------------

                                :
                                :

                           Event Request
              ------------------------------------>
                          Event Response
              &lt;------------------------------------

                                :
                                :
	</artwork>
	</figure>

   <t>At the end of the illustrated CAPWAP message exchange, the AC and WTP are
   securely exchanging CAPWAP Control messages. This illustration is provided to
   clarify protocol operation, and does not include any possible error
   conditions. <xref target="CAPWAP State Machine Definition"></xref> provides
   a detailed description of the corresponding state machine. </t>

    </section> <!-- CAPWAP Session Establishment Overview -->

	  <section title="CAPWAP State Machine Definition" anchor="CAPWAP State Machine Definition">
		<t>The following state diagram represents the lifecycle of a
		WTP-AC session. Use of DTLS by the CAPWAP protocol results
	   	in the juxtaposition of two nominally separate yet tightly bound
	  	state machines. The DTLS and CAPWAP state machines are coupled through
		an API consisting of commands (see
		<xref target="CAPWAP-to-DTLS-Commands"></xref>) and notifications
		(see <xref target="DTLS-to-CAPWAP-Notifications"></xref>). Certain
		transitions in the DTLS state machine are triggered by commands from
		the CAPWAP state machine, while certain transitions in the CAPWAP state
		machine are triggered by notifications from the DTLS state machine.</t>

		<figure anchor="CAPWAP Integated State Machine" title="CAPWAP Integrated State Machine">
<artwork>
                         /-------------------------------------\
                         |          /-------------------------\|
                         |         p|                         ||
                         |    q+----------+ r +------------+  ||
                         |     |   Run    |-->|   Reset    |-\||
                         |     +----------+   +------------+ |||
                        n|  o      ^           ^     ^      s|||
             +------------+--------/           |     |       |||
             | Data Check |             /-------/    |       |||
             +------------+&lt;-------\   |             |       |||
                                   |   |             |       |||
                    /------------------+--------\    |       |||
                   f|             m|  h|    j   v   k|       |||
            +--------+     +-----------+     +--------------+|||
            |  Join  |---->| Configure |     |  Image Data  ||||
            +--------+  n  +-----------+     +--------------+|||
             ^   |g                 i|                    l| |||
             |   |                   \-------------------\ | |||
             |   \--------------------------------------\| | |||
             \------------------------\                 || | |||
      /--------------&lt;----------------+---------------\ || | |||
      | /------------&lt;----------------+-------------\ | || | |||
      | |  4                          |d           t| | vv v vvv
      | |   +----------------+   +--------------+   +-----------+
      | |   |   DTLS Setup   |   | DTLS Connect |-->|  DTLS TD  |
    /-|-|---+----------------+   +--------------+ e +-----------+
    | | |    |$  ^  ^   |5  ^6         ^              ^  |w
    v v v    |   |  |   |   \-------\  |              |  |
    | | |    |   |  |   \---------\ |  |  /-----------/  |
    | | |    |   |  \--\          | |  |  |              |
    | | |    |   |     |          | |  |  |              |
    | | |    v  3|  1  |%     #   v |  |a |b             v
    | | \->+------+-->+------+   +-----------+    +--------+
    | |    | Idle |   | Disc |   | Authorize |    |  Dead  |
    | |    +------+&lt;--+------+   +-----------+    +--------+
    | |     ^   0^  2      |!
    | |     |    |         |   +-------+
   *| |u    |    \---------+---| Start |
    | |     |@             |   +-------+
    | \->+---------+&lt;------/   
    \--->| Sulking |
         +---------+&
</artwork>
       </figure>

		<t>The CAPWAP protocol state machine, depicted above, is used by both
		the AC and the WTP. In cases where states are not shared (i.e., not
		implemented in one or the other of the AC or WTP), this is explicitly
		called out in the transition descriptions below. For every state 
		defined, only certain messages are permitted to be sent and received.  
		The CAPWAP Control message definitions specify the state(s) in which
		each message is valid. </t>

		<t>Since the WTP only communicates with a single AC, it only has a
		single instance of the CAPWAP state machine.  The state machine works
		differently on the AC since it communicates with many WTPs.  The AC
		uses the concept of three threads.  Note that the term thread used here
		does not necessarily imply that implementers must use threads, but it
		is one possible way of implementing the AC's state machine.</t>
<!-- Possible replacement text
   Since the WTP only communicates with a single AC, it only has a
		single instance of the CAPWAP state machine. The state machine works
		differently on the AC since it communicates with many WTPs. The AC
		maintains two different types of state machine context; Listener and
		Service. The Listener context, which is managed by the Listener thread,
		while the Service context is managed by the Service thread. Note that
		the term thread used here does not require implementations to be
		multi-threaded, but is used to help illustrate the way the CAPWAP 
		state machine works.</t>
-->
		<list style="hanging">
			<t hangText="Listener Thread: ">The AC's Listener thread handles
			inbound DTLS session establishment requests, through the DTLSListen
			command. Upon creation, the Listener thread starts in the DTLS Setup
			state. Once a DTLS session has been validated, which occurs when
			the state machine enters the "Authorize" state, the Listener
			thread creates a WTP session-specific Service thread and state
			context. The state machine transitions in 
			<xref target="CAPWAP Integated State Machine"></xref> are
			represented by numerals. It is necessary for the AC to protect itself
			against various attacks that exist with non-authenticated frames.
			See <xref target="Security Considerations"></xref> for more
			information.</t> 

			<t hangText="Discovery Thread: ">The AC's Discovery thread is
			responsible for receiving, and responding to, Discovery Request
			messages. The state machine transitions in 
			<xref target="CAPWAP Integated State Machine"></xref> are
			represented by numerals. Note that the Discovery thread does not 
			maintain any per-WTP-specific context information, and a single 
			state context exists. It is necessary for the AC to protect
			itself against various attacks that exist with non-authenticated
			frames. See <xref target="Security Considerations"></xref> for more
			information.</t> 

			<t hangText="Service Thread: ">The AC's Service thread handles the
			per-WTP states, and one such thread exists per-WTP connection.
			This thread is created by the Listener thread when the Authorize
			state is reached. When created, the Service thread inherits a copy
			of the state machine context from the Listener thread. When
			communication with the WTP is complete, the Service thread is
			terminated and all associated resources are released. The state
			machine transitions in 
			<xref target="CAPWAP Integated State Machine"></xref> are
			represented by alphabetic and punctuation characters.</t>
		</list>

	<section title="CAPWAP Protocol State Transitions" anchor="CAPWAP Protocol State Transitions">
		<t> This section describes the various state transitions, and the
		events that cause them. This section does not discuss interactions
		between DTLS- and CAPWAP-specific states. Those interactions,
		and DTLS-specific states and transitions, are discussed in
		<xref target="CAPWAP/DTLS Interface"></xref>.</t>

		<list style="hanging">
			<t hangText="Start to Idle (0):">This transition occurs once
			device initialization is complete.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">This state transition is used to start
				the WTP's CAPWAP state machine.</t>

				<t hangText="AC:">The AC creates the Discovery and Listener
				threads and starts the CAPWAP state machine.</t>
			</list>

			<t hangText="Idle to Discovery (1):">This transition occurs to
			support the CAPWAP discovery process.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">The WTP enters the Discovery state prior to
				transmitting the first Discovery Request message (see 
				<xref target="Discovery Request"></xref>). Upon entering this
				state, the WTP sets the DiscoveryInterval timer (see 
				<xref target="CAPWAP Protocol Timers"></xref>). The WTP resets
				the DiscoveryCount counter to zero (0) (see 
				<xref target="CAPWAP Protocol Variables"></xref>). The WTP also
				clears all information from ACs it may have
				received during a previous Discovery phase.</t>

				<t hangText="AC:">This state transition is executed by the
				AC's Discovery thread, and occurs when a Discovery Request
				message is received. The AC SHOULD respond with a Discovery
				Response message (see <xref target="Discovery Response">
				</xref>).</t>
			</list>

			<t hangText="Discovery to Discovery (#):">In the Discovery state,
			the WTP determines to which AC to connect.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">This transition occurs when the DiscoveryInterval
				timer expires. If the WTP is configured with a list of ACs, it 
				transmits a Discovery Request message to every AC from which it
				has not received a Discovery Response message.  For every
				transition to this event, the WTP increments the DiscoveryCount
				counter. See <xref target="Discovery Request"></xref> for more
				information on how the WTP knows the ACs to which it should
				transmit the Discovery Request messages. The WTP restarts the
				DiscoveryInterval timer whenever it transmits Discovery Request
				messages.</t>

				<t hangText="AC:">This is an invalid state transition for the
				AC.</t>
			</list>

			<t hangText="Discovery to Idle (2):">This transition occurs on the
			AC's Discovery thread when the Discovery processing is complete.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">This is an invalid state transition for the
				WTP.</t>

				<t hangText="AC:">This state transition is executed by the
				AC's Discovery thread when it has transmitted the Discovery
				Response, in response to a Discovery Request.</t>
			</list>

			<t hangText="Discovery to Sulking (!):">This transition occurs on a
			WTP when AC Discovery fails.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">The WTP enters this state when the
				DiscoveryInterval timer expires and the DiscoveryCount variable
				is equal to the MaxDiscoveries variable (see
				<xref target="CAPWAP Protocol Variables"></xref>).
				Upon entering this state, the WTP MUST start the SilentInterval
				timer. While in the Sulking state, all received CAPWAP protocol
				messages MUST be ignored.</t>

				<t hangText="AC:">This is an invalid state transition for the
				AC.</t>
			</list>

			<t hangText="Sulking to Idle (@):">This transition occurs on a WTP
			when it must restart the Discovery phase.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">The WTP enters this state when the
				SilentInterval timer (see <xref target="CAPWAP Protocol Timers">
				</xref>) expires. The FailedDTLSSessionCount, DiscoveryCount, and
				FailedDTLSAuthFailCount counters are reset to zero.</t>

				<t hangText="AC:">This is an invalid state transition for the
				AC.</t>
			</list>

			<t hangText="Sulking to Sulking (&):">The Sulking state provides the
			silent period, minimizing the possibility for Denial-of-Service (DoS)
			attacks.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">All packets received from the AC while in the
				sulking state are ignored.</t>

				<t hangText="AC:">This is an invalid state transition for the
				AC.</t>
			</list>

			<t hangText="Idle to DTLS Setup (3):">This transition occurs to
			establish a secure DTLS session with the peer.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">The WTP initiates this transition by invoking
				the DTLSStart command (see
				<xref target="CAPWAP-to-DTLS-Commands"></xref>), which starts
				the DTLS session establishment with the chosen AC and the
				WaitDTLS timer is started (see <xref
				target="CAPWAP Protocol Timers"> </xref>). When the Discovery
				phase is bypassed, it is assumed the WTP has locally configured
				ACs.</t>

				<t hangText="AC:">Upon entering the Idle state from the Start
				state, the newly created Listener thread automatically
				transitions to the DTLS Setup and invokes the DTLSListen
				command (see <xref target="CAPWAP-to-DTLS-Commands"></xref>),
				and the WaitDTLS timer is started (see <xref
				target="CAPWAP Protocol Timers"> </xref>).</t>
			</list>

			<t hangText="Discovery to DTLS Setup (%):">This transition occurs to
			establish a secure DTLS session with the peer.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">The WTP initiates this transition by invoking
				the DTLSStart command (see
				<xref target="CAPWAP-to-DTLS-Commands"></xref>), which
				starts the DTLS session establishment with the chosen AC. The
				decision of to which AC to connect is the result of the
				Discovery phase, which is described in
				<xref target="AC Discovery"></xref>.</t>

				<t hangText="AC:">This is an invalid state transition for the
				AC.</t>
			</list>

			<t hangText="DTLS Setup to Idle ($):">This transition occurs when
			the DTLS connection setup fails.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">The WTP initiates this state transition when
				it receives a DTLSEstablishFail notification from DTLS (see
				<xref target="DTLS-to-CAPWAP-Notifications"></xref>), and
				the FailedDTLSSessionCount or the FailedDTLSAuthFailCount
				counter have not reached the value of the
				MaxFailedDTLSSessionRetry variable (see
				<xref target="CAPWAP Protocol Variables"></xref>). This error
				notification aborts the secure DTLS session establishment. When
				this notification is received, the FailedDTLSSessionCount
				counter is incremented. This state transition also occurs if the
				WaitDTLS timer has expired.</t>

				<t hangText="AC:">This is an invalid state transition for the
				AC.</t>
			</list>

			<t hangText="DTLS Setup to Sulking (*):">This transition occurs 
			when repeated attempts to set up the DTLS connection have failed.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">The WTP enters this state when the
				FailedDTLSSessionCount or the FailedDTLSAuthFailCount
				counter reaches the value of the MaxFailedDTLSSessionRetry
				variable (see <xref target="CAPWAP Protocol Variables"></xref>).
				Upon entering this state, the WTP MUST start the SilentInterval
				timer. While in the Sulking state, all received CAPWAP and DTLS
				protocol messages received MUST be ignored.</t>

				<t hangText="AC:">This is an invalid state transition for the
				AC.</t>
			</list>

			<t hangText="DTLS Setup to DTLS Setup (4):">This transition occurs
			when the DTLS Session failed to be established.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">This is an invalid state transition for the
				WTP.</t>

				<t hangText="AC:">The AC's Listener initiates this state
				transition when it receives a DTLSEstablishFail	notification
				from DTLS (see
				<xref target="DTLS-to-CAPWAP-Notifications"></xref>). This
				error notification aborts the secure DTLS session
				establishment. When this notification is received, the
				FailedDTLSSessionCount counter is incremented. The Listener
				thread then invokes the DTLSListen command (see
				<xref target="CAPWAP-to-DTLS-Commands"></xref>).</t>
			</list>

			<t hangText="DTLS Setup to Authorize (5):">This transition occurs when
			an incoming DTLS session is being established, and the DTLS stack
			needs authorization to proceed with the session establishment.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">This state transition occurs when the WTP
				receives the DTLSPeerAuthorize notification (see
				<xref target="DTLS-to-CAPWAP-Notifications"></xref>). Upon
				entering this state, the WTP performs an authorization
				check against the AC credentials. See
				<xref target="DTLS EndPoint Authentication and Authorization">
				</xref> for more information on AC authorization.</t>

				<t hangText="AC:">This state transition is handled by the AC's
				Listener thread when the DTLS module initiates the
				DTLSPeerAuthorize notification (see
				<xref target="DTLS-to-CAPWAP-Notifications"></xref>). The
				Listener thread forks an instance of the Service thread, along
				with a copy of the state context. Once created, the Service
				thread performs an authorization check against the WTP
				credentials.  See
				<xref target="DTLS EndPoint Authentication and Authorization">
				</xref> for more information on WTP authorization.</t>
			</list>

			<t hangText="Authorize to DTLS Setup (6):">This transition
			is executed by the Listener thread to enable it to listen for new
			incoming sessions.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">This is an invalid state transition for the
				WTP.</t>

				<t hangText="AC:">This state transition occurs when the AC's
				Listener thread has created the WTP context and the Service
				thread. The Listener thread then invokes the DTLSListen command
				(see <xref target="CAPWAP-to-DTLS-Commands"></xref>).</t>
			</list>

			<t hangText="Authorize to DTLS Connect (a):">This transition occurs
			to notify the DTLS stack that the session should be established.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">This state transition occurs when the WTP
				has successfully authorized the AC's credentials (see
				<xref target="DTLS EndPoint Authentication and Authorization">
				</xref>). This is done by invoking the DTLSAccept DTLS command
				(see <xref target="CAPWAP-to-DTLS-Commands"></xref>).</t>

				<t hangText="AC:">This state transition occurs when the AC
				has successfully authorized the WTP's credentials (see
				<xref target="DTLS EndPoint Authentication and Authorization">
				</xref>). This is done by invoking the DTLSAccept DTLS command
				(see <xref target="CAPWAP-to-DTLS-Commands"></xref>).</t>
			</list>

			<t hangText="Authorize to DTLS Teardown (b):">This transition occurs
			to notify the DTLS stack that the session should be aborted.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">This state transition occurs when the WTP
				has been unable to authorize the AC, using the AC credentials. The
				WTP then aborts the DTLS session by invoking the
				DTLSAbortSession command (see
				<xref target="CAPWAP-to-DTLS-Commands"></xref>). This state
				transition also occurs if the WaitDTLS timer has expired. The
				WTP starts the DTLSSessionDelete timer (see <xref
				target="DTLSSessionDelete"></xref>).</t>

				<t hangText="AC:">This state transition occurs when the AC
				has been unable to authorize the WTP, using the WTP credentials. The
				AC then aborts the DTLS session by invoking the
				DTLSAbortSession command (see
				<xref target="CAPWAP-to-DTLS-Commands"></xref>). This state
				transition also occurs if the WaitDTLS timer has expired. The
				AC starts the DTLSSessionDelete timer (see <xref
				target="DTLSSessionDelete"></xref>).</t>
			</list>

			<t hangText="DTLS Connect to DTLS Teardown (c):">This transition
			occurs when the DTLS Session failed to be established.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">This state transition occurs when the WTP
				receives either a DTLSAborted or DTLSAuthenticateFail
				notification (see
				<xref target="DTLS-to-CAPWAP-Notifications"></xref>),
				indicating that the DTLS session was not successfully
				established. When this transition occurs due to the
				DTLSAuthenticateFail notification, the FailedDTLSAuthFailCount
				is incremented; otherwise, the FailedDTLSSessionCount counter is
				incremented. This state transition also occurs if the WaitDTLS
				timer has expired.  The WTP starts the DTLSSessionDelete timer
				(see <xref target="DTLSSessionDelete"></xref>).</t>

				<t hangText="AC:">This state transition occurs when the AC
				receives either a DTLSAborted or DTLSAuthenticateFail
				notification (see
				<xref target="DTLS-to-CAPWAP-Notifications"></xref>),
				indicating that the DTLS session was not successfully
				established, and both of the FailedDTLSAuthFailCount and
				FailedDTLSSessionCount counters have not reached the value of
				the MaxFailedDTLSSessionRetry variable (see
				<xref target="CAPWAP Protocol Variables"></xref>). This state
				transition also occurs if the WaitDTLS timer has expired.
				The AC starts the DTLSSessionDelete timer (see <xref
				target="DTLSSessionDelete"></xref>).</t>
			</list>

			<t hangText="DTLS Connect to Join (d):">This transition occurs when
			the DTLS Session is successfully established.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">This state transition occurs when the WTP
				receives the DTLSEstablished notification (see
				<xref target="DTLS-to-CAPWAP-Notifications"></xref>),
				indicating that the DTLS session was successfully
				established. When this notification is received, the
				FailedDTLSSessionCount counter is set to zero. The WTP enters
				the Join state by transmitting the Join Request to the AC. The
				WTP stops the WaitDTLS timer.</t>

				<t hangText="AC:">This state transition occurs when the AC
				receives the DTLSEstablished notification (see
				<xref target="DTLS-to-CAPWAP-Notifications"></xref>),
				indicating that the DTLS session was successfully
				established. When this notification is received, the
				FailedDTLSSessionCount counter is set to zero.  The AC stops the
				WaitDTLS timer, and starts the WaitJoin timer.</t>
			</list>

			<t hangText="Join to DTLS Teardown (e):">This transition occurs when
			the join process has failed.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">This state transition occurs when the WTP
				receives a Join Response message with a Result Code message
				element containing an error, or if the Image Identifier provided
				by the AC in the Join Response message differs from the WTP's
				currently running firmware version and the WTP has the requested
				image in its non-volatile memory. This causes the WTP to
				initiate the DTLSShutdown command (see
				<xref target="CAPWAP-to-DTLS-Commands"></xref>). This transition
				also occurs if the WTP receives one of the following DTLS
				notifications: DTLSAborted, DTLSReassemblyFailure, or
				DTLSPeerDisconnect.  The WTP starts the DTLSSessionDelete timer
				(see <xref target="DTLSSessionDelete"></xref>).</t>

				<t hangText="AC:">This state transition occurs either if the
				WaitJoin timer expires or if the AC transmits a Join Response message
				with a Result Code message element containing an error. This
				causes the AC to initiate the DTLSShutdown command (see
				<xref target="CAPWAP-to-DTLS-Commands"></xref>). This transition
				also occurs if the AC receives one of the following DTLS
				notifications: DTLSAborted, DTLSReassemblyFailure, or
				DTLSPeerDisconnect.  The AC starts the DTLSSessionDelete timer
				(see <xref target="DTLSSessionDelete"></xref>).</t>
			</list>

			<t hangText="Join to Image Data (f):">This state transition is
			 used by the WTP and the AC to download executable firmware.</t>
			 <list style="hanging" hangIndent="6">
			 	<t hangText="WTP:">The WTP enters the Image Data state when it
				receives a successful Join Response message and determines that the
				software version in the Image Identifier message element is not
				the same as its currently running image. The WTP also detects
				that the requested image version is not currently available in
				the WTP's non-volatile storage (see
				<xref target="Firmware Management"></xref> for a
				full description of the firmware download process). The WTP
				initializes the EchoInterval timer (see
				<xref target="CAPWAP Protocol Timers"></xref>), and transmits
				the Image Data Request message (see
				<xref target="Image Data Request"></xref>) requesting
				the start of the firmware download.</t>

				<t hangText="AC:">This state transition occurs when the AC
				receives the Image Data Request message from the WTP, after
				having sent its Join Response to the WTP. The AC stops the 
				WaitJoin timer. The AC MUST transmit an Image Data Response
				message (see <xref target="Image Data Response"></xref>) to the
				WTP, which includes a portion of the firmware.</t>
			</list>

			<t hangText="Join to Configure (g):">This state transition is used
			by the WTP and the AC to exchange configuration information.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">The WTP enters the Configure state when it
				receives a successful Join Response message, and determines that
				the included Image Identifier message element is the same as its
				currently running image. The WTP transmits the Configuration
				Status Request message (see <xref
				target="Configuration-Status-Request"></xref>) to the AC with
				message elements describing its current configuration.</t>

				<t hangText="AC:">This state transition occurs when it
				receives the Configuration Status Request message from the WTP
				(see <xref target="Configuration-Status-Request"></xref>),
				which MAY include specific message elements to
				override the WTP's configuration. The AC stops the WaitJoin
				timer. The AC transmits the Configuration Status Response
				message (see
				<xref target="Configuration-Status-Response"></xref>) and
				starts the ChangeStatePendingTimer timer (see
				<xref target="CAPWAP Protocol Timers"></xref>).</t>
			 </list>

			<t hangText="Configure to Reset (h):">This state transition is used
			to reset the connection either due to an error during the
			configuration phase, or when the WTP determines it needs to reset
			in order for the new configuration to take effect. The CAPWAP Reset
			command is used to indicate to the peer that it will initiate a DTLS
			teardown.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">The WTP enters the Reset state when it
				receives a Configuration Status Response message indicating an
				error or when it determines that a reset of the WTP is required,
				due to the characteristics of a new configuration.</t>

				<t hangText="AC:">The AC transitions to the Reset state when it
				receives a Change State Event message from the WTP that contains
				an error for which AC policy does not permit the WTP to
				provide service. This state transition also occurs when the
				AC ChangeStatePendingTimer timer expires.</t>
			</list>

			<t hangText="Configure to DTLS Teardown (i):">This transition
			occurs when the configuration process aborts due to a DTLS
			error.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">The WTP enters this state when it receives
				one of the following DTLS notifications: DTLSAborted,
				DTLSReassemblyFailure, or DTLSPeerDisconnect
				(see <xref target="DTLS-to-CAPWAP-Notifications"></xref>).
				The WTP MAY tear down the DTLS session if it receives
				frequent DTLSDecapFailure notifications. The WTP starts the
				DTLSSessionDelete timer (see <xref
				target="DTLSSessionDelete"></xref>).</t>

				<t hangText="AC:">The AC enters this state when it receives
				one of the following DTLS notifications: DTLSAborted,
				DTLSReassemblyFailure, or DTLSPeerDisconnect
				(see <xref target="DTLS-to-CAPWAP-Notifications"></xref>). 
				The AC MAY tear down the DTLS session if it receives frequent
				DTLSDecapFailure notifications.  The AC starts the
				DTLSSessionDelete timer (see <xref
				target="DTLSSessionDelete"></xref>).</t>
			</list>

			<t hangText="Image Data to Image Data (j):">The Image Data state is
			used by the WTP and the AC during the firmware download phase.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">The WTP enters the Image Data state when it
				receives an Image Data Response message indicating that the AC
				has more data to send. This state transition also occurs when
				the WTP receives the subsequent Image Data Requests, at which
				time it resets the ImageDataStartTimer time to ensure it
				receives the next expected Image Data Request from the AC.
				This state transition can also occur when the WTP's
				EchoInterval timer (see <xref target="EchoInterval"/>) expires,
				in which case the WTP transmits an Echo Request message (see
				<xref target="Echo Request"/>), and resets its EchoInterval
				timer. The state transition also occurs when the WTP receives
				an Echo Response from the AC (see <xref target="Echo Response"/>).</t>

				<t hangText="AC:">This state transition occurs when the
				AC receives the Image Data Response message from the WTP while
				already in the Image Data state. This state transition also
				occurs when the AC receives an Echo Request (see <xref
				target="Echo Request"/>) from the WTP, in which case it responds
				with an Echo Response (see <xref target="Echo Response"/>), and
				resets its EchoInterval timer (see <xref
				target="EchoInterval"/>).</t>
			</list>


			<t hangText="Image Data to Reset (k):">This state transition is used
			to reset the DTLS connection prior to restarting the WTP after an
			image download.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">When an image download completes, or if the
				ImageDataStartTimer timer expires, the WTP enters the Reset
				state. The WTP MAY also transition to this state upon receiving
				an Image Data Response message from the AC (see
				<xref target="Image Data Response"></xref>) indicating a
				failure.</t>

				<t hangText="AC:">The AC enters the Reset state either when the 
				image transfer has successfully completed or an error occurs
				during the image download process.</t>
			</list>

			<t hangText="Image Data to DTLS Teardown (l):">This transition
			occurs when the firmware download process aborts due to a DTLS
			error.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">The WTP enters this state when it receives
				one of the following DTLS notifications: DTLSAborted,
				DTLSReassemblyFailure, or DTLSPeerDisconnect
				(see <xref target="DTLS-to-CAPWAP-Notifications"></xref>).
				The WTP MAY tear down the DTLS session if it receives
				frequent DTLSDecapFailure notifications. The WTP starts the
				DTLSSessionDelete timer (see <xref
				target="DTLSSessionDelete"></xref>).</t>

				<t hangText="AC:">The AC enters this state when it receives
				one of the following DTLS notifications: DTLSAborted,
				DTLSReassemblyFailure, or DTLSPeerDisconnect
				(see <xref target="DTLS-to-CAPWAP-Notifications"></xref>).
				The AC MAY tear down the DTLS session if it receives
				frequent DTLSDecapFailure notifications.  The AC starts the
				DTLSSessionDelete timer (see <xref
				target="DTLSSessionDelete"></xref>).</t>
			</list>

			<t hangText="Configure to Data Check (m):">This state transition occurs
			when the WTP and AC confirm the configuration.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">The WTP enters this state when it receives a
				successful Configuration Status Response message from the AC.
				The WTP transmits the Change State Event Request message (see
				<xref target="Change State Event Request"></xref>).</t>

				<t hangText="AC:">This state transition occurs when the AC
				receives the Change State Event Request message (see
				<xref target="Change State Event Request"></xref>) from the WTP.
				The AC responds with a Change State Event Response message (see
				<xref target="Change State Event Response"></xref>).
				The AC MUST start the DataCheckTimer timer and stops the
				ChangeStatePendingTimer timer (see
				<xref target="CAPWAP Protocol Timers"></xref>).</t>
			</list>

			<t hangText="Data Check to DTLS Teardown (n):">This transition
			occurs when the WTP does not complete the Data Check exchange.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">This state transition occurs if the WTP does
				not receive the Change State Event Response message before a
				CAPWAP retransmission timeout occurs. The WTP also
				transitions to this state if the underlying reliable transport's
				RetransmitCount counter has reached the MaxRetransmit
				variable (see <xref target="CAPWAP Protocol Timers"></xref>).
				The WTP starts the DTLSSessionDelete timer (see <xref
				target="DTLSSessionDelete"></xref>).</t>

				<t hangText="AC:">The AC enters this state when the
				DataCheckTimer timer expires (see
				<xref target="CAPWAP Protocol Timers"></xref>).  The AC starts
				the DTLSSessionDelete timer (see <xref
				target="DTLSSessionDelete"></xref>).</t>
			</list>

			<t hangText="Data Check to Run (o):">This state transition
			occurs when the linkage between the control and data channels is
			established, causing the WTP and AC to enter their normal state of
			operation.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">The WTP enters this state when it receives a
				successful Change State Event Response message from the AC. The
				WTP initiates the data channel, which MAY require the
				establishment of a DTLS session, starts the DataChannelKeepAlive
				timer (see <xref target="DataChannelKeepAlive"/>) and transmits
				a Data Channel Keep-Alive packet (see <xref
				target="CAPWAP Data Channel Keepalive"/>). The WTP then starts
				the EchoInterval timer and DataChannelDeadInterval timer (see 
				<xref target="CAPWAP Protocol Timers"></xref>).</t>

				<t hangText="AC:">This state transition occurs when the AC
				receives the Data Channel Keep-Alive packet (see
				<xref target="CAPWAP Data Channel Keepalive"></xref>), with a
				Session ID message element matching that included by the WTP
				in the Join Request message. The AC disables the DataCheckTimer
				timer. Note that if AC policy is to require the data channel to
				be encrypted, this process would also require the establishment
				of a data channel DTLS session. Upon receiving the Data Channel
				Keep-Alive packet, the AC transmits its own Data Channel Keep
				Alive packet.</t>
			</list>

			<t hangText="Run to DTLS Teardown (p):">This state transition
			occurs when an error has occurred in the DTLS stack, causing the
			DTLS session to be torn down.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">The WTP enters this state when it receives
				one of the following DTLS notifications: DTLSAborted,
				DTLSReassemblyFailure, or DTLSPeerDisconnect
				(see <xref target="DTLS-to-CAPWAP-Notifications"></xref>).
				The WTP MAY tear down the DTLS session if it receives
				frequent DTLSDecapFailure notifications. The WTP also
				transitions to this state if the underlying reliable transport's
				RetransmitCount counter has reached the MaxRetransmit
				variable (see <xref target="CAPWAP Protocol Timers"></xref>).
				The WTP starts the DTLSSessionDelete timer (see <xref
				target="DTLSSessionDelete"></xref>).</t>

				<t hangText="AC:">The AC enters this state when it receives
				one of the following DTLS notifications: DTLSAborted,
				DTLSReassemblyFailure, or DTLSPeerDisconnect
				(see <xref target="DTLS-to-CAPWAP-Notifications"></xref>).
				The AC MAY tear down the DTLS session if it receives
				frequent DTLSDecapFailure notifications.  The AC
				transitions to this state if the underlying reliable transport's
				RetransmitCount counter has reached the MaxRetransmit
				variable (see <xref target="CAPWAP Protocol Timers"></xref>).
                This state transition also occurs when the AC's EchoInterval
				timer (see <xref target="EchoInterval"></xref>) expires. The AC
				starts the DTLSSessionDelete timer (see <xref
				target="DTLSSessionDelete"></xref>).</t>
			</list>

			<t hangText="Run to Run (q):">This is the normal state of operation.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">This is the WTP's normal state of operation.
				The WTP resets its EchoInterval timer whenever it transmits a
				request to the AC. There are many events that result in this state
				transition:</t>
				<list style="hanging">
					<t hangText="Configuration Update:">The WTP receives a
					Configuration Update Request message (see
					<xref target="Configuration Update Request"></xref>).
					The WTP MUST respond with a Configuration Update Response
					message (see
					<xref target="Configuration Update Response"></xref>).</t>

					<t hangText="Change State Event:">The WTP receives a Change
					State Event Response message, or determines that it must
					initiate a Change State Event Request message, as a result
					of a failure or change in the state of a radio.</t>

					<t hangText="Echo Request:">The WTP sends an Echo Request
					message (<xref target="Echo Request"></xref>) or receives the
					corresponding Echo Response message, (see
					<xref target="Echo Response"></xref>) from the AC. When the
					WTP receives the Echo Response, it resets its EchoInterval
					timer (see <xref target="EchoInterval"></xref>).</t>

					<t hangText="Clear Config Request:">The WTP receives a Clear
					Configuration Request message (see
					<xref target="Clear-Configuration-Request"></xref>) and MUST
					generate a corresponding Clear Configuration Response
					message (see <xref target="Clear-Configuration-Response">
					</xref>). The WTP MUST reset its configuration back to
					manufacturer defaults.</t>

					<t hangText="WTP Event:">The WTP sends a WTP Event
					Request message, delivering information to the AC (see
					<xref target="WTP Event Request"></xref>). The WTP receives
					a WTP Event Response message from the AC (see
					<xref target="WTP Event Response"></xref>).</t>

					<t hangText="Data Transfer:">The WTP sends a Data
					Transfer Request or Data Transfer Response message to the AC
					(see <xref target="Data Transfer"></xref>). The WTP
					receives a Data Transfer Request or Data Transfer Response
					message from the AC (see <xref target="Data Transfer">
					</xref>). Upon receipt of a Data Transfer Request, the
					WTP transmits a Data Transfer Response to the AC.</t>

					<t hangText="Station Configuration Request:">The WTP
					receives a Station Configuration Request message (see 
					<xref target="Station-Configuration-Request"></xref>), to
					which it MUST respond with a Station Configuration Response message (see
					<xref target="Station-Configuration-Response"></xref>).</t>
				</list>

				<t hangText="AC:">This is the AC's normal state of operation. 
				Note that the receipt of any Request from the WTP causes the
				AC to reset its EchoInterval timer (see <xref
				target="EchoInterval"></xref>).</t>
				<list style="hanging">
					<t hangText="Configuration Update:">The AC sends a
					Configuration Update Request message (see
					<xref target="Configuration Update Request"></xref>) to the
					WTP to update its configuration. The AC receives a
					Configuration Update Response message (see
					<xref target="Configuration Update Response"></xref>) from
					the WTP.</t>

					<t hangText="Change State Event:">The AC receives a Change
					State Event Request message (see
					<xref target="Change State Event Request"></xref>), to which
					it MUST respond with the Change State Event Response message
					(see <xref target="Change State Event Response"></xref>).</t>

					<t hangText="Echo Request:">The AC receives an Echo Request
					message (see <xref target="Echo Request"></xref>), to which
					it MUST respond with an Echo Response message (see
					<xref target="Echo Response"></xref>).</t>

					<t hangText="Clear Config Response:">The AC sends a
					Clear Configuration Request message (see
					<xref target="Clear-Configuration-Request"></xref>) to the
					WTP to clear its configuration. The AC receives a Clear
					Configuration Response message from the WTP (see
					<xref target="Clear-Configuration-Response"></xref>).</t>

					<t hangText="WTP Event:">The AC receives a WTP Event
					Request message from the WTP (see 
					<xref target="WTP Event Request"></xref>) and MUST generate
					a corresponding WTP Event Response message (see
					<xref target="WTP Event Response"></xref>).</t>
					
					<t hangText="Data Transfer:">The AC sends a Data
					Transfer Request or Data Transfer Response message to the
					WTP (see <xref target="Data Transfer"></xref>). The AC
					receives a Data Transfer Request or Data Transfer Response
					message from the WTP (see <xref target="Data Transfer">
					</xref>). Upon receipt of a Data Transfer Request, the
					AC transmits a Data Transfer Response to the WTP.</t>

					<t hangText="Station Configuration Request:">The AC sends a Station
					Configuration Request message (see
					<xref target="Station-Configuration-Request"></xref>) or
					receives the corresponding Station Configuration Response
					message (see
					<xref target="Station-Configuration-Response"></xref>) from
					the WTP.</t>

				</list>
			</list>

			<t hangText="Run to Reset (r):">This state transition is used when
			either the AC or WTP tears down the connection. This may occur as
			part of normal operation, or due to error conditions.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">The WTP enters the Reset state when it
				receives a Reset Request message from the AC.</t>

				<t hangText="AC:">The AC enters the Reset state when it
				transmits a Reset Request message to the WTP.</t>
			</list>

			<t hangText="Reset to DTLS Teardown (s):">This transition occurs
			when the CAPWAP reset is complete to terminate the DTLS session.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">This state transition occurs when the WTP
				transmits a Reset Response message. The WTP does not invoke the
				DTLSShutdown command (see
				<xref target="CAPWAP-to-DTLS-Commands"></xref>). The WTP starts
				the DTLSSessionDelete timer (see <xref
				target="DTLSSessionDelete"></xref>).</t>

				<t hangText="AC:">This state transition occurs when the AC
				receives a Reset Response message. This causes the AC to
				initiate the DTLSShutdown command (see
				<xref target="CAPWAP-to-DTLS-Commands"></xref>). The AC starts
				the DTLSSessionDelete timer (see <xref
				target="DTLSSessionDelete"></xref>).</t>
			</list>

			<t hangText="DTLS Teardown to Idle (t):">This transition occurs
			when the DTLS session has been shut down.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">This state transition occurs when the WTP has
				successfully cleaned up all resources associated with the
				control plane DTLS session, or if the DTLSSessionDelete timer
				(see <xref target="DTLSSessionDelete"></xref>) expires. The data
				plane DTLS session is also shut down, and all resources released,
				if a DTLS session was established for the data plane. Any timers
				set for the current instance of the state machine are also cleared.</t>

				<t hangText="AC:">This is an invalid state transition for the
				AC.</t>
			</list>

			<t hangText="DTLS Teardown to Sulking (u):">This transition occurs 
			when repeated attempts to setup the DTLS connection have failed.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">The WTP enters this state when the
				FailedDTLSSessionCount or the FailedDTLSAuthFailCount
				counter reaches the value of the MaxFailedDTLSSessionRetry
				variable (see <xref target="CAPWAP Protocol Variables"></xref>).
				Upon entering this state, the WTP MUST start the SilentInterval
				timer. While in the Sulking state, all received CAPWAP and DTLS
				protocol messages received MUST be ignored.</t>

				<t hangText="AC:">This is an invalid state transition for the
				AC.</t>
			</list>

			<t hangText="DTLS Teardown to Dead (w):">This transition occurs
			when the DTLS session has been shut down.</t>
			<list style="hanging" hangIndent="6">
				<t hangText="WTP:">This is an invalid state transition for the
				WTP.</t>

				<t hangText="AC:">This state transition occurs when the AC has
				successfully cleaned up all resources associated with the
				control plane DTLS session , or if the DTLSSessionDelete timer
				(see <xref target="DTLSSessionDelete"></xref>) expires. The data
				plane DTLS session is also shut down, and all resources released,
				if a DTLS session was established for the data plane. Any timers
				set for the current instance of the state machine are also
				cleared. The AC's Service thread is terminated.</t>
			</list>
		</list>
	   </section><!-- CAPWAP Protocol State Transitions -->	 

	<section title="CAPWAP/DTLS Interface" anchor="CAPWAP/DTLS Interface"> 
	<t>This section describes the DTLS Commands used by CAPWAP, and the
	notifications received from DTLS to the CAPWAP protocol stack.</t>

	<section title="CAPWAP to DTLS Commands" anchor="CAPWAP-to-DTLS-Commands"> 

	<t>Six commands are defined for the CAPWAP to DTLS API. These "commands"
	are conceptual, and may be implemented as one or more function calls. This
	API definition is provided to clarify interactions between the DTLS and
	CAPWAP components of the integrated CAPWAP state machine.</t>

	<t> Below is a list of the minimal command APIs:	</t>
	<list style="symbols">

<!--		<t>DTLSInit is invoked in order to initialize the DTLS protocol
		stack. The CAPWAP protocol stack includes various elements in the 
		initialization procedure, including the crypto algorithms supported
		(see <xref target="DTLS-Endpoint-Authentication"></xref>).</t> -->

		<t>DTLSStart is sent to the DTLS component to cause a DTLS session
		to be established. Upon invoking the DTLSStart command, the WaitDTLS
		timer is started. The WTP initiates this
		DTLS command, as the AC does not initiate DTLS sessions.</t>

		<t>DTLSListen is sent to the DTLS component to allow the DTLS component
		to listen for incoming DTLS session requests.</t>

		<t>DTLSAccept is sent to the DTLS component to allow the DTLS
		session establishment to continue successfully.</t>

		<t>DTLSAbortSession is sent to the DTLS component to cause the session
		that is in the process of being established to be aborted. This command
		is also sent when the WaitDTLS timer expires. When this command is
		executed, the FailedDTLSSessionCount counter is incremented.</t>

		<t>DTLSShutdown is sent to the DTLS component to cause session
		teardown. </t>

		<t>DTLSMtuUpdate is sent by the CAPWAP component to modify the MTU size
		used by the DTLS component. See <xref target="MTU Discovery"></xref> 
		for more information on MTU Discovery. The default size is 1468 bytes.</t>
 	</list>
	</section><!-- CAPWAP to DTLS Commands -->	

	<section title="DTLS to CAPWAP Notifications" anchor="DTLS-to-CAPWAP-Notifications"> 

	<t>DTLS notifications are defined for the DTLS to CAPWAP API. These
	"notifications" are conceptual and may be implemented in numerous ways
	(e.g., as function return values). This API definition is provided to clarify
	interactions between the DTLS and CAPWAP components of the integrated CAPWAP
	state machine. It is important to note that the notifications listed below
	MAY cause the CAPWAP state machine to jump from one state to another using
	a state transition not listed in
	<xref target="CAPWAP Protocol State Transitions"></xref>. When a
	notification listed below occurs, the target CAPWAP state shown in
	<xref target="CAPWAP Integated State Machine"></xref> becomes the current
	state.</t>

	<t>Below is a list of the API notifications:</t>
	<list style="symbols">

<!--		<t>n1: DTLSInitComplete is sent by the DTLS library to the CAPWAP
		protocol stack when initialization is complete. The initialization
		may be successful, in which case the CAPWAP state machine proceeds.
		Alternatively, if the initialization fails, which could occurs due to
		lack of memory, or some other internal error condition, causes the 
		CAPWAP state machine to stop in the Idle state.</t>  -->

		<t>DTLSPeerAuthorize is sent to the CAPWAP component during
		DTLS session establishment once the peer's identity has been
		received. This notification MAY be used by the CAPWAP component
		to authorize the session, based on the peer's identity. The
		authorization process will lead to the CAPWAP component initiating
		either the DTLSAccept or DTLSAbortSession commands.</t>

		<t>DTLSEstablished is sent to the CAPWAP component to indicate that
		a secure channel now exists, using the parameters provided during
		the DTLS initialization process. When this notification is received,
		the FailedDTLSSessionCount counter is reset to zero. When
		this notification is received, the WaitDTLS timer is stopped.</t>

		<t>DTLSEstablishFail is sent when the DTLS session establishment
		has failed, either due to a local error or due to the peer rejecting
		the session establishment. When this notification is received,
		the FailedDTLSSessionCount counter is incremented.</t>

		<t>DTLSAuthenticateFail is sent when DTLS session establishment has
		failed due to an authentication error. When this notification is
		received, the FailedDTLSAuthFailCount counter is incremented.</t>

		<t>DTLSAborted is sent to the CAPWAP component to indicate that session
		abort (as requested by CAPWAP) is complete; this occurs to confirm a
		DTLS session abort or when the WaitDTLS timer expires. When
		this notification is received, the WaitDTLS timer is stopped.</t>

		<t>DTLSReassemblyFailure MAY be sent to the CAPWAP component to indicate
		DTLS fragment reassembly failure.</t>

		<t>DTLSDecapFailure MAY be sent to the CAPWAP module to indicate a
		decapsulation failure. DTLSDecapFailure MAY be sent to the CAPWAP module to
		indicate an encryption/authentication failure. This notification
		is intended for informative purposes only, and is not intended to
		cause a change in the CAPWAP state machine (see
		<xref target="Interference with a DTLS Session"></xref>).</t>

		<t>DTLSPeerDisconnect is sent to the CAPWAP component to indicate the
		DTLS session has been torn down. Note that this notification is only 
		received if the DTLS session has been established. </t>
	</list>
	</section><!-- DTLS to CAPWAP Notifications -->

	</section> <!-- CAPWAP/DTLS Interface -->

	</section><!--CAPWAP State Machine Definition -->
	 		
	<section title="Use of DTLS in the CAPWAP Protocol" anchor="Use-of-DTLS-in-the-CAPWAP-Protocol">

	<t>DTLS is used as a tightly integrated, secure wrapper for the
	CAPWAP protocol. In this document, DTLS and CAPWAP are discussed as nominally 
	distinct entities; however, they are very closely coupled, and may even be
	implemented inseparably. Since there are DTLS library implementations
	currently available, and since security protocols (e.g., IPsec, TLS) are
	often implemented in widely available acceleration hardware, it is both
	convenient and forward-looking to maintain a modular distinction in this
	document. </t>

	<t>This section describes a detailed walk-through of the interactions 
	between the DTLS module and the CAPWAP module, via 'commands' (CAPWAP to
	DTLS) and 'notifications' (DTLS to CAPWAP) as they would be encountered
	during the normal course of operation.</t>

	<section title="DTLS Handshake Processing" anchor="DTLS-Handshake-Processing" >

	<t> Details of the DTLS handshake process are specified in
	<xref target="RFC4347"></xref>. This section describes the
	interactions between the DTLS session establishment process and the
	CAPWAP protocol. Note that the conceptual DTLS state is shown below
	to help understand the point at which the DTLS states transition.
	In the normal case, the DTLS handshake will proceed as shown in 
	<xref target="DTLS Handshake"></xref>. (NOTE: this example uses
	certificates, but pre-shared keys are also supported.) </t>

	<figure anchor="DTLS Handshake" title="DTLS Handshake">
	<artwork>
        ============                         ============
            WTP                                   AC
        ============                         ============
        ClientHello           ------>
                              &lt;------       HelloVerifyRequest
                              			(with cookie)
                              
        ClientHello           ------>
        (with cookie)
                              &lt;------       ServerHello                      
                              &lt;------       Certificate
                              &lt;------       ServerHelloDone

        (WTP callout for AC authorization
		 occurs in CAPWAP Auth state)

        Certificate*
        ClientKeyExchange
        CertificateVerify*
        ChangeCipherSpec
        Finished              ------>

                             (AC callout for WTP authorization
                              occurs in CAPWAP Auth state)

                                            ChangeCipherSpec
                              &lt;------       Finished

	</artwork>
	</figure>

	<t>DTLS, as specified, provides its own retransmit timers with an
	exponential back-off. <xref target="RFC4347"/> does not specify how long
	retransmissions should continue. Consequently, timing out incomplete
	DTLS handshakes is entirely the responsibility of the CAPWAP module.</t>

	<t>The DTLS implementation used by CAPWAP MUST support TLS Session
	Resumption. Session resumption is typically used to establish the DTLS
	session used for the data channel. Since the data channel uses different
	port numbers than the control channel, the DTLS implementation on the WTP
	MUST provide an interface that allows the CAPWAP module to request session
	resumption despite the use of the different port numbers (TLS
	implementations usually attempt session resumption only when connecting to
	the same IP address and port number). Note that session resumption is not
	guaranteed to occur, and a full DTLS handshake may occur instead.</t>

	<t>The DTLS implementation used by CAPWAP MUST use replay detection, per
	Section 3.3 of <xref target="RFC4347"/>.  Since the CAPWAP protocol handles
	retransmissions by re-encrypting lost frames, any duplicate DTLS frames are
	either unintentional or malicious and should be silently discarded.</t>

	</section><!--DTLS Handshake Processing -->

	<section title="DTLS Session Establishment" anchor="DTLS Session Establishment" >	 
	<t> The WTP, either through the Discovery process or through
	pre-configuration, determines to which AC to connect. The WTP uses the
	DTLSStart command to request that a secure connection be established to the
	selected AC. Prior to initiation of the DTLS handshake, the WTP sets the
	WaitDTLS timer. Upon invoking the DTLSStart or DTLSListen commands, the WTP
	and AC, respectively, set the WaitDTLS timer. If the DTLSEstablished
	notification is not received prior to timer expiration, the DTLS session is
	aborted by issuing the DTLSAbortSession DTLS command. This notification
	causes the CAPWAP module to transition to the Idle state. Upon receiving a
	DTLSEstablished notification, the WaitDTLS timer is deactivated. </t>
	</section><!--DTLS Session Establishment-->

	<section title="DTLS Error Handling" anchor="DTLS Error Handling">
	<!--
	<t>If the AC does not respond to any DTLS handshake messages sent by the
	WTP, the DTLS specification calls for the WTP to retransmit these messages
	according to the current value of the exponential back-off timer. If the
	WaitDTLS timer expires, CAPWAP will issue the DTLSAbortSession command,
	causing DTLS to terminate the handshake and remove any allocated session
	context.  Note that DTLS MAY send a single TLS Alert message to the AC to
	indicate session termination.</t> -->

	<t>If the AC or WTP does not respond to any DTLS handshake messages sent by
	its peer, the DTLS specification calls for the message to be retransmitted.
	Note that during the handshake, when both the AC and the WTP are expecting
	additional handshake messages, they both retransmit if an expected message
	has not been received (note that retransmissions for CAPWAP Control messages
	work differently: all CAPWAP Control messages are either requests or
	responses, and the peer who sent the request is responsible for
	retransmissions).</t>

<!--	<t>If the WTP does not respond to any DTLS handshake messages sent by the
	AC, the CAPWAP protocol allows for three possibilities, listed below. Note
	that DTLS MAY send a single TLS Alert message to the AC to indicate session
	termination.</t>

	<list style="symbols">
		<t> The message was lost in transit; in this case, the DTLS
		implementation on the WTP will retransmit its last outstanding handshake
		message, since it did not receive a reply.</t>

		<t> The WTP sent a DTLS Alert, which was lost in transit; in this case,
		the AC's WaitDTLS timer will expire, and the session will be terminated.</t>

		<t>Communication with the WTP has completely failed; in this case, the
		AC's WaitDTLS timer will expire, and the session will be terminated.</t>
	</list>

	<t>The DTLS specification provides for retransmission of unacknowledged
	requests. If retransmissions remain unacknowledged, the WaitDTLS timer will
	eventually expire, at which time the CAPWAP component will terminate the
	session.</t> -->

	<t>If the WTP or the AC does not receive an expected DTLS handshake message
	despite of retransmissions, the WaitDTLS timer will eventually expire, and
	the session will be terminated.  This can happen if communication between
	the peers has completely failed, or if one of the peers sent a DTLS Alert
	message that was lost in transit (DTLS does not retransmit Alert
	messages).</t>

    <t>If a cookie fails to validate, this could represent a WTP error, or
	it could represent a DoS attack.  Hence, AC resource utilization
	SHOULD be minimized.  The AC MAY log a message indicating the
	failure, and SHOULD treat the message as though no cookie were
	present.</t>
<!-- Issue 157: Issue with handling of cookies
	<t>If a cookie fails to validate, this could represent a WTP error,
	or it could represent a DoS attack. Hence, AC resource utilization 
	SHOULD be minimized. The AC MAY log a message indicating the failure,
	but SHOULD NOT attempt to reply to the WTP.</t>
-->

	<t>Since DTLS Handshake messages are potentially larger than the maximum
	record size, DTLS supports fragmenting of Handshake messages across
	multiple records.  There are several potential causes of re-assembly
	errors, including overlapping and/or lost fragments.  The DTLS
	component MUST send a DTLSReassemblyFailure notification to the CAPWAP component. Whether
	precise information is given along with notification is an implementation
	issue, and hence is beyond the scope of this document.  Upon receipt of such
	an error, the CAPWAP component SHOULD log an appropriate
	error message.  Whether processing continues or the DTLS session is
	terminated is implementation dependent. </t>

	<t>DTLS decapsulation errors consist of three types: decryption errors,
	authentication errors, and malformed DTLS record headers. Since DTLS
	authenticates the data prior to encapsulation, if decryption fails, it is
	difficult to detect this without first attempting to authenticate the packet.
	If authentication fails, a decryption error is also likely, but not
	guaranteed. Rather than attempt to derive (and require the implementation of)
	algorithms for detecting decryption failures, decryption failures are reported as
	authentication failures. The DTLS component MUST provide a DTLSDecapFailure
	notification to the CAPWAP component when such errors occur. If a malformed DTLS record
	header is detected, the packets SHOULD be silently discarded, and the
	receiver MAY log an error message.</t>

	<t>There is currently only one encapsulation error defined: MTU exceeded.
	As part of DTLS session establishment, the CAPWAP component informs the DTLS
	component of the MTU size. This may be dynamically modified at any time
	when the CAPWAP component sends the DTLSMtuUpdate command to the DTLS
	component (see <xref target="CAPWAP-to-DTLS-Commands"></xref>). The value
	provided to the DTLS stack is the result of the MTU Discovery process, which
	is described in <xref target="MTU Discovery"></xref>. The DTLS
	component returns this notification to the CAPWAP component whenever a
	transmission request will result in a packet that exceeds the MTU.</t>

	</section> <!-- DTLS Error Handling -->

	<section title="DTLS Endpoint Authentication and Authorization"
	anchor="DTLS EndPoint Authentication and Authorization" >

	<t>DTLS supports endpoint authentication with certificates or pre-shared
	keys. The TLS algorithm suites for each endpoint authentication method
	are described below.</t>

	<section title="Authenticating with Certificates">
	<t>CAPWAP implementations only use cipher suites that are recommended for
	use with DTLS, see <xref target="DTLS-DESIGN"/>. At present, the following
	algorithms MUST be supported when using certificates for CAPWAP
	authentication:</t>

	<list style="symbols">
		<t>TLS_RSA_WITH_AES_128_CBC_SHA <xref target="RFC5246"/></t>
	</list>

	<t>The following algorithms SHOULD be supported when using certificates:</t>
	<list style="symbols">
		<t>TLS_DHE_RSA_WITH_AES_128_CBC_SHA <xref target="RFC5246"/></t>
	</list>

	<t>The following algorithms MAY be supported when using certificates:</t>
	<list style="symbols">
		<t>TLS_RSA_WITH_AES_256_CBC_SHA <xref target="RFC5246"/></t>
		<t>TLS_DHE_RSA_WITH_AES_256_CBC_SHA <xref target="RFC5246"/></t>
	</list>

	<t>Additional ciphers MAY be defined in subsequent CAPWAP specifications.</t>

	</section> <!-- Authenticating With Certificates -->

	<section title="Authenticating with Pre-Shared Keys">
	<t>Pre-shared keys present significant challenges from a security
	perspective, and for that reason, their use is strongly discouraged. 
	Several methods for authenticating with pre-shared keys are defined
	<xref target="RFC4279"/>, and we focus on the following two:</t>
	<list style="symbols">
		<t>Pre-Shared Key (PSK) key exchange algorithm - simplest method,
		ciphersuites use only symmetric key algorithms.</t>
		<t>DHE_PSK key exchange algorithm - use a PSK to authenticate a 
		Diffie-Hellman exchange.  These ciphersuites give some additional
		protection against dictionary attacks and also provide Perfect Forward 
		Secrecy (PFS).</t>
	</list>

	<t>The first approach (plain PSK) is susceptible to passive dictionary
	attacks; hence, while this algorithm MUST be supported, special care should
	be taken when choosing that method. In particular, user-readable passphrases
	SHOULD NOT be used, and use of short PSKs SHOULD be strongly discouraged.</t>

	<t>The following cryptographic algorithms MUST be supported when using
	pre-shared keys:</t>
	<list style="symbols">
		<t>TLS_PSK_WITH_AES_128_CBC_SHA <xref target="RFC5246"/></t>
		<t>TLS_DHE_PSK_WITH_AES_128_CBC_SHA <xref target="RFC5246"/></t>
	</list>

	<t>The following algorithms MAY be supported when using pre-shared keys:</t>
	<list style="symbols">
		<t>TLS_PSK_WITH_AES_256_CBC_SHA <xref target="RFC5246"/></t>
		<t>TLS_DHE_PSK_WITH_AES_256_CBC_SHA <xref target="RFC5246"/></t>
	</list>

	<t>Additional ciphers MAY be defined in following CAPWAP specifications.</t>
	</section> <!-- Authenticating With Pre-shared Keys -->

	<section anchor="Certificate-Usage" title="Certificate Usage">

	<t>Certificate authorization by the AC and WTP is required so that
	only an AC may perform the functions of an AC and that only a WTP may
	perform the functions of a WTP.  This restriction of functions to the
	AC or WTP requires that the certificates used by the AC MUST be
	distinguishable from the certificate used by the WTP.  To accomplish 
  	this differentiation, the x.509 certificates MUST include the Extended Key
	Usage (EKU) certificate extension <xref target="RFC5280"/>.</t>

	<t>The EKU field indicates one or more purposes for which a certificate
	may be used.  It is an essential part in authorization.  Its syntax is
	described in <xref target="RFC5280"/> and <xref target="ISO.9834-1.1993"/>
	and is as follows:</t>
<artwork>
      ExtKeyUsageSyntax  ::=  SEQUENCE SIZE (1..MAX) OF KeyPurposeId

      KeyPurposeId  ::=  OBJECT IDENTIFIER

</artwork>

	<t>Here we define two KeyPurposeId values, one for the WTP and one for
	the AC.  Inclusion of one of these two values indicates a certificate is
	authorized for use by a WTP or AC, respectively. These values are formatted
	as id-kp fields.</t>

<artwork>
   	  id-kp  OBJECT IDENTIFIER  ::=
  	      { iso(1) identified-organization(3) dod(6) internet(1)
  	        security(5) mechanisms(5) pkix(7) 3 }

  	   id-kp-capwapAC   OBJECT IDENTIFIER  ::=  { id-kp 18 }
  	   
  	   id-kp-capwapWTP  OBJECT IDENTIFIER  ::=  { id-kp 19 }
</artwork>

	<t>All capwap devices MUST support the ExtendedKeyUsage certificate
	extension if it is present in a certificate.  If the extension is present,
	then the certificate MUST have either the id-kp-capwapAC or the
	id-kp-anyExtendedKeyUsage keyPurposeID to act as an AC.  Similarly, if the
	extension is present, a device MUST have the id-kp-capwapWTP or
	id-kp-anyExtendedKeyUsage keyPurposeID to act as a WTP.</t>

	<t>Part of the CAPWAP certificate validation process includes ensuring
	that the proper EKU is included and allowing the CAPWAP
	session to be established only if the extension properly represents the
	device. For instance, an AC SHOULD NOT accept a connection request from
	another AC, and therefore MUST verify that the id-kp-capwapWTP EKU is
	present in the certificate.</t>

	<t>CAPWAP implementations MUST support certificates where the common
	name (CN) for both the WTP and AC is the MAC address of that device.  The
	MAC address MUST be encoded in the PrintableString format, using the well-recognized MAC address format of 01:23:45:67:89:ab. The CN field MAY
	contain either of the <xref target="EUI-48">EUI-48</xref> or
	<xref target="EUI-64">EUI-64</xref> MAC Address formats. This seemingly
	unconventional use of the CN field is consistent with other standards that
	rely on device certificates that are provisioned during the manufacturing
	process, such as Packet Cable <xref target="PacketCable"/>, Cable Labs
	<xref target="CableLabs"/>, and WiMAX <xref target="WiMAX"/>. See <xref
	target="Use of MAC Address in CN Field"/> for more information on the use
	of the MAC address in the CN field.</t>

	<t>ACs and WTPs MUST authorize (e.g., through access control lists)
	certificates of devices to which they are connecting, e.g., based on the
	issuer, MAC address, or organizational information specified in the
	certificate. The identities specified in the certificates bind a
	particular DTLS session to a specific pair of mutually authenticated and
	authorized MAC addresses. The particulars of authorization filter
	construction are implementation details which are, for the most part, not
	within the scope of this specification. However, at minimum, all devices
	MUST verify that the appropriate EKU bit is set according to the role of
	the peer device (AC versus WTP), and that the issuer of the certificate is
	appropriate for the domain in question.</t>

    </section> <!-- Certificate Usage -->

	<section anchor="PSK Usage" title="PSK Usage">

	<t>When DTLS uses PSK Ciphersuites, the ServerKeyExchange message MUST
	contain the "PSK identity hint" field and the ClientKeyExchange
	message MUST contain the "PSK identity" field.  These fields are used
	to help the WTP select the appropriate PSK for use with the AC, and
	then indicate to the AC which key is being used.
	When PSKs are provisioned to WTPs and ACs, both the PSK Hint and PSK
	Identity for the key MUST be specified.</t>

	<t>The PSK Hint SHOULD uniquely identify the AC and the PSK Identity
	SHOULD uniquely identify the WTP.  It is RECOMMENDED that these hints
	and identities be the ASCII HEX-formatted MAC addresses of the
	respective devices, since each pairwise combination of WTP and AC
	SHOULD have a unique PSK.  The PSK Hint and Identity SHOULD be
	sufficient to perform authorization, as simply having knowledge of a
	PSK does not necessarily imply authorization.</t>

	<t>If a single PSK is being used for multiple devices on a CAPWAP
	network, which is NOT RECOMMENDED, the PSK Hint and Identity can no
	longer be a MAC address, so appropriate hints and identities SHOULD
	be selected to identify the group of devices to which the PSK is
	provisioned.</t>
	</section> <!-- PSK Usage -->

	</section> <!-- DTLS EndPoint Authentication and Authorization -->

	</section> <!-- Use of DTLS in the CAPWAP Protocol -->

     </section> <!-- Protocol Overview -->

     <section anchor="CAPWAP Transport" title="CAPWAP Transport">
        <t>Communication between a WTP and an AC is established using the
		standard UDP client/server model.  The CAPWAP protocol supports both UDP
		and UDP-Lite  <xref target="RFC3828"></xref> transport protocols. When
		run over IPv4, UDP is used for the CAPWAP Control and Data channels.</t>

		<t>When run over IPv6, the CAPWAP Control channel always uses UDP, while
		the CAPWAP Data channel may use either UDP or UDP-Lite. UDP-Lite is the
		default transport protocol for the CAPWAP Data channel. However, if a
		middlebox or IPv4 to IPv6 gateway has been discovered, UDP is used for
		the CAPWAP Data channel.</t>

		<t>This section describes how the CAPWAP protocol is carried over IP
		and UDP/UDP-Lite transport protocols. The CAPWAP Transport
		Protocol message element, <xref target="CAPWAP Transport Protocol"></xref>,
		describes the rules to use in determining which transport protocol is to
		be used.</t>

		<t>In order for CAPWAP to be compatible with potential middleboxes
		in the network, CAPWAP implementations MUST send return traffic from the
		same port on which they received traffic from a given peer. Further, any
		unsolicited requests generated by a CAPWAP node MUST be sent on the same
		port.</t>

	<section anchor="UDP Transport" title="UDP Transport">
		<t>One of the CAPWAP protocol requirements is to allow a WTP to reside
		behind a middlebox, firewall, and/or Network Address Translation (NAT)
		device. Since a CAPWAP session is initiated by the WTP (client) to the
		well-known UDP port of the AC (server), the use of UDP is a logical
		choice.  When CAPWAP is run over IPv4, the UDP checksum field in CAPWAP
		packets MUST be set to zero.</t>

		<t>CAPWAP protocol control packets sent from the WTP to the AC use
		the CAPWAP Control channel, as defined in 
		<xref target="Terminology"></xref>. The CAPWAP control port at the AC
		is the well-known UDP port 5246. The CAPWAP control port at the WTP can
		be any port selected by the WTP.</t>

		<t>CAPWAP protocol data packets sent from the WTP to the AC use the
		CAPWAP Data channel, as defined in <xref target="Terminology"></xref>.
		The CAPWAP data port at the AC is the well-known UDP port 5247. If
		an AC permits the administrator to change the CAPWAP control port, the
		CAPWAP data port MUST be the next consecutive port number. The CAPWAP
		data port at the WTP can be any port selected by the WTP.</t> 

    </section> <!-- UDP Transport -->

	<section anchor="UDP-Lite Transport" title="UDP-Lite Transport">
		<t>When CAPWAP is run over IPv6, UDP-Lite is the default transport
		protocol, which reduces the checksum processing required for each packet
		(compared to the use of UDP over IPv6 <xref target="RFC2460"></xref>).
		When UDP-Lite is used, the checksum field MUST have a coverage of 8
		<xref target="RFC3828"></xref>.</t>

		<t>UDP-Lite uses the same port assignments as UDP.</t>
    </section> <!-- UDP-Lite Transport -->

	<section title="AC Discovery" anchor="AC Discovery">
		<t>The AC Discovery phase allows the WTP to determine which ACs are
		available and choose the best AC with which to establish a CAPWAP session.
		The Discovery phase occurs when the WTP enters the optional Discovery state.
		A WTP does not need to complete the AC Discovery phase if
		it uses a pre-configured AC. This section
		details the mechanism used by a WTP to dynamically discover 
		candidate ACs.</t>

		<t>A WTP and an AC will frequently not reside in the same IP subnet
		(broadcast domain).  When this occurs, the WTP must be capable of
		discovering the AC, without requiring that multicast services are
		enabled in the network.</t>

		<t>When the WTP attempts to establish communication with an AC, it sends
		the Discovery Request message and receives the Discovery Response
		message from the AC(s).  The WTP MUST send the Discovery Request message
		to either the limited broadcast IP address
                (255.255.255.255), the well-known CAPWAP multicast address
                (224.0.1.140), or to the unicast IP address of the AC. For IPv6
		networks, since broadcast does not exist, the use of "All ACs multicast
		address" (FF0X:0:0:0:0:0:0:18C) is used instead. Upon
                receipt of the Discovery Request message,
		the AC sends a Discovery Response message to the unicast IP address of
		the WTP, regardless of whether the Discovery Request message was sent
		as a broadcast, multicast, or unicast message.</t>

	   <t>WTP use of a limited IP broadcast, multicast, or unicast IP address is
	   implementation dependent. ACs, on the other hand, MUST support broadcast,
	   multicast, and unicast discovery.</t>

	   <t>When a WTP transmits a Discovery Request message to a unicast
	   address, the WTP must first obtain the IP address of the AC. Any static
	   configuration of an AC's IP address on the WTP non-volatile storage is
	   implementation dependent. However, additional dynamic schemes are
	   possible, for example:</t>

	   <list style="hanging">
	         <t hangText="DHCP:">See <xref target="RFC5417"></xref>
			 for more information on the use of DHCP to discover AC IP
			 addresses.</t>

	         <t hangText="DNS:">The WTP MAY support use of DNS Service Records (SRVs) 
			 <xref target="RFC2782"></xref> to discover the AC address(es). 
			 In this case, the WTP first obtains (e.g., from local
			 configuration) the correct domain name suffix (e.g., "example.com")
			 and performs an SRV lookup with Service name "capwap-control" and
			 Proto "udp". Thus, the name resolved in DNS would be, e.g.,
			 "_capwap-control._udp.example.com".  Note that the SRV record MAY
			 specify a non-default port number for the control channel; the port
			 number for the data channel is the next port number (control
			 channel port + 1).</t>.
	   </list>

	   <t>An AC MAY also communicate alternative ACs to the WTP within the 
	   Discovery Response message through the AC IPv4 List (see
	   <xref target="AC-IPv4-List"></xref>) and AC IPv6 List (see
	   <xref target="AC-IPv4-List"></xref>). The addresses provided in these 
	   two message elements are intended to help the WTP discover additional
	   ACs through means other than those listed above.</t>

	   <t>The AC Name with Priority message element (see
	   <xref target="AC-Name-with-Priority"></xref>) is used to communicate a
	   list of preferred ACs to the WTP. The WTP SHOULD attempt to utilize the
	   ACs listed in the order provided by the AC. The Name-to-IP Address
	   mapping is handled via the Discovery message exchange, in which the ACs
	   provide their identity in the AC Name (see <xref target="AC-Name"/>)
	   message element in the Discovery Response message.</t>

	   <t>Once the WTP has received Discovery Response messages from the candidate ACs,
	   it MAY use other factors to determine the preferred AC. For
	   instance, each binding defines a WTP Radio Information message element
	   (see <xref target="Wireless Binding Definition"></xref>),  which the AC
	   includes in Discovery Response messages. The presence of one or more of
	   these message elements is used to identify the CAPWAP bindings
	   supported by the AC. A WTP MAY connect to an AC based on the
	   supported bindings advertised.</t>
	</section> <!-- AC Discovery -->

	<section anchor="Fragmentation-Reassembly" title="Fragmentation/Reassembly">
		<t>While fragmentation and reassembly services are provided by IP, the
		CAPWAP protocol also provides such services. Environments where the
		CAPWAP protocol is used involve firewall, NAT, and "middlebox" devices,
		which tend to drop IP fragments to minimize possible DoS attacks. By
		providing fragmentation and reassembly at the application layer, any
		fragmentation required due to the tunneling component of the CAPWAP
		protocol becomes transparent to these intermediate devices.
		Consequently, the CAPWAP protocol can be used in any network topology
		including firewall, NAT, and middlebox devices.</t>

		<t>It is important to note that the fragmentation mechanism employed by
		CAPWAP has known limitations and deficiencies, which are similar to
		those described in <xref target="RFC4963"/>. The limited size of the
		Fragment ID field (see <xref target="CAPWAP Header"/>) can cause wrapping
		of the field, and hence cause fragments from different datagrams to be
		incorrectly spliced together (known as "mis-associated"). For example, a
		100Mpbs link with an MTU of 1500 (causing fragmentation at 1450 bytes)
		would cause the Fragment ID field wrap in 8 seconds. Consequently,
		CAPWAP implementers are warned to properly size their buffers for
		reassembly purposes based on the expected wireless technology
		throughput.</t>

		<t>CAPWAP implementations SHOULD perform MTU Discovery (see <xref
		target="MTU Discovery"/>), which can avoid the need for fragmentation.
		At the time of writing of this specification, most enterprise switching
		and routing infrastructure were capable of supporting "mini-jumbo"
		frames (1800 bytes), which eliminates the need for fragmentation
		(assuming the station's MTU is 1500 bytes). The need for fragmentation
		typically continues to exist when the WTP communicates with the AC over
		a Wide Area Network (WAN). Therefore, future versions of the CAPWAP
		protocol SHOULD consider either increasing the size of the Fragment ID
		field or providing alternative extensions.</t>
    </section> <!-- Fragmentation/Reassembly -->

	<section anchor="MTU Discovery" title="MTU Discovery">
		<t>Once a WTP has discovered the AC with which it wishes to establish a CAPWAP
		session, it SHOULD perform a Path MTU (PMTU) discovery. One
		recommendation for performing PMTU discovery is to have the WTP 
		transmit Discovery Request (see <xref target="Discovery Request"></xref>)
		messages, and include the MTU Discovery Padding message element
		(see <xref target="MTU-Discovery-Padding"></xref>). The actual procedures
		used for PMTU discovery are described in  <xref target="RFC1191"></xref>
		for IPv4; for IPv6, <xref target="RFC1981"></xref> SHOULD be used.
		Alternatively, implementers MAY use the procedures defined in
		<xref target="RFC4821"></xref>. The WTP SHOULD also periodically
		re-evaluate the PMTU using the guidelines provided in these two RFCs,
		using the Primary Discovery Request (see <xref
		target="Primary Discovery Request"></xref>) along with the MTU
		Discovery Padding message element (see <xref
		target="MTU-Discovery-Padding"></xref>). When the MTU is initially
		known, or updated in the case where an existing session already exists,
		the discovered PMTU is used to configure the DTLS component (see <xref
		target="CAPWAP-to-DTLS-Commands"></xref>), while non-DTLS frames need to
		be fragmented to fit the MTU, defined in <xref
		target="Fragmentation-Reassembly"></xref>.</t>
	</section> <!-- CAPWAP MTU Discovery -->

	</section> <!-- CAPWAP Transport Layer -->

    <section title="CAPWAP Packet Formats">
        <t>This section contains the CAPWAP protocol packet formats. A CAPWAP
		protocol packet consists of one or more CAPWAP Transport Layer packet
		headers followed by a CAPWAP message. The CAPWAP message can be either of
		type Control or Data, where Control packets carry signaling, and Data
		packets carry user payloads. The CAPWAP frame formats for CAPWAP
		Data packets, and for DTLS encapsulated CAPWAP Data and Control
		packets are defined below. </t>

		<t>The CAPWAP Control protocol includes two messages that are never
		protected by DTLS: the Discovery Request message and the
		Discovery Response message. These messages need to be in the clear to
		allow the CAPWAP protocol to properly identify and process them. The
		format of these packets are as follows:</t>

<artwork>
    CAPWAP Control Packet (Discovery Request/Response):
    +-------------------------------------------+
    | IP  | UDP | CAPWAP | Control | Message    |
    | Hdr | Hdr | Header | Header  | Element(s) |
    +-------------------------------------------+
</artwork>

		<t>All other CAPWAP Control protocol messages MUST be protected via
		the DTLS protocol, which ensures that the packets are both authenticated
		and encrypted. These packets include the CAPWAP DTLS Header, which
		is described in <xref target="CAPWAP DTLS Header"></xref>. The format of
		these packets is as follows:</t>
<artwork>
    CAPWAP Control Packet (DTLS Security Required):
    +------------------------------------------------------------------+
    | IP  | UDP | CAPWAP   | DTLS | CAPWAP | Control| Message   | DTLS |
    | Hdr | Hdr | DTLS Hdr | Hdr  | Header | Header | Element(s)| Trlr |
    +------------------------------------------------------------------+
                           \---------- authenticated -----------/
                                  \------------- encrypted ------------/
</artwork>

		<t>The CAPWAP protocol allows optional protection of data packets,
		using DTLS. Use of data packet protection is determined by
		AC policy. When DTLS is utilized, the optional CAPWAP DTLS Header is
		present, which is described in <xref target="CAPWAP DTLS Header"></xref>.
		The format of CAPWAP Data packets is shown below:</t>

<artwork>
    CAPWAP Plain Text Data Packet :
    +-------------------------------+
    | IP  | UDP | CAPWAP | Wireless |
    | Hdr | Hdr | Header | Payload  |
    +-------------------------------+ 

    DTLS Secured CAPWAP Data Packet:
    +--------------------------------------------------------+
    | IP  | UDP |  CAPWAP  | DTLS | CAPWAP | Wireless | DTLS |
    | Hdr | Hdr | DTLS Hdr | Hdr  |  Hdr   | Payload  | Trlr |
    +--------------------------------------------------------+
                           \------ authenticated -----/
                                  \------- encrypted --------/
</artwork>

    <list style="hanging">
        <t hangText="UDP Header:">All CAPWAP packets are encapsulated within
		either UDP, or UDP-Lite when used over IPv6.
		<xref target="CAPWAP Transport"></xref> defines the specific UDP
		or UDP-Lite usage.</t>

        <t hangText="CAPWAP DTLS Header:">All DTLS encrypted CAPWAP protocol
		packets are prefixed with the CAPWAP DTLS Header (see 
		<xref target="CAPWAP DTLS Header"></xref>).</t>

        <t hangText="DTLS Header:">The DTLS Header provides authentication and
		encryption services to the CAPWAP payload it encapsulates. This protocol
		is defined in <xref target="RFC4347"></xref>.</t>

        <t hangText="CAPWAP Header:">All CAPWAP protocol packets use a common
		header that immediately follows the CAPWAP preamble or DTLS Header. The
		CAPWAP Header is defined in <xref target="CAPWAP Header"></xref>.</t>

        <t hangText="Wireless Payload:">A CAPWAP protocol packet that contains a wireless
        payload is a CAPWAP Data packet. The CAPWAP protocol does not specify
        the format of the wireless payload, which is defined by the
		appropriate wireless standard. Additional information is
		in <xref target="CAPWAP Data Messages"></xref>.</t>

        <t hangText="Control Header:">The CAPWAP protocol includes a signaling
		component, known as the CAPWAP Control protocol. All CAPWAP Control packets
		include a Control Header, which is defined in 
		<xref target="Control Message Format"></xref>.
		CAPWAP Data packets do not contain a Control Header field.</t>

        <t hangText="Message Elements:">A CAPWAP Control packet includes one
		or more message elements, which are found immediately following the
		Control Header. These message elements are in a Type/Length/Value style
		header, defined in <xref target="CAPWAP-Protocol-Message-Elements">
		</xref>.</t>
    </list>

	<t>A CAPWAP implementation MUST be capable of receiving a reassembled
	CAPWAP message of length 4096 bytes. A CAPWAP implementation MAY indicate
	that it supports a higher maximum message length, by including the Maximum
	Message Length message element, see <xref target="Maximum-Message-Length">
	</xref>, in the Join Request message or the Join Response message.</t>

	<section anchor="CAPWAP Preamble" title="CAPWAP Preamble">
	<t>The CAPWAP preamble is common to all CAPWAP transport headers and
	is used to identify the header type that immediately follows. The reason
	for this preamble is to avoid needing to perform byte comparisons in order
	to guess whether or not the frame is DTLS encrypted. It also provides an
	extensibility framework that can be used to support additional transport
	types. The format of the preamble is as follows:</t>
 
<artwork>
      0               
      0 1 2 3 4 5 6 7 
     +-+-+-+-+-+-+-+-+
     |Version| Type  |
     +-+-+-+-+-+-+-+-+
</artwork>

	<list style="hanging">
		<t hangText="Version:">A 4-bit field that contains the version of
		CAPWAP used in this packet. The value for this specification is zero (0).</t>

		<t hangText="Type:">A 4-bit field that specifies the payload
		type that follows the UDP header. The following values are
		supported:</t>

		<list style="hanging" hangIndent="6">
			<t hangText="0 -">CAPWAP Header. The CAPWAP Header (see
			<xref target="CAPWAP Header"></xref>) immediately follows the UDP
			header. If the packet is received on the
			CAPWAP Data channel, the CAPWAP stack MUST treat the packet as a
			clear text CAPWAP Data packet. If received on the CAPWAP Control
			channel, the CAPWAP stack MUST treat the packet as a clear text
			CAPWAP Control packet.  If the control packet is not a Discovery
			Request or Discovery Response packet, the packet MUST be dropped.</t>

			<t hangText="1 -">CAPWAP DTLS Header. The CAPWAP DTLS Header (and
			DTLS packet) immediately follows the UDP header (see
			<xref target="CAPWAP DTLS Header"></xref>).</t>
		</list>
	</list>
	</section>

	<section anchor="CAPWAP DTLS Header" title="CAPWAP DTLS Header">
	<t>The CAPWAP DTLS Header is used to identify the packet as a DTLS
	encrypted packet. The first eight bits include the common CAPWAP
	Preamble. The remaining 24 bits are padding to ensure 4-byte
	alignment, and MAY be used in a future version of the protocol. The DTLS
	packet <xref target="RFC4347"></xref> always immediately follows this header.
	The format of the CAPWAP DTLS Header is as follows:</t>

<artwork>
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |CAPWAP Preamble|                    Reserved                   |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

	<list style="hanging">
		<t hangText="CAPWAP Preamble:">The CAPWAP Preamble is defined in
		<xref target="CAPWAP Preamble"></xref>. The CAPWAP Preamble's
		Payload Type field MUST be set to one (1).</t>
 
		<t hangText="Reserved:">The 24-bit field is reserved for future use. All
		implementations complying with this protocol MUST set to zero any bits
		that are reserved in the version of the protocol supported by that
		implementation.  Receivers MUST ignore all bits not defined for the
		version of the protocol they support.</t>
	</list>
	</section>

	<section anchor="CAPWAP Header" title="CAPWAP Header">
	<t>All CAPWAP protocol messages are encapsulated using a common header
	format, regardless of the CAPWAP Control or CAPWAP Data transport
	used to carry the messages.  However, certain flags are not
	applicable for a given transport.  Refer to the specific transport
	section in order to determine which flags are valid.</t>

	<t>Note that the optional fields defined in this section MUST be present in
	the precise order shown below.</t> 
 
<artwork>
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |CAPWAP Preamble|  HLEN   |   RID   | WBID    |T|F|L|W|M|K|Flags|
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Fragment ID          |     Frag Offset         |Rsvd |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                 (optional) Radio MAC Address                  |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |            (optional) Wireless Specific Information           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                        Payload ....                           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

	<list style="hanging">
		<t hangText="CAPWAP Preamble:">The CAPWAP Preamble is defined in
		<xref target="CAPWAP Preamble"></xref>. The CAPWAP Preamble's
		Payload Type field MUST be set to zero (0). If the CAPWAP DTLS Header is
		present, the version number in both CAPWAP Preambles MUST match.
		The reason for this duplicate field is to avoid any possible tampering
		of the version field in the preamble that is not encrypted or
		authenticated.</t>

		<t hangText="HLEN:">A 5-bit field containing the length of the CAPWAP
		transport header in 4-byte words (similar to IP header length). This
		length includes the optional headers.</t>

		<t hangText="RID:">A 5-bit field that contains the Radio ID number for
		this packet, whose value is between one (1) and 31. Given that MAC
		Addresses are not necessarily unique across physical radios in a WTP,
		the Radio Identifier (RID) field is used to indicate with which physical
		radio the message is associated.</t>
 
		<t hangText="WBID:">A 5-bit field that is the wireless binding
		identifier.  The identifier will indicate the type of wireless packet
		associated with the radio. The following values are defined:</t>

		<list style="hanging">
			<t hangText="0 -">Reserved</t>
			<t hangText="1 -">IEEE 802.11</t>
			<t hangText="2 -">Reserved</t>
			<t hangText="3 -">EPCGlobal <xref target="EPCGlobal"></xref></t>
		</list>

	    <t hangText="T:">The Type 'T' bit indicates the format of the frame
		being transported in the payload.  When this bit is
		set to one (1), the payload has the native frame format indicated by
		the WBID field. When this bit is zero (0), the payload is an IEEE 802.3
		frame.</t> 

	    <t hangText="F:">The Fragment 'F' bit indicates whether this packet is
		a fragment. When this bit is one (1), the packet is a fragment and MUST
		be combined with the other corresponding fragments to reassemble the
		complete information exchanged between the WTP and AC.</t>
 
		<t hangText="L:">The Last 'L' bit is valid only if the 'F' bit is
		set and indicates whether the packet contains the last fragment of a
		fragmented exchange between WTP and AC.  When this bit is one (1), the
		packet is the last fragment.  When this bit is (zero) 0, the packet is not the
		last fragment.</t>

		<t hangText="W:">The Wireless 'W' bit is used to specify whether the
		optional Wireless Specific Information field is present in the header.
		A value of one (1) is used to represent the fact that the optional
		header is present.</t>

		<t hangText="M:">The Radio MAC 'M' bit is used to indicate that the Radio MAC
		Address optional header is present. This is used to communicate the MAC
		address of the receiving radio.</t>

		<t hangText="K:">The Keep-Alive 'K' bit indicates the packet is a Data 
		Channel Keep-Alive packet. This packet is used to map the data
		channel to the control channel for the specified Session ID and to
		maintain freshness of the data channel. The 'K' bit MUST NOT be set for
		data packets containing user data.</t>

		<t hangText="Flags:">A set of reserved bits for future flags in the 
		CAPWAP Header. All implementations complying with this protocol MUST set
		to zero any bits that are reserved in the version of the protocol
		supported by that implementation.  Receivers MUST ignore all bits not
		defined for the version of the protocol they support.</t>

		<t hangText="Fragment ID:">A 16-bit field whose value is assigned to
		each group of fragments making up a complete set.  The Fragment ID space is
		managed individually for each direction for every WTP/AC pair.  The
		value of Fragment ID is incremented with each new set of fragments.  The
		Fragment ID wraps to zero after the maximum value has been used to
		identify a set of fragments.</t>  

		<t hangText="Fragment Offset:">A 13-bit field that indicates where in the
		payload this fragment belongs during re-assembly. This field is
		valid when the 'F' bit is set to 1. The fragment offset is measured in
		units of 8 octets (64 bits). The first fragment has offset zero. Note that
		the CAPWAP protocol does not allow for overlapping fragments. </t> 

		<t hangText="Reserved:">The 3-bit field is reserved for future use. All
		implementations complying with this protocol MUST set to zero any bits
		that are reserved in the version of the protocol supported by that
		implementation.  Receivers MUST ignore all bits not defined for the
		version of the protocol they support.</t>

		<t hangText="Radio MAC Address:">This optional field contains the MAC
		address of the radio receiving the packet. Because the native wireless
		frame format to IEEE 802.3 format causes the MAC address of the WTP's
		radio to be lost, this field allows the address to be communicated to
		the AC. This field is only present if the 'M' bit is set. The HLEN field
		assumes 4-byte alignment, and this field MUST be padded with zeroes
		(0x00) if it is not 4-byte aligned.</t>

		<t>The field contains the basic format:</t>
<artwork>
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |     Length    |                  MAC Address
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

		<list style="hanging">
			<t hangText="Length:">The length of the MAC address
			field. The formats and lengths specified in <xref
			target="EUI-48"></xref> and <xref target="EUI-64"></xref> are
			supported.</t>

			<t hangText="MAC Address:">The MAC address of the receiving
			radio.</t>
		</list>

		<t hangText="Wireless Specific Information:">This optional field
		contains technology-specific information that may be used to carry per-packet wireless information. This field is only present if the 'W' bit
		is set. The WBID field in the CAPWAP Header is used to identify the
		format of the Wireless-Specific Information optional field. The HLEN
		field assumes 4-byte alignment, and this field MUST be padded with
		zeroes (0x00) if it is not 4-byte aligned.</t>

		<t>The Wireless-Specific Information field uses the following format:</t>
<artwork>
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |    Length     |                Data...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

	<list style="hanging">
		<t hangText="Length:">The 8-bit field contains the length of the data
        field, with a maximum size of 255.</t>

		<t hangText="Data:">Wireless-specific information, defined by the
		wireless-specific binding specified in the CAPWAP Header's WBID
		field.</t>
	</list>

		<t hangText="Payload:">This field contains the header for a CAPWAP Data
		Message or CAPWAP Control Message, followed by the data contained in
		the message.</t>
	</list>

     </section> <!-- CAPWAP Header -->

    <section anchor="CAPWAP Data Messages" title="CAPWAP Data Messages">
		<t>There are two different types of CAPWAP Data packets: CAPWAP Data Channel
		Keep-Alive packets and Data Payload packets. 
		The first is used by the WTP to synchronize the control
		and data channels and to maintain freshness of the data
		channel. The second is used to transmit user payloads between the 
		AC and WTP. This section describes both types of CAPWAP Data
		packet formats.</t>

		<t>Both CAPWAP Data messages are transmitted on the CAPWAP Data channel.</t>

    <section anchor="CAPWAP Data Channel Keepalive"
	   title="CAPWAP Data Channel Keep-Alive">
        <t>The CAPWAP Data Channel Keep-Alive packet is used to bind the CAPWAP
		control channel with the data channel, and to maintain freshness of the
		data channel, ensuring that the channel is still functioning. The CAPWAP
		Data Channel Keep-Alive packet is transmitted by the WTP when the
		DataChannelKeepAlive timer expires (see
		<xref target="DataChannelKeepAlive"></xref>). When the CAPWAP Data
		Channel Keep-Alive packet is transmitted, the WTP sets the
		DataChannelDeadInterval timer.</t>

		<t>In the CAPWAP Data Channel Keep-Alive packet, all of the fields in the 
		CAPWAP Header, except the HLEN field and the 'K'
		bit, are set to zero upon transmission. Upon receiving a CAPWAP Data Channel 
		Keep-Alive packet, the AC transmits a CAPWAP Data Channel Keep-Alive packet back to the
		WTP. The contents of the transmitted packet are identical to
		the contents of the received packet.</t>

		<t>Upon receiving a CAPWAP Data Channel Keep-Alive packet, the WTP cancels the 
		DataChannelDeadInterval timer and resets the DataChannelKeepAlive timer.
		The CAPWAP Data Channel Keep-Alive packet is retransmitted by the WTP in the same
		manner as the CAPWAP Control messages. If the DataChannelDeadInterval
		timer expires, the WTP tears down the control DTLS session,
		and the data DTLS session if one existed.</t>

		<t>The CAPWAP Data Channel Keep-Alive packet contains the following payload immediately
		following the CAPWAP Header (see <xref target="CAPWAP Header"></xref>).</t>:

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    Message Element Length     |  Message Element [0..N] ...
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

	<list style="hanging">
		<t hangText= "Message Element Length: ">
		The 16-bit Length field indicates the number of bytes following the
		CAPWAP Header, with a maximum size of 65535.</t>

		<t hangText= "Message Element[0..N]: ">
		The message element(s) carry the information pertinent to each of the 
		CAPWAP Data Channel Keep-Alive message. The following message elements MUST
		be present in this CAPWAP message:</t>
		<list style="hanging">
			<t>Session ID, see <xref target="Session ID"></xref>.</t>	
		</list>
	</list>

    </section> <!-- CAPWAP Data Channel Keep-Alive -->

    <section anchor="Station Data Payloads" title="Data Payload">
        <t>A CAPWAP protocol Data Payload packet encapsulates a forwarded wireless
		frame. The CAPWAP protocol defines two different modes of encapsulation:
		IEEE 802.3 and native wireless. IEEE 802.3 encapsulation requires that
		for 802.11 frames, the 802.11 *Integration* function be performed in the
		WTP. An IEEE 802.3-encapsulated user payload frame has the following
		format:</t>

<artwork>
    +------------------------------------------------------+
    | IP Header | UDP Header | CAPWAP Header | 802.3 Frame |
    +------------------------------------------------------+
</artwork>

		<t>The CAPWAP protocol also defines the native wireless encapsulation
		mode. The format of the encapsulated CAPWAP Data frame is subject
		to the rules defined by the specific wireless technology binding.
		Each wireless technology binding MUST contain a section
		entitled "Payload Encapsulation", which defines the format of the
		wireless payload that is encapsulated within CAPWAP Data packets.</t>

        <t>For 802.3 payload frames, the 802.3 frame is encapsulated (excluding
		the IEEE 802.3 Preamble, Start Frame Delimiter (SFD), and Frame Check
		Sequence (FCS) fields). If the encapsulated frame would exceed the
		transport layer's MTU, the sender is responsible for the fragmentation of
		the frame, as specified in <xref target="Fragmentation-Reassembly"/>.
		The CAPWAP protocol can support IEEE 802.3 frames whose length is
		defined in the IEEE 802.3as specification <xref target="FRAME-EXT"/>.</t>

    </section> <!-- Station Data Payloads -->

	<section anchor="Establishment of a DTLS Data Channel"
	title="Establishment of a DTLS Data Channel">
		<t>If the AC and WTP are configured to tunnel the data channel over
		DTLS, the proper DTLS session must be initiated.  To avoid having to
		reauthenticate and reauthorize an AC and WTP, the DTLS data channel
		SHOULD be initiated using the TLS session resumption feature
		<xref target="RFC5246"/>.</t>
 
		<t>The AC DTLS implementation MUST NOT initiate a data channel session
		for a DTLS session for which there is no active control
		channel session.</t>
    </section> <!-- Establishment of a DTLS Data Channel -->

    </section> <!-- CAPWAP Data Messages -->
        
    <section anchor="CAPWAP Control Messages Overview" title="CAPWAP Control Messages">
        <t>The CAPWAP Control protocol provides a control channel between
        the WTP and the AC. Control messages are divided into the following
		message types:</t>

        <list style="hanging">
	         <t hangText="Discovery:">CAPWAP Discovery messages are used to 
			 identify potential ACs, their load and capabilities.</t>

	         <t hangText="Join:">CAPWAP Join messages are used by a WTP to
			 request service from an AC, and for the AC to respond to the WTP.</t>
			 
	         <t hangText="Control Channel Management:">CAPWAP Control channel management messages are used 
	         to maintain the control channel.</t>			 
			 
	         <t hangText="WTP Configuration Management:">The WTP Configuration messages are used
			 by the AC to deliver a specific configuration to the WTP.
			 Messages that retrieve
			 statistics from a WTP are also included in WTP Configuration Management.</t>

	         <t hangText="Station Session Management:">Station Session Management
			 messages are used by the AC to deliver specific station policies to the
			 WTP.</t>

	         <t hangText="Device Management Operations:">Device management operations are used
			 to request and deliver a firmware image to the WTP.</t>
<!-- Mike Issue 100 -->
		<t hangText="Binding-Specific CAPWAP Management Messages:">Messages in this category are used
			by the AC and the WTP to exchange protocol-specific CAPWAP management messages. These
			messages may or may not be used to change the link state of a station.</t>
<!-- Mike Issue 100 -->
	</list>

	<t>Discovery, Join, Control Channel Management, WTP Configuration Management,
	and Station Session Management CAPWAP Control messages MUST be implemented.
	Device Management Operations messages MAY be implemented.</t>

	<t>CAPWAP Control messages sent from the WTP to the AC indicate that the WTP 
	is operational, providing an implicit keep-alive mechanism for the WTP. The
	Control Channel Management Echo Request and Echo Response messages provide
	an explicit keep-alive mechanism when other CAPWAP Control messages are not
	exchanged.</t>

    <section anchor="Control Message Format" title="Control Message Format">
        <t>All CAPWAP Control messages are sent encapsulated within the CAPWAP Header 
        (see <xref target="CAPWAP Header"></xref>). Immediately
		following the CAPWAP Header is the control header, which has the
		following format:</t>
<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                       Message Type                            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    Seq Num    |        Msg Element Length     |     Flags     |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Msg Element [0..N] ...
  +-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

<!-- Mike Issue 136 -->
    <section anchor="CAPWAP-Message-Type" title="Message Type">
		<t> The Message Type field identifies the function of the CAPWAP Control
		message.  To provide extensibility, the Message Type field is comprised
		of an IANA Enterprise Number <xref target="RFC3232"></xref> and an
		enterprise-specific message type number.  The first three octets contain
		the IANA Enterprise Number in network byte order, with zero used for
		CAPWAP base protocol (this specification) defined message types. The
		last octet is the enterprise-specific message type number, which has a
		range from 0 to 255.</t>

		<t>The Message Type field is defined as:</t>
		
<artwork>
      Message Type =
	      IANA Enterprise Number * 256 +
		  Enterprise Specific Message Type Number
</artwork>

		<t>The CAPWAP protocol reliability mechanism requires that messages be
		defined in pairs, consisting of both a Request and a Response message. 
		The Response message MUST acknowledge the Request message.
		The assignment of CAPWAP Control Message Type Values always occurs in
		pairs. All Request messages have odd
		numbered Message Type Values, and all Response messages have even
		numbered Message Type Values. The Request value MUST be assigned first.
		As an example, assigning a Message Type Value of 3 for a Request message
		and 4 for a Response message is valid, while assigning a Message
		Type Value of 4 for a Response message and 5 for the corresponding
		Request message is invalid.</t>

		<t>When a WTP or AC receives a message with a Message Type Value field that is
		not recognized and is an odd number, the number in the Message Type Value
		Field is incremented by one, and a Response message with a Message Type Value
		field containing the incremented value and containing the Result
		Code message element with the value (Unrecognized Request) is returned
		to the sender of the received message. If
		the unknown message type is even, the message is ignored.</t>

<!-- Mike Issue 136 -->
<t>The valid values for CAPWAP Control Message Types are specified in the table below:</t>

<artwork>
        CAPWAP Control Message           Message Type
                                           Value      
        Discovery Request                    1
        Discovery Response                   2
        Join Request                         3
        Join Response                        4
        Configuration Status Request         5
        Configuration Status Response        6
        Configuration Update Request         7
        Configuration Update Response        8
        WTP Event Request                    9
        WTP Event Response                  10
        Change State Event Request          11
        Change State Event Response         12
        Echo Request                        13
        Echo Response                       14
        Image Data Request                  15
        Image Data Response                 16
        Reset Request                       17
        Reset Response                      18
        Primary Discovery Request           19
        Primary Discovery Response          20
        Data Transfer Request               21
        Data Transfer Response              22
        Clear Configuration Request         23
        Clear Configuration Response        24
        Station Configuration Request       25
        Station Configuration Response      26
</artwork>

	</section> <!-- Message Type -->

    <section title="Sequence Number">
        <t>The Sequence Number field is an identifier value used to match 
        Request and Response packets.  When a CAPWAP packet with a Request 
        Message Type Value is received, the value of the Sequence Number field is 
        copied into the corresponding Response message.</t>

		<t>When a CAPWAP Control message is sent, the sender's internal sequence number
		counter is monotonically incremented, ensuring that no two pending Request messages
		have the same sequence number. The Sequence Number field wraps back to
		zero.</t>
    </section> <!-- Sequence Number -->

    <section title="Message Element Length">
        <t>The Length field indicates the number of bytes following the Sequence
		Number field. </t>
    </section> <!-- Message Element Length -->

    <section anchor="CAPWAP Control Flags" title="Flags">
        <t>The Flags field MUST be set to zero.</t>
    </section> <!-- Flags -->

    <section title="Message Element [0..N]">
        <t>The message element(s) carry the information pertinent to each of the 
        control message types.  Every control message in this specification
		specifies which message elements are permitted.</t>

		<t>When a WTP or AC receives a CAPWAP message without a message element
		that is specified as mandatory for the CAPWAP message, then the CAPWAP
		message is discarded. If the received message was a Request message for
		which the corresponding Response message carries message elements, then
		a corresponding Response message with a Result Code message element
		indicating "Failure - Missing Mandatory Message Element" is returned to
		the sender.</t>

		<t>When a WTP or AC receives a CAPWAP message with a message element
		that the WTP or AC does not recognize, the CAPWAP message is discarded.
		If the received message was a Request message for which the
		corresponding Response message carries message elements, then a
		corresponding Response message with a Result Code message element
		indicating "Failure - Unrecognized Message Element" and one or more
		Returned Message Element message elements is included, containing the
		unrecognized message element(s). </t>
	
    </section> <!-- Message Element[0..N] -->
    </section> <!-- Control Message Format -->

    <section title="Quality of Service">
		<t>The CAPWAP base protocol does not provide any Quality of Service
		(QoS) recommendations for use with the CAPWAP Data messages. Any
		wireless-specific CAPWAP binding specification that has QoS requirements
		MUST define the application of QoS to the CAPWAP Data messages.</t>

		<t>The IP header also includes the Explicit Congestion
		Notification (ECN) bits [RFC3168].  Section 9.1.1 of
		<xref target="RFC3168"/> describes two levels of ECN
		functionality: full functionality and limited functionality.
		CAPWAP ACs and WTPs SHALL implement the limited functionality
		and are RECOMMENDED to implement the full functionality
		described in <xref target="RFC3168"/>.</t>

    <section title="Applying QoS to CAPWAP Control Message">
        <t>It is recommended that CAPWAP Control messages be sent by both the
		AC and the WTP with an appropriate Quality-of-Service precedence
		value, ensuring that congestion in the network minimizes occurrences of
		CAPWAP Control channel disconnects. Therefore, a QoS-enabled CAPWAP device SHOULD use the following values:</t>

        <list style="hanging">
         <t hangText= "802.1Q: ">The priority tag of 7 SHOULD be used.</t>
         <t hangText= "DSCP: ">The CS6 per-hop behavior Service Class SHOULD be
		 used, which is described in <xref target="RFC2474"/>).</t>
		</list>

	</section> <!-- Applying QoS to CAPWAP Control Message -->
	</section> <!-- Quality of Service -->

	<section anchor="Retransmissions" title="Retransmissions">

<!--	<t>The CAPWAP control protocol operates as a reliable transport. For each
	Request message, a Response message is defined, which is used to acknowledge
	receipt of the Request message. In addition, the control header Sequence
	Number field is used to pair the Request and Response messages (see <xref
	target="Control Message Format"></xref>). This Request/Response pair,
	combined with the Sequence Number, implies that both the WTP and the AC can
	only have a single request outstanding at any given time.</t> -->

	<t>The CAPWAP Control protocol operates as a reliable transport.  For
	each Request message, a Response message is defined, which is used
	to acknowledge receipt of the Request message.  In addition, the
	control header Sequence Number field is used to pair the Request
	and Response messages  (see <xref target="Control Message Format"/>).</t>

<!--	<t>Response messages are not explicitly acknowledged, therefore
	if a Response message is not received, the original Request message is retransmitted.
	Implementations MAY cache Response messages to respond
	to a retransmitted Request messages with minimal local processing.
	Retransmitted Request messages MUST NOT be altered by the sender. The sender MUST assume
	that the original Request message was processed, but that the Response message was lost.
	Any alterations to the original Request message MUST have a new
	Sequence Number, and be treated as a new Request message by the receiver.</t> -->

	<t>Response messages are not explicitly acknowledged; therefore, if a
	Response message is not received, the original Request message is
	retransmitted.</t>

	<t>Implementations MUST keep track of the sequence number of the last
	received Request message, and MUST cache the corresponding Response
	message. If a retransmission with the same sequence number is received, the
	cached Response message MUST be retransmitted without re-processing the
	Request. If an older Request message is received, meaning one where the
	sequence number is smaller, it MUST be ignored. A newer Request message,
	meaning one whose sequence number is larger, is processed as usual.</t>

	<t>Note: A sequence number is considered "smaller" when s1 is smaller than
	s2 modulo 256 if and only if (s1&lt;s2 and (s2-s1)&lt;128) or
        (s1>s2&nbsp;and&nbsp;(s1-s2)>128).</t> 

	<t>Both the WTP and the AC can only have a single request outstanding
	at any given time. Retransmitted Request messages MUST NOT be altered by the
	sender.</t>

	<t>After transmitting a Request message, the RetransmitInterval (see
	<xref target="CAPWAP Protocol Timers"></xref>) timer and MaxRetransmit (see
	<xref target="CAPWAP Protocol Variables"></xref>) variable are used
	to determine if the original Request message needs to be
	retransmitted. The RetransmitInterval timer is used the first time the
	Request is retransmitted. The timer is then doubled every subsequent time
	the same Request message is retransmitted, up to MaxRetransmit but no more
	than half the EchoInterval timer (see <xref target="EchoInterval"></xref>).
	Response messages are not subject to these timers.</t>

	<t>If the sender stops retransmitting a Request message before reaching
	MaxRetransmit retransmissions (which leads to transition to DTLS Teardown,
	as described in <xref target="CAPWAP Protocol State Transitions"/>), it
	cannot know whether the recipient received and processed the Request or not.
	In most situations, the sender SHOULD NOT do this, and instead continue
	retransmitting until a Response message is received, or transition to DTLS
	Teardown occurs. However, if the sender does decide to continue the
	connection with a new or modified Request message, the new message MUST have
	a new sequence number, and be treated as a new Request message by the
	receiver. Note that there is a high chance that both the WTP and the AC's
	sequence numbers will become out of sync.</t>

	<t>When a Request message is retransmitted, it MUST be re-encrypted via the
	DTLS stack. If the peer had received the Request message, and the
	corresponding Response message was lost, it is necessary to ensure that
	retransmitted Request messages are not identified as replays by the DTLS
	stack. Similarly, any cached Response messages that are retransmitted as a
	result of receiving a retransmitted Request message MUST be re-encrypted via
	DTLS.</t>

	<t>Duplicate Response messages, identified by the Sequence Number field in
	the CAPWAP Control message header, SHOULD be discarded upon receipt.</t> 
	</section> <!-- Retransmissions -->

    </section> <!-- CAPWAP Control Messages Overview -->

    <section anchor="CAPWAP-Protocol-Message-Elements" title="CAPWAP Protocol Message Elements">
       <t>This section defines the CAPWAP Protocol message elements that are
	   included in CAPWAP protocol control messages.</t>

        <t>Message elements are used to carry information needed in control
		messages. Every message element is identified by the Type Value field,
		defined below. The total length of the message elements is indicated in
		the message element's length field.</t>

        <t>All of the message element definitions in this document use a diagram
        similar to the one below in order to depict its format. Note that to
		simplify this specification, these diagrams do not include the header
		fields (Type and Length). The header field values are defined in the
		message element descriptions.</t>

		<t>Unless otherwise specified, a control message that lists a set of
		supported (or expected) message elements MUST NOT expect the message
		elements to be in any specific order. The sender MAY include the message
		elements in any order. Unless otherwise noted, one message element of
		each type is present in a given control message.</t>

		<t>Unless otherwise specified, any configuration information sent by the
		AC to the WTP MAY be saved to non-volatile storage (see
		<xref target="Configuration Consistency"></xref>) for more
		information).</t>

		<t>Additional message elements may be defined in separate IETF
		documents.</t>

        <t>The format of a message element uses the TLV format shown
		here:</t>

<!-- Mike Issue 136 -->
<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |              Type             |             Length            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Value ...   |
  +-+-+-+-+-+-+-+-+
</artwork>

	<t> The 16-bit Type field identifies the information carried in the Value
	field and Length (16 bits) indicates the number of bytes in the Value field.
	The value of zero (0) is reserved and MUST NOT be used. The rest of the
	Type field values are allocated as follows: </t>

<artwork>
           Usage                              Type Values

CAPWAP Protocol Message Elements                   1 - 1023
IEEE 802.11 Message Elements                    1024 - 2047
Reserved for Future Use                         2048 - 3071
EPCGlobal Message Elements                      3072 - 4095
Reserved for Future Use                         4096 - 65535
</artwork>
<!-- Mike Issue 136 - Dorothy Comment - formula applies to message types, not message element types-->

<t> The table below lists the CAPWAP protocol Message Elements and their Type values.</t>

<artwork>
CAPWAP Message Element                            Type Value

AC Descriptor                                         1
AC IPv4 List                                          2
AC IPv6 List                                          3
AC Name                                               4
AC Name with Priority                                 5
AC Timestamp                                          6
Add MAC ACL Entry                                     7
Add Station                                           8
Reserved                                              9
CAPWAP Control IPV4 Address                          10
CAPWAP Control IPV6 Address                          11
CAPWAP Local IPV4 Address                            30
CAPWAP Local IPV6 Address                            50
CAPWAP Timers                                        12
CAPWAP Transport Protocol                            51
Data Transfer Data                                   13
Data Transfer Mode                                   14
Decryption Error Report                              15 
Decryption Error Report Period                       16
Delete MAC ACL Entry                                 17 
Delete Station                                       18
Reserved                                             19
Discovery Type                                       20 
Duplicate IPv4 Address                               21
Duplicate IPv6 Address                               22
ECN Support                                          53
Idle Timeout                                         23
Image Data                                           24
Image Identifier                                     25
Image Information                                    26
Initiate Download                                    27
Location Data                                        28
Maximum Message Length                               29
MTU Discovery Padding                                52
Radio Administrative State                           31
Radio Operational State                              32
Result Code                                          33
Returned Message Element                             34
Session ID                                           35
Statistics Timer                                     36 
Vendor Specific Payload                              37
WTP Board Data                                       38
WTP Descriptor                                       39
WTP Fallback                                         40
WTP Frame Tunnel Mode                                41
Reserved                                             42
Reserved                                             43
WTP MAC Type                                         44
WTP Name                                             45
Unused/Reserved                                      46
WTP Radio Statistics                                 47
WTP Reboot Statistics                                48
WTP Static IP Address Information                    49

</artwork>
<!-- REMOVED from above
Add Static MAC ACL Entry                              9
Delete Static MAC ACL Entry                          19
WTP IPv4 IP Address                                  42
WTP IPv6 IP Address                                  43
-->

	<section anchor="AC-Descriptor" title="AC Descriptor">
        <t>The AC Descriptor message element is used by the AC to communicate its 
        current state. The value contains the following fields.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |            Stations           |             Limit             |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |          Active WTPs          |            Max WTPs           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    Security   |  R-MAC Field  |   Reserved1   |  DTLS Policy  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                  AC Information Sub-Element...
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>
        <list style="hanging">
         <t hangText= "Type: ">
         1 for AC Descriptor</t>

         <t hangText= "Length: ">
         >= 12</t>

         <t hangText="Stations: ">
         The number of stations currently served by the AC</t>

         <t hangText="Limit: ">
         The maximum number of stations supported by the AC </t>

         <t hangText="Active WTPs: ">
         The number of WTPs currently attached to the AC </t>

         <t hangText="Max WTPs: ">
         The maximum number of WTPs supported by the AC</t>

		<t hangText="Security: ">
         An 8-bit mask specifying the authentication credential type supported by
		 the AC (see <xref
		 target="DTLS EndPoint Authentication and Authorization"></xref>). The
		 field has the following format:</t>
<artwork>
      0 1 2 3 4 5 6 7 
     +-+-+-+-+-+-+-+-+
     |Reserved |S|X|R|
     +-+-+-+-+-+-+-+-+
</artwork>
		<list style="hanging">
		 <t hangText="Reserved:">A set of reserved bits for future use. All
		 implementations complying with this protocol MUST set to zero any bits
		 that are reserved in the version of the protocol supported by that
		 implementation.  Receivers MUST ignore all bits not defined for the
		 version of the protocol they support.</t>
                 </list>

                 <list style="hanging" hangIndent="6">
         <t hangText= "S: "> The AC supports the pre-shared secret authentication, as
		 described in <xref target="Use-of-Preshared-Keys-in-CAPWAP"></xref>.</t>

         <t hangText= "X: "> The AC supports X.509 Certificate authentication,
		 as described in <xref target="Use-of-Certificates-in-CAPWAP"></xref>.</t>

         <t hangText= "R: "> A reserved bit for future use. All implementations
		 complying with this protocol MUST set to zero any bits that are
		 reserved in the version of the protocol supported by that
		 implementation.  Receivers MUST ignore all bits not defined for the
		 version of the protocol they support.</t>

		</list>

		 <t hangText="R-MAC Field: ">
         The AC supports the optional Radio MAC Address field in the CAPWAP
		 transport header (see <xref target="CAPWAP Header"></xref>). The
		 following enumerated values are supported:</t>
        <list style="hanging">
         <t hangText="0 -">  Reserved</t>
         <t hangText="1 -">  Supported</t>
         <t hangText="2 -">  Not Supported</t>
		 </list>

		 <t hangText="Reserved:">A set of reserved bits for future use. All
		 implementations complying with this protocol MUST set to zero any bits
		 that are reserved in the version of the protocol supported by that
		 implementation.  Receivers MUST ignore all bits not defined for the
		 version of the protocol they support.</t>

         <t hangText="DTLS Policy: ">
		 The AC communicates its policy on the use of DTLS for the CAPWAP
		 data channel. The AC MAY communicate more than one supported option,
		 represented by the bit field below. The WTP MUST abide by one of the
		 options communicated by AC. The field has the following format:</t>
<artwork>
      0 1 2 3 4 5 6 7 
     +-+-+-+-+-+-+-+-+
     |Reserved |D|C|R|
     +-+-+-+-+-+-+-+-+
</artwork>
		<list style="hanging">
		 <t hangText="Reserved:">A set of reserved bits for future use. All
		 implementations complying with this protocol MUST set to zero any bits
		 that are reserved in the version of the protocol supported by that
		 implementation.  Receivers MUST ignore all bits not defined for the
		 version of the protocol they support.</t>
                 </list>

                 <list style="hanging" hangIndent="6">
         <t hangText= "D: "> DTLS-Enabled Data Channel Supported</t>

         <t hangText= "C: "> Clear Text Data Channel Supported</t>

         <t hangText= "R: "> A reserved bit for future use. All implementations
		 complying with this protocol MUST set to zero any bits that are
		 reserved in the version of the protocol supported by that
		 implementation.  Receivers MUST ignore all bits not defined for the
		 version of the protocol they support.</t>
		</list>

         <t hangText="AC Information Sub-Element: ">
         The AC Descriptor message element contains multiple AC Information
		 sub-elements, and defines two sub-types, each of which MUST be present.
		 The AC Information sub-element has the following format:</t>

<list style="hanging">
<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                AC Information Vendor Identifier               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      AC Information Type      |     AC Information Length     |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                     AC Information Data...
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

         <t hangText="AC Information Vendor Identifier: ">
         A 32-bit value containing the IANA-assigned "Structure of Management Information (SMI) Network
         Management Private Enterprise Codes".</t>

         <t hangText="AC Information Type: ">
         Vendor-specific encoding of AC information in the UTF-8 format <xref
		 target="RFC3629"/>. The following enumerated values are supported. Both
		 the Hardware and Software Version sub-elements MUST be included in the
		 AC Descriptor message element. The values listed below are used in
		 conjunction with the AC Information Vendor Identifier field, whose
		 value MUST be set to zero (0). This field, combined with the AC
		 Information Vendor Identifier set to a non-zero (0) value, allows
		 vendors to use a private namespace.</t>

		 <list style="hanging" hangIndent="6">
		 <t hangText="4 -">
		 Hardware Version: The AC's hardware version number.</t>
		 <t hangText="5 -">
		 Software Version: The AC's Software (firmware) version number.</t>
		 </list>

         <t hangText="AC Information Length: ">
         Length of vendor-specific encoding of AC information, with a maximum
		 size of 1024.</t>

         <t hangText="AC Information Data: ">
         Vendor-specific encoding of AC information.</t>
	</list>
		 </list>
    </section> <!-- AC Descriptor -->

  <section anchor="AC-IPv4-List" title="AC IPv4 List">
        <t>The AC IPv4 List message element is used to configure a WTP with the
		latest list of ACs available for the WTP to join.</t>
<artwork>

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                       AC IP Address[]                         |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>
<list style="hanging">
         <t hangText= "Type: ">
         2 for AC IPv4 List</t>

         <t hangText= "Length: ">
         >= 4</t>

         <t hangText= "AC IP Address: ">An array of 32-bit integers
		 containing AC IPv4 Addresses, containing no more than 1024
		 addresses.</t>
</list>

</section> <!-- AC IPv4 List -->
    <section anchor="AC-IPv6-List" title="AC IPv6 List">
		<t>The AC IPv6 List message element is used to configure a WTP with the
		latest list of ACs  available for the WTP to join. </t>
   
<artwork>

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                       AC IP Address[]                         |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                       AC IP Address[]                         |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                       AC IP Address[]                         |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                       AC IP Address[]                         |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</artwork>

<list style="hanging">
         <t hangText= "Type: ">
         3 for AC IPV6 List</t>

         <t hangText= "Length: ">
         >= 16</t>

         <t hangText= "AC IP Address: ">An array of 128-bit integers
		 containing AC IPv6 Addresses, containing no more than 1024
		 addresses.</t>
</list>
    </section> <!-- AC IPv6 List -->

    <section anchor="AC-Name" title="AC Name">
        <t>The AC Name message element contains an UTF-8 <xref
		target="RFC3629"></xref> representation of the AC identity. The value is
		a variable-length byte string.  The string is NOT zero terminated.</t>

<artwork>
   0               
   0 1 2 3 4 5 6 7 
  +-+-+-+-+-+-+-+-+
  |   Name ...
  +-+-+-+-+-+-+-+-+
</artwork>

		 <list style="hanging">
         <t hangText= "Type: ">
         4 for AC Name</t>

         <t hangText= "Length: ">
         >= 1</t>

         <t hangText="Name: ">
         A variable-length UTF-8 encoded string <xref target="RFC3629"></xref> 
		 containing the AC's name, whose maximum size MUST NOT exceed 512
		 bytes.</t>
        </list>

    </section> <!-- AC Name -->
    
	<section anchor="AC-Name-with-Priority" title="AC Name with Priority">
		<t>The AC Name with Priority message element is sent by the AC to the WTP
		to configure preferred ACs. The number of instances of this message
		element is equal to the number of ACs configured on the WTP. The WTP
		also uses this message element to send its configuration to the AC.</t>

<artwork>
   0                   1
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Priority  |   AC Name...  
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         5 for AC Name with Priority</t>

         <t hangText= "Length: ">
         >= 2</t>

         <t hangText="Priority: ">
         A value between 1 and 255 specifying the priority order of the
		 preferred AC. For instance, the value of one (1) is used to set the
		 primary AC, the value of two (2) is used to set the secondary, etc.</t>

         <t hangText="AC Name: ">
         A variable-length UTF-8 encoded string <xref target="RFC3629"></xref> 
		 containing the AC name, whose maximum size MUST NOT exceed 512 bytes.</t>

        </list>
    </section> <!-- AC Name with Priority -->
    
     <section anchor="AC-Timestamp" title="AC Timestamp">
        <t>The AC Timestamp message element is sent by the
        AC to synchronize the WTP clock.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           Timestamp                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         6 for AC Timestamp</t>

         <t hangText= "Length: ">
         4</t>

        <t hangText="Timestamp: ">
         The AC's current time, allowing all of the WTPs to be time
		 synchronized in the format defined by Network Time Protocol (NTP) in
		 <xref target="RFC1305">RFC 1305</xref>. Only the most significant 32
		 bits of the NTP time are included in this field.</t>

        </list>
    </section> <!-- AC Timestamp -->
    
      <section anchor="Add-MAC-ACL-Entry"  title="Add MAC ACL Entry">
        <t>The Add MAC Access Control List (ACL) Entry message element is used
		by an AC to add a MAC ACL list entry on a WTP, ensuring that the WTP no
		longer provides service to the MAC addresses provided in the message.
		The MAC addresses provided in this message element are not expected to
		be saved in non-volatile memory on the WTP. The MAC ACL table on the WTP
		is cleared every time the WTP establishes a new session with an AC.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Num of Entries|    Length     |         MAC Address ...        
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

	<list style="hanging">
		<t hangText= "Type: ">
		7 for Add MAC ACL Entry</t>

		<t hangText= "Length: ">
		>= 8</t>

		<t hangText="Num of Entries: ">
		The number of instances of the Length/MAC Address fields in the array.
		This value MUST NOT exceed 255.</t>

        <t hangText="Length:">The length of the MAC Address
			field. The formats and lengths specified in <xref
			target="EUI-48"></xref> and <xref target="EUI-64"></xref> are
			supported.</t>

		<t hangText="MAC Address: ">
		MAC addresses to add to the ACL.</t>

        </list>
    </section> <!-- Add MAC ACL Entry -->
    
      <section anchor="Add-Station-Station" title="Add Station">
	<t>The Add Station message element is used by the AC to inform a WTP that it 
	should forward traffic for a station. The Add Station
	message element is accompanied by technology-specific binding 
	information element(s), which may include security parameters. Consequently,
	the security parameters MUST be applied by the WTP for the
	station.</t>

	<t>After station policy has been delivered to the WTP through the Add Station
	message element, an AC MAY change any policies by sending a
	modified Add Station message element. When a WTP receives an Add Station
	message element for an existing station, it MUST override any
	existing state for the station. </t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    Radio ID   |     Length    |          MAC Address ...       
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |  VLAN Name...  
  +-+-+-+-+-+-+-+-+
</artwork>

	<list style="hanging">
		<t hangText= "Type: ">
		8 for Add Station</t>

		<t hangText= "Length: ">
		>= 8</t>

		<t hangText="Radio ID: ">
		An 8-bit value representing the radio, whose value is between one (1)
		and 31.</t>

        <t hangText="Length:">The length of the MAC Address
			field. The formats and lengths specified in <xref
			target="EUI-48"></xref> and <xref target="EUI-64"></xref> are
			supported.</t>

		<t hangText="MAC Address: ">
		The station's MAC address.</t>

		<t hangText="VLAN Name: ">
        An optional variable-length UTF-8 encoded string <xref target="RFC3629">
		</xref>, with a maximum length of 512 octets, containing the VLAN Name
		on which the WTP is to locally bridge user data. Note this field is only
		valid with WTPs configured in Local MAC mode.</t>
	</list>
    </section> <!-- Add Station message element -->

<!--
     <section anchor="Add-Static-MAC-ACL-Entry" title="Add Static MAC ACL Entry">
        <t>The Add Static MAC ACL Entry message element is used by an AC to add a
        permanent ACL entry on a WTP, ensuring that the WTP no longer provides any
        service to the MAC addresses provided in the message.  The MAC Addresses
		provided in this message element are expected to be saved in
		non-volatile memory on the WTP.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Num of Entries|     Length    |          MAC Address ...       
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

	<list style="hanging">
		<t hangText= "Type: ">
		9 for Add Static MAC ACL Entry</t>

		<t hangText= "Length: ">
		>= 8</t>

		<t hangText="Num of Entries: ">
		The number of instances of the Length/MAC Addresses fields in the array.
		This value MUST NOT exceed 255.</t>

        <t hangText="Length:">The length of the MAC Address
        field. The following formats, and lengths, are supported
        <xref target="EUI-48"></xref> and <xref target="EUI-64"></xref>.</t>

		<t hangText="MAC Address: ">
		MAC Addresses to add to the permanent ACL.</t>

	</list>
    </section> --> <!-- Add Static MAC ACL Entry -->

   <section anchor="CAPWAP-Control-IPv4-Address" title="CAPWAP Control IPv4 Address">
        <t>The CAPWAP Control IPv4 Address message element is sent by the
        AC to the WTP during the Discovery process and is used by the AC to
		provide the interfaces available on the AC, and the current number of
		WTPs connected. When multiple CAPWAP Control IPV4 Address
		message elements are returned, the WTP SHOULD perform load
		balancing across the multiple interfaces (see <xref
		target="Join Request"/>).</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           IP Address                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |           WTP Count           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

      <list style="hanging">
         <t hangText= "Type: ">
         10 for CAPWAP Control IPv4 Address</t>

         <t hangText= "Length: ">
         6</t>

         <t hangText="IP Address: ">
         The IP address of an interface.</t>

         <t hangText="WTP Count: ">
         The number of WTPs currently connected to the interface, with a
		 maximum value of 65535.</t>

        </list>
    </section> <!-- CAPWAP Control IPv4 Address -->

    <section anchor="CAPWAP-Control-IPv6-Address" title="CAPWAP Control IPv6 Address">
        <t>The CAPWAP Control IPv6 Address message element is sent by the
        AC to the WTP during the Discovery process and is used by the AC to
		provide the interfaces available on the AC, and the current number of 
		WTPs connected. This message element is useful for the WTP to perform 
		load balancing across multiple interfaces (see <xref
		target="Join Request"/>).</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           IP Address                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           IP Address                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           IP Address                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           IP Address                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |           WTP Count           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

      <list style="hanging">
         <t hangText= "Type: ">
         11 for CAPWAP Control IPv6 Address</t>

         <t hangText= "Length: ">
         18</t>

         <t hangText="IP Address: ">
         The IP address of an interface.</t>

         <t hangText="WTP Count: ">
         The number of WTPs currently connected to the interface, with a
		 maximum value of 65535.</t>

        </list>
    </section> <!-- CAPWAP Control IPv6 Address -->

   <section anchor="CAPWAP-Local-IPv4-Address" title="CAPWAP Local IPv4 Address">
        <t>The CAPWAP Local IPv4 Address message element is sent by either the
		WTP, in the Join Request, or by the AC, in the Join Response. The CAPWAP
		Local IPv4 Address message element is used to communicate the IP
		Address of the transmitter. The receiver uses this to determine whether
		a middlebox exists between the two peers, by comparing the source IP
		address of the packet against the value of the message element.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           IP Address                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

      <list style="hanging">
         <t hangText= "Type: ">
         30 for CAPWAP Local IPv4 Address</t>

         <t hangText= "Length: ">
         4</t>

         <t hangText="IP Address: ">
         The IP address of the sender.</t>

        </list>
    </section> <!-- CAPWAP Local IPv4 Address -->

   <section anchor="CAPWAP-Local-IPv6-Address" title="CAPWAP Local IPv6 Address">
        <t>The CAPWAP Local IPv6 Address message element is sent by either the
		WTP, in the Join Request, or by the AC, in the Join Response. The CAPWAP
		Local IPv6 Address message element is used to communicate the IP
		Address of the transmitter. The receiver uses this to determine whether
		a middlebox exists between the two peers, by comparing the source IP
		address of the packet against the value of the message element.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           IP Address                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           IP Address                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           IP Address                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           IP Address                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

      <list style="hanging">
         <t hangText= "Type: ">
         50 for CAPWAP Local IPv6 Address</t>

         <t hangText= "Length: ">
         16</t>

         <t hangText="IP Address: ">
         The IP address of the sender.</t>

        </list>
    </section> <!-- CAPWAP Local IPv6 Address -->

	<section anchor="CAPWAP-Timers" title="CAPWAP Timers">
        <t>The CAPWAP Timers message element is used by an AC to configure CAPWAP
        timers on a WTP.</t>

<artwork>
   0                   1           
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Discovery   | Echo Request  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         12 for CAPWAP Timers</t>

         <t hangText= "Length: ">
         2</t>

         <t hangText="Discovery: ">
         The number of seconds between CAPWAP Discovery messages, when the WTP
		 is in the Discovery phase. This value is used to configure the
		 MaxDiscoveryInterval timer (see
		 <xref target="MaxDiscoveryInterval"></xref>).</t>

         <t hangText="Echo Request: ">
         The number of seconds between WTP Echo Request CAPWAP messages. This
		 value is used to configure the EchoInterval timer (see 
		 <xref target="EchoInterval"></xref>). The AC sets its EchoInterval
		 timer to this value, plus the maximum retransmission time as 
		 described in <xref target="Retransmissions"></xref>.</t>

        </list>
    </section> <!-- CAPWAP Timers -->

	<section anchor="CAPWAP Transport Protocol" title="CAPWAP Transport Protocol">
        <t>When CAPWAP is run over IPv6, the UDP-Lite or UDP transports MAY be
		used (see <xref target="CAPWAP Transport"></xref>). The CAPWAP IPv6
		Transport Protocol message element is used by either the WTP or the
		AC to signal which transport protocol is to be used for the CAPWAP
		data channel.</t>

		<t>Upon receiving the Join Request, the AC MAY set the CAPWAP
		Transport Protocol to UDP-Lite in the Join Response message if the
		CAPWAP message was received over IPv6, and the CAPWAP Local IPv6 Address
		message element (see <xref target="CAPWAP-Local-IPv6-Address"></xref>)
		is present and no middlebox was detected (see <xref
		target="NAT Considerations"></xref>).</t>

		<t>Upon receiving the Join Response, the WTP MAY set the CAPWAP
		Transport Protocol to UDP-Lite in the Configuration Status Request or
		Image Data Request message if the AC advertised support for UDP-Lite,
		the message was received over IPv6, the CAPWAP Local IPv6 Address message
		element (see <xref target="CAPWAP-Local-IPv6-Address"></xref>) and
		no middlebox was detected (see <xref
		target="NAT Considerations"></xref>). Upon receiving either the
		Configuration Status Request or the Image Data Request, the AC MUST
		observe the preference indicated by the WTP in the CAPWAP Transport
		Protocol, as long as it is consistent with what the AC advertised in the
		Join Response.</t>

		<t>For any other condition, the CAPWAP Transport Protocol MUST be set to
		UDP.</t>

<artwork>
   0
   0 1 2 3 4 5 6 7 
  +-+-+-+-+-+-+-+-+
  |   Transport   |
  +-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         51 for CAPWAP Transport Protocol</t>

         <t hangText= "Length: ">
         1</t>

         <t hangText="Transport: ">
         The transport to use for the CAPWAP Data channel. The following 
		 enumerated values are supported:</t>

		 <list style="hanging" hangIndent="6">
         <t hangText="1 -">  UDP-Lite:
		 The UDP-Lite transport protocol is to be used for the CAPWAP Data
		 channel. Note that this option MUST NOT be used if the CAPWAP Control
		 channel is being used over IPv4.</t>
         <t hangText="2 -">  UDP:
		 The UDP transport protocol is to be used for the CAPWAP Data channel.</t>
		 </list>

        </list>
    </section> <!-- CAPWAP Transport Protocol -->

    <section anchor="Data-Transfer-Data" title="Data Transfer Data">
        <t>The Data Transfer Data message element is used by the WTP to provide
        information to the AC for debugging purposes.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Data Type   |   Data Mode   |         Data Length           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Data ....
  +-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         13 for Data Transfer Data</t>

         <t hangText= "Length: ">
         >= 5</t>

         <t hangText="Data Type: ">
         An 8-bit value representing the transfer Data Type. The following 
         enumerated values are supported:</t>
         <list style="hanging">
         <t hangText="1 -"> Transfer data is included.</t>
         <t hangText="2 -"> Last Transfer Data Block is included (End of File (EOF)).</t>
         <t hangText="5 -"> An error occurred. Transfer is aborted.</t>
		 </list>

         <t hangText="Data Mode: ">
         An 8-bit value describing the type of information being transmitted. The following
		 enumerated values are supported:
</t>
        <list style="hanging">
         <t hangText="0 -">  Reserved</t>
         <t hangText="1 -">  WTP Crash Data</t>
         <t hangText="2 -">  WTP Memory Dump</t>
        </list>

         <t hangText="Data Length: ">
         Length of data field, with a maximum size of 65535.</t>

         <t hangText="Data: ">
         Data being transferred from the WTP to the AC, whose type is identified
		 via the Data Mode field.</t>

        </list>
    </section> <!-- Data Transfer Data -->
    
     <section anchor="Data-Transfer-Mode" title="Data Transfer Mode">
<!-- Mike: Issue 133 -->
     <t>The Data Transfer Mode message element is used by the WTP to indicate 
     the type of data transfer information it is sending to the AC for debugging purposes.</t>
<!-- Mike: Issue 133 -->

<artwork>
   0               
   0 1 2 3 4 5 6 7 
  +-+-+-+-+-+-+-+-+
  |   Data Mode   |
  +-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         14 for Data Transfer Mode</t>

         <t hangText= "Length: ">
         1</t>

         <t hangText="Data Mode: ">
         An 8-bit value describing the type of information being requested. The following
		 enumerated values are supported:</t>
        <list style="hanging">
         <t hangText="0 -">  Reserved</t>
         <t hangText="1 -">  WTP Crash Data</t>
         <t hangText="2 -">  WTP Memory Dump</t>
        </list>

        </list>
    </section> <!-- Data Transfer Mode -->
    
    <section anchor="Decryption-Error-Report" title="Decryption Error Report">
        <t>The Decryption Error Report message element value is used by 
        the WTP to inform the AC of decryption errors that have occurred since
		the last report. Note that this error reporting mechanism is not
		used if encryption and decryption services are provided in the AC.</t>

<artwork>
   0                   1                   2       
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Radio ID    |Num Of Entries |     Length    | MAC Address... 
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

	<list style="hanging">
		<t hangText= "Type: ">
		15 for Decryption Error Report</t>

		<t hangText= "Length: ">
		>= 9</t>

		<t hangText="Radio ID: ">
		The Radio Identifier refers to an interface index on the
		WTP, whose value is between one (1) and 31.</t>

		<t hangText="Num of Entries: ">
		The number of instances of the Length/MAC Address fields in the array.
		This field MUST NOT exceed the value of 255.</t>

        <t hangText="Length:">The length of the MAC Address
			field. The formats and lengths specified in <xref
			target="EUI-48"></xref> and <xref target="EUI-64"></xref> are
			supported.</t>

		<t hangText="MAC Address: ">
		MAC address of the station that has caused decryption errors.</t>

		</list>
    </section> <!-- Decryption Error Report -->
    
    <section anchor="Decryption-Error-Report-Period" title="Decryption Error Report Period">
		<t>The Decryption Error Report Period message element value is used by 
		the AC to inform the WTP how frequently it should send decryption error
		report messages. Note that this error reporting mechanism is not
		used if encryption and decryption services are provided in the AC.</t>

<artwork>
   0                   1                   2       
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Radio ID    |        Report Interval        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         16 for Decryption Error Report Period</t>

         <t hangText= "Length: ">
         3</t>

		<t hangText="Radio ID: ">
		The Radio Identifier refers to an interface index on the
		WTP, whose value is between one (1) and 31.</t>

         <t hangText="Report Interval: ">
         A 16-bit unsigned integer indicating the time, in seconds. The default
		 value for this message element can be found in
		 <xref target="ReportInterval"></xref>.</t>
		</list>
    </section> <!-- Decryption Error Report Period -->

    <section anchor="Delete-MAC-ACL-Entry" title="Delete MAC ACL Entry">
        <t>The Delete MAC ACL Entry message element is used by an AC to delete
		a MAC ACL entry on a WTP, ensuring that the WTP provides
        service to the MAC addresses provided in the message.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Num of Entries|     Length    |          MAC Address ...       
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

	<list style="hanging">
		<t hangText= "Type: ">
		17 for Delete MAC ACL Entry</t>

		<t hangText= "Length: ">
		>= 8</t>

		<t hangText="Num of Entries: ">
		The number of instances of the Length/MAC Address fields in the array.
		This field MUST NOT exceed the value of 255.</t>

        <t hangText="Length:">The length of the MAC Address
			field. The formats and lengths specified in <xref
			target="EUI-48"></xref> and <xref target="EUI-64"></xref> are
			supported.</t>

		<t hangText="MAC Address: ">
		An array of MAC addresses to delete from the ACL.</t>

        </list>
    </section> <!-- Delete MAC ACL Entry -->

	<section anchor="Delete-Station-Station" title="Delete Station ">
		<t>The Delete Station message element is used by the AC to inform a
		WTP that it should no longer provide service to a particular station.
		The WTP MUST terminate service to the station immediately upon receiving
		this message element.</t>

		<t>The transmission of a Delete Station message element could occur for
		various reasons, including for administrative reasons, or if
		the station has roamed to another WTP.</t>

<!-- PRC: Added after sending Michael the latest spec -->
		<t>The Delete Station message element MAY be sent by the WTP, in
		the WTP Event Request message, to inform the AC that a particular station is no
		longer being provided service. This could occur as a result of an Idle
		Timeout (see section 4.4.43), due to internal resource shortages or for
		some other reason.</t>

<!--
The following text has been removed, but is crucial. I am including it here as
a reference to make sure that it is covered in the 802.11 bindings spec:
		<t>Once access has been terminated for a given station, any future
        packets received from the STA must result in a deauthenticate
        message, as specified in <xref target="IEEE.802-11.1999"></xref>.</t>
-->

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    Radio ID   |     Length    |        MAC Address... 
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         18 for Delete Station</t>

         <t hangText= "Length: ">
         >= 8</t>

         <t hangText="Radio ID: ">
         An 8-bit value representing the radio, whose value is between one (1)
		 and 31.</t>

        <t hangText="Length:">The length of the MAC Address
			field. The formats and lengths specified in <xref
			target="EUI-48"></xref> and <xref target="EUI-64"></xref> are
			supported.</t>

         <t hangText="MAC Address: ">
         The station's MAC address.</t>
        </list>
    </section> <!-- Delete Station -->
    
<!--
     <section anchor="Delete-Static-MAC-ACL-Entry" title="Delete Static MAC ACL Entry">
        <t>The Delete Static MAC ACL Entry message element is used by an AC to delete a
        previously added static MAC ACL entry on a WTP, ensuring that the WTP provides
        service to the MAC addresses provided in the message.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Num of Entries|     Length    |         MAC Address ...        
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

	<list style="hanging">
		<t hangText= "Type: ">
		19 for Delete Static MAC ACL Entry</t>

		<t hangText= "Length: ">
		>= 8</t>

		<t hangText="Num of Entries: ">
		The number of instances of the Length/MAC Addresses fields in the array.
		This field MUST NOT exceed the value of 1024.</t>

        <t hangText="Length:">The length of the MAC Address
        field. The following formats, and lengths, are supported
        <xref target="EUI-48"></xref> and <xref target="EUI-64"></xref>.</t>

		<t hangText="MAC Address: ">
		An array of MAC Addresses to delete from the static MAC ACL entry.</t>

	</list>
    </section> --> <!-- Delete Static MAC ACL Entry -->
    
<section anchor="Discovery-Type" title="Discovery Type">
		<t>The Discovery Type message element is used by the WTP to indicate how
		it has come to know about the existence of the AC to which it is sending
		the Discovery Request message.</t>

<artwork>
   0               
   0 1 2 3 4 5 6 7 
  +-+-+-+-+-+-+-+-+
  | Discovery Type|
  +-+-+-+-+-+-+-+-+
</artwork>

         <list style="hanging">
         <t hangText= "Type: ">
         20 for Discovery Type</t>

         <t hangText= "Length: ">
         1</t>

         <t hangText="Discovery Type: ">
         An 8-bit value indicating how the WTP discovered the AC. The following
		 enumerated values are supported:</t>
        <list style="hanging" hangIndent="6">
         <t hangText="0 -">  Unknown</t>
         <t hangText="1 -">  Static Configuration</t>
         <t hangText="2 -">  DHCP</t>
         <t hangText="3 -">  DNS</t>
         <t hangText="4 -">  AC Referral (used when the AC was
		 configured either through the AC IPv4 List or AC IPv6 List message
		 element)</t>
        </list>

        </list>
    </section> <!-- Discovery Type -->
    
     <section anchor="Duplicate-IPv4-Address" title="Duplicate IPv4 Address">
        <t>The Duplicate IPv4 Address message element is used by a WTP to inform
        an AC that it has detected another IP device using the same IP address that the WTP 
        is currently using.</t>

		<!= ISSUE 194 > 
		<t> The WTP MUST transmit this message element with the status set to 1 
		after it has detected a duplicate IP address. When the WTP detects that the
		duplicate IP address has been cleared, it MUST send this message element
		with the status set to 0.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                          IP Address                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |     Status    |     Length    |          MAC Address ...       
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

	<list style="hanging">
		<t hangText= "Type: ">
		21 for Duplicate IPv4 Address</t>

		<t hangText= "Length: ">
		>= 12</t>

		<t hangText="IP Address: ">
		The IP address currently used by the WTP.</t>

		<t hangText="Status: ">
		The status of the duplicate IP address. The value MUST be set to 1
		when a duplicate address is detected, and 0 when the duplicate address
		has been cleared.</t>

        <t hangText="Length:">The length of the MAC Address
			field. The formats and lengths specified in <xref
			target="EUI-48"></xref> and <xref target="EUI-64"></xref> are
			supported.</t>

		<t hangText="MAC Address: ">
		The MAC address of the offending device.</t>
	</list>
	<!= /ISSUE 194 >
    </section> <!-- Duplicate IPv4 Address -->

    <section anchor="Duplicate-IPv6-Address" title="Duplicate IPv6 Address">
        <t>The Duplicate IPv6 Address message element is used by a WTP to inform
        an AC that it has detected another host using the same IP address that the WTP
        is currently using.</t>

		<!= ISSUE 194 > 
		<t> The WTP MUST transmit this message element with the status set to 1 
		after it has detected a duplicate IP address. When the WTP detects that the
		duplicate IP address has been cleared, it MUST send this message element
		with the status set to 0.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                          IP Address                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                          IP Address                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                          IP Address                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                          IP Address                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |     Status    |     Length    |         MAC Address ...       
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

	<list style="hanging">
		<t hangText= "Type: ">
		22 for Duplicate IPv6 Address</t>

		<t hangText= "Length: ">
		>= 24</t>

		<t hangText="IP Address: ">
		The IP address currently used by the WTP.</t>

		<t hangText="Status: ">
		The status of the duplicate IP address. The value MUST be set to 1
		when a duplicate address is detected, and 0 when the duplicate address
		has been cleared.</t>

        <t hangText="Length:">The length of the MAC Address
			field. The formats and lengths specified in <xref
			target="EUI-48"></xref> and <xref target="EUI-64"></xref> are
			supported.</t>

		<t hangText="MAC Address: ">
		The MAC address of the offending device.</t>
	</list>
	<!= /ISSUE 194 >
    </section> <!-- Duplicate IPv6 Address -->
    
     <section anchor="Idle-Timeout" title="Idle Timeout">
        <t>The Idle Timeout message element is sent by the
        AC to the WTP to provide the Idle Timeout value that the WTP SHOULD
        enforce for its active stations. The value applies to all radios
		on the WTP.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                            Timeout                            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         23 for Idle Timeout</t>

         <t hangText= "Length: ">
         4</t>

         <t hangText="Timeout: ">
         The current Idle Timeout, in seconds, to be enforced by the WTP. The
		 default value for this message element is specified in
		 <xref target="IdleTimeout"></xref>.</t>

        </list>
    </section> <!-- Idle Timeout -->

     <section anchor="ECN Support" title="ECN Support">
        <t>The ECN Support message element is sent by both the WTP and the
	AC to indicate their support for the Explicit Congestion Notification
	(ECN) bits, as defined in <xref target="RFC3168"/>.</t>

<artwork>
   0
   0 1 2 3 4 5 6 7
  +-+-+-+-+-+-+-+-+
  |  ECN Support  |
  +-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         53 for ECN Support</t>

         <t hangText= "Length: ">
         1</t>

         <t hangText="ECN Support: ">
         An 8-bit value representing the sender's support for ECN, as defined
         in <xref target="RFC3168"/>. All CAPWAP Implementations MUST support
         the Limited ECN Support mode. Full ECN Support is used if both the WTP
         and AC advertise the capability for "Full and Limited ECN" Support; 
         otherwise, Limited ECN Support is used.</t>
        <list style="hanging">
         <t hangText="0 -"> Limited ECN Support</t>
         <t hangText="1 -"> Full and Limited ECN Support</t>
        </list>

        </list>
    </section> <!-- ECN Support -->

     <section anchor="Image-Data"  title="Image Data">
        <t>The Image Data message element is present in the Image Data Request
		message sent by the AC and contains the following fields.</t> 

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Data Type   |                    Data ....
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         24 for Image Data</t>

         <t hangText= "Length: ">
         >= 1</t>

         <t hangText="Data Type: ">
         An 8-bit value representing the image Data Type. The following 
         enumerated values are supported:</t>
        <list style="hanging">
         <t hangText="1 -"> Image data is included.</t>
         <t hangText="2 -"> Last Image Data Block is included (EOF).</t>
         <t hangText="5 -"> An error occurred. Transfer is aborted.</t>
	</list>

         <t hangText="Data: ">
         The Image Data field contains up to 1024 characters, and its length is
		 inferred from this message element's length field. If the block being
		 sent is the last one, the Data Type field is set to 2. The AC MAY opt
		 to abort the data transfer by setting the Data Type field to 5. When
		 the Data Type field is 5, the Value field has a zero length.</t>
        </list>
    </section> <!-- Image Data -->

     <section anchor="Image-Identifier" title="Image Identifier">
        <t>The Image Identifier message element is sent by the AC to the WTP to
		indicate the expected active software version that is to be run on the
		WTP. The WTP sends the Image Identifier message element in order to 
		request a specific software version from the AC. The actual download
		process is defined in <xref target="Firmware Management"></xref>. The
		value is a variable-length UTF-8 encoded string
		<xref target="RFC3629"></xref>, which is NOT zero terminated.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                       Vendor Identifier                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                             Data...                           
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>
        <list style="hanging">
         <t hangText= "Type: ">
         25 for Image Identifier</t>

         <t hangText= "Length: ">
         >= 5</t>

         <t hangText="Vendor Identifier: ">
         A 32-bit value containing the IANA-assigned "SMI Network
         Management Private Enterprise Codes".</t>

         <t hangText="Data: ">
         A variable-length UTF-8 encoded string <xref target="RFC3629"></xref> 
		 containing the firmware identifier to be run on the WTP, whose length
		 MUST NOT exceed 1024 octets. The length of this field is inferred from
		 this message element's length field.</t>
		</list>
    </section> <!-- Image Identifier -->

     <section anchor="Image-Information"  title="Image Information">
        <t>The Image Information message element is present in the
		Image Data Response message sent by the AC to the WTP and contains the
		following fields.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           File Size                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                              Hash                             |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                              Hash                             |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                              Hash                             |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                              Hash                             |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         26 for Image Information</t>

         <t hangText= "Length: ">
         20</t>

         <t hangText="File Size: ">
         A 32-bit value containing the size of the file, in bytes, that will be 
		 transferred by the AC to the WTP.</t>

         <t hangText="Hash: ">
         A 16-octet MD5 hash of the image using the procedures defined in
		 <xref target="RFC1321"></xref>. </t>
        </list>
    </section> <!-- Image Information -->

    <section anchor="Initiate Download" title="Initiate Download">
        <t>The Initiate Download message element is used by the WTP to inform
		the AC that the AC SHOULD initiate a firmware upgrade. The AC
		subsequently transmits an Image Data Request message, which includes the
		Image Data message element. This message element does not contain any
		data.</t>

        <list style="hanging">
         <t hangText= "Type: ">
         27 for Initiate Download</t>

         <t hangText= "Length: ">
         0</t>
		</list>
    </section> <!-- Initiate Download -->

	<section anchor="Location-Data" title="Location Data">
        <t>The Location Data message element is a variable-length byte UTF-8
		encoded string <xref target="RFC3629"></xref> containing user-defined 
		location information (e.g., "Next to Fridge"). This information is
		configurable by the network administrator, and allows the WTP location
		to be determined. The string is not zero terminated.</t>

<artwork>
   0                   
   0 1 2 3 4 5 6 7 
  +-+-+-+-+-+-+-+-+-
  | Location ...                         
  +-+-+-+-+-+-+-+-+-
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         28 for Location Data</t>

         <t hangText= "Length: ">
         >= 1</t>

         <t hangText="Location: ">
         A non-zero-terminated UTF-8 encoded string <xref target="RFC3629">
		 </xref> containing the WTP location, whose maximum size MUST NOT exceed
		 1024.</t>
		</list>
	</section> <!-- Location Data -->
    
       <section anchor="Maximum-Message-Length" title="Maximum Message Length">
        <t>The Maximum Message Length message element is included in the Join
		Request message by the WTP to indicate the maximum CAPWAP message length
		that it supports to the AC. The Maximum Message Length message element
		is optionally included in Join Response message by the AC to indicate
		the maximum CAPWAP message length that it supports to the WTP.</t>
	
<artwork>
      0              1
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |    Maximum Message Length     |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</artwork>

	<list style="hanging">
         <t hangText= "Type: ">
         29 for Maximum Message Length</t>

         <t hangText= "Length: ">
         2</t>

         <t hangText="Maximum Message Length">
         A 16-bit unsigned integer indicating the maximum message length.</t>
	</list>
	</section> <!-- Maximum Message Length-->

	<section anchor="MTU-Discovery-Padding" title="MTU Discovery Padding">
	<t>The MTU Discovery Padding message element is used as padding to
	perform MTU discovery, and MUST contain octets of value 0xFF, of any
	length.</t>
	
<artwork>
   0                                   
   0 1 2 3 4 5 6 7 
  +-+-+-+-+-+-+-+-+
  |  Padding...                           
  +-+-+-+-+-+-+-+-

</artwork>

	<list style="hanging">
         <t hangText= "Type: ">
         52 for MTU Discovery Padding</t>

         <t hangText= "Length: ">
         Variable</t>

         <t hangText="Pad: ">
         A variable-length pad, filled with the value 0xFF.</t>
	</list>
	</section> <!-- MTU Discovery Padding-->

	<section anchor="Radio-Administrative-State" title="Radio Administrative State">
        <t>The Radio Administrative State message element is used to communicate
		the state of a particular radio. The Radio Administrative State message
		element is sent by the AC to change the state of the WTP. The WTP saves
		the value, to ensure that it remains across WTP resets. The WTP
		communicates this message element during the configuration phase, in the
		Configuration Status Request message, to ensure that the AC has the WTP
		radio current administrative state settings. The message element
		contains the following fields:</t>

<artwork>
      0                   1       
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Radio ID    |  Admin State  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         31 for Radio Administrative State</t>

         <t hangText= "Length: ">
         2</t>

         <t hangText="Radio ID: ">
		 An 8-bit value representing the radio to configure, whose value is
		 between one (1) and 31. The Radio ID field MAY also include the value
		 of 0xff, which is used to identify the WTP. If an AC wishes to change
		 the administrative state of a WTP, it includes 0xff in the Radio ID
		 field.</t>

         <t hangText="Admin State: ">
         An 8-bit value representing the administrative state of the 
         radio. The default value for the Admin State field is listed in
         <xref target="AdminState"></xref>. The following enumerated values are
         supported:</t>
        <list style="hanging">
         <t hangText="0 -">  Reserved</t>
         <t hangText="1 -">  Enabled</t>
         <t hangText="2 -">  Disabled</t>
        </list>
	</list>
	</section> <!-- Radio Administrative State -->

	<section anchor="Radio-Operational-State" title="Radio Operational State">
        <t>The Radio Operational State message element is sent by the WTP to the
		AC to communicate a radio's operational state. This message element
		is included in the Configuration Update Response message by the WTP if it
		was requested to change the state of its radio, via the Radio
		Administrative State message element, but was unable to comply to the request.
		This message element is included in the Change State Event message when a WTP
		radio state was changed unexpectedly. This could occur due to a hardware
		failure. Note that the operational state setting is not saved on the WTP,
		and therefore does not remain across WTP resets. The value contains three
		fields, as shown below.</t>

<artwork>
   0                   1                   2
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Radio ID    |     State     |     Cause     |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>


        <list style="hanging">
         <t hangText= "Type: ">
         32 for Radio Operational State</t>

         <t hangText= "Length: ">
         3</t>

         <t hangText="Radio ID: ">
         The Radio Identifier refers to an interface index on the WTP, whose
		 value is between one (1) and 31. A value of 0xFF is invalid, as it is
		 not possible to change the WTP's operational state.</t>

         <t hangText="State: ">
         An 8-bit Boolean value representing the state of the radio. The
		 following enumerated values are supported:</t>
        <list style="hanging">
         <t hangText="0 -">  Reserved</t>
         <t hangText="1 -">  Enabled</t>
         <t hangText="2 -">  Disabled</t>
        </list>

		 <t hangText="Cause: ">
		 When a radio is inoperable, the cause field contains
         the reason the radio is out of service. The following enumerated values
		 are supported:</t>
        <list style="hanging">
         <t hangText="0 -">  Normal</t>
         <t hangText="1 -">  Radio Failure</t>
         <t hangText="2 -">  Software Failure</t>
		 <t hangText="3 -">  Administratively Set</t>
        </list>
        </list>
    </section> <!-- Radio Operational State -->

	<section anchor="Result-Code" title="Result Code">
        <t>The Result Code message element value is a 32-bit integer value, 
        indicating the result of the Request message corresponding to the 
        sequence number included in the Response message.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                         Result Code                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         33 for Result Code</t>

         <t hangText= "Length: ">
         4</t>

         <t hangText="Result Code: ">
         The following enumerated values are defined:</t>
		 <list style="hanging">
         <t hangText="0"> Success</t>
         <t hangText="1"> Failure (AC List Message Element MUST Be Present)</t>
         <t hangText="2"> Success (NAT Detected)</t>
         <t hangText="3"> Join Failure (Unspecified)</t>
         <t hangText="4"> Join Failure (Resource Depletion)</t>
         <t hangText="5"> Join Failure (Unknown Source)</t>
         <t hangText="6"> Join Failure (Incorrect Data)</t>
         <t hangText="7"> Join Failure (Session ID Already in Use)</t>          
         <t hangText="8"> Join Failure (WTP Hardware Not Supported) </t>  
         <t hangText="9"> Join Failure (Binding Not Supported)</t>   
         <t hangText="10"> Reset Failure (Unable to Reset)</t>   
         <t hangText="11"> Reset Failure (Firmware Write Error)</t>   
		 <!-- ISSUE 72+ -->
		 <t hangText="12"> Configuration Failure (Unable to Apply Requested Configuration - Service Provided Anyhow)</t>
		 <t hangText="13"> Configuration Failure (Unable to Apply Requested Configuration - Service Not Provided)</t>
         <t hangText="14"> Image Data Error (Invalid Checksum)</t>   
         <t hangText="15"> Image Data Error (Invalid Data Length)</t>   
         <t hangText="16"> Image Data Error (Other Error)</t>
		 <t hangText="17"> Image Data Error (Image Already Present)</t>
         <t hangText="18"> Message Unexpected (Invalid in Current State)</t>
         <t hangText="19"> Message Unexpected (Unrecognized Request)</t>
         <t hangText="20"> Failure - Missing Mandatory Message Element</t>
         <t hangText="21"> Failure - Unrecognized Message Element</t>
         <t hangText="22"> Data Transfer Error (No Information to Transfer)</t>
		 </list>

		</list>
    </section> <!-- Result Code -->

	<section anchor="Returned-Message-Element" title="Returned Message Element">
        <t>The Returned Message Element is sent by the WTP in the Change
		State Event Request message to communicate to the AC which message
		elements in the Configuration Status Response it was unable to apply
		locally. The Returned Message Element message element contains a result
		code indicating the reason that the configuration could not be applied,
		and encapsulates the failed message element.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    Reason     |    Length     |       Message Element...
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>


        <list style="hanging">
         <t hangText= "Type: ">
         34 for Returned Message Element</t>

         <t hangText= "Length: ">
         >= 6</t>

         <t hangText= "Reason: ">
         The reason the configuration in the offending message element could
		 not be applied by the WTP. The following enumerated values are
		 supported:</t>
        <list style="hanging">
         <t hangText="0 -">  Reserved</t>
         <t hangText="1 -">  Unknown Message Element</t>
         <t hangText="2 -">  Unsupported Message Element</t>
         <t hangText="3 -">  Unknown Message Element Value</t>
		 <t hangText="4 -">  Unsupported Message Element Value</t>
        </list>

         <t hangText= "Length: ">
         The length of the Message Element field, which MUST NOT exceed 255
		 octets.</t>

         <t hangText= "Message Element: ">
         The Message Element field encapsulates the message element sent by
		 the AC in the Configuration Status Response message that caused the
		 error.</t>
        </list>
    </section> <!-- Returned Message Element -->

	<section anchor="Session ID" title="Session ID">
        <t>The Session ID message element value contains a randomly generated
        unsigned 128-bit integer. </t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           Session ID                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           Session ID                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           Session ID                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           Session ID                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         35 for Session ID</t>

         <t hangText= "Length: ">
         16</t>

         <t hangText="Session ID: ">
         A 128-bit unsigned integer used as a random session identifier </t>
		</list>
    </section> <!-- Session ID -->

	<section anchor="Statistics-Timer" title="Statistics Timer">
        <t>The Statistics Timer message element value is used by the AC to inform 
        the WTP of the frequency with which it expects to receive updated statistics. </t>

<artwork>
   0                   1
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |        Statistics Timer       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         36 for Statistics Timer</t>

         <t hangText= "Length: ">
         2</t>

         <t hangText="Statistics Timer: ">
         A 16-bit unsigned integer indicating the time, in seconds. The
		 default value for this timer is specified in
		 <xref target="StatisticsTimer"></xref>.</t>
		</list>
    </section> <!-- Statistics Timer -->

	<section anchor="Vendor Specific Payload" title="Vendor Specific Payload">
        <t>The Vendor Specific Payload message element is used to communicate
		vendor-specific information between the WTP and the AC. The Vendor
		Specific Payload message element MAY be present in any CAPWAP message.
		The exchange of vendor-specific data between the MUST NOT modify the
		behavior of the base CAPWAP protocol and state machine. The message
		element uses the following format:</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                       Vendor Identifier                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |          Element ID           |    Data...    
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         37 for Vendor Specific Payload</t>

         <t hangText= "Length: ">
         >= 7</t>

         <t hangText="Vendor Identifier: ">
         A 32-bit value containing the IANA-assigned "SMI Network 
         Management Private Enterprise Codes" <xref target="RFC3232"></xref>.</t>
		

         <t hangText="Element ID: ">
         A 16-bit Element Identifier that is managed by the vendor.</t>

         <t hangText="Data: ">
         Variable-length vendor-specific information, whose contents and format
		 are proprietary and understood based on the Element ID field. This
		 field MUST NOT exceed 2048 octets.</t>
        </list>
    </section> <!-- Vendor Specific Payload -->

    <section anchor="WTP-Board-Data"title="WTP Board Data">
        <t>The WTP Board Data message element is sent by the WTP to the AC
        and contains information about the hardware present.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                       Vendor Identifier                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                   Board Data Sub-Element...
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         38 for WTP Board Data</t>

         <t hangText= "Length: ">
         >=14</t>

         <t hangText="Vendor Identifier: ">
         A 32-bit value containing the IANA-assigned "SMI Network
         Management Private Enterprise Codes", identifying the WTP hardware
		 manufacturer. The Vendor Identifier field MUST NOT be set to zero.</t>

         <t hangText="Board Data Sub-Element: ">
         The WTP Board Data message element contains multiple Board Data
		 sub-elements, some of which are mandatory and some are optional, as
		 described below. The Board Data Type values are not extensible by
		 vendors, and are therefore not coupled along with the Vendor Identifier
		 field. The Board Data sub-element has the following format:</t>
<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |        Board Data Type        |       Board Data Length       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                      Board Data Value...                           
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

		 <list style="hanging">
         <t hangText="Board Data Type: "> The Board Data Type field identifies
		 the data being encoded. The CAPWAP protocol defines the following
		 values, and each of these types identify whether their presence is
		 mandatory or optional:</t>
                 </list>
		 <list style="hanging" hangIndent="6">
		 <t hangText="0 -"> WTP Model Number: The WTP Model Number MUST be
		 included in the WTP Board Data message element.</t>
		 <t hangText="1 -"> WTP Serial Number: The WTP Serial Number MUST be
		 included in the WTP Board Data message element.</t>
		 <t hangText="2 -"> Board ID: A hardware identifier, which MAY be
		 included in the WTP Board Data message element.</t>
		 <t hangText="3 -"> Board Revision: A revision number of the board,
		 which MAY be included in the WTP Board Data message element.</t>
		 <t hangText="4 -"> Base MAC Address: The WTP's Base MAC address, which
		 MAY be assigned to the primary Ethernet interface.</t>
		 </list>

         <t hangText="Board Data Length: "> The length of the data in the Board
		 Data Value field, whose length MUST NOT exceed 1024 octets.</t>

         <t hangText="Board Data Value: "> The data associated with the Board
		 Data Type field for this Board Data sub-element.</t>

        </list>
    </section> <!-- WTP Board Data -->
    
      <section anchor="WTP-Descriptor" title="WTP Descriptor">
        <t>The WTP Descriptor message element is used by a WTP to communicate its 
        current hardware and software (firmware) configuration. The value contains the 
        following fields:</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Max Radios  | Radios in use |  Num Encrypt  |Encryp Sub-Elmt|
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |     Encryption Sub-Element    |    Descriptor Sub-Element...
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         39 for WTP Descriptor</t>

         <t hangText= "Length: ">
         >= 33</t>

         <t hangText="Max Radios: ">
         An 8-bit value representing the number of radios (where each radio is
		 identified via the Radio ID field) supported by the WTP.</t>

         <t hangText="Radios in use: ">
         An 8-bit value representing the number of radios in use in 
         the WTP.</t>

		 <t hangText="Num Encrypt: ">
		 The number of 3-byte Encryption sub-elements that follow this field.
		 The value of the Num Encrypt field MUST be between one (1) and 255.</t>

         <t hangText="Encryption Sub-Element: ">
         The WTP Descriptor message element MUST contain at least one Encryption
		 sub-element. One sub-element is present for each binding supported
		 by the WTP. The Encryption sub-element has the following
		 format:</t>
<artwork>
   0                   1                   2       
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |Resvd|  WBID   |  Encryption Capabilities      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

		 <list style="hanging">
		<t hangText="Resvd:">The 3-bit field is reserved for future use. All
		implementations complying with this protocol MUST set to zero any bits
		that are reserved in the version of the protocol supported by that
		implementation.  Receivers MUST ignore all bits not defined for the
		version of the protocol they support.</t>

		<t hangText="WBID: ">
		 A 5-bit field that is the wireless binding identifier.  The
		 identifier will indicate the type of wireless packet associated
		 with the radio.  The WBIDs defined in this specification can be
		 found in <xref target="CAPWAP Header"/>.</t>

         <t hangText="Encryption Capabilities: ">
         This 16-bit field is used by the WTP to communicate its capabilities
         to the AC. A WTP that does not have any encryption capabilities 
         sets this field to zero (0). Refer to the specific wireless binding for
         further specification of the Encryption Capabilities field.</t>
		 </list>

         <t hangText="Descriptor Sub-Element: ">
         The WTP Descriptor message element contains multiple Descriptor
		 sub-elements, some of which are mandatory and some are optional, as
		 described below. The Descriptor sub-element has the following
		 format:</t>
<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                  Descriptor Vendor Identifier                 |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |        Descriptor Type        |       Descriptor Length       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                       Descriptor Data...
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

		 <list style="hanging">
         <t hangText="Descriptor Vendor Identifier: ">
         A 32-bit value containing the IANA-assigned "SMI Network
         Management Private Enterprise Codes".</t>

         <t hangText="Descriptor Type: "> The Descriptor Type field identifies
		 the data being encoded. The format of the data is vendor-specific
		 encoded in the UTF-8 format <xref target="RFC3629"/>. The CAPWAP
		 protocol defines the following values, and each of these types identify
		 whether their presence is mandatory or optional. The values listed
		 below are used in conjunction with the Descriptor Vendor Identifier
		 field, whose value MUST be set to zero (0). This field, combined with
		 the Descriptor Vendor Identifier set to a non-zero (0) value, allows
		 vendors to use a private namespace.</t>

		 <list style="hanging" hangIndent="6">
		 <t hangText="0 -">
		 Hardware Version: The WTP hardware version number MUST be present.</t>
		 <t hangText="1 -">
		 Active Software Version: The WTP running software version number MUST be present.</t>
		 <t hangText="2 -">
		 Boot Version: The WTP boot loader version number MUST be present.</t>	
		 <t hangText="3 -">
		 Other Software Version: The WTP non-running software (firmware) version number MAY be present.
		 This type is used to communicate alternate software versions that
		 are available on the WTP's non-volatile storage.</t>
		 </list>

         <t hangText="Descriptor Length: ">
         Length of the vendor-specific encoding of the Descriptor Data field, whose
		 length MUST NOT exceed 1024 octets.</t>

         <t hangText="Descriptor Data: ">
         Vendor-specific data of WTP information encoded in the UTF-8 format
		 <xref target="RFC3629"></xref>.</t>
		 </list>
		 </list>
    </section> <!-- WTP Descriptor -->
    
      <section anchor="WTP-Fallback" title="WTP Fallback">
        <t>The WTP Fallback message element is sent by the AC to the WTP
        to enable or disable automatic CAPWAP fallback in the event that
        a WTP detects its preferred AC to which it is not currently connected.</t>

<artwork>
   0               
   0 1 2 3 4 5 6 7 
  +-+-+-+-+-+-+-+-+
  |     Mode      |
  +-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         40 for WTP Fallback</t>

         <t hangText= "Length: ">
         1</t>

         <t hangText="Mode: ">
         The 8-bit value indicates the status of automatic CAPWAP fallback
         on the WTP. When enabled, if the WTP detects that its primary AC is
		 available, and that the WTP is not connected to the primary AC, the WTP SHOULD automatically 
		 disconnect from its current AC and reconnect to its primary AC. If
		 disabled, the WTP will only reconnect to its primary AC through manual
		 intervention (e.g., through the Reset Request message). The default
		 value for this field is specified in
		 <xref target="WTPFallBack"></xref>. The following enumerated values are
		 supported:</t>
		 <list style="hanging">
         <t hangText="0 -">  Reserved</t>
         <t hangText="1 -">  Enabled</t>
         <t hangText="2 -">  Disabled</t>
		 </list>
        </list>
    </section> <!-- WTP Fallback -->
    
     <section anchor="WTP-Frame-Tunnel-Mode" title="WTP Frame Tunnel Mode">
	<t>The WTP Frame Tunnel Mode message element allows the WTP to
   	communicate the tunneling modes of operation that it supports to the AC.  
   	A WTP that advertises support for all types allows the AC to select which type 
   	will be used, based on its local policy.</t>
	
<artwork>
   0
   0 1 2 3 4 5 6 7
  +-+-+-+-+-+-+-+-+
  |Reservd|N|E|L|U|
  +-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         41 for WTP Frame Tunnel Mode</t>

         <t hangText= "Length: ">
         1</t>

		 <t hangText="Reservd: "> A set of reserved bits for future use. All
		 implementations complying with this protocol MUST set to zero any bits
		 that are reserved in the version of the protocol supported by that
		 implementation.  Receivers MUST ignore all bits not defined for the
		 version of the protocol they support.</t>
                 </list>

                 <list style="hanging" hangIndent="6">
         <t hangText= "N: "> Native Frame Tunnel mode requires the WTP and AC to
		 encapsulate all user payloads as native wireless frames, as defined by
		 the wireless binding (see for example <xref
		 target="CAPWAP Data Messages"></xref>)</t>

         <t hangText= "E: "> The 802.3 Frame Tunnel Mode requires the WTP and AC
		 to encapsulate all user payload as native IEEE 802.3 frames (see
		 <xref target="CAPWAP Data Messages"></xref>). All user traffic is
		 tunneled to the AC. This value MUST NOT be used when the WTP MAC Type
		 is set to Split MAC.</t>

         <t hangText= "L: "> When Local Bridging is used, the WTP does not tunnel
		 user traffic to the AC; all user traffic is locally bridged. This value
		 MUST NOT be used when the WTP MAC Type is set to Split MAC.</t>

         <t hangText= "R: "> A reserved bit for future use. All implementations
		 complying with this protocol MUST set to zero any bits that are
		 reserved in the version of the protocol supported by that
		 implementation.  Receivers MUST ignore all bits not defined for the
		 version of the protocol they support.</t>
        </list>

    </section> <!-- WTP Frame Tunnel Mode --> 

<!--
    <section anchor="WTP-IPv4-IP-Address" title="WTP IPv4 IP Address">
        <t>The WTP IPv4 address is used to perform NAT detection.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                      WTP IPv4 IP Address                      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         42 for WTP IPv4 IP Address</t>

         <t hangText= "Length: ">
         4</t>

         <t hangText="WTP IPv4 IP Address: ">
         The IPv4 address from which the WTP is sending packets. This field is
         used for NAT detection.</t>

         </list>
    </section> --> <!-- WTP IPv4 IP Address -->

<!--
    <section anchor="WTP-IPv6-IP-Address" title="WTP IPv6 IP Address">
        <t>The WTP IPv6 address is used to perform NAT detection (e.g., IPv4
		to IPv6 NAT to help with technology transition).</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                      WTP IPv6 IP Address                      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                      WTP IPv6 IP Address                      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                      WTP IPv6 IP Address                      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                      WTP IPv6 IP Address                      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         43 for WTP IPv6 IP Address</t>

         <t hangText= "Length: ">
         32</t>

         <t hangText="WTP IPv6 IP Address: ">
         The IPv6 address from which the WTP is sending packets. This field is
		 used for NAT detection.</t>

         </list>
    </section> --> <!-- WTP IPv6 IP Address -->

	<section anchor="WTP-MAC-Type" title="WTP MAC Type">
	<t>The WTP MAC-Type message element allows the WTP to communicate its 
	mode of operation to the AC. A WTP that advertises support for both modes 
	allows the AC to select the mode to use, based on local policy.</t>
	
<artwork>
   0
   0 1 2 3 4 5 6 7
  +-+-+-+-+-+-+-+-+
  |   MAC Type    |
  +-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         44 for WTP MAC Type</t>

         <t hangText= "Length: ">
         1</t>

         <t hangText="MAC Type: ">
         The MAC mode of operation supported by the WTP. The following
		 enumerated values are supported:</t>
		 <list style="hanging" hangIndent="6">
		 <t hangText="0 -">
		 Local MAC: Local MAC is the default mode that MUST be supported by all WTPs. When
		 tunneling is enabled (see <xref target="WTP-Frame-Tunnel-Mode"/>), the
		 encapsulated frames MUST be in the 802.3 format (see <xref
		 target="Station Data Payloads"/>), unless a wireless management or
		 control frame which MAY be in its native format. Any CAPWAP binding
		 needs to specify the format of management and control wireless
		 frames.</t>
		 <t hangText="1 -">
		 Split MAC: Split MAC support is optional, and allows the AC to receive and process
		 native wireless frames.</t>
		 <t hangText="2 -">
		 Both: WTP is capable of supporting both Local MAC and Split MAC.</t>
		 </list>
        </list>
    </section> <!-- WTP MAC Type -->

<!-- Moved the WTP-Manager-Control-IPv4/6-Address message elements as a result
     of renaming -->

	<section anchor="WTP-Name" title="WTP Name">
		<t>The WTP Name message element is a variable-length byte UTF-8 encoded 
		string <xref target="RFC3629"></xref>. The string is not zero terminated.</t>
<artwork>
   0                   
   0 1 2 3 4 5 6 7 
  +-+-+-+-+-+-+-+-+-
  |  WTP Name ...   
  +-+-+-+-+-+-+-+-+-
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         45 for WTP Name</t>

         <t hangText= "Length: ">
         >= 1</t>

         <t hangText="WTP Name: ">
         A non-zero-terminated UTF-8 encoded string <xref target="RFC3629">
		 </xref> containing the WTP name, whose maximum size MUST NOT exceed 512
		 bytes.</t>
   </list>

    </section> <!-- WTP Name -->
<!--
  <section anchor="WTP-Operational-Statistics" title="WTP Operational Statistics">
        <t>The WTP Operational Statistics message element is sent by the WTP to the
        AC to provide statistics related to the operation of the WTP.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Radio ID   | Tx Queue Level | Wireless Link Frames per Sec  |   
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         48 for WTP Operational Statistics</t>

         <t hangText= "Length: ">
         4</t>

         <t hangText="Radio ID: ">
         The radio ID of the radio to which the statistics apply.</t>

         <t hangText="Wireless Transmit Queue Level: ">
         The percentage of Wireless Transmit queue utilization, calculated as
		 the sum of utilized transmit queue lengths divided by the sum of
		 maximum transmit queue lengths, multiplied by 100. The Wireless
		 Transmit Queue Level is representative of congestion conditions over
		 wireless interfaces between the WTP and stations.</t>

         <t hangText="Wireless Link Frames per Sec: ">
         The number of frames transmitted or received per second by the WTP over
		 the air interface.</t>         

        </list>
    </section> 
-->

  <section anchor="WTP-Radio-Statistics" title="WTP Radio Statistics">
        <t>The WTP  Radio Statistics message element is sent by the WTP to the
		AC to communicate statistics on radio behavior and reasons why the WTP
		radio has been reset.  These counters are never reset on the WTP, and
		will therefore roll over to zero when the maximum size has been
		reached.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Radio ID    | Last Fail Type|          Reset Count          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |       SW Failure Count        |        HW Failure Count       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |     Other  Failure Count      |     Unknown Failure Count     |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Config Update Count      |     Channel Change Count      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |       Band Change Count       |      Current Noise Floor      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         47 for WTP Radio Statistics</t>

         <t hangText= "Length: ">
         20</t>

         <t hangText="Radio ID: ">
         The radio ID of the radio to which the statistics apply, whose value is
		 between one (1) and 31.</t>

         <t hangText="Last Failure Type: ">
         The last WTP failure. The following enumerated values are supported:</t>
        <list style="hanging">
         <t hangText="0 -">  Statistic Not Supported</t>
         <t hangText="1 -">  Software Failure</t>
         <t hangText="2 -">  Hardware Failure</t>
         <t hangText="3 -">  Other Failure</t>
         <t hangText="255 -">  Unknown (e.g., WTP doesn't keep track of info)</t>
        </list>

         <t hangText="Reset Count: ">
         The number of times that the radio has been reset.</t>

         <t hangText="SW Failure Count: ">
         The number of times that the radio has failed due to software-related reasons.</t>       

         <t hangText="HW Failure Count: ">
         The number of times that the radio has failed due to hardware-related reasons.</t> 

         <t hangText="Other Failure Count: ">
         The number of times that the radio has failed due to known reasons, other than software
         or hardware failure.</t>

         <t hangText="Unknown Failure Count: ">
         The number of times that the radio has failed for unknown reasons.</t>

         <t hangText="Config Update Count: ">
         The number of times that the radio configuration has been updated.</t>

         <t hangText="Channel Change Count: ">
         The number of times that the radio channel has been changed.</t>

         <t hangText="Band Change Count: ">
         The number of times that the radio has changed frequency bands.</t> 

         <t hangText="Current Noise Floor: ">
         A signed integer that indicates the noise floor of the radio receiver in units of dBm.</t> 

        </list>
    </section> <!-- WTP Radio Statistics -->   
    
 <section anchor="WTP-Reboot-Statistics" title="WTP Reboot Statistics">
        <t>The WTP Reboot Statistics message element is sent by the WTP to the
		AC to communicate reasons why WTP reboots have occurred. These
		counters are never reset on the WTP, and will therefore roll over to
		zero when the maximum size has been reached.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |         Reboot Count          |      AC Initiated Count       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Link Failure Count       |       SW Failure Count        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |       HW Failure Count        |      Other Failure Count      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |     Unknown Failure Count     |Last Failure Type|
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         48 for WTP Reboot Statistics</t>

         <t hangText= "Length: ">
         15</t>

         <t hangText="Reboot Count: ">
         The number of reboots that have occurred due to a WTP crash. A value
		 of 65535 implies that this information is not available on the WTP.</t>

         <t hangText="AC Initiated Count: ">
         The number of reboots that have occurred at the request of a CAPWAP protocol
         message, such as a change in configuration that required a reboot or
         an explicit CAPWAP protocol reset request. A value of 65535 implies that this
		 information is not available on the WTP.</t>

         <t hangText="Link Failure Count: ">
         The number of times that a CAPWAP protocol connection with an AC has
		 failed due to link failure.</t>

         <t hangText="SW Failure Count: ">
         The number of times that a CAPWAP protocol connection with an AC has
		 failed due to software-related reasons.</t>

          <t hangText="HW Failure Count: ">
         The number of times that a CAPWAP protocol connection with an AC has
		 failed due to hardware-related reasons.</t>

         <t hangText="Other Failure Count: ">
         The number of times that a CAPWAP protocol connection with an AC has
		 failed due to known reasons, other than AC initiated, link, SW or HW
		 failure.</t>

         <t hangText="Unknown Failure Count: ">
         The number of times that a CAPWAP protocol connection with an AC has
		 failed for unknown reasons.</t>        

         <t hangText="Last Failure Type: ">
         The failure type of the most recent WTP failure. The following
		 enumerated values are supported:</t>
        <list style="hanging">
         <t hangText="0 -">  Not Supported</t>
         <t hangText="1 -">  AC Initiated (see <xref target="Reset Request"></xref>)</t>
         <t hangText="2 -">  Link Failure</t>
         <t hangText="3 -">  Software Failure</t>
         <t hangText="4 -">  Hardware Failure</t>
         <t hangText="5 -">  Other Failure</t>
         <t hangText="255 -">  Unknown (e.g., WTP doesn't keep track of info)</t>
        </list>

        </list>
    </section> <!-- WTP Reboot Statistics -->


  <section anchor="WTP-Static-IP-Address-Information" title="WTP Static IP Address Information">
        <t>The WTP Static IP Address Information message element is used by
        an AC to configure or clear a previously configured static IP address
        on a WTP. IPv6 WTPs are expected to use dynamic addresses.</t>

<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                          IP Address                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                            Netmask                            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                            Gateway                            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    Static     |
  +-+-+-+-+-+-+-+-+
</artwork>

        <list style="hanging">
         <t hangText= "Type: ">
         49 for WTP Static IP Address Information</t>

         <t hangText= "Length: ">
         13</t>

         <t hangText="IP Address: ">
         The IP address to assign to the WTP. This field is only valid if the
		 static field is set to one.</t>

         <t hangText="Netmask: ">
         The IP Netmask. This field is only valid if the static field is set to
		 one.</t>

         <t hangText="Gateway: ">
         The IP address of the gateway. This field is only valid if the
		 static field is set to one.</t>

         <t hangText="Static: ">
         An 8-bit Boolean stating whether or not the WTP should use a static IP address. A value of zero disables the static IP address, while a value of
		 one enables it.</t>

        </list>
    </section> <!-- WTP Static IP Address Information -->

    </section> <!-- CAPWAP Protocol Message Elements-->
    
    <section anchor="CAPWAP Protocol Timers" title="CAPWAP Protocol Timers">
        <t>This section contains the definition of the CAPWAP timers.</t>

    <section anchor="ChangeStatePendingTimer" title="ChangeStatePendingTimer">
		<t>The maximum time, in seconds, the AC will wait for the Change
		State Event Request from the WTP after having transmitted a successful
		Configuration Status Response message.</t>

        <t>    Default: 25 seconds</t>
    </section> <!-- ChangeStatePendingTimer -->

    <section anchor="DataChannelKeepAlive" title="DataChannelKeepAlive">
		<t>The DataChannelKeepAlive timer is used by the WTP to determine the
		next opportunity when it must transmit the Data Channel Keep-Alive, in
		seconds.</t>

        <t>    Default: 30 seconds</t>
    </section> <!-- DataChannelKeepAlive -->

    <section title="DataChannelDeadInterval">
        <t>The minimum time, in seconds, a WTP MUST wait without having
		received a Data Channel Keep-Alive packet before the destination 
		for the Data Channel Keep-Alive packets may be considered dead. The value
		of this timer MUST 
		be no less than 2*DataChannelKeepAlive seconds and no greater that 
		240 seconds.</t>

        <t>    Default: 60</t>
    </section> <!-- DataChannelDeadInterval -->

	<section title="DataCheckTimer">
		<t>The number of seconds the AC will wait for the Data Channel Keep
		Alive, which is required by the CAPWAP state machine's Data Check
		state. The AC resets the state machine if this timer expires prior to
		transitioning to the next state.</t>

        <t>    Default: 30</t>
    </section> <!-- DataCheckTimer -->

    <section title="DiscoveryInterval">
        <t>The minimum time, in seconds, that a WTP MUST wait after receiving a 
        Discovery Response message, before initiating a DTLS handshake.</t>

        <t>    Default: 5</t>
    </section> <!-- DiscoveryInterval -->

    <section title="DTLSSessionDelete" anchor="DTLSSessionDelete">
        <t>The minimum time, in seconds, a WTP MUST wait for DTLS session deletion.</t>

        <t>    Default: 5</t>

    </section> <!-- DTLSSessionDelete -->

	<section anchor="EchoInterval" title="EchoInterval">
        <t>The minimum time, in seconds, between sending Echo Request messages
		to the AC with which the WTP has joined.</t>

        <t>    Default: 30</t>
    </section> <!-- EchoInterval -->

    <section anchor="IdleTimeout" title="IdleTimeout">
        <t>The default Idle Timeout is 300 seconds.</t>
    </section> <!-- IdleTimeout -->

	<section title="ImageDataStartTimer">
		<t>The number of seconds the WTP will wait for its peer to transmit the
		Image Data Request.</t>

        <t>    Default: 30</t>
    </section> <!-- ImageDataStartTimer -->

    <section anchor="MaxDiscoveryInterval" title="MaxDiscoveryInterval">
        <t>The maximum time allowed between sending Discovery Request messages,
         in seconds. This value MUST be no less than 2 seconds and no greater 
        than 180 seconds.</t>

        <t>    Default: 20 seconds.</t>
    </section> <!-- MaxDiscoveryInterval -->

<!-- Removed due to Issue 20
	<section title="NeighborDeadInterval">
		<t>The minimum time, in seconds, a WTP MUST wait without having received
		an Echo Response message to its Echo Request message, before the
		destination for the Echo Request may be considered dead.  This value
		MUST be no less than 2*EchoInterval seconds and no greater than 240
		seconds.</t>

        <t>    Default: 60</t>
    </section> <!-- NeighborDeadInterval -->
-->

    <section anchor="ReportInterval" title="ReportInterval">
        <t>The ReportInterval is used by the WTP to determine the interval the
		WTP uses between sending the Decryption Error message elements to inform
		the AC of decryption errors, in seconds.</t>

        <t>The default Report Interval is 120 seconds.</t>
    </section> <!-- ReportInterval -->

    <section title="RetransmitInterval">
        <t>The minimum time, in seconds, in which a non-acknowledged CAPWAP packet
		will be retransmitted.</t>

        <t>    Default: 3</t>
    </section> <!-- RetransmitInterval -->
    
    <section title="SilentInterval">
        <t>For a WTP, this is the minimum time, in seconds, a WTP MUST wait
		before it MAY again send Discovery Request messages or attempt to establish a
		DTLS session. For an AC, this is the minimum time, in seconds, during which
		the AC SHOULD ignore all CAPWAP and DTLS packets received from the
		WTP that is in the Sulking state.</t>

        <t>    Default: 30 seconds</t>
    </section> <!-- SilentInterval -->

    <section anchor="StatisticsTimer" title="StatisticsTimer">
        <t>The StatisticsTimer is used by the WTP to determine the interval
		the WTP uses between the WTP Events Requests it transmits to the AC to
		communicate its statistics, in seconds.</t>

        <t>    Default: 120 seconds</t>
    </section> <!-- StatisticsTimer -->

    <section title="WaitDTLS">
        <t>The maximum time, in seconds, a WTP MUST wait without having received 
        a DTLS Handshake message from an AC. This timer MUST be greater than 30
		seconds.</t>

        <t>    Default: 60</t>
    </section> <!-- WaitDTLS -->

    <section title="WaitJoin">
        <t>The maximum time, in seconds, an AC will wait after the DTLS session
		has been established until it receives the Join Request from the WTP.
		This timer MUST be greater than 20 seconds.</t>

        <t>    Default: 60</t>
    </section> <!-- WaitJoin -->

    </section> <!-- CAPWAP Protocol Timers -->

    <section anchor="CAPWAP Protocol Variables" title="CAPWAP Protocol Variables">
        <t>This section defines the CAPWAP protocol variables, which are used
		for various protocol functions. Some of these variables are
		configurable, while others are counters or have a fixed value. For non-counter-related variables, default values are specified. However,
		when a WTP's variable configuration is explicitly overridden by an AC,
		the WTP MUST save the new value.</t>

    <section anchor="AdminState" title="AdminState">
        <t>The default Administrative State value is enabled (1).</t>
    </section> <!-- AdminState -->

    <section title="DiscoveryCount">
        <t>The number of Discovery Request messages transmitted by a WTP to a single AC. This is 
		a monotonically increasing counter.</t>
    </section> <!-- DiscoveryCount -->

    <section anchor="FailedDTLSAuthFailCount" title="FailedDTLSAuthFailCount">
        <t>The number of failed DTLS session establishment attempts due to
		authentication failures.</t>
    </section> <!-- FailedDTLSAuthFailCount -->

    <section anchor="FailedDTLSSessionCount" title="FailedDTLSSessionCount">
        <t>The number of failed DTLS session establishment attempts.</t>
    </section> <!-- FailedDTLSSessionCount -->

    <section title="MaxDiscoveries">
        <t>The maximum number of Discovery Request messages that will be sent after a WTP 
        boots.</t>

        <t>    Default: 10</t>
    </section> <!-- MaxDiscoveries -->

    <section title="MaxFailedDTLSSessionRetry">
        <t>The maximum number of failed DTLS session establishment attempts
		before the CAPWAP device enters a silent period.</t>

        <t>    Default: 3</t>
    </section> <!-- MaxFailedDTLSSessionRetry -->

    <section title="MaxRetransmit">
        <t>The maximum number of retransmissions for a given CAPWAP packet before
		the link layer considers the peer dead.</t>

        <t>    Default: 5</t>
    </section> <!-- MaxRetransmit -->

    <section title="RetransmitCount">
        <t>The number of retransmissions for a given CAPWAP packet. This is a 
		monotonically increasing counter.</t>
    </section> <!-- RetransmitCount -->

    <section anchor="WTPFallBack" title="WTPFallBack">
        <t>The default WTP Fallback value is enabled (1).</t>
    </section> <!-- WTPFallBack -->

    </section> <!-- CAPWAP Protocol Variables -->


    <section anchor="WTP Saved Variables" title="WTP Saved Variables">
        <t>In addition to the values
		defined in <xref target="CAPWAP Protocol Variables"></xref>, the
		following values SHOULD be saved on the WTP in non-volatile memory.
		CAPWAP wireless bindings MAY define additional values that SHOULD be stored on
		the WTP.</t>

    <section title="AdminRebootCount">
        <t>The number of times the WTP has rebooted administratively,
		defined in <xref target="WTP-Reboot-Statistics"></xref>.</t>
    </section> <!-- AdminRebootCount -->

    <section title="FrameEncapType">
        <t>For WTPs that support multiple Frame Encapsulation Types, it is 
		useful to save the value configured by the AC. The Frame Encapsulation
		Type is defined in <xref target="WTP-Frame-Tunnel-Mode"></xref>.</t>
    </section> <!-- FrameEncapType -->

    <section title="LastRebootReason">
        <t>The reason why the WTP last rebooted, defined in
		<xref target="WTP-Reboot-Statistics"></xref>.</t>
    </section> <!-- LastRebootReason -->

	<section title="MacType">
        <t>For WTPs that support multiple MAC-Types, it is useful to save the
		value configured by the AC. The MAC-Type is defined in
		<xref target="WTP-MAC-Type"></xref>.</t>
    </section> <!-- MacType -->

    <section title="PreferredACs">
        <t>The preferred ACs, with the index, defined in
		<xref target="AC-Name-with-Priority"></xref>.</t>
    </section> <!-- PreferredACs -->

    <section title="RebootCount">
        <t>The number of times the WTP has rebooted, defined in
	<xref target="WTP-Reboot-Statistics"></xref>.</t>
    </section> <!-- RebootCount -->

<!--
    <section title="Static ACL Table">
        <t>The static ACL table saved on the WTP, as configured by the
		Add Static MAC ACL Entry message element, see
		<xref target="Add-Static-MAC-ACL-Entry"></xref>.</t>
    </section> --> <!-- Static ACL Table -->

    <section title="Static IP Address">
        <t>The static IP address assigned to the WTP, as configured by the
		WTP Static IP address Information message element (see
		<xref target="WTP-Static-IP-Address-Information"></xref>).</t>
    </section> <!-- Static IP Address -->

    <section title="WTPLinkFailureCount">
        <t>The number of times the link to the AC has failed, see
	 <xref target="WTP-Reboot-Statistics"></xref>.</t>
    </section> <!-- WTPLinkFailureCount -->

    <section title="WTPLocation">
        <t>The WTP Location, defined in <xref target="Location-Data"></xref>.</t>
    </section> <!-- WTPLocation -->

    <section title="WTPName">
        <t>The WTP Name, defined in <xref target="WTP-Name"></xref>.</t>
    </section> <!-- WTPName -->

	</section> <!-- WTP Saved Variables -->

</section> <!-- CAPWAP Packet Definitions -->

<section anchor="CAPWAP Discovery Operations" title="CAPWAP Discovery Operations">

    <t>The Discovery messages are used by a WTP to determine which ACs are
    available to provide service, and the capabilities and load of the
    ACs.</t>

    <section anchor="Discovery Request" title="Discovery Request Message">
		<t>The Discovery Request message is used by the WTP to automatically
		discover potential ACs available in the network. The Discovery Request
		message provides ACs with the primary capabilities of the WTP. A WTP
		must exchange this information to ensure subsequent exchanges with the
		ACs are consistent with the WTP's functional characteristics. </t>

        <t>Discovery Request messages MUST be sent by a WTP in the Discover
		state after waiting for a random delay less than MaxDiscoveryInterval,
		after a WTP first comes up or is (re)initialized.  A WTP MUST send no
		more than the maximum of MaxDiscoveries Discovery Request messages,
		waiting for a random delay less than MaxDiscoveryInterval between each
		successive message.</t>

        <t>This is to prevent an explosion of WTP Discovery Request messages. 
		An example of this occurring is when many WTPs are powered on at the
		same time.</t>

<!-- REMOVED due to Issue 20
        <t>Discovery Request messages MUST be sent by a WTP when no Echo
		Response messages are received for NeighborDeadInterval and the WTP
		returns to the Idle state.  Discovery Request messages are sent after
		NeighborDeadInterval. They MUST be sent after waiting for a random delay
		less than MaxDiscoveryInterval.  A WTP MAY send up to a maximum of
		MaxDiscoveries Discovery Request messages, waiting for a random delay
		less than MaxDiscoveryInterval between each successive message. </t>
-->

        <t>If a Discovery Response message is not received after sending the
		maximum number of Discovery Request messages, the WTP enters the Sulking
		state and MUST wait for an interval equal to SilentInterval before
		sending further Discovery Request messages.</t>

    	<t>Upon receiving a Discovery Request message, the AC will respond with
		a Discovery Response message sent to the address in the source address
		of the received Discovery Request message. Once a Discovery Response
		has been received, if the WTP decides to establish a session with the
		responding AC, it SHOULD perform an MTU discovery, using the process
		described in <xref target="MTU Discovery"></xref>.</t>
<!-- Removed the following text since we will not be using RFC 4821 
		use the Discovery Request/Response messages for
		the purposes of MTU Discovery. In this instance, the Discovery messages
		are used for probing purposes, as defined in
		<xref target="RFC4821"></xref>, and use the MTU Discovery Padding
		message element (see <xref target="MTU-Discovery-Padding"></xref>) for
		padding purposes.</t>
-->
		<t>It is possible for the AC to receive a clear text Discovery Request message
		while a DTLS session is already active with the WTP. This is most likely
		the case if the WTP has rebooted, perhaps due to a software or power
		failure, but could also be caused by a DoS attack. In such cases, any
		WTP state, including the state machine instance, MUST NOT be cleared
		until another DTLS session has been successfully established,
		communicated via the DTLSSessionEstablished DTLS notification (see
		<xref target="DTLS-to-CAPWAP-Notifications"></xref>).</t>

		<t>The binding specific WTP Radio Information message element
		(see <xref target="Wireless Binding Definition"></xref>) is included in
		the Discovery Request message to advertise WTP support for one or more
		CAPWAP bindings.</t>

    	<t>The Discovery Request message is sent by the WTP when in the
		Discovery state. The AC does not transmit this message.</t>

    	<t>The following message elements MUST be included in the Discovery
		Request message:</t>
		<list style="symbols">
			<t>Discovery Type, see <xref target="Discovery-Type"></xref> </t>
			<t>WTP Board Data, see <xref target="WTP-Board-Data"></xref> </t>
			<t>WTP Descriptor, see <xref target="WTP-Descriptor"></xref> </t>
			<t>WTP Frame Tunnel Mode, see <xref target="WTP-Frame-Tunnel-Mode"></xref> </t>
			<t>WTP MAC Type, see <xref target="WTP-MAC-Type"></xref> </t>
			<t>WTP Radio Information message element(s) that the WTP supports;
			These are defined by the individual link layer CAPWAP Binding
			Protocols (see <xref target="Wireless Binding Definition"></xref>).</t>
		</list>

    	<t>The following message elements MAY be included in the Discovery
		Request message:</t>
		<list style="symbols">
			<t>MTU Discovery Padding, see
			<xref target="MTU-Discovery-Padding"></xref> </t>
			<t>Vendor Specific Payload, see
			<xref target="Vendor Specific Payload"></xref> </t>
		</list>

    </section> <!-- Discovery Request Message -->

    <section anchor="Discovery Response" title="Discovery Response Message">
        <t>The Discovery Response message provides a mechanism for an AC to
		advertise its services to requesting WTPs.</t>

    	<t>When a WTP receives a Discovery Response message, it MUST wait for an interval not 
        less than DiscoveryInterval for receipt of additional Discovery Response messages.  
        After the DiscoveryInterval elapses, the WTP enters the DTLS-Init state and 
        selects one of the ACs that sent a Discovery Response message and send a DTLS Handshake to that AC.</t>

		<t>One or more binding-specific WTP Radio Information message elements
		(see <xref target="Wireless Binding Definition"></xref>) are included in
		the Discovery Request message to advertise AC support for the CAPWAP bindings.
		The AC MAY include only the bindings it shares in common with the WTP,
		known through the WTP Radio Information message elements received in the
		Discovery Request message, or it MAY include all of the bindings supported. The
		WTP MAY use the supported bindings in its AC decision process. Note that
		if the WTP joins an AC that does not support a specific CAPWAP binding,
		service for that binding MUST NOT be provided by the WTP.</t>

    	<t>The Discovery Response message is sent by the AC when in the Idle state.
		The WTP does not transmit this message.</t>

    	<t>The following message elements MUST be included in the Discovery Response Message:</t>

        <list style="symbols">
			<t>AC Descriptor, see <xref target="AC-Descriptor"></xref> </t>
			<t>AC Name, see <xref target="AC-Name"></xref> </t>
			<t>WTP Radio Information message element(s) that the AC supports;
			these are defined by the individual link layer CAPWAP Binding
			Protocols (see <xref target="Wireless Binding Definition"></xref>
			for more information).</t>

			<t>One of the following message elements MUST be included in the
			Discovery Response Message:</t>

			<list style="symbols">
			<t>CAPWAP Control IPv4 Address, see
			<xref target="CAPWAP-Control-IPv4-Address"></xref> </t>
			<t>CAPWAP Control IPv6 Address, see
			<xref target="CAPWAP-Control-IPv6-Address"></xref> </t>
			</list>
		</list>

		<t>The following message elements MAY be included in the Discovery
		Response message:</t>
			<list style="symbols">
			<t>Vendor Specific Payload, see
			<xref target="Vendor Specific Payload"></xref> </t>
			</list>

    </section> <!-- Discovery Response -->

    <section anchor="Primary Discovery Request" title="Primary Discovery Request Message">
		<t>The Primary Discovery Request message is sent by the WTP to:</t>
		<list style="symbols">
		<t>determine whether its preferred (or primary) AC is available, or</t>
		<t>perform a Path MTU Discovery (see Section 3.5).</t>
		</list>


        <t>A Primary Discovery Request message is sent by a WTP when it has a
		primary AC configured, and is connected to another AC. This generally
		occurs as a result of a failover, and is used by the WTP as a means to
		discover when its primary AC becomes available. Since the WTP only has a
		single instance of the CAPWAP state machine, the Primary Discovery
		Request is sent by the WTP when in the Run state. The AC does not
		transmit this message.</t>

		<t>The frequency of the Primary Discovery Request messages should be no
		more often than the sending of the Echo Request message.</t>

        <t>Upon receipt of a Primary Discovery Request message, the AC responds with a
		Primary Discovery Response message sent to the address in the source
		address of the received Primary Discovery Request message.</t>

    	<t>The following message elements MUST be included in the Primary
		Discovery Request message.</t>

		<list style="symbols">
		<t>Discovery Type, see <xref target="Discovery-Type"></xref> </t>
		<t>WTP Board Data, see <xref target="WTP-Board-Data"></xref> </t>
		<t>WTP Descriptor, see <xref target="WTP-Descriptor"></xref> </t>
		<t>WTP Frame Tunnel Mode, see <xref target="WTP-Frame-Tunnel-Mode"></xref> </t>
		<t>WTP MAC Type, see <xref target="WTP-MAC-Type"></xref> </t>
		<t>WTP Radio Information message element(s) that the WTP supports; these are defined
		by the individual link layer CAPWAP Binding Protocols (see
		<xref target="Wireless Binding Definition"></xref> for more
		information).</t>
		</list>

    	<t>The following message elements MAY be included in the Primary
		Discovery Request message:</t>
		<list style="symbols">
			<t>MTU Discovery Padding, see
			<xref target="MTU-Discovery-Padding"></xref> </t>
			<t>Vendor Specific Payload, see
			<xref target="Vendor Specific Payload"></xref> </t>
		</list>

    </section> <!-- Primary Discovery Request -->

    <section anchor="Primary Discovery Response" title="Primary Discovery Response">
        <t>The Primary Discovery Response message enables an AC to advertise
		its availability and services to requesting WTPs that are configured to
		have the AC as its primary AC.</t>

        <t>The Primary Discovery Response message is sent by an AC after receiving a
		Primary Discovery Request message.</t>

    	<t>When a WTP receives a Primary Discovery Response message, it may establish
		a CAPWAP protocol connection to its primary AC, based on the configuration of the
		WTP Fallback Status message element on the WTP.</t>

    	<t>The Primary Discovery Response message is sent by the AC when in the Idle
		state. The WTP does not transmit this message.</t>

    	<t>The following message elements MUST be included in the Primary Discovery Response message.</t>

        <list style="symbols">
			<t>AC Descriptor, see <xref target="AC-Descriptor"></xref> </t>
			<t>AC Name, see <xref target="AC-Name"></xref> </t>
			<t>WTP Radio Information message element(s) that the AC supports; These are defined
			by the individual link layer CAPWAP Binding Protocols (see
			<xref target="Wireless Binding Definition"></xref> for more
			information).</t>
		</list>

    	<t>One of the following message elements MUST be included in the
		Discovery Response Message:</t>
        <list style="symbols">
			<t>CAPWAP Control IPv4 Address, see <xref target="CAPWAP-Control-IPv4-Address"></xref> </t>
			<t>CAPWAP Control IPv6 Address, see <xref target="CAPWAP-Control-IPv6-Address"></xref> </t>
		</list>

    	<t>The following message elements MAY be included in the Primary
		Discovery Response message:</t>
		<list style="symbols">
			<t>Vendor Specific Payload, see
			<xref target="Vendor Specific Payload"></xref> </t>
		</list>

   </section> <!-- Primary Discovery Response -->

	</section> <!-- CAPWAP Discovery Operations -->
       
   <section anchor="CAPWAP Join Operations" title="CAPWAP Join Operations">

    <t>The Join Request message is used by a WTP to request service from an AC
	after a DTLS connection is established to that AC. The Join Response message
	is used by the AC to indicate that it will or will not provide
	service.</t>

    <section anchor="Join Request" title="Join Request">
	<t>The Join Request message is used by a WTP to request service through the
	AC.  If the WTP is performing the optional AC Discovery process (see <xref
	target="AC Discovery"/>), the join process occurs after the WTP has received
	one or more Discovery Response messages. During the Discovery process, an AC
	MAY return more than one CAPWAP Control IPv4 Address or CAPWAP Control IPv6
	Address message elements. When more than one such message element is
	returned, the WTP SHOULD perform "load balancing" by choosing the interface
	that is servicing the least number of WTPs (known through the WTP Count
	field of the message element). Note, however, that other load balancing
	algorithms are also permitted. Once the WTP has determined its preferred AC,
	and its associated interface, to which to connect, it establishes the DTLS
	session, and transmits the Join Request over the secured control channel.
	When an AC receives a Join Request message it responds with a Join Response
	message.</t>

<!--
	<t>The WTP includes a pseudo-random 64 bit Session ID in the CAPWAP Header
	(see <xref target="CAPWAP Header"></xref>). The Session ID MUST remain 
	the same across all future CAPWAP control and data packets sent by both the
	WTP and the AC to identify the specific CAPWAP session. The WTP and AC MUST
	ensure that all future control and data packets sent from the respective
	IP address and UDP port numbers have the same Session ID.</t>
-->

	<t>Upon completion of the DTLS handshake and receipt of
	the DTLSEstablished notification, the WTP sends the Join Request message to the AC.
	When the AC is notified of the DTLS session establishment, it does not clear
	the WaitDTLS timer until it has received the Join Request message, at which
	time it sends a Join Response message to the WTP,
	indicating success or failure.</t>

	<t>One or more WTP Radio Information message elements (see
	<xref target="Wireless Binding Definition"></xref>) are included in the
	Join Request to request service for the CAPWAP bindings by the AC.
	Including a binding that is unsupported by the AC will result in a failed
	Join Response.</t>

	<t>If the AC rejects the Join Request, it sends a Join Response message with
	a failure indication and initiates an abort of the DTLS session via the 
	DTLSAbort command.</t>

	<t>If an invalid (i.e., malformed) Join Request message is received, the
	message MUST be silently discarded by the AC. No response is sent to the
	WTP. The AC SHOULD log this event. </t>

	<t>The Join Request is sent by the WTP when in the Join State.
	The AC does not transmit this message.</t>

	<t>The following message elements MUST be included in the Join Request
	message.</t>

	<list style="symbols">

	<t>Location Data, see <xref target="Location-Data"></xref> </t>
	<t>WTP Board Data, see <xref target="WTP-Board-Data"></xref> </t>
	<t>WTP Descriptor, see <xref target="WTP-Descriptor"></xref> </t>
	<t>WTP Name, see <xref target="WTP-Name"></xref> </t>	
	<t>Session ID, see <xref target="Session ID"></xref> </t>	
	<t>WTP Frame Tunnel Mode, see <xref target="WTP-Frame-Tunnel-Mode"></xref> </t>
	<t>WTP MAC Type, see <xref target="WTP-MAC-Type"></xref> </t>
	<t>WTP Radio Information message element(s) that the WTP supports; these are defined
	by the individual link layer CAPWAP Binding Protocols (see
	<xref target="Wireless Binding Definition"></xref> for more
	information).</t>
	<t>ECN Support, see <xref target="ECN Support"></xref> </t>
	</list>

	<t>At least one of the following message element MUST be included in the
	Join Request message.</t>
	<list style="symbols">
		<t>CAPWAP Local IPv4 Address, see <xref target="CAPWAP-Local-IPv4-Address"></xref> </t>
		<t>CAPWAP Local IPv6 Address, see <xref target="CAPWAP-Local-IPv6-Address"></xref> </t>

	<!--
		<t>WTP IPv4 IP Address, see <xref target="WTP-IPv4-IP-Address"></xref> </t>
		<t>WTP IPv6 IP Address, see <xref target="WTP-IPv6-IP-Address"></xref> </t>
	-->
	</list>

	<t>The following message element MAY be included in the Join Request message.</t>
	<list style="symbols">
		<t>CAPWAP Transport Protocol, see <xref target="CAPWAP Transport Protocol"></xref> </t>
		<t>Maximum Message Length, see <xref target="Maximum-Message-Length"></xref> </t>
		<t>WTP Reboot Statistics, see <xref target="WTP-Reboot-Statistics"></xref> </t>		
<!--
		<t>WTP IPv4 IP Address, see <xref target="WTP-IPv4-IP-Address"></xref> </t>
		<t>WTP IPv6 IP Address, see <xref target="WTP-IPv6-IP-Address"></xref> </t>
-->
		<t>Vendor Specific Payload, see
		<xref target="Vendor Specific Payload"></xref> </t>
	</list>	

  </section> <!-- Join Request  -->                                                          

	<section anchor="Join Response" title="Join Response">
	<t>The Join Response message is sent by the AC to indicate to a WTP that it
	is capable and willing to provide service to the WTP.</t>

	<t>The WTP, receiving a Join Response message, checks for success or failure.
	If the message indicates success, the WTP clears the WaitDTLS timer for the
	session and proceeds to the Configure state.</t>

	<t>If the WaitDTLS Timer expires prior to reception of the Join Response
	message, the WTP MUST terminate the handshake, deallocate session
	state and initiate the DTLSAbort command.</t>

	<t>If an invalid (malformed) Join Response message is received, the WTP SHOULD
	log an informative message detailing the error. This error MUST be
	treated in the same manner as AC non-responsiveness. 
	The WaitDTLS timer will eventually expire, and the WTP
	MAY (if it is so configured) attempt to join a new AC.</t>

	<t>If one of the WTP Radio Information message elements (see
	<xref target="Wireless Binding Definition"></xref>) in the Join Request message
	requested support for a CAPWAP binding that the AC does not support, the
	AC sets the Result Code message element to "Binding Not Supported".</t>

	<t>The AC includes the Image Identifier message element to indicate
	the software version it expects the WTP to run. This information is used to 
	determine whether the WTP MUST change its currently running firmware
	image or download a new version (see
	<xref target="Image Data Request"></xref>).</t>

	<t>The Join Response message is sent by the AC when in the Join State.
	The WTP does not transmit this message.</t>

	<t>The following message elements MUST be included in the Join Response message.</t>

	<list style="symbols">
		<t>Result Code, see <xref target="Result-Code"></xref> </t>
		<t>AC Descriptor, see <xref target="AC-Descriptor"></xref> </t>
		<t>AC Name, see <xref target="AC-Name"></xref> </t>
		<t>WTP Radio Information message element(s) that the AC supports; these are defined
		by the individual link layer CAPWAP Binding Protocols (see
		<xref target="Wireless Binding Definition"></xref>).</t>
		<t>ECN Support, see <xref target="ECN Support"></xref> </t>
	</list>

   	<t>One of the following message elements MUST be included in the
	Join Response Message:</t>
	<list style="symbols">
		<t>CAPWAP Control IPv4 Address, see <xref target="CAPWAP-Control-IPv4-Address"></xref> </t>
		<t>CAPWAP Control IPv6 Address, see <xref target="CAPWAP-Control-IPv6-Address"></xref> </t>
	</list>

   	<t>One of the following message elements MUST be included in the
	Join Response Message:</t>
	<list style="symbols">
		<t>CAPWAP Local IPv4 Address, see <xref target="CAPWAP-Local-IPv4-Address"></xref> </t>
		<t>CAPWAP Local IPv6 Address, see <xref target="CAPWAP-Local-IPv6-Address"></xref> </t>
	</list>

	<t>The following message elements MAY be included in the Join Response message.</t>

	<list style="symbols">
		<t>AC IPv4 List, see <xref target="AC-IPv4-List"></xref> </t>
		<t>AC IPv6 List, see <xref target="AC-IPv6-List"></xref> </t>
		<t>CAPWAP Transport Protocol, see <xref target="CAPWAP Transport Protocol"></xref> </t>
		<t>Image Identifier, see <xref target="Image-Identifier"></xref> </t>
		<t>Maximum Message Length, see <xref target="Maximum-Message-Length"></xref> </t>
		<t>Vendor Specific Payload, see
		<xref target="Vendor Specific Payload"></xref> </t>
	</list>	
   </section> <!-- Join Response  -->
    
    </section> <!-- CAPWAP Join Operations -->    

   <section anchor="Control Channel Management" title="Control Channel Management">

    <t>The Control Channel Management messages are used by the WTP and AC to
	maintain a control communication channel. CAPWAP Control messages, such as the
	WTP Event Request message sent from the WTP to the AC indicate to the AC that the
	WTP is operational. When such control messages are not being sent,
	the Echo Request and Echo Response messages are used to maintain the control
	communication channel. </t>
	
    <section anchor="Echo Request" title="Echo Request">
        <t>The Echo Request message is a keep-alive mechanism for CAPWAP
		control messages.</t>

        <t>Echo Request messages are sent periodic