<?xml version="1.0" encoding="US-ASCII" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  ]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no"?>

<rfc number="7692"
     category="std"
     submissionType="IETF"
     consensus="yes"
     ipr="trust200902">

  <front>
    <title>Compression Extensions for WebSocket</title>
    <author
       initials="T.Y."
       surname="Yoshino"
       fullname="Takeshi Yoshino">
      <organization>Google, Inc.</organization>
      <address>
        <email>tyoshino@google.com</email>
      </address>
    </author>

    <date month="December" year="2015"/>

    <area>Applications</area>
    <workgroup>HyBi Working Group</workgroup>

<abstract>
<t>This document defines a framework for creating WebSocket extensions that
add compression functionality to the WebSocket Protocol. An extension based on
this framework compresses the payload data portion of WebSocket data messages
on a per-message basis using parameters negotiated during the opening handshake.
This framework provides a general method for applying a compression algorithm 
to the contents of WebSocket messages. Each compression algorithm has to be
defined in a document defining the
extension by specifying the parameter negotiation and the payload transformation
algorithm in detail. This document also specifies one specific compression 
extension using the DEFLATE algorithm.</t>
</abstract>

</front>


  <middle>
    <section title="Introduction">
      <t>
        This document specifies a framework for adding compression functionality to the WebSocket Protocol <xref target="RFC6455" />.
        The framework specifies how to define WebSocket Per-Message Compression Extensions (PMCEs) for a compression algorithm based on the extension concept of the WebSocket Protocol specified in Section 9 of <xref target="RFC6455" />.
        A WebSocket client and a peer WebSocket server negotiate the use of a PMCE and determine the parameters required to configure the compression algorithm during the WebSocket opening handshake.
        The client and server can then exchange data messages whose frames contain compressed data in the payload data portion.
      </t>

      <t>
        This framework only specifies a general method for applying a compression algorithm to the contents of WebSocket messages.
        Each individual PMCE has to be specified in a document describing in detail how to negotiate the configuration parameters for the specific compression algorithm used by that PMCE and how to transform (compress and decompress) data in the payload data portion.
      </t>

      <t>
        A WebSocket client may offer multiple PMCEs during the WebSocket opening handshake.
        A peer WebSocket server receiving the offer may choose to accept the preferred PMCE or decline all of them.
        PMCEs use the RSV1 bit of the WebSocket frame header to indicate whether a message is compressed or not so that an endpoint can choose not to compress messages with incompressible contents.
      </t>

      <t>
        This document also specifies one specific PMCE based on the DEFLATE <xref target="RFC1951" /> algorithm.
        The DEFLATE algorithm is widely available on various platforms, and its overhead is small.



        The extension name of this PMCE is "permessage-deflate".
        To align the end of compressed data to an octet boundary, this extension uses the algorithm described in Section 2.1 of <xref target="RFC1979"/>.
        Endpoints can take over the LZ77 sliding window <xref target="LZ77" /> used to build frames for previous messages to achieve a better compression ratio.
        For resource-limited devices, this extension provides parameters to limit memory usage for compression context.
      </t>
    </section>

    <section title="Conformance Requirements and Terminology">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119" />.
      </t>

      <t>
        Requirements phrased in the imperative as part of algorithms (such as "strip any leading space characters" or "return false and abort these steps") are to be interpreted with the meaning of the key word ("MUST", "SHOULD", "MAY", etc.) used in introducing the algorithm.
      </t>

      <t>
        Conformance requirements phrased as algorithms or specific steps can be implemented in any manner, so long as the end result is equivalent.
        In particular, the algorithms defined in this specification are
	intended to be easy to understand and are not intended to be performant.
      </t>

      <t>
        This document references the procedure to <spanx style="emph">Fail the WebSocket Connection</spanx>.
        This procedure is defined in Section 7.1.7 of <xref target="RFC6455" />.
      </t>

      <t>
        This document references the event that <spanx style="emph">The WebSocket Connection is Established</spanx> and the event that <spanx style="emph">A WebSocket Message Has Been Received</spanx>.
        These events are defined in Sections 4.1 and 6.2, respectively, of <xref target="RFC6455" />.
      </t>

      <t>
        This document uses the Augmented Backus-Naur Form (ABNF) notation of <xref target="RFC5234" />.
        The DIGIT (decimal 0-9) rule is included by reference, as defined in the Appendix B.1 of <xref target="RFC5234" />.
      </t>
    </section>

    <section title="Complementary Terminology">
      <t>
        This document defines some terms about WebSocket and WebSocket extension mechanisms that are underspecified or not defined at all in <xref target="RFC6455" />.
      </t>

      <t>data message - a message consisting of data frames as defined in Section 5.6 of <xref target="RFC6455" />.
      </t>

      <t>message payload (or payload of a message) - the concatenation of the payload data portion of all data frames (see Section 6.2 of <xref target="RFC6455"/>) representing a single message.
      </t>

      <t>next extension in use after extension X - the next extension listed after X in the <spanx style="verb">Sec-WebSocket-Extensions</spanx> header in the server's opening handshake as defined in Section 9.1 of <xref target="RFC6455" />.
        Such an extension is applied to outgoing data from the application
	right after X on the sender side but is applied right before X to
	incoming data from the underlying transport.
      </t>

      <t>extension in use preceding extension X - the extension listed
	right before X in the <spanx
	style="verb">Sec-WebSocket-Extensions</spanx> header in the server's opening handshake.
        Such an extension is applied to outgoing data from the application
	right before X on the sender side but is applied right after X to incoming data from the underlying transport.
      </t>

      <t>extension negotiation offer - each element in the <spanx style="verb">Sec-WebSocket-Extensions</spanx> header in the client's opening handshake.
      </t>

      <t>extension negotiation response - each element in the <spanx style="verb">Sec-WebSocket-Extensions</spanx> header in the server's opening handshake.
      </t>

      <t>corresponding extension negotiation response for an extension
	negotiation offer - an extension negotiation response that a server sends back to the peer client containing the same extension name as the offer and meeting the requirements represented by the offer.
      </t>

      <t>Accepting an extension negotiation offer - including a corresponding extension negotiation response for the offer in the <spanx style="verb">Sec-WebSocket-Extensions</spanx> header in the server's opening handshake.
      </t>

      <t>Declining an extension negotiation offer - not including a corresponding extension negotiation response for the offer in the <spanx style="verb">Sec-WebSocket-Extensions</spanx> header in the server's opening handshake.
      </t>


    </section>

    <section title="WebSocket Per-Message Compression Extension">
      <t>
        WebSocket PMCEs are extensions to the WebSocket Protocol enabling compression functionality.
        PMCEs are built based on the extension concept of the WebSocket
	Protocol specified in Section 9 of <xref target="RFC6455" />.
        PMCEs are individually defined for each compression algorithm to be
	implemented and are registered in the "WebSocket Extension Name
	Registry" created in Section 11.4 of <xref target="RFC6455" />.
        Each PMCE referring to this framework MUST define the following:

        <list style="symbols">
          <t>
            The extension name of the PMCE and any applicable extension
	    parameters that MUST be included in the <spanx
	    style="verb">Sec-WebSocket-Extensions</spanx> 
	    header during the extension negotiation offer/response.
          </t>

          <t>
            How to interpret the extension parameters exchanged during the
	    opening handshake.
          </t>

          <t>
            How to transform the payload of a message.
          </t>
        </list>
      </t>

      <t>
        One PMCE is defined in <xref target="deflate" /> of this document and is registered in <xref target="iana" />.
        Other PMCEs may be defined in the future in other documents.
      </t>

      <t>
        <xref target="negotiation" /> describes the basic extension negotiation process.
        <xref target="framing" /> describes how to apply the compression algorithm with negotiated parameters to the contents of WebSocket messages.
      </t>
    </section>

    <section title="Extension Negotiation" anchor="negotiation">
      <t>
        To offer use of a PMCE, a client MUST include the extension name of the PMCE in the <spanx style="verb">Sec-WebSocket-Extensions</spanx> header field of its opening handshake of the WebSocket connection.
        Extension parameters are used to specify the PMCE offer in detail.
        For example, a client lists its preferred configuration parameter values for the compression algorithm of the PMCE.
        A client may also offer multiple PMCE choices to the server by including multiple elements in the <spanx style="verb">Sec-WebSocket-Extensions</spanx> header, one for each PMCE offered.
        This set of elements MAY include multiple PMCEs with the same extension name to offer the possibility to use the same algorithm with different configuration parameters.
        The order of elements is important as it specifies the client's preference.
        An element preceding another element has higher preference.
        It is recommended that a server accepts PMCEs with higher preference if the server supports them.
      </t>

      <t>
        A PMCE negotiation offer provides requests and/or hints to the server.
      </t>

      <t>
        A request in a PMCE negotiation offer indicates constraints on the server's behavior that must be satisfied if the server accepts the offer.
        For example, suppose that a server sends data compressed with the DEFLATE algorithm to a client.
        The server must keep the original bytes of data that it recently compressed and sent to the client.
        The client must keep the result of decompressing the bytes of data that it recently received from the server.
        The amount of bytes of data kept is called the LZ77 window size.
        The LZ77 window size of the client must not be less than the LZ77 window size of the server.
        In a PMCE negotiation offer, the client MUST inform the server of its LZ77 window size so that the server uses an LZ77 window size that is not greater than the LZ77 window size of the client.
        This restriction on the LZ77 window size is an example of a request in a PMCE negotiation offer.
      </t>

      <t>
        A hint in a PMCE negotiation offer provides information about the client's behavior that the server may either safely ignore or refer to when the server decides its behavior.
        For example, suppose that a client sends data compressed with the DEFLATE algorithm to a server.
        The client must keep the original bytes of data that it recently compressed and sent to the server.
        The server must keep the result of decompressing the bytes of data that it recently received from the client.
        The LZ77 window size of the server must not be less than the LZ77 window size of the client.

   In a PMCE negotiation offer, the
   client MAY inform the server of the maximum LZ77 window size the client can
   afford
   so that the server can choose to use an LZ77 window size that is not
   greater than the maximum size of the client.
        This information is an example of a hint in a PMCE negotiation offer.
        It's waste of memory to use an LZ77 window size greater than the LZ77 window size the client actually uses.
        Using the hint, the server can avoid the waste of memory.
        Since the hint itself doesn't specify the constraints on the endpoints, the server must use the "agreed parameters" (defined below) to explicitly ask the client not to use an LZ77 window size greater than the LZ77 window size of the server.
      </t>

      <t>
        To accept the use of an offered PMCE, a server MUST include the extension name of the PMCE in the <spanx style="verb">Sec-WebSocket-Extensions</spanx> header field of its opening handshake of the WebSocket connection.



        Extension parameters represent the detailed configuration parameters for the PMCE to use.
        These extension parameters and their values are called "agreed parameters".
        The element MUST represent a PMCE that is fully supported by the server.
        The contents of the element don't need to be exactly the same as those of the received extension negotiation offers.
        For example, suppose that a server received a PMCE extension negotiation offer with an extension parameter "X" indicating that the client can enable an optional feature named X.
        The server may accept the PMCE offer with an element without the
	extension parameter "X", meaning that the server chose not to enable
	the feature X.
        In this case, the offer contains the extension parameter "X", but the "agreed parameters" don't contain the extension parameter "X".
      </t>

      <t>
        "Agreed parameters" must represent how the requests and hints in the
	client's extension negotiation offer have been handled in addition to
	the server's requests and hints on the client's behavior, so that the
	client can configure its behavior without identifying exactly which
	PMCE extension negotiation offer has been accepted.

      </t>

      <t>
        For example, if a client sends an extension negotiation offer that includes a parameter "enable_compression" and another without this parameter, the server accepts the former and informs the client by sending back an element that includes parameter(s) acknowledging "enable_compression".
        The name of the acknowledging parameter doesn't need to be exactly the same as the offer.
        For example, two parameters, "enable_strong_compression" and
	"enable_weak_compression", may be defined as acknowledging parameters
	for "enable_compression".

      </t>

      <t>
        Compression features can be applied differently for each direction.
        For such features, the acknowledging parameter and the parameter in the reverse direction must be chosen to distinguish them.
        For example, in order to make parameters distinguishable, a "server_" prefix can be added to parameters affecting data sent from a server, and a "client_" prefix can be added to parameters affecting data sent from a client.
      </t>

      <t>
        A server MUST NOT accept a PMCE extension negotiation offer together with another extension if the PMCE will conflict with the extension on their use of the RSV1 bit.
        A client that received a response accepting a PMCE extension negotiation offer together with such an extension MUST <spanx style="emph">Fail the WebSocket Connection</spanx>.
      </t>

      <t>
        A server MUST NOT accept a PMCE extension negotiation offer together with another extension if the PMCE will be applied to the output of the extension and any of the following conditions applies to the extension:

        <list style="symbols">
          <t>
            The extension requires the boundary of frames to be preserved between the output from the extension at the sender and the input to the extension at the receiver.
          </t>

          <t>
            The extension uses the <spanx style="verb">Extension data</spanx> field or any of the reserved bits on the WebSocket header as a per-frame attribute.
          </t>
        </list>

        A client that receives a response accepting a PMCE extension negotiation offer together with such an extension MUST <spanx style="emph">Fail the WebSocket Connection</spanx>.
      </t>

      <t>
        A server declining all offered PMCEs MUST NOT include any element with PMCE names.
        If a server responds with no PMCE element in the <spanx style="verb">Sec-WebSocket-Extensions</spanx> header, both endpoints proceed without per-message compression once <spanx style="emph">the WebSocket Connection is established</spanx>.
      </t>

      <t>
        If a server gives an invalid response, such as accepting a PMCE that the client did not offer, the client MUST <spanx style="emph">Fail the WebSocket Connection</spanx>.
      </t>

      <t>
        If a server responds with a valid PMCE element in the <spanx style="verb">Sec-WebSocket-Extensions</spanx> header and <spanx style="emph">the WebSocket Connection is established</spanx>, both endpoints MUST use the algorithm described in <xref target="framing" /> and the message payload transformation (compressing and decompressing) procedure of the PMCE configured with the "agreed parameters" returned by the server to exchange messages.
      </t>

      <section title="General Negotiation Flow" anchor="generalnegotiation">
        <t>
          This section describes a general negotiation flow.
          How to handle parameters in detail must be specified in the document specifying the PMCE.
        </t>

        <t>
          A client makes an offer including parameters identifying the following:
          <list style="symbols">
            <t>Hints about how the client is planning to compress data</t>
            <t>Requests about how the server compresses data</t>
            <t>Limitations concerning the client's compression functionality</t>
          </list>
          The peer server makes a determination of its behavior based on these parameters.
          If the server can and wants to proceed with this PMCE enabled, the server responds to the client with parameters identifying the following:
          <list style="symbols">
            <t>Requests about how the client compresses data</t>
            <t>How the server will compress data</t>
          </list>
          Based on these parameters received from the server, the client determines its behavior and if it can and wants to proceed with this PMCE enabled.
          Otherwise, the client starts the closing handshake with close code 1010.
        </t>
      </section>

      <section title="Negotiation Examples">
        <t>
          The following are example values for the <spanx style="verb">Sec-WebSocket-Extensions</spanx> header offering PMCEs;
          permessage-foo and permessage-bar in the examples are
	  hypothetical extension names of PMCEs for the compression algorithm foo and bar.

          <list style="symbols">
            <t>
              Offer the permessage-foo.

              <figure>
                <artwork>
       permessage-foo
                </artwork>
              </figure>
            </t>

            <t>
              Offer the permessage-foo with a parameter x with a value of 10.

              <figure>
                <artwork>
       permessage-foo; x=10
                </artwork>
              </figure>

              The value may be quoted.

              <figure>
                <artwork>
       permessage-foo; x="10"
                </artwork>
              </figure>
            </t>

            <t>
              Offer the permessage-foo as first choice and the permessage-bar as a fallback plan.

              <figure>
                <artwork>
       permessage-foo, permessage-bar
                </artwork>
              </figure>
            </t>

            <t>
              Offer the permessage-foo with a parameter use_y, which enables a
	      feature y as first choice, and the permessage-foo without the
	      use_y parameter as a fallback plan.


              <figure>
                <artwork>
       permessage-foo; use_y, permessage-foo
                </artwork>
              </figure>
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title="Framing" anchor="framing">
      <t>
        PMCEs operate only on data messages.
      </t>

      <t>
        This document allocates the RSV1 bit of the WebSocket header for PMCEs
	and calls the bit the <spanx style="verb">Per-Message
	Compressed</spanx> bit.

        On a WebSocket connection where a PMCE is in use, this bit indicates whether a message is compressed or not.
      </t>

      <t>
        A message with the <spanx style="verb">Per-Message Compressed</spanx> bit set on the first fragment of the message is called a "compressed message".
        Frames of a compressed message have compressed data in the payload data portion.
        An endpoint receiving a compressed message decompresses the concatenation of the compressed data of the frames of the message by following the decompression procedure specified by the PMCE in use.
        The endpoint uses the bytes corresponding to the application data
	portion in this decompressed data for the <spanx style="emph">A
	WebSocket Message Has Been Received</spanx> event instead of the
	received data as is.
      </t>

      <t>
        A message with the <spanx style="verb">Per-Message Compressed</spanx> bit unset on the first fragment of the message is called an "uncompressed message".
        Frames of an uncompressed message have uncompressed original data as is in the payload data portion.
        An endpoint receiving an uncompressed message uses the concatenation
	of the application data portion of the frames of the message as is for the <spanx style="emph">A WebSocket Message Has Been Received</spanx> event.
      </t>

      <section title="Compression">
        <t>
          An endpoint MUST use the following algorithm to send a message in the form of a compressed message.

          <list style="numbers">
            <t>
              Compress the message payload of the original message by following the compression procedure of the PMCE.
              The original message may be input from the application layer or
	      output of another WebSocket extension, depending on which
	      extensions were negotiated.

            </t>

            <t>
              Process the compressed data as follows:

              <list style="symbols">


<t>

                  If this PMCE is the last extension to process outgoing
		  messages, build frame(s) using the compressed data
		  instead of the original data for the message payload,
		  set the <spanx style="verb">Per-Message Compressed</spanx>
		  bit of the first frame, and then send the frame(s) as described
		  in Section 6.1 of <xref target="RFC6455"/>.
                </t>

                <t>
                  Otherwise, pass the transformed message payload and modified header values, including the <spanx style="verb">Per-Message Compressed</spanx> bit value set to 1, to the next extension after the PMCE.
                  If the extension expects frames for input, build a frame for the message and pass it.
                </t>
              </list>
            </t>
          </list>
        </t>

        <t>
          An endpoint MUST use the following algorithm to send a message in the form of an uncompressed message.

          <list style="numbers">
            <t>
              Process the original data as follows:

              <list style="symbols">


                <t>
                  If this PMCE is the last extension to process outgoing
		  messages, build frame(s) using the original data for the
		  payload data portion as is, unset the <spanx
		  style="verb">Per-Message Compressed</spanx> bit of the first
		  frame, and then send the frame(s) as described in Section 6.1 of
		  <xref target="RFC6455"/>.
                </t>

                <t>
                  Otherwise, pass the message payload and header values to the
		  next extension after the PMCE as is.
                  If the extension expects frames for input, build a frame for the message and pass it.
                </t>
              </list>
            </t>
          </list>
        </t>

        <t>
          An endpoint MUST NOT set the <spanx style="verb">Per-Message Compressed</spanx> bit of control frames and non-first fragments of a data message.
          An endpoint receiving such a frame MUST <spanx style="emph">Fail the WebSocket Connection</spanx>.
        </t>

        <t>
          PMCEs do not change the opcode field.
          The opcode of the first frame of a compressed message indicates the opcode of the original message.
        </t>

        <t>
          The payload data portion in frames generated by a PMCE is not subject to the constraints for the original data type.
          For example, the concatenation of the output data corresponding to the application data portion of frames of a compressed text message is not required to be valid UTF-8.
          At the receiver, the payload data portion after decompression is subject to the constraints for the original data type again.
        </t>
      </section>

      <section title="Decompression">
        <t>
          An endpoint MUST use the following algorithm to receive a message in the form of a compressed message.

          <list style="numbers">
            <t>
              Concatenate the payload data portion of the received frames of the compressed message.
              The received frames may be direct input from the underlying transport or output of another WebSocket extension, depending on which extensions were negotiated.
            </t>

            <t>
              Decompress the concatenation by following the decompression procedure of the PMCE.
            </t>

            <t>
              Process the decompressed message as follows:

              <list style="symbols">
                <t>
                  If this is the last extension to process incoming messages, deliver the <spanx style="emph">A WebSocket Message Has Been Received</spanx> event to the application layer with the decompressed message payload and header values, including the <spanx style="verb">Per-Message Compressed</spanx> bit unset to 0.
                </t>

                <t>
                  Otherwise, pass the decompressed message payload and header values, including the <spanx style="verb">Per-Message Compressed</spanx> bit unset to 0, to the extension preceding the PMCE.
                  If the extension expects frames for input, build a frame for the message and pass it.
                </t>
              </list>
            </t>
          </list>
        </t>

        <t>
          An endpoint MUST use the following algorithm to receive a message in the form of an uncompressed message.

          <list style="numbers">
            <t>
              Process the received message as follows:

              <list style="symbols">
                <t>
                  If this PMCE is the last extension to process incoming
		  messages, deliver the <spanx style="emph">A WebSocket
		  Message Has Been Received</spanx> event to the application
		  layer with the received message payload and header values as
		  is.
                </t>

                <t>
                  Otherwise, pass the message payload and header values to the
		  extension preceding the PMCE as is.
                  If the extension expects frames for input, build a frame for the message and pass it.
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title="The &quot;permessage-deflate&quot; Extension" anchor="deflate">
      <t>
        This section defines a specific PMCE called <spanx style="verb">permessage-deflate</spanx>.
        It compresses the payload of a message using the DEFLATE algorithm <xref target="RFC1951" /> and uses the byte boundary alignment method introduced in <xref target="RFC1979" />.
      </t>

      <t>
        This section uses the term "byte" with the same meaning as used in <xref
	target="RFC1951"/>, i.e., 8 bits stored or transmitted as a unit (same
	as an octet).

      </t>

      <t>
        The registered extension name for this extension is <spanx style="verb">permessage-deflate</spanx>.
      </t>

      <t>
        Four extension parameters are defined for <spanx style="verb">permessage-deflate</spanx> to help endpoints manage per-connection resource usage.

        <list style="symbols">
          <t><spanx style="verb">server_no_context_takeover</spanx></t>
          <t><spanx style="verb">client_no_context_takeover</spanx></t>
          <t><spanx style="verb">server_max_window_bits</spanx></t>
          <t><spanx style="verb">client_max_window_bits</spanx></t>
        </list>

        These parameters enable two methods (no_context_takeover and max_window_bits) of constraining memory usage that may be applied independently to either direction of WebSocket traffic.
        The extension parameters with the "client_" prefix are used by the client to configure its compressor and by the server to configure its decompressor.
        The extension parameters with the "server_" prefix are used by the server to configure its compressor and by the client to configure its decompressor.
        All four parameters are defined for both a client's extension negotiation offer and a server's extension negotiation response.
      </t>

      <t>
        A server MUST decline an extension negotiation offer for this extension if any of the following conditions are met:

        <list style="symbols">
          <t>The negotiation offer contains an extension parameter not defined for use in an offer.</t>
          <t>The negotiation offer contains an extension parameter with an invalid value.</t>
          <t>The negotiation offer contains multiple extension parameters with the same name.</t>
          <t>The server doesn't support the offered configuration.</t>
        </list>
      </t>

      <t>
        A client MUST <spanx style="emph">Fail the WebSocket Connection</spanx> if the peer server accepted an extension negotiation offer for this extension with an extension negotiation response meeting any of the following conditions:

        <list style="symbols">
          <t>The negotiation response contains an extension parameter not defined for use in a response.</t>
          <t>The negotiation response contains an extension parameter with an invalid value.</t>
          <t>The negotiation response contains multiple extension parameters with the same name.</t>
          <t>The client does not support the configuration that the response represents.</t>
        </list>
      </t>

      <t>
        The term "LZ77 sliding window" <xref target="LZ77" /> used in this section means the buffer used by the DEFLATE algorithm to store recently processed input.
        The DEFLATE compression algorithm searches the buffer for a match with the following input.
      </t>

      <t>
        The term "use context takeover" used in this section means that the same LZ77 sliding window used by the endpoint to build frames of the previous sent message is reused to build frames of the next message to be sent.
      </t>

      <section title="Extension Parameters">
        <section title="Context Takeover Control">
          <section title="The &quot;server_no_context_takeover&quot; Extension Parameter">
            <t>
              A client MAY include the <spanx style="verb">server_no_context_takeover</spanx> extension parameter in an extension negotiation offer.
              This extension parameter has no value.
              By including this extension parameter in an extension negotiation offer, a client prevents the peer server from using context takeover.
              If the peer server doesn't use context takeover, the client doesn't need to reserve memory to retain the LZ77 sliding window between messages.
            </t>

            <t>
              Absence of this extension parameter in an extension negotiation offer indicates that the client can decompress a message that the server built using context takeover.
            </t>

            <t>
              A server accepts an extension negotiation offer that includes the <spanx style="verb">server_no_context_takeover</spanx> extension parameter by including the <spanx style="verb">server_no_context_takeover</spanx> extension parameter in the corresponding extension negotiation response to send back to the client.
              The <spanx style="verb">server_no_context_takeover</spanx> extension parameter in an extension negotiation response has no value.
            </t>

            <t>
              It is RECOMMENDED that a server supports the <spanx style="verb">server_no_context_takeover</spanx> extension parameter in an extension negotiation offer.
            </t>

            <t>
              A server MAY include the <spanx style="verb">server_no_context_takeover</spanx> extension parameter in an extension negotiation response even if the extension negotiation offer being accepted by the extension negotiation response didn't include the <spanx style="verb">server_no_context_takeover</spanx> extension parameter.
            </t>
          </section>

          <section title="The &quot;client_no_context_takeover&quot; Extension Parameter">
            <t>
              A client MAY include the <spanx style="verb">client_no_context_takeover</spanx> extension parameter in an extension negotiation offer.
              This extension parameter has no value.
              By including this extension parameter in an extension negotiation offer, a client informs the peer server of a hint that even if the server doesn't include the <spanx style="verb">client_no_context_takeover</spanx> extension parameter in the corresponding extension negotiation response to the offer, the client is not going to use context takeover.
            </t>

            <t>
              A server MAY include the <spanx style="verb">client_no_context_takeover</spanx> extension parameter in an extension negotiation response.
              If the received extension negotiation offer includes the <spanx style="verb">client_no_context_takeover</spanx> extension parameter, the server may either ignore the parameter or use the parameter to avoid taking over the LZ77 sliding window unnecessarily by including the <spanx style="verb">client_no_context_takeover</spanx> extension parameter in the corresponding extension negotiation response to the offer.
              The <spanx style="verb">client_no_context_takeover</spanx> extension parameter in an extension negotiation response has no value.
              By including the <spanx style="verb">client_no_context_takeover</spanx> extension parameter in an extension negotiation response, a server prevents the peer client from using context takeover.
              This reduces the amount of memory that the server has to reserve for the connection.
            </t>

            <t>
              Absence of this extension parameter in an extension negotiation response indicates that the server can decompress messages built by the client using context takeover.
            </t>

            <t>
              A client MUST support the <spanx style="verb">client_no_context_takeover</spanx> extension parameter in an extension negotiation response.
            </t>
          </section>
        </section>

        <section title="Limiting the LZ77 Sliding Window Size">
          <section title="The &quot;server_max_window_bits&quot; Extension Parameter">
            <t>
              A client MAY include the <spanx style="verb">server_max_window_bits</spanx> extension parameter in an extension negotiation offer.
  This parameter has a decimal integer value without leading
  zeroes between 8 to 15, inclusive, indicating the base-2
  logarithm of the LZ77 sliding window size, and MUST conform to
  the ABNF below.


              <figure>
                <artwork>
    server-max-window-bits = 1*DIGIT
                </artwork>
              </figure>

              By including this parameter in an extension negotiation offer, a client limits the LZ77 sliding window size that the server will use to compress messages.
              If the peer server uses a small LZ77 sliding window to compress messages, the client can reduce the memory needed for the LZ77 sliding window.
            </t>

            <t>
              A server declines an extension negotiation offer with this parameter if the server doesn't support it.
            </t>

            <t>
              Absence of this parameter in an extension negotiation offer indicates that the client can receive messages compressed using an LZ77 sliding window of up to 32,768 bytes.
            </t>

            <t>
              A server accepts an extension negotiation offer with this parameter by including the <spanx style="verb">server_max_window_bits</spanx> extension parameter in the extension negotiation response to send back to the client with the same or smaller value as the offer.
              The <spanx style="verb">server_max_window_bits</spanx> extension
	      parameter in an extension negotiation response has a decimal
	      integer value without leading zeroes between 8 to 15, inclusive,
	      indicating the base-2 logarithm of the LZ77 sliding window size,
	      and MUST conform to the ABNF below.

              <figure>
                <artwork>
    server-max-window-bits = 1*DIGIT
                </artwork>
              </figure>
            </t>

            <t>
              A server MAY include the <spanx style="verb">server_max_window_bits</spanx> extension parameter in an extension negotiation response even if the extension negotiation offer being accepted by the response didn't include the <spanx style="verb">server_max_window_bits</spanx> extension parameter.
            </t>
          </section>

          <section title="The &quot;client_max_window_bits&quot; Extension Parameter">
            <t>
              A client MAY include the <spanx style="verb">client_max_window_bits</spanx> extension parameter in an extension negotiation offer.
              This parameter has no value or a decimal integer value without leading zeroes between 8 to 15 inclusive indicating the base-2 logarithm of the LZ77 sliding window size.
              If a value is specified for this parameter, the value MUST conform to the ABNF below.

              <figure>
                <artwork>
    client-max-window-bits = 1*DIGIT
                </artwork>
              </figure>

              By including this parameter in an offer, a client informs the peer server that the client supports the <spanx style="verb">client_max_window_bits</spanx> extension parameter in an extension negotiation response and, optionally, a hint by attaching a value to the parameter.


              If the <spanx style="verb">client_max_window_bits</spanx>
	      extension parameter in an extension negotiation offer has a
	      value, the parameter also informs the peer server of a hint that
	      even if the server doesn't include the <spanx
	      style="verb">client_max_window_bits</spanx> extension parameter
	      in the corresponding extension negotiation response with a value
	      greater than the one in the extension negotiation offer or if the
	      server doesn't include the extension parameter at all, the
	      client is not going to use an LZ77 sliding window size greater
	      than the size specified by the value in the extension
	      negotiation offer to compress messages.
            </t>

            <t>
              If a received extension negotiation offer has the <spanx style="verb">client_max_window_bits</spanx> extension parameter, the server MAY include the <spanx style="verb">client_max_window_bits</spanx> extension parameter in the corresponding extension negotiation response to the offer.
              If the <spanx style="verb">client_max_window_bits</spanx> extension parameter in a received extension negotiation offer has a value, the server may either ignore this value or use this value to avoid allocating an unnecessarily big LZ77 sliding window by including the <spanx style="verb">client_max_window_bits</spanx> extension parameter in the corresponding extension negotiation response to the offer with a value equal to or smaller than the received value.
              The <spanx style="verb">client_max_window_bits</spanx> extension parameter in an extension negotiation response has a decimal integer value without leading zeroes between 8 to 15 inclusive indicating the base-2 logarithm of the LZ77 sliding window size and MUST conform to the ABNF below.

              <figure>
                <artwork>
    client-max-window-bits = 1*DIGIT
                </artwork>
              </figure>

              By including this extension parameter in an extension negotiation response, a server limits the LZ77 sliding window size that the client uses to compress messages.
              This reduces the amount of memory for the decompression context that the server has to reserve for the connection.
            </t>

            <t>
              If a received extension negotiation offer doesn't have the <spanx style="verb">client_max_window_bits</spanx> extension parameter, the corresponding extension negotiation response to the offer MUST NOT include the <spanx style="verb">client_max_window_bits</spanx> extension parameter.
            </t>

            <t>
              Absence of this extension parameter in an extension negotiation response indicates that the server can receive messages compressed using an LZ77 sliding window of up to 32,768 bytes.
            </t>
          </section>
        </section>

        <section title="Examples">
          <t>
            The simplest <spanx style="verb">Sec-WebSocket-Extensions</spanx> header in a client's opening handshake to offer use of the "permessage-deflate" extension looks like this:

            <figure>
              <artwork>
    Sec-WebSocket-Extensions: permessage-deflate
              </artwork>
            </figure>

            Since the <spanx style="verb">client_max_window_bits</spanx> extension parameter is not included in this extension negotiation offer, the server must not accept the offer with an extension negotiation response that includes the <spanx style="verb">client_max_window_bits</spanx> extension parameter.
            The simplest <spanx style="verb">Sec-WebSocket-Extensions</spanx> header in a server's opening handshake to accept use of the "permessage-deflate" extension is the same:

            <figure>
              <artwork>
    Sec-WebSocket-Extensions: permessage-deflate
              </artwork>
            </figure>
          </t>

          <t>
            The following extension negotiation offer sent by a client is asking the server to use an LZ77 sliding window with a size of 1,024 bytes or less and declaring that the client supports the <spanx style="verb">client_max_window_bits</spanx> extension parameter in an extension negotiation response.

            <figure>
              <artwork>
    Sec-WebSocket-Extensions:
        permessage-deflate;
        client_max_window_bits; server_max_window_bits=10
              </artwork>
            </figure>

            This extension negotiation offer might be rejected by the server because the server doesn't support the <spanx style="verb">server_max_window_bits</spanx> extension parameter in an extension negotiation offer.
            This is fine if the client cannot receive messages compressed using a larger sliding window size, but if the client just prefers using a small window but wants to fall back to the "permessage-deflate" without the <spanx style="verb">server_max_window_bits</spanx> extension parameter, the client can make an offer with the fallback option like this:

            <figure>
              <artwork>
    Sec-WebSocket-Extensions:
        permessage-deflate;
        client_max_window_bits; server_max_window_bits=10,
        permessage-deflate;
        client_max_window_bits
              </artwork>
            </figure>

            The server can accept "permessage-deflate" by picking any supported one from the listed offers.
            To accept the first option, for example, the server may send back a response as follows:

            <figure>
              <artwork>
    Sec-WebSocket-Extensions:
        permessage-deflate; server_max_window_bits=10
              </artwork>
            </figure>

            To accept the second option, for example, the server may send back a response as follows:

            <figure>
              <artwork>
    Sec-WebSocket-Extensions: permessage-deflate
              </artwork>
            </figure>
          </t>
        </section>
      </section>

      <section title="Message Payload Transformation" anchor="transformation">
        <section title="Compression">
          <t>
            An endpoint uses the following algorithm to compress a message.

            <list style="numbers">
              <t>
                Compress all the octets of the payload of the message using DEFLATE.
              </t>

              <t>
                If the resulting data does not end with an empty DEFLATE block with no compression (the <spanx style="verb">BTYPE</spanx> bits are set to 00), append an empty DEFLATE block with no compression to the tail end.
              </t>

              <t>
                Remove 4 octets (that are 0x00 0x00 0xff 0xff) from the tail end.
                After this step, the last octet of the compressed data contains (possibly part of) the DEFLATE header bits with the <spanx style="verb">BTYPE</spanx> bits set to 00.
              </t>
            </list>
          </t>

          <t>
            When using DEFLATE in the first step above:

            <list style="symbols">
              <t>
                An endpoint MAY use multiple DEFLATE blocks to compress one message.
              </t>

              <t>
                An endpoint MAY use DEFLATE blocks of any type.
              </t>

              <t>
                An endpoint MAY use both DEFLATE blocks with the <spanx style="verb">BFINAL</spanx> bit set to 0 and DEFLATE blocks with the <spanx style="verb">BFINAL</spanx> bit set to 1.
              </t>

              <t>
                When any DEFLATE block with the <spanx style="verb">BFINAL</spanx> bit set to 1 doesn't end at a byte boundary, an endpoint MUST add minimal padding bits of 0 to make it end at a byte boundary.
                The next DEFLATE block follows the padded data if any.
              </t>
            </list>
          </t>

          <t>
            An endpoint fragments a compressed message by splitting the result of running this algorithm.
            Even when only part of the payload is available, a fragment can be built by compressing the available data and choosing the block type appropriately so that the end of the resulting compressed data is aligned at a byte boundary.
            Note that for non-final fragments, the removal of 0x00 0x00 0xff 0xff MUST NOT be done.
          </t>

          <t>
            An endpoint MUST NOT use an LZ77 sliding window longer than 32,768 bytes to compress messages to send.
          </t>

          <t>
            If the "agreed parameters" contain the <spanx style="verb">client_no_context_takeover</spanx> extension parameter, the client MUST start compressing each new message with an empty LZ77 sliding window.
            Otherwise, the client MAY take over the LZ77 sliding window used to build the last compressed message.
            Note that even if the client has included the <spanx style="verb">client_no_context_takeover</spanx> extension parameter in its offer, the client MAY take over the LZ77 sliding window used to build the last compressed message if the "agreed parameters" don't contain the <spanx style="verb">client_no_context_takeover</spanx> extension parameter.
            The client-to-server <spanx style="verb">client_no_context_takeover</spanx> extension parameter is just a hint for the server to build an extension negotiation response.
          </t>

          <t>
            If the "agreed parameters" contain the <spanx style="verb">server_no_context_takeover</spanx> extension parameter, the server MUST start compressing each new message with an empty LZ77 sliding window.
            Otherwise, the server MAY take over the LZ77 sliding window used to build the last compressed message.
          </t>

          <t>
            If the "agreed parameters" contain the <spanx style="verb">client_max_window_bits</spanx> extension parameter with a value of w, the client MUST NOT use an LZ77 sliding window longer than the w-th power of 2 bytes to compress messages to send.
            Note that even if the client has included in its offer the <spanx style="verb">client_max_window_bits</spanx> extension parameter with a value smaller than one in the "agreed parameters", the client MAY use an LZ77 sliding window with any size to compress messages to send as long as the size conforms to the "agreed parameters".
            The client-to-server <spanx style="verb">client_max_window_bits</spanx> extension parameter is just a hint for the server to build an extension negotiation response.
          </t>

          <t>
            If the "agreed parameters" contain the <spanx style="verb">server_max_window_bits</spanx> extension parameter with a value of w, the server MUST NOT use an LZ77 sliding window longer than the w-th power of 2 bytes to compress messages to send.
          </t>
        </section>

        <section title="Decompression">
          <t>
            An endpoint uses the following algorithm to decompress a message.

            <list style="numbers">
              <t>
                Append 4 octets of 0x00 0x00 0xff 0xff to the tail end of the payload of the message.
              </t>

              <t>
                Decompress the resulting data using DEFLATE.
              </t>
            </list>
          </t>

          <t>
            If the "agreed parameters" contain the <spanx style="verb">server_no_context_takeover</spanx> extension parameter, the client MAY decompress each new message with an empty LZ77 sliding window.
            Otherwise, the client MUST decompress each new message using the LZ77 sliding window used to process the last compressed message.
          </t>

          <t>
            If the "agreed parameters" contain the <spanx style="verb">client_no_context_takeover</spanx> extension parameter, the server MAY decompress each new message with an empty LZ77 sliding window.
            Otherwise, the server MUST decompress each new message using the LZ77 sliding window used to process the last compressed message.
            Note that even if the client has included the <spanx style="verb">client_no_context_takeover</spanx> extension parameter in its offer, the server MUST decompress each new message using the LZ77 sliding window used to process the last compressed message if the "agreed parameters" don't contain the <spanx style="verb">client_no_context_takeover</spanx> extension parameter.
            The client-to-server <spanx style="verb">client_no_context_takeover</spanx> extension parameter is just a hint for the server to build an extension negotiation response.
          </t>

          <t>
            If the "agreed parameters" contain the <spanx style="verb">server_max_window_bits</spanx> extension parameter with a value of w, the client MAY reduce the size of its LZ77 sliding window to decompress received messages down to the w-th power of 2 bytes.
            Otherwise, the client MUST use a 32,768-byte LZ77 sliding window to decompress received messages.
          </t>

          <t>
            If the "agreed parameters" contain the <spanx style="verb">client_max_window_bits</spanx> extension parameter with a value of w, the server MAY reduce the size of its LZ77 sliding window to decompress received messages down to the w-th power of 2 bytes.
            Otherwise, the server MUST use a 32,768-byte LZ77 sliding window to decompress received messages.
            Note that even if the client has included in its offer the <spanx style="verb">client_max_window_bits</spanx> extension parameter with a value smaller than one in the "agreed parameters", the client MUST use an LZ77 sliding window of a size that conforms the "agreed parameters" to compress messages to send.
            The client-to-server <spanx style="verb">client_max_window_bits</spanx> extension parameter is just a hint for the server to build an extension negotiation response.
          </t>
        </section>

        <section title="Examples">
          <t>
            This section introduces examples of how the "permessage-deflate" extension transforms messages.
          </t>

          <section title="A Message Compressed Using One Compressed DEFLATE Block">
            <t>
              Suppose that an endpoint sends a text message "Hello".
              If the endpoint uses one compressed DEFLATE block (compressed
	      with fixed Huffman code and the <spanx
	      style="verb">BFINAL</spanx> bit not set) to compress the
	      message, the endpoint obtains the compressed data to use for the message payload as follows.
            </t>

            <t>
              The endpoint compresses "Hello" into one compressed DEFLATE
	      block and flushes the resulting data into a byte array using an empty DEFLATE block with no compression:

              <figure>
                <artwork>
    0xf2 0x48 0xcd 0xc9 0xc9 0x07 0x00 0x00 0x00 0xff 0xff
                </artwork>
              </figure>

              By stripping 0x00 0x00 0xff 0xff from the tail end, the endpoint gets the data to use for the message payload:

              <figure>
                <artwork>
    0xf2 0x48 0xcd 0xc9 0xc9 0x07 0x00
                </artwork>
              </figure>
            </t>

            <t>
              Suppose that the endpoint sends this compressed message without
	      fragmentation.



              The endpoint builds one frame by putting all of the compressed data in the payload data portion of the frame:

              <figure>
                <artwork>
    0xc1 0x07 0xf2 0x48 0xcd 0xc9 0xc9 0x07 0x00
                </artwork>
              </figure>

              The first 2 octets (0xc1 0x07) are the WebSocket frame header
	      (FIN=1, RSV1=1, RSV2=0, RSV3=0, opcode=text, MASK=0, Payload length=7).
              The following figure shows what value is set in each field of the WebSocket frame header.

              <figure>


                <artwork>
     0                   1
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
    +-+-+-+-+-------+-+-------------+
    |F|R|R|R| opcode|M| Payload len |
    |I|S|S|S|       |A|             |
    |N|V|V|V|       |S|             |
    | |1|2|3|       |K|             |
    +-+-+-+-+-------+-+-------------+
    |1|1|0|0|   1   |0|      7      |
    +-+-+-+-+-------+-+-------------+
                </artwork>
              </figure>
            </t>

            <t>
              Suppose that the endpoint sends the compressed message with fragmentation.
              The endpoint splits the compressed data into fragments and builds frames for each fragment.
              For example, if the fragments are 3 and 4 octets, the first frame is:

              <figure>
                <artwork>
    0x41 0x03 0xf2 0x48 0xcd
                </artwork>
              </figure>

              and the second frame is:

              <figure>
                <artwork>
    0x80 0x04 0xc9 0xc9 0x07 0x00
                </artwork>
              </figure>

              Note that the RSV1 bit is set only on the first frame.
            </t>
          </section>

          <section title="Sharing LZ77 Sliding Window">
            <t>
              Suppose that a client has sent a message "Hello" as a compressed message and will send the same message "Hello" again as a compressed message.

              <figure>
                <artwork>
    0xf2 0x48 0xcd 0xc9 0xc9 0x07 0x00
                </artwork>
              </figure>

              The above is the payload of the first message that the client has sent.
              If the "agreed parameters" contain the <spanx style="verb">client_no_context_takeover</spanx> extension parameter, the client compresses the payload of the next message into the same bytes (if the client uses the same <spanx style="verb">BTYPE</spanx> value and <spanx style="verb">BFINAL</spanx> value).
              So, the payload of the second message will be:

              <figure>
                <artwork>
    0xf2 0x48 0xcd 0xc9 0xc9 0x07 0x00
                </artwork>
              </figure>

              If the "agreed parameters" did not contain the <spanx style="verb">client_no_context_takeover</spanx> extension parameter, the client can compress the payload of the next message into fewer bytes by referencing the history in the LZ77 sliding window.
              So, the payload of the second message will be:

              <figure>
                <artwork>
    0xf2 0x00 0x11 0x00 0x00
                </artwork>
              </figure>

              So, 2 bytes are saved in total.
            </t>

            <t>
              Note that even if some uncompressed messages (with the RSV1 bit unset) are inserted between the two "Hello" messages, they don't affect the LZ77 sliding window.
            </t>
          </section>

          <section title="Using a DEFLATE Block with No Compression">

<t>A DEFLATE block with no compression may be used.
</t>
            <t>
              <figure>
                <artwork>
    0xc1 0x0b 0x00 0x05 0x00 0xfa 0xff 0x48 0x65 0x6c 0x6c 0x6f 0x00
                </artwork>
              </figure>

              This is a frame constituting a text message "Hello" built using a DEFLATE block with no compression.
              The first 2 octets (0xc1 0x0b) are the WebSocket frame header
	      (FIN=1, RSV1=1, RSV2=0, RSV3=0, opcode=text, MASK=0, Payload length=7).
              Note that the RSV1 bit is set for this message (only on the first fragment if the message is fragmented) because the RSV1 bit is set when DEFLATE is applied to the message, including the case when only DEFLATE blocks with no compression are used.
              The 3rd to 13th octets consist of the payload data containing "Hello" compressed using a DEFLATE block with no compression.
            </t>
          </section>

          <section title="Using a DEFLATE Block with &quot;BFINAL&quot; Set to 1">
            <t>
              On platforms on which the flush method using an empty DEFLATE block with no compression is not available, implementors can choose to flush data using DEFLATE blocks with <spanx style="verb">BFINAL</spanx> set to 1.

              <figure>
                <artwork>
    0xf3 0x48 0xcd 0xc9 0xc9 0x07 0x00 0x00
                </artwork>
              </figure>

              This is the payload of a message containing "Hello" compressed using a DEFLATE block with <spanx style="verb">BFINAL</spanx> set to 1.
              The first 7 octets constitute a DEFLATE block with <spanx
	      style="verb">BFINAL</spanx> set to 1 and <spanx
	      style="verb">BTYPE</spanx> set to 01 containing "Hello".
              The last 1 octet (0x00) contains the header bits with <spanx
	      style="verb">BFINAL</spanx> set to 0 and <spanx
	      style="verb">BTYPE</spanx> set to 00, and 5 padding bits of 0.
              This octet is necessary to allow the payload to be decompressed
	      in the same manner as messages flushed using DEFLATE blocks with
	      "BFINAL" unset.
            </t>
          </section>

          <section title="Two DEFLATE Blocks in One Message">
            <t>
              Two or more DEFLATE blocks may be used in one message.

              <figure>
                <artwork>
    0xf2 0x48 0x05 0x00 0x00 0x00 0xff 0xff 0xca 0xc9 0xc9 0x07 0x00
                </artwork>
              </figure>

              The first 3 octets (0xf2 0x48 0x05) and the least significant two bits of the 4th octet (0x00) constitute one DEFLATE block with <spanx style="verb">BFINAL</spanx> set to 0 and <spanx style="verb">BTYPE</spanx> set to 01 containing "He".
              The rest of the 4th octet contains the header bits with <spanx style="verb">BFINAL</spanx> set to 0 and <spanx style="verb">BTYPE</spanx> set to 00, and the 3 padding bits of 0.
              Together with the following 4 octets (0x00 0x00 0xff 0xff), the header bits constitute an empty DEFLATE block with no compression.
              A DEFLATE block containing "llo" follows the empty DEFLATE block.
            </t>
          </section>

          <section title="Generating an Empty Fragment">
            <t>
              Suppose that an endpoint is sending data of unknown size.
              The endpoint may encounter the end-of-data signal from the data source when its buffer for uncompressed data is empty.
              In such a case, the endpoint just needs to send the last
	      fragment with the FIN bit set to 1 and the payload set to the
	      DEFLATE block(s), which contains 0 bytes of data.

              If the compression library being used doesn't generate any data when its buffer is empty, an empty uncompressed DEFLATE block can be built and used for this purpose as follows:

              <figure>
                <artwork>
    0x00
                </artwork>
              </figure>


              The single octet 0x00 contains the header bits with <spanx style="verb">BFINAL</spanx> set to 0 and <spanx style="verb">BTYPE</spanx> set to 00, and 5 padding bits of 0.
            </t>
          </section>
        </section>
      </section>

      <section title="Implementation Notes">
        <t>
          On most common software development platforms, the DEFLATE compression library provides a method for aligning compressed data to byte boundaries using an empty DEFLATE block with no compression.
          For example, zlib <xref target="zlib" /> does this when <spanx style="verb">Z_SYNC_FLUSH</spanx> is passed to the deflate function.
        </t>

        <t>
          Some platforms may only provide methods to output and process
	  compressed data with a zlib header and an Adler-32 checksum.

          On such platforms, developers need to write stub code to remove and
	  complement the zlib and Adler-32 checksum by themselves.
        </t>

        <t>
          To obtain a useful compression ratio, an LZ77 sliding window size of 1,024 or more is RECOMMENDED.
        </t>

        <t>
          If a side disallows context takeover, its endpoint can easily figure
	  out whether 
or not a certain message will be shorter if compressed.
          Otherwise, it's not easy to know whether future messages will benefit from having a certain message compressed.
          Implementors may employ some heuristics to determine this.
        </t>
      </section>
    </section>

    <section title="Security Considerations">
      <t>
        There is a known exploit when history-based compression is combined with a secure transport <xref target="CRIME" />.
        Implementors should pay attention to this point when integrating this extension with other extensions or protocols.
      </t>
    </section>

    <section title="IANA Considerations" anchor="iana">
      <section title="Registration of the &quot;permessage-deflate&quot; WebSocket Extension Name">
        <t>
          IANA has registered the following WebSocket extension name in the
	  "WebSocket Extension Name Registry" defined in
           <xref target="RFC6455" />.


          <list style="hanging">
            <t hangText="Extension Identifier">
              <vspace blankLines="0"/>
              permessage-deflate
            </t>

            <t hangText="Extension Common Name">
              <vspace blankLines="0"/>
              WebSocket Per-Message Deflate
            </t>

            <t hangText="Extension Definition">
              <vspace blankLines="0"/>
              This document.
            </t>

            <t hangText="Known Incompatible Extensions">
              <vspace blankLines="0"/>
              None
            </t>
          </list>
        </t>

        <t>
          The <spanx style="verb">permessage-deflate</spanx> extension name is used in the <spanx style="verb">Sec-WebSocket-Extensions</spanx> header in the WebSocket opening handshake to negotiate use of the "permessage-deflate" extension.
        </t>
      </section>

      <section title="Registration of the &quot;Per-Message Compressed&quot; WebSocket Framing Header Bit">
        <t>
          IANA has registered the following WebSocket framing header bit
	  in the "WebSocket Framing Header Bits Registry" defined in <xref
	  target="RFC6455"/>.


          <list style="hanging">
            <t hangText="Value">
              <vspace blankLines="0"/>
              RSV1
            </t>


            <t hangText="Description">
              <vspace blankLines="0"/>
  The "Per-Message Compressed" bit, which indicates whether or not the message
  is compressed. RSV1 is set for compressed messages and unset for
  uncompressed messages.
            </t>

            <t hangText="Reference">
              <vspace blankLines="0"/>
              <xref target="framing" /> of this document.
            </t>
          </list>
        </t>

        <t>
          The <spanx style="verb">Per-Message Compressed</spanx> framing header bit is used on the first fragment of data messages to indicate whether the payload of the message is compressed by the PMCE or not.
        </t>
      </section>
    </section>
  </middle>

  <back>


    <references title="Normative References">
      <?rfc include="reference.RFC.1951" ?>
      <?rfc include="reference.RFC.5234" ?>
      <?rfc include="reference.RFC.6455" ?>
      <?rfc include="reference.RFC.2119" ?>

<reference anchor="LZ77"
           target="https://www.cs.duke.edu/courses/spring03/cps296.5/papers/ziv_lempel_1977_universal_algorithm.pdf">
  <front>
    <title>A Universal Algorithm for Sequential Data Compression</title>
    <author initials="J" surname="Ziv" fullname="Jacob Ziv"></author>
    <author initials="A" surname="Lempel" fullname="Abraham Lempel"></author>
    <date month="May" year="1977"/>
  </front>
  <seriesInfo name="IEEE Transactions on Information Theory, Vol. 23,"
              value="No. 3, pp. 337-343, DOI 10.1109/TIT.1977.1055714"/>
</reference>


      <reference anchor="CRIME">
        <front>
          <title>The CRIME attack</title>
          <author initials="J." surname="Rizzo" fullname="Juliano Rizzo"></author>
          <author initials="T." surname="Duong" fullname="Thai Duong"></author>
          <date month="September" year="2012" />
        </front>
        <seriesInfo name="EKOparty Security" value="Conference" />
      </reference>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.1979" ?>

<reference anchor="zlib" target="http://www.zlib.net/">
  <front>
    <title>zlib</title>
    <author initials="J.L" surname="Gailly" fullname="Jean-loup	Gailly"></author>
    <author initials="M" surname="Adler" fullname="Mark Adler"></author>
    <date />
  </front>
</reference>
    </references>

<section title="Acknowledgements" numbered="no">
<t>Special thanks to Patrick McManus who wrote up the initial
specification of a DEFLATE-based compression extension for the
WebSocket Protocol, which I referred to when writing this specification.</t>

<t>Thanks to the following people who participated in discussions on the
HyBi WG and contributed ideas and/or provided detailed reviews (the
list is likely incomplete): Adam Rice, Alexander Philippou,
Alexey Melnikov, Arman Djusupov, Bjoern Hoehrmann, Brian McKelvey,
Dario Crivelli, Greg Wilkins, Inaki Baz Castillo, Jamie Lokier,
Joakim Erdfelt, John A.&nbsp;Tamplin, Julian Reschke, Kenichi Ishibashi,
Mark Nottingham, Peter Thorson, Roberto Peon, Salvatore Loreto,
Simone Bordet, Tobias Oberstein, and Yutaka Hirano.  Note that the people
listed above didn't necessarily endorse the end result of this work.</t>
</section>
</back>
</rfc>
