<?xml version="1.0" encoding="UTF-8"?>
<!--
    This XML document is the output of clean-for-DTD.xslt; a tool that strips
    extensions to RFC2629(bis) from documents for processing with xml2rfc.
-->

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc subcompact="no"?>
<?rfc inline="yes"?>
<!DOCTYPE rfc
  PUBLIC "" "rfc2629.dtd">
<rfc ipr="pre5378Trust200902" number="5842" category="exp">
  
  <front>
    <title abbrev="Binding Extensions to WebDAV">Binding Extensions to Web Distributed Authoring and Versioning (WebDAV)</title>
    <author initials="G." surname="Clemm" fullname="Geoffrey Clemm">
      <organization>IBM</organization>
      <address>
        <postal>
          <street>550 King Street</street>
          <city>Littleton</city>
          <region>MA</region>
          <code>01460</code>
        </postal>
        <email>geoffrey.clemm@us.ibm.com</email>
      </address>
    </author>
    <author initials="J." surname="Crawford" fullname="Jason Crawford">
      <organization>IBM Research</organization>
      <address>
        <postal>
          <street>P.O. Box 704</street>
          <city>Yorktown Heights</city>
          <region>NY</region>
          <code>10598</code>
        </postal>
        <email>ccjason@us.ibm.com</email>
      </address>
    </author>
  	<author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
  		<organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address>
        <postal>
          <street>Hafenweg 16</street>
          <city>Muenster</city><region>NW</region><code>48155</code>
          <country>Germany</country>
        </postal>
  		  <email>julian.reschke@greenbytes.de</email>	
  		</address>
  	</author>
    <author initials="J." surname="Whitehead" fullname="Jim Whitehead">
      <organization abbrev="U.C. Santa Cruz">UC Santa Cruz, Dept. of Computer Science</organization>
      <address>
        <postal>
          <street>1156 High Street</street>
          <city>Santa Cruz</city>
          <region>CA</region>
          <code>95064</code>
        </postal>
        <email>ejw@cse.ucsc.edu</email>
      </address>
    </author>

    <date month="April" year="2010"/>
 <keyword>HTTP</keyword>
 <keyword>WebDAV</keyword>
 <keyword>collections</keyword>
 <keyword>hard link</keyword>
	
    <abstract>
      <t>
        This specification defines bindings, and the BIND method for creating
        multiple bindings to the same resource.  Creating a new binding to a
        resource causes at least one new URI to be mapped to that resource.  Servers
        are required to ensure the integrity of any bindings that they
        allow to be created.
      </t>
    </abstract>
  </front>

	<middle>
  


<section title="Introduction" anchor="introduction">
<t>
  This specification extends the WebDAV Distributed Authoring Protocol (<xref target="RFC4918"/>) to enable
  clients to create new access paths to existing resources.  This capability is
  useful for several reasons:
</t>
<t>
  URIs of WebDAV-compliant resources are hierarchical and correspond to a hierarchy
  of collections in resource space.  The WebDAV Distributed Authoring Protocol
  makes it possible to organize these resources into hierarchies, placing them
  into groupings, known as collections, which are more easily browsed and
  manipulated than a single flat collection.  However, hierarchies require
  categorization decisions that locate resources at a single location in the
  hierarchy, a drawback when a resource has multiple valid categories.  For
  example, in a hierarchy of vehicle descriptions containing collections for
  cars and boats, a description of a combination car/boat vehicle could belong
  in either collection.  Ideally, the description should be accessible from both.
  Allowing clients to create new URIs that access the existing resource lets
  them put that resource into multiple collections.
</t>
<t>
  Hierarchies also make resource sharing more difficult, since resources that
  have utility across many collections are still forced into a single collection.
  For example, the mathematics department at one university might create a
  collection of information on fractals that contains bindings to some local
  resources but also provides access to some resources at other universities.  For
  many reasons, it may be undesirable to make physical copies of the shared
  resources on the local server, for example, to conserve disk space, to respect copyright 
  constraints, or to make any changes in the shared resources visible
  automatically.  Being able to create new access paths to existing resources in 
  other collections or even on other servers is useful for this sort of case.
</t>
<t>
  The BIND method, defined here, provides a mechanism for allowing clients to
  create alternative access paths to existing WebDAV resources.  HTTP 
  <xref target="RFC2616"/> and WebDAV <xref target="RFC4918"/>
  methods are able to work because there are mappings between URIs and resources.  A
  method is addressed to a URI, and the server follows the mapping from that
  URI to a resource, applying the method to that resource.  Multiple URIs may be
  mapped to the same resource, but until now, there has been no way for clients
  to create additional URIs mapped to existing resources. 
</t>
<t>
  BIND lets clients associate a new URI with an existing WebDAV resource, and
  this URI can then be used to submit requests to the resource.  Since URIs of
  WebDAV resources are hierarchical, and correspond to a hierarchy of
  collections in resource space, the BIND method also has the effect of adding
  the resource to a collection.  As new URIs are associated with the resource,
  it appears in additional collections.
</t>
<t>
  A BIND request does not create a new resource, but simply makes a
  new URI for submitting requests to an existing resource available.  The new URI is
  indistinguishable from any other URI when submitting a request to a resource.  Only 
  one round trip is needed to submit a request to the intended target.
  Servers are required to enforce the integrity of the relationships between
  the new URIs and the resources associated with them.  Consequently, it may be
  very costly for servers to support BIND requests that cross server boundaries.
</t>
<t>
  This specification is organized as follows.  <xref target="terminology"/> defines terminology
  used in the rest of the specification, while <xref target="overview.of.bindings"/> overviews bindings.
  <xref target="properties"/> defines the new properties needed to support multiple bindings to
  the same resource.  <xref target="METHOD_BIND"/> specifies the BIND method, used to create
  multiple bindings to the same resource.  <xref target="METHOD_UNBIND"/> specifies the UNBIND
  method, used to remove a binding to a resource.  <xref target="METHOD_REBIND"/> specifies the
  REBIND method, used to move a binding to another collection.  
</t>

<section title="Terminology" anchor="terminology">
<t>
  The terminology used here follows and extends that in the WebDAV Distributed
  Authoring Protocol specification <xref target="RFC4918"/>.
</t>
<t>
  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
  "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
  interpreted as described in <xref target="RFC2119"/>. 
</t>
<t>
  This document uses XML DTD fragments (<xref target="XML"/>) as a notational convention, using the rules defined in Section 17 of <xref target="RFC4918"/>.
</t>
<t>
  <iref item="URI Mapping" primary="true"/>
  <?rfc needLines="4"?>URI Mapping
  <list><t>
    A relation between an absolute URI and a resource.  For an absolute URI U
    and the resource it identifies R, the URI mapping can be thought of as
    (U =&gt; R).  Since a resource can represent items that are not network
    retrievable as well as those that are, it is possible for a resource to
    have zero, one, or many URI mappings.  Mapping a resource to an "http"-scheme URI makes it possible to submit HTTP requests to the
    resource using the URI.
  </t></list>
</t>
<t>
  <iref item="Path Segment" primary="true"/>
  

<?rfc needLines="4" ?><?rfc needLines="4"?>Path Segment
  <list><t>
    Informally, the characters found between slashes ("/") in a URI.
    Formally, as defined in Section 3.3 of <xref target="RFC3986"/>.
  </t></list>
</t>
<t>
  <iref item="Binding" primary="true"/>
  <?rfc needLines="4"?>Binding
  <list><t>
    A relation between a single path segment (in a collection) and a resource.  A
    binding is part of the state of a collection.  If two different
    collections contain a binding between the same path segment and the same
    resource, these are two distinct bindings.  So for a collection C, a path
    segment S, and a resource R, the binding can be thought of as C:(S -&gt; R).
    Bindings create URI mappings, and hence allow requests to be sent to a
    single resource from multiple locations in a URI namespace.  For example,
    given a collection C (accessible through the URI 
    http://www.example.com/CollX), a path segment S (equal to "foo.html"), and 
    a resource R, then creating the binding C: (S -&gt; R) makes it possible to
    use the URI http://www.example.com/CollX/foo.html to access R.
  </t></list>
</t>
<t>
  <iref item="Collection" primary="true"/>
  <?rfc needLines="4"?>Collection
  <list><t>
    A resource that contains, as part of its state, a set of bindings that 
    identify internal member resources.
  </t></list>
</t>
<t>
  <iref item="Internal Member URI" primary="true"/>
  <?rfc needLines="4"?>Internal Member URI
  <list><t>
    The URI that identifies an internal member of a collection and that
    consists of the URI for the collection, followed by a slash character
    ('/'), followed by the path segment of the binding for that internal member.
  </t></list>
</t>
<t>
  <iref item="Binding Integrity" primary="true"/>
  <?rfc needLines="4"?>Binding Integrity
  <list><t>
    The property of a binding that says that:
    <list style="symbols">
      <t>the binding continues to exist, and</t>
      <t>the identity of the resource identified by that binding does not change,</t>
    </list></t>
    <t>
    unless an explicit request is executed that is defined to delete that
    binding (examples of requests that delete a binding are DELETE, MOVE, and
    -- defined later on -- UNBIND and REBIND).
  </t></list>
</t>
</section>

<section title="Method Preconditions and Postconditions" anchor="method.preconditions.and.postconditions">
<t>
  See Section 16 of <xref target="RFC4918"/> for the
  definitions of "precondition" and "postcondition". 
</t>
</section>
</section>



<section title="Overview of Bindings" anchor="overview.of.bindings">
<t>
  Bindings are part of the state of a collection.  They define the internal
  members of the collection and the names of those internal members.
</t>
<t>
  Bindings are added and removed by a variety of existing HTTP methods.  A
  method that creates a new resource, such as PUT, COPY, and MKCOL, adds a
  binding.  A method that deletes a resource, such as DELETE, removes a
  binding.  A method that moves a resource (e.g., MOVE) both adds a binding
  (in the destination collection) and removes a binding (in the source
  collection).  The BIND method introduced here provides a mechanism for
  adding a second binding to an existing resource.  There is no difference
  between an initial binding added by PUT, COPY, or MKCOL and additional
  bindings added with BIND.
</t>
<t>
  It would be very undesirable if one binding could be destroyed as a side
  effect of operating on the resource through a different binding.  In
  particular, the removal of one binding to a resource (e.g., with a DELETE or
  a MOVE) MUST NOT disrupt another binding to that resource, e.g., by turning
  that binding into a dangling path segment.  The server MUST NOT reclaim
  system resources after removing one binding, while other bindings to the
  resource remain.  In other words, the server MUST maintain the integrity<iref item="Binding Integrity"/> of
  a binding.  It is permissible, however, for future method definitions (e.g., a 
  DESTROY method) to have semantics that explicitly remove all bindings 
  and/or immediately reclaim system resources.
</t>
<t><list>
  <t>
    Note: the collection model described herein is not compatible
    with systems in which resources inherit properties based solely on the
    access path, as the ability to create additional bindings will cause a
    single resource to appear as member of several different collections at the
    same time.
  </t>
</list></t>

<section title="Bindings to Collections" anchor="bindings.to.collections">
<t>
  Creating a new binding to a collection makes each resource associated with
  a binding in that collection accessible via a new URI, and thus creates new
  URI mappings to those resources but no new bindings.
</t>
<t>
  For example, suppose a new binding CollY is created for collection C1 in the
  figure below.  It immediately becomes possible to access resource R1 using
  the URI /CollY/x.gif and to access resource R2 using the URI /CollY/y.jpg,
  but no new bindings for these child resources were created.  This is because
  bindings are part of the state of a collection, and they associate a URI that
  is relative to that collection with its target resource.  No change to the
  bindings in Collection C1 is needed to make its children accessible using
  /CollY/x.gif and /CollY/y.jpg.
</t>
<figure><artwork align="center" type="drawing"><![CDATA[
+-------------------------+
| Root Collection         |
|  bindings:              |
|  CollX          CollY   |
+-------------------------+
    |            /          
    |           /
    |          /
+------------------+
| Collection C1    |
| bindings:        |
| x.gif     y.jpg  |
+------------------+
    |          \               
    |           \               
    |            \              
+-------------+   +-------------+
| Resource R1 |   | Resource R2 |
+-------------+   +-------------+
]]></artwork></figure>

<section title="Bind Loops" anchor="bind.loops">
<t>
  Bindings to collections can result in loops ("cycles"), which servers MUST detect when
  processing "Depth: infinity" requests.  It is sometimes possible to complete
  an operation in spite of the presence of a loop.  For instance, a PROPFIND
  can still succeed if the server uses the new status code
  208 (Already Reported) defined in <xref target="status.208.already.reported"/>.
</t>
<t>  
  However, the 508 (Loop Detected) status code is defined in <xref target="status.508.loop.detected"/> for use in contexts where an
  operation is terminated because a loop was encountered.
</t>
<t>
  Support for loops is OPTIONAL: servers MAY reject
  requests that would lead to the creation of a bind loop (see DAV:cycle-allowed
  precondition defined in <xref target="METHOD_BIND"/>).
</t>
</section>


</section>

<section title="URI Mappings Created by a New Binding" anchor="uri.mappings.created.by.a.new.binding">
<t>
  Suppose a binding from "Binding-Name" to resource R is to be added to a
  collection, C. &nbsp;Then if C-MAP is the set of URIs that were mapped to C
  before the BIND request, then for each URI "C-URI" in C-MAP, the URI
  "C-URI/Binding-Name" is mapped to resource R following the BIND request.
</t>
<figure><preamble>
  For example, if a binding from "foo.html" to R is added to a collection C,
  and if the following URIs are mapped to C:
</preamble><artwork type="example"><![CDATA[
http://www.example.com/A/1/
http://example.com/A/one/
]]></artwork></figure>
<figure><preamble>
  then the following new mappings to R are introduced:
</preamble><artwork type="example"><![CDATA[
http://www.example.com/A/1/foo.html
http://example.com/A/one/foo.html
]]></artwork></figure>
<t>
  Note that if R is a collection, additional URI mappings are created to the
  descendents of R.&nbsp; Also, note that if a binding is made in collection C to C
  itself (or to a parent of C), an infinite number of mappings are introduced.
</t>
<figure><preamble>
  For example, if a binding from "myself" to C is then added to C, the
  following infinite number of additional mappings to C are introduced:
</preamble><artwork type="example"><![CDATA[
http://www.example.com/A/1/myself
http://www.example.com/A/1/myself/myself
   ...
]]></artwork></figure>
<figure><preamble>
  and the following infinite number of additional mappings to R are introduced:
</preamble><artwork type="example"><![CDATA[
http://www.example.com/A/1/myself/foo.html
http://www.example.com/A/1/myself/myself/foo.html
   ...
]]></artwork></figure>
</section> 
 


<section title="COPY and Bindings" anchor="copy.and.bindings">
<t>
  As defined in Section 9.8 of <xref target="RFC4918"/>, COPY causes the resource identified
  by the Request-URI to be duplicated and makes the new resource accessible 
  using the URI specified in the Destination header.  Upon successful
  completion of a COPY, a new binding is created between the last path
  segment of the Destination header and the destination resource.  The new
  binding is added to its parent collection, identified by the Destination
  header minus its final segment.
</t>
<figure><preamble>
  The following figure shows an example: suppose that a COPY is issued to
  URI-3 for resource R (which is also mapped to URI-1 and URI-2), with the
  Destination header set to URI-X.  After successful completion of the COPY
  operation, resource R is duplicated to create resource R', and a new binding
  has been created that creates at least the URI mapping between URI-X and
  the new resource (although other URI mappings may also have been created).
</preamble><artwork align="center" type="drawing"><![CDATA[
URI-1   URI-2    URI-3                           URI-X
   |       |        |                              |
   |       |        |   <---- URI Mappings ---->   |
   |       |        |                              |
+---------------------+                 +------------------------+
|     Resource R      |                 |     Resource R'        |
+---------------------+                 +------------------------+
]]></artwork></figure>
<t>
  It might be thought that a COPY request with "Depth: 0" on a collection would
  duplicate its bindings, since bindings are part of the collection's state.
  This is not the case, however.  The definition of Depth in <xref target="RFC4918"/> makes it
  clear that a "Depth: 0" request does not apply to a collection's members.
  Consequently, a COPY with "Depth: 0" does not duplicate the bindings
  contained by the collection.
</t>
<t>
  If a COPY request causes an existing resource to be updated, the bindings to
  that resource MUST be unaffected by the COPY request.  Using the preceding
  example, suppose that a COPY request is issued to URI-X for resource R', with
  the Destination header set to URI-2.  The content and dead properties of
  resource R would be updated to be a copy of those of resource R', but the
  mappings from URI-1, URI-2, and URI-3 to resource R remain unaffected.
  If, because of multiple bindings to a resource, more than one source resource
  updates a single destination resource, the order of the updates is server
  defined (see
  <xref target="example.copy.multiple.update"/> for an example).
</t>
<t>
  If a COPY request would cause a new resource to be created as a copy of an
  existing resource, and that COPY request has already created a copy of that
  existing resource, the COPY request instead creates another binding to the
  previous copy, instead of creating a new resource (see
  <xref target="example.copy.graph"/> for an example).
</t>

<section title="Example: COPY with &#34;Depth: infinity&#34; in Presence of Bind Loops">
<figure>
<preamble>
As an example of how COPY with "Depth: infinity" would work in the presence of
bindings, consider the following collection:
</preamble>
<artwork align="center" type="drawing"><![CDATA[
+------------------+
| Root Collection  |
|  bindings:       |
|  CollX           |
+------------------+
    |
    |
+-------------------------------+
| Collection C1                 |<-------+
| bindings:                     |        |
| x.gif      CollY              |        |
+-------------------------------+        |
    |            \        (creates loop) |
    |             \                      |
+-------------+   +------------------+   |
| Resource R1 |   | Collection C2    |   |
+-------------+   | bindings:        |   |
                  | y.gif     CollZ  |   |
                  +------------------+   |
                      |         |        |
                      |         +--------+
                      |
                  +-------------+
                  | Resource R2 |
                  +-------------+
]]></artwork>
</figure>
<figure>
<preamble>
If a COPY request with "Depth: infinity" is submitted to /CollX, with a destination of
/CollA, the outcome of the copy operation is that
a copy of the tree is replicated to the target /CollA:
</preamble>
<artwork align="center" type="drawing"><![CDATA[
+------------------+
| Root Collection  |
|  bindings:       |
|  CollX     CollA |
+------------------+
   |           |
   |           +---------------------------+
   |                                       |
+-------------------+                      |
| Collection C1     |<------------------+  |
| bindings:         |                   |  |
| x.gif      CollY  |                   |  |
+-------------------+                   |  |
   |            \        (creates loop) |  |
   |             \                      |  |
+-------------+   +-----------------+   |  |
| Resource R1 |   | Collection C2   |   |  |
+-------------+   | bindings:       |   |  |
                  | y.gif     CollZ |   |  |
                  +-----------------+   |  |
                      |         |       |  |
                      |         +-------+  |
                      |                    |
                  +-------------+          |
                  | Resource R2 |          |
                  +-------------+          |
                                           |
           +-------------------------------+
           |
+-------------------+
| Collection C3     |<------------------+
| bindings:         |                   |
| x.gif      CollY  |                   |
+-------------------+                   |
   |            \        (creates loop) |
   |             \                      |
+-------------+   +-----------------+   |
| Resource R3 |   | Collection C4   |   |
+-------------+   | bindings:       |   |
                  | y.gif     CollZ |   |
                  +-----------------+   |
                      |         |       |
                      |         +-------+
                      |
                  +-------------+
                  | Resource R4 |
                  +-------------+
]]></artwork>
</figure>

<t>
  Note that the same would apply for more complex loops.
</t>

</section>


<section title="Example: COPY Updating Multiple Bindings" anchor="example.copy.multiple.update">
<figure><preamble>
Given the following collection hierarchy:
</preamble><artwork align="center" type="drawing" xml:space="preserve"><![CDATA[
                    +------------------+
                    | Root Collection  |
                    |  bindings:       |
                    |  CollX     CollY |
                    +------------------+
                       /              \
                      /                \
                     /                  \           
  +--------------------------+   +-----------------+
  |      Collection C1       |   | Collection C2   |
  |      bindings:           |   | bindings:       |
  |     x.gif     y.gif      |   | x.gif     y.gif |
  +--------------------------+   +-----------------+
          |         |                |         |
          |         |                |         |
+-------------+  +-------------+   +-------------+
| Resource R1 |  | Resource R2 |   | Resource R3 |
+-------------+  +-------------+   +-------------+
]]></artwork>
<postamble>
  A COPY of /CollX with "Depth: infinity" to /CollY will not result in a changed
  hierarchy, and Resource R3 will be updated with the content of either Resource R1
  or Resource R2.
</postamble>
</figure>
</section>


<section title="Example: COPY with &#34;Depth: infinity&#34; with Multiple Bindings to a Leaf Resource" anchor="example.copy.graph">
<figure><preamble>
Given the following collection hierarchy:
</preamble><artwork align="center" type="drawing"><![CDATA[
+------------------+
| Root Collection  |
|  bindings:       |
|  CollX           |
+------------------+
   |            
   |  
   |               
+----------------+ 
| Collection C1  |
| bindings:      |
| x.gif    y.gif | 
+----------------+
   |         |     
   |         |    
 +-------------+   
 | Resource R1 |
 +-------------+
]]></artwork></figure>
<figure><preamble>
A COPY of /CollX with "Depth: infinity" to /CollY results in the following
collection hierarchy:
</preamble><artwork align="center" type="drawing"><![CDATA[
+------------------+
| Root Collection  |
|  bindings:       |
|  CollX     CollY |
+------------------+
   |              \
   |               \
   |                \           
+----------------+  +-----------------+
| Collection C1  |  | Collection C2   |
| bindings:      |  | bindings:       |
| x.gif    y.gif |  | x.gif     y.gif |
+----------------+  +-----------------+
   |         |          |         |
   |         |          |         |
 +-------------+      +-------------+
 | Resource R1 |      | Resource R2 |
 +-------------+      +-------------+
]]></artwork></figure>
</section>

</section> 
 
<section title="DELETE and Bindings" anchor="delete.and.bindings">
<t>
  When there are multiple bindings to a resource, a DELETE applied to that
  resource MUST NOT remove any bindings to that resource other than the one
  identified by the Request-URI.  For example, suppose the collection
  identified by the URI "/a" has a binding named "x" to a resource R, and
  another collection identified by "/b" has a binding named "y" to the same
  resource R.&nbsp;  Then, a DELETE applied to "/a/x" removes the binding named "x"
  from "/a" but MUST NOT remove the binding named "y" from "/b" (i.e., after the
  DELETE, "/y/b" continues to identify the resource R).
</t>
<t>
  When DELETE is applied to a collection, it MUST NOT modify the membership
  of any other collection that is not itself a member of the collection being
  deleted.  For example, if both "/a/.../x" and "/b/.../y" identify the same
  collection, C, then applying DELETE to "/a" must not delete an internal
  member from C or from any other collection that is a member of C, because
  that would modify the membership of "/b". 
</t>
<t>
  If a collection supports the UNBIND method (see <xref target="METHOD_UNBIND"/>), a DELETE of an
  internal member of a collection MAY be implemented as an UNBIND request.
  In this case, applying DELETE to a Request-URI has the effect of removing
  the binding identified by the final segment of the Request-URI from the
  collection identified by the Request-URI minus its final segment.  Although
  <xref target="RFC4918"/> allows a DELETE to be a non-atomic operation, when the DELETE
  operation is implemented as an UNBIND, the operation is atomic.  In
  particular, a DELETE on a hierarchy of resources is simply the removal of a
  binding to the collection identified by the Request-URI. 
</t>
</section>

<section title="MOVE and Bindings" anchor="move.and.bindings">
<t>
  When MOVE is applied to a resource, the other bindings to that resource
  MUST be unaffected; and if the resource being moved is a collection, the
  bindings to any members of that collection MUST be unaffected.  Also, if MOVE
  is used with Overwrite:T to delete an existing resource, the constraints
  specified for DELETE apply.
</t>
<t>
  If the destination collection of a MOVE request supports the REBIND method
  (see <xref target="METHOD_REBIND"/>), a MOVE of a resource into that collection MAY be implemented
  as a REBIND request.  Although <xref target="RFC4918"/> allows a MOVE to be a non-atomic
  operation, when the MOVE operation is implemented as a REBIND, the operation
  is atomic.  In particular, applying a MOVE to a Request-URI and a Destination
  URI has the effect of removing a binding to a resource (at the Request-URI)
  and creating a new binding to that resource (at the Destination URI).  
  Even when the
  Request-URI identifies a collection, the MOVE operation involves only
  removing one binding to that collection and adding another.
</t>

<section title="Example: Simple MOVE">
<t>
  As an example, suppose that a MOVE is issued to URI-3 for resource R below
  (which is also mapped to URI-1 and URI-2), with the Destination header set
  to URI-X.  After successful completion of the MOVE operation, a new binding
  has been created that creates the URI mapping between URI-X and resource R.&nbsp;  The 
  binding corresponding to the final segment of URI-3 has been removed,
  which also causes the URI mapping between URI-3 and R to be removed.  If
  resource R were a collection, old URI-3-based mappings to members of R
  would have been removed, and new URI-X-based mappings to members of R would
  have been created.  
</t>
<figure><preamble>
&gt;&gt; Before Request:
</preamble><artwork align="center" type="drawing"><![CDATA[
 URI-1   URI-2    URI-3
   |       |        |          
   |       |        |      <---- URI Mappings
   |       |        |
+---------------------+
|     Resource R      |
+---------------------+
]]></artwork></figure>
<figure><preamble>
&gt;&gt; After Request:
</preamble><artwork align="center" type="drawing"><![CDATA[
 URI-1   URI-2    URI-X
   |       |        |          
   |       |        |      <---- URI Mappings
   |       |        |
+---------------------+
|     Resource R      |
+---------------------+
]]></artwork></figure>
</section>

<section title="Example: MOVE Request Causing a Bind Loop">
<t>
  Note that in the presence of collection bindings, a MOVE request can cause
  the creation of a bind loop.
</t>
<figure>
<preamble>Consider the top-level collections C1 and C2 with URIs
"/CollW/" and "/CollX/". C1 also contains an additional binding named
"CollY" to C2:</preamble>
<artwork align="center" type="drawing"><![CDATA[
                  +------------------+
                  | Root Collection  |
                  |  bindings:       |
                  |  CollW    CollX  |
                  +------------------+
                      |          |
                      |          |
         +------------------+    |
         | Collection C1    |    |
         |  bindings:       |    |
         |           CollY  |    |
         +------------------+    |
                      |          |
                      |          |
                  +------------------+
                  | Collection C2    |
                  |                  |
                  |                  |
                  +------------------+
]]></artwork></figure>
<t>
  In this case, the MOVE request below would cause a bind loop:
</t>
<figure><preamble>
&gt;&gt; Request:
</preamble><artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
MOVE /CollW HTTP/1.1
Host: example.com
Destination: /CollX/CollZ
]]></artwork></figure>
<figure>
<preamble>If the request succeeded, the resulting state would be:</preamble>
<artwork align="center" type="drawing"><![CDATA[
                  +------------------+
                  | Root Collection  |
                  |  bindings:       |
                  |           CollX  |
                  +------------------+
                                 |
                                 |
         +------------------+    |
         | Collection C1    |    |
  +----> |  bindings:       |    |
  |      |           CollY  |    |
  |      +------------------+    |
  |                   |          |
  |                   |          |
  |               +------------------+
  |               | Collection C2    |
  |               |  bindings:       |
  |               | CollZ            |
  |               +------------------+
  |                   |
  |                   |
  +-------------------+
]]></artwork></figure>
</section>

</section>

<section title="PROPFIND and Bindings">
<t>
  Consistent with <xref target="RFC4918"/>, the value of a dead property MUST be independent of the number of bindings to
  its host resource or of the path submitted to PROPFIND.  On the other hand, the behavior
  for each live property depends on its individual definition (for example, see <xref target="RFC3744"/>, Section 5, Paragraph 2
  for a case where the value is independent of its path and bindings, and
  <xref target="RFC4918"/>, Section 8.8 for a discussion about the
  live properties DAV:getetag and DAV:getlastmodified, which may behave
  differently).
</t>
</section>

<section title="Determining Whether Two Bindings Are to the Same Resource" anchor="determining.whether.two.bindings.are.to.the.same.resource">
<t>
  It is useful to have some way of determining whether two bindings are to the
  same resource.  Two resources might have identical contents and properties,
  but not be the same resource (e.g., an update to one resource does not affect
  the other resource).
</t>
<t>
  The REQUIRED DAV:resource-id property defined in <xref target="PROPERTY_resource-id"/> is a resource
  identifier, which MUST be unique across all resources for all time.  If the
  values of DAV:resource-id returned by PROPFIND requests through two bindings
  are identical character by character, the client can be assured that the two bindings are to the
  same resource.
</t>
<t>
  The DAV:resource-id property is created, and its value assigned, when the
  resource is created.  The value of DAV:resource-id MUST NOT be changed.
  Even after the resource is no longer accessible through any URI, that value
  MUST NOT be reassigned to another resource's DAV:resource-id property.
</t>
<t>
  Any method that creates a new resource MUST assign a new, unique value to
  its DAV:resource-id property. For example, a PUT applied to a null resource,
  COPY (when not overwriting an existing target) and 
  CHECKIN (see <xref target="RFC3253"/>, Section 4.4) must assign a new, unique value to the DAV:resource-id property
  of the new resource they create.
</t>
<t>
  On the other hand, any method that affects an existing resource 
  must not change the value of its DAV:resource-id property.  Specifically, a PUT or a
  COPY that updates an existing resource must not change the value of its
  DAV:resource-id property.  A REBIND, since it does not create a new resource,
  but only changes the location of an existing resource, must not change the
  value of the DAV:resource-id property.
</t>
</section>

<section title="Discovering the Bindings to a Resource" anchor="discovering.the.bindings.to.a.resource">
<t>
  An OPTIONAL DAV:parent-set property on a resource provides a list of the
  bindings that associate a collection and a URI segment with that resource.  If
  the DAV:parent-set property exists on a given resource, it MUST contain
  a complete list of all bindings to that resource that the client is
  authorized to see.  When deciding whether to support the DAV:parent-set
  property, server implementers / administrators should balance the benefits
  it provides against the cost of maintaining the property and the security
  risks enumerated in Sections 
  <xref target="private.locations.may.be.revealed" format="counter"/> and <xref target="parent-set.and.denial.of.service" format="counter"/>.
</t>
</section>

</section>
  
<section title="Properties" anchor="properties">
<t>
  The bind feature introduces the properties defined below.
</t>
<t>
  A DAV:allprop PROPFIND request SHOULD NOT return any of the properties
  defined by this document.  This allows a binding server to perform
  efficiently when a naive client, which does not understand the cost of
  asking a server to compute all possible live properties, issues a DAV:allprop
  PROPFIND request.
</t>

<section title="DAV:resource-id Property" anchor="PROPERTY_resource-id">
<iref item="DAV:resource-id property" primary="true"/>
<iref item="Properties" subitem="DAV:resource-id" primary="true"/>
<t>
  The DAV:resource-id property is a REQUIRED property that enables clients to
  determine whether two bindings are to the same resource.  The value of
  DAV:resource-id is a URI, and may use any registered URI scheme that
  guarantees the uniqueness of the value across all resources for all time
  (e.g., the urn:uuid: URN namespace defined in <xref target="RFC4122"/> or
  the opaquelocktoken: URI scheme defined in <xref target="RFC4918"/>).
</t>
<figure><artwork type="application/xml-dtd"><![CDATA[
<!ELEMENT resource-id (href)>
]]></artwork></figure>

</section>

<section title="DAV:parent-set Property" anchor="PROPERTY_parent-set">
<iref item="DAV:parent-set property" primary="true"/>
<iref item="Properties" subitem="DAV:parent-set" primary="true"/>
<t>
  The DAV:parent-set property is an OPTIONAL property that enables clients to
  discover what collections contain a binding to this resource (i.e., what
  collections have that resource as an internal member).  It contains an  
  href/segment pair for each collection that has a binding to the resource.
  The href identifies the collection, and the segment identifies the binding
  name of that resource in that collection.
</t>
<t>
  A given collection MUST appear only once in the DAV:parent-set for any given
  binding, even if there are multiple URI mappings to that collection.
</t>
<figure><artwork type="application/xml-dtd"><![CDATA[
<!ELEMENT parent-set (parent)*>
<!ELEMENT parent (href, segment)>
<!ELEMENT segment (#PCDATA)>
<!-- PCDATA value: segment, as defined in Section 3.3 of
     [RFC3986] -->

]]></artwork></figure>


<section title="Example for DAV:parent-set Property">
<t>
  For example, if collection C1 is mapped to both /CollX and /CollY, and C1
  contains a binding named "x.gif" to a resource R1, then either
  [/CollX, x.gif] or [/CollY, x.gif] can appear in the DAV:parent-set of R1,
  but not both.  But if C1 also had a binding named "y.gif" to R1, then there
  would be two entries for C1 in the DAV:parent-set of R1 (i.e., both
  [/CollX, x.gif] and [/CollX, y.gif] or, alternatively, both [/CollY, x.gif]
  and [/CollY, y.gif]).
</t>
<figure><artwork align="center" type="drawing"><![CDATA[
+-------------------------+
| Root Collection         |
|  bindings:              |
|  CollX          CollY   |
+-------------------------+
    |            /          
    |           /
    |          /
+-----------------+
| Collection C1   |
| bindings:       |
| x.gif    y.gif  |
+-----------------+
     |      |               
     |      |               
     |      |              
 +-------------+
 | Resource R1 |
 +-------------+
]]></artwork>
</figure>
<t>
  In this case, one possible value for the DAV:parent-set property on
  "/CollX/x.gif" would be: 
</t>
<figure><artwork type="text/plain"><![CDATA[

  <parent-set xmlns="DAV:">
    <parent>
      <href>/CollX</href>
      <segment>x.gif</segment>
    </parent>
    <parent>
      <href>/CollX</href>
      <segment>y.gif</segment>
    </parent>
  </parent-set>
]]></artwork></figure>
</section>
</section>
</section>

<section title="BIND Method" anchor="METHOD_BIND">
<iref item="BIND method" primary="true"/>
<iref item="Methods" subitem="BIND" primary="true"/>
<t>
  The BIND method modifies the collection identified by the Request-URI, by
  adding a new binding from the segment specified in the BIND body to the
  resource identified in the BIND body.
</t>
<t>
  If a server cannot guarantee the integrity<iref item="Binding Integrity"/> of the binding, the BIND request
  MUST fail.  Note that it is especially difficult to maintain the integrity of
  cross-server bindings.  Unless the server where the resource resides knows
  about all bindings on all servers to that resource, it may unwittingly
  destroy the resource or make it inaccessible without notifying another
  server that manages a binding to the resource.  For example, if server A
  permits the creation of a binding to a resource on server B, server A must
  notify server B about its binding and must have an agreement with B that B
  will not destroy the resource while A's binding exists.  Otherwise, server B
  may receive a DELETE request that it thinks removes the last binding to the
  resource and destroy the resource while A's binding still exists.
  The precondition DAV:cross-server-binding is defined below
  for cases where servers fail cross-server BIND requests because they cannot
  guarantee the integrity of cross-server bindings.
</t>
<t>
  By default, if there already is a binding for the specified segment in the
  collection, the new binding replaces the existing binding.  This default
  binding replacement behavior can be overridden using the Overwrite header
  defined in Section 10.6 of <xref target="RFC4918"/>.
</t>
<t>
   If a BIND request fails, the server state preceding the request MUST be restored.
   This method is unsafe and idempotent (see <xref target="RFC2616"/>, Section 9.1).
</t>
<t>
  <iref item="BIND method" subitem="Marshalling"/>
  Marshalling:
  <list>
    <t>The request MAY include an Overwrite header.</t>
    <t>The request body MUST be a DAV:bind XML element.
      <figure><artwork type="application/xml-dtd"><![CDATA[
   <!ELEMENT bind (segment, href)>
         ]]></artwork></figure>
    </t>
    <t> 
      If the request succeeds, the server MUST return 201 (Created) when a new
      binding was created and 200 (OK) or 204 (No Content)  when an existing binding was replaced.
    </t>
    <t>
      If a response body for a successful request is included, it MUST be a
      DAV:bind-response XML element.  Note that this document does not define
      any elements for the BIND response body, but the DAV:bind-response
      element is defined to ensure interoperability between future extensions
      that do define elements for the BIND response body.
      <figure><artwork type="application/xml-dtd"><![CDATA[
   <!ELEMENT bind-response ANY>
         ]]></artwork></figure>
    </t>
  </list>
</t>
<t>
  <iref item="BIND method" subitem="Preconditions"/>
  Preconditions:
  <list>
    <t>
      <iref item="Condition Names" subitem="DAV:bind-into-collection (pre)" primary="true"/>
      <iref item="DAV:bind-into-collection precondition" primary="true"/>
      (DAV:bind-into-collection): The Request-URI MUST identify a collection.
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:bind-source-exists (pre)" primary="true"/>
      <iref item="DAV:bind-source-exists precondition" primary="true"/>
      (DAV:bind-source-exists): The DAV:href element MUST identify a resource.
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:binding-allowed (pre)" primary="true"/>
      <iref item="DAV:binding-allowed precondition" primary="true"/>
      (DAV:binding-allowed): The resource identified by the DAV:href supports
      multiple bindings to it.
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:cross-server-binding (pre)" primary="true"/>
      <iref item="DAV:cross-server-binding precondition" primary="true"/>
      (DAV:cross-server-binding): If the resource identified by the DAV:href
      element in the request body is on another server from the collection
      identified by the Request-URI, the server MUST support cross-server
      bindings
      (servers that do not support cross-server bindings can use this
      condition code to signal the client exactly why the request failed).
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:name-allowed (pre)" primary="true"/>
      <iref item="DAV:name-allowed precondition" primary="true"/>
      (DAV:name-allowed): The name specified by the DAV:segment is available
      for use as a new binding name.
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:can-overwrite (pre)" primary="true"/>
      <iref item="DAV:can-overwrite precondition" primary="true"/>
      (DAV:can-overwrite): If the collection already contains a binding with
      the specified path segment, and if an Overwrite header is included, the
      value of the Overwrite header MUST be "T".
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:cycle-allowed (pre)" primary="true"/>
      <iref item="DAV:cycle-allowed precondition" primary="true"/>
      (DAV:cycle-allowed): If the DAV:href element identifies a collection,
      and if the Request-URI identifies a collection that is a member of that
      collection, the server MUST support cycles in the URI namespace
      (servers that do not support cycles can use this
      condition code to signal the client exactly why the request failed).
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:locked-update-allowed (pre)" primary="true"/>
      <iref item="DAV:locked-update-allowed precondition" primary="true"/>
      (DAV:locked-update-allowed): If the collection identified by the
      Request-URI is write-locked, then the appropriate token MUST be specified
      in an If request header.
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:locked-overwrite-allowed (pre)" primary="true"/>
      <iref item="DAV:locked-overwrite-allowed precondition" primary="true"/>
      (DAV:locked-overwrite-allowed): If the collection already contains a
      binding with the specified path segment, and if that binding is protected
      by a write lock, then the appropriate token MUST be specified in an If
      request header.
    </t>
  </list>
</t>
<t>
  <iref item="BIND method" subitem="Postconditions"/>
  Postconditions:
  <list>
    <t>
      <iref item="Condition Names" subitem="DAV:new-binding (post)" primary="true"/>
      <iref item="DAV:new-binding postcondition" primary="true"/>
      (DAV:new-binding): The collection MUST have a binding that maps the
      segment specified in the DAV:segment element in the request body to the
      resource identified by the DAV:href element in the request body.
    </t>
  </list>
</t>

<section title="Example: BIND">
<figure><preamble>
&gt;&gt; Request:
</preamble><artwork type="message/http; msgtype=&#34;request&#34;" xml:space="preserve"><![CDATA[
BIND /CollY HTTP/1.1
Host: www.example.com
Content-Type: application/xml; charset="utf-8"
Content-Length: 172

<?xml version="1.0" encoding="utf-8" ?>
<D:bind xmlns:D="DAV:">
   <D:segment>bar.html</D:segment>
   <D:href>http://www.example.com/CollX/foo.html</D:href>
</D:bind>
]]></artwork></figure>
<figure><preamble>
&gt;&gt; Response:
</preamble><artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 201 Created
Location: http://www.example.com/CollY/bar.html
]]></artwork></figure>
<t>
  The server added a new binding to the collection,
  "http://www.example.com/CollY", associating "bar.html" with the resource
  identified by the URI "http://www.example.com/CollX/foo.html".  Clients can
  now use the URI "http://www.example.com/CollY/bar.html" to submit requests 
  to that resource.
</t>
</section>
</section>
  
<section title="UNBIND Method" anchor="METHOD_UNBIND">
<iref item="UNBIND method" primary="true"/>
<iref item="Methods" subitem="UNBIND" primary="true"/>
<t>
  The UNBIND method modifies the collection identified by the Request-URI by
  removing the binding identified by the segment specified in the UNBIND body.
</t>
<t>
  Once a resource is unreachable by any URI mapping, the server MAY reclaim
  system resources associated with that resource.  If UNBIND removes a binding
  to a resource, but there remain URI mappings to that resource, the server
  MUST NOT reclaim system resources associated with the resource.
</t>
<t>
   If an UNBIND request fails, the server state preceding the request MUST be restored.
   This method is unsafe and idempotent (see <xref target="RFC2616"/>, Section 9.1).
</t>
<t>
  <iref item="UNBIND method" subitem="Marshalling"/>
  Marshalling:
  <list>
    <t>The request body MUST be a DAV:unbind XML element.
      <figure><artwork type="application/xml-dtd"><![CDATA[
   <!ELEMENT unbind (segment)>
   ]]></artwork></figure></t>
    <t>If the request succeeds, the server MUST return 200 (OK) or 204 (No Content) when the
    binding was successfully deleted.</t>
    <t>If a response body for a successful request is included, it MUST be a
    DAV:unbind-response XML element.  Note that this document does not define
    any elements for the UNBIND response body, but the DAV:unbind-response
    element is defined to ensure interoperability between future extensions
    that do define elements for the UNBIND response body.
    <figure><artwork type="application/xml-dtd"><![CDATA[
   <!ELEMENT unbind-response ANY>
   ]]></artwork></figure></t>
  </list>
</t>
<t>
  <iref item="UNBIND method" subitem="Preconditions"/>
  Preconditions:
  <list>
    <t>
      <iref item="Condition Names" subitem="DAV:unbind-from-collection (pre)" primary="true"/>
      <iref item="DAV:unbind-from-collection precondition" primary="true"/>
      (DAV:unbind-from-collection): The Request-URI MUST identify a collection.
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:unbind-source-exists (pre)" primary="true"/>
      <iref item="DAV:unbind-source-exists precondition" primary="true"/>
      (DAV:unbind-source-exists): The DAV:segment element MUST identify a
      binding in the collection identified by the Request-URI.
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:locked-update-allowed (pre)" primary="true"/>
      <iref item="DAV:locked-update-allowed precondition" primary="true"/>
      (DAV:locked-update-allowed): If the collection identified by the
      Request-URI is write-locked, then the appropriate token MUST be specified
      in the request.
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:protected-url-deletion-allowed (pre)" primary="true"/>
      <iref item="DAV:protected-url-deletion-allowed precondition" primary="true"/>
      (DAV:protected-url-deletion-allowed): If the binding identified by the
      segment is protected by a write lock, then the appropriate token MUST be
      specified in the request.
    </t>
  </list>
</t>
<t>
  <iref item="UNBIND method" subitem="Postconditions"/>
  Postconditions:
  <list>
    <t>
      <iref item="Condition Names" subitem="DAV:binding-deleted (post)" primary="true"/>
      <iref item="DAV:binding-deleted postcondition" primary="true"/>
      (DAV:binding-deleted): The collection MUST NOT have a binding for the
      segment specified in the DAV:segment element in the request body.
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:lock-deleted (post)" primary="true"/>
      <iref item="DAV:lock-deleted postcondition" primary="true"/>
      (DAV:lock-deleted): If the internal member URI of the binding specified
      by the Request-URI and the DAV:segment element in the 
      request body was protected by a write lock at the time of the request, 
      that write lock must have been deleted by the request.
    </t>
  </list>
</t>

<section title="Example: UNBIND">
<figure><preamble>
&gt;&gt; Request:
</preamble><artwork type="message/http; msgtype=&#34;request&#34;" xml:space="preserve"><![CDATA[
UNBIND /CollX HTTP/1.1
Host: www.example.com
Content-Type: application/xml; charset="utf-8"
Content-Length: 117

<?xml version="1.0" encoding="utf-8" ?>
<D:unbind xmlns:D="DAV:">
   <D:segment>foo.html</D:segment>
</D:unbind>
]]></artwork></figure>
<figure><preamble>
&gt;&gt; Response:
</preamble><artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 200 OK
]]></artwork></figure>
<t>
  The server removed the binding named "foo.html" from the collection,
  "http://www.example.com/CollX".  A request to the resource named
  "http://www.example.com/CollX/foo.html" will return a 404 (Not Found) response.
</t>
</section>
</section>
  
<section title="REBIND Method" anchor="METHOD_REBIND">
<iref item="REBIND method" primary="true"/>
<iref item="Methods" subitem="REBIND" primary="true"/>
<t>
  The REBIND method removes a binding to a resource from a collection, and adds a binding to that resource into 
  the collection identified by the Request-URI.  The
  request body specifies the binding to be added (segment) and the 
  old binding to be removed
  (href).  It is effectively an atomic form of a MOVE request,
  and MUST be treated the same way as MOVE for the purpose of determining access permissions.
</t>
<t>
   If a REBIND request fails, the server state preceding the request MUST be restored.
   This method is unsafe and idempotent (see <xref target="RFC2616"/>, Section 9.1).
</t>
<t>
  <iref item="REBIND method" subitem="Marshalling"/>
  Marshalling:
  <list>
    <t>The request MAY include an Overwrite header.</t>
    <t>The request body MUST be a DAV:rebind XML element.
      <figure><artwork type="application/xml-dtd"><![CDATA[
   <!ELEMENT rebind (segment, href)>
   ]]></artwork></figure></t>
    <t>If the request succeeds, the server MUST return 201 (Created) when a
    new binding was created and 200 (OK) or 204 (No Content) when an existing binding was replaced.</t>
    <t>If a response body for a successful request is included, it MUST be a
      DAV:rebind-response XML element.  Note that this document does not define
      any elements for the REBIND response body, but the DAV:rebind-response
      element is defined to ensure interoperability between future extensions
      that do define elements for the REBIND response body.
      <figure><artwork type="application/xml-dtd"><![CDATA[
   <!ELEMENT rebind-response ANY>
   ]]></artwork></figure></t>
  </list> 
</t>
<t>
  <iref item="REBIND method" subitem="Preconditions"/>
  Preconditions:
  <list>
    <t>
      <iref item="Condition Names" subitem="DAV:rebind-from-collection (pre)" primary="true"/>
      <iref item="DAV:rebind-from-collection precondition" primary="true"/>
      (DAV:rebind-into-collection): The Request-URI MUST identify a
      collection.
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:rebind-source-exists (pre)" primary="true"/>
      <iref item="DAV:rebind-source-exists precondition" primary="true"/>
      (DAV:rebind-source-exists): The DAV:href element MUST identify a
      resource.
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:cross-server-binding (pre)" primary="true"/>
      <iref item="DAV:cross-server-binding precondition" primary="true"/>
      (DAV:cross-server-binding): If the resource identified by the DAV:href
      element in the request body is on another server from the collection
      identified by the Request-URI, the server MUST support cross-server bindings
      (servers that do not support cross-server bindings can use this
      condition code to signal the client exactly why the request failed).
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:name-allowed (pre)" primary="true"/>
      <iref item="DAV:name-allowed precondition" primary="true"/>
      (DAV:name-allowed): The name specified by the DAV:segment is available
      for use as a new binding name.
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:can-overwrite (pre)" primary="true"/>
      <iref item="DAV:can-overwrite precondition" primary="true"/>
      (DAV:can-overwrite): If the collection already contains a binding with
      the specified path segment, and if an Overwrite header is included, the
      value of the Overwrite header MUST be "T".
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:cycle-allowed (pre)" primary="true"/>
      <iref item="DAV:cycle-allowed precondition" primary="true"/>
      (DAV:cycle-allowed): If the DAV:href element identifies a collection,
      and if the Request-URI identifies a collection that is a member of that
      collection, the server MUST support cycles in the URI namespace
      (servers that do not support cycles can use this
      condition code to signal the client exactly why the request failed).
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:locked-update-allowed (pre)" primary="true"/>
      <iref item="DAV:locked-update-allowed precondition" primary="true"/>
      (DAV:locked-update-allowed): If the collection identified by the
      Request-URI is write-locked, then the appropriate token MUST be specified
      in the request.
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:protected-url-modification-allowed (pre)" primary="true"/>
      <iref item="DAV:protected-url-modification-allowed precondition" primary="true"/>
      (DAV:protected-url-modification-allowed): If the collection identified
      by the Request-URI already contains a binding with the specified path
      segment, and if that binding is protected by a write lock, then the
      appropriate token MUST be specified in the request.
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:locked-source-collection-update-allowed (pre)" primary="true"/>
      <iref item="DAV:locked-source-collection-update-allowed precondition" primary="true"/>
      (DAV:locked-source-collection-update-allowed): If the collection
      identified by the parent collection prefix of the DAV:href  URI is
      write-locked, then the appropriate token MUST be specified in the request.
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:protected-source-url-deletion-allowed (pre)" primary="true"/>
      <iref item="DAV:protected-source-url-deletion-allowed precondition" primary="true"/>
      (DAV:protected-source-url-deletion-allowed): If the DAV:href URI is
      protected by a write lock, then the appropriate token MUST be specified
      in the request.
    </t>
  </list>
</t>
<t>
  <iref item="REBIND method" subitem="Postconditions"/>
  Postconditions:
  <list>
    <t>
      <iref item="Condition Names" subitem="DAV:new-binding (post)" primary="true"/>
      <iref item="DAV:new-binding postcondition" primary="true"/>
      (DAV:new-binding): The collection MUST have a binding that maps the
      segment specified in the DAV:segment element in the request body, to the
      resource that was identified by the DAV:href element in the request body.
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:binding-deleted (post)" primary="true"/>
      <iref item="DAV:binding-deleted postcondition" primary="true"/>
      (DAV:binding-deleted): The URL specified in the DAV:href element in the
      request body MUST NOT be mapped to a resource.
    </t>
    <t>
      <iref item="Condition Names" subitem="DAV:lock-deleted (post)" primary="true"/>
      <iref item="DAV:lock-deleted postcondition" primary="true"/>
      (DAV:lock-deleted): If the URL specified in the DAV:href element in the 
      request body was protected by a write lock at the time of the request, 
      that write lock must have been deleted by the request.
    </t>
  </list>
</t>

<section title="Example: REBIND">
<figure><preamble>
&gt;&gt; Request:
</preamble><artwork type="message/http; msgtype=&#34;request&#34;" xml:space="preserve"><![CDATA[
REBIND /CollX HTTP/1.1
Host: www.example.com
Content-Type: application/xml; charset="utf-8"
Content-Length: 176

<?xml version="1.0" encoding="utf-8" ?>
<D:rebind xmlns:D="DAV:">
   <D:segment>foo.html</D:segment>
   <D:href>http://www.example.com/CollY/bar.html</D:href>
</D:rebind>
]]></artwork></figure>
<figure><preamble>
&gt;&gt; Response:
</preamble><artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 200 OK
]]></artwork></figure>
<t>
  The server added a new binding to the collection, "http://www.example.com/CollX",
  associating "foo.html" with the resource identified by the URI
  "http://www.example.com/CollY/bar.html" and removes the binding named
  "bar.html" from the collection identified by the URI "http://www.example.com/CollY".  Clients
  can now use the URI "http://www.example.com/CollX/foo.html" to submit
  requests to that resource, and requests on the URI
  "http://www.example.com/CollY/bar.html" will fail with a 404 (Not Found) response.
</t>
</section>

<section title="Example: REBIND in Presence of Locks and Bind Loops">
<figure>
<preamble>
  To illustrate the effects of locks and bind loops on a REBIND operation,
  consider the following collection:
</preamble>
<artwork align="center" type="drawing"><![CDATA[
+------------------+
| Root Collection  |
|  bindings:       |
|  CollW           |
+------------------+
     |
     |
     |
+-------------------------------+
| Collection C1                 |<--------+
| LOCKED infinity               |         |
| (lock token L1)               |         |
| bindings:                     |         |
| CollX               CollY     |         |
+-------------------------------+         |
     |                  |                 |
     |                  |  (creates loop) |
     |                  |                 |
+-----------------+  +------------------+ |
| Collection C2   |  | Collection C3    | |
| (inherit lock)  |  | (inherit lock)   | | 
| (lock token L1) |  | (lock token L1)  | |
| bindings:       |  | bindings:        | |
|  {none}         |  | y.gif     CollZ  | |
+-----------------+  +------------------+ |
                       |            |     |
                       |            +-----+
                       |
                   +---------------------------+
                   | Resource R2               |
                   | (lock inherited from C1)  |
                   | (lock token L1)           |
                   +---------------------------+
]]></artwork>
<postamble>
  (where L1 is "urn:uuid:f92d4fae-7012-11ab-a765-00c0ca1f6bf9").
</postamble>
</figure>
<t>
  Note that the binding between CollZ and C1 creates a loop in the containment
  hierarchy.  Servers are not required to support such loops, though the server
  in this example does.
</t>
<figure>
<preamble>
  The REBIND request below will remove the segment "CollZ" from C3 and add a new
  binding from "CollA" to the collection C2.
</preamble>
<artwork type="message/http; msgtype=&#34;request&#34;" xml:space="preserve"><![CDATA[
REBIND /CollW/CollX HTTP/1.1
Host: www.example.com
If: (<urn:uuid:f92d4fae-7012-11ab-a765-00c0ca1f6bf9>)
Content-Type: application/xml; charset="utf-8"
Content-Length: 152

<?xml version="1.0" encoding="utf-8" ?>
<D:rebind xmlns:D="DAV:">
  <D:segment>CollA</D:segment>
  <D:href>/CollW/CollY/CollZ</D:href>
</D:rebind>
]]></artwork></figure>
<figure>
<preamble>
  The outcome of the REBIND operation is:
</preamble>
<artwork align="center" type="drawing"><![CDATA[
+------------------+
| Root Collection  |
|  bindings:       |
|  CollW           |
+------------------+
     |
     |
     |
+-------------------------------+
| Collection C1                 |
| LOCKED infinity               |
| (lock token L1)               |
| bindings:                     |  
| CollX                  CollY  |
+-------------------------------+
     |              ^      |             
     |              |      |              
+-----------------+ | +------------------+ 
| Collection C2   | | | Collection C3    |
|(inherited lock) | | | (inherited lock) |
|(lock token L1)  | | | (lock token L1)  |
| bindings:       | | | bindings:        |
| CollA           | | | y.gif            |
+-----------------+ | +------------------+
    |               |    |           
    +---------------+    |          
     (creates loop)      |
                   +---------------------------+
                   | Resource R2               |
                   | (inherited lock from C1)  |
                   | (lock token L1)           |
                   +---------------------------+
]]></artwork>
</figure>
</section>
</section>

<section title="Additional Status Codes" anchor="additional.status.codes">

<section title="208 Already Reported" anchor="status.208.already.reported">
<iref item="Status Codes" subitem="208 Already Reported" primary="true"/>
<iref item="208 Already Reported (status code)" primary="true"/>
<t>
  The 208 (Already Reported) status code can be used inside a DAV:propstat
  response element to avoid enumerating the internal members of multiple
  bindings to the same collection repeatedly.  For each binding to a 
  collection inside the request's scope, only one will
  be reported with a 200 status, while subsequent DAV:response elements for all
  other bindings will use the 208 status, and no DAV:response elements for
  their descendants are included.
</t>
<t>
  Note that the 208 status will only occur for "Depth: infinity" requests,
  and that it is of particular importance when the multiple collection
  bindings cause a bind loop as discussed in <xref target="uri.mappings.created.by.a.new.binding"/>.
</t>
<t>
  A client can request the DAV:resource-id property in a PROPFIND request to
  guarantee that they can accurately reconstruct the binding structure of a
  collection with multiple bindings to a single resource.
</t>
<t>
  For backward compatibility with clients not aware of the 208 status code appearing
  in multistatus response bodies, it SHOULD NOT be used unless the client
  has signaled support for this specification using the "DAV" request
  header (see <xref target="dav.request.header"/>).  Instead, a 508 status should be returned 
  when a binding loop is discovered.
  This allows the server to return the 508 as the top-level return status, 
  if it discovers it before it started the response, or in the middle of a 
  multistatus, if it discovers it in the middle of streaming out a 
  multistatus response. 
</t>

<section title="Example: PROPFIND by Bind-Aware Client">
<t>
  For example, consider a PROPFIND request on /Coll (bound to collection C),
  where the members of  /Coll are /Coll/Foo (bound to resource R) and /Coll/Bar
  (bound to collection C).
</t>
<figure><preamble>
&gt;&gt; Request:
</preamble>
<artwork type="message/http; msgtype=&#34;request&#34;" xml:space="preserve"><![CDATA[
PROPFIND /Coll/ HTTP/1.1
Host: www.example.com
Depth: infinity
DAV: bind
Content-Type: application/xml; charset="utf-8"
Content-Length: 152

<?xml version="1.0" encoding="utf-8" ?>
<D:propfind xmlns:D="DAV:">
  <D:prop>
   <D:displayname/>
   <D:resource-id/>
  </D:prop>
</D:propfind>
]]></artwork></figure> 
<figure><preamble>
&gt;&gt; Response:
</preamble>
<artwork type="message/http; msgtype=&#34;response&#34;" xml:space="preserve"><![CDATA[
HTTP/1.1 207 Multi-Status
Content-Type: application/xml; charset="utf-8"
Content-Length: 1241

<?xml version="1.0" encoding="utf-8" ?>
<D:multistatus xmlns:D="DAV:">
  <D:response>
    <D:href>http://www.example.com/Coll/</D:href>
    <D:propstat>
      <D:prop>
        <D:displayname>Loop Demo</D:displayname>
        <D:resource-id>
          <D:href
>urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf8</D:href>
        </D:resource-id>
      </D:prop>
      <D:status>HTTP/1.1 200 OK</D:status>
    </D:propstat>
  </D:response>
  <D:response>
    <D:href>http://www.example.com/Coll/Foo</D:href>
    <D:propstat>
      <D:prop>
        <D:displayname>Bird Inventory</D:displayname>
        <D:resource-id>
          <D:href
>urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf9</D:href>
        </D:resource-id>
      </D:prop>
      <D:status>HTTP/1.1 200 OK</D:status>
    </D:propstat>
  </D:response>
  <D:response>
    <D:href>http://www.example.com/Coll/Bar</D:href>
    <D:propstat>
      <D:prop>
        <D:displayname>Loop Demo</D:displayname>
        <D:resource-id>
          <D:href
>urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf8</D:href>
        </D:resource-id>
      </D:prop>
      <D:status>HTTP/1.1 208 Already Reported</D:status>
    </D:propstat>
  </D:response>
</D:multistatus>
]]></artwork></figure> 
</section>

<section title="Example: PROPFIND by Non-Bind-Aware Client">
<t>
  In this example, the client isn't aware of the 208 status code introduced
  by this specification.  As the "Depth: infinity" PROPFIND request would cause
  a loop condition, the whole request is rejected with a 508 status. 
</t>
<figure><preamble>
&gt;&gt; Request:
</preamble>
<artwork type="message/http; msgtype=&#34;request&#34;" xml:space="preserve"><![CDATA[
PROPFIND /Coll/ HTTP/1.1
Host: www.example.com
Depth: infinity
Content-Type: application/xml; charset="utf-8"
Content-Length: 125

<?xml version="1.0" encoding="utf-8" ?>
<D:propfind xmlns:D="DAV:">
   <D:prop> <D:displayname/> </D:prop>
</D:propfind>
]]></artwork></figure> 
<figure><preamble>
&gt;&gt; Response:
</preamble><artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 508 Loop Detected
]]></artwork></figure> 
</section>
</section>

<section title="508 Loop Detected" anchor="status.508.loop.detected">
<iref item="Status Codes" subitem="508 Loop Detected" primary="true"/>
<iref item="508 Loop Detected (status code)" primary="true"/>
<t>
  The 508 (Loop Detected) status code indicates that the server terminated an
  operation because it encountered an infinite loop while processing a request
  with "Depth: infinity".   This status indicates that the entire operation
  failed.  
</t>
</section>
</section>


<section title="Capability Discovery">
  
<section title="OPTIONS Method">
<t>
  <iref item="DAV header" subitem="compliance class 'bind'" primary="true"/>
  If the server supports bindings, it MUST return the compliance class name "bind"
  as a field in the "DAV" response header (see <xref target="RFC4918"/>, Section 10.1)
  from an OPTIONS request on any resource implemented by that
  server.  A value of "bind" in the "DAV" header MUST indicate that the server
  supports all MUST-level requirements and REQUIRED features specified in this
  document.
</t>  
</section>

<section title="'DAV' Request Header" anchor="dav.request.header">
<t>
  Clients SHOULD signal support for all MUST-level requirements and REQUIRED
  features by submitting a "DAV" request header containing the compliance class
  name "bind".  In particular, the client MUST understand the 208 status
  code defined in <xref target="status.208.already.reported"/>.
</t>
</section>

</section>

<section title="Relationship to Locking in WebDAV" anchor="locking">
<iref item="Locking"/>
<t>
  Locking is an optional feature of WebDAV (<xref target="RFC4918"/>). The
  base WebDAV specification and this protocol extension have been designed
  in parallel, making sure that all features of WebDAV can be 
  implemented on a server that implements this protocol as well.
</t>
<t>
  Unfortunately, WebDAV uses the term "lock-root" inconsistently. It is
  introduced in Section 6.1 of <xref target="RFC4918"/>, point 2, as:
</t>
<t><list>
  <t>
    2. A resource becomes directly locked when a LOCK request to a URL of
    that resource creates a new lock. The "lock-root" of the new lock is that
    URL. If at the time of the request, the URL is not mapped to a resource, a
    new empty resource is created and directly locked.
  </t>
</list></t>
<t>
  On the other hand, <xref target="RFC4918"/>, Section 9.10.1
  states:
</t>
<t><list>
  <t>
   A LOCK request to an existing resource will create a lock on the
   resource identified by the Request-URI, provided the resource is not
   already locked with a conflicting lock.  The resource identified in
   the Request-URI becomes the root of the lock.
  </t>
</list></t>
<t>
  Servers that implement both WebDAV locking and support for multiple bindings
  MUST use the first interpretation: the lock-root is the URI through which
  the lock was created, not a resource. This URI, and potential aliases of this
  URI (<xref target="RFC4918"/>, Section 5), are said to be "protected"
  by the lock.
</t>
<t>
  As defined in the introduction to Section 7 of <xref target="RFC4918"/>,
  write operations that modify the state of a locked resource require that the
  lock token is submitted with the request. Consistent with WebDAV, the state
  of the resource consists of the content ("any variant"), dead properties, 
  lockable live properties (item 1), plus, for a collection, all its bindings
  (item 2). Note that this, by definition, does not depend on the Request-URI
  to which the write operation is applied (the locked state is a property of
  the resource, not its URI).
</t>
<t>
  However, the lock-root is the URI through which the lock was requested. Thus,
  the protection defined in item 3 of the list does not apply to additional
  URIs that may be mapped to the same resource due to the existence of
  multiple bindings.
</t>

<section title="Example: Locking and Multiple Bindings">
<t>
  Consider a root collection "/", containing the two collections C1 and
  C2, named "/CollX" and "/CollY", and a child resource R, bound to C1 as
  "/CollX/test" and bound to C2 as "/CollY/test":
</t>
<figure><artwork align="center" type="drawing" xml:space="preserve"><![CDATA[
     +-------------------------+
     | Root Collection         |
     |  bindings:              |
     |  CollX          CollY   |
     +-------------------------+
         |                |          
         |                |
         |                |
+---------------+  +---------------+
| Collection C1 |  | Collection C2 |
| bindings:     |  | bindings:     |
|     test      |  |     test      |
+---------------+  +---------------+
         |               |
         |               |  
         |               |  
        +------------------+
        |    Resource R    |
        +------------------+
]]></artwork></figure>
<t>
  Given a host name of "www.example.com", applying a depth-zero write lock to
  "/CollX/test" will lock the resource R, and the lock-root of this lock will
  be "http://www.example.com/CollX/test".
</t>
<t>
  Thus, the following operations will require that the associated lock token is
  submitted with the "If" request header
  (<xref target="RFC4918"/>, Section 10.4):
  <list style="symbols">
    <t>a PUT or PROPPATCH request modifying the content or lockable properties of resource
    R (as R is locked) -- no matter which URI is used as request target, and</t>
    <t>a MOVE, REBIND, UNBIND, or DELETE request causing "/CollX/test" not to be mapped to resource R anymore (be it
    addressed to "/CollX" or "/CollX/test").</t>
  </list>
</t>
<t>
  The following operations will not require submission of the lock token:
  <list style="symbols">
    <t>a DELETE request addressed to "/CollY" or "/CollY/test", as it does not
    affect the resource R, nor the lock-root,</t>
    <t>for the same reason, an UNBIND request removing the binding "test" from collection C2, or the
    binding "CollY" from the root collection, and</t>
    <t>similarly, a MOVE or REBIND request causing "/CollY/test" not being mapped
    to resource R anymore.</t>
  </list>
</t>
<t>
  Note that despite the lock-root being "http://www.example.com/CollX/test", an UNLOCK request can
  be addressed through any URI mapped to resource R, as UNLOCK operates on the
  resource identified by the Request-URI, not that URI (see <xref target="RFC4918"/>, Section 9.11).
</t>
</section>
</section>

<section title="Relationship to WebDAV Access Control Protocol">
<t>
  Note that the WebDAV Access Control Protocol has been designed for
  compatibility with systems that allow multiple URIs to map to the same
  resource (see <xref target="RFC3744"/>, Section 5):  
</t>
<t><list>
  <t>
    Access control properties (especially DAV:acl and DAV:inherited-acl-set)
    are defined on the resource identified by the Request-URI of a PROPFIND
    request. A direct consequence is that if the resource is accessible via
    multiple URI, the value of access control properties is the same across
    these URI. 
  </t>
</list></t>
<t>
  Furthermore, note that BIND and REBIND behave the same as MOVE with respect
  to the DAV:acl property (see <xref target="RFC3744"/>, Section 7.3).
</t>

</section>

<section title="Relationship to Versioning Extensions to WebDAV">
<t>
  Servers that implement Workspaces (<xref target="RFC3253"/>, Section 6)
  and Version-Controlled Collections (<xref target="RFC3253"/>, Section 14)
  already need to implement BIND-like behavior in order to handle UPDATE and
  UNCHECKOUT semantics.
</t>
<t>
  Consider a workspace "/ws1/", containing the version-controlled, checked-out
  collections C1 and C2, named "/ws1/CollX" and "/ws1/CollY",
  and a version-controlled resource R, bound to C1 as "/ws1/CollX/test":
</t>
<figure><artwork align="center" type="drawing" xml:space="preserve"><![CDATA[
     +-------------------------+
     | Workspace               |
     |  bindings:              |
     |  CollX          CollY   |
     +-------------------------+
         |                |          
         |                |
         |                |
+---------------+  +---------------+
| Collection C1 |  | Collection C2 |
| bindings:     |  |               |
|     test      |  |               |
+---------------+  +---------------+
         |                       
         |                         
         |                         
        +------------------+
        |    Resource R    |
        +------------------+
]]></artwork></figure>
<t>
  Moving "/ws1/CollX/test" into "/ws1/CollY", checking in C2, but undoing the
  checkout on C1 will undo part of the MOVE request, thus restoring the binding
  from C1 to R, but keeping the new binding from C2 to R:
</t>
<figure><preamble>
&gt;&gt; Request:
</preamble>
<artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
MOVE /ws1/CollX/test HTTP/1.1
Host: www.example.com
Destination: /ws1/CollY/test
]]></artwork>
</figure> 
<figure><preamble>
&gt;&gt; Response:
</preamble><artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 204 No Content
]]></artwork></figure> 
<figure><preamble>
&gt;&gt; Request:
</preamble><artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
CHECKIN /ws1/CollY/ HTTP/1.1
Host: www.example.com
]]></artwork></figure> 
<figure><preamble>
&gt;&gt; Response:
</preamble><artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 201 Created
Cache-Control: no-cache
Location: http://repo.example.com/his/17/ver/42
]]></artwork></figure> 
<figure><preamble>
&gt;&gt; Request:
</preamble><artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
UNCHECKOUT /ws1/CollX/ HTTP/1.1
Host: www.example.com
]]></artwork>
</figure> 
<figure><preamble>
&gt;&gt; Response:
</preamble><artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 200 OK
Cache-Control: no-cache
]]></artwork></figure> 
<t>
  As a result, both C1 and C2 would have a binding to R:
</t>
<figure><artwork align="center" type="drawing" xml:space="preserve"><![CDATA[
     +-------------------------+
     | Workspace               |
     |  bindings:              |
     |  CollX          CollY   |
     +-------------------------+
         |                |          
         |                |
         |                |
+---------------+  +---------------+
| Collection C1 |  | Collection C2 |
| bindings:     |  | bindings:     |
|     test      |  |     test      |
+---------------+  +---------------+
         |                |
         |                |  
         |                |
        +------------------+
        |    Resource R    |
        +------------------+
]]></artwork></figure>
<t>
  The MOVE semantics defined in Section 3.15 of <xref target="RFC3253"/>
  already require that "/ws1/CollX/test" and "/ws1/CollY/test" will have the same 
  version history (as exposed in the DAV:version-history property). Furthermore,
  the UNCHECKOUT semantics (which in this case is similar to UPDATE, see
  Section 14.11 of <xref target="RFC3253"/>) require:
</t>
<t><list>
  <t>
    If a new version-controlled member is in a workspace that already has
    a version-controlled resource for that version history, then the new
    version-controlled member MUST be just a binding (i.e., another name for)
    that existing version-controlled resource.
  </t>
</list></t>
<t>
  Thus, "/ws1/CollX/test" and "/ws1/CollY/test" will be bindings to the same
  resource R, and have identical DAV:resource-id properties.
</t>
</section>

<section title="Security Considerations" anchor="security.considerations">
<t>
  This section is provided to make WebDAV implementers aware of the security
  implications of this protocol.
</t>
<t>
  All of the security considerations of HTTP/1.1 (<xref target="RFC2616"/>, Section 15) and the WebDAV Distributed
  Authoring Protocol specification (<xref target="RFC4918"/>, Section 20) also apply to this protocol specification.
  In addition, bindings introduce several new security concerns and increase
  the risk of some existing threats.  These issues are detailed below.
</t>

<section title="Privacy Concerns" anchor="privacy.concerns">
<t>
  In a context where cross-server bindings are supported, creating bindings on
  a trusted server may make it possible for a hostile agent to induce users to
  send private information to a target on a different server.
</t>
</section>

<section title="Bind Loops" anchor="bind.loops.privacy.concerns">
<t>
  Although bind loops were already possible in HTTP 1.1, the introduction
  of the BIND method creates a new avenue for clients to create loops
  accidentally or maliciously.  If the binding and its target are on the same
  server, the server may be able to detect BIND requests that would create
  loops.  Servers are required to detect loops that are caused by bindings to
  collections during the processing of any requests with "Depth: infinity".
</t>
</section>

<section title="Bindings and Denial of Service" anchor="bindings.and.denial.of.service">
<t>
  Denial-of-service attacks were already possible by posting URIs that were
  intended for limited use at heavily used Web sites.  The introduction of
  BIND creates a new avenue for similar denial-of-service attacks.  If
  cross-server bindings are supported, clients can now create bindings at 
  heavily used sites to target locations that were not designed for heavy usage.
</t>
</section>

<section title="Private Locations May Be Revealed" anchor="private.locations.may.be.revealed">
<t>
  If the DAV:parent-set property is maintained on a resource, the owners of
  the bindings risk revealing private locations.  The directory structures
  where bindings are located are available to anyone who has access to the
  DAV:parent-set property on the resource.  Moving a binding may reveal its
  new location to anyone with access to DAV:parent-set on its resource.
</t>
</section>

<section title="DAV:parent-set and Denial of Service" anchor="parent-set.and.denial.of.service">
<t>
  If the server maintains the DAV:parent-set property in response to bindings
  created in other administrative domains, it is exposed to hostile attempts to
  make it devote resources to adding bindings to the list.
</t>
</section>
</section>

<section title="Internationalization Considerations" anchor="internationalization.considerations">
<t>
  All internationalization considerations mentioned in Section 19 of <xref target="RFC4918"/> also apply to
  this document.
</t>
</section>

<section title="IANA Considerations" anchor="iana.considerations">

<t>
  <xref target="additional.status.codes"/> defines the HTTP status codes
  <iref item="Status Codes" subitem="208 Already Reported"/>
  <iref item="208 Already Reported (status code)"/>
  208 (Already Reported) and
  <iref item="Status Codes" subitem="508 Loop Detected"/>
  <iref item="508 Loop Detected (status code)"/>
  508 (Loop Detected), which have been added to the HTTP Status Code Registry.
  
</t>
</section>

<section title="Acknowledgements" anchor="acknowledgments">

<t>
  This document is the collaborative product of the authors and Tyson Chihaya,
  Jim Davis, Chuck Fay and Judith Slein.  It has benefited from thoughtful
  discussion by Jim Amsden, Peter Carlson, Steve Carter, Ken Coar, Ellis Cohen,
  Dan Connolly, Bruce Cragun, Cyrus Daboo, Spencer Dawkins, Mark Day, Werner Donne, Rajiv Dulepet, David
  Durand, Lisa Dusseault, Stefan Eissing, Roy Fielding, Yaron Goland, Joe Hildebrand, Fred Hitt, Alex Hopmann, James Hunt,
  Marcus Jager, Chris Kaler, Manoj Kasichainula, Rohit Khare, Brian Korver, Daniel LaLiberte, 
  Steve Martin, Larry Masinter, Jeff McAffer, Alexey Melnikov, Surendra Koduru Reddy, Max Rible,
  Sam Ruby, Bradley Sergeant, Nick Shelness, John Stracke, John Tigue, John
  Turner, Kevin Wiggen, and other members of the concluded WebDAV working group.
</t>
</section>

  </middle>

  <back>
  
  
<references title="Normative References">


<reference anchor="RFC2119">

<front>
<title abbrev="RFC Key Words">Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials="S." surname="Bradner" fullname="Scott Bradner">
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>

<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year="1997" month="March"/>
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.

</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name="BCP" value="14"/>
<seriesInfo name="RFC" value="2119"/>
<format type="TXT" octets="4723" target="ftp://ftp.isi.edu/in-notes/rfc2119.txt"/>
<format type="HTML" octets="17491" target="http://xml.resource.org/public/rfc/html/rfc2119.html"/>
<format type="XML" octets="5777" target="http://xml.resource.org/public/rfc/xml/rfc2119.xml"/>
</reference>

<reference anchor="RFC2616">

<front>
<title abbrev="HTTP/1.1">Hypertext Transfer Protocol -- HTTP/1.1</title>
<author initials="R." surname="Fielding" fullname="Roy T. Fielding">
<organization abbrev="UC Irvine">Department of Information and Computer Science</organization>
<address>
<postal>
<street>University of California, Irvine</street>
<city>Irvine</city>
<region>CA</region>

<code>92697-3425</code></postal>
<facsimile>+1(949)824-1715</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials="J." surname="Gettys" fullname="James Gettys">
<organization abbrev="Compaq/W3C">World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>

<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>jg@w3.org</email></address></author>
<author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
<organization abbrev="Compaq">Compaq Computer Corporation</organization>
<address>
<postal>
<street>Western Research Laboratory</street>
<street>250 University Avenue</street>

<city>Palo Alto</city>
<region>CA</region>
<code>94305</code></postal>
<email>mogul@wrl.dec.com</email></address></author>
<author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
<organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>

<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>frystyk@w3.org</email></address></author>
<author initials="L." surname="Masinter" fullname="Larry Masinter">
<organization abbrev="Xerox">Xerox Corporation</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>

<street>3333 Coyote Hill Road</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94034</code></postal>
<email>masinter@parc.xerox.com</email></address></author>
<author initials="P." surname="Leach" fullname="Paul J. Leach">
<organization abbrev="Microsoft">Microsoft Corporation</organization>
<address>
<postal>
<street>1 Microsoft Way</street>

<city>Redmond</city>
<region>WA</region>
<code>98052</code></postal>
<email>paulle@microsoft.com</email></address></author>
<author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
<organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>

<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>timbl@w3.org</email></address></author>
<date year="1999" month="June"/>
<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers . A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.
</t>
<t>

   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specification defines the protocol
   referred to as "HTTP/1.1", and is an update to RFC 2068 .
</t></abstract></front>

<seriesInfo name="RFC" value="2616"/>
<format type="TXT" octets="422317" target="ftp://ftp.isi.edu/in-notes/rfc2616.txt"/>
<format type="PS" octets="5529857" target="ftp://ftp.isi.edu/in-notes/rfc2616.ps"/>
<format type="PDF" octets="550558" target="ftp://ftp.isi.edu/in-notes/rfc2616.pdf"/>
<format type="HTML" octets="636125" target="http://xml.resource.org/public/rfc/html/rfc2616.html"/>
<format type="XML" octets="493420" target="http://xml.resource.org/public/rfc/xml/rfc2616.xml"/>
</reference>

<reference anchor="RFC3986">

<front>
<title abbrev="URI Generic Syntax">Uniform Resource Identifier (URI): Generic Syntax</title>
<author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
<organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
<address>
<postal>
<street>Massachusetts Institute of Technology</street>
<street>77 Massachusetts Avenue</street>
<city>Cambridge</city>

<region>MA</region>
<code>02139</code>
<country>USA</country></postal>
<phone>+1-617-253-5702</phone>
<facsimile>+1-617-258-5999</facsimile>
<email>timbl@w3.org</email>
<uri>http://www.w3.org/People/Berners-Lee/</uri></address></author>
<author initials="R." surname="Fielding" fullname="Roy T. Fielding">
<organization abbrev="Day Software">Day Software</organization>

<address>
<postal>
<street>5251 California Ave., Suite 110</street>
<city>Irvine</city>
<region>CA</region>
<code>92617</code>
<country>USA</country></postal>
<phone>+1-949-679-2960</phone>
<facsimile>+1-949-679-2972</facsimile>
<email>fielding@gbiv.com</email>

<uri>http://roy.gbiv.com/</uri></address></author>
<author initials="L." surname="Masinter" fullname="Larry Masinter">
<organization abbrev="Adobe Systems">Adobe Systems Incorporated</organization>
<address>
<postal>
<street>345 Park Ave</street>
<city>San Jose</city>
<region>CA</region>
<code>95110</code>
<country>USA</country></postal>

<phone>+1-408-536-3024</phone>
<email>LMM@acm.org</email>
<uri>http://larry.masinter.net/</uri></address></author>
<date year="2005" month="January"/>
<area>Applications</area>
<keyword>uniform resource identifier</keyword>
<keyword>URI</keyword>
<keyword>URL</keyword>
<keyword>URN</keyword>

<keyword>WWW</keyword>
<keyword>resource</keyword>
<abstract>
<t>
A Uniform Resource Identifier (URI) is a compact sequence of characters
that identifies an abstract or physical resource.  This specification
defines the generic URI syntax and a process for resolving URI references
that might be in relative form, along with guidelines and security
considerations for the use of URIs on the Internet.
The URI syntax defines a grammar that is a superset of all valid URIs,
allowing an implementation to parse the common components of a URI
reference without knowing the scheme-specific requirements of every
possible identifier.  This specification does not define a generative
grammar for URIs; that task is performed by the individual
specifications of each URI scheme.
</t></abstract></front>

<seriesInfo name="STD" value="66"/>
<seriesInfo name="RFC" value="3986"/>
<format type="TXT" octets="141811" target="ftp://ftp.isi.edu/in-notes/rfc3986.txt"/>
<format type="HTML" octets="213584" target="http://xml.resource.org/public/rfc/html/rfc3986.html"/>
<format type="XML" octets="163534" target="http://xml.resource.org/public/rfc/xml/rfc3986.xml"/>
</reference>

<reference anchor="RFC4918">

<front>
<title>HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)</title>
<author initials="L." surname="Dusseault" fullname="L. Dusseault" role="editor">
<organization/></author>
<date year="2007" month="June"/>
<abstract>
<t>Web Distributed Authoring and Versioning (WebDAV) consists of a set of methods, headers, and content-types ancillary to HTTP/1.1 for the management of resource properties, creation and management of resource collections, URL namespace manipulation, and resource locking (collision avoidance).&lt;/t&gt;&lt;t&gt; RFC 2518 was published in February 1999, and this specification obsoletes RFC 2518 with minor revisions mostly due to interoperability experience. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name="RFC" value="4918"/>

<format type="TXT" octets="276352" target="ftp://ftp.rfc-editor.org/in-notes/rfc4918.txt"/>
</reference>




<reference anchor="XML" target="http://www.w3.org/TR/2008/REC-xml-20081126/">
  <front>
    <title>Extensible Markup Language (XML) 1.0 (Fifth Edition)</title>
    <author initials="T." surname="Bray" fullname="Tim Bray">
      <organization>Textuality and Netscape</organization>
      <address>
        <email>tbray@textuality.com</email>
      </address>
    </author>
    <author initials="J." surname="Paoli" fullname="Jean Paoli">
      <organization>Microsoft</organization>
      <address>
        <email>jeanpa@microsoft.com</email>
      </address>
    </author>
    <author initials="C.M." surname="Sperberg-McQueen" fullname="C. M. Sperberg-McQueen">
      <organization>W3C</organization>
      <address>
        <email>cmsmcq@w3.org</email>
      </address>
    </author>
    <author initials="E." surname="Maler" fullname="Eve Maler">
      <organization>Sun Microsystems</organization>
      <address>
        <email>eve.maler@east.sun.com</email>
      </address>
    </author>
    <author initials="F." surname="Yergeau" fullname="Francois Yergeau">
      <organization/>
    </author>
    <date day="26" month="November" year="2008"/>
  </front>
  <seriesInfo name="W3C" value="REC-xml-20081126"/>
</reference>

</references>

<references title="Informative References">

<reference anchor="RFC3253">

<front>
<title abbrev="Versioning Extensions to WebDAV">Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)</title>
<author initials="G." surname="Clemm" fullname="Geoffrey Clemm">
<organization>Rational Software</organization>
<address>
<postal>
<street>20 Maguire Road</street>
<city>Lexington</city>
<region>MA</region>

<code>02421</code>
<country>US</country></postal>
<email>geoffrey.clemm@rational.com</email></address></author>
<author initials="J." surname="Amsden" fullname="Jim Amsden">
<organization>IBM</organization>
<address>
<postal>
<street>3039 Cornwallis</street>
<street>Research Triangle Park</street>
<region>NC</region>

<code>27709</code>
<country>US</country></postal>
<email>jamsden@us.ibm.com</email></address></author>
<author initials="T." surname="Ellison" fullname="Tim Ellison">
<organization>IBM</organization>
<address>
<postal>
<street>Hursley Park</street>
<city>Winchester</city>
<code>S021 2JN</code>

<country>UK</country></postal>
<email>tim_ellison@uk.ibm.com</email></address></author>
<author initials="C." surname="Kaler" fullname="Christopher Kaler">
<organization>Microsoft</organization>
<address>
<postal>
<street>One Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>90852</code>

<country>US</country></postal>
<email>ckaler@microsoft.com</email></address></author>
<author initials="J." surname="Whitehead" fullname="Jim Whitehead">
<organization abbrev="U.C. Santa Cruz">UC Santa Cruz, Dept. of Computer Science</organization>
<address>
<postal>
<street>1156 High Street</street>
<city>Santa Cruz</city>
<region>CA</region>
<code>95064</code>

<country>US</country></postal>
<email>ejw@cse.ucsc.edu</email></address></author>
<date year="2002" month="March"/>
<abstract>
<t>
   This document specifies a set of methods, headers, and resource types
   that define the WebDAV (Web Distributed Authoring and Versioning)
   versioning extensions to the HTTP/1.1 protocol.  WebDAV versioning
   will minimize the complexity of clients that are capable of
   interoperating with a variety of versioning repository managers, to
   facilitate widespread deployment of applications capable of utilizing
   the WebDAV Versioning services.  WebDAV versioning includes automatic
   versioning for versioning-unaware clients, version history
   management, workspace management, baseline management, activity
   management, and URL namespace versioning.
</t></abstract></front>

<seriesInfo name="RFC" value="3253"/>
<format type="TXT" octets="245514" target="ftp://ftp.isi.edu/in-notes/rfc3253.txt"/>
<format type="HTML" octets="429660" target="http://xml.resource.org/public/rfc/html/rfc3253.html"/>
<format type="XML" octets="305030" target="http://xml.resource.org/public/rfc/xml/rfc3253.xml"/>
</reference>

<reference anchor="RFC3744">

<front>
<title abbrev="WebDAV Access Control Protocol">Web Distributed Authoring and Versioning (WebDAV) Access Control Protocol</title>
<author initials="G." surname="Clemm" fullname="Geoffrey Clemm">
<organization>IBM</organization>
<address>
<postal>
<street>20 Maguire Road</street>
<city>Lexington</city>
<region>MA</region>

<code>02421</code></postal>
<email>geoffrey.clemm@us.ibm.com</email></address></author>
<author initials="J. F." surname="Reschke" fullname="Julian F. Reschke">
<organization abbrev="greenbytes">greenbytes GmbH</organization>
<address>
<postal>
<street>Salzmannstrasse 152</street>
<city>Muenster</city>
<region>NW</region>
<code>48159</code>

<country>Germany</country></postal>
<email>julian.reschke@greenbytes.de</email></address></author>
<author initials="E." surname="Sedlar" fullname="Eric Sedlar">
<organization>Oracle Corporation</organization>
<address>
<postal>
<street>500 Oracle Parkway</street>
<city>Redwood Shores</city>
<region>CA</region>
<code>94065</code></postal>

<email>eric.sedlar@oracle.com</email></address></author>
<author initials="J." surname="Whitehead" fullname="Jim Whitehead">
<organization abbrev="U.C. Santa Cruz">U.C. Santa Cruz, Dept. of Computer Science</organization>
<address>
<postal>
<street>1156 High Street</street>
<city>Santa Cruz</city>
<region>CA</region>
<code>95064</code></postal>
<email>ejw@cse.ucsc.edu</email></address></author>

<date year="2004" month="May"/>
<abstract>
<t>
        This document specifies a set of methods, headers, message bodies,
        properties, and reports that define Access Control extensions to the
        WebDAV Distributed Authoring Protocol.  This protocol permits a client to
        read and modify access control lists that instruct a server whether to
        allow or deny operations upon a resource (such as HyperText Transfer
        Protocol (HTTP) method invocations) by a given principal.  A lightweight
        representation of principals as Web resources supports integration of a
        wide range of user management repositories.  Search operations allow
        discovery and manipulation of principals using human names.
      </t></abstract></front>

<seriesInfo name="RFC" value="3744"/>
<format type="TXT" octets="146623" target="ftp://ftp.isi.edu/in-notes/rfc3744.txt"/>
<format type="HTML" octets="228863" target="http://xml.resource.org/public/rfc/html/rfc3744.html"/>
<format type="XML" octets="171435" target="http://xml.resource.org/public/rfc/xml/rfc3744.xml"/>
</reference>

<reference anchor="RFC4122">

<front>
<title abbrev="UUID URN">A Universally Unique IDentifier (UUID) URN Namespace</title>
<author initials="P." surname="Leach" fullname="Paul J. Leach">
<organization>Microsoft</organization>
<address>
<postal>
<street>1 Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>

<code>98052</code>
<country>US</country></postal>
<phone>+1 425-882-8080</phone>
<email>paulle@microsoft.com</email></address></author>
<author initials="M." surname="Mealling" fullname="Michael Mealling">
<organization>Refactored Networks, LLC</organization>
<address>
<postal>
<street>1635 Old Hwy 41</street>
<street>Suite 112, Box 138</street>

<city>Kennesaw</city>
<region>GA</region>
<code>30152</code>
<country>US</country></postal>
<phone>+1-678-581-9656</phone>
<email>michael@refactored-networks.com</email>
<uri>http://www.refactored-networks.com</uri></address></author>
<author initials="R." surname="Salz" fullname="Rich Salz">
<organization>DataPower Technology, Inc.</organization>

<address>
<postal>
<street>1 Alewife Center</street>
<city>Cambridge</city>
<region>MA</region>
<code>02142</code>
<country>US</country></postal>
<phone>+1 617-864-0455</phone>
<email>rsalz@datapower.com</email>
<uri>http://www.datapower.com</uri></address></author>

<date year="2005" month="July"/>
<keyword>URN, UUID</keyword>
<abstract>
<t>This specification defines a Uniform Resource Name namespace for
      UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally
      Unique IDentifier). A UUID is 128 bits long, and can
      guarantee uniqueness across space and time. UUIDs were originally
      used in the Apollo Network Computing System and later in the Open
      Software Foundation's (OSF) Distributed Computing Environment (DCE),
      and then in Microsoft Windows platforms.</t>
<t>This specification is derived from the DCE specification with the
      kind permission of the OSF (now known as The Open Group).  Information from earlier versions of the DCE specification have been	
      incorporated into this document.</t></abstract></front>

<seriesInfo name="RFC" value="4122"/>
<format type="TXT" octets="59319" target="ftp://ftp.isi.edu/in-notes/rfc4122.txt"/>
<format type="HTML" octets="82717" target="http://xml.resource.org/public/rfc/html/rfc4122.html"/>
<format type="XML" octets="62931" target="http://xml.resource.org/public/rfc/xml/rfc4122.xml"/>
</reference>
 

</references>
  </back>
</rfc>
