<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>  
<?rfc subcompact="no"?>
<?rfc sortrefs="yes"?>

<!-- used v2 -->

<rfc number="7181" ipr="pre5378Trust200902" category="std" submissionType="IETF" consensus="yes">

  <front>

    <title abbrev="OLSRv2">The Optimized Link State Routing Protocol Version 2</title>
    <author initials="T.H." surname="Clausen" fullname="Thomas Heide Clausen">
      <organization>LIX, Ecole Polytechnique</organization>
      <address>
        <phone>+33 6 6058 9349</phone>
        <email>T.Clausen@computer.org</email>
        <uri>http://www.ThomasClausen.org/</uri>
      </address>
    </author>
   
    <author initials="C.M." surname="Dearlove" fullname="Christopher Dearlove">
      <organization abbrev="BAE Systems ATC">BAE Systems Advanced Technology Centre</organization>
      <address>
         <postal>
          <street>West Hanningfield Road</street>
          <city>Great Baddow, Chelmsford</city>
          <country>United Kingdom</country>
        </postal>
        <phone>+44 1245 242194</phone>
        <email>chris.dearlove@baesystems.com</email>
        <uri>http://www.baesystems.com/</uri>
      </address>
    </author>
   
    <author initials="P." surname="Jacquet" fullname="Philippe Jacquet">
      <organization>Alcatel-Lucent Bell Labs</organization>
      <address>
        <phone>+33 6 7337 1880</phone>
        <email>philippe.jacquet@alcatel-lucent.com</email>
      </address>
    </author>

    <author fullname="Ulrich Herberg" initials="U." surname="Herberg">
      <organization>Fujitsu Laboratories of America</organization>
      <address>
        <postal>
          <street>1240 E. Arques Ave.</street>
          <city>Sunnyvale</city>
          <region>CA</region>
          <code>94085</code>
          <country>USA</country>
        </postal>
        <email>ulrich@herberg.name</email>
        <uri>http://www.herberg.name/</uri>
      </address>
    </author>

    <date month="April" year="2014"/>
    <area>Routing</area>
    <workgroup>Mobile Ad hoc Networking (MANET)</workgroup>


<abstract>

  <t>
This specification describes version 2 of the Optimized Link State
   Routing Protocol (OLSRv2) for Mobile Ad Hoc Networks (MANETs).
  </t>

</abstract>

  </front>

  <middle>
<section anchor='introduction' title='Introduction'>

  <t>
The Optimized Link State Routing Protocol version 2 (OLSRv2) is the
successor to OLSR (version 1) as published in <xref
target="RFC3626"/>. Compared to <xref target="RFC3626"/>, OLSRv2 retains the
same basic mechanisms and algorithms, enhanced by the ability to use a link
metric other than hop count in the selection of shortest routes. OLSRv2 also
uses a more flexible and efficient signaling framework and includes some
simplification of the messages being exchanged.
  </t>
   
  <t>
    OLSRv2 is developed for Mobile Ad Hoc Networks (MANETs). It operates as a
table-driven, proactive protocol, i.e., it exchanges topology information with
    other routers in the network regularly. OLSRv2 is an optimization of the
    classic link state routing protocol. Its key concept is that of multipoint
    relays (MPRs). Each router selects two sets of MPRs, each being a set of its
    neighbor routers that "cover" all of its symmetrically connected 2-hop neighbor
    routers. These two sets are "flooding MPRs" and "routing MPRs", which are used to
    achieve flooding reduction and topology reduction, respectively.
  </t>

  <t>
    Flooding reduction is achieved by control traffic being flooded through the
    network using hop-by-hop forwarding, but with a router only needing to forward
    control traffic that is first received directly from one of the routers that
    have selected it as a flooding MPR (its "flooding MPR selectors"). This
    mechanism, denoted "MPR flooding", provides an efficient mechanism for
    information distribution within the MANET by reducing the number of
    transmissions required <xref target="MPR"/>.
  </t>

  <t>
    Topology reduction is achieved by assigning a special responsibility to routers
    selected as routing MPRs when declaring link state information. A sufficient
    requirement for OLSRv2 to provide shortest routes to all destinations is that
    routers declare link state information for their routing MPR selectors, if any.
    Routers that are not selected as routing MPRs need not send any link state
    information. Based on this reduced link state information, routing MPRs are
    used as intermediate routers in multi-hop routes.
  </t>

  <t>
    Thus, the use of MPRs allows reduction of the number and the size of link state
    messages and reduction in the amount of link state information maintained in each router.
    When possible (in particular if using a hop count metric), the same routers may
    be picked as both flooding MPRs and routing MPRs.
  </t>

  <t>
    A router selects both routing and flooding MPRs from among its one-hop neighbors
    connected by "symmetric", i.e., bidirectional, links. Therefore, selecting routes
    through routing MPRs avoids the problems associated with data packet transfer over
    unidirectional links (e.g., the problem of not getting link-layer acknowledgments
    at each hop, for link layers employing this technique).
  </t>

  <t>
    OLSRv2 uses and extends the MANET Neighborhood Discovery Protocol (NHDP)
    defined in <xref target="RFC6130"/> and also uses the Generalized MANET Packet/Message Format <xref target="RFC5444"/>, the TLVs specified in
    <xref target="RFC5497"/> and, optionally, message jitter as specified in
    <xref target="RFC5148"/>. These four other protocols and specifications
    were all originally created as part of OLSRv2 but have been specified
    separately for wider use.
  </t>

  <t>
    OLSRv2 makes no assumptions about the underlying link layer. OLSRv2, through
    its use of <xref target="RFC6130"/>, may use link-layer information and
    notifications when available and applicable. In addition, OLSRv2 uses link metrics
    that may be derived from link layer or any other information. OLSRv2 does not
    specify the physical meaning of link metrics but specifies a means by which new
    types of link metrics may be specified in the future but used by OLSRv2 without
    modification.
  </t>

  <t>
    OLSRv2, like OLSR <xref target="RFC3626"/>, inherits its concept of forwarding
    and relaying from the High Performance Radio Local Area Network (HIPERLAN) (a MAC-layer protocol), which is standardized by ETSI
    <xref target="HIPERLAN"/> <xref target="HIPERLAN2"/>. This document does
not obsolete <xref target="RFC3626"/>, which is left in place for further
experimentation.
  </t>

</section>
<section anchor="terminology" title="Terminology">
 
  <t>
    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
    "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
    "OPTIONAL" in this document are to be interpreted as described in
    <xref target="RFC2119"/>.
  </t>
	
  <t>
    All terms introduced in <xref target="RFC5444"/>, including "packet",
    "Packet Header", "message", "Message Header", "Message Body", "Message Type",
    "message sequence number", "hop limit", "hop count", "Address Block",
    "TLV Block", "TLV", "Message TLV", "Address Block TLV", "type" (of TLV),
    "type extension" (of TLV), "value" (of TLV), "address", "address prefix",
    and "address object" are to be interpreted as described there.
  </t>

  <t>
    All terms introduced in <xref target="RFC6130"/>, including "interface",
    "MANET interface", "network address", "link", "symmetric link",
    "symmetric 1-hop neighbor", "symmetric 2-hop neighbor", "symmetric 1-hop neighborhood"
    "constant", "interface parameter", "router parameter", "Information Base",
    and "HELLO message" are to be interpreted as described there.
  </t>

  <t>
    Additionally, this specification uses the following terminology:
  </t>

  <t>

    <list style="hanging">
	
      <t hangText="Router:"> <vspace blankLines="0"/>
        A MANET router that implements this protocol.
      </t>

      <t hangText="OLSRv2 interface:"> <vspace blankLines="0"/>
        A MANET interface running this protocol. A router running this protocol MUST
        have at least one OLSRv2 interface.
      </t>

      <t hangText="Routable address:"> <vspace blankLines="0"/>
        A network address that may be used as the destination of a data packet.
        A router that implements this protocol will need to distinguish a routable
        address from a non-routable address by direct inspection of the network
        address, based on global-scope address allocations by IANA and/or
        administrative configuration (consistently across the MANET).
        Broadcast and multicast addresses, and addresses that are limited
        in scope to less than the entire MANET, MUST NOT be considered as routable
        addresses. Anycast addresses may be considered as routable addresses.
      </t>

      <t hangText="Originator address:"> <vspace blankLines="0"/>
        An address that is unique (within the MANET) to a router. A router
        MUST select an originator address; it MAY choose one of its
        interface addresses as its originator address; and it MAY select either
        a routable or non-routable address. A broadcast, multicast, or anycast
        address MUST NOT be chosen as an originator address. If the router
        selects a routable address, then it MUST be one that the router will
        accept as destination. An originator address MUST NOT have a prefix
        length, except when included in an Address Block where it MAY be
        associated with a prefix of maximum prefix length (e.g., if the originator
        address is an IPv6 address, it MUST have either no prefix length or have a
        prefix length of 128).
      </t>

      <t hangText="Message originator address:"> <vspace blankLines="0"/>
        The originator address of the router that created a message, as deduced
        from that message by its recipient. For all messages used in this
        specification, including HELLO messages defined in <xref target="RFC6130"/>,
        the recipient MUST be able to deduce an originator address. The message
        originator address will usually be included in the message as its
        &lt;msg-orig-addr&gt; element as defined in <xref target="RFC5444"/>.
        However, an exceptional case, which does not add a &lt;msg-orig-addr&gt;
        element to a HELLO message, may be used by a router that only has a
        single address.
      </t>

	<t hangText="Willingness:"> <vspace blankLines="0"/>
        A numerical value between WILL_NEVER and WILL_ALWAYS (both inclusive)
        that represents the router's willingness to be selected as an MPR.
        A router has separate willingness values to be a flooding MPR and
        a routing MPR.
	</t>

      <t hangText ="Willing symmetric 1-hop neighbor:"> <vspace blankLines="0"/>
        A symmetric 1-hop neighbor that has willingness not equal to WILL_NEVER.
      </t>

      <t hangText="Multipoint relay (MPR):"> <vspace blankLines="0"/>
        A router, X, is an MPR for a router, Y, if router Y has indicated its
        selection of router X as an MPR in a recent HELLO message. Router X may
        be a flooding MPR for Y if it is indicated to participate in the
        flooding process of messages received from router Y, or it may be a
        routing MPR for Y if it is indicated to declare link state information
        for the link from X to Y.&nbsp; It may also be both at the same time.
      </t>

      <t hangText="MPR selector:"> <vspace blankLines="0"/>
        A router, Y, is a flooding/routing MPR selector of router X if router Y
        has selected router X as a flooding/routing MPR.
      </t>

      <t hangText="MPR flooding:"> <vspace blankLines="0"/>
        The optimized MANET-wide information distribution mechanism, employed
        by this protocol, in which a message is relayed by only a reduced subset
        of the routers in the network. MPR flooding is the mechanism by which
        flooding reduction is achieved.
      </t>

	<t hangText="EXPIRED:"> <vspace blankLines="0"/>
	  Indicates that a timer is set to a value clearly preceding the current
        time (e.g., current time - 1).
      </t>
    </list>

  </t>

  <t>
    This specification employs the same notational conventions as 
    <xref target="RFC5444"/> and <xref target="RFC6130"/>. 
  </t>

</section>
<section anchor="applicability" title="Applicability Statement">
    
  <t> 
    This document specifies OLSRv2, a proactive routing protocol
    intended for use in Mobile Ad Hoc Networks (MANETs) <xref target="RFC2501"/>.
    The protocol's applicability is determined by its characteristics, which are
    that this protocol:

    <list style="symbols">

      <t>
        Is designed to work in networks with a dynamic topology and
        in which messages may be lost, such as due to collisions over
        wireless media.
      </t>

      <t>
        Supports routers that each have one or more participating
        OLSRv2 interfaces, which will consist of some or all of its MANET
        interfaces using <xref target="RFC6130"/>. The set of a router's
        OLSRv2 interfaces, and the sets of its other MANET and non-MANET
        interfaces, may change over time. Each interface may have one or
        more network addresses (which may have prefix lengths), and these
        may also be dynamically changing.
      </t>

      <t>
        Enables hop-by-hop routing, i.e., each router can use its local
        information provided by this protocol to route packets.
      </t>

      <t>
        Continuously maintains routes to all destinations in the network,
        i.e., routes are instantly available and data traffic is subject to
        no delays due to route discovery. Consequently, no data traffic
        buffering is required.
      </t>

      <t>
        Supports routers that have non-OLSRv2 interfaces that may be
        local to a router or that can serve as gateways towards other
        networks.
    	</t>

      <t>
        Enables the use of bidirectional additive link metrics to use
        shortest distance routes (i.e., routes with smallest total of
        link metrics). Incoming link metric values are to be determined
        by a process outside this specification.
      </t>

      <t>
        Is optimized for large and dense networks; the larger and more
        dense a network, the more optimization can be achieved by using
        MPRs, compared to the classic link state algorithm <xref target="MPR"/>.
      </t>

      <t>
        Uses <xref target="RFC5444"/> as described in its "Intended Usage"
        appendix and by <xref target="RFC5498"/>.
      </t>

      <t>
        Allows "external" and "internal" extensibility (adding new Message
        Types and adding information to existing messages) as enabled by
        <xref target="RFC5444"/>.
      </t>		

      <t>
        Is designed to work in a completely distributed manner and does
        not depend on any central entity.
      </t>

    </list>

  </t>

</section>
<section anchor="functioning" title="Protocol Overview and Functioning">

  <t>
    The objectives of this protocol are for each router to:
		
    <list style="symbols">

      <t>
        Identify all destinations in the network.
      </t>

      <t>
        Identify a sufficient subset of links in the network, in order that
        shortest routes can be calculated to all available destinations.
      </t>

      <t>
        Provide a Routing Set containing these shortest routes from this router
        to all destinations (routable addresses and local links).
      </t>

    </list>

  </t>

  <section title="Overview">

    <t>
      These objectives are achieved, for each router, by:
		
      <list style="symbols">

	  <t>
          Using NHDP <xref target="RFC6130"/> to identify symmetric 1-hop neighbors and
          symmetric 2-hop neighbors.
        </t>

        <t>
          Reporting its participation in OLSRv2, and its willingness to be a flooding
          MPR and to be a routing MPR, by extending the HELLO messages defined in
          <xref target="RFC6130"/> by the addition of an MPR_WILLING Message TLV. The
          router's "flooding willingness" indicates how willing it is to participate
          in MPR flooding. The router's "routing willingness" indicates how willing
          it is to be an intermediate router for routing. Note that a router is
          still able to be a routing source or destination, even if unwilling to
          perform either function.
        </t>

        <t>
          Extending the HELLO messages defined in <xref target="RFC6130"/> to allow
          the addition of directional link metrics to advertised links with other
          routers participating in OLSRv2 and to indicate which link metric type is
          being used by those routers. Both incoming and outgoing link metrics may be
          reported, the former determined by the advertising router.
        </t>

        <t>
          Selecting flooding MPRs and routing MPRs from among its willing
          symmetric 1-hop neighbors such that, for each set of MPRs, all symmetric
          2-hop neighbors are reachable either directly or via at least one selected
          MPR, using a path of appropriate minimum total metric for at least routing
          MPR selection. An analysis and examples of MPR selection algorithms are given
          in <xref target="MPR"/>; a suggested algorithm, appropriately adapted for
          each set of MPRs, is included in <xref target="mprcalc"/> of this
          specification. Note that it is not necessary for routers to use the 
          same algorithm in order to interoperate in the  same MANET, but each such
          algorithm must have the appropriate properties, described in
          <xref target="mpr-set-population"/>.
        </t>

        <t>
          Signaling its flooding MPR and routing MPR selections, by extending the
          HELLO messages defined in <xref target="RFC6130"/> to report this information
          by the addition of MPR Address Block TLV(s) associated with the appropriate
          network addresses.
        </t>

        <t>
          Extracting its flooding MPR selectors and routing MPR selectors from
          received HELLO messages, using the included MPR Address Block TLV(s).
        </t>

	  <t>
    	    Defining a TC (Topology Control) Message Type using the message format
          specified in <xref target="RFC5444"/>. TC messages are used
          to periodically signal links between routing MPR selectors and
          itself throughout the MANET. This signaling includes suitable
          directional neighbor metrics (the best link metric in that direction
          between those routers).
        </t>

        <t>
          Allowing its TC messages, as well as HELLO messages, to be included
          in packets specified in <xref target="RFC5444"/>, using the "manet"
          IP protocol or UDP port as specified in <xref target="RFC5498"/>.
        </t>

        <t>
          Diffusing TC messages by using a flooding reduction mechanism,
          denoted "MPR flooding"; only the flooding MPRs of a router will
          retransmit messages received from (i.e., originated or last relayed
          by) that router.
        </t>

      </list>

    </t>

    <t>
      Note that the indicated extensions to <xref target="RFC6130"/> are of
      forms permitted by that specification.
    </t>

    <t>
      This specification defines:
		
      <list style="symbols">

        <t>
          The requirement to use <xref target="RFC6130"/>, its parameters,
          constants, HELLO messages, and Information Bases, each as extended
          in this specification.
        </t>

        <t>
          Two new Information Bases: the Topology Information Base and the
          Received Message Information Base.
        </t>

        <t>
          TC messages, which are used for MANET wide signaling (using MPR
          flooding) of selected topology (link state) information.
        </t>

        <t>
          A requirement for each router to have an originator address to be
          included in, or deducible from, HELLO messages and TC messages.
        </t>

        <t>
          The specification of new Message TLVs and Address Block TLVs that
          are used in HELLO messages and TC messages, including for reporting
          neighbor status, MPR selection, external gateways, link metrics,
          willingness to be an MPR, and content sequence numbers. Note that the
          generation of (incoming) link metric values is to be undertaken by a
          process outside this specification; this specification concerns only
          the distribution and use of those metrics.
        </t>

        <t>
          The generation of TC messages from the appropriate information in the
          Information Bases.
        </t>

        <t>
          The updating of the Topology Information Base according to received
          TC messages.
        </t>

         <t>
          The MPR flooding mechanism, including the inclusion of message
          originator address and sequence number to manage duplicate messages,
          using information recorded in the Received Message Information Base.
        </t>

       <t>
          The response to other events, such as the expiration of information
          in the Information Bases.
        </t>

      </list>
		
    </t>
	
    <t>
      This protocol inherits the stability of a link state algorithm and has
      the advantage of having routes immediately available when needed, due to
      its proactive nature.
    </t>

    <t>
      This protocol only interacts with IP through routing table management
      and the use of the sending IP address for IP datagrams containing
      messages used by this specification.
    </t>

  </section>

  <section title="Routers and Interfaces">

    <t>
      In order for a router to participate in a MANET using this protocol,
      it must have at least one, and possibly more, OLSRv2 interfaces.
      Each OLSRv2 interface:

      <list style="symbols">

        <t>
          Is a MANET interface, as specified in <xref target="RFC6130"/>.
          In particular, it must be configured with one or more network addresses;
          these addresses must each be specific to this router and must include
          any address that will be used as the sending address of any IP packet
          sent on this OLSRv2 interface.
        </t>

        <t>
          Has a number of interface parameters, adding to those specified in
          <xref target="RFC6130"/>.
        </t>

        <t>
          Has an Interface Information Base, extending that specified in
          <xref target="RFC6130"/>.
        </t>

        <t>
          Generates and processes HELLO messages according to <xref target="RFC6130"/>,
          extended as specified in <xref target="HELLOmessages"/>.
        </t>
      </list>
    </t>

    <t>
      In addition to a set of OLSRv2 interfaces as described above, each router:

      <list style="symbols">

        <t>
          May have one or more non-OLSRv2 interfaces (which may include MANET 
          interfaces and/or non-MANET interfaces) and/or local attached networks
          for which this router can accept IP packets. All routable addresses for which
          the router is to accept IP packets must be used as an (OLSRv2 or non-OLSRv2)
          interface network address or as an address of a local attached network of
          the router.
        </t>

        <t>
          Has a number of router parameters, adding to those specified in
          <xref target="RFC6130"/>.
        </t>

        <t>
          Has a Local Information Base, extending that specified in
          <xref target="RFC6130"/>, including selection of an originator address
          and recording any locally attached networks.
        </t>

        <t>
          Has a Neighbor Information Base, extending that specified in
          <xref target="RFC6130"/> to record MPR selection and advertisement
          information.
        </t>

        <t>
          Has a Topology Information Base, recording information received in
          TC messages.
        </t>

        <t>
          Has a Received Message Information Base, recording information
          about received messages to ensure that each TC message is only
          processed once, and forwarded at most once on each OLSRv2 interface,
          by a router.
        </t>
        
        <t>
          Generates, receives, and processes TC messages.
        </t>
        
      </list>
    </t>

  </section>

  <section title="Information Base Overview">

    <t>
      Each router maintains the Information Bases described in the following
      sections. These are used for describing the protocol in this
      specification. An implementation of this protocol may maintain this
      information in the indicated form or in any other organization that
      offers access to this information. In particular, note that it is not
      necessary to remove Tuples from Sets at the exact time indicated,
      only to behave as if the Tuples were removed at that time.
    </t>

    <section title="Local Information Base">

      <t>
        The Local Information Base is specified in <xref target="RFC6130"/>
        and contains a router's local configuration. It is extended in this
        specification to also record an originator address and to include
        a router's:
		
        <list style="symbols">
         <t>
           Originator Set, containing addresses that were recently used as
           this router's originator address, that is used, together with the
           router's current originator address, to enable a router to recognize
           and discard control traffic that was originated by the router itself.
         </t>
         <t>
           Local Attached Network Set, containing network addresses of networks
           to which this router can act as a gateway, that it advertises in its
           TC messages.
         </t>
       </list>

	</t>

    </section>

    <section title="Interface Information Base">

	<t>
        The Interface Information Base for each OLSRv2 interface is as
        specified in <xref target="RFC6130"/>, extended to also
        record, in each Link Set, link metric values (incoming and
        outgoing) and flooding MPR selector information.
      </t>

    </section>

    <section title="Neighbor Information Base">

      <t>
        The Neighbor Information Base is specified in <xref target="RFC6130"/>
        and is extended to also record, in the Neighbor Tuple for each
        neighbor:
        <list style="symbols">
          <t>
            Its originator address.
          </t>
          <t>
            Neighbor metric values, these being the minimum of the link
            metric values in the indicated direction for all symmetric 1-hop
            links with that neighbor.
          </t>
          <t>
            Its willingness to be a flooding MPR and to be a routing MPR.
          </t>
          <t>
            Whether it has been selected by this router as a flooding MPR
            or as a routing MPR and whether it is a routing MPR selector
            of this router. (Whether it is a flooding MPR selector of this
            neighbor is recorded in the Interface Information Base.)
          </t>
          <t>
            Whether it is to be advertised in TC messages sent by this router.
          </t>
        </list>
      </t>

    </section>

    <section title="Topology Information Base">

 	<t>
        The Topology Information Base in each router contains:

        <list style="symbols">

          <t>
            An Advertising Remote Router Set, recording each remote router from 
            which TC messages have been received. This is used in order to
            determine if a received TC message contains fresh or outdated
            information; a received TC message is ignored in the latter case.
          </t>

          <t>
            A Router Topology Set, recording links between routers in the MANET,
            as described by received TC messages.
          </t>

          <t>
            A Routable Address Topology Set, recording routable addresses in the
            MANET (available as IP packet destinations) and from which remote router
            these routable addresses can be directly reached (i.e., in a single
            IP hop from that remote router), as reported by received TC messages.
          </t>

          <t>
            An Attached Network Set, recording networks to which a remote router
            has advertised that it may act as a gateway. These networks may be
            reached in one or more IP hops from that remote router.
          </t>

          <t>
            A Routing Set, recording routes from this router to all available
            destinations. The IP routing table is to be updated using this Routing Set.
            (A router may choose to use any or all destination network addresses in the
            Routing Set to update the IP routing table. This selection is outside the
            scope of this specification.)
          </t>

        </list>

      </t>
      
      <t>
        The purpose of the Topology Information Base is to record information
        used, in addition to that in the Local Information Base, the
        Interface Information Bases, and the Neighbor Information Base, to
        construct the Routing Set (which is also included in the Topology
        Information Base).
      </t>

      <t>
        This specification describes the calculation of the Routing Set based on
        a Topology Graph constructed in two phases. First, a "backbone" graph
        representing the routers in the MANET, and the connectivity between them,
        is constructed from the Local Information Base, the Neighbor Information Base,
        and the Router Topology Set.&nbsp; Second, this graph is "decorated" with additional
        destination network addresses using the Local Information Base, the Routable
        Address Topology Set, and the Attached Network Set.
     </t>

     <t>
       The Topology Graph does not need to be recorded in the Topology Information Base;
       it can either be constructed as required when the Routing Set is to be changed
       or need not be explicitly constructed (as illustrated in <xref target="rs-algo"/>).
       An implementation may, however, construct and retain the Topology Graph if preferred.
      </t>

    </section>

    <section title="Received Message Information Base">

      <t>
        The Received Message Information Base in each router contains:

        <list style="symbols">
          <t>
            A Received Set for each OLSRv2 interface, describing TC messages
            received by this router on that OLSRv2 interface.
          </t>
          <t>
            A Processed Set, describing TC messages processed by this router.
          </t>
          <t>
            A Forwarded Set, describing TC messages forwarded by this router.
          </t>
        </list>

	</t>

	<t>
        The Received Message Information Base serves the MPR flooding mechanism
        by ensuring that received messages are forwarded at most once by a
router
        and also ensures that received messages are processed exactly once by a
        router. The Received Message Information Base may also record information
        about other Message Types that use the MPR flooding mechanism.
	</t>

    </section>

  </section>

  <section title="Signaling Overview">

    <t>
      This protocol generates and processes HELLO messages according to
      <xref target="RFC6130"/>. HELLO messages transmitted on OLSRv2 interfaces
      are extended according to <xref target="HELLOmessages"/>
      of this specification to include an originator address, link metrics, and
      MPR selection information.
    </t>

    <t>
      This specification defines a single Message Type, the TC message.
      TC messages are sent by their originating router proactively, at a
      regular interval, on all OLSRv2 interfaces. This interval may be fixed
      or dynamic, for example, it may be backed off due to congestion
      or network stability. TC messages may also be sent as a response to a
      change in the router itself, or its advertised symmetric 1-hop neighborhood,
      for example, on first being selected as a routing MPR.
    </t>

    <t>
      Because TC messages are sent periodically, this protocol is tolerant
      of unreliable transmissions of TC messages. Message losses may occur more
      frequently in wireless networks due to collisions or other transmission
      problems. This protocol may use "jitter", randomized adjustments to
      message transmission times, to reduce the incidence of collisions, as
      specified in <xref target="RFC5148"/>.
    </t>

    <t>
    	This protocol is tolerant of out-of-sequence delivery of TC messages
      due to in-transit message reordering. Each router maintains an
      Advertised Neighbor Sequence Number (ANSN) that is incremented when
      its recorded neighbor information that is to be included in its TC
      messages changes. This ANSN is included in the router's TC messages.
      The recipient of a TC message can use this included ANSN to identify
      which of the information it has received is most recent, even if
      messages have been reordered while in transit. Only the most recent
      information received is used; older information received later is
      discarded.
    </t>

    <t>
      TC messages may be "complete" or "incomplete". A complete TC message
      advertises all of the originating router's routing MPR selectors; it
      may also advertise other symmetric 1-hop neighbors. Complete TC messages
      are generated periodically (and also, optionally, in response to
      symmetric 1-hop neighborhood changes). Incomplete TC messages may be
      used to report additions to advertised information, without repeating
      unchanged information.
    </t>

    <t>
      TC messages, and HELLO messages as extended by this specification,
      define (by inclusion or by deduction when having a single address)
      an originator address for the router that created the message.
      A TC message reports both the originator addresses and routable addresses
      of its advertised neighbors, distinguishing the two using an Address
      Block TLV (an address may be both routable and an originator address).
      TC messages also report the originator's locally attached networks.
    </t>

    <t>
      TC messages are MPR flooded throughout the MANET. A router retransmits
      a TC message received on an OLSRv2 interface if and only if the message
      did not originate at this router and has not been previously forwarded
      by this router, this is the first time the message has been received on
      this OLSRv2 interface, and the message is received from (i.e., originated
      from or was last relayed by) one of this router's flooding MPR selectors.
    </t>

    <t>
      Some TC messages may be MPR flooded over only part of the network,
      e.g., allowing a router to ensure that nearer routers are kept more up
      to date than distant routers, such as is used in Fisheye State Routing
      <xref target="FSR"/> and Fuzzy Sighted Link State routing
      <xref target="FSLS"/>. This is enabled using <xref target="RFC5497"/>.
    </t>

    <t>
      TC messages include outgoing neighbor metrics that will be used in the
      selection of routes.
    </t>

  </section>  

  <section title="Link Metrics">

    <t>
      OLSRv1 <xref target="RFC3626"/> created minimum hop routes to destinations.
      However, in many, if not most, circumstances, better routes (in terms of
      quality of service for end users) can be created by use of link metrics.
    </t>

    <t>
	OLSRv2, as defined in this specification, supports metric-based routing,
      i.e., it allows links to each have a chosen metric. Link metrics as
      defined in OLSRv2 are additive, and the routes that are to be created
      are those with the minimum sum of the link metrics along that route.
    </t>

    <t>
      Link metrics are defined to be directional; the link metric from
      one router to another may be different from that on the reverse link.
      The link metric is assessed at the receiver, as on a (typically) wireless
      link, that is the better informed as to link information. Both incoming
      and outgoing link information is used by OLSRv2; the distinctions in this
      specification must be clearly followed.
    </t>

    <t>
      This specification also defines both incoming and outgoing neighbor metrics
      for each symmetric 1-hop neighbor, these being the minimum value of the link
      metrics in the same direction for all symmetric links with that neighbor.
      Note that this means that all neighbor metric values are link metric values
      and that specification of, for example, link metric value encoding also
      includes encoding of neighbor metric values.
    </t>

    <t>
      This specification does not define the nature of the link metric. However,
      this specification allows, through use of the type extension of a defined
      Address Block TLV, for link metrics with specific meanings to be defined
      and either allocated by IANA or privately used. Each HELLO or TC message
      carrying link (or neighbor) metrics thus indicates which
      link metric information it is carrying, allowing routers to
      determine if they can interoperate. If link metrics require additional
      signaling to determine their values, whether in HELLO messages or
      otherwise, then this is permitted but is outside the scope of this
      specification.
    </t>

    <t>
	Careful consideration should be given to how to use link metrics. In
      particular, it is advisable to not simply default to use of all links
      with equal metrics (i.e., hop count) for routing without careful
      consideration of whether that is appropriate or not.
    </t>
  </section>
  
  <section title="Flooding MPRs and Routing MPR">
  	<t>
		This specification uses two sets of MPRs: flooding MPRs and routing MPRs. These are selected separately, because:
		<list style="symbols">
			<t>
				Flooding MPRs may use metrics; routing MPRs must use metrics.
			</t>
			<t>
				When flooding MPRs use metrics, these are outgoing link metrics;
				routing MPRs use incoming neighbor metrics.
			</t>
			<t>
Flooding MPRs must be selected per OLSRv2 interface; routing
      MPRs need not be selected per OLSRv2 interface.
			</t>
		</list>
	</t>
	
  </section>
  
  <section title="Routing Set Use">

    <t>
      The purpose of the Routing Set is to determine and record routes
      (local interface network address and next-hop interface network
      address) to all possible routable addresses advertised by this
      protocol as well as all destinations that are local, i.e.,
      within one hop, to the router (whether using routable addresses
      or not). Only symmetric links are used in such routes.
    </t>

    <t>
      It is intended that the Routing Set can be used for IP packet routing,
      by using its contents to update the IP routing table. That 
update, and whether any Routing Tuples are not used when updating the IP
routing table, is outside the scope of this specification.
    </t>

    <t>
      The signaling in this specification has been designed so that a
      "backbone" Topology Graph of routers, each identified by its
      originator address, with at most one direct connection between any
      pair of routers, can be constructed (from the Neighbor Set and the
      Router Topology Set) using a suitable minimum path length algorithm.
      This Topology Graph can then have other network addresses (routable
      or of symmetric 1-hop neighbors) added to it (using the Interface
      Information Bases, the Routable Address Topology Set, and the Attached
      Network Set).
    </t>

  </section>

</section>
<section anchor="parameters" title="Protocol Parameters and Constants">

  <t>
    The parameters and constants used in this specification are those
    defined in <xref target="RFC6130"/> plus those defined in this section.
    The separation in <xref target="RFC6130"/> into interface parameters,
    router parameters, and constants is also used in this specification.
  </t>

  <t>
Similarly to the parameters in <xref target="RFC6130"/>, parameters defined in this
specification MAY be changed dynamically by a router
and need not be
the same on different routers, even in the same MANET, or, for
interface parameters, on different interfaces of the
same router.
  </t>

  <section title="Protocol and Port Numbers" anchor="protocol-and-port-numbers">

    <t>
      This protocol specifies TC messages, which are included in packets as
      defined by <xref target="RFC5444"/>. These packets MUST be sent either
      using the "manet" protocol number or the "manet" UDP well-known port
      number, as specified in <xref target="RFC5498"/>.
    </t>

    <t>
	TC messages and HELLO messages <xref target="RFC6130"/> MUST,
      in a given MANET, either both use IP or both use UDP,
      in order for it to be possible to combine messages of both protocols
      into the same <xref target="RFC5444"/> packet for transmission.
    </t>

  </section>

  <section title="Multicast Address" anchor="multicast-address">

    <t>
      This protocol specifies TC messages, which are included in packets as
      defined by <xref target="RFC5444"/>. These packets MAY be transmitted
      using the Link-Local multicast address "LL-MANET-Routers", as specified
      in <xref target="RFC5498"/>.
    </t>

  </section>

  <section title="Interface Parameters">  
 
    <t>
      A single additional interface parameter is specified for OLSRv2 interfaces
      only.
    </t>

    <section title="Received Message Validity Time">

      <t>
        The following parameter manages the validity time of recorded
        received message information:
      </t>

      <t>
        <list style="hanging">
          <t hangText="RX_HOLD_TIME:"> <vspace blankLines="0"/>
	      The period after receipt of a message by the appropriate
            OLSRv2 interface of this router for which that information
            is recorded, in order that the message is recognized as having
            been previously received on this OLSRv2 interface.
	    </t>
	  </list>
      </t>

      <t>
        The following constraints apply to this parameter:
	</t>

	<t>
        <list style="symbols">
          <t>
	      RX_HOLD_TIME &gt; 0
	    </t>
	    <t>
            RX_HOLD_TIME SHOULD be greater than the maximum difference
            in time that a message may take to traverse the MANET, taking
            into account any message forwarding jitter as well as propagation,
            queuing, and processing delays.
	    </t>
	  </list>
      </t>

    </section>

  </section>
 
  <section title="Router Parameters">
 
 	<t>
        The following router parameters are specified for routers.
 	</t>
    <section title="Local History Times">

      <t>
        The following router parameter manages the time for which local information
        is retained:
      </t>

      <t>
        <list style="hanging">
          <t hangText="O_HOLD_TIME:"> <vspace blankLines="0"/>
            The time for which a recently used and replaced originator address
            is used to recognize the router's own messages.
          </t>
        </list>
      </t>

      <t>
        The following constraint applies to this parameter:
        <list style="symbols">
          <t>
            O_HOLD_TIME &gt; 0
          </t>
        </list>
      </t>

    </section>
  
    <section anchor="LinkMetricType" title="Link Metric Parameters">

      <t>
        All routes found using this specification use a single link
        metric type that is specified by the router parameter
        LINK_METRIC_TYPE, which may take any value from 0 to 255,
        both inclusive.
      </t>
	
    </section>

    <section anchor="intervals" title="Message Intervals">

      <t>
        The following parameters regulate TC message transmissions by a router.
        TC messages are usually sent periodically but MAY also be sent in response
        to changes in the router's Neighbor Set and/or Local Attached Network Set.
        In a highly dynamic network, and with a larger value of the parameter
        TC_INTERVAL and a smaller value of the parameter TC_MIN_INTERVAL,
        TC messages MAY be transmitted more often in response to changes than
        periodically. However, because a router has no knowledge of, for example,
        routers remote to it (i.e., beyond two hops away) joining the network,
        TC messages MUST NOT be sent purely responsively.
      </t>

      <t>
        <list style="hanging">
          <t hangText="TC_INTERVAL:"> <vspace blankLines="0"/>
            The maximum time between the transmission of two
            successive TC messages by this router. When no TC messages are
            sent in response to local network changes (by design or because
            the local network is not changing), then TC messages MUST be sent
            at a regular interval TC_INTERVAL, possibly modified by jitter, as
            specified in <xref target="RFC5148"/>.
          </t>
          <t hangText="TC_MIN_INTERVAL:"> <vspace blankLines="0"/>
            The minimum interval between transmission of two successive
            TC messages by this router. (This minimum interval MAY be modified
            by jitter, as specified in <xref target="RFC5148"/>.)
          </t>
        </list>
      </t>

      <t>
        The following constraints apply to these parameters:
      </t>

      <t>
        <list style="symbols">
          <t>
            TC_INTERVAL &gt; 0
          </t>
          <t>
            0 &lt;= TC_MIN_INTERVAL &lt;= TC_INTERVAL
          </t>
          <t>
            If TLVs with Type = INTERVAL_TIME, as defined in
            <xref target="RFC5497"/>, are included in TC messages,
            then TC_INTERVAL MUST be representable by way of the
            exponent-mantissa notation described in Section 5 of
            <xref target="RFC5497"/>.
          </t>
        </list>
      </t>

    </section>

    <section title="Advertised Information Validity Times">

      <t>
        The following parameters manage the validity time of information advertised
        in TC messages:
      </t>

      <t>
        <list style="hanging">
          <t hangText="T_HOLD_TIME:"> <vspace blankLines="0"/>
            Used as the minimum value in the TLV with Type = VALIDITY_TIME
            included in all TC messages sent by this router. If a single value of
            parameter TC_HOP_LIMIT (see <xref target="hop-limit"/>) is used, then this 
            will be the only value in that TLV.
          </t>
          <t hangText="A_HOLD_TIME:"> <vspace blankLines="0"/>
            The period during which TC messages are sent after they no longer
            have any advertised information to report but are sent in order to
            accelerate outdated information removal by other routers.
	    </t>
        </list>
      </t>

      <t>
        The following constraints apply to these parameters:
      </t>

      <t>
        <list style="symbols">
          <t>
            T_HOLD_TIME &gt; 0
          </t>
          <t>
            A_HOLD_TIME &gt;= 0
          </t>
          <t>
            T_HOLD_TIME &gt;= TC_INTERVAL
          </t>
          <t>
            If TC messages can be lost, then both T_HOLD_TIME and A_HOLD_TIME SHOULD be
            significantly greater than TC_INTERVAL; a value &gt;= 3 x TC_INTERVAL is RECOMMENDED.
          </t>
          <t> 
            T_HOLD_TIME MUST be representable by way of the exponent-mantissa notation
            described in Section 5 of <xref target="RFC5497"/>.
          </t>
        </list>
      </t>

    </section>

    <section title="Processing and Forwarding Validity Times">

      <t>
        The following parameters manage the processing and forwarding validity time of
        recorded message information:
      </t>

      <t>
        <list style="hanging">
          <t hangText="P_HOLD_TIME:"> <vspace blankLines="0"/>
		The period after receipt of a message that is processed by this router for
            which that information is recorded, in order that the message is not processed
            again if received again.
	    </t>
          <t hangText="F_HOLD_TIME:"> <vspace blankLines="0"/>
		The period after receipt of a message that is forwarded by this router for
            which that information is recorded, in order that the message is not forwarded
            again if received again.
          </t>
        </list>
      </t>

      <t>
        The following constraints apply to these parameters:
      </t>

      <t>
        <list style="symbols">
          <t>
            P_HOLD_TIME &gt; 0
          </t>
          <t>
            F_HOLD_TIME &gt; 0
          </t>
          <t>
            Both of these parameters SHOULD be greater than the maximum difference in time that
            a message may take to traverse the MANET, taking into account any message forwarding
            jitter as well as propagation, queuing, and processing delays.
          </t>
        </list>
      </t>

    </section>

    <section title="Jitter">

      <t> 
        If jitter, as defined in <xref target="RFC5148"/>, is used, then the governing jitter
        parameters are as follows:
      </t>

      <t>
        <list style="hanging">
          <t hangText="TP_MAXJITTER:"> <vspace blankLines="0"/>
            Represents the value of MAXJITTER used in <xref target="RFC5148"/>
            for periodically generated TC messages sent by this router.
          </t>
          <t hangText="TT_MAXJITTER:"> <vspace blankLines="0"/>
            Represents the value of MAXJITTER used in <xref target="RFC5148"/>
            for externally triggered TC messages sent by this router.
          </t>
          <t hangText="F_MAXJITTER:"> <vspace blankLines="0"/>
            Represents the default value of MAXJITTER used in <xref target="RFC5148"/>
            for messages forwarded by this router. However, before using F_MAXJITTER, a router
            MAY attempt to deduce a more appropriate value of MAXJITTER, for example, based
            on any TLVs with Type = INTERVAL_TIME or Type = VALIDITY_TIME contained in the
            message to be forwarded.
          </t>
        </list>
      </t>

      <t>
        For constraints on these parameters, see <xref target="RFC5148"/>.
      </t>

    </section>

    <section anchor="hop-limit" title="Hop Limit ">

      <t>
        The parameter TC_HOP_LIMIT is the hop limit set in each TC message.
        TC_HOP_LIMIT MAY be a single fixed value or MAY be different in
        TC messages sent by the same router. However, each other router, at
        any hop count distance, MUST see a regular pattern of TC messages
        in order that meaningful values of TLVs with Type = INTERVAL_TIME
        and Type = VALIDITY_TIME at each hop count distance can be included
        as defined in <xref target="RFC5497"/>. Thus, the pattern of TC_HOP_LIMIT
        MUST be defined to have this property. For example, the repeating
        pattern (255 4 4) satisfies this property (having period TC_INTERVAL
        at hop counts up to 4, inclusive, and 3 x TC_INTERVAL at hop counts
        greater than 4), but the repeating pattern (255 255 4 4) does not
        satisfy this property because at hop counts greater than 4, message
        intervals are alternately TC_INTERVAL and 3 x TC_INTERVAL.
      </t>

      <t>
        The following constraints apply to this parameter:
      </t>

      <t>
        <list style="symbols">
          <t>
            The maximum value of TC_HOP_LIMIT &gt;= the network diameter in hops;
            a value of 255 is RECOMMENDED. Note that if using a pattern of
            different values of TC_HOP_LIMIT as described above, then only the
            maximum value in the pattern is so constrained.
          </t>
          <t>
            All values of TC_HOP_LIMIT &gt;= 2.
          </t>
        </list>
      </t>

    </section>

    <section title="Willingness" anchor="Willingnesses">

      <t>
        Each router has two willingness parameters: WILL_FLOODING and WILL_ROUTING,
        each of which MUST be in the range WILL_NEVER to WILL_ALWAYS, inclusive.
      </t>

      <t>
	  WILL_FLOODING represents the router's willingness to be selected as a
        flooding MPR and hence to participate in MPR flooding, in particular
        of TC messages.
      </t>

      <t>
	  WILL_ROUTING represents the router's willingness to be selected as a
        routing MPR and hence to be an intermediate router on routes.
      </t>

      <t>
        In either case, the higher the value, the greater the router's willingness
        to be a flooding or routing MPR, as appropriate. If a router has a willingness
        value of WILL_NEVER (the lowest possible value), it does not perform the
        corresponding task. 
  A MANET using
  this protocol with too many routers having either of the willingness
parameters
  WILL_FLOODING or WILL_ROUTING equal to WILL_NEVER will not function;
        it MUST be ensured, by administrative or other means, that this does not happen.
      </t>

      <t>
 Note that the proportion at which the routers having a willingness value equal to
 WILL_NEVER is "too many" depends on the network topology -- which, in
 a MANET, may change dynamically.
        Willingness is intended to enable that certain routers (e.g.,
        routers that have generous resources, such as a permanent power supply) can be
        configured to assume more of the network operation, while others (e.g., routers
        that have lesser resources, such as are battery operated) can avoid such tasks.
        A general guideline would be that only if a router is not actually able to assume the task (flooding or routing) should it be configured with the corresponding
        willingness WILL_NEVER.
      </t>

      <t>
        If a router has a willingness value equal to WILL_ALWAYS (the highest possible
        value), then it will always be selected as a flooding or routing MPR,
as appropriate,
        by all symmetric 1-hop neighbors.
      </t>
    
      <t>
	  In a MANET in which all routers have WILL_FLOODING = WILL_ALWAYS, flooding reduction
        will effectively be disabled, and flooding will perform as blind flooding.
      </t>

      <t>
	  In a MANET in which all routers have WILL_ROUTING = WILL_ALWAYS, topology reduction
        will effectively be disabled, and all routers will advertise all of their links in
        TC messages.
	</t>
	  
      <t>
	  A router that has WILL_ROUTING = WILL_NEVER will not act as an intermediate router
        in the MANET. Such a router can act as a source, destination, or gateway to another
        routing domain.
      </t>
	
      <t>
        Different routers MAY have different values for WILL_FLOODING and/or WILL_ROUTING.
      </t>

      <t>
        The following constraints apply to these parameters:
      </t>

      <t>
        <list style="symbols">
          <t>
            WILL_NEVER &lt;= WILL_FLOODING &lt;= WILL_ALWAYS
          </t>
          <t>
            WILL_NEVER &lt;= WILL_ROUTING &lt;= WILL_ALWAYS
          </t>
        </list>
      </t>

    </section>

  </section>

  <section title="Parameter Change Constraints">

    <t>
      If protocol parameters are changed dynamically, then the constraints in this section apply.
    </t>

    <t>
      <list style="hanging">

        <t hangText="RX_HOLD_TIME">
          <list style="symbols">
            <t>
              If RX_HOLD_TIME for an OLSRv2 interface changes, then the expiry time
              for all Received Tuples for that OLSRv2 interface MAY be changed.
            </t>
          </list>
        </t>

        <t hangText="O_HOLD_TIME">
          <list style="symbols">
            <t>
              If O_HOLD_TIME changes, then the expiry time for all Originator Tuples
              MAY be changed.
            </t>
          </list>
        </t>

        <t hangText="TC_INTERVAL">
          <list style="symbols">
            <t>
              If TC_INTERVAL increases, then the next TC message
              generated by this router MUST be generated according to the previous,
              shorter TC_INTERVAL. Additional subsequent TC messages MAY be
              generated according to the previous, shorter, TC_INTERVAL.
            </t>
            <t>
              If TC_INTERVAL decreases, then the following TC
              messages from this router MUST be generated according to the
              current, shorter, TC_INTERVAL.
            </t>
          </list>
        </t>

        <t hangText="P_HOLD_TIME">
          <list style="symbols">
            <t>
              If P_HOLD_TIME changes, then the expiry time for all Processed Tuples MAY
              be changed.
            </t>
          </list>
        </t>

        <t hangText="F_HOLD_TIME">
          <list style="symbols">
            <t>
              If F_HOLD_TIME changes, then the expiry time for all Forwarded Tuples MAY
              be changed.
            </t>
          </list>
        </t>

        <t hangText="TP_MAXJITTER">
          <list style="symbols">
            <t>
              If TP_MAXJITTER changes, then the periodic TC message schedule
              on this router MAY be changed immediately.
            </t>
          </list>
        </t>

        <t hangText="TT_MAXJITTER">
          <list style="symbols">
            <t>
              If TT_MAXJITTER changes, then externally triggered TC messages
              on this router MAY be rescheduled.
            </t>
          </list>
        </t>

        <t hangText="F_MAXJITTER">
          <list style="symbols">
            <t>
              If F_MAXJITTER changes, then TC messages waiting to be forwarded
              with a delay based on this parameter MAY be rescheduled.
            </t>
          </list>
        </t>

        <t hangText="TC_HOP_LIMIT">
          <list style="symbols">
            <t>
              If TC_HOP_LIMIT changes, and the router uses multiple values after the
              change, then message intervals and validity times included in TC messages
              MUST be respected. The simplest way to do this is to start any new
              repeating pattern of TC_HOP_LIMIT values with its largest value.
            </t>
          </list>
        </t>

        <t hangText="LINK_METRIC_TYPE">
          <list style="symbols">
            <t>
              If LINK_METRIC_TYPE changes, then all link metric information
              recorded by the router is invalid. The router MUST take the following
              actions and all consequent actions described in <xref target="base-changes"/>
              and <xref target="RFC6130"/>.
              <list style="symbols">
                <t>
                  For each Link Tuple in any Link Set for an OLSRv2 interface, either
                  update L_in_metric (the value MAXIMUM_METRIC MAY be used) or remove
                  the Link Tuple from the Link Set.
                </t>
                <t>
                  For each Link Tuple that is not removed, set:
                  <list style="symbols">
                    <t>
            	    L_out_metric := UNKNOWN_METRIC;
            	  </t>
           		  <t>
            	    L_SYM_time := EXPIRED; 
            	  </t>
           		  <t>
                      L_MPR_selector := false.
            	  </t>
                  </list>
                </t>
                <t>
                  Remove all Router Topology Tuples, Routable Address Topology Tuples,
                  Attached Network Tuples, and Routing Tuples from their respective
                  Protocol Sets in the Topology Information Base.
                </t>
              </list>
		</t>
	    </list>
	  </t>

      </list>
    </t>

  </section>

  <section title="Constants">

    <t>
      The following constants are specified for routers. Unlike router parameters,
      constants MUST NOT change and MUST be the same on all routers.
    </t>

    <section title="Link Metric Constants">
  	
      <t>
	  The constant minimum and maximum link metric values are defined by:
	  <list style="symbols">
	    <t>MINIMUM_METRIC := 1</t>
	    <t>MAXIMUM_METRIC := 16776960</t>
	  </list>
    	</t>

      <t>
        The symbolic value UNKNOWN_METRIC is defined in <xref target="link_metric_representation"/>.
      </t>

    </section>

    <section title="Willingness Constants">

      <t>
	  The constant minimum, RECOMMENDED default, and maximum willingness values are defined by:
	  <list style="symbols">
          <t>WILL_NEVER   := 0</t>
          <t>WILL_DEFAULT := 7</t>
          <t>WILL_ALWAYS  := 15</t>
        </list>
      </t>

    </section>

    <section title="Time Constant">

      <t>
        The constant C (time granularity) is used as specified in <xref target="RFC5497"/>. It MUST be the same
        as is used by <xref target="RFC6130"/>, with RECOMMENDED value:
        <list style="symbols">
          <t>C := 1/1024 second</t>
        </list>
        Note that this constant is used in the representation of time intervals. Time values
        (such as are stored in Protocol Tuples) are not so represented. A resolution of C in
        such values is sufficient (but not necessary) for such values.
      </t>

    </section>

  </section>

</section>
<section anchor="link_metric_values" title="Link Metric Values">
 
  <t>
    A router records a link metric value for each direction of a link of which it has knowledge. These link metric values are used to create metrics for routes by the addition of link metric values.
  </t>
    
  <section anchor="link_metric_representation" title="Link Metric Representation">

    <t>
      Link metrics are reported in messages using a compressed representation
that occupies 12 bits, consisting of a 4-bit field and an 8-bit field. The
compressed representation represents positive integer values with a minimum
value of 1 and a maximum value that is slightly smaller than the maximum 24-bit
value. Only those values that have exact representation in the compressed
      form are used. Route metrics are the summation of no more than 256 link metric values and can therefore be represented using no more than 32 bits.
    </t>
   
    <t>
      Link and route metrics used in the Information Bases defined in this
specification refer to the uncompressed values, and arithmetic involving them
does likewise and assumes full precision in the result. (How an implementation
records the values is not part of this specification, as long as it behaves as
if recording uncompressed values. An implementation can, for example, use
32-bit values for all link and route metrics.)
    </t>
 
    <t>
      In some cases, a link metric value may be unknown. This is indicated in
this specification by the symbolic value UNKNOWN_METRIC. An implementation may
use any representation of UNKNOWN_METRIC as it is never included in messages
or used in any computation. (Possible representations are zero or any value
greater than the maximum representable metric value.)
    </t>
 
  </section>
   
  <section title="Link Metric Compressed Form">
   
    <t>
      The 12-bit compressed form of a link metric uses a modified form of a
representation with an 8-bit mantissa (denoted a) and a 4-bit exponent (denoted
b). Note that if represented as the 12-bit value 256b+a, then the ordering of
those 12-bit values is identical to the ordering of the represented values.
    </t>
     
    <t>
      The value so represented is (257+a)2^b - 256, where ^ denotes exponentiation. This has a minimum value (when a = 0 and b = 0) of MINIMUM_METRIC = 1 and a maximum value (when a = 255 and b = 15) of MAXIMUM_METRIC = 2^24 - 256.
    </t>
 
    <t>
      An algorithm for computing a and b for the smallest representable value not less than a link metric value v such that MINIMUM_METRIC &lt;= v &lt;= MAXIMUM_METRIC is:
      <list style="numbers">
        <t>
          Find the smallest integer b such that v + 256 &lt;= 2^(b + 9).
        </t>
        <t>
          Set a := (v - 256(2^b - 1)) / (2^b) - 1, rounded up to the nearest integer.
        </t>
      </list>
     </t>

  </section>

</section>
<section anchor="local-base" title="Local Information Base">

  <t>
    The Local Information Base, as defined for each router in <xref target="RFC6130"/>,
    is extended by this protocol by:

    <list style="symbols">
      <t>
        Recording the router's originator address. The originator address
        MUST be unique to this router. It MUST NOT be used by any other
        router as an originator address. It MAY be included in any network
        address in any I_local_iface_addr_list of this router; it MUST NOT
        be included in any network address in any I_local_iface_addr_list
        of any other router. It MAY be included in, but MUST NOT be equal to,
        the AL_net_addr in any Local Attached Network Tuple in this or any
        other router.
      </t>
      <t>
        The addition of an Originator Set, defined in
        <xref target="originator-set"/>, and a Local Attached Network Set,
        defined in <xref target="local-attached-set"/>.
      </t>
    </list>
  </t>

  <t>
    All routable addresses of the router for which it is to accept IP packets
    as destination MUST be included in the Local Interface Set or the Local
    Attached Network Set.
  </t>

  <section anchor="originator-set" title="Originator Set">

    <t>
      A router's Originator Set records addresses that were recently
      used as originator addresses by this router. If a router's
      originator address is immutable, then the Originator Set is always
      empty and MAY be omitted. It consists of Originator Tuples:
    </t>

    <figure>
      <artwork>
   (O_orig_addr, O_time)
      </artwork>
    </figure>

    <t>
      where:
      <list>
        <t>
          O_orig_addr is a recently used originator address; note that this does not
          include a prefix length.
        </t>
        <t>
          O_time specifies the time at which this Tuple expires and MUST be removed.
        </t>
      </list>
    </t>

  </section>

  <section anchor="local-attached-set" title="Local Attached Network Set">

    <t>
   A router's Local Attached Network Set records its local non-OLSRv2
   interfaces via which it can act as a gateway to other networks.  The
   Local Attached Network Set MUST be provided to this protocol and MUST
   reflect any changes in the router's status.  (In cases where the
   router's configuration is static, the Local Attached Network Set will
   be constant; in cases where the router has no such non-OLSRv2 interfaces,
   the Local Attached Network Set will be empty.)  The Local Attached
   Network Set is not modified by this protocol.  This protocol 
      will respond to (externally provided) changes to the Local Attached
      Network Set.&nbsp; It consists of Local Attached Network Tuples:
    </t>

    <figure>
      <artwork>
   (AL_net_addr, AL_dist, AL_metric)
      </artwork>
    </figure>

    <t>
      where:
      <list>
        <t>
          AL_net_addr is the network address of an attached network that can be reached
          via this router. This SHOULD be a routable address. It is constrained
          as described below.
        </t>
        <t>
          AL_dist is the number of hops to the network with network address AL_net_addr
          from this router.
        </t>
        <t>
          AL_metric is the metric of the link to the attached network with address
          AL_net_addr from this router.
        </t>
      </list>
    </t>

    <t>
      Attached networks local to this router only (i.e., not reachable except
      via this router) SHOULD be treated as local non-MANET interfaces and
      added to the Local Interface Set, as specified in <xref target="RFC6130"/>,
      rather than added to the Local Attached Network Set.
    </t>

    <t>
      Because an attached network is not specific to the router and may be
      outside the MANET, an attached network MAY also be attached to other
      routers. Routing to an AL_net_addr will use maximum prefix length
      matching; consequently, an AL_net_addr MAY include, but MUST NOT equal
      or be included in, any network address that is of any interface of
      any router (i.e., is included in any I_local_iface_addr_list) or equal
      any router's originator address.
    </t>

    <t>
      It is not the responsibility of this protocol to maintain routes from
      this router to networks recorded in the Local Attached Network Set.
    </t>

    <t>
  Local Attached Network Tuples are removed from the Local Attached
  Network Set only when the router's local attached network
  configuration changes, i.e., they are not subject to timer-based
  expiration or changes due to received messages.
    </t>

  </section>

</section>
<section anchor="interface-information-base" title="Interface Information Base">

  <t>
    An Interface Information Base, as defined in <xref target="RFC6130"/>, is
    maintained for each MANET interface. The Link Set and 2-Hop Set in the
    Interface Information Base for an OLSRv2 interface are modified by this
    protocol. In some cases, it may be convenient to consider these Sets as
    also containing these additional elements for other MANET interfaces,
    taking the indicated values on creation but never being updated.
  </t>

  <section title="Link Set">

    <t>
      The Link Set is modified by adding these additional elements to each Link Tuple:


        <list>
          <t>
	      L_in_metric is the metric of the link from the OLSRv2 interface
            with addresses L_neighbor_iface_addr_list to this OLSRv2 interface;
          </t>
          <t>
		L_out_metric is the metric of the link to the OLSRv2 interface
            with addresses L_neighbor_iface_addr_list from this OLSRv2 interface;
          </t>
          <t>
		L_mpr_selector is a boolean flag, describing if this neighbor has
            selected this router as a flooding MPR, i.e., is a flooding MPR
            selector of this router.
          </t>
        </list>
        L_in_metric will be specified by a process that is external to this
        specification. Any Link Tuple with L_status = HEARD or
        L_status = SYMMETRIC MUST have a specified value of L_in_metric
        if it is to be used by this protocol.
      </t>

      <t>
        A Link Tuple created (but not updated) by <xref target="RFC6130"/> MUST set:
        <list style="symbols">
          <t> L_in_metric    := UNKNOWN_METRIC;</t>
          <t> L_out_metric   := UNKNOWN_METRIC;</t>      
          <t> L_mpr_selector := false.</t>
        </list>
      </t>

    </section>

  <section title="2-Hop Set">

    <t>
      The 2-Hop Set is modified by  adding these additional elements to each 2-Hop Tuple:
      <list>
        <t>
          N2_in_metric is the neighbor metric from the router with address N2_2hop_iface_addr to the router with OLSRv2 interface addresses N2_neighbor_iface_addr_list;
        </t>
         <t>
          N2_out_metric is the neighbor metric to the router with address N2_2hop_iface_addr from the router with OLSRv2 interface addresses N2_neighbor_iface_addr_list.
        </t>
      </list>
    </t>

    <t>
      A 2-Hop Tuple created (but not updated) by <xref target="RFC6130"/> MUST set:
      <list style="symbols">
        <t> N2_in_metric    := UNKNOWN_METRIC;</t>
        <t> N2_out_metric   := UNKNOWN_METRIC.</t>      
      </list>
    </t>
	
  </section>

</section>
<section anchor="local-link-base" title="Neighbor Information Base">

  <t>
    A Neighbor Information Base, as defined in <xref target="RFC6130"/>, is
    maintained for each router. It is modified by this protocol by adding
    these additional elements to each Neighbor Tuple in the Neighbor Set.
    In some cases, it may be convenient to consider these Sets as
    also containing these additional elements for other MANET interfaces,
    taking the indicated values on creation but never being updated.

    <list>

      <t>
        N_orig_addr is the neighbor's originator address, which may be unknown. Note
        that this originator address does not include a prefix length;
      </t>

      <t>
        N_in_metric is the neighbor metric of any link from this neighbor to an
        OLSRv2 interface of this router, i.e., the minimum of all corresponding
        L_in_metric with L_status = SYMMETRIC and L_in_metric != UNKNOWN_METRIC,
        UNKNOWN_METRIC if there are no such Link Tuples;
      </t>

      <t>
        N_out_metric is the neighbor metric of any link from an OLSRv2 interface
        of this router to this neighbor, i.e., the minimum of all corresponding
        L_out_metric with L_status = SYMMETRIC and L_out_metric != UNKNOWN_METRIC,
        UNKNOWN_METRIC if there are no such Link Tuples;
      </t>
        
	<t>
    	  N_will_flooding is the neighbor's willingness to be selected as a flooding MPR,
        in the range from WILL_NEVER to WILL_ALWAYS, both inclusive, taking the value
        WILL_NEVER if no OLSRv2-specific information is received from this neighbor;
    	</t>

	<t>
    	  N_will_routing is the neighbor's willingness to be selected as a routing MPR,
        in the range from WILL_NEVER to WILL_ALWAYS, both inclusive, taking the value
        WILL_NEVER if no OLSRv2-specific information is received from this neighbor;
    	</t>

      <t>
   	  N_flooding_mpr is a boolean flag, describing if this neighbor is selected as a flooding
        MPR by this router;
      </t>
        
      <t>
   	  N_routing_mpr is a boolean flag, describing if this neighbor is selected as a routing
        MPR by this router;
      </t>
        
      <t>
   	  N_mpr_selector is a boolean flag, describing if this neighbor has selected this
        router as a routing MPR, i.e., is a routing MPR selector of this router.
      </t>
        
      <t>
        N_advertised is a boolean flag, describing if this router has elected to
        advertise a link to this neighbor in its TC messages.
      </t>

    </list>
  </t>

  <t>
    A Neighbor Tuple created (but not updated) by <xref target="RFC6130"/>
    MUST set:
    <list style="symbols">
      <t> N_orig_addr     := unknown;</t>
      <t> N_in_metric     := UNKNOWN_METRIC;</t>
      <t> N_out_metric    := UNKNOWN_METRIC;</t>
      <t> N_will_flooding := WILL_NEVER;</t>
      <t> N_will_routing  := WILL_NEVER;</t>
      <t> N_routing_mpr   := false;</t>
      <t> N_flooding_mpr  := false;</t>
      <t> N_mpr_selector  := false;</t>
      <t> N_advertised    := false.</t>
    </list>
  </t>

  <t>
    The Neighbor Information Base also includes a variable, the Advertised
    Neighbor Sequence Number (ANSN), whose value is included in TC messages
    to indicate the freshness of the information transmitted. The ANSN is
    incremented whenever advertised information (the originator and
    routable addresses included in Neighbor Tuples with N_advertised = true
    and local attached networks recorded in the Local Attached Network Set
    in the Local Information Base) changes, including addition or removal
    of such information.
  </t>

</section>
<section anchor="topologybase" title="Topology Information Base">

  <t>
    The Topology Information Base, defined for each router by this
    specification, stores information received in TC messages in the
    Advertising Remote Router Set, the Router Topology Set, the Routable
    Address Topology Set, and the Attached Network Set.
  </t>

  <t>
    Additionally, a Routing Set is maintained, derived from the information
    recorded in the Local Information Base, the Interface Information Bases,
    the Neighbor Information Base, and the rest of the Topology Information Base.
  </t>

  <section anchor="arnset" title="Advertising Remote Router Set">

    <t>
      A router's Advertising Remote Router Set records information
      describing each remote router in the network that transmits
      TC messages, allowing outdated TC messages to be recognized
      and discarded. It consists of Advertising Remote Router Tuples:
    </t>

    <figure>
      <artwork>
   (AR_orig_addr, AR_seq_number, AR_time)
      </artwork>
    </figure>

    <t>
      where:
      <list>

        <t>
          AR_orig_addr is the originator address of a received TC message, note that
          this does not include a prefix length;
        </t>

        <t>
          AR_seq_number is the greatest ANSN in any TC message received that originated
          from the router with originator address AR_orig_addr (i.e., that
          contributed to the information contained in this Tuple);
        </t>

        <t>
          AR_time is the time at which this Tuple expires and MUST be removed.
        </t>

      </list>
    </t>

  </section>

  <section title="Router Topology Set">

    <t>
      A router's Topology Set records topology information about the 
      links between routers in the MANET. It consists of Router Topology Tuples:
    </t>

    <figure>
      <artwork>
   (TR_from_orig_addr, TR_to_orig_addr, TR_seq_number, TR_metric,
    TR_time)
      </artwork>
    </figure>

    <t>
      where:
      <list>

        <t>
          TR_from_orig_addr is the originator address of a router that can reach the router
          with originator address TR_to_orig_addr in one hop (note that this
          does not include a prefix length);
        </t>

        <t>
     TR_to_orig_addr is the originator address of a router that can be
     reached by the router with originator address TR_from_orig_addr in
     one hop (note that this does not include a prefix length);
        </t>

        <t>
          TR_seq_number is the greatest ANSN in any TC message received that originated
          from the router with originator address TR_from_orig_addr (i.e.,
          that contributed to the information contained in this Tuple);
        </t>

        <t>
          TR_metric is the neighbor metric from the router with originator address
          TR_from_orig_addr to the router with originator address
          TR_to_orig_addr;
        </t>
        
        <t>
          TR_time specifies the time at which this Tuple expires and MUST be removed.
        </t>

      </list>
    </t>

  </section>

  <section title="Routable Address Topology Set">


    <t>
   A router's Routable Address Topology Set records topology information
   about the routable addresses within the MANET, including via which routers
   they may be reached.  It consists of Routable Address Topology Tuples:
    </t>

    <figure>
      <artwork>
   (TA_from_orig_addr, TA_dest_addr, TA_seq_number, TA_metric,
    TA_time)
      </artwork>
    </figure>

    <t>
      where:
      <list>

         <t>
          TA_from_orig_addr is the originator address of a router that can reach the router with
          routable address TA_dest_addr in one hop (note that this does not
          include a prefix length);
        </t>

        <t>
          TA_dest_addr is a routable address of a router that can be reached by the router
          with originator address TA_from_orig_addr in one hop;
        </t>         

        <t>
          TA_seq_number is the greatest ANSN in any TC message received that originated
          from the router with originator address TA_from_orig_addr (i.e.,
          that contributed to the information contained in this Tuple);
        </t>
        
        <t>
          TA_metric is the neighbor metric from the router with originator address
          TA_from_orig_addr to the router with OLSRv2 interface address
          TA_dest_addr;
        </t>
        
        <t>
          TA_time specifies the time at which this Tuple expires and MUST be removed.
        </t>

      </list>
    </t>

  </section>

  <section anchor="networkset" title="Attached Network Set">

    <t>
      A router's Attached Network Set records information about networks
      (which may be outside the MANET) attached to other routers and their
      routable addresses. It consists of Attached Network Tuples:
    </t>

    <figure>
      <artwork>
   (AN_orig_addr, AN_net_addr, AN_seq_number, AN_dist, AN_metric,
    AN_time)
      </artwork>
    </figure>

    <t>
      where:
      <list>

        <t>
          AN_orig_addr is the originator address of a router that can act as gateway to
          the network with network address AN_net_addr (note that this does
          not include a prefix length);
        </t>

        <t>
          AN_net_addr is the network address of an attached network that may be reached
          via the router with originator address AN_orig_addr;
        </t>

        <t>
          AN_seq_number is the greatest ANSN in any TC message received that originated
          from the router with originator address AN_orig_addr (i.e., that
          contributed to the information contained in this Tuple);
        </t>

        <t>
          AN_dist is the number of hops to the network with network address AN_net_addr
          from the router with originator address AN_orig_addr;
        </t>

        <t>
          AN_metric is the metric of the link from the router with originator address
          AN_orig_addr to the attached network with address AN_net_addr;
        </t>
        
        <t>
          AN_time specifies the time at which this Tuple expires and MUST be removed.
        </t>

      </list>
    </t>

  </section>

  <section anchor="routingset" title="Routing Set">

    <t>
      A router's Routing Set records the first hop along a selected path to
      each destination for which any such path is known. It consists of
      Routing Tuples:
    </t>

    <figure>
      <artwork>
   (R_dest_addr, R_next_iface_addr, R_local_iface_addr, R_dist,
    R_metric)
      </artwork>
    </figure>

    <t>
      where:
      <list>

        <t>
          R_dest_addr is the network address of the destination, either the network address
          of an interface of a destination router or the network address of an
          attached network;
        </t>

        <t>
          R_next_iface_addr is the network address of the "next hop" on the selected path to the destination;
        </t>

        <t>
          R_local_iface_addr is an address of the local interface over which an IP packet
          MUST be sent to reach the destination by the selected path.
        </t>

        <t>
          R_dist is the number of hops on the selected path to the destination;
        </t>
        
        <t>
          R_metric is the metric of the route to the destination with address R_dest_addr.
        </t>

      </list>
    </t>

    <t>
      The Routing Set for a router is derived from the contents of other Protocol
      Sets of the router (the Link Sets, the Neighbor Set, the Router Topology Set,
      the Routable Address Topology Set, the Attached Network Set, and OPTIONAL use of
      the 2-Hop Sets). The Routing Set is updated (Routing Tuples added or removed,
      or the complete Routing Set recalculated) when routing paths are calculated,
      based on changes to these other Protocol Sets. Routing Tuples are not subject
      to timer-based expiration.
    </t>

  </section>

</section>
<section anchor="fwd-repositories" title="Received Message Information Base">

  <t>
    The Received Message Information Base, defined by this specification,
    records information required to ensure that a message is processed at
    most once and is forwarded at most once per OLSRv2 interface of a router,
    using MPR flooding. Messages are recorded using their "signature",
    consisting of their type, originator address, and message sequence number.
  </t>

  <section anchor="receivedset" title="Received Set">

    <t>
      A router has a Received Set per OLSRv2 interface. Each Received Set
      records the signatures of messages that have been received over that
      OLSRv2 interface. Each consists of Received Tuples:
    </t>

    <figure>
      <artwork>
   (RX_type, RX_orig_addr, RX_seq_number, RX_time)
      </artwork>
    </figure>

    <t>
      where:
      <list>
        <t>
          RX_type is the received Message Type;
        </t>
        <t>
          RX_orig_addr is the originator address of the received message (note that
          this does not include a prefix length);
        </t>
        <t>
          RX_seq_number is the message sequence number of the received message;
        </t>
        <t>
          RX_time specifies the time at which this Tuple expires and MUST be removed.
        </t>
      </list>
    </t>

  </section>

  <section anchor="Processed-Set" title="Processed Set">

    <t>
      A router has a single Processed Set that records signatures of messages
      that have been processed by the router. It consists of Processed Tuples:
    </t>

    <figure>
      <artwork>
   (P_type, P_orig_addr, P_seq_number, P_time)
      </artwork>
    </figure>

    <t>
      where:
      <list>
        <t>
          P_type is the processed Message Type;
        </t>
        <t>
          P_orig_addr is the originator address of the processed message (note that
          this does not include a prefix length);
        </t>
        <t>
          P_seq_number is the message sequence number of the processed message;
        </t>
        <t>
          P_time specifies the time at which this Tuple expires and MUST be removed.
        </t>
      </list>
    </t>

  </section>

  <section anchor="forwarded-Set" title="Forwarded Set">

    <t>
      A router has a single Forwarded Set that records signatures of messages
      that have been forwarded by the router. It consists of Forwarded Tuples:
    </t>

    <figure>
      <artwork>
   (F_type, F_orig_addr, F_seq_number, F_time)
      </artwork>
    </figure>

    <t>
      where:
      <list>
        <t>
          F_type is the forwarded Message Type;
        </t>
        <t>
          F_orig_addr is the originator address of the forwarded message (note that
          this does not include a prefix length);
        </t>
        <t>
          F_seq_number is the message sequence number of the forwarded message;
        </t>
        <t>
          F_time specifies the time at which this Tuple expires and MUST be removed.
        </t>
      </list>
    </t>

  </section>

</section>
<section title="Information Base Properties">

  <t>
    This section describes some additional properties of Information Bases
    and their contents.
  </t>

  <section title="Corresponding Protocol Tuples">

  <t>
    As part of this specification, in a number of cases, there is a natural
    correspondence from a Protocol Tuple in one Protocol Set to a single
    Protocol Tuple in another Protocol Set, in the same or another Information
    Base. The latter Protocol Tuple is referred to as "corresponding" to the
    former Protocol Tuple.
  </t>

  <t>
    Specific examples of corresponding Protocol Tuples include:
    <list style="symbols">
      <t>
        There is a Local Interface Tuple corresponding to each Link Tuple,
        where the Link Tuple is in the Link Set for a MANET interface
        and the Local Interface Tuple represents that MANET interface.
      </t>
      <t>
        There is a Neighbor Tuple corresponding to each Link Tuple that
        has L_HEARD_time not EXPIRED, such that N_neighbor_addr_list
        contains L_neighbor_iface_addr_list.
      </t>
      <t>
        There is a Link Tuple (in the Link Set in the same Interface
        Information Base) corresponding to each 2-Hop Tuple such that
        L_neighbor_iface_addr_list = N2_neighbor_iface_addr_list.
      </t>
      <t>
        There is a Neighbor Tuple corresponding to each 2-Hop Tuple,
        such that N_neighbor_addr_list contains N2_neighbor_iface_addr_list.
        (This is the Neighbor Tuple corresponding to the Link Tuple
        corresponding to the 2-Hop Tuple.)
      </t>
      <t>
        There is an Advertising Remote Router Tuple corresponding to each
        Router Topology Tuple such that AR_orig_addr = TR_from_orig_addr.
      </t>
      <t>
        There is an Advertising Remote Router Tuple corresponding to each
        Routable Address Topology Tuple such that AR_orig_addr = TA_from_orig_addr.
      </t>
      <t>
        There is an Advertising Remote Router Tuple corresponding to each
        Attached Network Tuple such that AR_orig_addr = AN_orig_addr.
      </t>
      <t>
        There is a Neighbor Tuple corresponding to each Routing Tuple
        such that N_neighbor_addr_list contains R_next_iface_addr.
      </t>
    </list>
  </t>

  </section>

  <section title="Address Ownership">

  <t>
    Addresses or network addresses with the following properties are considered as
    "fully owned" by a router when processing a received message:
    <list style="symbols">
      <t>
        Equaling its originator address; OR
      </t>
      <t>
        Equaling the O_orig_addr in an Originator Tuple; OR
      </t>
      <t>
        Equaling or being a sub-range of the I_local_iface_addr_list in a Local
Interface Tuple; OR
      </t>
      <t>
        Equaling or being a sub-range of the IR_local_iface_addr in a Removed
Interface Address Tuple; OR
      </t>
      <t>
        Equaling an AL_net_addr in a Local Attached Network Tuple.
      </t>
    </list>
  </t>

  <t>
    Addresses or network addresses with the following properties are considered as
    "partially owned" (which may include being fully owned) by a router when processing
    a received message:
    <list style="symbols">
      <t>
        Overlapping (equaling or containing) its originator address; OR
      </t>
      <t>
        Overlapping (equaling or containing) the O_orig_addr in an Originator
Tuple; OR
      </t>
      <t>
        Overlapping the I_local_iface_addr_list in a Local Interface Tuple; OR
      </t>
      <t>
        Overlapping the IR_local_iface_addr in a Removed Interface Address
Tuple; OR
      </t>
      <t>
        Equaling or having as a sub-range an AL_net_addr in a Local Attached Network Tuple.
      </t>
    </list>
  </t>

  </section>

</section>
<section anchor="OLSRmessages" title="Packets and Messages">

  <t>
    The packet and message format used by this protocol is defined
    in <xref target="RFC5444"/>. Except as otherwise noted, options
    defined in <xref target="RFC5444"/> may be freely used, in particular
    alternative formats defined by packet, message, Address Block, and
    TLV flags. 
  </t>
  
  <t>
    This section describes the usage of the packets and messages defined
    in <xref target="RFC5444"/> by this specification and the TLVs
    defined by, and used in, this specification.
  </t>
  
  <section title="Messages">

    <t>
    	Routers using this protocol exchange information through messages.
      The Message Types used by this protocol are the HELLO message and
      the TC message. The HELLO message is defined by <xref target="RFC6130"/>
      and extended by this specification (see <xref target="HELLOmessages"/>).
      The TC message is defined by this specification (see <xref target="TCmessages"/>).
    </t>

  </section>
    
  <section title="Packets">

    <t>
    	One or more messages sent by a router at the same time SHOULD be combined
      into a single packet, subject to any constraints on maximum packet size
      (such as derived from the MTU over a local single hop) that MAY be imposed.
      These messages may have originated at the sending router or 
      at another router and are being forwarded by the sending router. Messages
      with different originating routers MAY be combined for transmission within
      the same packet. Messages from other protocols defined using <xref target="RFC5444"/>,
      including but not limited to NHDP <xref target="RFC6130"/>, MAY be combined for
      transmission within the same packet. This specification does not define or
      use any contents of the Packet Header.
    </t>

    <t>
    	Forwarded messages MAY be jittered as described in <xref target="RFC5148"/>,
      including the observation that the forwarding jitter of all messages received
      in a single packet SHOULD be the same. The value of MAXJITTER used in jittering
      a forwarded message MAY be based on information in that message (in particular
      any Message TLVs with Type = INTERVAL_TIME or Type = VALIDITY_TIME) or otherwise
      SHOULD be with a maximum delay of F_MAXJITTER. A router MAY modify the jitter
      applied to a message in order to more efficiently combine messages in packets,
      as long as the maximum jitter is not exceeded.
    </t>

  </section>
	
  <section anchor="tlvs" title="TLVs">

    <t>
	This specification defines two Message TLVs and four Address Block TLVs.
    </t>
    <t>
      All references in this specification to TLVs that do not indicate a type extension
      assume Type Extension = 0. TLVs in processed messages with a type
extension that is
      neither zero as so assumed, nor a specifically indicated non-zero type extension, are ignored.
    </t>
<t>
Note that, following <xref target="RFC5444"/> and network byte order, bits in
an octet are
numbered
from 0 (most significant) to 7 (least significant).
</t>


    <section title="Message TLVs" anchor="msgtlvs">

      <t>
	  The MPR_WILLING TLV is used in HELLO messages. A message MUST NOT contain more than one MPR_WILLING TLV.
	</t>

    	<texttable anchor="hellomsgtlvoverview" title="MPR_WILLING TLV Definition">
        <ttcol align="center">Type</ttcol>
        <ttcol align="center">Value&nbsp;Length</ttcol>
        <ttcol align="left">Value</ttcol>
	  <c>MPR_WILLING</c><c>1&nbsp;octet</c>
	  <c>Bits 0-3 encode the parameter WILL_FLOODING; bits 4-7 encode the parameter WILL_ROUTING.</c>
	</texttable>

	<t>
	  The CONT_SEQ_NUM TLV is used in TC messages. A message MUST NOT contain more than one CONT_SEQ_NUM TLV.
    	</t>

      <texttable anchor="contseqnumtlv" title="CONT_SEQ_NUM TLV Definition">
	  <ttcol align="center">Type</ttcol>
    	  <ttcol align="center">Value&nbsp;Length</ttcol>
        <ttcol align="left">Value</ttcol>
        <c>CONT_SEQ_NUM</c><c>2&nbsp;octets</c>
        <c>The ANSN contained in the Neighbor Information Base.</c>
      </texttable>
 
    </section>
  		
    <section title="Address Block TLVs" anchor="addrtlvs">

      <t>
        The LINK_METRIC TLV is used in HELLO messages and TC messages. It MAY
        use any type extension; only LINK_METRIC TLVs with type extension equal
        to LINK_METRIC_TYPE will be used by this specification. An address
        MUST NOT be associated with more than one link metric value for any given
        type extension, kind (link or neighbor), and direction using this TLV.
      </t>

      <texttable anchor="linkmetrictlv" title="LINK_METRIC TLV Definition">
	  <ttcol align="center">Type</ttcol>
    	  <ttcol align="center">Value&nbsp;Length</ttcol>
        <ttcol align="left">Value</ttcol>
        <c>LINK_METRIC</c><c>2&nbsp;octets</c>
        <c>Bits 0-3 indicate kind(s) and direction(s); bits 4-7 indicate
           exponent (b); and bits 8-15 indicate mantissa (a).</c>
      </texttable>

      <t>
        The exponent and mantissa use the representation defined in
        <xref target="link_metric_values"/>. Each bit of the types and directions
        sub-field, if set ('1'), indicates that the link metric is of the indicated
        kind and direction. Any combination of these bits MAY be used.
      </t>

      <texttable anchor="linkmetrictlvstart" title="LINK_METRIC TLV Types and Directions">
	  <ttcol align="center">Bit</ttcol>
    	  <ttcol align="center">Kind</ttcol>
        <ttcol align="left">Direction</ttcol>
        <c>0</c><c>Link metric</c><c>Incoming</c>
        <c>1</c><c>Link metric</c><c>Outgoing</c>
        <c>2</c><c>Neighbor metric</c><c>Incoming</c>
        <c>3</c><c>Neighbor metric</c><c>Outgoing</c>
      </texttable>

      <t>
	  The MPR TLV is used in HELLO messages and indicates that an address with
        which it is associated is of a symmetric 1-hop neighbor that has been
        selected as an MPR.
      </t>

      <texttable anchor="mprtlv" title="MPR TLV Definition">
	  <ttcol align="center">Type</ttcol>
    	  <ttcol align="center">Value&nbsp;Length</ttcol>
        <ttcol align="left">Value</ttcol>
        <c>MPR</c><c>1&nbsp;octet</c>
        <c>FLOODING indicates that the corresponding address is of a neighbor
           selected as a flooding MPR; ROUTING indicates that the corresponding
           address is of a neighbor selected as a routing MPR; and FLOOD_ROUTE
           indicates both (see <xref target="tlv_values"/>).</c>
      </texttable>

      <t>


        The NBR_ADDR_TYPE TLV is used in TC messages.
      </t>

      <texttable anchor="nbraddrtypetlv" title="NBR_ADDR_TYPE TLV Definition">
        <ttcol align="center">Type</ttcol>
        <ttcol align="center">Value&nbsp;Length</ttcol>
        <ttcol align="left">Value</ttcol>
        <c>NBR_ADDR_TYPE</c><c>1&nbsp;octet</c>
          <c>ORIGINATOR indicates that the corresponding address (which MUST have
             maximum prefix length) is an originator address; ROUTABLE indicates
             that the corresponding network address is a routable address of an
             interface; and ROUTABLE_ORIG indicates that the corresponding address is
             both (see <xref target="tlv_values"/>).</c>
      </texttable>

      <t>
        If an address is both an originator address and a routable address, then it
        may be associated with either one Address Block TLV with Type := NBR_ADDR_TYPE
        and Value := ROUTABLE_ORIG, or with two Address Block TLVs with Type:= NBR_ADDR_TYPE,
        one with Value := ORIGINATOR and one with Value := ROUTABLE.
      </t>

      <t>
        The GATEWAY TLV is used in TC messages. An address MUST NOT be associated with
        more than one hop count value using this TLV.
      </t>

      <texttable anchor="gatewaytlv" title="GATEWAY TLV Definition">
        <ttcol align="center">Type</ttcol>
        <ttcol align="center">Value&nbsp;Length</ttcol>
        <ttcol align="left">Value</ttcol>
        <c>GATEWAY</c><c>1&nbsp;octet</c><c>Number of hops to attached network.</c>
      </texttable>

      <t>
        All address objects included in a TC message according to this specification MUST
        be associated either with at least one TLV with Type := NBR_ADDR_TYPE or with a TLV
        with Type := GATEWAY, but not both. Any other address objects MAY be included in
        Address Blocks in a TC message but are ignored by this specification.
      </t>

    </section>	

  </section>
	
</section>
<section anchor="messageforwarding" title="Message Processing and Forwarding">

  <t>
    This section describes the optimized flooding operation (MPR flooding) used
    when control messages, as instances of <xref target="RFC5444"/>, are intended
    for MANET-wide distribution. This flooding mechanism defines when a received
    message is, or is not, processed and/or forwarded.
  </t>

  <t>
    This flooding mechanism is used by this protocol and MAY be used by extensions
    to this protocol that define, and hence own, other Message Types, to manage
    processing and/or forwarding of these messages. This specification contains
    elements (P_type, RX_type, F_type) required only for such usage. 
  </t>

  <t>
    This flooding mechanism is always used for TC messages (see <xref target="TCmessages"/>).
    Received HELLO messages (see <xref target="HELLOmessages"/>) are, unless invalid,
    always processed and never forwarded by this flooding mechanism. They thus do not need
    to be recorded in the Received Message Information Base.
  </t>

  <t>
    The processing selection and forwarding mechanisms are designed to only need
    to parse the Message Header in order to determine whether a message is to be
    processed and/or forwarded and not to have to parse the Message Body even if
    the message is forwarded (but not processed). An implementation MAY only parse
    the Message Body if necessary or MAY always parse the Message Body and reject
    the message if it cannot be so parsed or any other error is identified.
  </t>

  <t>
    An implementation MUST discard the message silently if it is unable to
    parse the Message Header or (if attempted) the Message Body, or if a message
    (other than a HELLO message) does not include a message sequence number.
  </t>

  <section anchor="msg-received" title="Actions When Receiving a Message">

    <t>
      On receiving, on an OLSRv2 interface, a message of a type specified to be
      using this mechanism, which includes the TC messages defined in this
      specification, a router MUST perform the following:

      <list style="numbers">

        <t>
          If the router recognizes from the originator address of the message
          that the message is one that the receiving router itself originated
          (i.e., the message originator address is the originator address of this
          router or is an O_orig_addr in an Originator Tuple), then the message
          MUST be silently discarded.
        </t>

        <t>
          Otherwise:
          <list style="numbers">
            <t>
              If the message is of a type that may be processed, then the message
              is considered for processing according to
              <xref target="consider-processing"/>.
            </t>
            <t>
              If the message is of a type that may be forwarded, AND:
              <list style="symbols">
                <t>&lt;msg-hop-limit&gt; is present and &lt;msg-hop-limit&gt;
&gt; 1; AND</t>
                <t>&lt;msg-hop-count&gt; is not present or &lt;msg-hop-count&gt; &lt; 255,</t>
              </list>
              then the message is considered for forwarding according to
              <xref target="consider-forwarding"/>.
            </t>
          </list>
        </t>

      </list>
    </t>
      
  </section>
    
  <section anchor="consider-processing" title="Message Considered for Processing">

    <t>
      If a message (the "current message") is considered for processing,
      then the following tasks MUST be performed:

      <list style="numbers">

        <t>
          If the sending address (i.e., the source address of the IP datagram
          containing the current message) does not match (taking into account
          any address prefix) a network address in an L_neighbor_iface_addr_list
          of a Link Tuple, with L_status = SYMMETRIC, in the Link Set for the
          OLSRv2 interface on which the current message was received (the
          "receiving interface"), then processing the current message is OPTIONAL.
          If the current message is not processed, then the following steps are
          not carried out.
        </t>

        <t>
          If a Processed Tuple exists with:
          <list style="symbols">
            <t>
              P_type = the Message Type of the current message; AND
            </t>
            <t>
              P_orig_addr = the originator address of the current message; AND
            </t>
            <t>
              P_seq_number = the message sequence number of the current message,
            </t>
          </list>
          then the current message MUST NOT be processed.
        </t>

        <t>
          Otherwise:

          <list style="numbers">
            <t>
              Create a Processed Tuple in the Processed Set with:
              <list style="symbols">
                <t>
                  P_type := the Message Type of the current message;
                </t>
                <t>
                  P_orig_addr := the originator address of the current message;
                </t>
                <t>
                  P_seq_number := the sequence number of the current message;
                </t>
                <t>
                  P_time := current time + P_HOLD_TIME.
                </t>
              </list>
            </t>
            <t>
              Process the current message according to its Message Type. For a TC
              message, this is as defined in <xref target="tcprocess"/>.
            </t>
          </list>

        </t> 

      </list>
    </t>

  </section>

  <section anchor="consider-forwarding" title="Message Considered for Forwarding">

    <t>
      If a message (the "current message") is considered for forwarding,
      then the following tasks MUST be performed:

      <list style="numbers">

        <t>
          If the sending address (i.e., the source address of the IP datagram
          containing the current message) does not match (taking into account
          any address prefix) a network address in an L_neighbor_iface_addr_list
          of a Link Tuple, with L_status = SYMMETRIC, in the Link Set for the
          OLSRv2 interface on which the current message was received (the
          "receiving interface"), then the current message MUST be silently
          discarded.
        </t>

        <t>
          Otherwise:

          <list style="numbers">
            <t>
              If a Received Tuple exists in the Received Set for the receiving
              interface, with:
              <list style="symbols">
                <t>
                  RX_type = the Message Type of the current message; AND
                </t>
                <t>
                  RX_orig_addr = the originator address of the current message; AND
                </t>
                <t>
                  RX_seq_number = the sequence number of the current message,
                </t>
		  </list>
              then the current message MUST be silently discarded.
            </t>
            <t>
              Otherwise:
              <list style="numbers">
                <t>
                  Create a Received Tuple in the Received Set for the receiving
                  interface with:
                  <list style="symbols">
                    <t>
                      RX_type := the Message Type of the current message;
                    </t>
                    <t>
                      RX_orig_addr := originator address of the current message;
                    </t>
                    <t>
                      RX_seq_number := sequence number of the current message;
                    </t>
                    <t>
                      RX_time := current time + RX_HOLD_TIME.
                    </t>
                  </list>
                </t>
                <t>
                  If a Forwarded Tuple exists with:
                  <list style="symbols">
                    <t>
                      F_type = the Message Type of the current message; AND
                    </t>
                    <t>
                      F_orig_addr = the originator address of the current message; AND
                    </t>
                    <t>
                      F_seq_number = the sequence number of the current message,
                    </t>
                  </list>
                  then the current message MUST be silently discarded.
                </t>

                <t>
Otherwise, if the sending address matches (taking account
              of any address prefix), any network address in an
              L_neighbor_iface_addr_list of a Link Tuple in the Link
              Set for the receiving OLSRv2 interface that has L_status
              = SYMMETRIC and L_mpr_selector = true, then:
                  <list style="numbers">
                    <t>
                      Create a Forwarded Tuple in the Forwarded Set with:
                      <list style="symbols">
                        <t>
                          F_type := the Message Type of the current message;
                        </t>
                        <t>
                          F_orig_addr := originator address of the current message;
                        </t>
                        <t>
                          F_seq_number := sequence number of the current message;
                        </t>
                        <t>
                          F_time := current time + F_HOLD_TIME.
                        </t>
                      </list>
                    </t>
                    <t>
                      The Message Header of the current message is modified by:
                      <list style="symbols">
                        <t>
                          Decrement &lt;msg-hop-limit&gt; in the Message Header by 1; AND
                        </t>
                        <t>
                          If present, increment &lt;msg-hop-count&gt; in the Message Header by 1.
                        </t>
                      </list>
                    </t>
                    <t>
                      The message is transmitted over all OLSRv2 interfaces, as described in
                      <xref target="OLSRmessages"/>.
                    </t>
                  </list>
				
                </t>
				<t> Otherwise, the current message MUST be silently discarded.</t>
		  </list>

            </t>

          </list>

        </t>

      </list>

    </t>

  </section>

</section>
<section anchor="HELLOmessages" title="HELLO Messages">

  <t>
    The HELLO Message Type is owned by NHDP <xref target="RFC6130"/>, and 
    HELLO messages are thus generated, transmitted, received, and processed by
    NHDP. This protocol, as permitted by <xref target="RFC6130"/>,
    also uses HELLO messages, including adding to HELLO message generation and
    implementing additional processing based on received HELLO messages. HELLO
    messages are not forwarded by NHDP <xref target="RFC6130"/> or by OLSRv2.
  </t>
    
  <section anchor="hellogen" title="HELLO Message Generation">

	<t>
	  HELLO messages sent over OLSRv2 interfaces are generated as defined in <xref target="RFC6130"/>
        and then modified as described in this section. HELLO messages sent on other MANET interfaces
        are not modified by this specification.
	</t>
	<t>
	  HELLO messages sent over OLSRv2 interfaces are extended by adding the following elements:

      <list style = "symbols">

        <t>
          A message originator address, recording this router's originator address.
          This MUST use a &lt;msg-orig-addr&gt; element, unless:
          <list style = "symbols">
            <t>
              The message specifies only a single local interface address (i.e., contains
              only one address object that is associated with an Address Block TLV with
              Type = LOCAL_IF and that has no prefix length or a maximum prefix length)
              that will then be used as the message originator address; OR
            </t>
            <t>
              The message does not include any local interface network addresses (i.e.,
              has no address objects associated with an Address Block TLV with Type = LOCAL_IF),
              as permitted by the specification in <xref target="RFC6130"/>, when the router
              that generated the HELLO message has only one interface address and will use
              that as the sending address of the IP datagram in which the HELLO message is
              contained. In this case, that address will be used as the message originator
              address.
            </t>
          </list>
        </t>

        <t>
          A Message TLV with Type := MPR_WILLING MUST be included.
        </t>

        <t>
          The following cases associate Address Block TLVs with one or more addresses from
          a Link Tuple or a Neighbor Tuple if these are included in the HELLO message. In
          each case, the TLV MUST be associated with at least one address object for an address
          from the relevant Tuple; the TLV MAY be associated with more such addresses (including a
          copy of that address object, possibly not itself associated with any other indicated
          TLVs, in the same or a different Address Block). These additional TLVs MUST NOT be
          associated with any other addresses in a HELLO message that will be
processed by NHDP
          <xref target="RFC6130"/>.

          <list style="symbols">

            <t>
              For each Link Tuple for which L_in_metric != UNKNOWN_METRIC and for which one or
              more addresses in its L_neighbor_iface_addr_list are included as address objects
              with an associated Address Block TLV with Type = LINK_STATUS and Value = HEARD
              or Value = SYMMETRIC, at least one of these addresses MUST be associated
              with an Address Block TLV with Type := LINK_METRIC indicating an incoming link
              metric with value L_in_metric.
            </t>

            <t>
              For each Link Tuple for which L_out_metric != UNKNOWN_METRIC and for which one or
              more addresses in its L_neighbor_iface_addr_list are included as address objects
              with an associated Address Block TLV with Type = LINK_STATUS and Value = SYMMETRIC,
              at least one of these addresses MUST be associated with an Address Block TLV with
              Type := LINK_METRIC indicating an outgoing link metric with value L_out_metric.
            </t>

            <t>
              For each Neighbor Tuple for which N_symmetric = true and for which one or
              more addresses in its N_neighbor_addr_list are included as address objects
              with an associated Address Block TLV with Type = LINK_STATUS or Type = OTHER_NEIGHB
              and Value = SYMMETRIC, at least one of these addresses MUST be associated with an
              Address Block TLV with Type := LINK_METRIC indicating an incoming neighbor metric
              with value N_in_metric.
            </t>

            <t>
              For each Neighbor Tuple for which N_symmetric = true and for which one or
              more addresses in its N_neighbor_addr_list are included as address objects
              with an associated Address Block TLV with Type = LINK_STATUS or Type = OTHER_NEIGHB
              and Value = SYMMETRIC, at least one of these addresses MUST be associated with an
              Address Block TLV with Type := LINK_METRIC indicating an outgoing neighbor metric
              with value N_out_metric.
            </t>

            <t>
              For each Neighbor Tuple with N_flooding_mpr = true and for which one or more
              network addresses in its N_neighbor_addr_list are included as address objects
              in the HELLO message with an associated Address Block TLV with Type = LINK_STATUS
              and Value = SYMMETRIC, at least one of these addresses MUST be associated
              with an Address Block TLV with Type := MPR and Value := FLOODING or
              Value := FLOOD_ROUTE.
            </t>

            <t>
              For each Neighbor Tuple with N_routing_mpr = true and for which one or more
              network addresses in its N_neighbor_addr_list are included as address objects
              in the HELLO message with an associated Address Block TLV with Type = LINK_STATUS
              and Value = SYMMETRIC, at least one of these addresses MUST be associated
              with an Address Block TLV with Type := MPR and Value := ROUTING or
              Value := FLOOD_ROUTE.
            </t>

          </list>

        </t>

      </list>
    </t>

  </section>
  
  <section title="HELLO Message Transmission">
  
    <t>
      HELLO messages are scheduled and transmitted by NHDP <xref target="RFC6130"/>.
      This protocol MAY require that an additional HELLO message be sent on each
      OLSRv2 interface when either of the router's sets of MPRs changes, in
      addition to the cases specified in <xref target="RFC6130"/> and subject
      to the constraints specified in <xref target="RFC6130"/> (notably on
minimum HELLO message transmission intervals).
    </t>
  
  </section>
  
  <section anchor="helloprocess" title="HELLO Message Processing">
  
    <t>
      When received on an OLSRv2 interface, HELLO messages are made available
      to this protocol in two ways, both as permitted by <xref target="RFC6130"/>:
      <list style="symbols">
        <t>
          Such received HELLO messages MUST be made available to this protocol
          on reception, which allows them to be discarded before being
processed by NHDP
          <xref target="RFC6130"/>, for example, if the information added to the
          HELLO message by this specification is inconsistent.
        </t>
        <t>
          Such received HELLO messages MUST be made available to OLSRv2 after NHDP
          <xref target="RFC6130"/> has completed its processing thereof, unless
          discarded as malformed by NHDP, for processing by OLSRv2.
        </t>
      </list>
    </t>

    <section anchor="hello_discard" title="HELLO Message Discarding">

    <t>
      In addition to the reasons specified in <xref target="RFC6130"/> for
      discarding a HELLO message on reception, a HELLO message received on an
      OLSRv2 interface MUST be discarded before processing by NHDP <xref target="RFC6130"/>
      or this
  specification if it:

      <list style="symbols">

        <t>
          Has more than one Message TLV with Type = MPR_WILLING.
        </t>

        <t>
          Has a message originator address, or a network address corresponding to an
          address object associated with an Address Block TLV with Type = LOCAL_IF,
          that is partially owned by this router. (Some of these cases are already 
          excluded by <xref target="RFC6130"/>.)
        </t>

        <t>
          Includes any address object associated with an Address Block TLV with
          Type = LINK_STATUS or Type = OTHER_NEIGHB that overlaps the message's
          originator address.
        </t>
        

        <t>
          Contains any address that will be processed by NHDP <xref target="RFC6130"/>
          that is associated, using the same or different address objects, with
          two different values of link metric with the same kind and direction
          using a TLV with Type = LINK_METRIC and Type Extension = LINK_METRIC_TYPE.
          This also applies to different addresses that are both of the OLSRv2
          interface on which the HELLO message was received.
        </t>

        <t>
          Contains any address object associated with an Address Block TLV with
          Type = MPR that is not also associated with an Address Block TLV with
          Type = LINK_STATUS and Value = SYMMETRIC (including using a different
          copy of that address object in the same or a different Address Block).
        </t>

      </list>

    </t>

  </section>

  <section title="HELLO Message Usage">

    <t>
      HELLO messages are first processed as specified in <xref target="RFC6130"/>.
      That processing includes identifying (or creating) a Link Tuple and a Neighbor Tuple
      corresponding to the originator of the HELLO message (the "current Link Tuple"
      and the "current Neighbor Tuple"). After this, the following processing MUST also be
      performed if the HELLO message is received on an OLSRv2 interface and contains a TLV
      with Type = MPR_WILLING:


      <list style="numbers">
        <t>
          If the HELLO message has a well-defined message originator address, i.e.,
          has an &lt;msg-orig-addr&gt; element or has zero or one network addresses
          associated with a TLV with Type = LOCAL_IF:
          <list style="numbers">
            <t>
              Remove any Neighbor Tuple, other than the current Neighbor Tuple, with
              N_orig_addr = message originator address, taking any consequent action
              (including removing one or more Link Tuples) as specified in
              <xref target="RFC6130"/>.
            </t>
            <t>
              The current Link Tuple is then updated according to:
              <list style="numbers">
                <t>
                  Update L_in_metric and L_out_metric as described in <xref target="metric-update"/>;
                </t>
                <t>
                  Update L_mpr_selector as described in <xref target="mprs-set-population"/>.
                </t>
              </list>
            </t>
            <t>
              The current Neighbor Tuple is then updated according to:
              <list style="numbers">
                <t>
                  N_orig_addr := message originator address;
                </t>
                <t>
                  Update N_in_metric and N_out_metric as described in <xref target="metric-update"/>;
                </t>
                <t>
                  Update N_will_flooding and N_will_routing as described in <xref target="willingness-update"/>;
                </t>
                <t>
                  Update N_mpr_selector as described in <xref target="mprs-set-population"/>.
                </t>

              </list>
            </t>
<t>
All 2-Hop Tuples that were updated as described in <xref target="RFC6130"/>
are then updated according to:

<list style="numbers">
<t>
Update N2_in_metric and N2_out_metric as described in
<xref target="metric-update"/>.
</t>
</list>
</t>

          </list>
        </t>
        <t>
          If there are any changes to the router's Information Bases, then perform the processing defined in
          <xref target="base-changes"/>.
        </t>
      </list>
    </t>

    <section anchor="metric-update" title="Updating Metrics">

      <t>
   For each address in a received HELLO message with an associated TLV
   with Type = LINK_STATUS and Value = HEARD or Value = SYMMETRIC, an
   incoming (to the message originator) link metric value is defined.
   If the HELLO message contains a TLV with Type = LINK_METRIC and Type
   Extension = LINK_METRIC_TYPE that associates that address value with a
metric value of the appropriate kind
   (link) and direction (incoming) of metric, then the incoming link metric
   is that metric value; otherwise, the incoming link metric is defined as UNKNOWN_METRIC.
      </t>
      <t>
   For each address in a received HELLO message with an associated TLV
   with Type = LINK_STATUS and Value = SYMMETRIC, an outgoing (from the
   message originator) link metric value is defined.
   If the HELLO message contains a TLV with Type = LINK_METRIC and Type
   Extension = LINK_METRIC_TYPE that associates that address value with
   a metric value of the appropriate kind (link) and direction
   (outgoing) of metric, then the outgoing link metric is that metric
   value; otherwise, the outgoing link metric is defined as
   UNKNOWN_METRIC.
      </t>
      <t>
  For each address in a received HELLO message with an associated TLV
   with Type = LINK_STATUS or Type = OTHER_NEIGHB and Value = SYMMETRIC,
   an incoming (to the message originator) neighbor metric value is
   defined.
   If the HELLO message contains a TLV with Type = LINK_METRIC and Type
   Extension = LINK_METRIC_TYPE that associates that address value with
   a metric value of the appropriate kind (neighbor) and direction
   (incoming) of metric, then the incoming neighbor metric is that metric
   value; otherwise, the incoming neighbor metric is defined as
   UNKNOWN_METRIC.
      </t>
      <t>
   For each address in a received HELLO message with an associated TLV
   with Type = LINK_STATUS or Type = OTHER_NEIGHB and Value = SYMMETRIC,
   an outgoing (from the message originator) neighbor metric value is
   defined.
   If the HELLO message contains a TLV with Type = LINK_METRIC and Type
   Extension = LINK_METRIC_TYPE that associates that address value with
   a metric value of the appropriate kind (neighbor) and direction
   (outgoing) of metric, then the outgoing neighbor metric is that metric
   value; otherwise, the outgoing neighbor metric is defined as
   UNKNOWN_METRIC.
      </t>

      <t>
        The link metric elements L_in_metric and L_out_metric in a Link Tuple
        are updated according to the following:
        <list style="symbols">
          <t>
            For any Link Tuple, L_in_metric MAY be set to any representable value
            by a process outside this specification at any time. L_in_metric MUST
            be so set whenever L_status becomes equal to HEARD or SYMMETRIC (if no
            other value is available, then the value MAXIMUM_METRIC MUST be used).
            Setting L_in_metric MAY use information based on the receipt of a packet
            including a HELLO message that causes the creation or updating of the
            Link Tuple.
          </t>
          <t>
            When, as specified in <xref target="RFC6130"/>, a Link Tuple is updated
            (possibly immediately after being created) due to the receipt of a HELLO
            message, if L_status = SYMMETRIC, then L_out_metric is set equal to the
            incoming link metric for any included address of the interface on which
            the HELLO message was received. (Note that the rules for discarding
            HELLO messages in <xref target="hello_discard"/> make this value
            unambiguous.) 
 If there is any such address, but no such link
    metric, then L_out_metric is set to UNKNOWN_METRIC.
          </t>
        </list>
      </t>

      <t>
        The neighbor metric elements N_in_metric and N_out_metric in a Neighbor Tuple
        are updated according to <xref target="neighbor-changes"/>.
      </t>

      <t>
        The metric elements N2_in_metric and N2_out_metric in any 2-Hop Tuple
        updated as defined in <xref target="RFC6130"/> are updated to equal the
        incoming neighbor metric and outgoing neighbor metric, respectively,
        associated with the corresponding N2_2hop_addr. If there are no such metrics,
        then these elements are set to UNKNOWN_METRIC.
     </t>

    </section>

    <section anchor="willingness-update" title="Updating Willingness">

      <t>
        N_will_flooding and N_will_routing in the current Neighbor Tuple are updated
        using the Message TLV with Type = MPR_WILLING (note that this must be present)
        as follows:
        <list style="symbols">
          <t>
            N_will_flooding := bits 0-3 of the value of that TLV; AND
          </t>
          <t>
            N_will_routing := bits 4-7 of the value of that TLV.
          </t>
        </list>
        (Each being in the range 0 to 15, i.e., WILL_NEVER to WILL_ALWAYS.)
      </t>

    </section>

    <section anchor="mprs-set-population" title="Updating MPR Selector Status">

      <t>
        L_mpr_selector is updated as follows:
        <list style="numbers">
          <t>
            If a router finds an address object representing any of its relevant local
            interface network addresses (i.e., those contained in the I_local_iface_addr_list of
            an OLSRv2 interface) with an associated Address Block TLV with Type = MPR and
            Value = FLOODING or Value = FLOOD_ROUTE in the HELLO message (indicating that
            the originating router has selected the receiving router as a flooding MPR),
            then, for the current Link Tuple:
            <list style="symbols">
              <t>
                L_mpr_selector := true.
              </t>
            </list>
	      </t>
	      <t>
            Otherwise (i.e., if no such address object and Address Block TLV was found),
            if a router finds an address object representing any of its relevant local
            interface network addresses (i.e., those contained in the I_local_iface_addr_list of
            an OLSRv2 interface) with an associated Address Block TLV with Type = LINK_STATUS
            and Value = SYMMETRIC in the HELLO message, then, for the current Link Tuple:
            <list style="symbols">
              <t>
                L_mpr_selector := false.
              </t>
            </list>
          </t>	
        </list>
      </t>

      <t>
        N_mpr_selector is updated as follows:
        <list style="numbers">
          <t>
            If a router finds an address object representing any of its relevant local
            interface network addresses (those contained in the I_local_iface_addr_list of
            an OLSRv2 interface) with an associated Address Block TLV with Type = MPR and
            Value = ROUTING or Value = FLOOD_ROUTE in the HELLO message (indicating that
            the originating router has selected the receiving router as a routing MPR), then,
            for the current Neighbor Tuple:
            <list style="symbols">
              <t>
                N_mpr_selector := true;
              </t>
              <t>
                N_advertised := true.
              </t>
            </list>
	      </t>
	      <t>
            Otherwise (i.e., if no such address object and Address Block TLV was found),
            if a router finds an address object representing any of its relevant local
            interface network addresses (those contained in the I_local_iface_addr_list of
            an OLSRv2 interface) with an associated Address Block TLV with Type = LINK_STATUS
            and Value = SYMMETRIC in the HELLO message, then, for the current Neighbor Tuple:
            <list style="symbols">
              <t>
                N_mpr_selector := false;
              </t>
              <t>
                The router MAY also set N_advertised := false.
              </t>
            </list>
          </t>	
        </list>
      </t>

    </section>

    </section>

  </section>

</section>
<section anchor="TCmessages" title="TC Messages">

  <t>
    This protocol defines, and hence owns, the TC Message Type (see <xref target="iana"/>).
    Thus, as specified in <xref target="RFC5444"/>, this protocol generates and transmits
    all TC messages, receives all TC messages, and is responsible for determining whether
    and how each TC message is to be processed (updating the Topology Information Base)
    and/or forwarded, according to this specification.
  </t>

  <section anchor="tcgen" title="TC Message Generation">

    <t>
      A TC message is a message as defined in <xref target="RFC5444"/>. A generated TC
      message MUST contain the following elements as defined in <xref target="RFC5444"/>:
    </t>
    
    <t>
	<list style="symbols">

    	  <t>
          A message originator address, recording this router's originator address.
          This MUST use a &lt;msg-orig-addr&gt; element.
	  </t>

    	  <t>
    	    &lt;msg-seq-num&gt; element containing the message sequence number.
        </t>

        <t>
    	    A &lt;msg-hop-limit&gt; element, containing TC_HOP_LIMIT. A router MAY use
          the same or different values of TC_HOP_LIMIT in its TC messages (see
          <xref target="hop-limit"/>).
        </t>

        <t>
    	    A &lt;msg-hop-count&gt; element, containing zero, if the message contains a TLV
          with either Type = VALIDITY_TIME or Type = INTERVAL_TIME (as specified in
          <xref target="RFC5497"/>) indicating more than one time value according to
          distance. A TC message MAY contain such a &lt;msg-hop-count&gt; element even
          if it does not need to.
	  </t>

        <t>
          A single Message TLV with Type := CONT_SEQ_NUM and Value := ANSN from the
          Neighbor Information Base. If the TC message is complete, then this Message
          TLV MUST have Type Extension := COMPLETE; otherwise, it MUST have
          Type Extension := INCOMPLETE. (Exception: a TC message MAY omit such a
          Message TLV if the TC message does not include any address objects with
          an associated Address Block TLV with Type = NBR_ADDR_TYPE or Type = GATEWAY.)
        </t>

        <t>
          A single Message TLV with Type := VALIDITY_TIME, as specified in
          <xref target="RFC5497"/>. If all TC messages are sent with the same hop limit,
          then this TLV MUST have a value encoding the period T_HOLD_TIME. If TC messages
          are sent with different hop limits (more than one value of TC_HOP_LIMIT), then
          this TLV MUST specify times that vary with the number of hops
          appropriate to the chosen pattern of TC message hop limits, as specified in
          <xref target="RFC5497"/>; these times SHOULD be appropriate multiples of
          T_HOLD_TIME. The options included in <xref target="RFC5497"/> for representing
          zero and infinite times MUST NOT be used.
        </t>

        <t>
          If the TC message is complete, all network addresses that are the N_orig_addr
          of a Neighbor Tuple with N_advertised = true, MUST be represented by address
          objects in one or more Address Blocks. If the TC message is incomplete, then
          any such address objects MAY be included. At least one copy of each such
          address object that is included MUST be associated with an Address Block TLV
          with Type := NBR_ADDR_TYPE and Value := ORIGINATOR or with Value := ROUTABLE_ORIG
          if that address object is also to be associated with Value = ROUTABLE.
        </t>

        <t>
          If the TC message is complete, all routable addresses that are in the
          N_neighbor_addr_list of a Neighbor Tuple with N_advertised = true MUST
          be represented by address objects in one or more Address Blocks. If the
          TC message is incomplete, then any such address objects MAY be included.
          At least one copy of each such address object MUST be associated with an
          Address Block TLV with Type = NBR_ADDR_TYPE and Value = ROUTABLE or
          with Value = ROUTABLE_ORIG if also to be associated with Value = ORIGINATOR.
          At least one copy of each such address object MUST be associated with an
          Address Block TLV with Type = LINK_METRIC and Type Extension = LINK_METRIC_TYPE
          indicating an outgoing neighbor metric with value equal to the corresponding
          N_out_metric.
        </t>

        <t>
          If the TC message is complete, all network addresses that are the AL_net_addr
          of a Local Attached Network Tuple MUST be represented by address objects in one
          or more Address Blocks. If the TC message is incomplete, then any such address
          objects MAY be included. At least one copy of each such address object MUST be
          associated with an Address Block TLV with Type := GATEWAY and Value := AN_dist.
          At least one copy of each such address object MUST be associated with an
          Address Block TLV with Type = LINK_METRIC and Type Extension = LINK_METRIC_TYPE
          indicating an outgoing neighbor metric equal to the corresponding AL_metric.
	  </t>

      </list>
    </t>

    <t>
      A TC message MAY contain:
      <list style="symbols">
        <t>
          A single Message TLV with Type := INTERVAL_TIME, as specified in <xref target="RFC5497"/>.
          If all TC messages are sent with the same hop limit, then this TLV MUST have a value
          encoding the period TC_INTERVAL. If TC messages are sent with different hop limits,
          then this TLV MUST specify times that vary with the number of hops  appropriate
          to the chosen pattern of TC message hop limits, as specified in <xref target="RFC5497"/>;
          these times MUST be appropriate multiples of TC_INTERVAL. The options included in
          <xref target="RFC5497"/> for representing zero and infinite times MUST NOT be used.
        </t>
      </list>
    </t>
    
  </section>
  
  <section anchor="tctransmission" title="TC Message Transmission">

    <t> 
      A router with one or more OLSRv2 interfaces, and with any Neighbor Tuples
      with N_advertised = true, or with a non-empty Local Attached Network Set
      MUST generate TC messages. A router that does not have such information
      to advertise MUST also generate "empty" TC messages for a period A_HOLD_TIME
      after it last generated a non-empty TC message.
    </t>

    <t>
      Complete TC messages are generated and transmitted periodically on all
      OLSRv2 interfaces, with a default interval between two consecutive
      TC message transmissions by the same router of TC_INTERVAL.
    </t>

    <t>
      TC messages MAY be generated in response to a change in the information
      that they are to advertise, indicated by a change in the ANSN in the
      Neighbor Information Base. In this case, a router MAY send a complete
      TC message and, if so, MAY restart its TC message schedule. Alternatively,
      a router MAY send an incomplete TC message with at least the newly
      advertised network addresses (i.e., not previously, but now, an N_orig_addr
      or in an N_neighbor_addr_list in a Neighbor Tuple with N_advertised = true
      or an AL_net_addr) in its Address Blocks, with associated Address Block TLV(s).
      Note that a router cannot report removal of advertised content using an
      incomplete TC message.
    </t>

    <t>
      When sending a TC message in response to a change of advertised network addresses,
      a router MUST respect a minimum interval of TC_MIN_INTERVAL between sending
      TC messages (complete or incomplete) and a maximum interval of TC_INTERVAL
      between sending complete TC messages. Thus, a router MUST NOT send an incomplete
      TC message if within TC_MIN_INTERVAL of the next scheduled time to send a complete
      TC message.
    </t>

    <t>
      The generation of TC messages, whether scheduled or triggered by a change of
      contents, MAY be jittered as described in <xref target="RFC5148"/>. The values
      of MAXJITTER used MUST be:
      <list style="symbols">
        <t>TP_MAXJITTER for periodic TC message generation;</t>
        <t>TT_MAXJITTER for responsive TC message generation.</t>
      </list>
    </t>
    
  </section>  

  <section anchor="tcprocess" title="TC Message Processing">

    <t>
      On receiving a TC message on an OLSRv2 interface, the receiving router MUST then
      follow the processing and forwarding procedures defined in
      <xref target="messageforwarding"/>.
    </t>

    <t>
      If the message is considered for processing (<xref target="consider-processing"/>),
      then a router MUST first check if the message is invalid for processing by this router,
      as defined in <xref target="invalid-tc-message"/>. 


A router MAY make a                                                                                                
similar check before considering a message for forwarding; it MUST                                                 
check the aspects that apply to elements in the Message Header.  
    </t>
      

    <t> 
      If the TC message is not invalid, then the processing specific to TC Message Type,
      described in <xref target="tcprocessoverview"/>, MUST be applied. This will
      update its appropriate Interface Information Bases and its Router Information Base.
      Following this, if there are any changes in these Information Bases, then the
      processing in <xref target="base-changes"/> MUST be performed.
    </t>

    <section anchor="invalid-tc-message" title="TC Message Discarding">

      <t>
        A received TC message is invalid for processing by this router if the message:

        <list style="symbols">

          <t>
            Has an address length specified in the Message Header that is not equal
            to the length of the addresses used by this router.
          </t>

          <t>
            Does not include a message originator address and a message sequence number.
          </t>

          <t>
            Does not include a hop count and contains a multi-value TLV with
            Type = VALIDITY_TIME or Type = INTERVAL_TIME, as defined in
            <xref target="RFC5497"/>.
          </t>

          <t>
            Does not have exactly one Message TLV with Type = VALIDITY_TIME.
          </t>

          <t>
            Has more than one Message TLV with Type = INTERVAL_TIME.
          </t>

          <t>
            Does not have a Message TLV with Type = CONT_SEQ_NUM and
            Type Extension = COMPLETE or Type Extension = INCOMPLETE and contains
            at least one address object associated with an Address Block TLV with
            Type = NBR_ADDR_TYPE or Type = GATEWAY.
          </t>

          <t>
            Has more than one Message TLV with Type = CONT_SEQ_NUM and
            Type Extension = COMPLETE or Type Extension = INCOMPLETE.
          </t>

          <t>
            Has a message originator address that is partially owned by this router.
          </t>

          <t>
            Includes any address object with a prefix length that is not maximal
            (equal to the address length, in bits), associated with an Address Block TLV
            with Type = NBR_ADDR_TYPE and Value = ORIGINATOR or Value = ROUTABLE_ORIG.
          </t>

          <t>
            Includes any address object that represents a non-routable address,
            associated with an Address Block TLV with Type = NBR_ADDR_TYPE and
            Value = ROUTABLE or Value = ROUTABLE_ORIG.
          </t>

          <t>
            Includes any address object associated with an Address Block TLV with
            Type = NBR_ADDR_TYPE or Type = GATEWAY that also represents the message's
            originator address.
          </t>

          <t>
            Includes any address object (including different copies of an address
            object in the same or different Address Blocks) that is associated with
            an Address Block TLV with Type = NBR_ADDR_TYPE or Type = GATEWAY that
            is also associated with more than one outgoing neighbor metric using a
            TLV with Type = LINK_METRIC and Type Extension = LINK_METRIC_TYPE.
          </t>

          <t>
            Associates any address object (including different copies of an address
            object in the same or different Address Blocks) with more than one
            single hop count value using one or more Address Block TLV(s) with
            Type = GATEWAY.
          </t>

          <t>
            Associates any address object (including different copies of an address
            object in the same or different Address Blocks) with Address Block
            TLVs with Type = NBR_ADDR_TYPE and Type = GATEWAY.
          </t>

        </list>

      </t>

      <t>
        A router MAY recognize additional reasons for identifying that a message
        is invalid. An invalid message MUST be silently discarded, without updating
        the router's Information Bases.
      </t>

      <t>
        Note that a router that acts inconsistently, for example, rejecting TC
        messages "at random", may cause parts of the network to not be able to
        communicate with other parts of the network. It is RECOMMENDED that
        such "additional reasons for identifying that a message is invalid"
        be a consistent network-wide policy (e.g., as part of a security policy),
        implemented on all participating routers.
      </t>

    </section>

    <section anchor="tcprocessoverview" title="TC Message Processing Definitions">

      <t>
        When, according to <xref target="consider-processing"/>, a TC message is to be
        "processed according to its type", this means that:
        <list style="symbols">
          <t>
            If the TC message contains a Message TLV with Type = CONT_SEQ_NUM and
            Type Extension = COMPLETE, then processing according to <xref target="tcprocessstart"/>
            and then according to <xref target="tcprocessfinish"/> is carried out.
          </t>
          <t>
            If the TC message contains a Message TLV with Type = CONT_SEQ_NUM and
            Type Extension = INCOMPLETE, then only processing according to
            <xref target="tcprocessstart"/> is carried out.
          </t>
        </list>
      </t>

      <t>
        For the purposes of the TC message processing in <xref target="tcprocessstart"/> and <xref target="tcprocessfinish"/>:
        <list style="symbols">
  	      <t>
            "validity time" is calculated from a VALIDITY_TIME Message TLV in the TC message according
             to the specification in <xref target="RFC5497"/>. All information in the TC message
             has the same validity time.
          </t>
          <t>
            "received ANSN" is defined as being the value of a Message TLV with Type = CONT_SEQ_NUM.
          </t>
          <t>
            "associated metric value" is defined for any address in the TC message as being either
            the outgoing neighbor metric value indicated by a TLV with Type = LINK_METRIC and
            Type Extension = LINK_METRIC_TYPE that is associated with any address object in the
            TC message that is equal to that address or as UNKNOWN_METRIC otherwise. (Note that
            the rules in <xref target="invalid-tc-message"/> make this definition unambiguous.)
          </t>
          <t>
            Comparisons of sequence numbers are carried out as specified in <xref target="sequence-numbers"/>.
          </t>
        </list>
      </t>

    </section>

    <section anchor="tcprocessstart" title="Initial TC Message Processing">

      <t>
        The TC message is processed as follows:
        <list style="numbers">
          <t>
            The Advertising Remote Router Set is updated according to <xref target="tcprocesshistory"/>.
            If the TC message is indicated as discarded in that processing, then the following steps
            are not carried out.
          </t>
          <t>
            The Router Topology Set is updated according to <xref target="tcprocessrouter"/>.
          </t>
          <t>
            The Routable Address Topology Set is updated according to <xref target="tcprocessroutable"/>.
          </t>
          <t>
            The Attached Network Set is updated according to <xref target="tcprocessattached"/>.
          </t>
        </list>
      </t>

      <section anchor="tcprocesshistory" title="Populating the Advertising Remote Router Set">

        <t>
          The router MUST update its Advertising Remote Router Set as follows:
          <list style="numbers">

	        <t>
              If there is an Advertising Remote Router Tuple with:
              <list style="symbols">
	            <t>AR_orig_addr = message originator address; AND</t>
                <t>AR_seq_number &gt; received ANSN,</t>
	          </list>
	          then the TC message MUST be discarded.
	        </t>

            <t>
              Otherwise:

              <list style="numbers">

                <t>
                  If there is no Advertising Remote Router Tuple such that:
  	              <list style="symbols">
  	                <t>AR_orig_addr = message originator address;</t>
  	              </list>
                  then create an Advertising Remote Router Tuple with:
  	              <list style="symbols">
  	                <t>AR_orig_addr := message originator address.</t>
  	              </list>
                </t>

                <t>
                  This Advertising Remote Router Tuple (existing or new)
                  is then modified as follows:
  	              <list style="symbols">
  	                <t>AR_seq_number := received ANSN;</t>
  	                <t>AR_time       := current time + validity time.</t>
  	              </list>
  	            </t>

              </list>

            </t>

          </list>
        </t>
 
      </section>


      <section anchor="tcprocessrouter" title="Populating the Router Topology Set">

        <t>
          The router MUST update its Router Topology Set as follows:

	    <list style="numbers"> 

  	      <t>
              For each address (henceforth, advertised address) that
corresponds to one
              or more address objects with an associated Address Block TLV with
              Type = NBR_ADDR_TYPE and Value = ORIGINATOR or Value = ROUTABLE_ORIG
              and that is not partially owned by this router, perform the following
              processing:

	        <list style="numbers">

                <t>
                  If the associated metric is UNKNOWN_METRIC, then remove any
                  Router Topology Tuple such that:

		      <list style="symbols">
		        <t>TR_from_orig_addr = message originator address; AND</t>
		        <t>TR_to_orig_addr   = advertised address.</t>
		      </list>
                </t>

		    <t>
                  Otherwise, if there is no Router Topology Tuple such that:

		      <list style="symbols">
		        <t>TR_from_orig_addr = message originator address; AND</t>
		        <t>TR_to_orig_addr   = advertised address,</t>
		      </list>

	  	      then create a new Router Topology Tuple with:

		      <list style="symbols">
		        <t>TR_from_orig_addr := message originator address;</t>
		        <t>TR_to_orig_addr   := advertised address.</t>
                  </list>
                </t>

                <t>
                  This Router Topology Tuple (existing or new) is then modified as follows:
                  <list style="symbols">
		        <t>TR_seq_number := received ANSN;</t>
		        <t>TR_metric     := associated link metric;</t>
		        <t>TR_time       := current time + validity time.</t>
        	      </list>
		    </t>

              </list>

    	      </t>

	    </list>

        </t>

      </section>

      <section anchor="tcprocessroutable" title="Populating the Routable Address Topology Set">

        <t>
          The router MUST update its Routable Address Topology Set as follows:

	    <list style="numbers"> 

  	      <t>
              For each network address (henceforth, advertised address) that corresponds to
              one or more address objects with an associated Address Block TLV with
              Type = NBR_ADDR_TYPE and Value = ROUTABLE or Value = ROUTABLE_ORIG
              and that is not partially owned by this router, perform the following
              processing:

	        <list style="numbers">

                <t>
                  If the associated metric is UNKNOWN_METRIC, then remove any
                  Routable Address Topology Tuple such that:

		      <list style="symbols">
		        <t>TA_from_orig_addr = message originator address; AND</t>
		        <t>TA_dest_addr      = advertised address.</t>
		      </list>
                </t>

		    <t>
                  Otherwise, if there is no Routable Address Topology Tuple such that:

		      <list style="symbols">
		        <t>TA_from_orig_addr = message originator address; AND</t>
		        <t>TA_dest_addr      = advertised address,</t>
		      </list>

	  	      then create a new Routable Address Topology Tuple with:

		      <list style="symbols">
		        <t>TA_from_orig_addr := message originator address;</t>
		        <t>TA_dest_addr      := advertised address.</t>
                  </list>
                </t>

                <t>
                  This Routable Address Topology Tuple (existing or new) is then modified as follows:
                  <list style="symbols">
		        <t>TA_seq_number := received ANSN;</t>
		        <t>TA_metric     := associated link metric;</t>
		        <t>TA_time       := current time + validity time.</t>
        	      </list>
		    </t>

              </list>

    	      </t>

	    </list>

        </t>

      </section>

      <section anchor="tcprocessattached" title="Populating the Attached Network Set">

        <t>
          The router MUST update its Attached Network Set as follows:

          <list style="numbers">

  	      <t>
              For each network address (henceforth, attached address) that corresponds to one or more
              address objects with an associated Address Block TLV with Type = GATEWAY and that
              is not fully owned by this router, perform the following processing:

	        <list style="numbers">

                <t>
                  If the associated metric is UNKNOWN_METRIC, then remove any
                  Attached Network Tuple such that:

		      <list style="symbols">
		        <t>AN_net_addr  = attached address; AND</t>
		        <t>AN_orig_addr = message originator address.</t>
		      </list>
                </t>

		    <t>
                  Otherwise, if there is no Attached Network Tuple such that:

		      <list style="symbols">
		        <t>AN_net_addr  = attached address; AND</t>
		        <t>AN_orig_addr = message originator address,</t>
		      </list>

	  	      then create a new Attached Network Tuple with:

		      <list style="symbols">
		        <t>AN_net_addr  := attached address;</t>
		        <t>AN_orig_addr := message originator address.</t>
                  </list>

                </t>

                <t>
                  This Attached Network Tuple (existing or new) is then modified as follows:

                  <list style="symbols">
		        <t>AN_seq_number := received ANSN;</t>
                    <t>AN_dist       := the Value of the associated GATEWAY TLV;</t>
		        <t>AN_metric     := associated link metric;</t>
		        <t>AN_time       := current time + validity time.</t>
        	      </list>

		    </t>
  
	        </list>

 	      </t>

          </list>

        </t>

      </section>

    </section>

    <section anchor="tcprocessfinish" title="Completing TC Message Processing">

      <t>
        The TC message is processed as follows:
        <list style="numbers">
          <t>
            The Router Topology Set is updated according to <xref target="tcpurgerouter"/>.
          </t>
          <t>
            The Routable Address Topology Set is updated according to <xref target="tcpurgeroutable"/>.
          </t>
          <t>
            The Attached Network Set is updated according to <xref target="tcpurgeattached"/>.
          </t>
        </list>
      </t>
  
      <section anchor="tcpurgerouter" title="Purging the Router Topology Set">

        <t>
          The Router Topology Set MUST be updated as follows:
          <list style="numbers">
            <t>
              Any Router Topology Tuples with:
              <list style="symbols">
    	        <t>TR_from_orig_addr = message originator address; AND</t>
	            <t>TR_seq_number &lt; received ANSN,</t>
	          </list>
	          MUST be removed.
            </t>
          </list>
        </t>

      </section>

      <section anchor="tcpurgeroutable" title="Purging the Routable Address Topology Set">

        <t>
          The Routable Address Topology Set MUST be updated as follows:
          <list style="numbers">
            <t>
              Any Routable Address Topology Tuples with:
              <list style="symbols">
    	          <t>TA_from_orig_addr = message originator address; AND</t>
	          <t>TA_seq_number &lt; received ANSN,</t>
	        </list>
	        MUST be removed.
            </t>
          </list>
        </t>

      </section>

      <section anchor="tcpurgeattached" title="Purging the Attached Network Set">

        <t>
          The Attached Network Set MUST be updated as follows:
          <list style="numbers">
            <t>
              Any Attached Network Tuples with:
              <list style="symbols">
    	          <t>AN_orig_addr  = message originator address; AND</t>
	          <t>AN_seq_number &lt; received ANSN,</t>
	        </list>
	        MUST be removed.
            </t>
          </list>
        </t>

      </section>

    </section>

  </section>

</section>
<section anchor="base-changes" title="Information Base Changes">

  <t>
    The changes described in the following sections MUST be carried
    out when any Information Base changes as indicated.
  </t>

  <section anchor="originator-changes" title="Originator Address Changes">

    <t>
      If the router changes its originator address, then:
      <list style="numbers">
        <t>
          If there is no Originator Tuple with:
          <list style="symbols">
            <t>O_orig_addr = old originator address</t>
          </list>
          then create an Originator Tuple with:
          <list style="symbols">
            <t>O_orig_addr := old originator address</t>
          </list>
          The Originator Tuple (existing or new) with:
          <list style="symbols">
            <t>O_orig_addr = new originator address</t>
          </list>
          is then modified as follows:
          <list style="symbols">
            <t>O_time := current time + O_HOLD_TIME</t>
          </list>
        </t>
      </list>
    </t>

  </section>


  <section anchor="link-state-changes" title="Link State Changes">
  
    <t>
      The consistency of a Link Tuple MUST be maintained according to the following rules,
      in addition to those in <xref target="RFC6130"/>:
      <list style="symbols">
        <t>
          If L_status = HEARD or L_status = SYMMETRIC, then L_in_metric MUST be
          set (by a process outside this specification).
        </t>
        <t>
          If L_status != SYMMETRIC, then set L_mpr_selector := false.
        </t>
        <t>
          If L_out_metric = UNKNOWN_METRIC, then L_status MUST NOT equal SYMMETRIC;
          set L_SYM_time := EXPIRED if this would otherwise be the case.
        </t>
      </list>
    </t>
    
  </section>

  <section anchor="neighbor-changes" title="Neighbor State Changes">

    <t>
      The consistency of a Neighbor Tuple MUST be maintained according to the following rules,
      in addition to those in <xref target="RFC6130"/>:
      <list style="numbers">
        <t>
          If N_symmetric = true, then N_in_metric MUST equal the minimum value of all
          L_in_metric of corresponding Link Tuples with L_status = SYMMETRIC and
          L_in_metric != UNKNOWN_METRIC. If there are no such Link Tuples, then
          N_in_metric MUST equal UNKNOWN_METRIC.
        </t>
        <t>
          If N_symmetric = true, then N_out_metric MUST equal the minimum value of all
          L_out_metric of corresponding Link Tuples with L_status = SYMMETRIC and
          L_out_metric != UNKNOWN_METRIC. If there are no such Link Tuples, then
          N_out_metric MUST equal UNKNOWN_METRIC.
        </t>
        <t>
          If N_symmetric = false, then N_flooding_mpr, N_routing_mpr, N_mpr_selector, and
          N_advertised MUST all be equal to false.
        </t>
        <t>
          If N_mpr_selector = true, then N_advertised MUST be equal to true.
        </t>
        <t>
If N_symmetric = true, N_out_metric != UNKNOWN_METRIC and
       N_mpr_selector = false, then a router MAY select N_advertised =
       true or N_advertised = false.  The more neighbors that are
       advertised, the larger TC messages become, but the more
       redundancy is available for routing.  A router SHOULD consider
       the nature of its network in making such a decision and SHOULD
       avoid unnecessary changes in advertising status, which may result
       in unnecessary changes to routing.
        </t>
      </list>
    </t>

  </section>

  <section anchor="advertised-changes" title="Advertised Neighbor Changes">

    <t>
      The router MUST increment the ANSN in the Neighbor Information Base whenever:
      <list style="numbers">
        <t>
          Any Neighbor Tuple changes its N_advertised value, or any Neighbor Tuple with
          N_advertised = true is removed.
        </t>
        <t>
Any Neighbor Tuple with N_advertised = true changes its
       N_orig_addr or has any routable address added to or removed
       from N_neighbor_addr_list.
        </t>
        <t>
          Any Neighbor Tuple with N_advertised = true has N_out_metric changed.
        </t>
        <t>
          There is any change to the Local Attached Network Set.
        </t>
      </list>
    </t>

  </section>
  <section anchor="remote-expires" title="Advertising Remote Router Tuple Expires">

    <t>
      The Router Topology Set, the Routable Address Topology Set, and the
      Attached Network Set MUST be changed when an Advertising Remote Router Tuple
      expires (AR_time is reached). The following changes are required before the
      Advertising Remote Router Tuple is removed:
      <list style="numbers">
        <t>
          All Router Topology Tuples with:
          <list style="symbols">
            <t>TR_from_orig_addr = AR_orig_addr of the Advertising Remote Router Tuple</t>
          </list>
          are removed.
        </t>
        <t>
          All Routable Address Topology Tuples with:
          <list style="symbols">
            <t>TA_from_orig_addr = AR_orig_addr of the Advertising Remote Router Tuple</t>
          </list>
          are removed.
        </t>
        <t>
          All Attached Network Tuples with:
          <list style="symbols">
            <t>AN_orig_addr = AR_orig_addr of the Advertising Remote Router Tuple</t>
          </list>
          are removed.
        </t>
      </list>
    </t>

  </section>


  <section anchor="neighborhood-changes" title="Neighborhood Changes and MPR Updates">

    <t>
      The sets of symmetric 1-hop neighbors selected as flooding MPRs and routing MPRs
      MUST satisfy the conditions defined in <xref target="mpr-set-population"/>.
      To ensure this:

      <list style="numbers">

        <t>
          The set of flooding MPRs of a router MUST be recalculated if:
          <list style="symbols">
            <t>
              A Link Tuple is added with L_status = SYMMETRIC and
              L_out_metric != UNKNOWN_METRIC; OR
            </t>
            <t>
              A Link Tuple with L_status = SYMMETRIC and
              L_out_metric != UNKNOWN_METRIC is removed; OR
            </t>
            <t>
              A Link Tuple with L_status = SYMMETRIC and L_out_metric != UNKNOWN_METRIC
              changes to having L_status = HEARD, L_status = LOST, or
              L_out_metric = UNKNOWN_METRIC; OR
            </t>
            <t>
              A Link Tuple with L_status = HEARD or L_status = LOST
              changes to having L_status = SYMMETRIC and
              L_out_metric != UNKNOWN_METRIC; OR
            </t>
            <t>
              The flooding MPR selection process uses metric values (see
              <xref target="flooding-mprs"/>) and the L_out_metric of any
              Link Tuple with L_status = SYMMETRIC changes; OR
            </t>
            <t>
              The N_will_flooding of a Neighbor Tuple with N_symmetric = true
              and N_out_metric != UNKNOWN_METRIC changes from WILL_NEVER
              to any other value; OR
            </t>
            <t>
              The N_will_flooding of a Neighbor Tuple with N_flooding_mpr = true
              changes to WILL_NEVER from any other value; OR
            </t>
            <t>
              The N_will_flooding of a Neighbor Tuple with N_symmetric = true,
              N_out_metric != UNKNOWN_METRIC, and N_flooding_mpr = false
              changes to WILL_ALWAYS from any other value; OR
            </t>
            <t>
              A 2-Hop Tuple with N2_out_metric != UNKNOWN_METRIC
              is added or removed; OR
            </t>
            <t>
The N2_out_metric of any 2-Hop Tuple changes and either
           the flooding MPR selection process uses metric values (see
           <xref target="flooding-mprs"/>) or the change is to or from UNKNOWN_METRIC.
            </t>
          </list>
        </t>

        <t>
          Otherwise, the set of flooding MPRs of a router MAY be recalculated if the
          N_will_flooding of a Neighbor Tuple with N_symmetric = true
          changes in any other way; it SHOULD be recalculated if N_flooding_mpr = false
          and this is an increase in N_will_flooding or if N_flooding_mpr = true and
          this is a decrease in N_will_flooding.
        </t>

        <t>
          The set of routing MPRs of a router MUST be recalculated if:
          <list style="symbols">
            <t>
              A Neighbor Tuple is added with N_symmetric = true and
              N_in_metric != UNKNOWN_METRIC; OR
            </t>
            <t>
              A Neighbor Tuple with N_symmetric = true and N_in_metric != UNKNOWN_METRIC
              is removed; OR
            </t>
            <t>
              A Neighbor Tuple with N_symmetric = true and N_in_metric != UNKNOWN_METRIC
              changes to having N_symmetric = false; OR
            </t>
            <t>
              A Neighbor Tuple with N_symmetric = false changes to having
              N_symmetric = true and N_in_metric != UNKNOWN_METRIC; OR
            </t>
            <t>
              The N_in_metric of any Neighbor Tuple with N_symmetric = true changes; OR
            </t>
            <t>
              The N_will_routing of a Neighbor Tuple with N_symmetric = true
              and N_in_metric != UNKNOWN_METRIC changes from WILL_NEVER
              to any other value; OR
            </t>
            <t>
              The N_will_routing of a Neighbor Tuple with N_routing_mpr = true changes
              to WILL_NEVER from any other value; OR
            </t>
            <t>
              The N_will_routing of a Neighbor Tuple with N_symmetric = true,
              N_in_metric != UNKNOWN_METRIC and N_routing_mpr = false
              changes to WILL_ALWAYS from any other value; OR
            </t>
             <t>
              A 2-Hop Tuple with N2_in_metric != UNKNOWN_METRIC is added or removed; OR
            </t>
            <t>
              The N2_in_metric of any 2-Hop Tuple changes.
            </t>
          </list>
        </t>
        <t>
          Otherwise, the set of routing MPRs of a router MAY be recalculated if the
          N_will_routing of a Neighbor Tuple with N_symmetric = true
          changes in any other way; it SHOULD be recalculated if N_routing_mpr = false
          and this is an increase in N_will_routing or if N_routing_mpr = true and
          this is a decrease in N_will_routing.
        </t>
      </list>

    </t>

    <t>
      If either set of MPRs of a router is recalculated, this MUST be as described in
      <xref target ="mpr-set-population"/>.
    </t>

  </section>

  <section anchor="routing-changes" title="Routing Set Updates">

    <t>
      The Routing Set MUST be updated, as described in <xref target="routing-table"/>,
      when changes in the Local Information Base, the Neighborhood Information Base,
      or the Topology Information Base indicate a change (including of any potentially
      used outgoing neighbor metric values) of the known symmetric links and/or
      attached networks in the MANET, hence changing the Topology Graph. It is sufficient
      to consider only changes that affect at least one of:
      <list style="symbols">
        <t>
          The Local Interface Set for an OLSRv2 interface, if the change removes any
          network address in an I_local_iface_addr_list. In this case, unless the
          OLSRv2 interface is removed, it may not be necessary to do more than
          replace such network addresses, if used, by an alternative network address
          from the same I_local_iface_addr_list.
        </t>
        <t>
          The Local Attached Set, if the change removes any
          AL_net_addr that is also an AN_net_addr. In this case, it
          may not be necessary to do more than add Routing Tuples
          with R_dest_addr equal to that AN_net_addr.
        </t>
        <t>
          The Link Set of any OLSRv2 interface, considering only Link Tuples that have,
          or just had, L_status = SYMMETRIC and L_out_metric != UNKNOWN_METRIC
          (including removal of such Link Tuples).
        </t>
        <t>
          The Neighbor Set of the router, considering only Neighbor Tuples that have,
          or just had, N_symmetric = true and N_out_metric != UNKNOWN_METRIC and do not
          have N_orig_addr = unknown.
        </t>
        <t>
          The 2-Hop Set of any OLSRv2 interface, if used in the creation
          of the Routing Set and if the change affects any 2-Hop Tuples with
          N2_out_metric != UNKNOWN_METRIC.
        </t>
        <t>
          The Router Topology Set of the router.
        </t>
        <t>
          The Routable Address Topology Set of the router.
        </t>
        <t>
          The Attached Network Set of the router.
        </t>
      </list>
    </t>

  </section>

</section>
<section anchor="mpr-set-population" title="Selecting MPRs">

  <t>
    Each router MUST select, from among its willing symmetric 1-hop neighbors,
    two subsets of these routers, as flooding and routing MPRs. This selection
    is recorded in the router's Neighbor Set and reported in the router's
    HELLO messages. Routers MAY select their MPRs by any process that satisfies
    the conditions that follow, which may, but need not, use the organization
    of the data described. Routers can freely interoperate whether they use the
    same or different MPR selection algorithms.
  </t>

  <t>
    Only flooding MPRs forward control messages flooded through the MANET,
    thus effecting a flooding reduction, an optimization of the
    flooding mechanism, known as MPR flooding. Routing MPRs are used to
    effect a topology reduction in the MANET. (If no such reduction is
    required, then a router can select all of its relevant neighbors as
    routing MPRs.) Consequently, while it is not essential that these two
    sets of MPRs are minimal, keeping the numbers of MPRs small ensures
    that the overhead of this protocol is kept to a minimum.
  </t>

  <section title="Overview">

    <t>
      MPRs are selected according to the following steps, defined in the
      following sections:
      <list style="symbols">
        <t>
          A data structure known as a Neighbor Graph is defined.
        </t>
        <t>
          The properties of an MPR Set derived from a Neighbor Graph
          are defined. Any algorithm that creates an MPR Set that
          satisfies these properties is a valid MPR selection algorithm.
          An example algorithm that creates such an MPR Set is given in
          <xref target="mprcalc"/>.
        </t>
        <t>
          How to create a Neighbor Graph for each interface based on
          the corresponding Interface Information Base is defined, and
          how to combine the resulting MPR Sets to determine the router's
          flooding MPRs and record those in the router's Neighbor Set are described.
        </t>
        <t>
          How to create a single Neighbor Graph based on all Interface
          Information Bases and the Neighbor Information Base is defined,
          and how to record the resulting MPR Set as the router's routing
          MPRs in the router's Neighbor Set is described.
        </t>
        <t>
          A specification as to when MPRs MUST be calculated is given.
        </t>
      </list>
    </t>

    <t>
      When a router selects its MPRs, it MAY consider any characteristics
      of its neighbors that it is aware of. In particular, it SHOULD consider the
      willingness of the neighbor, as recorded by the corresponding N_will_flooding
      or N_will_routing value, as appropriate, preferring neighbors with higher
      values. (Note that willingness values equal to WILL_NEVER and WILL_ALWAYS
      are always considered, as described.) However, a router MAY consider other
      characteristics to have a greater significance.
    </t>

    <t>
      Each router MAY select its flooding and routing MPRs independently
      of each other or coordinate its selections. A router MAY make its
      MPR selections independently of the MPR selection by other routers,
      or it MAY, for example, give preference to routers that either are,
      or are not, already selected as MPRs by other routers.
    </t>

  </section>

  <section anchor="neighbor-graph" title="Neighbor Graph">

    <t>
      A Neighbor Graph is a structure defined here as consisting of sets N1 and
      N2 and some associated metric and willingness values. Elements of set N1
      represent willing symmetric 1-hop neighbors, and elements of set N2 represent
      addresses of a symmetric 2-hop neighbor.
    </t>

    <t>
      A Neighbor Graph has the following properties:
      <list style="symbols">
        <t>
          It contains two disjoint sets N1 and N2.
        </t>
        <t>
          For each element x in N1, there is an associated willingness value W(x)
          such that WILL_NEVER &lt; W(x) &lt;= WILL_ALWAYS.
        </t>
        <t>
          For each element x in N1, there is an associated metric d1(x) &gt; 0.
        </t>
        <t>
          For some elements y in N2, there is an associated metric d1(y) &gt; 0.
          (Other elements y in N2 have undefined d1(y); this may be considered
          to be infinite.)
        </t>
        <t>
          For each element x in N1, there is a subset N2(x) of elements of N2;
          this subset may be empty. For each x in N1 and each y in N2(x), there
          is an associated metric d2(x,y) &gt; 0. (For other x in N1 and y in N2,
          d2(x,y) is undefined and may be considered infinite.)
        </t>
        <t>
          N2 is equal to the union of all the N2(x) for all x in N1, i.e.,
          for each y in N2, there is at least one x in N1 such that y is
          in N2(x).
        </t>
      </list>
    </t>

    <t>
      It is convenient to also define:
      <list style="symbols">
        <t>
          For each y in N2, the set N1(y) that contains x in N1 if and only if
          y is in N2(x). From the final property above, N1(y) is not empty.
        </t>
        <t>
          For each x in N1 and y in N2, if d2(x,y) is defined, then
          d(x,y) := d1(x)+d2(x,y); otherwise, d(x,y) is not defined.
          (Thus, d(x,y) is defined if y is in N2(x) or, equivalently,
          if x is in N1(y).)
        </t>
        <t>
          For any subset S of N1 and for each y in N2, the metric d(y,S) is the
          minimum value of d1(y), if defined, and of all d(x,y) for x in
          N1(y) and in S.&nbsp; If there are no such metrics to take the minimum value
          of, then d(y,S) is undefined (may be considered to be infinite). From
          the final property above, d(y,N1) is defined for all y.
        </t>
      </list>
    </t>

  </section>

  <section anchor="mpr-properties" title="MPR Properties">

    <t>
      Given a Neighbor Graph as defined in <xref target="neighbor-graph"/>,
      an MPR Set for that Neighbor Graph is a subset M of the set N1 that
      satisfies the following properties:
      <list style="symbols">
        <t>
          If x in N1 has W(x) = WILL_ALWAYS, then x is in M.
        </t>
        <t>
          For any y in N2 that does not have a defined d1(y), there is at
          least one element in M that is also in N1(y). This is
          equivalent to the requirement that d(y,M) is defined.
        </t>
        <t>
          For any y in N2, d(y,M) = d(y,N1).
        </t>
      </list>
    </t>

    <t>
   These properties reflect that the MPR Set consists of
   a set of symmetric 1-hop neighbors that cover all the symmetric 2-hop
   neighbors and that they do so retaining a minimum distance
   route (1-hop, if present, or 2-hop) to each symmetric 2-hop neighbor.
    </t>

    <t>
      Note that if M is an MPR Set, then so is any subset of N1 that contains
      M; also note that N1 is always an MPR Set.&nbsp; An MPR Set may be empty but
      cannot be empty if N2 contains any elements y that do not have a defined
      d1(y).
    </t>

  </section>

  <section anchor="flooding-mprs" title="Flooding MPRs">

    <t>
      Whenever flooding MPRs are to be calculated, an implementation MUST
      determine and record a set of flooding MPRs that is equivalent to one
      calculated as described in this section.
    </t>

    <t>
      The calculation of flooding MPRs need not use link metrics or, equivalently,
      may use link metrics with a fixed value, here taken to be 1. However, links
      with unknown metric (L_out_metric = UNKNOWN_METRIC) MUST NOT be used even
      if link metrics are otherwise not used.
    </t>

    <t>
      Routers MAY make individual decisions as to whether to use link metrics for
      the calculation of flooding MPRs. A router MUST use the same approach to the
      choice of whether to use link metrics for all links, i.e., in the cases
      indicated by A or B, the same choice MUST be made in each case.
    </t>

    <t>
      For each OLSRv2 interface (the "current interface"), define a Neighbor
      Graph as defined in <xref target="neighbor-graph"/> according to the
      following:
      <list style="symbols">
        <t>
          Define a reachable Link Tuple to be a Link Tuple in the Link Set
          for the current interface with L_status = SYMMETRIC and
          L_out_metric != UNKNOWN_METRIC.
        </t>
        <t>
          Define an allowed Link Tuple to be a reachable Link Tuple whose
          corresponding Neighbor Tuple has N_will_flooding &gt; WILL_NEVER.
        </t>
        <t>
          Define an allowed 2-Hop Tuple to be a 2-Hop Tuple in the 2-Hop Set
          for the current interface for which N2_out_metric != UNKNOWN_METRIC
          and there is an allowed Link Tuple with
          L_neighbor_iface_addr_list = N2_neighbor_iface_addr_list.
        </t>
        <t>
          Define an element of N1 for each allowed Link Tuple. This then
          defines the corresponding Link Tuple for each element of N1 and
          the corresponding Neighbor Tuple for each element of N1, being the
          Neighbor Tuple corresponding to that Link Tuple.
        </t>
        <t>
          For each element x in N1, define W(x) := N_will_flooding of the
          corresponding Neighbor Tuple.
        </t>
        <t>
          For each element x in N1, define d1(x) as either:
          <list style="letters">
            <t>L_out_metric of the corresponding Link Tuple; OR</t>
            <t>1.</t>
          </list>
        </t>
        <t>
          Define an element of N2 for each network address that is the
          N2_2hop_addr of one or more allowed 2-Hop Tuples. This then
          defines the corresponding address for each element of N2.
        </t>
        <t>
          For each element y in N2, if the corresponding address is in
          the N_neighbor_addr_list of a Neighbor Tuple that corresponds
          to one or more reachable Link Tuples, then define d1(y) as
          either:
          <list style="letters">
            <t>the minimum value of the L_out_metric of those Link Tuples; OR</t>
            <t>1.</t>
          </list>
          Otherwise, d1(y) is not defined. In the latter case, where d1(y) := 1,
          all such y in N2 may instead be removed from N2.
        </t>
        <t>
          For each element x in N1, define N2(x) as the set of elements
          y in N2 whose corresponding address is the N2_2hop_addr of an
          allowed 2-Hop Tuple that has
          N2_neighbor_iface_addr_list = L_neighbor_iface_addr_list
          of the Link Tuple corresponding to x.  For all such x and y,
          define d2(x,y) as either:
          <list style="letters">
            <t>N2_out_metric of that 2-Hop Tuple; OR</t>
            <t>1.</t>
          </list>
        </t>
      </list>
    </t>

    <t>
      It is up to an implementation to decide how to label each element of N1
      or N2. For example, an element of N1 may be labeled with one or more
      addresses from the corresponding L_neighbor_iface_addr_list or with
      a pointer or reference to the corresponding Link Tuple.
    </t>

    <t>
      Using these Neighbor Graphs, flooding MPRs are selected and recorded by:
      <list style="symbols">
        <t>
          For each OLSRv2 interface, determine an MPR Set as specified in
          <xref target="mpr-properties"/>.
        </t>
        <t>
          A Neighbor Tuple represents a flooding MPR and has
          N_flooding_mpr := true (otherwise, N_flooding_mpr := false) if and only
          if that Neighbor Tuple corresponds to an element in an MPR Set created
          for any interface as described above. That is, the overall set of
          flooding MPRs is the union of the sets of flooding MPRs for all OLSRv2
          interfaces.
        </t>
      </list>
    </t>

    <t>
      A router MAY select its flooding MPRs for each OLSRv2 interface
      independently, or it MAY coordinate its MPR selections across its
      OLSRv2 interfaces, as long as the required condition is satisfied
      for each OLSRv2 interface. One such coordinated approach is to
      process the OLSRv2 interfaces sequentially and, for each OLSRv2
      interface, start with flooding MPRs selected (and not removable)
      if the neighbor has been already selected as an MPR for an
      OLSRv2 interface that has already been processed. The algorithm
      specified in <xref target="mprcalc"/> can be used in this way.
    </t>

  </section>

  <section title="Routing MPRs">

    <t>
      Whenever routing MPRs are to be calculated, an implementation MUST
      determine and record a set of routing MPRs that is equivalent to one
      calculated as described in this section.
    </t>

    <t>
      Define a single Neighbor Graph as defined in <xref target="neighbor-graph"/>
      according to the following:
      <list style="symbols">
        <t>
          Define a reachable Neighbor Tuple to be a Neighbor Tuple with
          N_symmetric = true and N_in_metric != UNKNOWN_METRIC.
        </t>
        <t>
          Define an allowed Neighbor Tuple to be a reachable Neighbor Tuple
          with N_will_routing &gt; WILL_NEVER.
        </t>
        <t>
          Define an allowed 2-Hop Tuple to be a 2-Hop Tuple in the 2-Hop Set
          for any OLSRv2 interface with N2_in_metric != UNKNOWN_METRIC and
          for which there is an allowed Neighbor Tuple with N_neighbor_addr_list
          containing N2_neighbor_iface_addr_list.
        </t>
        <t>
          Define an element of N1 for each allowed Neighbor Tuple. This then
          defines the corresponding Neighbor Tuple for each element of N1.
        </t>
        <t>
          For each element x in N1, define W(x) := N_will_routing of the
          corresponding Neighbor Tuple.
        </t>
        <t>
          For each element x in N1, define d1(x) := N_in_metric of the
          corresponding Neighbor Tuple.
        </t>
        <t>
          Define an element of N2 for each network address that is the
          N2_2hop_addr of one or more allowed 2-Hop Tuples. This then
          defines the corresponding address for each element of N2.
        </t>
        <t>
          For each element y in N2, if the corresponding address is in
          the N_neighbor_addr_list of a reachable Neighbor Tuple, then
          define d1(y) to be the N_in_metric of that Neighbor Tuple;
          otherwise, d1(y) is not defined.
        </t>
        <t>
          For each element x in N1, define N2(x) as the set of elements
          y in N2 whose corresponding address is the N2_2hop_addr of an
          allowed 2-Hop Tuple that has N2_neighbor_iface_addr_list
          contained in N_neighbor_addr_list of the Neighbor Tuple
          corresponding to x. &nbsp;For all such x and y, define
          d2(x,y) := N2_out_metric of that 2-Hop Tuple.
        </t>
      </list>
    </t>

    <t>
      It is up to an implementation to decide how to label each element of N1
      or N2. For example, an element of N1 may be labeled with one or more
      addresses from the corresponding N_neighbor_addr_list or with
      a pointer or reference to the corresponding Neighbor Tuple.
    </t>

    <t>
      Using these Neighbor Graphs, routing MPRs are selected and recorded according to the following:
      <list style="symbols">
        <t>
          Determine an MPR Set as specified in <xref target="mpr-properties"/>.
        </t>
        <t>
          A Neighbor Tuple represents a routing MPR and has
          N_routing_mpr := true (otherwise, N_routing_mpr := false) if and only
          if that Neighbor Tuple corresponds to an element in the MPR Set created
          as described above.
        </t>
      </list>
    </t>

  </section>

  <section title="Calculating MPRs">

    <t>
      A router MUST recalculate each of its sets of MPRs whenever the currently
      selected set of MPRs does not still satisfy the required conditions. It
      MAY recalculate its MPRs if the current set of MPRs is still valid but
      could be more efficient. Sufficient conditions to recalculate a router's
      sets of MPRs are given in <xref target="neighborhood-changes"/>.
    </t>

  </section>

</section>
<section anchor="routing-table" title="Routing Set Calculation">
  
  <t>
    The Routing Set of a router is populated with Routing Tuples that
    represent paths from that router to all destinations in the network.
    These paths are calculated based on the Network Topology Graph,
    which is constructed from information in the Information
    Bases, obtained via HELLO and TC message exchange.
  </t>
      
  <t>
    Changes to the Routing Set do not require any messages to be transmitted.
    The state of the Routing Set SHOULD, however, be reflected in the IP routing
    table by adding and removing entries from that routing table as appropriate.
    Only appropriate Routing Tuples (in particular only those that represent
    local links or paths to routable addresses) need be reflected in the IP
    routing table.
  </t>

  <section anchor="topologygraph" title="Network Topology Graph">

    <t>
      The Network Topology Graph is formed from information from
      the router's Local Interface Set, Link Sets for OLSRv2 interfaces,
      Neighbor Set, Router Topology Set, Routable Address Topology Set,
      and Attached Network Set.&nbsp; The Network Topology Graph MAY also
      use information from the router's 2-Hop Sets for OLSRv2 interfaces.
      The Network Topology Graph forms the router's topological view of
      the network in the form of a directed graph. Each edge in that graph
      has a metric value. The Network Topology Graph has a "backbone"
      (within which minimum total metric routes will be constructed)
      containing the following edges:

      <list style="symbols">

        <t>
          Edges X -> Y for all possible Y, and one X per Y, such that:
          <list style="symbols">
            <t>
              Y is the N_orig_addr of a Neighbor Tuple; AND
            </t>
            <t>
              N_orig_addr is not unknown; AND
            </t>
            <t>
              X is in the I_local_iface_addr_list of a Local Interface Tuple; AND
            </t>
            <t>
              There is a Link Tuple with L_status = SYMMETRIC and L_out_metric != UNKNOWN_METRIC
              such that this Neighbor Tuple and this Local Interface Tuple correspond to it.
              A network address from L_neighbor_iface_addr_list will be denoted R in
              this case.
            </t>
          </list>
      It SHOULD be preferred, where possible, to select R = Y and to select X
from
      the Local Interface Tuple corresponding to the Link Tuple from
      which R was selected.  The metric for such an edge is the
      corresponding N_out_metric.
        </t>

        <t>
          All edges W -> U such that:
          <list style="symbols">
            <t>
              W is the TR_from_orig_addr of a Router Topology Tuple; AND
            </t>
            <t>
              U is the TR_to_orig_addr of the same Router Topology Tuple.
            </t>
          </list>
          The metric of such an edge is the corresponding TR_metric.
        </t>

      </list>

      The Network Topology Graph is further "decorated" with the following
      edges. If a network address S, V, Z, or T equals a network address Y or W,
      then the edge terminating in the network address S, V, Z, or T MUST NOT
      be used in any path.

      <list style="symbols">

        <t>
          Edges X -> S for all possible S, and one X per S, such that:
          <list style="symbols">
            <t>
              S is in the N_neighbor_addr_list of a Neighbor Tuple; AND
            </t>
            <t>
              X is in the I_local_iface_addr_list of a Local Interface Tuple; AND
            </t>
            <t>
              There is a Link Tuple with L_status = SYMMETRIC and L_out_metric != UNKNOWN_METRIC
              such that this Neighbor Tuple and this Local Interface Tuple correspond to it.
              A network address from L_neighbor_iface_addr_list will be denoted
              R in this case.
            </t>
          </list>
      It SHOULD be preferred, where possible, to select R = S and to select
X from
      the Local Interface Tuple corresponding to the Link Tuple from
      which R was selected.  The metric for such an edge is the
      corresponding N_out_metric.
        </t>

        <t>
          All edges W -> V such that:
          <list style="symbols">
            <t>
              W is the TA_from_orig_addr of a Routable Address Topology Tuple; AND
            </t>
            <t>
              V is the TA_dest_addr of the same Routable Address Topology Tuple.
            </t>
          </list>
          The metric for such an edge is the corresponding TA_metric.
        </t>

        <t>
          All edges W -> T such that:
          <list style="symbols">
            <t>
              W is the AN_orig_addr of an Attached Network Tuple; AND
            </t>
            <t>
              T is the AN_net_addr of the same Attached Network Tuple.
            </t>
          </list>
          The metric for such an edge is the corresponding AN_metric.
        </t>

        <t>
          (OPTIONAL) All edges Y -> Z such that:
          <list style="symbols">
            <t>
              Z is a routable address and is the N2_2hop_addr of a 2-Hop Tuple
              with N2_out_metric != UNKNOWN_METRIC; AND
            </t>
            <t>
              Y is the N_orig_addr of the corresponding Neighbor Tuple; AND
            </t>
            <t>
              This Neighbor Tuple has N_will_routing not equal to WILL_NEVER.
            </t>
          </list>
          A path terminating with such an edge MUST NOT be used in preference
          to any other path. The metric for such an edge is the corresponding
          N2_out_metric.
        </t>

      </list>

    </t>

    <t>
      Any part of the Topology Graph that is not connected to a local network address
      X is not used. Only one selection X SHOULD be made from each I_local_iface_addr_list,
      and only one selection R SHOULD be made from any L_neighbor_iface_addr_list.
      All edges have a hop count of 1, except edges W -> T that have a hop count of the
      corresponding value of AN_dist.
    </t>

  </section>

  <section title="Populating the Routing Set">

    <t>
      The Routing Set MUST contain the shortest paths for all destinations
	from all local OLSRv2 interfaces using the Network Topology Graph.
	This calculation MAY use any algorithm, including any means of choosing
	between paths of equal total metric. (In the case of two paths of equal
      total metric but differing hop counts, the path with the lower hop
      count SHOULD be used.)
    </t>

    <t>
      Using the notation of <xref target="topologygraph"/>, initially "backbone" paths
      using only edges X -> Y and W -> U need be constructed (using a minimum distance
      algorithm). Then paths using only a final edge of the other types may be added.
      These MUST NOT replace backbone paths with the same destination (and paths
      terminating in an edge Y -> Z SHOULD NOT replace paths with any other form of
      terminating edge).
    </t>

    <t>
      Each path will correspond to a Routing Tuple. These will be of two types.
      The first type will represent single edge paths, of type X -> S or X -> Y,
      by:
      <list style="symbols">
        <t>R_local_iface_addr := X;</t>
        <t>R_next_iface_addr  := R;</t>
        <t>R_dest_addr        := S or Y;</t>
        <t>R_dist             := 1;</t>
        <t>R_metric           := edge metric,</t>
      </list>
      where R is as defined in <xref target="topologygraph"/> for these types
      of edge.
    </t>

    <t>
      The second type will represent a multiple edge path, which will always have first edge
      of type X -> Y, and will have final edge of type W -> U, W -> V, W -> T, or Y -> Z.
      The Routing Tuple will be:
      <list style="symbols">
        <t>R_local_iface_addr := X; </t>
        <t>R_next_iface_addr  := Y;</t>
        <t>R_dest_addr        := U, V, T or Z;</t>
        <t>R_dist             := the total hop count of all edges in the path;</t>
        <t>R_metric           := the total metric of all edges in the path.</t>
      </list>
    </t>

    <t>
      Finally, Routing Tuples of the second type whose R_dest_addr is not routable
      MAY be discarded.
    </t>

    <t>
      An example algorithm for calculating the Routing Set of a router is given
      in <xref target="rs-algo"/>.
    </t>

  </section>

</section>
<section anchor="constants" title="Proposed Values for Parameters">

  <t>
    This protocol uses all parameters defined in <xref target="RFC6130"/>
    and additional parameters defined in this specification. All but
    one (RX_HOLD_TIME) of these additional parameters are router parameters as
    defined in <xref target="RFC6130"/>. The proposed values of the additional
    parameters defined in the following sections are appropriate to the case
    where all parameters (including those defined in <xref target="RFC6130"/>)
    have a single value. Proposed values for parameters defined in
    <xref target="RFC6130"/> are given in that specification.
  </t>

  <t>
    The following proposed values are based on experience with <xref target="RFC3626"/>
    deployments (such as documented in <xref target="McCabe"/>) and are considered
    typical. They can be changed to accommodate different deployment requirements
    -- for example, a network with capacity-limited network interfaces would be expected
    to use greater values for message intervals, whereas a highly mobile network would
    be expected to use lower values for message intervals. When determining these values,
    the constraints specified in <xref target="parameters"/> MUST be respected.
  </t>
	<t>
		Note that routers in a MANET need not all use the same set of parameters, and those parameters that are indicated as interface parameters need not be the same on all OLSRv2 interfaces of a single router.
	</t>
	

  <section title="Local History Time Parameters">
  
    <t>
      <list style="symbols">
	  <t>O_HOLD_TIME             := 30 seconds</t>
      </list>
    </t>

  </section>

  <section title="Message Interval Parameters">
  
    <t>
      <list style="symbols">
	  <t>TC_INTERVAL             := 5 seconds</t>
	  <t>TC_MIN_INTERVAL         := TC_INTERVAL/4</t>
      </list>
    </t>

  </section>

  <section title="Advertised Information Validity Time Parameters">

    <t>
      <list style="symbols">
        <t>T_HOLD_TIME             := 3 x TC_INTERVAL</t>
        <t>A_HOLD_TIME             := T_HOLD_TIME</t>
      </list>
    </t>

  </section>

  <section title="Received Message Validity Time Parameters">

    <t>
      <list style="symbols">
	  <t>RX_HOLD_TIME            := 30 seconds</t>
	  <t>P_HOLD_TIME             := 30 seconds</t>
	  <t>F_HOLD_TIME             := 30 seconds</t>
      </list>
    </t>

  </section>

  <section title="Jitter Time Parameters">

    <t>
      <list style="symbols">
        <t>TP_MAXJITTER          := HP_MAXJITTER</t>
        <t>TT_MAXJITTER          := HT_MAXJITTER</t>
        <t>F_MAXJITTER           := TT_MAXJITTER</t>
      </list>
    </t>

  </section>

  <section title="Hop Limit Parameter">

    <t>
      <list style="symbols">
        <t>TC_HOP_LIMIT          := 255</t>
      </list>
    </t>

  </section>

  <section title="Willingness Parameters">

    <t>
      <list style="symbols">
        <t>WILL_FLOODING         := WILL_DEFAULT</t>
        <t>WILL_ROUTING          := WILL_DEFAULT</t>
      </list>
    </t>

  </section>

</section>
<section anchor="sequence-numbers" title="Sequence Numbers">

  <t>
    Sequence numbers are used in this specification for the purpose of
    discarding "old" information, i.e., messages received out of order.
    However, with a limited number of bits for representing sequence numbers,
    wraparound (in which the sequence number is incremented from the maximum
    possible value to zero) will occur. To prevent this from interfering
    with the operation of this protocol, the following MUST be observed when
    determining the ordering of sequence numbers.
  </t>

  <t>
    The term MAXVALUE designates in the following one more than
    the largest possible value for a sequence number. For a 16-bit sequence
number (like those defined in this specification),
    MAXVALUE is 65536.
  </t>

  <t>
    The sequence number S1 is said to be "greater than" the sequence
    number S2 if:
    <list style="symbols">
      <t> S1 &gt; S2 AND S1 - S2 &lt; MAXVALUE/2, OR</t>
      <t> S2 &gt; S1 AND S2 - S1 &gt; MAXVALUE/2</t>
    </list>
  </t>

  <t>
    When sequence numbers S1 and S2 differ by MAXVALUE/2, their ordering
    cannot be determined. In this case, which should not occur, either
    ordering may be assumed.
  </t>

  <t>
    Thus, when comparing two messages, it is possible -- even in the
    presence of wraparound -- to determine which message contains the
    most recent information.
  </t>

</section>
<section title="Extensions" anchor="extensions">

  <t>
    An extension to this protocol will need to interact with this specification
    and possibly also with <xref target="RFC6130"/>. This protocol is designed to
    permit such interactions, in particular:

    <list style="symbols">

      <t>
        Through accessing, and possibly extending, the information in the
        Information Bases. All updates to the elements specified in this
        specification are subject to the normative constraints specified in
        <xref target="RFC6130"/> and <xref target="constraints"/>. &nbsp;Note that
        the processing specified in this document ensures that these
        constraints are satisfied.
      </t>
      
      <t>
        Through accessing an outgoing message prior to it being
        transmitted over any OLSRv2 interface and adding information
        to it as specified in <xref target="RFC5444"/>. This MAY
        include Message TLVs and/or network addresses with associated
        Address Block TLVs. (Network addresses without new associated
        TLVs SHOULD NOT be added to messages.) This may, for example,
        be to allow a security protocol, as suggested in
        <xref target="security"/>, to add a TLV containing a
        cryptographic signature to the message.
      </t>

      <t>
        Through accessing an incoming message and potentially discarding
        it prior to processing by this protocol. This may, for example,
        allow a security protocol, as suggested in <xref target="security"/>,
        to perform verification of message signatures and prevent
        processing and/or forwarding of unverifiable messages by this
        protocol.
      </t>

      <t>
        Through accessing an incoming message after it has been completely
        processed by this protocol. In particular, this may allow a protocol
        that has added information, by way of inclusion of appropriate TLVs
        or of network addresses associated with new TLVs, access to such information
        after appropriate updates have been recorded in the Information Bases
        in this protocol.
      </t>

      <t>
        Through requesting that a message be generated at a specific time.
        In that case, message generation MUST still respect the constraints
        in <xref target="RFC6130"/> and <xref target="intervals"/>.
      </t>

    </list>

  </t>

</section>
<section anchor="security" title="Security Considerations">

  <t>
    As a proactive routing protocol, OLSRv2 is a potential target for various attacks. 
    This section presents the envisioned security architecture for OLSRv2 and gives guidelines
    on how to provide integrity, confidentiality, and integration into external routing domains.
    Separately specified mandatory security mechanisms are summarized, and some observations on
    key management are given.
  </t>

  <section anchor="security_architecture" title="Security Architecture">

    <t>
      OLSRv2 integrates into the architecture specified in Appendix A of <xref target="RFC5444"/>,
      in <xref target="RFC5498"/>, and in Section 16 of <xref target="RFC6130"/>,
      the latter by using and extending its messages and Information Bases.
    </t>

    <t>
      As part of this architecture, OLSRv2 and NHDP <xref target="RFC6130"/> recognize that there may be external
      reasons for rejecting messages that would be considered "badly formed" or "insecure",
      e.g., if an Integrity Check Value (ICV) included in a message by an external mechanism cannot be
      verified. This architecture allows options as to whether and how to implement security
      features, reflecting  the situation that MANET routing protocol deployment domains have
      varying security requirements, ranging from "practically unbreakable" to "virtually none".
      This approach allows MANET routing protocol specifications to remain generic, with
      extensions to them and/or extensions to the multiplexing and demultiplexing process
      described in Appendix A of <xref target="RFC5444"/>, providing security mechanisms
      appropriate to a given deployment domain.
    </t>

    <t>
      The following sections provide guidelines on how to provide integrity, confidentiality, and
      integration with external routing domains in such extensions.
    </t>

  </section>

  <section anchor="integrity" title="Integrity">

    <t>
      Each router injects topological information into the network by transmitting HELLO messages
      and, for some routers, also TC messages. If some routers for some reason (malice or malfunction)
      inject invalid control traffic, network integrity may be compromised. Therefore, message,
      or packet, authentication is strongly advised.
    </t>

    <t>
      Different such situations may occur, for example:
      <list style="numbers">
        <t>
          A router generates TC messages, advertising links to non-neighbor routers;
        </t>
        <t>
          A router generates TC messages, pretending to be another router;
        </t>
        <t>
          A router generates HELLO messages, advertising non-neighbor routers;
        </t>
        <t>
          A router generates HELLO messages, pretending to be another router;
        </t>
        <t>
          A router forwards altered control messages;
        </t>
        <t>
          A router does not forward control messages;
        </t>
        <t>
          A router does not select multipoint relays correctly;
        </t>
        <t>
          A router forwards broadcast control messages unaltered but does not forward
          unicast data traffic;
        </t>
        <t>
          A router "replays" previously recorded control traffic from another router.
        </t>

      </list>
    </t>

    <t>
      Authentication of the originator router for control messages (for
      situations 2, 4, and 5) and of the individual links announced in the
      control messages (for situations 1 and 3) may be used as a
      countermeasure.  However, to prevent routers from repeating old (and
      correctly authenticated) information (situation 9), additional
      information is required (e.g., a timestamp or sequence number), allowing a router to positively identify such replayed messages.
    </t>

    <t>
	In general, ICVs (e.g., digital signatures) and other required security information
      can be transmitted within the HELLO and TC messages or within a packet
      header using the TLV mechanism. Either option permits different levels
      of protection to coexist in the same network, if desired.
    </t>
    
    <t>
      An important consideration is that all control messages (HELLO messages
      and TC messages) are transmitted to all routers in the 1-hop neighborhood
      and some control messages (TC messages) are flooded to all routers in the network.
      This is done in a packet that is transmitted to all routers in the 1-hop neighborhood,
      the current set of which may not be known. Thus, a control message or
      packet used by this protocol is always contained in a transmission destined for
      multiple destinations, and it is important that the authentication mechanism employed
      permits any receiving router to validate the authenticity of a message or
      packet.
    </t>

    <t>
      <xref target="RFC7182"/> specifies a common exchange format for cryptographic
      information in the form of Packet TLVs, Message TLVs, and Address Block TLVs,
      as specified in <xref target="RFC5444"/>. These may be used (and shared) among
      MANET routing protocol security extensions. In particular, <xref target="RFC7182"/>
      specifies the format of TLVs for containing Integrity Check Values (ICVs), i.e.,
      signatures, for providing integrity, as well as TLVs for containing temporal information for
      preventing replay attacks. <xref target="RFC7182"/> specifies registries for using different
      ciphers and formats of temporal information. When using ICV TLVs in an OLSRv2 deployment,
      failure to verify an included ICV mandates rejection of an incoming message or packet as "invalid", according
      to Section 12.1 of <xref target="RFC6130"/> and according to <xref target="invalid-tc-message"/>
      of this specification when using the multiplexing and demultiplexing process described in
      Appendix A of <xref target="RFC5444"/>.
    </t>
  
    <t>
      <xref target="RFC7182"/> specifies how to
      insert ICVs into generated messages, how to verify incoming messages, and to reject
      "insecure" messages (i.e., messages without an ICV or with an ICV that cannot be
      verified). Different MANET deployments may, as a
      result of the purpose for which they are used and the possibility and nature of
      their configuration, require different ICV algorithms and timestamps or multiple keys,
      and thus, a security extension may use any of the different options provided in
      <xref target="RFC7182"/>.
    </t>

  </section>

  <section anchor="confidentiality" title="Confidentiality">

    <t>
      OLSRv2 periodically MPR floods topological information to all routers in the network.
      Hence, if used in an unprotected network, in particular, an unprotected wireless network,
      the network topology is revealed to anyone who successfully listens to the control
      messages. This information may serve an attacker to acquire details about the topology
      and therefore to initiate more effective attacks against routers in the routing domain,
      e.g., by spoofing addresses of routers in the network and attracting traffic for these
      addresses. Note that this is independent of the data traffic and purely protects the
      control traffic, i.e., information about the network topology.
    </t>

    <t>
      In situations where the confidentiality of the network topology is of importance,
      regular cryptographic techniques, such as use of OLSRv2 multicast control packets
      encrypted using IPsec (e.g., with a shared secret key), can be applied to ensure that
      control traffic can be read and interpreted by only those authorized to do so.
      Alternatively, a security extension may specify a mechanism to provide confidentiality
      for control messages and/or packets. However, unless the information about the network
      topology itself is confidential, integrity of control messages (as specified in
      <xref target="integrity"/>) is sufficient to admit only trusted routers (i.e., routers
      with valid credentials) to the network.
    </t>

  </section>

  <section anchor="external" title="Interaction with External Routing Domains">

    <t>
      This protocol provides a basic mechanism for injecting external routing information
      into this protocol's routing domain. Routing information can also be extracted from this
      protocol's Information Bases, in particular the Routing Set, and injected into an
      external routing domain, if the routing protocol governing that routing domain permits this.
    </t>

    <t>
      When operating routers connecting a routing domain using this protocol to an external routing
      domain, care MUST be taken not to allow potentially insecure and untrustworthy information
      to be injected from this routing domain to an external routing domain. Care MUST also be
      taken to validate the correctness of information prior to it being injected, so as to avoid
      polluting routing tables with invalid information.
    </t>

    <t>
      A recommended way of extending connectivity from an external routing domain to this
      routing domain, which is routed using this protocol, is to assign an IP prefix (under the
      authority of the routers/gateways connecting this routing domain with the external
      routing domain) exclusively to this routing domain and to configure the gateways
      to advertise routes for that IP prefix into the external routing domain.
    </t>

  </section>

  <section title="Mandatory Security Mechanisms" anchor="mandatory_security">

    <t>
      A conformant implementation of OLSRv2 MUST, at minimum, implement the security mechanisms
      specified in <xref target="RFC7183"/>, providing integrity and replay protection
      of OLSRv2 control messages, including of HELLO messages specified by <xref target="RFC6130"/>
      and used by OLSRv2, by inclusion of a timestamp TLV and an Integrity Check Value (ICV) TLV.
      This ICV TLV uses a SHA-256-based HMAC and one or more manually managed shared secret keys.
      The timestamp TLV is based on Portable Operating System Interface (POSIX) time, assuming router time synchronization.
    </t>
  
    <t>
      The baseline use case, for which this security mechanism provides adequate integrity
      protection without rekeying, is for short-lived (for example, up to a couple of months)
      OLSRv2 deployments. 
    </t>

    <t>
      Any deployment of OLSRv2 SHOULD use the security mechanism specified in
      <xref target="RFC7183"/> but MAY use another mechanism if more appropriate
      in an OLSRv2 deployment. For example, for longer-term OLSRv2 deployments, alternative
      security mechanisms (e.g., rekeying) SHOULD be considered.
    </t>

  </section>

  <section title="Key Management" anchor="key_management">

    <t>
      This specification, as well as <xref target="RFC7183"/>, does not mandate
      automated key management (AKM) as part of the security architecture for OLSRv2.
      While some use cases for OLSRv2 may require AKM, the baseline assumption is that
      many use cases do not, for the reasons detailed below.
    </t>

    <t>
      Bootstrapping a key is hard in a radio network, where it is, in general, not
      possible to determine from where a received signal was transmitted or if two
      transmissions come from the same or from different sources.
    </t>

    <t>
      The widespread use of radio networks and mobile phone networks works under the
      assumptions that (i) secret information is embedded in mobile phones at manufacture,
      and (ii) a centralized database of this is accessible during the network lifetime.
    </t>

    <t>
      As a primary use case of a MANET is to provide connectivity without centralized
      entities and with minimal management, a solution such as described in the previous
      paragraph is not feasible. In many instances, a cryptographic authority may not be
      present in the MANET at all, since such a cryptographic authority would be
      too vulnerable. Due to the potentially dynamic topology of a MANET, a
      cryptographic authority may also become unreachable (to some or all of the MANET
      routers) without prior warning.
    </t>

    <t>
      <xref target="BCP107"/> provides guidelines for cryptographic key management.
      Specifically, Section 2.1 sets forth requirements for when AKM is required,
      and Section 2.2 sets forth conditions under which manual key management is
      acceptable. 
    </t>

    <t>
      Section 2.1 of <xref target="BCP107"/> stipulates that "Automated key management
      MUST be used if any of [a set of given] conditions hold". These conditions are
      listed below, and arguments for each are provided in regard to their applicability for the baseline use case of OLSRv2.
      
      <list style="symbols">
        <t>A party will have to manage n^2 static keys, where n may become large.
          <vspace blankLines="1"/>
          The baseline use case of OLSRv2 uses only one or a small set of manually managed shared secrets in the whole MANET.
        </t>
        
        <t>Any stream cipher (such as RC4 <xref target="RFC6229"/><xref
target="RC4"/>, AES-CTR <xref target="RFC3610"/><xref
target="NIST-SP-800-38A"/>, or AES-CCM <xref target="RFC3686"/><xref
target="NIST-SP-800-38C"/>) is used.

          <vspace blankLines="1"/>
          A stream cipher is not envisioned for use to generate ICVs for OLSRv2 control messages.
        </t>
        
        <t>An initialization vector (IV) might be reused, especially an
implicit IV.  Note that random or pseudo-random explicit IVs are not a problem unless the probability of repetition is high.
          <vspace blankLines="1"/>
          An IV is not envisioned for use to generate ICVs for OLSRv2 control messages.

        </t>
        
        <t>Large amounts of data might need to be encrypted in a short time, causing frequent change of the short-term session key.
          <vspace blankLines="1"/>
          Integrity Check Values (ICVs) are required only for OLSRv2 control messages, which are low-volume messages.
        </t>
        
        <t>Long-term session keys are used by more than two
parties. Multicast is a necessary exception, but multicast key management
standards are emerging in order to avoid this in the future. Sharing long-term
session keys should generally be discouraged.
          <vspace blankLines="1"/>
          OLSRv2 control messages are all sent using link-local multicast.
        </t>
        
        <t>The likely operational environment is one where personnel
(or device) turnover is frequent, causing frequent change of the short-term
session key.
          <vspace blankLines="1"/>
          This is not an intended deployment of OLSRv2. For longer-term OLSRv2 deployments, alternative
          security mechanisms (e.g., including rekeying) SHOULD be considered.
        </t>
      </list>
    </t>
    
    <t>
      Section 2.2 of <xref target="BCP107"/> stipulates that "Manual key management may be a
      reasonable approach in any of [a given set of] situations". These situations are listed
      below, and arguments for each are provided in regard to their applicability for the baseline
      use case of OLSRv2.
      
      <list style="symbols">

        <t>The environment has very limited available bandwidth or very high round-trip times.  Public key systems tend to require long messages and lots of computation; symmetric key alternatives, such as Kerberos, often require several round trips and interaction with third parties.
          <vspace blankLines="1"/>
          As previously noted, there may not be the required infrastructure (cryptographic authority)
          present (or, if present, may not be reachable) in the MANET. Bandwidth in a MANET is commonly
          limited, both by being a radio environment and by the need for any signaling to consume a
          minimal proportion thereof, and round trip times may also be significant.
        </t>
        
        <t>The information being protected has low value.
          <vspace blankLines="1"/>
          This depends on the OLSRv2 use case, but the information being protected is OLSRv2
          control traffic, which is of at least moderate value; thus, this case does not apply.
        </t>
        
        <t>The total volume of traffic over the entire lifetime of the long-term session key will be very low.
          <vspace blankLines="1"/>
          Integrity Check Values (ICVs) are required only for OLSRv2 control messages, which are low-volume messages.
        </t>
        
        <t>The scale of each deployment is very limited.
          <vspace blankLines="1"/>
          A typical use case for OLSRv2 may involve only tens of devices --
with even the largest use cases for OLSRv2 being small by Internet
      standards.
        </t>

      </list>

    </t>
    
  </section>

</section>
<section anchor="iana" title="IANA Considerations">

  <t>
    This specification defines one Message Type, which has been allocated
    from the "Message Types" registry of <xref target="RFC5444"/>,
    two Message TLV Types, which have been allocated from the "Message TLV Types"
    registry of <xref target="RFC5444"/>, and four Address Block TLV Types,
    which have been allocated from the "Address Block TLV Types" registry of
    <xref target="RFC5444"/>.
  </t>
	
  <section title="Expert Review: Evaluation Guidelines">
   
    <t>
      For the registries where an Expert Review is required, the designated
      expert SHOULD take the same general recommendations into consideration
      as are specified by <xref target="RFC5444"/>.
    </t>

  </section>

  <section title="Message Types">

    <t>
	This specification defines one Message Type, allocated from the
      0-223 range of the "Message Types" namespace defined in
      <xref target="RFC5444"/>, as specified in <xref target="messagetypes"/>.
    </t>

    <texttable anchor="messagetypes" title="Message Type Assignment">
      <ttcol align="center">Type</ttcol>
      <ttcol align="left">Description</ttcol>
      <c>1</c><c>TC : Topology Control (MANET-wide signaling)</c>
    </texttable>	

  </section>

  <section anchor="msg-type-specific-types" title="Message-Type-Specific TLV Type Registries">

    <t>
      IANA has created a registry for Message-Type-specific
      Message TLVs for TC messages, in accordance with Section 6.2.1 of
      <xref target="RFC5444"/> and with initial assignments and allocation
      policies as specified in <xref target="TC-message-specific-message-tlv-types"/>.
    </t>
	
    <texttable anchor="TC-message-specific-message-tlv-types"
     title="TC Message-Type-Specific Message TLV Types">
      <ttcol align="center">Type</ttcol>
      <ttcol align="left">Description</ttcol>
      <ttcol align="left">Allocation Policy</ttcol>
      <c>128-223</c><c>Unassigned</c><c>Expert Review</c>
    </texttable>
		
    <t>
      IANA has created a registry for Message-Type-specific
      Address Block TLVs for TC messages, in accordance with Section 6.2.1 of
      <xref target="RFC5444"/> and with initial assignments and allocation
      policies as specified in <xref target="TC-message-specific-address-block-tlv-types"/>.
    </t>
	
    <texttable anchor="TC-message-specific-address-block-tlv-types"
               title="TC Message-Type-Specific Address Block TLV Types">
      <ttcol align="center">Type</ttcol>
      <ttcol align="left">Description</ttcol>
      <ttcol align="left">Allocation Policy</ttcol>
      <c>128-223</c><c>Unassigned</c><c>Expert Review</c>
    </texttable>
		
  </section>

  <section title="Message TLV Types">

    <t>
      This specification defines two Message TLV Types, which have been allocated
      from the "Message TLV Types" namespace defined in <xref target="RFC5444"/>.
      IANA has made allocations in the 0-127 range for these types.
      Two new Type Extension registries have been created with assignments as
      specified in <xref target="mpr_willing"/> and
<xref target="cont_seq_num"/>.
      Specifications of these TLVs are in <xref target="msgtlvs"/>. Each of
      these TLVs MUST NOT be included more than once in a Message TLV Block.
    </t>

    <texttable anchor="mpr_willing" title="Message TLV Type Assignment: MPR_WILLING">
	  <ttcol align="center">Name</ttcol>
      <ttcol align="center">Type</ttcol>
      <ttcol align="center">Type Extension</ttcol>
      <ttcol align="left">Description</ttcol>
      <ttcol align="left">Allocation Policy</ttcol>
	<c>MPR_WILLING</c><c>7</c><c>0</c>
        <c>Bits 0-3 specify the originating router's willingness to act as a flooding MPR;
           bits 4-7 specify the originating router's willingness to act as a routing MPR.</c>
        <c></c>
      <c>MPR_WILLING</c><c>7</c><c>1-255</c><c>Unassigned.</c><c>Expert Review</c>
    </texttable>

    <t>
      <vspace blankLines="999"/>
    </t>

    <texttable anchor="cont_seq_num" title="Message TLV Type Assignment: CONT_SEQ_NUM">
      <ttcol align="center">Name</ttcol>
      <ttcol align="center">Type</ttcol>
      <ttcol align="center">Type Extension</ttcol>
      <ttcol align="left">Description</ttcol>
      <ttcol align="left">Allocation Policy</ttcol>
	<c>CONT_SEQ_NUM</c><c>8</c><c>0</c>
        <c> COMPLETE: Specifies a content sequence number for this complete message.</c><c></c>
	<c>CONT_SEQ_NUM</c><c>8</c><c>1</c>
        <c>INCOMPLETE: Specifies a content sequence number for this incomplete message.</c><c></c>
      <c>CONT_SEQ_NUM</c><c>8</c><c>2-255</c><c>Unassigned.</c><c>Expert Review</c>
    </texttable>

    <t>
      Type extensions indicated as Expert Review SHOULD be allocated as
      described in <xref target="RFC5444"/>, based on Expert Review as
      defined in <xref target="RFC5226"/>.
    </t>

  </section>

  <section title="Address Block TLV Types" anchor="address_tlv_types">

    <t>
      This specification defines four Address Block TLV Types, which have been allocated
      from the "Address Block TLV Types" namespace defined in <xref target="RFC5444"/>.
      IANA has made allocations in the 8-127 range for these types.
      Four new Type Extension registries have been created with assignments as
specified in Tables 13, 14, 15, and 16. Specifications of these TLVs are in <xref target="addrtlvs"/>.
    </t>



<t>The registration procedure for the "LINK_METRIC Address Block TLV Type
Extensions" registry is Expert Review.</t>

    <texttable anchor="linkmetric" title="Address Block TLV Type Assignment: LINK_METRIC">
      <ttcol align="center">Name</ttcol>
      <ttcol align="center">Type</ttcol>
      <ttcol align="center">Type Extension</ttcol>
      <ttcol align="left">Description</ttcol>

	  <c>LINK_METRIC</c><c>7</c><c>0</c>
        <c>Link metric meaning assigned by administrative action.</c>

      <c>LINK_METRIC</c><c>7</c><c>1-223</c><c>Unassigned.</c>
      <c>LINK_METRIC</c><c>7</c><c>224-255</c><c>Reserved for Experimental
Use</c>
    </texttable>

    <t>
      All LINK_METRIC TLVs, whatever their type extension, MUST use their value field to
      encode the kind and value (in the interval MINIMUM_METRIC to MAXIMUM_METRIC,
      inclusive) of a link metric as specified in Sections 
<xref target="link_metric_values" format="counter"/> and
      <xref target="addrtlvs" format="counter"/>. An assignment of a LINK_METRIC TLV type extension MUST specify
      the physical meaning of the link metric and the mapping of that physical meaning to the representable values
      in the indicated interval.
    </t>

    <texttable anchor="mpr" title="Address Block TLV Type Assignment: MPR">
      <ttcol align="center">Name</ttcol>
      <ttcol align="center">Type</ttcol>
      <ttcol align="center">Type Extension</ttcol>
      <ttcol align="left">Description</ttcol>
      <ttcol align="left">Allocation Policy</ttcol>
	  <c>MPR</c><c>8</c><c>0</c>
        <c>Specifies that a given network address is of a router selected as a flooding MPR
           (FLOODING = 1), that a given network address is of a router selected as a routing MPR
           (ROUTING = 2), or both (FLOOD_ROUTE = 3).</c>
        <c></c>
      <c>MPR</c><c>8</c><c>1-255</c><c>Unassigned.</c><c>Expert Review</c>
    </texttable>

    <texttable anchor="nbraddrtype" title="Address Block TLV Type Assignment: NBR_ADDR_TYPE">
      <ttcol align="center">Name</ttcol>
      <ttcol align="center">Type</ttcol>
      <ttcol align="center">Type Extension</ttcol>
      <ttcol align="left">Description</ttcol>
      <ttcol align="left">Allocation Policy</ttcol>
	<c>NBR_ADDR_TYPE</c><c>9</c><c>0</c>
        <c>Specifies that a given network address is of a neighbor reached via the originating router,
           if it is an originator address (ORIGINATOR = 1), is a routable address (ROUTABLE = 2),
           or if it is both (ROUTABLE_ORIG = 3).</c><c></c>
      <c>NBR_ADDR_TYPE</c><c>9</c><c>1-255</c><c>Unassigned.</c><c>Expert Review</c>
    </texttable>

    <texttable anchor="gateway" title="Address Block TLV Type Assignment: GATEWAY">
      <ttcol align="center">Name</ttcol>
      <ttcol align="center">Type</ttcol>
      <ttcol align="center">Type extension</ttcol>
      <ttcol align="left">Description</ttcol>
      <ttcol align="left">Allocation Policy</ttcol>
	  <c>GATEWAY</c><c>10</c><c>0</c>
        <c>Specifies that a given network address is reached via a gateway on the
           originating router, with value equal to the number of hops.</c><c></c>
      <c>GATEWAY</c><c>10</c><c>1-255</c><c></c><c>Expert Review</c>
    </texttable>

    <t>
      Type extensions indicated as Expert Review SHOULD be allocated as
      described in <xref target="RFC5444"/>, based on Expert Review as
      defined in <xref target="RFC5226"/>.
    </t>

  </section>
  
  <section anchor="tlv_values" title="NBR_ADDR_TYPE and MPR Values">

    <t>
      Note: This section does not require any IANA action, as the required information
      is included in the descriptions of the MPR and NBR_ADDR_TYPE Address Block TLVs
      allocated in <xref target="address_tlv_types"/>. This information is recorded here
      for clarity and for use elsewhere in this specification.
    </t>

    <t>
      The Values that the MPR Address Block TLV can use are as follows:
      <list style="symbols">
        <t>FLOODING    := 1;</t>
        <t>ROUTING     := 2;</t>
        <t>FLOOD_ROUTE := 3.</t>
      </list>
    </t>

    <t>
      The Values that the NBR_ADDR_TYPE Address Block TLV can use are follows:
      <list style="symbols">
        <t>ORIGINATOR    := 1;</t>
        <t>ROUTABLE      := 2;</t>
        <t>ROUTABLE_ORIG := 3.</t>
      </list>
    </t>

  </section>
  
</section>
<section anchor="contributors" title="Contributors">
  
  <t>
    This specification is the result of the joint efforts of the following
contributors, listed alphabetically.

    <list style="symbols">
      <t>Cedric Adjih, INRIA, France, &lt;Cedric.Adjih@inria.fr&gt;</t>
      <t>Emmanuel Baccelli, INRIA , France,
&lt;Emmanuel.Baccelli@inria.fr&gt;</t>
      <t>Thomas Heide Clausen, LIX, France, &lt;T.Clausen@computer.org&gt;</t>
      <t>Justin Dean, NRL, USA, &lt;jdean@itd.nrl.navy.mil&gt;</t>
      <t>Christopher Dearlove, BAE Systems, UK,
&lt;chris.dearlove@baesystems.com&gt;</t>
      <t>Ulrich Herberg, Fujitsu Laboratories of America, USA,
&lt;ulrich@herberg.name&gt;</t>
      <t>Satoh Hiroki, Hitachi SDL, Japan,
&lt;hiroki.satoh.yj@hitachi.com&gt;</t>
      <t>Philippe Jacquet, Alcatel Lucent Bell Labs, France,
&lt;philippe.jacquet@alcatel-lucent.fr&gt;</t>
      <t>Monden Kazuya, Hitachi SDL, Japan,
&lt;kazuya.monden.vw@hitachi.com&gt;</t>
      <t>Kenichi Mase, Niigata University, Japan,
&lt;mase@ie.niigata-u.ac.jp&gt;</t>
      <t>Ryuji Wakikawa, Toyota, Japan, &lt;ryuji@sfc.wide.ad.jp&gt;</t>

    </list>
  </t>

</section>
<section anchor="acknowledgements" title="Acknowledgments">

  <t>
    The authors would like to acknowledge the team behind OLSRv1,
    as listed in RFC 3626, including Anis Laouiti (INT), Pascale Minet (INRIA),
    Paul Muhlethaler (INRIA), Amir Qayyum (M.A. Jinnah University), and
    Laurent Viennot (INRIA) for their contributions.
  </t>

  <t>
    The authors would like to gratefully acknowledge the following people for
    intense technical discussions, early reviews, and comments on the specification
    and its components (listed alphabetically): Khaldoun Al Agha (LRI),
    Teco Boot (Infinity Networks), Ross Callon (Juniper), Song-Yean Cho (Samsung), Alan Cullen (BAE Systems),
    Louise Lamont (CRC), Li Li (CRC), Joseph Macker (NRL), Richard Ogier (SRI),
    Charles E. Perkins (Futurewei), Henning Rogge (Frauenhofer FKIE), and the entire
    IETF MANET Working Group.
  </t>

  <t>
   Finally, the authors would like to express their gratitude to the Area Directors for providing valuable review comments during the IESG evaluation, in particular (listed alphabetically) Benoit Claise, Adrian Farrel, Stephen Farrell, Barry Leiba,  Pete Resnick, and Martin Stiemerling.
  </t>

</section>
  </middle>

  <back>
<references title="Normative References">

<?rfc include="reference.RFC.2119.xml"?>
<?rfc include="reference.RFC.5148.xml"?>
<?rfc include="reference.RFC.5226.xml"?>
<?rfc include="reference.RFC.5444.xml"?>
<?rfc include="reference.RFC.5497.xml"?>  
<?rfc include="reference.RFC.5498.xml"?>
<?rfc include="reference.RFC.6130.xml"?>


<reference anchor="RFC7182">
<front>
<title>Integrity Check Value and Timestamp TLV Definitions for Mobile Ad Hoc Networks (MANETs)</title>
<author initials='U' surname='Herberg' fullname='Ulrich Herberg'>
    <organization />
</author>
<author initials='T' surname='Clausen' fullname='Thomas Clausen'>
    <organization />
</author>
<author initials='C' surname='Dearlove' fullname='Christopher Dearlove'>
    <organization />
</author>
<date month='April' year='2014' />
</front>
<seriesInfo name='RFC' value='7182' />

</reference>



  <reference anchor="RFC7183">
  <front>
    <title>
Integrity Protection for the Neighborhood Discovery Protocol (NHDP) and
Optimized Link State Routing Protocol Version 2 (OLSRv2)
    </title>
    <author fullname="Ulrich Herberg" initials="U" surname="Herberg">
      <organization>Fujitsu Laboratories of America</organization>
    </author>
    <author initials="C.M." surname="Dearlove" fullname="Christopher Dearlove">
      <organization>BAE Systems ATC</organization>
    </author>
    <author fullname="Thomas Heide Clausen" initials="T" surname="Clausen">
      <organization>LIX, Ecole Polytechnique</organization>
    </author>
    <date month="April" year="2014" />
  </front>
<seriesInfo name='RFC' value='7183' />

  </reference>

</references>

<references title="Informative References">

<?rfc include="reference.RFC.2501.xml"?>
<?rfc include="reference.RFC.3626.xml"?>
<?rfc include="reference.RFC.6229.xml"?>
<?rfc include="reference.RFC.3610.xml"?>
<?rfc include="reference.RFC.3686.xml"?>

  <reference anchor="HIPERLAN">
    <front>
      <title>Radio Equipment and Systems (RES);
             HIgh PErformance Radio Local Area Network (HIPERLAN) Type 1; 
             Functional Specification</title>
      <author>
        <organization abbrev="ETSI">ETSI</organization>
      </author>
      <date month="June" year="1996" />
    </front>
<seriesInfo name='ETSI' value='300-652' />
  </reference>

  <reference anchor="HIPERLAN2">
    <front>
      <title>Increasing Reliability in Cable-Free Radio LANs: Low Level Forwarding in HIPERLAN</title>
      <author initials="P." surname="Jacquet" fullname="Philippe Jacquet">
        <organization abbrev="INRIA">Project Hipercom, INRIA Rocquencourt, France</organization>
      </author>
      <author initials="P." surname="Minet" fullname="Pascale Minet">
        <organization abbrev="INRIA">Project Hipercom, INRIA Rocquencourt, France</organization>
      </author>
      <author initials="P." surname="Muhlethaler" fullname="Paul Muhlethaler">
        <organization abbrev="INRIA">Project Hipercom, INRIA Rocquencourt, France</organization>
      </author>
      <author initials="N." surname="Rivierre" fullname="N. Rivierre">
        <organization abbrev="INRIA">Project Hipercom, INRIA Rocquencourt, France</organization>
      </author>
      <date year="1996" />
    </front>
  </reference>

  <reference anchor="MPR">
    <front>
      <title>Multipoint Relaying: An Efficient Technique for Flooding in Mobile Wireless Networks</title>
      <author initials="A." surname="Qayyum" fullname="Amir Qayyum">
        <organization abbrev="INRIA">Project Hipercom, INRIA Rocquencourt, France</organization>
      </author>
      <author initials="L." surname="Viennot" fullname="Laurent Viennot">
        <organization abbrev="INRIA">Project Hipercom, INRIA Rocquencourt, France</organization>
      </author>
      <author initials="A." surname="Laouiti" fullname="Anis Laouiti">
        <organization abbrev="INRIA">Project Hipercom, INRIA Rocquencourt, France</organization>
      </author>

      <date year="2001"/>
    </front>
  </reference>
  
  <reference anchor="FSR">
    <front>
      <title>Fisheye State Routing in Mobile Ad Hoc Networks</title>
      <author initials="G." surname="Pei" fullname="Guangyu Pei">
        <organization abbrev="UCLA">Computer Science Department, University of California, Los Angeles, USA</organization>
      </author>
      <author initials="M." surname="Gerla" fullname="Mario Gerla">
        <organization abbrev="UCLA">Computer Science Department, University of California, Los Angeles, USA</organization>
      </author>
      <author initials="T." surname="Chen" fullname="Tsu-We Chen">
        <organization abbrev="Bell Labs">Bell Laboratories, Lucent Technologies, USA</organization>
      </author>

      <date year="2000"/>
    </front>
  </reference>
  
  <reference anchor="FSLS">
    <front>
      <title>Making Link-State Routing Scale for Ad Hoc Networks</title>
      <author initials="C." surname="Santivanez" fullname="Cesar A. Santivanez">
        <organization abbrev="BBN">BBN Technologies, MA, USA</organization>
      </author>
      <author initials="R." surname="Ramanathan" fullname="Ram Ramanathan">
        <organization abbrev="BBN">BBN Technologies, MA, USA</organization>
      </author>
      <author initials="I." surname="Stavrakakis" fullname="Ioannis Stavrakakis">
        <organization abbrev="BBN">BBN Technologies, MA, USA</organization>
      </author>

      <date year="2000"/>
    </front>
  </reference>

  <reference anchor="McCabe">
    <front>
      <title>Scalability Modelling of Ad Hoc Routing Protocols - A Comparison of OLSR and DSR</title>
      <author initials="A." surname="McCabe" fullname="Andrew McCabe">
      </author>
      <author initials="C." surname="Dearlove" fullname="Christopher Dearlove">
      </author>
      <author initials="M." surname="Fredin" fullname="Mikael Fredin">
      </author>
      <author initials="L." surname="Axelsson" fullname="Leif Axelsson">
      </author>
      <date year="2004"/>
    </front>
  </reference>

  <reference anchor='BCP107'>
<front>
<title>Guidelines for Cryptographic Key Management</title>
<author initials='S.' surname='Bellovin' fullname='S. Bellovin'>
<organization /></author>
<author initials='R.' surname='Housley' fullname='R. Housley'>
<organization /></author>
<date year='2005' month='June' />
</front>

<seriesInfo name='BCP' value='107' />
<seriesInfo name='RFC' value='4107' />
<format type='TXT' octets='14752' target='http://www.rfc-editor.org/rfc/rfc4107.txt' />
</reference>

  <reference anchor="RC4">
    <front>
      <title>Applied Cryptography: Protocols, Algorithms, and Source Code in
C</title>
      <author initials="B." surname="Schneier" fullname="B. Schneier">
      </author>
        <date year="1996" />
    </front>
<seriesInfo name="Second Edition, John Wiley and Sons," value="New York" />
  </reference>


  <reference anchor="NIST-SP-800-38A">
    <front>
      <title>Recommendation for Block Cipher Modes of Operation: Methods and
Techniques</title>
      <author>
        <organization>National Institute of Standards and
Technology</organization>
      </author>
      <date month="December" year="2001" />
    </front>
<seriesInfo name="Special Publication" value="800-38A" />
  </reference>


  <reference anchor="NIST-SP-800-38C">
    <front>
      <title>Recommendation for Block Cipher Modes of Operation: The CCM Mode
for Authentication and Confidentiality</title>
      <author>
        <organization>National Institute of Standards and
Technology</organization>
      </author>
      <date month="May" year="2004" />
    </front>
<seriesInfo name="Special Publication" value="800-38C" />
  </reference>


</references>
<section anchor="constraints" title="Constraints">

  <t>
	Updates to the Local Information Base, the Neighborhood Information Base, or the Topology Information Base MUST ensure that all constraints specified in this appendix are maintained, as well as those specified in <xref target="RFC6130"/>. This is the case for the processing, specified in this document. Any protocol extension or outside process, which updates the Neighborhood Information Base or the Topology Information Base, MUST also ensure that these constraints are maintained.
  </t>

  <t>
    In each Originator Tuple:
    <list style="symbols">
      <t>
        O_orig_addr MUST NOT equal any other O_orig_addr.
      </t>
      <t>
        O_orig_addr MUST NOT equal this router's originator address.
      </t>
    </list>
  </t>

  <t>
    In each Local Attached Network Tuple:
    <list style="symbols">
      <t>
        AL_net_addr MUST NOT equal any other AL_net_addr.
      </t>
      <t>
        AL_net_addr MUST NOT equal or be a sub-range of any network address in the
        I_local_iface_addr_list of any Local Interface Tuple.
      </t>
      <t>
        AL_net_addr MUST NOT equal this router's originator address or
        equal the O_orig_addr in any Originator Tuple.
      </t>
      <t>
        AL_dist MUST NOT be less than zero.
      </t>
    </list>
  </t>

  <t>
    In each Link Tuple:
    <list style="symbols">
      <t>
        L_neighbor_iface_addr_list MUST NOT contain any network address that
        AL_net_addr of any Local Attached Network Tuple equals or is a sub-range of.
      </t>
      <t>
        If L_in_metric != UNKNOWN_METRIC, then L_in_metric MUST be representable in
        the defined compressed form.
      </t>
      <t>
        If L_out_metric != UNKNOWN_METRIC, then L_out_metric MUST be representable in
        the defined compressed form.
      </t>
      <t>
        If L_mpr_selector = true, then L_status = SYMMETRIC.
      </t>
    </list>
  </t>

  <t>
    In each Neighbor Tuple:
    <list style="symbols">
      <t>
        N_orig_addr MUST NOT be changed to unknown.
      </t>
      <t>
        N_orig_addr MUST NOT equal this router's originator address or
        equal O_orig_addr in any Originator Tuple.
      </t>
      <t>
        N_orig_addr MUST NOT equal the AL_net_addr in any Local Attached
Network Tuple.
      </t>
      <t>
        If N_orig_addr != unknown, then N_orig_addr MUST NOT equal the
N_orig_addr in
        any other Neighbor Tuple.
      </t>
      <t>
        N_neighbor_addr_list MUST NOT contain any network address that
includes
        this router's originator address, the O_orig_addr in any Originator
Tuple,
        or equal or have as a sub-range the AL_net_addr in any Local Attached
Network Tuple.
      </t>
      <t>
If N_orig_addr = unknown, then N_will_flooding = WILL_NEVER,
     N_will_routing = WILL_NEVER, N_flooding_mpr = false,
     N_routing_mpr = false, N_mpr_selector = false, and
     N_advertised = false.
      </t>
      <t>
        N_in_metric MUST equal the minimum value of the L_in_metric values of
all
        corresponding Link Tuples with L_status = SYMMETRIC and L_in_metric !=
UNKNOWN_METRIC,
        if any; otherwise, N_in_metric = UNKNOWN_METRIC.
      </t>
      <t>
        N_out_metric MUST equal the minimum value of the L_out_metric values of
all
        corresponding Link Tuples with L_status = SYMMETRIC and L_out_metric !=
UNKNOWN_METRIC,
        if any; otherwise, N_out_metric = UNKNOWN_METRIC.
      </t>
      <t>
        N_will_flooding and N_will_routing MUST be in the range from WILL_NEVER
        to WILL_ALWAYS, inclusive.
      </t>
      <t>
        If N_flooding_mpr = true, then N_symmetric MUST be true, N_out_metric
        MUST NOT equal UNKNOWN_METRIC, and N_will_flooding MUST NOT equal
WILL_NEVER.
      </t>
      <t>
        If N_routing_mpr = true, then N_symmetric MUST be true, N_in_metric
        MUST NOT equal UNKNOWN_METRIC, and N_will_routing MUST NOT equal
WILL_NEVER.
      </t>
      <t>
        If N_symmetric = true and N_flooding_mpr = false, then N_will_flooding
        MUST NOT equal WILL_ALWAYS.
      </t>
      <t>
        If N_symmetric = true and N_routing_mpr = false, then N_will_routing
        MUST NOT equal WILL_ALWAYS.
      </t>
      <t>
        If N_mpr_selector = true, then N_advertised MUST be true.
      </t>
      <t>
        If N_advertised = true, then N_symmetric MUST be true and
        N_out_metric MUST NOT equal UNKNOWN_METRIC.
      </t>


    </list>
  </t>

  <t>
    In each Lost Neighbor Tuple:
    <list style="symbols">
      <t>
        NL_neighbor_addr MUST NOT include this router's originator address,
        the O_orig_addr in any Originator Tuple, or equal or have as a sub-range the
        AL_net_addr in any Local Attached Network Tuple.
      </t>
    </list>
  </t>

  <t>
    In each 2-Hop Tuple:
    <list style="symbols">
      <t>
        N2_2hop_addr MUST NOT equal this router's originator address,
        equal the O_orig_addr in any Originator Tuple, or equal or have as a
        sub-range the AL_net_addr in any Local Attached Network Tuple.
      </t>
      <t>
        If N2_in_metric != UNKNOWN_METRIC, then N2_in_metric MUST be representable in
        the defined compressed form.
      </t>
      <t>
        If N2_out_metric != UNKNOWN_METRIC, then N2_out_metric MUST be representable in
        the defined compressed form.
      </t>
    </list>
  </t>

  <t>
    In each Advertising Remote Router Tuple:
    <list style="symbols">
      <t>
        AR_orig_addr MUST NOT be in any network address in the
        I_local_iface_addr_list in any Local Interface Tuple or
        be in the IR_local_iface_addr in any Removed Interface
        Address Tuple.
      </t>
      <t>
        AR_orig_addr MUST NOT equal this router's originator address
        or equal the O_orig_addr in any Originator Tuple.
      </t>
      <t>
        AR_orig_addr MUST NOT be in the AL_net_addr in any
        Local Attached Network Tuple.
      </t>
      <t>
        AR_orig_addr MUST NOT equal the AR_orig_addr in any other
        Advertising Remote Router Tuple.
      </t>
    </list>
  </t>

  <t>
    In each Router Topology Tuple:
    <list style="symbols">
       <t>
        There MUST be an Advertising Remote Router Tuple with
        AR_orig_addr = TR_from_orig_addr.
      </t>
     <t>
        TR_to_orig_addr MUST NOT be in any network address in the
        I_local_iface_addr_list in any Local Interface Tuple or be in the
        IR_local_iface_addr in any Removed Interface Address Tuple.
      </t>
      <t>
        TR_to_orig_addr MUST NOT equal this router's originator address
        or equal the O_orig_addr in any Originator Tuple.
      </t>
      <t>
        TR_to_orig_addr MUST NOT be in the AL_net_addr in any
        Local Attached Network Tuple.
      </t>
      <t>
        The ordered pair (TR_from_orig_addr, TR_to_orig_addr) MUST NOT
        equal the corresponding pair for any other Router Topology Tuple.
      </t>
      <t>
        TR_seq_number MUST NOT be greater than AR_seq_number in the Advertising
        Remote Router Tuple with AR_orig_addr = TR_from_orig_addr.
      </t>
      <t>
        TR_metric MUST be representable in the defined compressed form.
      </t>
    </list>
  </t>

  <t>
    In each Routable Address Topology Tuple:
    <list style="symbols">
       <t>
        There MUST be an Advertising Remote Router Tuple with
        AR_orig_addr = TA_from_orig_addr.
      </t>
     <t>
        TA_dest_addr MUST be routable.
      </t>
      <t>
        TA_dest_addr MUST NOT overlap any network address in the I_local_iface_addr_list
        in any Local Interface Tuple or overlap the IR_local_iface_addr in any
        Removed Interface Address Tuple.
      </t>
      <t>
        TA_dest_addr MUST NOT include this router's originator address or
        include the O_orig_addr in any Originator Tuple.
      </t>
      <t>
        TA_dest_addr MUST NOT equal or have as a sub-range the AL_net_addr in any
        Local Attached Network Tuple.
      </t>
      <t>
        The ordered pair (TA_from_orig_addr, TA_dest_addr) MUST NOT equal
        the corresponding pair for any other Attached Network Tuple.
      </t>
      <t>
        TA_seq_number MUST NOT be greater than AR_seq_number in the Advertising
        Remote Router Tuple with AR_orig_addr = TA_from_orig_addr.
      </t>
      <t>
        TA_metric MUST be representable in the defined compressed form.
      </t>
    </list>
  </t>

  <t>
    In each Attached Network Tuple:
    <list style="symbols">
      <t>
        There MUST be an Advertising Remote Router Tuple with
        AR_orig_addr = AN_orig_addr.
      </t>
      <t>
AN_net_addr MUST NOT equal or be a sub-range of any network
     address in the I_local_iface_addr_list in any Local Interface
     Tuple or equal or be a sub-range of the IR_local_iface_addr in any
     Removed  Interface Address Tuple.
      </t>
      <t>
        AN_net_addr MUST NOT equal this router's originator address
        or equal the O_orig_addr in any Originator Tuple.
      </t>

      <t>
        The ordered pair (AN_orig_addr, AN_net_addr) MUST NOT equal
        the corresponding pair for any other Attached Network Tuple.
      </t>
      <t>
        AN_seq_number MUST NOT be greater than AR_seq_number in the
        Advertising Remote Router Tuple with AR_orig_addr = AN_orig_addr.
      </t>
      <t>
        AN_dist MUST NOT be less than zero.
      </t>
      <t>
        AN_metric MUST be representable in the defined compressed form.
      </t>
    </list>
  </t>

</section>
<section anchor="mprcalc" title="Example Algorithm for Calculating MPRs">

  <t>
    The following specifies an algorithm that MAY be used to select
    an MPR Set given a Neighbor Graph, as defined in
    <xref target="neighbor-graph"/> and <xref target="mpr-properties"/>.
  </t>

  <t>
    This algorithm selects an MPR Set M that is a subset of the set N1
    that is part of the Neighbor Graph. This algorithm assumes that a
    subset I of N1 is pre-selected as MPRs, i.e., that M will contain I.
  </t>

  <section title="Additional Notation">

    <t>
      The following additional notation, in addition to that in
      <xref target="neighbor-graph"/>, will be used by this algorithm:

      <list style="hanging">

       <t hangText="N:"> <vspace blankLines="0"/>
         A subset of N2, consisting of those elements y in N2 such that
         either d1(y) is not defined, or there is at least one x in N1
         such that d(x,y) is defined and d(x,y) &lt; d1(y).
       </t>

       <t hangText="D(x):"> <vspace blankLines="0"/>
         For an element x in N1, the number of elements y in N for
         which d(x,y) is defined and has minimal value among the
         d(z,y) for all z in N1.
       </t>

       <t hangText="R(x,M):"> <vspace blankLines="0"/>
         For an element x in N1, the number of elements y in N for
         which d(x,y) is defined has minimal value among the d(z,y)
         for all z in N1 and no such minimal values have z in M.
         (Note that, denoting the empty set by 0, D(x) = R(x,0).)
       </t>

     </list>

    </t>

  </section>

  <section anchor="mpr-interface" title="MPR Selection Algorithm">

    <t>
      To create the MPR Set M, starting with M := I:

      <list style="numbers">

        <t>
          Add all elements x in N1 that have W(x) = WILL_ALWAYS to M.
        </t>

        <t>
          For each element y in N for which there is only one element x in N1
          such that d2(x,y) is defined, add that element x to M.
        </t>

        <t>
          While there exists any element x in N1 with R(x,M) &gt; 0:

          <list style="numbers">

            <t>
              Select an element x in N1 with R(x,M) &gt; 0 in the following order of
              priority, and then add to M:
              <list style="symbols">
                <t>
                  greatest W(x), THEN
                </t>
                <t>
                  greatest R(x,M), THEN
                </t>
                <t>
                  greatest D(x), THEN
                </t>
                <t>
                  any choice, which MAY be based on other criteria (for example, a
                  router MAY choose to prefer a neighbor as an MPR if that neighbor
                  has already selected the router as an MPR of the same type, MAY
                  prefer a neighbor based on information freshness, or MAY prefer
                  a neighbor based on length of time previously selected as an MPR)
                  or MAY be random.
                </t>
              </list>
            </t>

          </list>

        </t>

        <t>
          OPTIONAL: consider each element x in M, but not in I, in turn
          and if x can be removed from M while still leaving it satisfying
          the definition of an MPR Set, then remove that element x from M.
          Elements MAY be considered in any order, e.g., in order of
          increasing W(x).
        </t>

      </list>

    </t>

  </section>

</section>
<section anchor="rs-algo" title="Example Algorithm for Calculating the Routing Set">


  <t>
    The following procedure is given as an example for calculating
    the Routing Set using a variation of Dijkstra's algorithm. First,
    all Routing Tuples are removed, and then, using the selections
    and definitions in <xref target="rs-definitions"/>, the procedures
    in the following sections (each considered a "stage" of the processing)
    are applied in turn.
  </t>

  <section anchor="rs-definitions" title="Local Interfaces and Neighbors">

    <t>
      The following selections and definitions are made:
      <list style="numbers">

        <t>
          For each Local Interface Tuple, select a network address from its
          I_local_iface_addr_list. This is defined as the selected address
          for this Local Interface Tuple.
        </t>

        <t>
For each Link Tuple, the selected address of its corresponding
      Local Interface Tuple is defined as the selected local address
      for this Link Tuple.
        </t>

        <t>
          For each Neighbor Tuple with N_symmetric = true and N_out_metric != UNKNOWN_METRIC,
          select a Link Tuple with L_status = SYMMETRIC for which this is the corresponding
          Neighbor Tuple and has L_out_metric = N_out_metric. This is
          defined as the selected Link Tuple for this Neighbor Tuple.
        </t>

        <t>
          For each network address (N_orig_addr or in N_neighbor_addr_list,
          the "neighbor address") from a Neighbor Tuple with N_symmetric = true
          and N_out_metric != UNKNOWN_METRIC, select a Link Tuple (the "selected
          Link Tuple") from those for which this is the corresponding Neighbor
          Tuple, have L_status = SYMMETRIC, and have L_out_metric = N_out_metric, by:
          <list style="format %d." counter="appclist">
            <t>
              If there is such a Link Tuple whose L_neighbor_iface_addr_list
              contains the neighbor address, select that Link Tuple.
            </t>
            <t>
              Otherwise, select the selected Link Tuple for this Neighbor Tuple.
            </t>
          </list>
          Then for this neighbor address:
          <list style="format %d." counter="appclist">
            <t>
              The selected local address is defined as the selected local address
              for the selected Link Tuple.
            </t>
            <t>
              The selected link address is defined as an address from the
              L_neighbor_iface_addr_list of the selected Link Tuple, if possible
              equal to this neighbor address.
           </t>
          </list>
        </t>

        <t>
Routing Tuple preference is decided by preference for minimum
       R_metric, then for minimum R_dist, and then for preference for
       corresponding Neighbor Tuples in this order:
          <list style="symbols">
            <t>
              For greater N_will_routing.
            </t>
            <t>
              For N_mpr_selector = true over N_mpr_selector = false.
            </t>
          </list>
          Note that preferred Routing Tuples SHOULD be used. Routing Tuples with
          minimum R_metric MUST be used; this is specified outside the definition
          of preference. An implementation MAY modify this definition of preference
          (including for minimum R_dist) without otherwise affecting this algorithm.
        </t>

      </list>
    </t>

  </section>

  <section title="Add Neighbor Routers">

    <t>
      The following procedure is executed once.
      <list style="numbers">
        <t>
          For each Neighbor Tuple with N_symmetric = true and N_out_metric != UNKNOWN_METRIC,
          add a Routing Tuple with:
          <list style="symbols">
            <t>R_dest_addr        := N_orig_addr;</t>
            <t>R_next_iface_addr  := selected link address for N_orig_addr;</t>
            <t>R_local_iface_addr := selected local address for N_orig_addr;</t>
            <t>R_metric           := N_out_metric;</t>
            <t>R_dist             := 1.</t>
          </list>
        </t>
      </list>
    </t>

  </section>

  <section title="Add Remote Routers">
	
    <t>
      The following procedure is executed once.

      <list style="numbers">

        <t>
          Add a label that may be "used" or "unused" to each Routing Tuple,
          with all initial values equal to unused. (Note that this label is
          only required during this algorithm.)
        </t>

        <t>
          If there are no unused Routing Tuples, then this stage is complete;
          otherwise, repeat the following until that is the case.

          <list style="numbers">

            <t>
              Find the unused Routing Tuple with minimum R_metric (if more than one,
              pick any) and denote it the "current Routing Tuple".
            </t>

            <t>
              Mark the current Routing Tuple as used.
            </t>

            <t>
              For each Router Topology Tuple, with
              <vspace blankLines="0"/>
             TR_from_orig_addr = R_dest_addr of the current Routing Tuple:

              <list style="numbers">

                <t>
                  Define:
                  <list style="symbols">
                    <t>new_metric := R_metric of the current Routing Tuple + TR_metric;</t>
                    <t>new_dist   := R_dist of the current Routing Tuple + 1.</t>
                  </list>
                </t>

                <t>
                  If there is no Routing Tuple with R_dest_addr = TR_to_orig_addr, then
                  create an unused Routing Tuple with:
                  <list style="symbols">
                    <t>R_dest_addr        := TR_to_orig_addr;</t>
                    <t>R_next_iface_addr  := R_next_iface_addr of the current Routing Tuple;</t>
    	              <t>R_local_iface_addr := R_local_iface_addr of the current Routing Tuple;</t>
                    <t>R_metric           := new_metric;</t>
                    <t>R_dist             := new_dist.</t>
                  </list>
                </t>

                <t>
                  Otherwise, if there is an unused Routing Tuple with R_dest_addr = TR_to_orig_addr,
                  and either new_metric &lt; R_metric or (new_metric = R_metric and the updated
                  Routing Tuple would be preferred), then update this Routing Tuple to have:
                  <list style="symbols">
                    <t>R_next_iface_addr  := R_next_iface_addr of the current Routing Tuple;</t>
    	              <t>R_local_iface_addr := R_local_iface_addr of the current Routing Tuple;</t>
                    <t>R_metric           := new_metric;</t>
                    <t>R_dist             := new_dist.</t>
                  </list>
                </t>

              </list>

            </t>

          </list>

        </t>

      </list>

    </t>

  </section>

  <section title="Add Neighbor Addresses">

    <t>
      The following procedure is executed once.
      <list style="numbers">
        <t>
          For each Neighbor Tuple with N_symmetric = true and N_out_metric != UNKNOWN_METRIC:
          <list style="numbers">
            <t>
              For each network address (the "neighbor address") in N_neighbor_addr_list,
              if the neighbor address is not equal to the R_dest_addr of any Routing Tuple,
              then add a new Routing Tuple, with:
              <list style="symbols">
    	          <t>R_dest_addr        := neighbor address;</t>
                <t>R_next_iface_addr  := selected link address for the neighbor address;</t>
                <t>R_local_iface_addr := selected local address for the neighbor address;</t>
                <t>R_metric           := N_out_metric;</t>
                <t>R_dist             := 1.</t>
              </list>
            </t>
          </list>
        </t>
      </list>
    </t>

  </section>

  <section title="Add Remote Routable Addresses">
	
    <t>
      The following procedure is executed once.
      <list style="numbers">
        <t>
          For each Routable Address Topology Tuple, if:
          <list style="symbols">
            <t>
              TA_dest_addr is not equal to the R_dest_addr of any Routing Tuple
              added in an earlier stage; AND
            </t>
            <t>
              TA_from_orig_addr is equal to the R_dest_addr of a Routing Tuple
              (the "previous Routing Tuple"),
            </t>
          </list>
          then add a new Routing Tuple, with:
          <list style="symbols">
    	      <t>R_dest_addr        := TA_dest_addr;</t>
            <t>R_next_iface_addr  := R_next_iface_addr of the previous Routing Tuple;</t>
    	      <t>R_local_iface_addr := R_local_iface_addr of the previous Routing Tuple;</t>
            <t>R_metric           := R_metric of the previous Routing Tuple + TA_metric;</t>
            <t>R_dist             := R_dist of the previous Routing Tuple + 1.</t>
          </list>
       There may be more than one Routing Tuple that may be added for an
       R_dest_addr in this stage.  If so, then for each such
       R_dest_addr, a Routing Tuple with minimum R_metric MUST be
       added; otherwise, a Routing Tuple that is preferred SHOULD be
       added.
        </t>
      </list>
    </t>

  </section>

  <section title="Add Attached Networks">
	
    <t>
      The following procedure is executed once.
      <list style="numbers">
        <t>
          For each Attached Network Tuple, if:
          <list style="symbols">
             <t>
              AN_net_addr is not equal to the R_dest_addr of any Routing Tuple
              added in an earlier stage; AND
            </t>
            <t>
              AN_orig_addr is equal to the R_dest_addr of a Routing Tuple
              (the "previous Routing Tuple),
            </t>
          </list>
          then add a new Routing Tuple, with:
          <list style="symbols">
    	      <t>R_dest_addr        := AN_net_addr;</t>
            <t>R_next_iface_addr  := R_next_iface_addr of the previous Routing Tuple;</t>
    	      <t>R_local_iface_addr := R_local_iface_addr of the previous Routing Tuple;</t>
    	      <t>R_metric           := R_metric of the previous Routing Tuple + AN_metric;</t>
            <t>R_dist             := R_dist of the previous Routing Tuple + AN_dist.</t>
          </list>
       There may be more than one Routing Tuple that may be added for an
       R_dest_addr in this stage.  If so, then for each such
       R_dest_addr, a Routing Tuple with minimum R_metric MUST be
       added; otherwise, a Routing Tuple that is preferred SHOULD be
       added.
        </t>
      </list>
    </t>

  </section>

  <section title="Add 2-Hop Neighbors">
	
    <t>
The following procedure is OPTIONAL according to <xref target="topologygraph"/> and MAY be
executed once.
      <list style="numbers">
        <t>
          For each 2-Hop Tuple with N2_out_metric != UNKNOWN_METRIC, if:
          <list style="symbols">
            <t>
              N2_2hop_addr is a routable address; AND
            </t>
            <t>
              N2_2hop_addr is not equal to the R_dest_addr of any Routing Tuple
              added in an earlier stage; AND
            </t>
            <t>
              the Routing Tuple with R_dest_addr = N_orig_addr of the corresponding
              Neighbor Tuple (the "previous Routing Tuple") has R_dist = 1,
            </t>
          </list>
          then add a new Routing Tuple, with:
          <list style="symbols">
    	      <t>R_dest_addr        := N2_2hop_addr;</t>
            <t>R_next_iface_addr  := R_next_iface_addr of the previous Routing Tuple;</t>
    	      <t>R_local_iface_addr := R_local_iface_addr of the previous Routing Tuple;</t>
    	      <t>R_metric           := R_metric of the previous Routing Tuple + N_out_metric
                                     of the corresponding Neighbor Tuple;</t>
            <t>R_dist             := 2.</t>
          </list>
       There may be more than one Routing Tuple that may be added for an
       R_dest_addr in this stage.  If so, then for each such
       R_dest_addr, a Routing Tuple with minimum R_metric MUST be
       added; otherwise, a Routing Tuple that is preferred SHOULD be
       added.
        </t>
      </list>
    </t>

  </section>

</section>
<section anchor="layout" title="TC Message Example">

  <t>
    TC messages are instances of <xref target="RFC5444"/> messages. This
    specification requires that TC messages contain &lt;msg-hop-limit&gt;
    and &lt;msg-orig-addr&gt; fields. It supports TC messages with any
    combination of remaining message header options and address encodings
    enabled by <xref target="RFC5444"/> that convey the required information.
    As a consequence, there is no single way to represent how all TC messages
    look. This appendix illustrates a TC message; the exact values and content
    included are explained in the following text.
  </t>

  <t>
    The TC message's four-bit Message Flags (MF) field has a value of 15,
    indicating that the message header contains originator address, hop limit,
    hop count, and message sequence number fields. Its four-bit Message Address
    Length (MAL) field has value 3, indicating addresses in the message have a
    length of four octets, here being IPv4 addresses. The overall message length
    is 75 octets.
  </t>

  <t>
    The message has a Message TLV Block with a content length of 17 octets containing
    four TLVs. The first two TLVs are validity and interval times for the message.
    The third TLV is the content sequence number TLV used to carry the 2-octet ANSN
    and (with default type extension zero, i.e., COMPLETE) indicates that the
    TC message is complete. The fourth TLV contains forwarding and routing
    willingness values for the originating router (FWILL and RWILL, respectively).
    Each TLV uses a TLV with Flags octet (MTLVF) value 16,
    indicating that it has a Value, but no type extension or start and stop indexes.
    The first two TLVs have a Value Length of 1 octet; the last has a Value Length
    of 2 octets.
  </t>

  <t>
    The message has two Address Blocks. (This is not necessary. The
    information could be conveyed using a single Address Block; the
    use of two Address Blocks, which is also allowed, is illustrative
    only.) The first Address Block contains 3 addresses, with Flags
    octet (ABF) value 128, hence with a Head section (with length 2
    octets) but no Tail section and with Mid sections with length
    two octets. The following TLV Block (content length 13 octets) contains
    two TLVs. The first TLV is a NBR_ADDR_TYPE TLV with Flags octet (ATLVF)
    value 16, indicating a single Value but no indexes. Thus, all these
    addresses are associated with the Value (with Value Length 1 octet)
    ROUTABLE_ORIG, i.e., they are originator addresses of advertised
    neighbors that are also routable addresses. The second TLV is a
    LINK_METRIC TLV with Flags octet (ATLVF) value 20, indicating a
    Value for each address, i.e., as the total Value Length is 6 octets,
    each address is associated with a Value with length two octets.
                   These Value fields are each shown as having four bits
  indicating that they are outgoing neighbor metric values and as
  having twelve bits that represent the metric value (the first four
  bits being the exponent, the remaining eight bits the mantissa).
  </t>

  <t>
   The second Address Block contains 1 address, with Flags octet (ATLVF)
   176, indicating that there is a Head section (with length 2 octets),
   that the Tail section (with length 2 octets) consists of zero valued
   octets (not included), and that there is a single prefix length, which is
   16. The network address is thus Head.0.0/16. The following TLV Block
   (content length 9 octets) includes two TLVs. The first has a Flags
   octet (ATLVF) of 16, again indicating that no indexes are needed, but
   that a Value (with Value Length 1 octet) is present, indicating the
   address distance as a number of hops. The second TLV is another
   LINK_METRIC TLV, as in the first Address TLV Block except with a Flags
   octet (ATLVF) value 16, indicating that a single Value is present.
  </t>

  <figure>
    <artwork>
   0                   1                   2                   3  
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      TC       | MF=15 | MAL=3 |      Message Length = 75      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                      Originator Address                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Hop Limit   |   Hop Count   |    Message Sequence Number    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Message TLV Block Length = 17 | VALIDITY_TIME |  MTLVF = 16   |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Value Len = 1 | Value (Time)  | INTERVAL_TIME |  MTLVF = 16   |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Value Len = 1 | Value (Time)  | CONT_SEQ_NUM  |  MTLVF = 16   |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Value Len = 2 |         Value (ANSN)          |  MPR_WILLING  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |  MTLVF = 16   | Value Len = 1 | FWILL | RWILL | Num Addrs = 3 |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   ABF = 128   | Head Len = 2  |             Head              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |              Mid              |              Mid              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |              Mid              | Address TLV Block Length = 13 |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | NBR_ADDR_TYPE |  ATLVF = 16   | Value Len = 1 | ROUTABLE_ORIG |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |  LINK_METRIC  |  ATLVF = 20   | Value Len = 6 |0|0|0|1|Metric |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Metric (cont) |0|0|0|1|        Metric         |0|0|0|1|Metric |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Metric (cont) | Num Addrs = 1 |   ABF = 176   | Head Len = 2  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |             Head              | Tail Len = 2  | Pref Len = 16 |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Address TLV Block Length = 9  |    GATEWAY    |  ATLVF = 16   |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Value Len = 1 | Value (Hops)  |  LINK_METRIC  |  ATLVF = 16   |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Value Len = 2 |0|0|0|1|        Metric         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork>
  </figure>

</section>
<section anchor="flow" title="Flow and Congestion Control">

  <t>	
    Due to its proactive nature, this protocol has a natural control
    over the flow of its control traffic.  Routers transmit control
    messages at predetermined rates specified and bounded by message intervals.
  </t>

  <t>
    This protocol employs <xref target="RFC6130"/> for local signaling, embedding  
    MPR selection advertisement through a simple Address Block TLV and router
    willingness advertisement (if any) as a single Message TLV. Local
    signaling, therefore, shares the characteristics and constraints of  
    <xref target="RFC6130"/>.
  </t>

  <t>
    Furthermore, the use of MPRs can greatly reduce the signaling overhead
    from link state information dissemination in two ways, attaining both
    flooding reduction and topology reduction. First, using MPR flooding,
    the cost of distributing link state information throughout the network
    is reduced, as compared to when using blind flooding, since only MPRs
    need to forward link state declaration messages. Second, the amount
    of link state information for a router to declare is reduced; it only needs
    to contain that router's MPR selectors. This reduces the size of a
    link state declaration as compared to declaring full link state information.
    In particular, some routers may not need to declare any such information.
    In dense networks, the reduction of control traffic can be of several
    orders of magnitude compared to routing protocols using blind
    flooding <xref target="MPR"/>. This feature naturally provides more
    bandwidth for useful data traffic and further pushes the frontier of
    congestion.
  </t>

  <t>
    Since the control traffic is continuous and periodic, it keeps the quality
    of the links used in routing more stable.  However, using some options,
    some control messages (HELLO messages or TC messages) may be intentionally
    sent in advance of their deadline in order to increase the responsiveness
    of the protocol to topology changes. This may cause a small, temporary, and
    local increase of control traffic; however, this is at all times bounded by
    the use of minimum message intervals.
  </t>

  <t>
    A router that recognizes that the network is suffering from congestion can
    increase its message interval parameters. If this is done by most or all
    routers in the network, then the overall control traffic in the network will be reduced.
    When using this capability, routers will have to take care not to increase
    message interval parameters such that they cannot cope with network
    topology changes. Note that routers can make such decisions independently;
    it is not necessary for all routers to be using the same parameter values, nor is it necessary that all routers decide to change their intervals at the same time.
  </t>

</section>
  </back>

</rfc>
