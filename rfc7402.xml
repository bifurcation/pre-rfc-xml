<?xml version="1.0" encoding="US-ASCII" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC0791 SYSTEM "reference.RFC.0791" >
<!ENTITY RFC2119 SYSTEM "reference.RFC.2119" >
<!ENTITY RFC2404 SYSTEM "reference.RFC.2404" >
<!ENTITY RFC2410 SYSTEM "reference.RFC.2410" >
<!ENTITY RFC3602 SYSTEM "reference.RFC.3602" >
<!ENTITY RFC4106 SYSTEM "reference.RFC.4106" >
<!ENTITY RFC4301 SYSTEM "reference.RFC.4301" >
<!ENTITY RFC4303 SYSTEM "reference.RFC.4303" >
<!ENTITY RFC4309 SYSTEM "reference.RFC.4309" >
<!ENTITY RFC4493 SYSTEM "reference.RFC.4493" >
<!ENTITY RFC4494 SYSTEM "reference.RFC.4494" >
<!ENTITY RFC4543 SYSTEM "reference.RFC.4543" >
<!ENTITY RFC4868 SYSTEM "reference.RFC.4868" >
<!ENTITY RFC5202 SYSTEM "reference.RFC.5202" >
<!ENTITY RFC5206 SYSTEM "reference.RFC.5206" >
<!ENTITY RFC5207 SYSTEM "reference.RFC.5207" >
<!ENTITY RFC5770 SYSTEM "reference.RFC.5770" >
<!ENTITY RFC7296 SYSTEM "reference.RFC.7296" >
]>

<?rfc rfcedstyle="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>

<rfc number="7402" category="std" ipr="trust200902" obsoletes="5202"
     submissionType="IETF" consensus="yes">

  <front>
    <title abbrev="Using the ESP Transport Format with HIP">
      Using the Encapsulating Security Payload (ESP) Transport Format
with&nbsp;the&nbsp;Host Identity Protocol (HIP)</title>

    <author initials="P." surname="Jokela"
      fullname="Petri Jokela">
      <organization>Ericsson Research NomadicLab</organization>
      <address>
        <postal>
          <street />
          <city>JORVAS</city>
          <code>FIN-02420</code>
          <country>Finland</country>
        </postal>
        <phone>+358 9 299 1</phone>
        <email>petri.jokela@nomadiclab.com</email>
      </address>
    </author>

    <author initials="R." surname="Moskowitz" 
      fullname="Robert Moskowitz">
     <organization>HTT Consulting</organization>
      <address>
        <postal>
          <street />
          <city>Oak Park</city>
          <region>MI</region>
          <country>United States</country>
        </postal>
        <email>rgm@labs.htt-consult.com</email>
      </address>
    </author>

    <author initials="J." surname="Melen" 
      fullname="Jan Melen">
      <organization>Ericsson Research NomadicLab</organization>
      <address>
        <postal>
          <street />
          <city>JORVAS</city>
          <code>FIN-02420</code>
          <country>Finland</country>
        </postal>
        <phone>+358 9 299 1</phone>
        <email>jan.melen@nomadiclab.com</email>
      </address>
    </author>

    <date month="April" year="2015" />

    <abstract>

      <t>
        This memo specifies an Encapsulated Security Payload (ESP)
        based mechanism for transmission of user data packets, to be
        used with the Host Identity Protocol (HIP). This document
        obsoletes RFC 5202.
      </t>

    </abstract>

  </front>

  <middle>
    <section title="Introduction">

      <t>
        In the Host Identity Protocol Architecture <xref
        target="HIP-ARCH" />, hosts are identified with public keys.
        The Host Identity Protocol (HIP) <xref target="RFC7401"/> base
        exchange allows any two HIP-supporting hosts to authenticate
        each other and to create a HIP association between themselves.
        During the base exchange, the hosts generate a piece of shared
        keying material using an authenticated Diffie-Hellman exchange.
      </t>
      
      <t>
        The HIP base exchange specification <xref target="RFC7401"/>
        does not describe any transport formats or methods for user
        data to be used during the actual communication; it only
        defines that it is mandatory to implement
        the <xref target="RFC4303">Encapsulated Security Payload
        (ESP)</xref> based transport format and method.  This document
        specifies how ESP is used with HIP to carry actual user data.
      </t>
      <t>
        To be more specific, this document specifies a set of HIP
        protocol extensions and their handling.  Using these extensions,
        a pair of ESP Security Associations (SAs) is created between the
        hosts during the base exchange.  The resulting ESP Security
        Associations use keys drawn from the keying material (KEYMAT)
        generated during the base exchange.  After the HIP association
        and required ESP SAs have been established between the hosts,
        the user data communication is protected using ESP.  In addition,
        this document specifies methods to update an existing ESP Security
        Association.
      </t>

      <t>
        It should be noted that representations of Host Identity are not
        carried explicitly in the headers of user data packets.
        Instead, the ESP Security Parameter Index (SPI) is used to
        indicate the right host context.  The SPIs are selected during
        the HIP ESP setup exchange.  For user data packets, ESP SPIs (in 
        possible combination with IP addresses) are used indirectly to
        identify the host context, thereby avoiding any additional
        explicit protocol headers.
      </t>

      <t>
        HIP and ESP traffic have known issues with middlebox traversal
        (<xref target="RFC5207">RFC 5207</xref>).  Other specifications
        exist for operating HIP and ESP over UDP. (<xref
        target="RFC5770">RFC 5770</xref> is an experimental
        specification, and others are being developed.)  Middlebox
        traversal is out of scope for this document.
      </t>
      <t>
        This document obsoletes RFC 5202.
      </t>

    </section>

    <section title="Conventions Used in This Document">

      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
        NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
        "OPTIONAL" in this document are to be interpreted as described
        in <xref target="RFC2119">RFC 2119</xref>.
      </t>

    </section>
    <section title="Using ESP with HIP">
      <t>
        The HIP base exchange is used to set up a HIP association
        between two hosts.  The base exchange provides two-way host
        authentication and key material generation, but it does not
        provide any means for protecting data communication between
        the hosts.  In this document, we specify the use of ESP for
        protecting user data traffic after the HIP base exchange.
        Note that this use of ESP is intended only for host-to-host
        traffic; security gateways are not supported.
      </t>
      <t>
        To support ESP use, the HIP base exchange messages require
        some minor additions to the parameters transported.  In
        the R1 packet, the Responder adds the possible ESP transforms
        in an ESP_TRANSFORM parameter before sending it to the
        Initiator.  The Initiator gets the proposed transforms,
        selects one of those proposed transforms, and adds it to the I2
        packet in an ESP_TRANSFORM parameter.  In this I2 packet, the
        Initiator also sends the SPI value that it wants to be used
        for ESP traffic flowing from the Responder to the Initiator.
        This information is carried using the ESP_INFO parameter.
        When finalizing the ESP SA setup, the Responder sends its SPI
        value to the Initiator in the R2 packet, again using ESP_INFO.
      </t>    

      <section title="ESP Packet Format">
        <t>
          The <xref target="RFC4303">ESP specification</xref>
          defines the ESP packet format for IPsec.  The HIP ESP
          packet looks exactly the same as the IPsec ESP transport 
          format packet.  The semantics, however, are a bit different
          and are described in more detail in the next subsection. 
        </t>

      </section>

      <section anchor="sec_esp_packet" 
        title="Conceptual ESP Packet Processing">

        <t>
          ESP packet processing can be implemented in different ways in
          HIP.  It is possible to implement it in a way that a standards
          compliant, unmodified IPsec implementation <xref
          target="RFC4303" /> can be used in conjunction with some
          additional transport checksum processing above it, and if IP
          addresses are used as indexes to the right host context.
        </t>

        <t>
          When a standards compliant IPsec implementation that uses IP
          addresses in the Security Policy Database (SPD) and
          Security Association Database (SAD) is used, the packet
          processing may take the following steps.
          For outgoing packets, assuming that the upper-layer
          pseudo header has been built using IP addresses, the
          implementation recalculates upper-layer checksums using Host
          Identity Tags (HITs) and, after that, changes the packet
          source and destination addresses back to corresponding IP
          addresses.  The packet is sent to the IPsec ESP for transport
          mode handling, and from there the encrypted packet is sent to
          the network.  When an ESP packet is received, the packet is
          first put through the IPsec ESP transport mode handling, and
          after decryption, the source and destination IP addresses are
          replaced with HITs, and finally, upper-layer checksums are
          verified before passing the packet to the upper layer.
        </t>

        <t>
          An alternative way to implement packet processing is the BEET
          (Bound End-to-End Tunnel) mode (see <xref target="BEET" />).
          In BEET mode, the ESP packet is formatted as a transport mode
          packet, but the semantics of the connection are the same as
          for tunnel mode.  The "outer" addresses of the packet are the
          IP addresses, and the "inner" addresses are the HITs.  For
          outgoing traffic, after the packet has been encrypted, the
          packet's IP header is changed to a new one that contains IP
          addresses instead of HITs, and the packet is sent to the
          network. When the ESP packet is received, the SPI value,
          together with the integrity protection, allow the packet to be
          securely associated with the right HIT pair.  The packet
          header is replaced with a new header containing HITs, and the
          packet is decrypted.  BEET mode is completely internal for a
          host and doesn't require that the corresponding host implement it;
          instead, the corresponding host can have ESP transport mode and 
          do HIT IP conversions outside ESP.
        </t>

        <section anchor="spi" 
          title="Semantics of the Security Parameter Index (SPI)">
          
          <t>
            SPIs are used in ESP to find the right Security Association
            for received packets.  The ESP SPIs have added significance
            when used with HIP; they are a compressed representation of
            a pair of HITs.  Thus, SPIs MAY be used by intermediary
            systems in providing services like address mapping.  Note
            that since the SPI has significance at the receiver, only
            the &lt; DST, SPI &gt;, where DST is a destination IP address,
            uniquely identifies the receiver HIT at any given point of
            time.  The same SPI value may be used by several hosts.  A
            single &lt;&nbsp;DST, SPI &gt; value may denote different hosts
            and contexts at different points of time, depending on the
            host that is currently reachable at the DST.
          </t>
        
          <t>
            Each host selects for itself the SPI it wants to see in
            packets received from its peer.  This allows it to select
            different SPIs for different peers.  The SPI selection
            SHOULD be random; the rules of Section 2.1 of the <xref
            target="RFC4303">ESP specification</xref> must be followed.
            A different SPI SHOULD be used for each HIP exchange with a
            particular host; this is to avoid a replay attack.
            Additionally, when a host rekeys, the SPI MUST be changed.
            Furthermore, if a host changes over to use a different IP
            address, it MAY change the SPI.
          </t>
          
          <t>
            One method for SPI creation that meets the above criteria
            would be to concatenate the HIT with a 32-bit random or
            sequential number, hash this (using SHA1), and then use the
            high-order 32 bits as the SPI.
          </t>
          
          <t>
            The selected SPI is communicated to the peer in the third
            (I2) and fourth (R2) packets of the base HIP exchange.
            Changes in SPI are signaled with ESP_INFO parameters.
          </t>
          
        </section>
        
      </section>

      <section title="Security Association Establishment and Maintenance">

        <section title="ESP Security Associations">

          <t>
            In HIP, ESP Security Associations are set up between the HIP
            nodes during the base exchange <xref target="RFC7401"/>.
            Existing ESP SAs can be updated later using UPDATE messages.
            The reason for updating the ESP SA later can be, for example,
            a need for rekeying the SA because of sequence number rollover.
          </t>

          <t>
            Upon setting up a HIP association, each association is
            linked to two ESP SAs, one for incoming packets and one for
            outgoing packets.  The Initiator's incoming SA corresponds
            with the Responder's outgoing one, and vice versa.  The
            Initiator defines the SPI for its incoming association, as
            defined in <xref target="spi" />.  This SA is herein called
            SA-RI, and the corresponding SPI is called SPI-RI.
            Respectively, the Responder's incoming SA corresponds with
            the Initiator's outgoing SA and is called SA-IR, with the
            SPI being called SPI-IR.
          </t>
          
          <t>
            The Initiator creates SA-RI as a part of R1 processing,
            before sending out the I2, as explained in <xref
            target="inr1" />.  The keys are derived from KEYMAT, as
            defined in <xref target="key" />.  The Responder creates
            SA-RI as a part of I2 processing; see <xref target="ini2"
            />.
          </t>
          
          <t>
            The Responder creates SA-IR as a part of I2 processing,
            before sending out R2; see <xref target="ini2" />.  The
            Initiator creates SA-IR when processing R2; see <xref
            target="inr2" />.
          </t>
          
          <t>
            The initial session keys are drawn from the generated keying
            material, KEYMAT, after the HIP keys have been drawn as
            specified in <xref target="RFC7401"/>.
          </t>
          <t>
            When the HIP association is removed, the related ESP SAs
            MUST also be removed.
          </t>
        </section>

        <section anchor="esp_rekeying" title="Rekeying">
          
          <t>
            After the initial HIP base exchange and SA establishment, both
            hosts are in the ESTABLISHED state.  There are no longer Initiator
            and Responder roles, and the association is symmetric.  In this
            subsection, the party that initiates the rekey procedure is
            denoted with I' and the peer with R'.
          </t>
          <t>
            An existing HIP-created ESP SA may need updating during the
            lifetime of the HIP association.  This document specifies
            the rekeying of an existing HIP-created ESP SA, using the
            UPDATE message.  The ESP_INFO parameter introduced above is
            used for this purpose.
          </t>

          <t>
            I' initiates the ESP SA updating process when needed (see
            <xref target="association_update" />).  It creates an UPDATE
            packet with required information and sends it to the peer
            node.  The old SAs are still in use, local policy
            permitting.
          </t>
          
          <t>
            R', after receiving and processing the UPDATE (see <xref
            target="processing_her1" />), generates new SAs: SA-I'R' and
            SA-R'I'.  It does not take the new outgoing SA into use, but
            still uses the old one, so there temporarily exist two SA
            pairs towards the same peer host.  The SPI for the new
            outgoing SA, SPI-R'I', is specified in the received ESP_INFO
            parameter in the UPDATE packet.  For the new incoming SA, R'
            generates the new SPI value, SPI-I'R', and includes it in
            the response UPDATE packet.  
          </t>
          
          <t>
            When I' receives a response UPDATE from R', it
            generates new SAs, as described in <xref
              target="processing_her1" />: SA-I'R' and SA-R'I'.  It starts
            using the new outgoing SA immediately.
          </t>
          <t>
            R' starts using the new outgoing SA when it receives
            traffic on the new incoming SA or when it receives the
            UPDATE ACK confirming completion of rekeying.  After this,
            R' can remove the old SAs.  Similarly, when the I'
            receives traffic from the new incoming SA, it can safely
            remove the old SAs.
          </t>
          
        </section>
        
        <section title="Security Association Management">
          
          <t>
            An SA pair is indexed by the 2 SPIs and 2 HITs (both local and
            remote HITs since a system can have more than one HIT).  An
            inactivity timer is RECOMMENDED for all SAs.  If the state
            dictates the deletion of an SA, a timer is set to allow for
            any late arriving packets.
          </t>
          
        </section>
        
        <section title="Security Parameter Index (SPI)">
          
          <t>
            The SPIs in ESP provide a simple compression of the HIP data
            from all packets after the HIP exchange.  This does require a
            per HIT-pair Security Association (and SPI), and a decrease
            of policy granularity over other Key Management Protocols like
            Internet Key Exchange (IKE) <xref target="RFC7296" />.
          </t>
          
          <t>
            When a host updates the ESP SA, it provides a new inbound
            SPI to and gets a new outbound SPI from its peer.
          </t>
          
        </section>
        
        <section anchor="supported_ciphers" title="Supported Ciphers">
          
          <t>
            All HIP implementations MUST support AES-128-CBC and
            AES-256-CBC <xref target="RFC3602" />.  If the Initiator
            does not support any of the transforms offered by the
            Responder, it should abandon the negotiation and inform the
            peer with a NOTIFY message about a non-supported transform.
          </t>

          <t>
            In addition to AES-128-CBC, all implementations SHOULD
            implement the ESP NULL encryption algorithm.  When the ESP
            NULL encryption is used, it MUST be used together with SHA-256
            authentication as specified in <xref target="esptransform" />.
          </t>

          <t>
            When an authentication-only suite is used (NULL,
            AES-CMAC-96, and AES-GMAC are examples), the suite MUST NOT
            be accepted if offered by the peer unless the local policy
            configuration regarding the peer host is explicitly set to allow an
            authentication-only mode.  This is to prevent sessions from being
            downgraded to an authentication-only mode when one side's policy
            requests privacy for the session.
          </t>
      
        </section>
        
        <section anchor="sec-seq-num" title="Sequence Number">

          <t>
            The Sequence Number field is MANDATORY when ESP is used with
            HIP.  Anti-replay protection MUST be used in an ESP SA
            established with HIP.  When ESP is used with HIP, a 64-bit
            sequence number MUST be used.  This means that each host
            MUST rekey before its sequence number reaches 2^64.
          </t>
          <t>
            When using a 64-bit sequence number, the higher 32 bits are
            NOT included in the ESP header, but are simply kept local to 
            both peers.  See <xref target="RFC4301" />.
          </t>

        </section>
        <section title="Lifetimes and Timers">
          <t>
            HIP does not negotiate any lifetimes.  All ESP lifetimes are
            local policy.  The only lifetimes a HIP implementation MUST
            support are sequence number rollover (for replay
            protection), and SHOULD support timing out inactive ESP SAs.
            An SA times out if no packets are received using that SA.
            Implementations SHOULD support a configurable SA timeout
            value.  Implementations MAY support lifetimes for the
            various ESP transforms.  Each implementation SHOULD
            implement per-HIT configuration of the inactivity timeout,
            allowing statically configured HIP associations to stay
            alive for days, even when inactive.  
          </t>

        </section>

      </section>

      <section title="IPsec and HIP ESP Implementation Considerations">
        <t>
          When HIP is run on a node where a standards compliant IPsec is
          used, some issues have to be considered.
        </t>
        <t>
          The HIP implementation must be able to co-exist with other
          IPsec keying protocols.  When the HIP implementation selects
          the SPI value, it may lead to a collision if not implemented
          properly.  To avoid the possibility for a collision, the HIP
          implementation MUST ensure that the SPI values used for HIP 
          SAs are not used for IPsec or other SAs, and vice versa.
        </t>

        <t>
          Incoming packets using an SA that is not negotiated by HIP
          MUST NOT be processed as described in 
          <xref target="sec_esp_packet"/>, paragraph 2.  The SPI will
          identify the correct SA for packet decryption and MUST be
          used to identify that the packet has an upper-layer checksum
          that is calculated as specified in <xref target="RFC7401"/>.
        </t>
        <section title="Data Packet Processing Considerations">
          <t>
            For outbound traffic, the SPD (or coordinated SPDs, if there are
            two -- one for HIP and one for IPsec) MUST ensure that packets
            intended for HIP processing are given a HIP-enabled SA and that
            packets intended for IPsec processing are given an IPsec-enabled
            SA. The SP then MUST be bound to the matching
            SA, and non-HIP packets will not be processed by this SA.  Data
            originating from a socket that is not using HIP MUST NOT have
            the checksum recalculated (as described in
            <xref target="sec_esp_packet"/>, paragraph 2), and data
            MUST NOT be passed to the SP or SA created by HIP.
          </t>
          <t>
            It is possible that in the case of overlapping policies, the
            outgoing packet would be handled by both IPsec and HIP. In
            this case, it is possible that the HIP association is
            end to end, while the IPsec SA is for encryption between the
            HIP host and a security gateway. In the case of a security
            gateway ESP association, the ESP always uses tunnel mode. 
          </t>
          <t>
            In the case of IPsec tunnel mode, it is hard to see during the
            HIP SA processing if the IPsec ESP SA has the same final
            destination.  Thus, traffic MUST be encrypted with both the
            HIP ESP SA and the IPsec SA when the IPsec ESP SA is
            used in tunnel mode.
          </t>
          <t>
            In the case of IPsec transport mode, the connection endpoints
            are the same.  However, for HIP data packets it is not
            possible to avoid HIP SA processing, while mapping the HIP
            data packet's IP addresses to the corresponding HITs
            requires SPI values from the ESP header.  In the case of a
            transport mode IPsec SA, the IPsec encryption MAY be skipped
            to avoid double encryption, if the local policy allows.
          </t>
        </section>
        <section title="HIP Signaling Packet Considerations">
          <t>
            In general, HIP signaling packets should follow the same 
            processing as HIP data packets.  
          </t>
          <t>
            In the case of IPsec tunnel mode, the HIP signaling packets 
            are always encrypted using an IPsec ESP SA.  Note that this
            hides the HIP signaling packets from the eventual HIP 
            middleboxes on the path between the originating host and
            the security gateway. 
          </t>
          <t>
            In the case of IPsec transport mode, the HIP signaling packets
            MAY skip the IPsec ESP SA encryption if the local policy
            allows.  This allows the eventual HIP middleboxes to handle
            the passing HIP signaling packets. 
          </t>
        </section>

      </section>

    </section>
    

    <section anchor="proto" title="The Protocol">
      <t>
        In this section, the protocol for setting up an ESP association
        to be used with a HIP association is described.
      </t>


      <section title="ESP in HIP">
        <section title="IPsec ESP Transport Format Type">
          <t>
            The HIP handshake signals the TRANSPORT_FORMAT_LIST
            parameter in the R1 and I2 messages. This parameter contains
            a list of the supported HIP transport formats of the sending
            host, in the order of preference. The transport format type
            for IPsec ESP is the type number of the ESP_TRANSFORM
            parameter, i.e., 4095.
          </t>
        
      </section>

        <section title="Setting Up an ESP Security Association">

          <t>
            Setting up an ESP Security Association between hosts using
            HIP is performed by including parameters in the last three
            messages (R1, I2, and R2 messages) of the four-message HIP
            base exchange.
          </t>

          <figure>
            <artwork>
          Initiator                             Responder

                                I1
                ----------------------------------&gt;

                          R1: ESP_TRANSFORM 
                &lt;----------------------------------

                    I2: ESP_TRANSFORM, ESP_INFO
                ----------------------------------&gt;

                            R2: ESP_INFO 
                &lt;----------------------------------
            </artwork>      
          </figure>

          <t>
            The R1 message contains the ESP_TRANSFORM parameter, in
            which the sending host defines the possible ESP transforms
            it is willing to use for the ESP SA.
          </t>

          <t>
            Including the ESP_TRANSFORM parameter in the R1 message adds
            clarity to the TRANSPORT_FORMAT_LIST but may initiate
            negotiations for possibly unselected transforms. However,
            resource-constrained devices will most likely restrict
            support to a single transform for the sake of minimizing ROM
            overhead, and the additional parameter adds negligible
            overhead with unconstrained devices.
          </t>
          
          <t>
            The I2 message contains the response to an ESP_TRANSFORM
            received in the R1 message.  The sender must select one of
            the proposed ESP transforms from the ESP_TRANSFORM parameter
            in the R1 message and include the selected one in the
            ESP_TRANSFORM parameter in the I2 packet.  In addition to
            the transform, the host includes the ESP_INFO parameter
            containing the SPI value to be used by the peer host.
          </t>
          
          <t>
            In the R2 message, the ESP SA setup is finalized.  The
            packet contains the SPI information required by the
            Initiator for the ESP SA.
          </t>


        </section>
        <section title="Updating an Existing ESP SA">
          <t>
            The update process is accomplished using three messages. The
            HIP UPDATE message is used to update the parameters of an
            existing ESP SA.  The UPDATE mechanism and message are
            defined in <xref target="RFC7401"/>, and the additional
            parameters for updating an existing ESP SA are described here.
          </t>
          <t>
            The following picture shows a typical exchange when an
            existing ESP SA is updated.  Messages include SEQ and ACK
            parameters required by the UPDATE mechanism.
          </t>
          <figure>
            <artwork>
    H1                                                        H2
         UPDATE: SEQ, ESP_INFO [, DIFFIE_HELLMAN]
       -----------------------------------------------------&gt;

         UPDATE: SEQ, ACK, ESP_INFO [, DIFFIE_HELLMAN]
       &lt;-----------------------------------------------------

         UPDATE: ACK
       -----------------------------------------------------&gt;
            </artwork>      
          </figure>

          
          <t>
            The host willing to update the ESP SA creates and sends an
            UPDATE message.  The message contains the ESP_INFO parameter
            containing the old SPI value that was used, the new SPI
            value to be used, and the index value for the keying
            material, giving the point from where the next keys will be
            drawn.  If new keying material must be generated, the UPDATE
            message will also contain the DIFFIE_HELLMAN parameter
            defined in <xref target="RFC7401"/>.
          </t>

          <t>
            The host receiving the UPDATE message requesting update of
            an existing ESP SA MUST reply with an UPDATE message.  In
            the reply message, the host sends the ESP_INFO parameter
            containing the corresponding values: old SPI, new SPI, and
            the keying material index.  If the incoming UPDATE contained
            a DIFFIE_HELLMAN parameter, the reply packet MUST also
            contain a DIFFIE_HELLMAN parameter.
          </t>
          
        </section>
      </section>
    </section>
    
    <section anchor="packets" title="Parameter and Packet Formats">
      <t>
        In this section, new and modified HIP parameters are presented,
        as well as modified HIP packets. 
      </t>
      
      <section title="New Parameters">
        <t>
          Two HIP parameters are defined for setting up ESP transport
          format associations in HIP communication and for rekeying
          existing ones.  Also, the NOTIFICATION parameter, described
          in <xref target="RFC7401"/>, has two error values defined
          for this specification.
        </t>

        <figure>
          <artwork>
   Parameter         Type  Length     Data

   ESP_INFO          65    12         Remote's old SPI, 
                                      new SPI, and other info
   ESP_TRANSFORM     4095  variable   ESP Encryption and
                                      Authentication Transform(s)
          </artwork>
        </figure>
        <section anchor="espinfo" title="ESP_INFO">

          <t>
            During the establishment and update of an ESP SA, the SPI
            value of both hosts must be transmitted between the hosts.
            In addition, hosts need the index value to the KEYMAT when
            they are drawing keys from the generated keying material.
            The ESP_INFO parameter is used to transmit the SPI values
            and the KEYMAT index information between the hosts.
          </t>
            
          <t>
            During the initial ESP SA setup, the hosts send the SPI
            value that they want the peer to use when sending ESP data
            to them.  The value is set in the NEW SPI field of the
            ESP_INFO parameter.  In the initial setup, an old value
            for the SPI does not exist; thus, the OLD SPI field value
            is set to zero.  The OLD SPI field value may also be zero
            when additional SAs are set up between HIP hosts,
            e.g., in the case of multihomed HIP hosts <xref
            target="RFC5206" />.  However, such use is beyond
            the scope of this specification.
          </t>

          <t>
            The KEYMAT index value points to the place in the KEYMAT from
            where the keying material for the ESP SAs is drawn.  The
            KEYMAT index value is zero only when the ESP_INFO is sent
            during a rekeying process and new keying material is 
            generated.
          </t>
          
          <t>
            During the life of an SA established by HIP, one of the
            hosts may need to reset the Sequence Number to one and
            rekey.  The reason for rekeying might be an approaching
            sequence number wrap in ESP, or a local policy on the use
            of a key.  Rekeying ends the current SAs and starts new
            ones on both peers.
          </t>
          <t>
            During the rekeying process, the ESP_INFO parameter is used
            to transmit the changed SPI values and the keying material
            index.
          </t>
          
          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Reserved            |         KEYMAT Index          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            OLD SPI                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            NEW SPI                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type           65
   Length         12
   KEYMAT Index   index, in bytes, where to continue to draw ESP keys
                  from KEYMAT.  If the packet includes a new
                  Diffie-Hellman key and the ESP_INFO is sent in an
                  UPDATE packet, the field MUST be zero.  If the 
                  ESP_INFO is included in base exchange messages, the
                  KEYMAT Index must have the index value of the point 
                  from where the ESP SA keys are drawn.  Note that 
                  the length of this field limits the amount of
                  keying material that can be drawn from KEYMAT.  If
                  that amount is exceeded, the packet MUST contain
                  a new Diffie-Hellman key. 
   OLD SPI        old SPI for data sent to address(es) associated
                  with this SA.  If this is an initial SA setup, the
                  OLD SPI value is zero.
   NEW SPI        new SPI for data sent to address(es) associated
                  with this SA.
            </artwork>
          </figure>

        </section>
        <section anchor="esptransform" title="ESP_TRANSFORM">
          <t>
            The ESP_TRANSFORM parameter is used during ESP SA
            establishment.  The first party sends a selection of
            transform families in the ESP_TRANSFORM parameter, and the
            peer must select one of the proposed values and include it
            in the response ESP_TRANSFORM parameter.
          </t>
            
          <figure>
            <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Type              |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Reserved             |           Suite ID #1         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Suite ID #2          |           Suite ID #3         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Suite ID #n          |             Padding           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Type           4095
   Length         length in octets, excluding Type, Length, and 
                  padding.
   Reserved       zero when sent, ignored when received.
   Suite ID       defines the ESP Suite to be used.
            </artwork>
          </figure>

          <t>
            The following Suite IDs can be used:
          </t>

          <figure>
            <artwork>
         Suite ID                          Value

         RESERVED                          0   [RFC7402]
         AES-128-CBC with HMAC-SHA1        1   [RFC3602], [RFC2404]
         DEPRECATED                        2   [RFC7402]
         DEPRECATED                        3   [RFC7402]
         DEPRECATED                        4   [RFC7402]
         DEPRECATED                        5   [RFC7402]
         DEPRECATED                        6   [RFC7402]
         NULL with HMAC-SHA-256            7   [RFC2410], [RFC4868]
         AES-128-CBC with HMAC-SHA-256     8   [RFC3602], [RFC4868]
         AES-256-CBC with HMAC-SHA-256     9   [RFC3602], [RFC4868]
         AES-CCM-8                         10  [RFC4309]
         AES-CCM-16                        11  [RFC4309]
         AES-GCM with an 8-octet ICV       12  [RFC4106]
         AES-GCM with a 16-octet ICV       13  [RFC4106]
         AES-CMAC-96                       14  [RFC4493], [RFC4494]
         AES-GMAC                          15  [RFC4543]
            </artwork>
          </figure>
          <t>
            The sender of an ESP transform parameter MUST make sure that
            there are no more than six (6) Suite IDs in one ESP
            transform parameter.  Conversely, a recipient MUST be
            prepared to handle received transform parameters that
            contain more than six Suite IDs.  The limited number of
            Suite IDs sets the maximum size of the ESP_TRANSFORM parameter.
            As the default configuration, the ESP_TRANSFORM parameter
            MUST contain at least one of the mandatory Suite IDs.  There
            MAY be a configuration option that allows the administrator
            to override this default.
          </t>
          <t>
            Mandatory implementations: AES-128-CBC with HMAC-SHA-256.
            NULL with HMAC-SHA-256 SHOULD also be supported (see also
            <xref target="supported_ciphers" />).
          </t>

          <t>
            Under some conditions, it is possible to use Traffic Flow
            Confidentiality (TFC) <xref target="RFC4303" /> with ESP in
            BEET mode. However, the definition of such an operation is
            left for future work and must be done in a separate
            specification.
          </t>
        </section>


        <section anchor="notify_pars" title="NOTIFICATION Parameter">
          <t>
            The HIP base specification defines a set of NOTIFICATION
            error types.  The following error types are required for
            describing errors in ESP Transform crypto suites during
            negotiation.
          </t>
          <figure>
            <artwork>
      NOTIFICATION PARAMETER - ERROR TYPES     Value
      ------------------------------------     -----

      NO_ESP_PROPOSAL_CHOSEN                    18

         None of the proposed ESP Transform crypto suites was
         acceptable.

      INVALID_ESP_TRANSFORM_CHOSEN              19

         The ESP Transform crypto suite does not correspond to
         one offered by the Responder.
            </artwork>
          </figure>
        </section>
      </section>
      
      <section title="HIP ESP Security Association Setup">

        <t>
          The ESP Security Association is set up during the base
          exchange.  The following subsections define the ESP SA setup
          procedure using both base exchange messages (R1, I2, R2) and
          UPDATE messages.
        </t>

        <section title="Setup during Base Exchange">
          <section anchor="modr1" title="Modifications in R1">
            
            <t>
              The ESP_TRANSFORM contains the ESP modes supported by the
              sender, in the order of preference.  All implementations
              MUST support AES-128-CBC <xref target="RFC3602" /> with
              HMAC-SHA-256 <xref target="RFC4868" />.
            </t>
            
            <t>
              The following figure shows the resulting R1 packet layout.
            </t>
            <figure>
              <artwork>
   The HIP parameters for the R1 packet:

   IP ( HIP ( [ R1_COUNTER, ]
              PUZZLE,
              DIFFIE_HELLMAN,
              HIP_CIPHER,
              ESP_TRANSFORM,
              HOST_ID,
              [ ECHO_REQUEST, ]
              HIP_SIGNATURE_2 )
              [, ECHO_REQUEST ])
              </artwork>
            </figure>
            
          </section> 

          <section anchor="modi2" title="Modifications in I2">
            <t>
              The ESP_INFO contains the sender's SPI for this association
              as well as the KEYMAT index from where the ESP SA keys will
              be drawn.  The old SPI value is set to zero.
            </t>
            <t>
              The ESP_TRANSFORM contains the ESP mode selected by the
              sender of R1.  All implementations MUST support AES-128-CBC
              <xref target="RFC3602" /> with HMAC-SHA-256 <xref
              target="RFC4868" />.
            </t>
            <t>
              The following figure shows the resulting I2 packet layout.
            </t>
            
            <figure>
              <artwork>
   The HIP parameters for the I2 packet:

   IP ( HIP ( ESP_INFO,
              [R1_COUNTER,]
              SOLUTION,
              DIFFIE_HELLMAN,
              HIP_CIPHER,
              ESP_TRANSFORM,
              ENCRYPTED { HOST_ID },
              [ ECHO_RESPONSE ,]
              HMAC,
              HIP_SIGNATURE
              [, ECHO_RESPONSE] ) )
              </artwork>
            </figure>
            
          </section>

          <section anchor="modr2" title="Modifications in R2">
            
            <t>
              The R2 contains an ESP_INFO parameter, which
              has the SPI value of the sender of the R2 for
              this association.  The ESP_INFO also has the KEYMAT index
              value specifying where the ESP SA keys are drawn.
            </t>
            
            <t>
              The following figure shows the resulting R2 packet layout.
            </t>
            
            <figure>
              <artwork>
   The HIP parameters for the R2 packet:

   IP ( HIP ( ESP_INFO, HMAC_2, HIP_SIGNATURE ) )
              </artwork>
            </figure>


          </section>
          
        </section>
      </section>
      <section anchor="hip_her" title="HIP ESP Rekeying">
        <t>
          In this section, the procedure for rekeying an existing ESP SA
          is presented. 
        </t>
        <t>
          Conceptually, the process can be represented by the
          following message sequence using the host names I' and R'
          defined in <xref target="esp_rekeying" />.  For simplicity,
          HMAC and HIP_SIGNATURE are not depicted, and DIFFIE_HELLMAN
          keys are optional.  The UPDATE with ACK_I need not be
          piggybacked with the UPDATE with SEQ_R; it may be ACKed
          separately (in which case the sequence would include four
          packets).
        </t>

        <figure>
          <artwork>
        I'                                  R'
 
              UPDATE(ESP_INFO, SEQ_I, [DIFFIE_HELLMAN])
         -----------------------------------&gt;
              UPDATE(ESP_INFO, SEQ_R, ACK_I, [DIFFIE_HELLMAN])
         &lt;-----------------------------------
              UPDATE(ACK_R)
         -----------------------------------&gt;
          </artwork>
        </figure>

          <t>
            Below, the first two packets in this figure are explained.
          </t>
        <section title="Initializing Rekeying">
          <t>
            When HIP is used with ESP, the UPDATE packet is used to
            initiate rekeying.  The UPDATE packet MUST carry an ESP_INFO
            and MAY carry a DIFFIE_HELLMAN parameter.
          </t>
          <t>
            Intermediate systems that use the SPI will have to inspect
            HIP packets for those that carry rekeying information.  The
            packet is signed for the benefit of the intermediate
            systems.  Since intermediate systems may need the new SPI
            values, the contents cannot be encrypted.
          </t>
          <t>
            The following figure shows the contents of a rekeying
            initialization UPDATE packet.
          </t>
          <figure>
            <artwork>
   The HIP parameters for the UPDATE packet initiating rekeying: 

   IP ( HIP ( ESP_INFO,
              SEQ, 
              [DIFFIE_HELLMAN, ] 
              HMAC, 
              HIP_SIGNATURE ) )
            </artwork>
          </figure>


        </section>
        <section title="Responding to the Rekeying Initialization">
          <t>
            The UPDATE ACK is used to acknowledge the received UPDATE
            rekeying initialization.  The acknowledgment UPDATE packet
            MUST carry an ESP_INFO and MAY carry a DIFFIE_HELLMAN
            parameter.
          </t>
          <t>
            Intermediate systems that use the SPI will have to inspect
            HIP packets for packets carrying rekeying information.  The
            packet is signed for the benefit of the intermediate
            systems.  Since intermediate systems may need the new SPI
            values, the contents cannot be encrypted.
          </t>
          <t>
            The following figure shows the contents of a rekeying
            acknowledgment UPDATE packet.
          </t>
          <figure>
            <artwork>
   The HIP parameters for the UPDATE packet:

   IP ( HIP ( ESP_INFO, 
              SEQ,
              ACK, 
              [ DIFFIE_HELLMAN, ] 
              HMAC, 
              HIP_SIGNATURE ) )
            </artwork>
          </figure>
        </section>
      </section>

      <section anchor="ICMP" title="ICMP Messages">
        <t>
          ICMP message handling is mainly described in the HIP base
          specification <xref target="RFC7401"/>.
          In this section, we describe the actions related to ESP
          security associations.
        </t>
        <section title="Unknown SPI">
          <t>
            If a HIP implementation receives an ESP packet that has an
            unrecognized SPI number, it MAY respond (subject to rate
            limiting the responses) with an ICMP packet with type
            "Parameter Problem", with the pointer pointing to the
            beginning of the SPI field in the ESP header.
          </t>
        </section>
      </section>
    </section>
    
    
    <section anchor="handling" title="Packet Processing">
      <t>
        Packet processing is mainly defined in the HIP base
        specification <xref target="RFC7401"/>.
        This section describes the changes and new requirements for
        packet handling when the ESP transport format is used.  Note
        that all HIP packets (currently protocol 139) MUST bypass ESP
        processing.
      </t>


      <section title="Processing Outgoing Application Data">
        <t>
          Outgoing application data handling is specified in the HIP
          base specification <xref target="RFC7401"/>.  When the ESP
          transport format is used, and there is an active HIP session
          for the given &lt; source, destination &gt; HIT pair, the outgoing
          datagram is protected using the ESP security association.
          The following additional steps define the conceptual processing
          rules for outgoing ESP protected datagrams.
            
          <list style="numbers">
            <t>
              Detect the proper ESP SA using the HITs in the packet
              header or other information associated with the packet.
            </t>
            <t>
              Process the packet normally, as if the SA was a
              transport mode SA.
            </t>
            <t>
              Ensure that the outgoing ESP protected packet has proper
              IP header format, depending on the used IP address family,
              and proper IP addresses in its IP header, e.g., by
              replacing HITs left by the ESP processing.  Note that this
              placement of proper IP addresses MAY also be performed at
              some other point in the stack, e.g., before ESP
              processing.
            </t>
          </list> 
        </t>
      </section>

      <section title="Processing Incoming Application Data">
        <t>
          Incoming HIP user data packets arrive as ESP protected
          packets.  In the usual case, the receiving host has a
          corresponding ESP security association, identified by the SPI
          and destination IP address in the packet.  However, if the
          host has crashed or otherwise lost its HIP state, it may not
          have such an SA.
        </t>

        <t>
          The basic incoming data handling is specified in the HIP base
          specification.  Additional steps are required when ESP is used
          for protecting the data traffic.  The following steps define
          the conceptual processing rules for incoming ESP
          protected datagrams targeted to an ESP security association
          created with HIP.
          
          <list style="numbers">
            <t>
              Detect the proper ESP SA using the SPI. If the
              resulting SA is a non-HIP ESP SA, process the packet
              according to standard IPsec rules.  If there are no SAs
              identified with the SPI, the host MAY send an ICMP packet
              as defined in <xref target="ICMP" />.  How to handle lost
              state is an implementation issue.
            </t>
            <t>
              If the SPI matches with an active HIP-based ESP SA, 
              the IP addresses in the datagram are replaced with the
              HITs associated with the SPI.  Note that this
              IP-address-to-HIT conversion step MAY also be performed at
              some other point in the stack, e.g., after ESP
              processing. Note also that if the incoming packet has
              IPv4 addresses, the packet must be converted to IPv6
              format before replacing the addresses with HITs (such
              that the transport checksum will pass if there are no errors).
            </t>
            <t>
              The transformed packet is next processed normally
              by ESP, as if the packet were a transport mode
              packet.  The packet may be dropped by ESP, as usual.  In a
              typical implementation, the result of successful ESP
              decryption and verification is a datagram with the
              associated HITs as source and destination. 
            </t>
            <t>
              The datagram is delivered to the upper layer.
              Demultiplexing the datagram to the right upper-layer
              socket is performed as usual, except that the HITs
              are used in place of IP addresses during the demultiplexing.
            </t>
          </list>
        </t>
      </section>
      
      <section title="HMAC and SIGNATURE Calculation and Verification">
        <t>
          The new HIP parameters described in this document, ESP_INFO
          and ESP_TRANSFORM, must be protected using HMAC and signature
          calculations.  In a typical implementation, they are included
          in R1, I2, R2, and UPDATE packet HMAC and SIGNATURE calculations
          as described in <xref target="RFC7401"/>.
        </t>
      </section>
      
      <section anchor="inr1" 
        title="Processing Incoming ESP SA Initialization (R1)">
        <t>
          The ESP SA setup is initialized in the R1 message.  The
          receiving host (Initiator) selects one of the ESP transforms from the
          presented values.  If no suitable value is found, the
          negotiation is terminated.  The selected values are
          subsequently used when generating and using encryption keys,
          and when sending the reply packet.  If the proposed
          alternatives are not acceptable to the system, it may abandon
          the ESP SA establishment negotiation, or it
          may resend the I1 message within the retry bounds.
        </t>

        <t>
          After selecting the ESP transform and performing other R1
          processing, the system prepares and creates
          an incoming ESP security association.  It may also prepare
          a security association for outgoing traffic, but since it does
          not have the correct SPI value yet, it cannot activate it. 
        </t>

        
      </section>
      
      <section anchor="ini2"
        title="Processing Incoming Initialization Reply (I2)">
        
        <t>
          The following steps are required to process the incoming ESP SA
          initialization replies in I2.  The steps below assume that
          the I2 has been accepted for processing (e.g., has not
          been dropped due to HIT comparisons as described in 
          <xref target="RFC7401"/>).

          <list style="symbols">
            
            <t>
              The ESP_TRANSFORM parameter is verified, and it MUST
              contain a single value in the parameter; and it MUST
              match one of the values offered in the initialization packet.
            </t>
            <t>
              The ESP_INFO NEW SPI field is parsed to obtain the SPI
              that will be used for the Security Association outbound
              from the Responder and inbound to the Initiator.  For
              this initial ESP SA establishment, the old SPI value
              MUST be zero.  The KEYMAT Index field MUST contain
              the index value to the KEYMAT from where the ESP SA
              keys are drawn.
            </t>
            <t>
              The system prepares and creates both incoming and outgoing
              ESP security associations.
            </t>
            <t>
              Upon successful processing of the initialization reply
              message, the possible old Security Associations (as left
              over from an earlier incarnation of the HIP association)
              are dropped and the new ones are installed, and a
              finalizing packet, R2, is sent.  Possible ongoing rekeying
              attempts are dropped.
            </t>

          </list>
        </t>
        
      </section>
      
      <section anchor="inr2" title="Processing Incoming ESP SA Setup Finalization (R2)">
        <t>
          Before the ESP SA can be finalized, the ESP_INFO NEW SPI field
          is parsed to obtain the SPI that will be used for the ESP
          Security Association inbound to the sender of the finalization
          message R2.  The system uses this SPI to create or activate the
          outgoing ESP security association used for sending packets to
          the peer.
        </t>
      </section>
      
      <section title="Dropping HIP Associations">
        <t> 
          When the system drops a HIP association, as described in the HIP
          base specification, the associated ESP SAs MUST also be dropped.
        </t>
      </section>
      
      <section anchor="association_update" title="Initiating ESP SA Rekeying">

        <t>
          During ESP SA rekeying, the hosts draw new keys from the 
          existing keying material, or new keying material is generated
          from where the new keys are drawn. 
        </t>
        
        <t>
          A system may initiate the SA rekeying procedure at any time.  It
          MUST initiate a rekey if its incoming ESP sequence counter is
          about to overflow.  The system MUST NOT replace its keying
          material until the rekeying packet exchange successfully
          completes.
        </t>
        <t>
          Optionally, a system may include a new Diffie-Hellman key for
          use in new KEYMAT generation.  New KEYMAT generation occurs
          prior to drawing the new keys.
        </t>


        <t>
          The rekeying procedure uses the UPDATE mechanism defined in
          <xref target="RFC7401"/>.  Because each
          peer must update its half of the security association pair
          (including new SPI creation), the rekeying process requires
          that each side both send and receive an UPDATE.  A system will
          then rekey the ESP SA when it has sent parameters to the peer
          and has received both an ACK of the relevant UPDATE message
          and corresponding peer's parameters.  It may be that the ACK
          and the required HIP parameters arrive in different UPDATE
          messages.  This is always true if a system does not initiate an
          ESP SA update but responds to an update request from the peer,
          and may also occur if two systems initiate update nearly
          simultaneously.  In such a case, if the system has an
          outstanding update request, it saves the one parameter and
          waits for the other before completing rekeying.
        </t>


        <t>
          The following steps define the processing rules for
          initiating an ESP SA update:
          
          <list style="numbers">
            
            <t>
              The system decides whether to continue to use the existing
              KEYMAT or to generate a new KEYMAT.  In the latter case, the
              system MUST generate a new Diffie-Hellman public key.
            </t>
            <t>
              The system creates an UPDATE packet, which contains the
              ESP_INFO parameter.  In addition, the host may include the
              optional DIFFIE_HELLMAN parameter.  If the UPDATE contains
              the DIFFIE_HELLMAN parameter, the KEYMAT Index in the
              ESP_INFO parameter MUST be zero, and the Diffie-Hellman
              Group ID must be unchanged from that used in the initial
              handshake.  If the UPDATE does not
              contain DIFFIE_HELLMAN, the ESP_INFO KEYMAT Index MUST be
              greater than or equal to the index of the next byte to be drawn
              from the current KEYMAT.
            </t>

            <t>
              The system sends the UPDATE packet. For reliability, the
              underlying UPDATE retransmission mechanism MUST be used.
            </t>

            <t>
              The system MUST NOT delete its existing SAs, but continue
              using them if its policy still allows.  The rekeying
              procedure SHOULD be initiated early enough to make sure
              that the SA replay counters do not overflow.
            </t>

            <t>
              In case a protocol error occurs and the peer system
              acknowledges the UPDATE but does not itself send an
              ESP_INFO, the system may not finalize the outstanding ESP
              SA update request.  To guard against this, a system MAY
              re-initiate the ESP SA update procedure after some time
              waiting for the peer to respond, or it MAY decide to abort
              the ESP SA after waiting for an implementation-dependent
              time.  The system MUST NOT keep an outstanding ESP SA
              update request for an indefinite time.
            </t>

          </list>
        </t>

        <t>
          To simplify the state machine, a host MUST NOT generate new
          UPDATEs while it has an outstanding ESP SA update request,
          unless it is restarting the update process.
        </t>
      
      </section>

      <section anchor="processing_her1"
        title="Processing Incoming UPDATE Packets">
        
        <t>
          When a system receives an UPDATE packet, it must be processed
          if the following conditions hold (in addition to the generic
          conditions specified for UPDATE processing in Section 6.12 of
          <xref target="RFC7401"/>):
          <list style="numbers">
            <t>
              A corresponding HIP association must exist.  This is
              usually ensured by the underlying UPDATE mechanism.
            </t>
            <t>
              The state of the HIP association is ESTABLISHED or R2-SENT.
            </t>
          </list>
        </t>
        <t>
          If the above conditions hold, the following steps define
          the conceptual processing rules for handling the received
          UPDATE packet:
          <list style="numbers">
            <t>
              If the received UPDATE contains a DIFFIE_HELLMAN
              parameter, the received KEYMAT Index MUST be zero and the
              Group ID must match the Group ID in use on the
              association.  If this test fails, the packet SHOULD be
              dropped and the system SHOULD log an error message.
            </t>
 
            <t>
              If there is no outstanding rekeying request, the packet
              processing continues as specified in <xref
              target="NES-first" />.
            </t>
            <t>
              If there is an outstanding rekeying request, the UPDATE
              MUST be acknowledged, the received ESP_INFO (and possibly
              DIFFIE_HELLMAN) parameters must be saved, and the packet
              processing continues as specified in <xref
              target="leave-rekey" />.
            </t>
          </list>
        </t>
        <section anchor="NES-first" title="Processing UPDATE Packet: No
Outstanding Rekeying Request">
          <t>
            The following steps define the conceptual processing rules
            for handling a received UPDATE packet with the ESP_INFO
            parameter:
            <list style="numbers">

              <t>
                The system consults its policy to see if it needs to
                generate a new Diffie-Hellman key, and generates a new
                key (with same Group ID) if needed.  The system records 
                any newly generated
                or received Diffie-Hellman keys for use in KEYMAT
                generation upon finalizing the ESP SA update.
              </t>
              <t>
                If the system generated a new Diffie-Hellman key in
                the previous step, or if it received a DIFFIE_HELLMAN
                parameter, it sets the ESP_INFO KEYMAT Index to zero.
                Otherwise, the ESP_INFO KEYMAT Index MUST be greater than
                or equal to the index of the next byte to be drawn
                from the current KEYMAT.  In this case, it is
                RECOMMENDED that the host use the KEYMAT Index
                requested by the peer in the received ESP_INFO.
              </t>
              <t>
                The system creates an UPDATE packet, which contains an
                ESP_INFO parameter and the optional DIFFIE_HELLMAN
                parameter.  This UPDATE would also typically
                acknowledge the peer's UPDATE with an ACK parameter,
                although a separate UPDATE ACK may be sent.
              </t>
              <t>
                The system sends the UPDATE packet and stores any
                received ESP_INFO and DIFFIE_HELLMAN parameters.  At
                this point, it only needs to receive an
                acknowledgment for the newly sent UPDATE to finish
                the ESP SA update.  In the usual case, the
                acknowledgment is handled by the underlying UPDATE
                mechanism.
              </t>
            </list>
          </t>
        </section>
        
      </section>

      <section anchor="leave-rekey" title="Finalizing Rekeying">
        <t>
          A system finalizes rekeying when it has both received the
          corresponding UPDATE acknowledgment packet from the peer and
          successfully received the peer's UPDATE.  The following steps
          are taken:
          <list style="numbers">
            <t>
              If the received UPDATE messages contain a new
              Diffie-Hellman key, the system has a new Diffie-Hellman
              key due to initiating an ESP SA update, or both, the
              system generates a new KEYMAT.  If there is only one new
              Diffie-Hellman key, the old existing key is used as the
              other key.
            </t>
            <t>
              If the system generated a new KEYMAT in the previous step,
              it sets the KEYMAT Index to zero, independent of whether the
              received UPDATE included a Diffie-Hellman key or not.  If
              the system did not generate a new KEYMAT, it uses the
              greater KEYMAT Index of the two (sent and received) 
              ESP_INFO parameters.
            </t>
            <t>
              The system draws keys for new incoming and outgoing ESP
              SAs, starting from the KEYMAT Index, and prepares new
              incoming and outgoing ESP SAs.  The SPI for the outgoing
              SA is the new SPI value received in an ESP_INFO parameter.
              The SPI for the incoming SA was generated when the
              ESP_INFO was sent to the peer.  The order of the keys
              retrieved from the KEYMAT during the rekeying process is
              similar to that described in <xref target="key"/>.  Note
              that only IPsec ESP keys are retrieved during the rekeying
              process, not the HIP keys.
            </t>
            <t>
              The system starts to send to the new outgoing SA and
              prepares to start receiving data on the new incoming SA.
              Once the system receives data on the new incoming SA, it
              may safely delete the old SAs.
            </t>

          </list>
        </t>
      </section>


      <section title="Processing NOTIFY Packets">
        <t>
          The processing of NOTIFY packets is described in the HIP base
          specification.
        </t>
      </section>
      

    </section>


    <section anchor="key" title="Keying Material">
      <t>
        The keying material is generated as described in the HIP base
        specification.  During the base exchange, the initial keys are
        drawn from the generated material. After the HIP association
        keys have been drawn, the ESP keys are drawn in the following
        order:
  
        <list>
          <t>SA-gl ESP encryption key for HOST_g's outgoing
            traffic</t>
          <t>SA-gl ESP authentication key for HOST_g's outgoing
            traffic</t>
          <t>SA-lg ESP encryption key for HOST_l's outgoing
            traffic</t>
          <t>SA-lg ESP authentication key for HOST_l's outgoing
            traffic</t>
        </list>
      </t>
      <t>
        HOST_g denotes the host with the greater HIT value, and HOST_l
        denotes the host with the lower HIT value.  When HIT values are
        compared, they are interpreted as positive (unsigned) 128-bit
        integers in network byte order.  
      </t>
      <t>
        The four HIP keys are only drawn from KEYMAT during a HIP I1->R2
        exchange.  Subsequent rekeys using UPDATE will only draw the
        four ESP keys from KEYMAT.  <xref target="processing_her1" />
        describes the rules for reusing or regenerating KEYMAT based on
        the rekeying.  </t>

      <t>
        The number of bits drawn for a given algorithm is the "natural" size
        of the keys, as specified in Section 6.5 of <xref target="RFC7401"/>.
      </t>
    </section>

    <section title="Security Considerations">
      <t>
        In this document, the usage of ESP <xref
        target="RFC4303" /> between HIP hosts to protect
        data traffic is introduced.  The security considerations
        for ESP are discussed in the ESP specification.
      </t>

      <t>
        There are different ways to establish an ESP Security
        Association between two nodes.  This can be done, e.g., using IKE
        <xref target="RFC7296" />.  This document specifies how the Host
        Identity Protocol is used to establish ESP Security
        Associations. 
      </t>

      <t>
        The following issues are new or have changed from the standard
        ESP usage:
        <list style="symbols">
          <t>Initial keying material generation</t>
          <t>Updating the keying material</t>
        </list>
      </t>

      <t>
        The initial keying material is generated using the Host Identity
        Protocol <xref target="RFC7401"/> using the
        Diffie-Hellman procedure.  This document extends the usage of the
        UPDATE packet, defined in the base specification, to modify
        existing ESP SAs.  The hosts may rekey, i.e., force the generation
        of new keying material using the Diffie-Hellman procedure.
        The initial setup of ESP SAs between the hosts is done during
        the base exchange, and the message exchange is protected
        using methods provided by the base exchange.  Changes in
        connection parameters basically mean that the old ESP SA is
        removed and a new one is generated once the UPDATE message
        exchange has been completed.  The message exchange is protected
        using the HIP association keys.  Both HMAC and signing of
        packets are used. 
      </t>

    </section>

    <section title="IANA Considerations">

     <t>
       The following changes to the "Host Identity Protocol (HIP) Parameters"
       registries have been made.  In all cases, the changes updated the
       reference from <xref target="RFC5202" /> to this specification.
     </t>

      <t>
        This document defines two Parameter Types and two NOTIFY Message 
        Types for the Host Identity Protocol <xref target="RFC7401"/>.
      </t>
      <t>
        The parameters and their type numbers are defined in
        Sections <xref target="espinfo" format="counter" />
        and <xref target="esptransform" format="counter" />, and they
        have been added to the "Parameter Types" namespace created by
        <xref target="RFC7401"/>.  No new action regarding these values is
        required by this specification, other than updating the
        reference from <xref target="RFC5202" /> to this specification.
      </t>

      <t>
        The new NOTIFICATION error types and their values are defined
        in <xref target="notify_pars" />, and they have been added to the
        "Notify Message Types" namespace created by <xref target="RFC7401"/>.
        No new action regarding these values is required by this
        specification, other than updating the
        reference from <xref target="RFC5202" /> to this specification.
      </t>

      <t>
      <xref target="esptransform"/> of this document defines values
      for "ESP Transform Suite IDs", which are registered in a new
      IANA registry, with an "IETF Review" registration
      procedure <xref target="RFC5226" /> for new values.
      </t>
      
    </section>
   
  </middle>
  
  <back>

    <references title="Normative References">

<reference anchor='RFC2119' target="http://www.rfc-editor.org/info/rfc2119">
<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
</author>
<date year='1997' month='March' />
</front>
<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
</reference>

<reference anchor='RFC2404' target="http://www.rfc-editor.org/info/rfc2404">
<front>
<title>The Use of HMAC-SHA-1-96 within ESP and AH</title>
<author initials='C.' surname='Madson' fullname='Cheryl Madson'>
<organization>Cisco Systems, Inc.</organization>
<address>
<email>cmadson@cisco.com</email></address></author>
<author initials='R.' surname='Glenn' fullname='Rob Glenn'>
<organization>NIST</organization>
<address>
<email>rob.glenn@nist.gov</email></address></author>
<date year='1998' month='November' />
</front>
<seriesInfo name='RFC' value='2404' />
</reference>

<reference anchor='RFC2410' target="http://www.rfc-editor.org/info/rfc2410">
<front>
<title abbrev='NULL and IPsec'>The NULL Encryption Algorithm and Its Use With IPsec</title>
<author initials='R.' surname='Glenn' fullname='Rob Glenn'>
<organization>NIST</organization>
<address>
<email>rob.glenn@nist.gov</email></address></author>
<author initials='S.' surname='Kent' fullname='Stephen Kent'>
<organization>BBN Corporation</organization>
<address>
<email>kent@bbn.com</email></address></author>
<date year='1998' month='November' />
</front>
<seriesInfo name='RFC' value='2410' />
</reference>

<reference anchor='RFC3602' target="http://www.rfc-editor.org/info/rfc3602">
<front>
<title>The AES-CBC Cipher Algorithm and Its Use with IPsec</title>
<author initials='S.' surname='Frankel' fullname='S. Frankel'>
<organization /></author>
<author initials='R.' surname='Glenn' fullname='R. Glenn'>
<organization /></author>
<author initials='S.' surname='Kelly' fullname='S. Kelly'>
<organization /></author>
<date year='2003' month='September' />
</front>
<seriesInfo name='RFC' value='3602' />
</reference>

<reference anchor='RFC4106' target="http://www.rfc-editor.org/info/rfc4106">
<front>
<title>The Use of Galois/Counter Mode (GCM) in IPsec Encapsulating Security Payload (ESP)</title>
<author initials='J.' surname='Viega' fullname='J. Viega'>
<organization /></author>
<author initials='D.' surname='McGrew' fullname='D. McGrew'>
<organization /></author>
<date year='2005' month='June' />
</front>
<seriesInfo name='RFC' value='4106' />
</reference>

<reference anchor='RFC4303' target="http://www.rfc-editor.org/info/rfc4303">
<front>
<title>IP Encapsulating Security Payload (ESP)</title>
<author initials='S.' surname='Kent' fullname='S. Kent'>
<organization /></author>
<date year='2005' month='December' />
</front>
<seriesInfo name='RFC' value='4303' />
</reference>

<reference anchor='RFC4309' target="http://www.rfc-editor.org/info/rfc4309">
<front>
<title>Using Advanced Encryption Standard (AES) CCM Mode with IPsec Encapsulating Security Payload (ESP)</title>
<author initials='R.' surname='Housley' fullname='R. Housley'>
<organization /></author>
<date year='2005' month='December' />
</front>
<seriesInfo name='RFC' value='4309' />
</reference>

<reference anchor='RFC4868' target="http://www.rfc-editor.org/info/rfc4868">
<front>
<title>Using HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512 with IPsec</title>
<author initials='S.' surname='Kelly' fullname='S. Kelly'>
<organization /></author>
<author initials='S.' surname='Frankel' fullname='S. Frankel'>
<organization /></author>
<date year='2007' month='May' />
</front>
<seriesInfo name='RFC' value='4868' />
</reference>

<reference anchor='RFC4493' target="http://www.rfc-editor.org/info/rfc4493">
<front>
<title>The AES-CMAC Algorithm</title>
<author initials='JH.' surname='Song' fullname='JH. Song'>
<organization /></author>
<author initials='R.' surname='Poovendran' fullname='R. Poovendran'>
<organization /></author>
<author initials='J.' surname='Lee' fullname='J. Lee'>
<organization /></author>
<author initials='T.' surname='Iwata' fullname='T. Iwata'>
<organization /></author>
<date year='2006' month='June' />
</front>
<seriesInfo name='RFC' value='4493' />
</reference>

<reference anchor='RFC4494' target="http://www.rfc-editor.org/info/rfc4494">
<front>
<title>The AES-CMAC-96 Algorithm and Its Use with IPsec</title>
<author initials='JH.' surname='Song' fullname='JH. Song'>
<organization /></author>
<author initials='R.' surname='Poovendran' fullname='R. Poovendran'>
<organization /></author>
<author initials='J.' surname='Lee' fullname='J. Lee'>
<organization /></author>
<date year='2006' month='June' />
</front>
<seriesInfo name='RFC' value='4494' />
</reference>

<reference anchor='RFC4543' target="http://www.rfc-editor.org/info/rfc4543">
<front>
<title>The Use of Galois Message Authentication Code (GMAC) in IPsec ESP and AH</title>
<author initials='D.' surname='McGrew' fullname='D. McGrew'>
<organization /></author>
<author initials='J.' surname='Viega' fullname='J. Viega'>
<organization /></author>
<date year='2006' month='May' />
</front>
<seriesInfo name='RFC' value='4543' />
</reference>

<!-- draft-ietf-hip-rfc5201-bis (RFC 7401) -->
<reference anchor='RFC7401' target="http://www.rfc-editor.org/info/rfc7401">
<front>
<title>Host Identity Protocol Version 2 (HIPv2)</title>
<author initials='R' surname='Moskowitz' fullname='Robert Moskowitz' role="editor">
    <organization />
</author>
<author initials='T' surname='Heer' fullname='Tobias Heer'>
    <organization />
</author>
<author initials='P' surname='Jokela' fullname='Petri Jokela'>
    <organization />
</author>
<author initials='T' surname='Henderson' fullname='Thomas Henderson'>
    <organization />
</author>
<date month='April' year='2015' />
</front>
<seriesInfo name='RFC' value='7401' />
</reference>

    </references>
    <references title="Informative References">

<reference anchor='RFC4301' target="http://www.rfc-editor.org/info/rfc4301">
<front>
<title>Security Architecture for the Internet Protocol</title>
<author initials='S.' surname='Kent' fullname='S. Kent'>
<organization /></author>
<author initials='K.' surname='Seo' fullname='K. Seo'>
<organization /></author>
<date year='2005' month='December' />
</front>
<seriesInfo name='RFC' value='4301' />
</reference>

<reference anchor='RFC5202' target="http://www.rfc-editor.org/info/rfc5202">
<front>
<title>Using the Encapsulating Security Payload (ESP) Transport Format with the Host Identity Protocol (HIP)</title>
<author initials='P.' surname='Jokela' fullname='P. Jokela'>
<organization /></author>
<author initials='R.' surname='Moskowitz' fullname='R. Moskowitz'>
<organization /></author>
<author initials='P.' surname='Nikander' fullname='P. Nikander'>
<organization /></author>
<date year='2008' month='April' />
</front>
<seriesInfo name='RFC' value='5202' />
</reference>

<reference anchor='RFC5207' target="http://www.rfc-editor.org/info/rfc5207">
<front>
<title>NAT and Firewall Traversal Issues of Host Identity Protocol (HIP) Communication</title>
<author initials='M.' surname='Stiemerling' fullname='M. Stiemerling'>
<organization /></author>
<author initials='J.' surname='Quittek' fullname='J. Quittek'>
<organization /></author>
<author initials='L.' surname='Eggert' fullname='L. Eggert'>
<organization /></author>
<date year='2008' month='April' />
</front>
<seriesInfo name='RFC' value='5207' />
</reference>

<reference  anchor='RFC5226' target='http://www.rfc-editor.org/info/rfc5226'>
<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='T.' surname='Narten' fullname='T. Narten'><organization /></author>
<author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'><organization /></author>
<date year='2008' month='May' />
</front>
<seriesInfo name='BCP' value='26'/>
<seriesInfo name='RFC' value='5226'/>
<format type='ASCII' octets='66160'/>
</reference>

<reference anchor='RFC5770' target="http://www.rfc-editor.org/info/rfc5770">
<front>
<title>Basic Host Identity Protocol (HIP) Extensions for Traversal of Network Address Translators</title>
<author initials='M.' surname='Komu' fullname='M. Komu'>
<organization /></author>
<author initials='T.' surname='Henderson' fullname='T. Henderson'>
<organization /></author>
<author initials='H.' surname='Tschofenig' fullname='H. Tschofenig'>
<organization /></author>
<author initials='J.' surname='Melen' fullname='J. Melen'>
<organization /></author>
<author initials='A.' surname='Keranen' fullname='A. Keranen'>
<organization /></author>
<date year='2010' month='April' />
</front>
<seriesInfo name='RFC' value='5770' />
</reference>

<reference anchor='RFC7296' target="http://www.rfc-editor.org/info/rfc7296">
<front>
<title>Internet Key Exchange Protocol Version 2 (IKEv2)</title>
<author initials='C.' surname='Kaufman' fullname='C. Kaufman'>
<organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'>
<organization /></author>
<author initials='Y.' surname='Nir' fullname='Y. Nir'>
<organization /></author>
<author initials='P.' surname='Eronen' fullname='P. Eronen'>
<organization /></author>
<author initials='T.' surname='Kivinen' fullname='T. Kivinen'>
<organization /></author>
<date year='2014' month='October' />
</front>
<seriesInfo name='STD' value='79' />
<seriesInfo name='RFC' value='7296' />
</reference>

<reference anchor='RFC5206' target="http://www.rfc-editor.org/info/rfc5206">
<front>
<title>End-Host Mobility and Multihoming with the Host Identity Protocol</title>
<author initials='P.' surname='Nikander' fullname='P. Nikander'>
<organization /></author>
<author initials='T.' surname='Henderson' fullname='T. Henderson'>
<organization /></author>
<author initials='C.' surname='Vogt' fullname='C. Vogt'>
<organization /></author>
<author initials='J.' surname='Arkko' fullname='J. Arkko'>
<organization /></author>
<date year='2008' month='April' />
</front>
<seriesInfo name='RFC' value='5206' />
</reference>

<!-- draft-ietf-hip-rfc4423-bis (I-D Exists) -->
<reference anchor='HIP-ARCH'>
<front>
<title>Host Identity Protocol Architecture</title>
<author initials='R' surname='Moskowitz' fullname='Robert Moskowitz' role="editor">
    <organization />
</author>
<author initials='M' surname='Komu' fullname='Miika Komu'>
    <organization />
</author>
<date month='October' year='2014' />
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-hip-rfc4423-bis-09' />
</reference>

<reference anchor='RFC0791' target="http://www.rfc-editor.org/info/rfc791">
<front>
<title abbrev='Internet Protocol'>Internet Protocol</title>
<author initials='J.' surname='Postel' fullname='Jon Postel'>
<organization>University of Southern California (USC)/Information Sciences Institute</organization>
</author>
<date year='1981' day='1' month='September' /></front>
<seriesInfo name='STD' value='5' />
<seriesInfo name='RFC' value='791' />
</reference>

    </references>

    <section anchor="impl_note" title="A Note on Implementation Options">

      <t>
        It is possible to implement this specification in multiple
        different ways.  As noted above, one possible way of
        implementing this is to rewrite IP headers below IPsec.  In such an
        implementation, IPsec is used as if it was processing IPv6
        transport mode packets, with the IPv6 header containing HITs
        instead of IP addresses in the source and destination address
        fields.  In outgoing packets, after IPsec processing, the HITs
        are replaced with actual IP addresses, based on the HITs and
        the SPI.  In incoming packets, before IPsec processing, the IP
        addresses are replaced with HITs, based on the SPI in the
        incoming packet.  In such an implementation, all IPsec
        policies are based on HITs and the upper layers only see
        packets with HITs in the place of IP addresses.  Consequently,
        support of HIP does not conflict with other uses of IPsec as
        long as the SPI spaces are kept separate.  <xref target="BEET" /> 
        describes another way to implement this specification.
      </t>

    </section>

    <section anchor="BEET" title="Bound End-to-End Tunnel Mode for ESP">
      <t>
        This section introduces an alternative way of implementing the
        necessary functions for HIP ESP transport.  Compared to the option 
        of implementing the required address rewrites outside of IPsec,
        BEET has one implementation-level benefit.  In a
        BEET-mode-based implementation, the address-rewriting
        information is kept in one place, at the SAD.  On the other 
        hand, when address rewriting is implemented separately, the
        implementation MUST make sure that the information in the SAD
        and the information in the separate address-rewriting database
        are kept in synchrony.  As a result, the BEET-mode-based way of
        implementing this specification is RECOMMENDED over the separate
        implementation, as it binds the identities, encryption, and
        locators tightly together.  It should be noted that implementing
        BEET mode doesn't require that corresponding hosts implement it,
        as the behavior is only visible internally in a host.
      </t>
      <t>
        BEET mode is a combination of IPsec tunnel and transport modes,
        and it provides some of the features from both.  HIP uses HITs
        as the "inner" addresses and IP addresses as "outer" addresses,
        like IP addresses are used in tunnel mode.  Instead of
        tunneling packets between hosts, a conversion between inner
        and outer addresses is made at end hosts, and the inner
        address is never sent on the wire after the initial HIP
        negotiation.  BEET provides IPsec transport mode syntax (no
        inner headers) with limited tunnel mode semantics (fixed
        logical inner addresses -- the HITs -- and changeable outer
        IP addresses).
      </t>
      
      <section title="Protocol Definition">
        
        <t>In this section, we define the exact protocol formats and
        operations.</t>
        
        <section title="Changes to Security Association Data Structures"> 
          
          <t>A BEET mode Security Association contains the same data as
          a regular tunnel mode Security Association, with the exception
          that the inner selectors must be single addresses and cannot
          be subnets.  The data includes the following:
            
            <list style="symbols">
              
              <t>A pair of inner IP addresses.</t>
              
              <t>A pair of outer IP addresses.</t>
              
              <t>Cryptographic keys and other data as defined in
              Section 4.4.2 of <xref target="RFC4301">RFC 4301</xref>.</t>
              
            </list>
            
            A conforming implementation MAY store the data in a way
            similar to a regular tunnel mode Security Association.</t>
          
          <t>Note that in a conforming implementation the inner and
          outer addresses MAY belong to different address families.  All
          implementations that support both IPv4 and IPv6 SHOULD support
          both IPv4-over-IPv6 and IPv6-over-IPv4 tunneling.</t>
          
        </section>  
        
        
        <section title="Packet Format">
          
          <t>The wire packet format is identical to the ESP transport
          mode wire format as defined in Section 3.1.1 of
          <xref target="RFC4303" />.  However, the resulting packet
          contains outer IP addresses instead of the inner IP addresses
          received from the upper layer.  The construction of the
          outer headers is defined in Section 5.1.2 of 
          <xref target="RFC4301">RFC 4301</xref>.  The following
          diagram illustrates ESP BEET mode positioning for typical
          IPv4 and IPv6 packets. </t>
          
          <figure>
            <artwork>
IPv4 INNER ADDRESSES
--------------------

      BEFORE APPLYING ESP
 ------------------------------
 | inner IP hdr  |     |      |
 |               | TCP | Data |
 ------------------------------

      AFTER APPLYING ESP, OUTER v4 ADDRESSES
 ----------------------------------------------------
 | outer IP hdr  |     |     |      |   ESP   | ESP |
 | (any options) | ESP | TCP | Data | Trailer | ICV |
 ----------------------------------------------------
                       |&lt;---- encryption ----&gt;|
                 |&lt;-------- integrity -------&gt;|

      AFTER APPLYING ESP, OUTER v6 ADDRESSES
 ------------------------------------------------------
 | outer  | new ext |     |     |      |  ESP   | ESP |
 | IP hdr | hdrs    | ESP | TCP | Data | Trailer| ICV |
 ------------------------------------------------------
                          |&lt;--- encryption ----&gt;|
                    |&lt;------- integrity -------&gt;|

IPv4 INNER ADDRESSES with options
---------------------------------

      BEFORE APPLYING ESP
 ------------------------------
 | inner IP hdr  |     |      |
 |  + options    | TCP | Data |
 ------------------------------

      AFTER APPLYING ESP, OUTER v4 ADDRESSES
 ----------------------------------------------------------
 | outer IP hdr  |     |     |     |      |   ESP   | ESP |
 | (any options) | ESP | PH  | TCP | Data | Trailer | ICV |
 ----------------------------------------------------------
                       |&lt;------- encryption -------&gt;|
                 |&lt;----------- integrity ----------&gt;|

      AFTER APPLYING ESP, OUTER v6 ADDRESSES
 ------------------------------------------------------------
 | outer  | new ext |     |     |     |      |  ESP   | ESP |
 | IP hdr | hdrs    | ESP | PH  | TCP | Data | Trailer| ICV |
 ------------------------------------------------------------
                          |&lt;------ encryption -------&gt;|
                    |&lt;---------- integrity ----------&gt;|

                            PH    Pseudo Header for IPv4 options

IPv6 INNER ADDRESSES
--------------------

      BEFORE APPLYING ESP
 ------------------------------------------
 |              |  ext hdrs  |     |      |
 | inner IP hdr | if present | TCP | Data |
 ------------------------------------------

      AFTER APPLYING ESP, OUTER v6 ADDRESSES
 --------------------------------------------------------------
 | outer  | new ext |     | dest |     |      |  ESP    | ESP |
 | IP hdr | hdrs    | ESP | opts.| TCP | Data | Trailer | ICV |
 --------------------------------------------------------------
                                 |&lt;---- encryption ----&gt;|
                             |&lt;------- integrity ------&gt;|

      AFTER APPLYING ESP, OUTER v4 ADDRESSES
 ----------------------------------------------------
 | outer  |     | dest |     |      |  ESP    | ESP |
 | IP hdr | ESP | opts.| TCP | Data | Trailer | ICV |
 ----------------------------------------------------
                |&lt;------- encryption --------&gt;|
          |&lt;----------- integrity -----------&gt;|
            </artwork>
          </figure>
          
        </section>  
        <section title="Cryptographic Processing"> 
          
          <t>The outgoing packets MUST be protected exactly as in ESP
          transport mode <xref target="RFC4303" />.  That is, the
          upper-layer protocol packet is wrapped into an ESP header,
          encrypted, and authenticated exactly as if regular transport
          mode was used.  The resulting ESP packet is subject to IP
          header processing as defined in Appendices <xref
          target="section-ip-header-processing" format="counter" />
          and <xref target="section-outgoing" format="counter" />.
          The incoming ESP protected messages are verified and
          decrypted exactly as if regular transport mode was used.
          The resulting cleartext packet is subject to IP header
          processing as defined in Appendices <xref
          target="section-ip-header-processing" format="counter"/>
          and <xref target="section-incoming" format="counter" />.</t>
          
        </section>  
        
        <section anchor="section-ip-header-processing" title="IP Header
Processing">
          
          <t>The biggest difference between BEET mode and the other
          two modes is in IP header processing.  In the regular
          transport mode, the IP header is kept intact.  In the regular
          tunnel mode, an outer IP header is created on output and
          discarded on input.  In BEET mode, the IP header is
          replaced with another one on both input and output.</t>
          
          <t>On the BEET mode output side, the IP header processing MUST
          first ensure that the IP addresses in the original IP header
          contain the inner addresses as specified in the SA.  This MAY
          be ensured by proper policy processing, and it is possible
          that no checks are needed at the time of SA processing.  Once
          the IP header has been verified to contain the right IP inner
          addresses, it is discarded.  A new IP header is created, using
          the fields of the discarded inner header (except the IP
          addresses) to populate the fields of the new outer header. The
          IP addresses in the new header MUST be the outer tunnel
          addresses.</t>

          <t>On the input side, the received IP header is simply discarded.
          Since the packet has been decrypted and verified, no further
          checks are necessary.  A new IP header corresponding to a
          BEET mode inner header is created, using the fields of the
	  discarded outer header (except the IP addresses) to populate the
	  fields of the new inner header. The IP addresses in the new
          header MUST be the inner addresses. </t>
          
          <t>As the outer header fields are used as a hint for creating
          the inner header, it must be noted that the inner header differs
          as compared to a tunnel mode inner header. In BEET mode, the inner
          header will have the Time to Live (TTL), Don't Fragment (DF) bit,
          and other option values from the outer header. The TTL, DF bit,
          and other option values of the inner header MUST be processed
          by the stack.</t>
          
        </section>
        
        <section anchor="section-outgoing" title="Handling of Outgoing Packets">
          
          <t>The outgoing BEET mode packets are processed as follows:
            
            <list style="numbers">
              
              <t>The system MUST verify that the IP header contains the
              inner source and destination addresses, exactly as defined
              in the SA.  This verification MAY be explicit, or it MAY
              be implicit, for example, as a result of prior policy
              processing.  Note that in some implementations there may
              be no real IP header at this time but the source and
              destination addresses may be carried out of band.  If
              the source address is still unassigned, it SHOULD be
              ensured that the designated inner source address would be
              selected at a later stage.</t>
              
              <t>The IP payload (the contents of the packet beyond the
              IP header) is wrapped into an ESP header as defined in
              Section 3.3 of <xref target="RFC4303" />.</t>
              
              <t>A new IP header is constructed, replacing the original
              one.  The new IP header MUST contain the outer source and
              destination addresses, as defined in the SA.  Note that in
              some implementations there may be no real IP header at
              this time but the source and destination addresses may be
              carried out of band.  In the case where the source address
              must be left unassigned, it SHOULD be ensured that the
              right source address is selected at a later stage.  Other
              than the addresses, it is RECOMMENDED that the new IP
              header copies the fields from the original IP header.</t>
              
              <t>If there are any IPv4 options in the original packet,
              it is RECOMMENDED that they are discarded. If the inner
              header contains one or more options that need to be
              transported between the tunnel endpoints, the sender MUST
              encapsulate the options as defined in <xref
              target="section-ip-options" />.
              </t>
              
            </list>
          </t>
          
          <t>Instead of literally discarding the IP header and
          constructing a new one, a conforming implementation MAY simply
          replace the addresses in an existing header.  However, if the
          RECOMMENDED feature of allowing the inner and outer addresses
          from different address families is used, this simple strategy
          does not work. </t>
          
        </section>  
        
        <section anchor="section-incoming" title="Handling of Incoming Packets"> 
          
          <t>The incoming BEET mode packets are processed as follows:
            
            <list style="numbers">
              
              <t>The system MUST verify and decrypt the incoming packet
              successfully, as defined in Section 3.4 of
              <xref target="RFC4303" />.  If the verification or
              decryption fails, the packet MUST be discarded.</t>
              
              <t>The original IP header is simply discarded, without any
              checks.  Since the ESP verification succeeded, the packet
              can be safely assumed to have arrived from the right
              sender.</t>
              
              <t>A new IP header is constructed, replacing the original
              one. The new IP header MUST contain the inner source and
              destination addresses, as defined in the SA. If the sender
              has set the ESP Next Header field to 94 and included the
              pseudo header as described in <xref
              target="section-ip-options" />, the receiver MUST include
              the options after the constructed IP header. Note that in
              some implementations the real IP header may have already
              been discarded and the source and destination addresses
              are carried out of band.  In such a case, the out-of-band
              addresses MUST be the inner addresses.  Other than the
              addresses, it is RECOMMENDED that the new IP header copies
              the fields from the original IP header.</t>
              
            </list>
          </t> 
          
          <t>Instead of literally discarding the IP header and
          constructing a new one, a conforming implementation MAY simply
          replace the addresses in an existing header.  However, if the
          RECOMMENDED feature of allowing the inner and outer addresses
          from different address families is used, this simple strategy
          does not work. </t>
          
        </section>  
        
        <section anchor="section-ip-options" title="Handling of IPv4 Options">
          
          <t>In BEET mode, if IPv4 options are transported inside the
          tunnel, the sender MUST include a pseudo header after the ESP
          header. The pseudo header indicates that IPv4 options from
          the original packet are to be applied to the packet on the
          input side.</t>
          
          <t>The sender MUST set the Next Header field in the ESP
          header to 94. The resulting pseudo header, including the IPv4
          options, MUST be padded to an 8-octet boundary. The padding
          length is expressed in octets; valid padding lengths are 0 or 4
          octets, as the original IPv4 options are already padded to
          a 4-octet boundary. The padding MUST be filled with 
          No Operation (NOP) options as defined in
          Section 3.1 ("Internet Header Format") of <xref target="RFC0791"/>
          ("Internet Protocol"). The padding is added in
          front of the original options to ensure that the receiver is
          able to reconstruct the original IPv4 datagram. The Header
          Length field contains the length of the IPv4 options, and
          padding in 8-octet units.</t>
          
          <figure>
            <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Next Header  |   Header Len  |    Pad Len    |   Reserved    |
+---------------+---------------+-------------------------------+
|                       Padding (if needed)                     |
+---------------------------------------------------------------+
|                            IPv4 options ...                   |
|                                                               |
+---------------------------------------------------------------+

   Next Header          identifies the data following this header.
   Length in octets     8-bit unsigned integer.  Length of the 
                        pseudo header in 8-octet units, not 
                        including the first 8 octets.
            </artwork>
          </figure>
          
          <t>The receiver MUST remove this pseudo header and padding
          as a part of BEET processing, in order to reconstruct the
          original IPv4 datagram. The IPv4 options included in the
          pseudo header MUST be added after the reconstructed IPv4
          (inner) header on the receiving side.</t>
          
        </section>
        
      </section>
    </section>

    <section title="Acknowledgments" numbered="no">
      <t>
        This document was separated from the base Host Identity
        Protocol specification in the beginning of 2005.  Since then, a
        number of people have contributed to the text by providing
        comments and modification proposals.  The list of people
        includes Tom Henderson, Jeff Ahrenholz, Jan Melen, Jukka Ylitalo,
        and Miika Komu.  Especially, the authors want to thank Pekka
        Nikander for his invaluable contributions to the document since
        the first draft version.  The authors also want to thank Charlie
        Kaufman for reviewing the document with his eye on the usage of
        crypto algorithms.
      </t>

      <t>
        Due to the history of this document, most of the ideas are
        inherited from the base Host Identity Protocol specification.
        Thus, the list of people in the Acknowledgments section of that
        specification is also valid for this document.  Many people have
        given valuable feedback, and our apologies to anyone whose
        name is missing.
      </t>
    </section>

  </back>
</rfc>
