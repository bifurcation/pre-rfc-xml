<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc strict="no" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<?rfc rfcedstyle="yes" ?>

<rfc number="7512"
     category="std" 
     submissionType="IETF"
     consensus="yes"
     ipr="trust200902">

<front>

<title abbrev="The PKCS #11 URI Scheme">The PKCS #11 URI Scheme</title>

<author initials="J." surname="Pechanec" fullname="Jan Pechanec">
        <organization>Oracle Corporation</organization>

        <address>
                <postal>
                        <street>4180 Network Circle</street>
                        <city>Santa Clara</city>
                        <region>CA 95054</region>
                        <country>United States</country>
                </postal>

                <email>Jan.Pechanec@Oracle.com</email>
                <uri>http://www.oracle.com</uri>
        </address>
</author>

<author initials="D. J." surname="Moffat" fullname="Darren J. Moffat">
        <organization>Oracle Corporation</organization>

        <address>
                <postal>
                        <street>Oracle Parkway</street>
                        <street>Thames Valley Park</street>
                        <city>Reading</city>
                        <code>RG6 1RA</code>
                        <country>United Kingdom</country>
                </postal>

                <email>Darren.Moffat@Oracle.com</email>
                <uri>http://www.oracle.com</uri>
        </address>
</author>

<date month="April" year="2015" />

<area>General</area>
<workgroup>Network Working Group</workgroup>


<abstract>
<t>This memo specifies a PKCS #11 Uniform Resource Identifier (URI)
Scheme for identifying PKCS #11 objects stored in PKCS #11 tokens and
also for identifying PKCS #11 tokens, slots, or libraries. The URI scheme is
based on how PKCS #11 objects, tokens, slots, and libraries are
identified in "PKCS #11 v2.20: Cryptographic Token Interface Standard".
</t>
</abstract>
</front>

<middle>

<section anchor="intro" title="Introduction">

<t>"PKCS #11 v2.20: Cryptographic Token Interface Standard" <xref
target="PKCS11" /> specifies an API, called Cryptoki, for devices
that hold cryptographic information and perform cryptographic
functions.  Cryptoki (pronounced "crypto-key" and short for "cryptographic
token interface") follows a simple object-based approach, addressing
the goals of technology independence (any kind of device may be used)
and resource sharing (multiple applications may access multiple
devices), presenting applications with a common, logical view of the
device -- a cryptographic token.
</t>

<t>It is desirable for applications or libraries that work with
PKCS #11 tokens to accept a common identifier that consumers could use
to identify an existing PKCS #11 storage object in a PKCS #11 token, an
existing token itself, a slot, or an existing Cryptoki library (also
called a producer, module, or provider).  The set of storage object
types that can be stored in a PKCS #11 token includes a certificate; a data
object; and a public, private, or secret key.  These objects can
be uniquely identifiable via the PKCS #11 URI scheme defined in this
document.  The set of attributes describing a storage object can
contain an object label, its type, and its ID.  The set of attributes
that identifies a PKCS #11 token can contain a token label,
manufacturer name, serial number, and token model.  Attributes that
can identify a slot are a slot ID, description, and manufacturer.
Attributes that can identify a Cryptoki library are a library
manufacturer, description, and version.  Library attributes may be
necessary to use if more than one Cryptoki library provides a token
and/or PKCS #11 objects of the same name.  A set of query attributes is
provided as well.
</t>

<t>
A PKCS #11 URI cannot identify other objects defined in the
specification <xref target="PKCS11" /> aside from storage
objects.  For example, objects not identifiable by a PKCS #11 URI
include a hardware feature and mechanism.  Note that a Cryptoki
library does not have to provide for storage objects at all.  The URI
can still be used to identify a specific PKCS #11 token, slot, or an API
producer in such a case.
</t>

<t>A subset of existing PKCS #11 structure members and object
attributes was chosen to uniquely identify a PKCS #11 storage object,
token, slot, or library in a configuration file, on a command line, or
in a configuration property of something else.  Should there be a need
for a more complex information exchange on PKCS #11 entities, a
different means of data marshalling should be chosen accordingly.
</t>

<t>A PKCS #11 URI is not intended to be used to create new PKCS #11
objects in tokens or to create PKCS #11 tokens.  It is solely to be
used to identify and work with existing storage objects, tokens, and
slots through the PKCS #11 API, or to identify Cryptoki libraries
themselves.
</t>

<t>The URI scheme defined in this document is designed specifically
with a mapping to the PKCS #11 API in mind.  The URI scheme definition uses the scheme,
path, and query components defined in the "Uniform Resource Identifier
(URI): Generic Syntax" <xref target="RFC3986" /> document.  The URI scheme
does not use the hierarchical element for a naming authority in the
path since the authority part could not be mapped to PKCS #11 API
elements.  The URI scheme does not use the fragment component.
</t>

<t>If an application has no access to a producer or producers of the
PKCS #11 API, the query component module attributes can be used.
However, the PKCS #11 URI consumer can always decide to provide its own
adequate user interface to locate and load PKCS #11 API producers.
</t>

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref target="RFC2119"
/>.
</t>

</section>


<section anchor="scheme_def" title="PKCS #11 URI Scheme Definition">

<t>In accordance with <xref target="RFC4395" />, this section provides
the information required to register the PKCS #11 URI scheme.
</t>

<section anchor="scheme_name" title="PKCS #11 URI Scheme Name">
<t>pkcs11</t>
</section>

<section anchor="scheme_status" title="PKCS #11 URI Scheme Status">
<t>Permanent</t>
</section>

<section anchor="scheme_syntax" title="PKCS #11 URI Scheme Syntax">

<t>A PKCS #11 URI is a sequence of attribute value pairs separated by
a semicolon that form a one-level path component, optionally followed
by a query.  Except for the value of the "id" attribute defined later
in this section, these attribute value pairs and query components are
composed entirely of textual data and therefore SHOULD all first be
encoded as octets according to the UTF-8 character encoding <xref
target="RFC3629" />, in accordance with Section 2.5 of <xref
target="RFC3986" />; then, only those octets that do not correspond to
characters in the unreserved set or to permitted characters from the
reserved set SHOULD be percent-encoded.  Note that the value of the
"id" attribute SHOULD NOT be encoded as UTF-8 because it can contain
non-textual data, instead it SHOULD be entirely percent-encoded.  See
important caveats in Sections <xref target="uri_matching" format="counter"/> and <xref
target="i18n_considerations" format="counter"/> regarding working with UTF-8 strings
containing characters outside the US-ASCII character set.
</t>

<t>Grammar rules "unreserved" and "pct-encoded" in the PKCS #11 URI scheme
definition below are imported from <xref target="RFC3986" />.  As a
special case, note that according to Appendix A of <xref
target="RFC3986" />, a space must be percent-encoded.
</t>

<t>The PKCS #11 specification imposes various limitations on the value of
attributes, be it a more restrictive character set for the "serial"
attribute or fixed-size buffers for almost all the others, including
"token", "manufacturer", and "model" attributes.  The syntax of the
PKCS #11 URI scheme does not impose such limitations.  However, if the
consumer of a PKCS #11 URI encounters values that would not be accepted
by the PKCS #11 specification, it MUST refuse the URI as invalid.
</t>

<t>
<figure>
<preamble>A PKCS #11 URI takes the following form (for explanation of Augmented
BNF, see <xref target="RFC5234" />):</preamble>
<artwork>
pk11-URI             = "pkcs11:" pk11-path [ "?" pk11-query ]
; Path component and its attributes.  Path may be empty.
pk11-path            = [ pk11-pattr *(";" pk11-pattr) ]
pk11-pattr           = pk11-token / pk11-manuf / pk11-serial /
                       pk11-model / pk11-lib-manuf /
                       pk11-lib-ver / pk11-lib-desc /
                       pk11-object / pk11-type / pk11-id /
                       pk11-slot-desc / pk11-slot-manuf /
                       pk11-slot-id / pk11-v-pattr
; Query component and its attributes.  Query may be empty.
pk11-qattr           = pk11-pin-source / pk11-pin-value /
                       pk11-module-name / pk11-module-path /
                       pk11-v-qattr
pk11-query           = [ pk11-qattr *("&amp;" pk11-qattr) ]
; Section 2.2 of [RFC3986] mandates all potentially reserved characters
; that do not conflict with actual delimiters of the URI do not have
; to be percent-encoded.
pk11-res-avail       = ":" / "[" / "]" / "@" / "!" / "$" /
                       "'" / "(" / ")" / "*" / "+" / "," / "="
pk11-path-res-avail  = pk11-res-avail / "&amp;"
; "/" and "?" in the query component MAY be unencoded but "&amp;" MUST
; be encoded since it functions as a delimiter within the component.
pk11-query-res-avail = pk11-res-avail / "/" / "?" / "|"
pk11-pchar           = unreserved / pk11-path-res-avail / pct-encoded
pk11-qchar           = unreserved / pk11-query-res-avail / pct-encoded
pk11-token           = "token" "=" *pk11-pchar
pk11-manuf           = "manufacturer" "=" *pk11-pchar
pk11-serial          = "serial" "=" *pk11-pchar
pk11-model           = "model" "=" *pk11-pchar
pk11-lib-manuf       = "library-manufacturer" "=" *pk11-pchar
pk11-lib-desc        = "library-description" "=" *pk11-pchar
pk11-lib-ver         = "library-version" "=" 1*DIGIT [ "." 1*DIGIT ]
pk11-object          = "object" "=" *pk11-pchar
pk11-type            = "type" "=" ( "public" / "private" / "cert" /
                       "secret-key" / "data" )
pk11-id              = "id" "=" *pk11-pchar
pk11-slot-manuf      = "slot-manufacturer" "=" *pk11-pchar
pk11-slot-desc       = "slot-description" "=" *pk11-pchar
pk11-slot-id         = "slot-id" "=" 1*DIGIT
pk11-pin-source      = "pin-source" "=" *pk11-qchar
pk11-pin-value       = "pin-value" "=" *pk11-qchar
pk11-module-name     = "module-name" "=" *pk11-qchar
pk11-module-path     = "module-path" "=" *pk11-qchar
pk11-v-attr-nm-char  = ALPHA / DIGIT / "-" / "_"
; The permitted value of a vendor-specific attribute is based on
; whether the attribute is used in the path or in the query.
pk11-v-pattr         = 1*pk11-v-attr-nm-char "=" *pk11-pchar
pk11-v-qattr         = 1*pk11-v-attr-nm-char "=" *pk11-qchar
</artwork>
</figure>
</t>

<t>The URI path component contains attributes that identify a resource
in a one-level hierarchy provided by Cryptoki producers.  The query
component can contain a few attributes that may be needed to retrieve
the resource identified by the URI path component. Attributes in the path
component are delimited by the ';' character, attributes in the query
component use '&amp;' as a delimiter.
</t>

<t>Both path and query components MAY contain vendor-specific
attributes.  Such attribute names MUST NOT clash with existing
attribute names.  Note that in accordance with <xref target="BCP178"
/>, the previously used convention of starting vendor attributes with an
"x-" prefix is now deprecated.
</t>

<t>The general '/' delimiter MUST be percent-encoded in the path
component so that generic URI parsers never split the path component
into multiple segments.  It MAY be unencoded in the query component.
The delimiter '?' MUST be percent-encoded in the path component since the
PKCS #11 URI scheme uses a query component.  The delimiter '#' MUST be always
percent-encoded so that generic URI parsers do not treat a hash as a
beginning of a fragment identifier component.  All other generic
delimiters MAY be used unencoded (':', '[', ']', and '@') in a
PKCS #11 URI.
</t>

<t>The following table presents mapping between the PKCS #11 URI path
component attributes and the PKCS #11 API structure members and object
attributes.  Given that PKCS #11 URI users may be quite ignorant about
the PKCS #11 specification, the mapping is a product of a necessary
compromise between how precisely the URI attribute names are mapped to
the names in the specification and the ease of use and understanding
of the URI scheme.
</t>

<texttable anchor="uri-attr-mapping-to-spec" style="all"
  title="Mapping between URI Path Component Attributes and PKCS #11
  Specification Names">

        <ttcol align="left">URI component path attribute name</ttcol>
        <ttcol align="left">Attribute represents</ttcol>
        <ttcol align="left">PKCS #11 specification counterpart</ttcol>

        <c></c>
        <c></c>
        <c></c>

        <c>id</c>
        <c>key identifier for object</c>
        <c>"CKA_ID" object attribute</c>

        <c>library-description</c>
        <c>character-string description of the library</c>
	<c>"libraryDescription" member of CK_INFO structure.  It is a
	UTF-8 string.</c>

        <c>library-manufacturer</c>
        <c>ID of the Cryptoki library manufacturer</c>
        <c>"manufacturerID" member of the CK_INFO structure.  It is a
	UTF-8 string.</c>

        <c>library-version</c>
        <c>Cryptoki library version number</c>
        <c>"libraryVersion" member of the CK_INFO structure.</c>

        <c>manufacturer</c>
        <c>ID of the token manufacturer</c>
        <c>"manufacturerID" member of CK_TOKEN_INFO structure.  It is
	a UTF-8 string.</c>

        <c>model</c>
        <c>token model</c>
        <c>"model" member of CK_TOKEN_INFO structure.  It is a
	UTF-8 string.</c>

        <c>object</c>
        <c>description (name) of the object</c>
        <c>"CKA_LABEL" object attribute.  It is a
	UTF-8 string.</c>

        <c>serial</c>
        <c>character-string serial number of the token</c>
        <c>"serialNumber" member of CK_TOKEN_INFO structure.</c>

        <c>slot-description</c>
        <c>slot description</c>
        <c>"slotDescription" member of CK_SLOT_INFO structure.  It is
	a UTF-8 string.</c>

        <c>slot-id</c>
        <c>Cryptoki-assigned value that identifies a slot</c>
        <c>decimal number of "CK_SLOT_ID" type.</c>

        <c>slot-manufacturer</c>
        <c>ID of the slot manufacturer</c>
        <c>"manufacturerID" member of CK_SLOT_INFO structure.  It is
	a UTF-8 string.</c>

        <c>token</c>
        <c>application-defined label, assigned during token
        initialization</c>
        <c>"label" member of the CK_TOKEN_INFO structure.  It is a
	UTF-8 string.</c>

        <c>type</c>
        <c>object class (type)</c>
        <c>"CKA_CLASS" object attribute.</c>
</texttable>

<t>The following table presents mapping between the "type" attribute
values and corresponding PKCS #11 object classes.
</t>

<texttable anchor="type-mapping-to-classes"
  title="Mapping between the &quot;type&quot; Attribute and PKCS #11
  Object Classes">

        <ttcol align="left">Attribute value</ttcol>
        <ttcol align="left">PKCS #11 object class</ttcol>

        <c>cert</c>
        <c>CKO_CERTIFICATE</c>

        <c>data</c>
        <c>CKO_DATA</c>

        <c>private</c>
        <c>CKO_PRIVATE_KEY</c>

        <c>public</c>
        <c>CKO_PUBLIC_KEY</c>

        <c>secret-key</c>
        <c>CKO_SECRET_KEY</c>
</texttable>

<t>The query component attribute "pin-source" specifies where the
application or library should find the normal user's token PIN, the
"pin-value" attribute provides the normal user's PIN value directly,
if needed, and the "module-name" and "module-path" attributes modify
default settings for accessing PKCS #11 providers.  For the definition
of a "normal user", see <xref target="PKCS11" />.
</t>

<t>The ABNF rules above are a best-effort definition, and this paragraph
specifies additional constraints.  A PKCS #11 URI MUST NOT contain
duplicate attributes of the same name in the URI path component.  It
means that each attribute may be present at most once in the PKCS #11
URI path component.  Aside from the query attributes defined in this
document, duplicate (vendor) attributes MAY be present in the URI
query component and it is up to the URI consumer to decide on how to
deal with such duplicates.
</t>

<t>As stated earlier in this section, the value of the "id" attribute
can contain non-textual data. This is because the corresponding
PKCS #11 "CKA_ID" object attribute can contain arbitrary binary data.
Therefore, the whole value of the "id" attribute SHOULD be
percent-encoded.
</t>

<t>The "library-version" attribute represents the major and minor
version number of the library and its format is "M.N".  Both numbers
are one byte in size; see the "libraryVersion" member of the CK_INFO
structure in <xref target="PKCS11" /> for more information.
Value "M" for the attribute MUST be interpreted as "M" for the major
and "0" for the minor version of the library.  If the attribute is
present, the major version number is REQUIRED.  Both "M" and "N" MUST
be decimal numbers.
</t>

<t>Slot ID is a Cryptoki-assigned number that is not guaranteed to be stable
across PKCS #11 module initializations.  However, there are certain
libraries and modules that provide stable slot identifiers.  For
these cases, when the slot description and manufacturer ID is not
sufficient to uniquely identify a specific reader, the slot ID MAY
be used to increase the precision of the token identification.  In
other scenarios, using the slot IDs is likely to cause usability
issues.
</t>

<t>An empty PKCS #11 URI path component attribute that does allow for
an empty value matches a corresponding structure member or an object
attribute with an empty value. Note that according to the PKCS #11
specification <xref target="PKCS11" />, empty character values in a
PKCS #11 API producer must be padded with spaces and should not be NULL
terminated.
</t>

</section>

<section anchor="query_semantics"
title="PKCS #11 URI Scheme Query Attribute Semantics">

<t>An application can always ask for a PIN by any means it decides to.
What is more, in order not to limit PKCS #11 URI portability, the
"pin-source" attribute value format and interpretation is left to be
implementation specific.  However, the following rules SHOULD be
followed in descending order for the value of the "pin-source"
attribute:
</t>

<t><list style="symbols">
	<t>If the value represents a URI, it SHOULD be treated as an
	object containing the PIN.  Such a URI may be "file:",
	"https:", another PKCS #11 URI, or something else.
        </t>
        <t>If the value contains "|&lt;absolute-command-path&gt;", the
        implementation SHOULD read the PIN from the output of an
        application specified with absolute path
        "&lt;absolute-command-path&gt;".  Note that character "|"
        representing a pipe does not have to be percent-encoded in the
        query component of a PKCS #11 URI.
        </t>
        <t>Interpret the value as needed in an implementation-dependent way.</t>
</list>
</t>

<t>If a URI contains both "pin-source" and "pin-value" query
attributes, the URI SHOULD be refused as invalid.
</t>

<t>Use of the "pin-value" attribute may have security-related
consequences.  <xref target="security" /> should be consulted before
this attribute is ever used.  Standard percent-encoding rules SHOULD
be followed for the attribute value.
</t>

<t>A consumer of PKCS #11 URIs MAY accept query component attributes
"module-name" and "module-path" in order to modify default settings
for accessing a PKCS #11 provider or providers.
</t>

<t>Processing the URI query module attributes SHOULD follow these
rules:
</t>

<t><list style="symbols">
	<t>The attribute "module-name" SHOULD contain a case-insensitive
	PKCS #11 module name (not path nor filename) without system-specific
	affixes; said affix could be a ".so" or ".DLL"
	suffix, or a "lib" prefix, for example.  Not using system-specific
	affixes is expected to increase portability of
	PKCS #11 URIs among different systems.  A URI consumer
	searching for PKCS #11 modules SHOULD use a system or
	application-specific locations to find modules based on the
	name provided in the attribute.
        </t>
	<t>The attribute "module-path" SHOULD contain a system-specific
	absolute path to the PKCS #11 module or a system-specific
	absolute path to the directory of where PKCS #11 modules are
	located.  For security reasons, a URI with a relative path in
	this attribute SHOULD be rejected.
        </t>
        <t>The URI consumer MAY refuse to accept either of the
        attributes, or both.  If use of the attribute present in the
        URI string is not accepted, a warning message SHOULD be
        presented to the provider of the URI and system-specific
	module locations SHOULD be used.
        </t>
        <t>If either of the module attributes is present, only those
        modules found matching these query attributes SHOULD be used
        to search for an entity represented by the URI.
        </t>
        <t>The use of the module attributes does not suppress matching of
        any other URI path component attributes present in a URI.
        </t>
        <t>The semantics of using both attributes in the same URI string
        is implementation specific but such use SHOULD be avoided.
        Attribute "module-name" is preferred to "module-path" due to
        its system-independent nature, but the latter may be more
        suitable for development and debugging.
        </t>
	<t>A URI MUST NOT contain multiple module attributes of the
	same name.
        </t>
</list>
</t>

<t>Use of the module attributes may have security-related
consequences.  <xref target="security"/> should be consulted before
these attributes are ever used.
</t>

<t>A word "module" was chosen over a word "library" in these query
attribute names to avoid confusion with semantically different library
attributes used in the URI path component.</t>

</section>

<section anchor="uri_matching" title="PKCS #11 URI Matching Guidelines">

<t>A PKCS #11 URI can identify PKCS #11 storage objects, tokens,
slots, or Cryptoki libraries.  Note that since a URI may identify
four different types of entities, the context within which the URI is
used may be needed to determine the type.  For example, a URI with
only library attributes may either represent all objects in all tokens
in all Cryptoki libraries identified by the URI, all tokens in those
libraries, or just the libraries.
</t>

<t>The following guidelines can help a PKCS #11 URI consumer (e.g., an
application accepting PKCS #11 URIs) to match the URI with the desired
resource.
</t>

<t><list style="symbols">
  <t>The consumer needs to know whether the URI is to identify PKCS #11
  storage object(s), token(s), slot(s), or Cryptoki producer(s).
  </t>
  <t>If the consumer is willing to accept query component module
  attributes, only those PKCS #11 providers matching these attributes
  SHOULD be worked with.  See <xref target="query_semantics" /> for
  more information.
  </t>
  <t>An unrecognized attribute in the URI path component, including a
  vendor-specific attribute, SHOULD result in an empty set of matched
  resources.  The consumer can consider whether an error message
  presented to the user is appropriate in such a case.
  </t>
  <t>An unrecognized attribute in the URI query SHOULD be ignored.
  The consumer can consider whether a warning message presented to
  the user is appropriate in such a case.
  </t>
  <t>An attribute not present in the URI path component but known to a
  consumer matches everything.  Each additional attribute present in
  the URI path component further restricts the selection.
  </t>
  <t>A logical extension of the above is that a URI with an empty path
  component matches everything.  For example, if used to identify
  storage objects, it matches all accessible objects in all tokens
  provided by all relevant PKCS #11 API producers.
  </t>
  <t>Note that use of PIN attributes may change the set of storage
  objects visible to the consumer.
  </t>
  <t>In addition to query component attributes defined in this
  document, vendor-specific query attributes may contain further
  information about how to perform the selection or other related
  information.
  </t>
</list>
</t>

<t>As noted in <xref target="i18n_considerations" />, the PKCS #11
specification is not clear about how to normalize UTF-8-encoded
Unicode characters <xref target="RFC3629" />.  For that reason, it is
RECOMMENDED not to use characters outside the US-ASCII character set
for labels and names.  However, those who discover a need to use such
characters should be cautious, conservative, and expend extra effort
to be sure they know what they are doing and that failure to do so may
create both operational and security risks.  It means that when
matching UTF-8 string-based attributes (see <xref
target="uri-attr-mapping-to-spec" />) with characters outside the
US-ASCII repertoire, normalizing all UTF-8 strings before string
comparison may be the only safe approach.  For example, for objects
(keys), it means that PKCS #11 attribute search template would only
contain attributes that are not UTF-8 strings and another pass through
returned objects is then needed for UTF-8 string comparison after the
normalization is applied.
</t>

</section>

<section anchor="uri_comparision" title="PKCS #11 URI Comparison">

<t>Comparison of two URIs is a way of determining whether the URIs are
equivalent without comparing the actual resource to which the URIs point.
The comparison of URIs aims to minimize false negatives while strictly
avoiding false positives.  When working with UTF-8 strings with
characters outside the US-ASCII character sets, see important caveats in Sections
<xref target="uri_matching" format="counter"/> and <xref target="i18n_considerations" format="counter"/>.
</t>

<t>Two PKCS #11 URIs are said to be equal if URIs as character strings
are identical as specified in Section 6.2.1 of <xref target="RFC3986"
/>, or if both of the following rules are fulfilled:
</t>

<t><list style="symbols">
   <t>The set of attributes present in the URI is equal.  Note that the
   ordering of attributes in the URI string is not significant for the
   mechanism of comparison.
   </t>
   <t>The values of respective attributes are equal based on rules
   specified below
   </t>
</list></t>

<t>The rules for comparing values of respective attributes are:
</t>

<t><list style="symbols">
  <t>The values of path component attributes "library-description",
     "library-manufacturer", "manufacturer", "model", "object",
     "serial", "slot-description", "slot-manufacturer", "token",
     "type", and the query component attribute "module-name" MUST be
     compared using a simple string comparison, as specified in
     Section 6.2.1 of <xref target="RFC3986" />, after the case and the percent-encoding normalization were both applied as specified in
     Section 6.2.2 of <xref target="RFC3986" />.
  </t>
  <t>The value of the attribute "id" MUST be compared using the simple string
  comparison after all bytes are percent-encoded using uppercase
  letters for digits A-F.
  </t>
  <t>The value of the attribute "library-version" MUST be processed as a
  specific scheme-based normalization permitted by Section 6.2.3 of
  <xref target="RFC3986" />.  The value MUST be split into a major and
  minor version with character '.' (dot) serving as a delimiter.
  A library-version "M" MUST be treated as "M" for the major version and
  "0" for the minor version.  Then, resulting minor and major version
  numbers MUST be separately compared numerically.
  </t>
  <t>The value of the attribute "slot-id" MUST be processed as a
  specific scheme-based normalization permitted by Section 6.2.3 of
  <xref target="RFC3986" /> and compared numerically.
  </t>
  <t>The value of "pin-source", if containing a "file:" URI or
  "|&lt;absolute-command-path&gt;", MUST be compared using the simple
  string comparison after the full syntax-based normalization, as
  specified in Section 6.2.2 of <xref target="RFC3986" />, is applied.
  If the value of the "pin-source" attribute is believed to be overloaded,
  the case and percent-encoding normalization SHOULD be applied before
  the values are compared, but the exact mechanism of comparison is
  left to the application.
  </t>
  <t>The value of the attribute "module-path" MUST be compared using the
  simple string comparison after the full syntax-based normalization,
  as specified in Section 6.2.2 of <xref target="RFC3986" />, is
  applied.
  </t>
  <t>When comparing vendor-specific attributes, the case and
  percent-encoding normalization, as specified in Section 6.2.2 of
  <xref target="RFC3986" />, SHOULD be applied before the values are
  compared, but the exact mechanism of such a comparison is left to the
  application.
  </t>
</list></t>
</section>

<section anchor="uri_listing" title="Generating PKCS #11 URIs ">

<t>When generating URIs for PKCS #11 resources, the exact set of attributes
used in a URI is inherently context specific.  A PKCS #11 URI template
<xref target="RFC6570"/> support MAY be provided by a URI-generating application to
list URIs to access the same resource(s) again if the template
captured the necessary context.
</t>

</section>

</section>

<section anchor="examples" title="Examples of PKCS #11 URIs">

<t>This section contains some examples of how PKCS #11 token objects,
tokens, slots, and libraries can be identified using the PKCS #11 URI
scheme.  Note that in some of the following examples, line breaks and
spaces were inserted for better readability.  As specified in Appendix
C of <xref target="RFC3986" />, whitespace SHOULD be ignored when
extracting the URI.  Also note that all spaces that are part of the URIs are
percent-encoded, as specified in Appendix A of <xref
target="RFC3986"/>.</t>

<figure>
<preamble>An empty PKCS #11 URI might be useful to PKCS #11 consumers.
See <xref target="uri_matching" /> for more information on semantics
of such a URI.
</preamble>
<artwork>
  pkcs11:
</artwork>
</figure>

<figure>
<preamble>One of the simplest and most useful forms might be a PKCS #11
URI that specifies only an object label and its type.  The default
token is used so the URI does not specify it.  Note that when
specifying public objects, a token PIN may not be required.</preamble>
<artwork>
  pkcs11:object=my-pubkey;type=public
</artwork>
</figure>

<figure>
<preamble>When a private key is specified, either the "pin-source"
attribute, "pin-value", or an application-specific method would be
usually used.  Note that '/' is not percent-encoded in the
"pin-source" attribute value since this attribute is part of the query
component, not the path component, and thus is separated by '?' from the rest of
the URI.</preamble>
<artwork>
  pkcs11:object=my-key;type=private?pin-source=file:/etc/token
</artwork>
</figure>

<figure>
<preamble>The following example identifies a certificate in the
software token.  Note the use of an empty value for the attribute "serial", which
matches only empty "serialNumber" member of the "CK_TOKEN_INFO"
structure.  Also note that the "id" attribute value is entirely
percent-encoded, as recommended.  While ',' is in the reserved set, it
does not have to be percent-encoded since it does not conflict with
any sub-delimiters used.  The '#' character, as in "The Software
PKCS #11 Softtoken", MUST be percent-encoded.
</preamble>
<artwork>
  pkcs11:token=The%20Software%20PKCS%2311%20Softtoken;
         manufacturer=Snake%20Oil,%20Inc.;
         model=1.0;
         object=my-certificate;
         type=cert;
         id=%69%95%3E%5C%F4%BD%EC%91;
         serial=
         ?pin-source=file:/etc/token_pin
</artwork>
</figure>

<figure>
<preamble>The next example covers how to use the "module-name" query
attribute.  Considering that the module is located in the 
/usr/lib/libmypkcs11.so.1 file, the attribute value is "mypkcs11",
meaning only the module name without the full path and without the
platform-specific "lib" prefix and ".so.1" suffix.
</preamble>
<artwork>
  pkcs11:object=my-sign-key;
         type=private
         ?module-name=mypkcs11
</artwork>
</figure>

<figure>
<preamble>The following example covers how to use the "module-path"
query attribute.  The attribute may be useful if a user needs to
provide the key via a PKCS #11 module stored on a removable media, for
example.  Getting the PIN to access the private key here is left to be
application specific.
</preamble>
<artwork>
  pkcs11:object=my-sign-key;
         type=private
         ?module-path=/mnt/libmypkcs11.so.1
</artwork>
</figure>

<figure>
<preamble>In the context of where a token is expected, the token can be
identified without specifying any PKCS #11 objects.  A PIN might still
be needed in the context of listing all objects in the token, for
example.  <xref target="security" /> should be consulted before the
"pin-value" attribute is ever used.</preamble>
<artwork>
  pkcs11:token=Software%20PKCS%2311%20softtoken;
         manufacturer=Snake%20Oil,%20Inc.
         ?pin-value=the-pin
</artwork>
</figure>


<figure>
<preamble>In the context where a slot is expected, the slot can be
identified without specifying any PKCS #11 objects in any token that may
be inserted in the slot.</preamble>
<artwork>
  pkcs11:slot-description=Sun%20Metaslot
</artwork>
</figure>

<figure>
<preamble>The Cryptoki library alone can be also identified without
specifying a PKCS #11 token or object.</preamble>
<artwork>
  pkcs11:library-manufacturer=Snake%20Oil,%20Inc.;
         library-description=Soft%20Token%20Library;
         library-version=1.23
</artwork>
</figure>

<figure>
<preamble>The following example shows an attribute value with a
semicolon.  In such a case, it MUST be percent-encoded.  The token
attribute value MUST be read as "My token; created by Joe".  Lowercase 
letters MAY be used in percent-encoding, as shown below in
the "id" attribute value, but note that Sections 2.1 and 6.2.2.1 of
<xref target="RFC3986" /> state that all percent-encoded characters
SHOULD use the uppercase hexadecimal digits.  More specifically, if
the URI string were to be compared, the algorithm defined in <xref
target="uri_comparision" /> explicitly requires percent-encoding to
use the uppercase digits A-F in the "id" attribute values.  And as
explained in <xref target="scheme_syntax" />, library version "3"
MUST be interpreted as "3" for the major and "0" for the minor
version of the library.</preamble>
<artwork>
  pkcs11:token=My%20token%25%20created%20by%20Joe;
         library-version=3;
         id=%01%02%03%Ba%dd%Ca%fe%04%05%06
</artwork>
</figure>

<figure>
<preamble>If there is any need to include a literal "%;" substring,
for example, both characters MUST be escaped.  The token value MUST be
read as "A name with a substring %;".</preamble>
<artwork>
  pkcs11:token=A%20name%20with%20a%20substring%20%25%3B;
         object=my-certificate;
         type=cert
</artwork>
</figure>

<figure>
<preamble>The next example includes a small A with acute in the token
name.  It MUST be encoded in octets according to the UTF-8 character
encoding and then percent-encoded.  Given that a small A with acute is
U+225 Unicode code point, the UTF-8 encoding is 195 161 in decimal,
and that is "%C3%A1" in percent-encoding.
See also <xref target="i18n_considerations" /> on the use of characters
outside the US-ASCII character set for labels.
</preamble>
<artwork>
  pkcs11:token=Name%20with%20a%20small%20A%20with%20acute:%20%C3%A1;
         object=my-certificate;
         type=cert
</artwork>
</figure>

<figure>
<preamble>Both the path and query components MAY contain vendor-specific
attributes.  Attributes in the query component MUST be
delimited by '&amp;'.
</preamble>
<artwork>
  pkcs11:token=my-token;
         object=my-certificate;
         type=cert;
         vendor-aaa=value-a
         ?pin-source=file:/etc/token_pin
         &amp;vendor-bbb=value-b
</artwork>
</figure>

</section>

<section anchor="iana" title="IANA Considerations">

<section anchor="uri_scheme_registration" title="URI Scheme
Registration">

<t>This document moves the "pkcs11" URI scheme from the "Provisional URI Schemes" registry to the
"Permanent URI Schemes" registry.  The registration request complies with
<xref target="RFC4395" />.</t>

<t>
<list style="empty">
	<t>URI scheme name: pkcs11</t>

	<t>URI scheme status: permanent</t>

	<t>URI scheme syntax: Defined in <xref target="scheme_syntax"
	/> of [RFC7512].</t>

	<t>URI scheme semantics: Defined in <xref target="intro" /> of
	[RFC7512].</t>

	<t>Encoding considerations: See Sections <xref target="scheme_syntax" format="counter"
	/> and <xref target="i18n_considerations" format="counter" /> of [RFC7512].</t>

	<t>Applications/protocols that use this URI scheme name: For general
	information, see <xref target="intro" /> of [RFC7512].  A list
	of known consumers of the PKCS #11 URI include GnuTLS, Gnome,
	p11-kit, Oracle Solaris&nbsp;11 and higher, OpenSC, OpenConnect,
	and FreeIPA.</t>

	<t>Interoperability considerations: See <xref
	target="i18n_considerations" /> of [RFC7512].</t>

	<t>Security considerations: See <xref target="security" /> of
	[RFC7512].</t>

	<t>Contact: Jan Pechanec &lt;Jan.Pechanec@Oracle.com&gt;,
	Darren Moffat &lt;Darren.Moffat@Oracle.com&gt;</t>

	<t>Author/Change Controller: IESG &lt;iesg@ietf.org&gt;</t>

	<t>References: [RFC7512]</t>
</list>
</t>

</section>
</section>

<section anchor="i18n_considerations" title="Internationalization
Considerations">

<t>The PKCS #11 specification does not specify a canonical form for
strings of characters of the CK_UTF8CHAR type.  This presents the
usual false negative and false positive (aliasing) concerns that arise
when dealing with unnormalized strings.  Because all PKCS #11 items are
local and local security is assumed, these concerns are mainly about
usability and interoperability.
</t>

<t>In order to improve the user experience, it is RECOMMENDED that
applications that create PKCS #11 objects or label tokens not use
characters outside the US-ASCII character set for the labels.  If that
is not possible, labels SHOULD be normalized to Normalization Form C
(NFC) <xref target="UAX15" />.  For the same reason, PKCS #11 libraries,
slots (token readers), and tokens SHOULD use US-ASCII characters only
for their names, and if that is not possible, they SHOULD normalize
their names to NFC.  When listing PKCS #11 libraries, slots, tokens,
and/or objects, an application SHOULD normalize their names to NFC if
characters outside of the US-ASCII character set are expected.  When
matching PKCS #11 URIs to libraries, slots, tokens, and/or objects,
applications MAY convert names to a chosen normalization form before
the string comparison for matching, as those might predate these
recommendations.  See also <xref target="uri_matching" />.
</t>

</section>

<section anchor="security" title="Security Considerations">

<t> There are general security considerations for URI schemes
discussed in Section 7 of <xref target="RFC3986" />.</t>

<t>From those security considerations, Section 7.1 of <xref
target="RFC3986" /> applies since there is no guarantee that the same
PKCS #11 URI will always identify the same object, token, slot, or a
library in the future.</t>

<t>Section 7.2 of <xref target="RFC3986" /> applies since by accepting
query component attributes "module-name" or "module-path", the consumer
potentially allows loading of arbitrary code into a process.
</t>

<t>Section 7.5 of <xref target="RFC3986" /> applies since a PKCS #11
URI may be used in world-readable command-line arguments to run
applications, stored in public configuration files, or otherwise used
in clear text.  For that reason, the "pin-value" attribute should only
be used if the URI string itself is protected with the same level of
security as the token PIN itself otherwise is.
</t>

<t>The PKCS #11 specification does not provide means to authenticate
devices to users; it only authenticates users to tokens.
Instead, local and physical security are demanded: the user must be in
possession of their tokens, and the system into whose slots the users'
tokens are inserted must be secure.  As a result, the usual security
considerations regarding normalization do not arise.  For the same
reason, confusable script issues also do not arise.  Nonetheless, if
use of characters outside the US-ASCII character set is required, it
is best to normalize to NFC all strings appearing in PKCS #11 API
elements.  See also <xref target="i18n_considerations" />.
</t>

</section>

</middle>

<back>
<references title="Normative References">


    <reference  anchor='RFC3986' target='http://www.rfc-editor.org/info/rfc3986'>
    <front>
    <title>Uniform Resource Identifier (URI): Generic Syntax</title>
    <author initials='T.' surname='Berners-Lee' fullname='T. Berners-Lee'><organization /></author>
    <author initials='R.' surname='Fielding' fullname='R. Fielding'><organization /></author>
    <author initials='L.' surname='Masinter' fullname='L. Masinter'><organization /></author>
    <date year='2005' month='January' />
    </front>
    <seriesInfo name='STD' value='66'/>
    <seriesInfo name='RFC' value='3986'/>
    <format type='ASCII' octets='141811'/>
    </reference>

    <reference  anchor='RFC5234' target='http://www.rfc-editor.org/info/rfc5234'>
    <front>
    <title>Augmented BNF for Syntax Specifications: ABNF</title>
    <author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
    <author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
    <date year='2008' month='January' />
    </front>
    <seriesInfo name='STD' value='68'/>
    <seriesInfo name='RFC' value='5234'/>
    <format type='ASCII' octets='26359'/>
    </reference>

    <reference  anchor='RFC3629' target='http://www.rfc-editor.org/info/rfc3629'>
    <front>
    <title>UTF-8, a transformation format of ISO 10646</title>
    <author initials='F.' surname='Yergeau' fullname='F. Yergeau'><organization /></author>
    <date year='2003' month='November' />
    </front>
    <seriesInfo name='STD' value='63'/>
    <seriesInfo name='RFC' value='3629'/>
    <format type='ASCII' octets='33856'/>
    </reference>

    <reference  anchor='RFC2119' target='http://www.rfc-editor.org/info/rfc2119'>
    <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
    <date year='1997' month='March' />
    </front>
    <seriesInfo name='BCP' value='14'/>
    <seriesInfo name='RFC' value='2119'/>
    <format type='ASCII' octets='4723'/>
    </reference>
</references>

<references title="Informative References">

<reference anchor="BCP178" target="http://www.rfc-editor.org/info/bcp178">
        <front>
                <title>Deprecating the "X-" Prefix and Similar
		Constructs in Application Protocols</title>

                <author initials="P." surname="Saint-Andre"
		fullname="Peter Saint-Andre">
                </author>
                <author initials="D." surname="Crocker" fullname="Dave
		Crocker">
                </author>
                <author initials="M." surname="Nottingham" fullname="Mark
		Nottingham">
                </author>

                <date month="June" year="2012" />
        </front>
        <seriesInfo name="RFC" value="6648" />
        <seriesInfo name="BCP" value="178" />
</reference>

    <reference  anchor='RFC4395' target='http://www.rfc-editor.org/info/rfc4395'>
    <front>
    <title>Guidelines and Registration Procedures for New URI Schemes</title>
    <author initials='T.' surname='Hansen' fullname='T. Hansen'><organization /></author>
    <author initials='T.' surname='Hardie' fullname='T. Hardie'><organization /></author>
    <author initials='L.' surname='Masinter' fullname='L. Masinter'><organization /></author>
    <date year='2006' month='February' />
    </front> 
    <seriesInfo name='BCP' value='35'/>
    <seriesInfo name='RFC' value='4395'/>
    <format type='ASCII' octets='31933'/>
    </reference>

    <reference  anchor='RFC6570' target='http://www.rfc-editor.org/info/rfc6570'>
    <front>
    <title>URI Template</title>
    <author initials='J.' surname='Gregorio' fullname='J. Gregorio'><organization /></author>
    <author initials='R.' surname='Fielding' fullname='R. Fielding'><organization /></author>
    <author initials='M.' surname='Hadley' fullname='M. Hadley'><organization /></author>
    <author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
    <author initials='D.' surname='Orchard' fullname='D. Orchard'><organization /></author>
    <date year='2012' month='March' />
    </front>
    <seriesInfo name='RFC' value='6570'/>
    <format type='ASCII' octets='79813'/>
    </reference>


<reference anchor="PKCS11">
        <front>
                <title>PKCS #11 v2.20: Cryptographic Token Interface
                Standard</title>
                <author>
                        <organization>RSA Laboratories</organization>
                </author>
                <date month="June" year="2004" />
        </front>
	<seriesInfo name="Public Key Cryptography Standards" value="PKCS#11-v2.20"/>
</reference>

<reference anchor="UAX15" target="http://unicode.org/reports/tr15/">
        <front>
                <title>Unicode Standard Annex #15: Unicode
		Normalization Forms</title>
                <author initials="M." surname="Davis" fullname="Mark Davis"
		role="editor">
		</author>
                <author initials="K." surname="Whistler" fullname="Ken Whistler"
		role="editor">
		</author>
                <date month="June" year="2014" />
        </front>
	<seriesInfo name="Version" value="Unicode 7.0.0"/>
</reference>

</references>

<section title="Contributors" numbered="no">
<t>Stef Walter, Nikos Mavrogiannopoulos, Nico Williams, Dan Winship,
   Jaroslav Imrich, and Mark Phalan contributed to the development of
   this document. Shawn Emery shepherded the document.</t>
</section>

</back>


</rfc>


