<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY rfc0791 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.0791.xml'>
<!ENTITY rfc0793 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.0793.xml'>
<!ENTITY rfc0925 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.0925.xml'>
<!ENTITY rfc0959 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.0959.xml'>
<!ENTITY rfc1112 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1112.xml'>
<!ENTITY rfc1122 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1122.xml'>
<!ENTITY rfc1191 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1191.xml'>
<!ENTITY rfc1546 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1546.xml'>
<-- !ENTITY rfc1631 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1631.xml' -->
<!ENTITY rfc1812 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1812.xml'>
<!ENTITY rfc1918 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1918.xml'>
<!ENTITY rfc1958 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1958.xml'>
<!ENTITY rfc1981 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1981.xml'>
<!ENTITY rfc2101 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2101.xml'>
<!ENTITY rfc2461 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2461.xml'>
<!ENTITY rfc2491 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2491.xml'>
<!ENTITY rfc2644 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2644.xml'>
<!ENTITY rfc2767 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2767.xml'>
<!ENTITY rfc3338 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3338.xml'>
<!ENTITY rfc2775 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2775.xml'>
<!ENTITY rfc2923 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2923.xml'>
<!ENTITY rfc2979 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2979.xml'>
<!ENTITY rfc2991 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2991.xml'>
<!ENTITY rfc2993 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2993.xml'>
<!ENTITY rfc3021 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3021.xml'>
<!ENTITY rfc3069 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3069.xml'>
<!ENTITY rfc3077 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3077.xml'>
<!ENTITY rfc3550 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3550.xml'>
<!ENTITY rfc3552 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml'>
<!ENTITY rfc3618 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3618.xml'>
<!ENTITY rfc3775 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3775.xml'>
<!ENTITY rfc3819 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3819.xml'>
<!ENTITY rfc3927 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3927.xml'>
<!ENTITY rfc3972 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3972.xml'>
<!ENTITY rfc4007 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4007.xml'>
<!ENTITY rfc4301 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4301.xml'>
<!ENTITY rfc4380 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4380.xml'>
<!ENTITY rfc4423 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4423.xml'>
<!ENTITY rfc4601 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4601.xml'>
<!ENTITY rfc4786 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4786.xml'>
<!ENTITY rfc4821 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4821.xml'>
<!ENTITY rfc4861 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4861.xml'>
<!ENTITY rfc4890 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4890.xml'>
<!ENTITY rfc4903 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4903.xml'>
<!ENTITY rfc4948 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4948.xml'>
<!ENTITY rfc5213 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5213.xml'>
<!ENTITY rfc5218 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5218.xml'>
<!ENTITY rfc5694 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5694.xml'>


]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc compact="yes"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc subcompact="no"?>


<rfc number="6250" submissionType="IAB" category="info" ipr="trust200902" >
<front>
    <title abbrev="Evolution of the IP Model">
      Evolution of the IP Model
    </title>
    <author initials="D." surname="Thaler" fullname="Dave Thaler">
        <organization></organization>
        <address>
            <postal>
                <street>One Microsoft Way</street>
                <city>Redmond</city> <region>WA</region> <code>98052</code>
                <country>USA</country>
            </postal>
            <phone>+1 425 703 8835 </phone>
            <email>dthaler@microsoft.com</email>
        </address>
    </author>

    <author surname="IAB" fullname="Internet Architecture Board">
        <organization></organization>
        <address>
            <postal>
            </postal>
            <email>iab@iab.org</email>
        </address>
    </author>




    <date month="May" year="2011" />
    <abstract>
        <t> This RFC attempts to document various aspects of the IP service 
            model and how it has evolved over time. In particular, it
            attempts to document the properties of the IP layer as they
            are seen by upper-layer protocols and applications,
            especially properties that were (and, at times, still are) 
            incorrectly perceived to exist as well as properties that 
            would cause problems if changed.  The discussion of these
            properties is organized around evaluating a set of claims, or
            misconceptions. Finally,
            this document provides some guidance to protocol designers
            and implementers.
        </t>
    </abstract>
</front>

<middle>
<section title="Introduction">
    <t> Since the Internet Protocol was first published as 
        <xref target="IEN028"/> in 1978, 
        IP has provided a network-layer connectivity service to upper-layer 
        protocols and applications. The basic IP service model was documented 
        in the original IENs (and subsequently in the RFCs that obsolete 
        them).  However, since the mantra has been "Everything Over IP", 
        the IP 
        service model has evolved significantly over the past 30 years to 
        enable new behaviors that the original definition did not envision. 
        For example, by 1989 there was already some confusion and so
        <xref target="RFC1122"/> clarified many things and extended the
        model.  In 2004, <xref target="RFC3819"/> advised link-layer
        protocol designers on a number of issues that affect upper layers 
        and is the closest in intent to this document.
        Today's IP service model is not well documented in a single place, 
        but is either implicit or discussed piecemeal in many different RFCs. 
        As a result, today's IP service model is actually not well known, 
        or at least is often misunderstood. 
    </t>

    <t> In the early days of IP, changing or extending the basic IP service 
        model was easier since it was not as widely deployed and there were 
        fewer implementations. Today, the ossification of the Internet makes 
        evolving the IP model even more difficult. Thus, it is important to 
        understand the evolution of the IP model for two reasons: 
    </t>

    <list style="numbers">
        <t>To clarify what properties can and cannot be depended upon by upper-layer
protocols and applications. There are many misconceptions
            on which applications may be based
            and which are problematic. 
        </t>
        <t> To document lessons for future evolution to take into account. 
            It is important that the service model remain consistent, rather 
            than evolving in two opposing directions. It is sometimes the 
            case in IETF Working Groups today that directions are considered 
            or even taken that would change the IP service model. Doing this 
            without understanding the implications on applications can be 
            dangerous. 
        </t>
    </list>
    <t> This RFC attempts to document various aspects of the IP service 
        model and how it has evolved over time. In particular, it attempts
        to document 
        the properties of the IP layer, as seen by upper-layer 
        protocols and applications, especially properties that were 
        (and at times still are) incorrectly perceived to exist.  It also
        highlights properties that would cause problems if changed.
    </t>
</section>

<section title="The IP Service Model">
    <t> In this document, we use the term "IP service model" to refer to
        the model exposed by IP to higher-layer protocols and applications.
        This is depicted in <xref target="model"/> by the horizontal line.
    </t>

    <figure align="center" anchor="model">
        <artwork align="left"><![CDATA[
 +-------------+                                  +-------------+ 
 | Application |                                  | Application |
 +------+------+                                  +------+------+ 
        |                                                |
 +------+------+                                  +------+------+ 
 | Upper-Layer |                                  | Upper-Layer |
 |  Protocol   |                                  |  Protocol   |
 +------+------+                                  +------+------+ 
        |                                                |
------------------------------------------------------------------
        |                                                |
     +--+--+                  +-----+                 +--+--+
     | IP  |                  | IP  |                 | IP  |
     +--+--+                  +--+--+                 +--+--+
        |                        |                       |
  +-----+------+           +-----+------+          +-----+------+
  | Link Layer |           | Link Layer |          | Link Layer |
  +-----+------+           +--+-----+---+          +-----+------+
        |                     |     |                    |
        +---------------------+     +--------------------+

      Source                                        Destination
            ]]></artwork>
        <postamble>IP Service Model</postamble>
    </figure>

    <t> The foundation of the IP service model today is documented in 
        Section 2.2 of <xref target="RFC0791"/>. Generally speaking, IP provides 
        a connectionless delivery service for variable size packets, 
        which does not guarantee ordering, 
        delivery, or lack of duplication, but is merely best effort (although
        some packets may get better service than others). Senders 
        can send to a destination address without signaling a priori, and 
        receivers just listen on an already provisioned address, without 
        signaling a priori. 
    </t>

    <t> Architectural principles of the IP model are further discussed
        in <xref target="RFC1958"/> and in Sections 5 and 6 of <xref target="NEWARCH"/>.
    </t>

    <section title="Links and Subnets">
        <t> Section 2.1 of <xref target="RFC4903"/> discusses the terms 
            "link" and "subnet" with respect to the IP model. 
        </t>
        <t> A "link" in the IP service model refers to the topological area 
            within which a packet with an IPv4 Time to Live (TTL) or IPv6 Hop Limit of 1 can 
            be delivered. That is, where no IP-layer forwarding (which 
            entails a TTL/Hop Limit decrement) occurs between two nodes. 
        </t>
        <t> A "subnet" in the IP service model refers to the topological 
            area within which addresses from the same subnet prefix are 
            assigned to interfaces.
        </t>
    </section>
</section>

<section title="Common Application Misconceptions">
    <t> Below is a list of properties that are often assumed by 
        applications and upper-layer protocols, but which have become 
        less true over time. 
    </t>


    <section title="Misconceptions about Routing">

        <section title="Claim: Reachability is symmetric">


        <t> Many applications assume that if a host A can contact a host B,
            then the reverse is also true.  Examples of this behavior
            include request-response patterns, which require 
            reverse reachability only after forward reachability, as well as
            callbacks (e.g., as used by the File Transfer Protocol (FTP)
            <xref target="RFC0959"/>).
        </t>
        <t> Originally, it was the case that 
            reachability was symmetric (although the path taken may not be), 
            both within a link and across the Internet.  With the advent of 
            technologies such as Network Address Translators (NATs) and 
            firewalls (as in the following example figure), this can no 
            longer be assumed.  Today, host-to-host connectivity is
            challenging if not impossible in general.  It is relatively
            easy to initiate communication from hosts (A-E in the example 
            diagram) to servers (S), but not vice versa, nor between 
            hosts A-E.  For a longer discussion on peer-to-peer connectivity,
            see Appendix A of <xref target="RFC5694"/>.
        </t> 
    <figure align="center" anchor="SimplisticArchitecture">
        <artwork align="left"><![CDATA[
        __________                                 ___       ___
       /          \             ___        ___    /   \ ____|FW |__A
      /            \    ___    /   \ _____|NAT|__|     |    |___|
     |              |__|NAT|__|     |     |___|  |     |__B       
     |              |  |___|  |     |__C          \___/        
     |              |          \___/               ___
  S__|   Internet   |           ___        ___    /   \ 
     |              |   ___    /   \ _____|NAT|__|     |__D
     |              |__|FW |__|     |     |___|  |     |
     |              |  |___|  |     |__E          \___/
      \            /           \___/
       \__________/             
            ]]></artwork>
        <!-- <postamble>Example</postamble> -->
    </figure>
        <t> However, it is still the case that if a request can 
            be sent, then a reply to that request can generally be received, 
            but an unsolicited request in the other direction may not be
            received.  <xref target="RFC2993"/> discusses this in more
            detail.
            <!-- Unsolicited [unauthenticated] inbound reachability works -->
        </t>
        <t> There are also links (e.g., satellite) that were defined
            as unidirectional links and hence an address on such a link
            results in asymmetric reachability.  <xref target="RFC3077"/>
            explicitly addresses this problem for multihomed hosts by
            tunneling packets over another interface in order to restore
            symmetric reachability.
        </t>
        <t> Finally, even with common wireless networks such as 802.11, 
            this assumption may not be true, as discussed in Section 5.5 of
            <xref target="WIRELESS"/>.
        </t>
        </section>

        <section title="Claim: Reachability is transitive">
        <t> Many applications assume that if a host A can contact host B,
            and B can contact C, then host A can contact C.&nbsp;  Examples
            of this behavior include applications and protocols that use
            referrals.
        </t>
        <t> Originally, it was the case that 
            reachability was transitive, both within a link and across the 
            Internet. With the advent of technologies such as NATs and 
            firewalls and various routing policies, this can no longer be 
            assumed across the Internet, 
            but it is often still true within a link. As a result, 
            upper-layer protocols and applications may be relying on 
            transitivity 
            within a link. However, some radio technologies, 
            such as 802.11 ad hoc mode, violate this assumption within
            a link.
        </t>
        </section>

        <section title="Claim: Error messages can be received in response to data packets">
        <t> Some upper-layer protocols and applications assume that
            ICMP error messages will be received in response to packets
            sent that cannot be delivered.   Examples of this include 
            the use of Path MTU Discovery 
            <xref target="RFC1191"/> <xref target="RFC1981"/>
            relying on messages indicating packets were too big, 
            and traceroute and the use of expanding ring search 
            <xref target="RFC1812"/> relying on messages indicating 
            packets reached their TTL/Hop Limit.
        </t>
        <t> Originally, this assumption largely held, but many ICMP senders
            then chose to rate-limit responses in order to mitigate
            denial-of-service attacks, and many firewalls now block ICMP 
            messages entirely.  For a longer discussion, see Section 2.1 of
            <xref target="RFC2923"/>.
        </t>
        <t> This led to an alternate mechanism for Path MTU Discovery that
            does not rely on this assumption being true 
            <xref target="RFC4821"/> and guidance to firewall administrators 
            (<xref target="RFC4890"/> and Section 3.1.1 of <xref target="RFC2979"/>).
        </t>
        </section>

        <section title="Claim: Multicast is supported within a link">
        <t> <xref target="RFC1112"/> introduced multicast to the IP 
            service model. In this evolution, senders 
            still just send to a destination address without signaling a 
            priori, but in contrast to the original IP model, receivers must 
            signal to the network before they can receive traffic to 
            a multicast address. 
        </t>
        <t> Today, many applications and protocols use
            multicast addresses, including protocols for address 
            configuration, service discovery, etc.  (See
            <xref target="MCAST4"/> and <xref target="MCAST6"/> for those 
            that use well-known addresses.)
        </t>
        <t> Most of these only assume that multicast 
            works within a link and may or may not function across a wider 
            area. While network-layer multicast works over most link types, 
            there are Non-Broadcast Multi-Access (NBMA) links over which 
            multicast does not work (e.g., X.25, ATM, frame relay, 6to4, 
            Intra-Site Automatic Tunnel Addressing Protocol (ISATAP), Teredo) and this can interfere with some protocols and 
            applications.  Similarly, there are links such as 802.11 ad hoc
            mode where multicast packets may not get delivered to all 
            receivers on the link. <xref target="RFC4861"/> states:
        
        <list style="empty">
        <t>Note that all link types (including NBMA) are expected to provide
     multicast service for applications that need it (e.g., using multicast servers).</t></list>
and its predecessor [RFC2461] contained similar wording. </t>
        
      
        <t> However, not all link types today meet this expectation.
        </t>
        </section>

        <section title="Claim: IPv4 broadcast is supported">
        <t> IPv4 broadcast support was originally 
            defined on a link, across a network, and for subnet-directed 
            broadcast, and it is used by many applications and protocols. 
            For security reasons, however, <xref target="RFC2644"/> deprecated 
            the forwarding of broadcast packets.  Thus, since 1999, broadcast 
            can only be relied on within a link. Still, there exist NBMA 
            links over which broadcast does not work, and there exist some 
            "semi-broadcast" links (e.g., 802.11 ad hoc mode) where broadcast
            packets may not get delivered to all nodes on the link. 
            Another case where broadcast fails to work is when a
            /32 or /31 is assigned to a point-to-point interface
            (e.g., <xref target="RFC3021"/>), leaving no broadcast address 
            available.
        </t>
        <t> To a large extent, the addition of 
            link-scoped multicast to the IP service model obsoleted the need for broadcast. It is also worth noting that 
            the broadcast API model used by most platforms allows receivers 
            to just listen on an already provisioned address, without 
            signaling a priori, but in contrast to the unicast API model, 
            senders must signal to the local IP stack (SO_BROADCAST) before 
            they can send traffic to a broadcast address. However, from the 
            network's perspective, the host still sends without signaling 
            a priori. 
        </t>
        </section>

        <section title="Claim: Multicast/broadcast is less expensive than
                        replicated unicast">
        <t> Some applications and upper-layer protocols that use multicast
            or broadcast do so not because they do not know the addresses
            of receivers, but simply to avoid sending multiple copies
            of the same packet over the same link.
        </t>
        <t> In wired networks, sending 
            a single multicast packet on a link is generally less expensive 
            than sending multiple unicast packets. This may not be true for 
            wireless networks, where implementations can only send multicast 
            at the basic rate, regardless of the negotiated rates of potential 
            receivers.  As a result, replicated unicast may achieve much
            higher throughput across such links than multicast/broadcast
            traffic.
        </t>
        </section>

        <section title="Claim: The end-to-end latency of the first packet to a
                        destination is typical" anchor="initdelay">
        <t> Many applications and protocols choose a destination address by
            sending a message to each of a number of candidates,
            picking the first one to respond, and then using that
            destination for subsequent communication.  If the end-to-end
            latency of the first packet to each destination is atypical,
            this can result in a highly non-optimal destination
            being chosen, with much longer paths (and hence higher load on 
            the Internet) and lower throughput.
        </t>
        <t> Today, there are a number of reasons this is not true.
            First, when sending to a new destination there may be some 
            startup latency resulting from the link-layer or network-layer 
            mechanism in use, such as the Address Resolution Protocol (ARP), for instance.
            In addition, the first packet may follow a different path from
            subsequent packets.  For example, protocols such as 
            Mobile IPv6 <xref target="RFC3775"/>,
            Protocol Independent Multicast - Sparse Mode (PIM-SM) 
            <xref target="RFC4601"/>, and the Multicast Source Discovery 
            Protocol (MSDP) <xref target="RFC3618"/>
            send packets on one path, and then 
            allow immediately switching to a shorter path, resulting in 
            a large latency difference.  There are various proposals 
            currently being evaluated by
            the IETF Routing Research Group that result in similar
            path switching.
        </t>
        </section>

        <section title="Claim: Reordering is rare">
        <t> As discussed in <xref target="REORDER"/>, <xref target="RFC2991"/>, 
            and Section 15 of <xref target="RFC3819"/>, there are a number of 
            effects of
            reordering.  For example, reordering increases buffering
            requirements (and jitter) in many applications and in
            devices that do packet reassembly.  In particular, TCP <xref target="RFC0793"/>
            is adversely affected by reordering since it
            enters fast-retransmit when three packets are received before
            a late packet, which drastically lowers throughput.  Finally,
            some NATs and firewalls assume that the initial fragment
            arrives first, resulting in packet loss when this is not the
            case.
        </t>
        <t> Today, there are a number of things that cause reordering.
            For example, some routers do per-packet, round-robin load balancing,
            which, depending on the topology, can result in a great 
            deal of reordering.  As another example, when a packet is 
            fragmented at the sender, some hosts send the last fragment first.
            Finally, as discussed in <xref target="initdelay"/>, protocols 
            that do path switching after the first packet result in 
            deterministic reordering within the first burst of packets.
        </t>
        </section>

        <section title="Claim: Loss is rare and probabilistic, not deterministic">
        <t> In the original IP model, senders just send, 
            without signaling the network a priori. This works to a degree. 
            In practice, the last hop (and in rare cases, other hops) of the 
            path needs to resolve next hop information (e.g., the link-layer 
            address of the destination) on demand, which results in queuing 
            traffic, and if the queue fills up, some traffic gets dropped. 
            This means that bursty sources can be problematic (and indeed 
            a single large packet that gets fragmented becomes such a burst). 
            The problem is rarely observed in practice 
            today, either because the resolution within the last hop happens 
            very quickly, or because bursty applications are rarer. However, 
            any protocol that significantly increases such delays or adds 
            new resolutions would be a change to the classic IP model and 
            may adversely impact upper-layer protocols and applications 
            that result in bursts of packets.
        </t>
        <t> In addition, mechanisms that simply drop the first packet,
            rather than queuing it, also break this assumption.
            Similar to the result of reordering, they can result in
            a highly non-optimal destination being chosen by applications
            that use the first one to respond.  Two examples of mechanisms
            that appear to do this are network interface cards that
            support a "Wake-on-LAN" capability where any packet
            that matches a specified pattern will wake up a machine
            in a power-conserving mode, but only after dropping the
            matching packet, and MSDP, where encapsulating data packets 
            is optional, but doing so enables bursty sources to be 
            accommodated while a multicast tree is built back to the 
            source's domain.
        </t>
        </section>

        <section title="Claim: An end-to-end path exists at a single point in time">
        <t> In classic IP, applications assume that either an end-to-end path 
            exists to a destination or that the packet will 
            be dropped. In addition, IP today tends to assume that the 
            packet delay is relatively short (since the "Time"-to-Live is 
            just a hop count).  In IP's earlier history, the TTL field was 
            expected to also be decremented each second (not just each hop). 
        </t>
        <t> In general, this assumption is still true today.  However,
            the IRTF Delay Tolerant Networking Research Group is investigating 
            ways for applications to use IP in networks where this assumption
            is not true, such as store-and-forward networks (e.g., packets 
            carried by vehicles or animals).
        </t>
        </section>

        <section title="Discussion">
        <t> The reasons why the assumptions listed above are increasingly less
            true can be divided into two categories: effects caused by
            attributes of link-layer technologies and effects caused
            by network-layer technologies.
        </t>
        <t> RFC 3819 <xref target="RFC3819"/> advises link-layer
            protocol designers to minimize these effects.  Generally, the
            link-layer causes are not intentionally trying to break IP, but
            rather adding IP over the technology introduces the problem.
            Hence, where the link-layer protocol itself does not do so, 
            when specifying how IP is defined over such a link protocol,
            designers should compensate to the maximum extent possible.
            As examples, 
            <xref target="RFC3077"/> and <xref target="RFC2491"/> compensate
            for the lack of symmetric reachability and the lack of link-layer 
            multicast,
            respectively.  That is, when IP is defined over a link type,
            the protocol designers should attempt to restore the
            assumptions listed in this document.  For example,
            since an implementation can distinguish between 802.11 ad hoc
            mode versus infrastructure mode, it may be possible to define
            a mechanism below IP to compensate for the lack of transitivity
            over such links.
        </t>
        <t> At the network layer, as a general principle, we believe that
            reachability is good.  For security reasons 
            (<xref target="RFC4948"/>), however, it is
            desirable to restrict reachability by unauthorized parties; 
            indeed IPsec, an integral part of the IP model, provides
            one means to do so.
            Where there are issues with asymmetry, non-transitivity,
            and so forth, which are not direct results of restricting
            reachability to only authorized parties (for some definition
            of authorized), the IETF should attempt to avoid or solve   
            such issues.  Similar to the principle outlined in 
            Section 3.9 of <xref target="RFC1958"/>, 
            the general theme when defining a protocol is to be liberal in 
            what effects you accept, and conservative in what effects you 
            cause.
        </t>
        <t> However, in being liberal in what effects you accept, it is 
            also important to remember that diagnostics are important,
            and being too liberal can mask problems.  Thus, a tussle exists
            between the desire to provide a better experience to one's own
            users or applications and thus be more successful 
            (<xref target="RFC5218"/>), versus the desire to put pressure 
            on getting problems fixed.   One solution is to provide a 
            separate "pedantic mode" that can be enabled to see the problems
            rather than mask them.
        </t>
        </section>
    </section>

    <section title="Misconceptions about Addressing">
        <section title="Claim: Addresses are stable over long periods of time">
        <t> Originally, addresses were manually 
            configured on fixed machines, and hence addresses were very 
            stable.  With the advent of technologies such as DHCP, roaming, 
            and wireless, addresses can no longer be assumed to be stable 
            for long periods of time.  However, the APIs provided to 
            applications today typically still assume stable addresses
            (e.g., address lifetimes are not exposed to applications that 
            get addresses).  This can cause problems when addresses 
            become stale.
        </t>
        <t> For example, many applications resolve names to addresses
            and then cache them without any notion of lifetime.  In fact,
            the classic name resolution APIs do not even provide applications
            with the lifetime of entries.
        </t>
        <t> Proxy Mobile IPv6 <xref target="RFC5213"/>
            tries to restore this assumption to some extent by preserving
            the same address while roaming around a local area.  The
            issue of roaming between different networks has been known
            since at least 1980 when <xref target="IEN135"/> proposed a 
            mobility solution that attempted to restore this assumption
            by adding an additional address that can be used by applications,
            which is stable while roaming anywhere with Internet connectivity.
            More recent protocols such as Mobile IPv6 (MIP6) 
            <xref target="RFC3775"/> and the Host Identity Protocol (HIP) 
            <xref target="RFC4423"/> follow in this same vein.  

        </t>
        </section>

        <section title="Claim: An address is four bytes long">
        <t> Many applications and protocols were designed to only support
            addresses that are four bytes long.  Although this was sufficient
            for IPv4, the advent of IPv6 made this assumption invalid and
            with the exhaustion of IPv4 address space this assumption will
            become increasingly less true.  There have been some attempts
            to try to mitigate this problem with limited degrees of 
            success in constrained cases.  For example, "Bump-In-the-Stack" 
            <xref target="RFC2767"/> and "Bump-in-the-API" 
            <xref target="RFC3338"/> attempt to provide four-byte "IPv4"
            addresses for IPv6 destinations, but have many limitations
            including (among a number of others) all the problems of NATs.
        </t>
        </section>

        <section title="Claim: A host has only one address on one interface">
        <t> Although many 
            applications assume this (e.g., by calling a name resolution 
            function such as gethostbyname and then just using the first 
            address returned), it was never really true to begin with, 
            even if it was the common case.  Even <xref target="RFC0791"/> 
            states: 
        </t>
        <list style="empty">
        <t>
            ... provision must be made for a host to have several 
            physical interfaces to the network with each having several 
            logical Internet addresses.  
        </t>
        </list>
        <t> However, this assumption 
            is increasingly less true today, with the advent of multiple interfaces
            (e.g., wired and wireless), dual-IPv4/IPv6 nodes, multiple 
            IPv6 addresses on the same interface (e.g., link-local and 
            global), etc.  Similarly, many protocol specifications such 
            as DHCP only describe operations for a single interface, 
            whereas obtaining host-wide configuration from multiple
            interfaces presents a merging problem for nodes in practice.  
            Too often, this problem is simply ignored by Working Groups, 
            and applications and users suffer as a result from poor 
            merging algorithms.
        </t>
        <t> One use of protocols such as MIP6 and HIP is to
            make this assumption somewhat more true by adding an additional 
            "address" that can be the one used by such applications, and
            the protocol will deal with the complexity of multiple 
            physical interfaces and addresses.
        </t>
        </section>

        <section title="Claim: A non-multicast/broadcast address identifies
                        a single host over a long period of time">
        <t> Many applications and upper-layer protocols maintain a 
            communication session with a destination over some period
            of time.  If that address is reassigned to another host,
            or if that address is assigned to multiple hosts and
            the host at which packets arrive changes, such applications
            can have problems.
        </t>
        <t> In addition, many security mechanisms and configurations
            assume that one can block traffic by IP address, implying that
            a single attacker can be identified by IP address.  If that
            IP address can also identify many legitimate hosts, applying
            such a block can result in denial of service.
        </t>
        <t>
            <xref target="RFC1546"/> introduced the notion of anycast to
            the IP service model.  It states:
        </t>
        <list style="empty">
        <t> Because anycasting is stateless and does not guarantee
            delivery of multiple anycast datagrams to the same system, an
            application cannot be sure that it is communicating with the same
            peer in two successive UDP transmissions or in two successive TCP
            connections to the same anycast address.
        </t>
        <t> The obvious solutions to these issues are to require applications
            which wish to maintain state to learn the unicast address of their
            peer on the first exchange of UDP datagrams or during the first TCP
            connection and use the unicast address in future conversations.
        </t>
        </list>
        <t> The issues with anycast are further discussed in 
            <xref target="RFC4786"/> and 
            <xref target="ANYCAST"/>.
        </t>
        <t> Another mechanism by which multiple hosts use the same
            address is as a result of scoped addresses, as defined for both
            IPv4 <xref target="RFC1918"/> <xref target="RFC3927"/> and 
            IPv6 <xref target="RFC4007"/>.  Because such addresses
            can be reused within multiple networks, hosts in different
            networks can use the same address.  As a result, a host
            that is multihomed to two such networks cannot use the
            destination address to uniquely identify a peer.  For example,
            a host can no longer use a 5-tuple to uniquely identify a
            TCP connection.  This is why IPv6 added the concept of a 
            "zone index".
        </t>
        <t> Yet another example is that, in some high-availability solutions,
            one host takes over the IP address of another failed host.
        </t>
        <t> See <xref target="RFC2101"/>, <xref target="RFC2775"/>, and
            <xref target="SHARED-ADDRESSING"/> for
            additional discussion on address uniqueness.
        </t>
        </section>

        <section title="Claim: An address can be used as an indication of physical location">
        <t> Some applications attempt to use an address to infer some
            information about the physical location of the host with that
            address.   For example, geo-location services are often used to
            provide targeted content or ads.
        </t>
        <t> Various forms of tunneling have made this assumption less true,
            and this will become increasingly less true as the use of
            IPv4 NATs for large networks continues to increase.  See Section 7 of
            <xref target="SHARED-ADDRESSING"/>
            for a longer discussion.
        </t>
        </section>
        
        <section title="Claim: An address used by an application is the same as
                        the address used for routing">
        <t> Some applications assume that the address the application
            uses is the same as that used by routing.  For example,
            some applications use raw sockets to read/write packet
            headers, including the source and destination addresses in
            the IP header.  As another example, some applications make
            assumptions about locality (e.g., whether the destination
            is on the same subnet) by comparing addresses.
        </t>
        <t> Protocols such as Mobile IPv6 and HIP specifically break this 
            assumption
            (in an attempt to restore other assumptions as discussed above).
            Recently, the IRTF Routing Research Group has been evaluating
            a number of possible mechanisms, some of which would also
            break this assumption, while others preserve this assumption
            near the edges of the network and only break it in the
            core of the Internet.
        </t>
        <t> Breaking this assumption is sometimes referred to as
            an "identifier/locator" split.  However, as originally defined in 1978
            (<xref target="IEN019"/>, <xref target="IEN023"/>), an 
            address was originally  defined as only a locator, whereas 
            names were defined to be the identifiers.  However, the TCP 
            protocol then used addresses as identifiers.
        </t>
        <t> Finally, in a liberal sense, any tunneling mechanism might be 
            said to break this assumption, although, in practice, applications 
            that make this assumption will continue to work, since the
            address of the inside of the tunnel is still used for
            routing as expected.
        </t>
        </section>

        <section title="Claim: A subnet is smaller than a link">
        <t> In the classic IP model, a "subnet" is smaller than, or equal to, 
            a "link".  Destinations with addresses in the same on-link subnet 
            prefix can be reached with TTL 
            (or Hop Count) = 1.  Link-scoped multicast packets, and 
            all-ones broadcast packets will be delivered (in a best-effort 
            fashion) to all listening nodes on the link.   Subnet broadcast 
            packets will be delivered (in a best effort fashion) to all
            listening nodes in the subnet.  There have been some efforts 
            in the past (e.g., <xref target="RFC0925"/>, 
            <xref target="RFC3069"/>) to allow multi-link subnets and 
            change the above 
            service model, but the adverse impact on applications that 
            have such assumptions recommend against changing this 
            assumption.
        </t>
        <t> <xref target="RFC4903"/> discusses this topic in 
            more detail and surveys a number of protocols and applications
            that depend on this assumption.  Specifically, some applications
            assume that, if a destination address is in the same on-link subnet 
            prefix as the local machine, then therefore packets can be
            sent with TTL=1, or that packets can be received with TTL=255,
            or link-scoped multicast or broadcast can be used to reach
            the destination.
        </t>
        </section>

        <section title="Claim: Selecting a local address selects the interface"
                 anchor="weakhost">
        <t> Some applications 
            assume that binding to a given local address constrains traffic 
            reception to the interface with that address, and that traffic 
            from that address will go out on that address's interface. 
            However, Section 3.3.4.2 of <xref target="RFC1122"/> defines two 
            models: the Strong End System (or strong host) model where this 
            is true, and the Weak End System (or weak host) model where this 
            is not true. In fact, any router is inherently a weak host 
            implementation, since packets can be forwarded between interfaces. 
        </t>
        </section>

        <section title="Claim: An address is part of an on-link subnet prefix">
        <t> To some extent, this 
            was never true, in that there were cases in IPv4 where the 
            "mask" was 255.255.255.255, such as on a point-to-point link 
            where the two endpoints had addresses out of unrelated address 
            spaces, and no on-link subnet prefix existed on the link. 
            However, this didn't stop many platforms and applications 
            from assuming that every address had a "mask" (or prefix) that 
            was on-link. The assumption of whether a subnet is on-link (in 
            which case one can send directly to the destination after 
            using ARP/ND) or off-link (in which case one just sends to 
            a router) has evolved over the years, and it can no longer 
            be assumed that an address has an on-link prefix. 
            In 1998, <xref target="RFC2461"/> introduced the distinction as 
            part of the core IPv6 protocol suite. 
            This topic is discussed further in
            <xref target="ON-OFF-LINK"/>,
            and <xref target="RFC4903"/> 
            also touches on this topic with respect to the service model seen 
            by applications.  
        </t>
        </section>

        <section title="Discussion">
        <t> Section 4.1 of RFC 1958 <xref target="RFC1958"/> states:
            "In general, user applications should use names rather than
            addresses".
        </t>
        <t> We emphasize the above point, which is too often ignored.
            Many commonly used APIs unnecessarily expose addresses to 
            applications that already use names.  Similarly, some protocols
            are defined to carry addresses, rather than carrying names
            (instead of or in addition to addresses).  Protocols
            and applications that are already dependent on a naming
            system should be designed in such a way that they avoid or
            minimize any dependence on the notion of addresses.
        </t>
        <t> One challenge is that many hosts today do not have names
            that can be resolved.  For example, a host may not have a 
            fully qualified domain name (FQDN) or a Domain Name System (DNS) 
            server that will host its name.
        </t>
        <t> Applications that, for whatever reason, cannot use names
            should be IP-version agnostic.
        </t>
        </section>
    </section>

    <section title="Misconceptions about Upper-Layer Extensibility">
        <section title="Claim: New transport-layer protocols can work across the
                        Internet">
        <t> IP was originally designed to support the addition of new
            transport-layer protocols, and <xref target="PROTOCOLS"/>
            lists many such protocols.
        </t>
        <t> However, as discussed in
            <xref target="WAIST-HOURGLASS"/>,
            NATs and firewalls today break this assumption and often
            only allow UDP and TCP (or even just HTTP).
        </t>
        <t> Hence, while new protocols may work from some places, they
            will not necessarily work from everywhere, such as from behind
            such NATs and firewalls.
        </t>
        <t> Since even UDP and TCP may not work from everywhere, it may
            be necessary for applications to support "HTTP failover" modes.
            The use of HTTP as a "transport of last resort" has become 
            common (e.g., <xref target="BOSH"/> among others) even in
            situations where it is sub-optimal, such as in real-time
            communications or where bidirectional communication is
            required.  Also, the IETF HyBi Working Group is now in the
            process of designing a standards-based solution for layering
            other protocols on top of HTTP.  As a result of having
            to support HTTP failover, applications may have to be 
            engineered to sustain higher latency.
        </t>
        </section> 

        <section title="Claim: If one stream between a pair of addresses can get
                        through, then so can another">
        <t> Some applications and protocols use multiple upper-layer streams
            of data between the same pair of addresses and initiated by
            the same party.  Passive-mode FTP <xref target="RFC0959"/>, and 
            RTP <xref target="RFC3550"/>, are two examples of such protocols, 
            which use separate streams for data versus control channels.
        </t>
        <t>
            Today, there are many reasons why this may not be true.
            Firewalls, for example, may selectively allow/block specific
            protocol numbers and/or values in upper-layer protocol fields
            (such as port numbers).  Similarly, middleboxes such as NATs
            that create per-stream state may cause other streams to fail
            once they run out of space to store additional stream state.
        </t>
        </section>

        <section title="Discussion">
        <t> Section 5.1 of <xref target="NEWARCH"/> discusses the primary
            requirements of the original Internet architecture, including
            Service Generality.  It states:
        </t>
<list>
        <t> This goal was to support the widest possible range of 
            applications, by supporting a variety of types of
            service at the transport level. Services might be distinguished 
            by speed, latency, or reliability, for example. Service types 
            might include virtual circuit service, which provides reliable, 
            full-duplex byte streams, and also datagram service, which 
            delivers individual packets with no guarantees of reliability
            or ordering. The requirement for datagram service was motivated 
            by early ARPAnet experiments with packet speech (using IMP 
            Type 3 messages).
        </t>
</list>
        <t> The reasons that the assumptions in this section are becoming less
            true are due to network-layer (or higher-layer) techniques
            being introduced that interfere with the original requirement.
            Generally, these are done either in the name of security
            or as a side effect of solving some other problem such
            as address shortage.  Work is needed to investigate ways to 
            restore the original behavior while still meeting today's
            security requirements.
        </t>
        </section>
    </section>

    <section title="Misconceptions about Security">
        <section title="Claim: Packets are unmodified in transit">
        <t> Some applications and upper-layer protocols assume that
            a packet is unmodified in transit, except for a few well-defined
            fields (e.g., TTL).  Examples of this behavior include protocols
            that define their own integrity-protection mechanism such as
            a checksum.
        </t>
        <t> This assumption is broken by NATs as discussed in <xref 
            target="RFC2993"/> and other middleboxes that modify the
            contents of packets.  There are many tunneling technologies
            (e.g., <xref target="RFC4380"/>) that attempt to restore 
            this assumption to some extent.
        </t>
        <t> The IPsec architecture <xref target="RFC4301"/> added security
            to the IP model, providing a way to address this problem 
            without changing applications, although transport-mode IPsec
            is not currently widely used over the Internet.
        </t>
        </section>

        <section title="Claim: Packets are private">
        <t> The assumption that data is private has never really been true.
            However, many old applications and protocols (e.g., FTP) 
            transmit passwords or other sensitive data in the clear.  
        </t>
        <t> IPsec provides
            a way to address this problem without changing applications,
            although it is not yet widely deployed, and doing 
            encryption/decryption for all packets can be computationally
            expensive.
        </t>
        </section>

        <section title="Claim: Source addresses are not forged">
        <t> Most applications and protocols use the source
            address of some incoming packet when generating a response,
            and hence assume that it has not been forged (and as a
            result can often be vulnerable to various types of attacks
            such as reflection attacks).
        </t>
        <t> Various mechanisms that restore this assumption include, for
            example, IPsec and Cryptographically Generated Addresses (CGAs)
            <xref target="RFC3972"/>.
        </t>
        </section>

        <section title="Discussion">
        <t> A good discussion of threat models and common tools can
            be found in <xref target="RFC3552"/>.  Protocol designers 
            and applications developers are encouraged to be familiar 
            with that document.
        </t>
        </section>
    </section>
</section>

<section title="Security Considerations">
    <t> This document discusses assumptions about the IP service model
        made by many applications and upper-layer protocols.  Whenever
        these assumptions are broken, if the application or upper-layer
        protocol has some security-related behavior that is based on
        the assumption, then security can be affected.
    </t> 
    <t> For example, if an application assumes that binding to the IP
        address of a "trusted" interface means that it will never receive
        traffic from an "untrusted" interface, and that assumption is
        broken (as discussed in <xref target="weakhost"/>), then an attacker
        could get access to private information.
    </t>
    <t> As a result, great care should be taken when expanding the extent
        to which an assumption is false.  On the other hand, application
        and upper-layer protocol developers should carefully consider the
        impact of basing their security on any of the assumptions enumerated 
        in this document.
    </t>
    <t> It is also worth noting that many of the changes that have occurred 
        over time (e.g., firewalls, dropping directed broadcasts, etc.) that 
        are discussed in this document were done in the interest of improving 
        security at the expense of breaking some applications.
    </t>
</section>


<section title="Conclusion">
    <t> Because a huge number of applications already exist that use TCP/IP 
        for business-critical operations, any changes to the service model 
        need to be done with extreme care. Extensions that merely add 
        additional optional functionality without impacting any existing 
        applications are much safer than extensions that change one or 
        more of the core assumptions discussed above. Any changes to the 
        above assumptions should only be done in accordance with some 
        mechanism to minimize or mitigate the risks of breaking 
        mission-critical applications. Historically, changes have been done 
        without regard to such considerations and, as a result, the situation 
        for applications today is already problematic. The key to maintaining an 
        interoperable Internet is documenting and maintaining invariants 
        that higher layers can depend on, and being very judicious with 
        changes. 
    </t>
    <t> In general, lower-layer protocols should document the contract
        they provide to higher layers; that is, what assumptions the
        upper layer can rely on (sometimes this is done in the form of an
        applicability statement).  Conversely, higher-layer protocols
        should document the assumptions they rely on from the lower layer
        (sometimes this is done in the form of requirements).
    </t>
    <t> We must also recognize that a successful architecture often evolves
        as success brings growth and as technology moves forward.  As a
        result, the various assumptions made should be periodically reviewed
        when updating protocols.
    </t>
</section>

<section title="Acknowledgements">
        <!-- Bernard Aboba -->
    <t> Chris Hopps, Dow Street, Phil Hallam-Baker, and others provided helpful 
        discussion on various points that led to this document.  Iain Calder,
        Brian Carpenter, Jonathan Rosenberg, Erik Nordmark, Alain Durand, and 
        Iljitsch van Beijnum also provided valuable feedback.
    </t>
</section>

<section title="IAB Members at the Time of This Writing">
    <figure>
        <artwork>
Loa Andersson
Gonzalo Camarillo
Stuart Cheshire
Russ Housley
Olaf Kolkman
Gregory Lebovitz
Barry Leiba
Kurtis Lindqvist
Andrew Malis
Danny McPherson
David Oran
Dave Thaler
Lixia Zhang
        </artwork>
    </figure>
</section>

<section title="IAB Members at the Time of Approval">
    <figure>
        <artwork>
Bernard Aboba
Marcelo Bagnulo
Ross Callon
Spencer Dawkins
Russ Housley
John Klensin
Olaf Kolkman
Danny McPherson
Jon Peterson
Andrei Robachevsky
Dave Thaler
Hannes Tschofenig
        </artwork>
    </figure>
</section>

</middle>

<back>
<?rfc rfcedstyle="no" ?>
<references title="Normative References">

    &rfc0791; 
    &rfc1112; 
    &rfc1122; 
    &rfc1546; 
    &rfc2461; 
    &rfc2644; 
    &rfc4301; 
    &rfc4861; 

</references>

<references title="Informative References">

<!--    &I-D.iab-anycast-arch-implications; -->
<reference anchor='ANYCAST'>
<front>
<title>Architectural Considerations of IP Anycast</title>

<author initials='D' surname='McPherson' fullname='Danny McPherson'>
    <organization />
</author>

<author initials='D' surname='Oran' fullname='David Oran'>
    <organization />
</author>

<date month='February' day='9' year='2010' />

<abstract><t>This memo discusses architectural implications of IP anycast.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

<!--    &I-D.rosenberg-internet-waist-hourglass; -->


<reference anchor='WAIST-HOURGLASS'>
<front>
<title>UDP and TCP as the New Waist of the Internet Hourglass</title>

<author initials='J' surname='Rosenberg' fullname='Jonathan Rosenberg'>
    <organization />
</author>

<date month='February' day='11' year='2008' />

<abstract><t>One of the fundamental design principles of the Internet is that IP represents a common intermediate protocol layer, linking together a variety of link layer technologies underneath with a large number of applications on top.  When drawn graphically, this can be show as an hourglass with IP in the middle.  The preponderence of NATs and firewalls in the Internet has changed this reality, such that UDP and TCP are now the waist of the hourglass.  This document discusses this change and describes its implications for protocol and application design.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

<!--    &I-D.wbeebee-on-link-and-off-link-determination; -->


<reference anchor='ON-OFF-LINK'>
<front>
<title>IPv6 Subnet Model</title>

<author initials='H' surname='Singh' fullname='Hemant Singh'>
    <organization />
</author>

<author initials='W' surname='Beebee' fullname='Wes Beebee'>
    <organization />
</author>

<author initials='E' surname='Nordmark' fullname='Erik Nordmark'>
    <organization />
</author>

<date month='February' day='25' year='2008' />

<abstract><t>IPv6 specifies a model of a subnet that is different than the IPv4 subnet model.  The subtlety of the differences has turned out to cause interoperability problems.  This note spells out the most important difference; that an IPv6 address isn't automatically associated with an IPv6 on-link subnet prefix.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>

<!--    &I-D.ietf-intarea-shared-addressing-issues; -->



<reference anchor='SHARED-ADDRESSING'>
<front>
<title>Issues with IP Address Sharing</title>

<author initials='M' surname='Ford' fullname='Mat Ford'>
    <organization />
</author>

<author initials='M' surname='Boucadair' fullname='Mohammed Boucadair'>
    <organization />
</author>

<author initials='A' surname='Durand' fullname='Alain Durand'>
    <organization />
</author>

<author initials='P' surname='Levis' fullname='Pierre Levis'>
    <organization />
</author>

<author initials='P' surname='Roberts' fullname='Phil Roberts'>
    <organization />
</author>

<date month='March' day='3' year='2011' />

<abstract><t>The completion of IPv4 address allocations from IANA and the RIRs is causing service providers around the world to question how they will continue providing IPv4 connectivity service to their subscribers when there are no longer sufficient IPv4 addresses to allocate them one per subscriber.  Several possible solutions to this problem are now emerging based around the idea of shared IPv4 addressing.  These solutions give rise to a number of issues and this memo identifies those common to all such address sharing approaches.  Such issues include application failures, additional service monitoring complexity, new security vulnerabilities and so on.  Solution- specific discussions are out of scope.  Deploying IPv6 is the only perennial way to ease pressure on the public IPv4 address pool without the need for address sharing mechanisms that give rise to the issues identified herein.</t></abstract>

</front>

<seriesInfo name='Work in' value='Progress' />

</reference>


<reference anchor="BOSH"
               target="http://xmpp.org/extensions/xep-0124.html">
        <front>
            <title>Bidirectional-streams Over Synchronous HTTP (BOSH)
            </title>
            <author initials="I." surname="Paterson">
                <organization></organization>
                <address/>
            </author>
            <author initials="D." surname="Smith">
                <organization></organization>
                <address/>
            </author>
            <author initials="P." surname="Saint-Andre">
                <organization></organization>
                <address/>
            </author>
            <author initials="J." surname="Moffitt">
                <organization></organization>
                <address/>
            </author>
            <date year="2010"/>
        </front>
        <seriesInfo name="XEP" value="0124" />
    </reference>

    <reference anchor="IEN019"
               target="http://www.rfc-editor.org/ien/ien19.txt">
        <front>
            <title>A note on Inter-Network Naming, Addressing, and Routing
            </title>
            <author initials="J.F." surname="Shoch">
                <organization></organization>
                <address/>
            </author>
            <date month="January" year="1978"/>
        </front>
        <seriesInfo name="IEN" value="19" />
    </reference>

    <reference anchor="IEN023"
               target="http://www.rfc-editor.org/ien/ien23.txt">
        <front>
            <title>On Names, Addresses and Routings</title>
            <author initials="D." surname="Cohen">
                <organization></organization>
                <address/>
            </author>
            <date month="January" year="1978"/>
        </front>
        <seriesInfo name="IEN" value="23" />
    </reference>

    <reference anchor="IEN028" 
               target="http://www.rfc-editor.org/ien/ien28.pdf">

        <front>
            <title>Draft Internetwork Protocol Specification</title>
            <author initials="J." surname="Postel">
                <organization></organization>
                <address/>
            </author>
            <date month="February" year="1978"/>
        </front>
        <seriesInfo name="IEN" value="28" />
    </reference>

    <reference anchor="IEN135" 
               target="http://www.rfc-editor.org/ien/ien135.txt">
        <front>
            <title>Addressing Mobile Hosts in the ARPA Internet Environment
            </title>
            <author initials="C." surname="Sunshine">
                <organization></organization>
                <address/>
            </author>
            <author initials="J." surname="Postel">
                <organization></organization>
                <address/>
            </author>
            <date month="March" year="1980"/>
        </front>
        <seriesInfo name="IEN" value="135" />
    </reference>




    <reference anchor="MCAST4"
               target="http://www.iana.org/assignments/multicast-addresses">
        <front>
            <title>IPv4 Multicast Addresses</title>
            <author>
                <organization>Internet Assigned Numbers Authority</organization>
                <address/>
            </author>
        </front>
    </reference>

    <reference anchor="MCAST6"
           target="http://www.iana.org/assignments/ipv6-multicast-addresses">
        <front>
            <title>INTERNET PROTOCOL VERSION 6 MULTICAST ADDRESSES</title>
            <author>
                <organization>Internet Assigned Numbers Authority</organization>
                <address/>
            </author>
        </front>
    </reference>

    <reference anchor="PROTOCOLS"
           target="http://www.iana.org/assignments/protocol-numbers">
        <front>
            <title>Protocol Numbers</title>
            <author>
                <organization>Internet Assigned Numbers Authority</organization>
                <address/>
            </author>
        </front>
    </reference>

    <reference anchor="REORDER">
        <front>
            <title>Packet reordering is not pathological network behavior
            </title>
            <author initials="J.C.R." surname="Bennett">
                <organization></organization>
                <address/>
            </author>

            <author initials="C." surname="Partridge">
                <organization></organization>
                <address/>
            </author>

            <author initials="N." surname="Shectman">
                <organization></organization>
                <address/>
            </author>

            <date month="December" year="1999"/>
        </front>

        <seriesInfo name="IEEE/ACM Transactions on Networking,"
                    value="Vol. 7, No. 6" />
    </reference>

    &rfc0793; 
    &rfc0925; 
    &rfc0959; 
    &rfc1191; 
    <!-- &rfc1631; -->
    &rfc1812; 
    &rfc1918; 
    &rfc1958; 
    &rfc1981; 
    &rfc2101; 
    &rfc2491; 
    &rfc2767; 
    &rfc2775; 
    &rfc2923; 
    &rfc2979; 
    &rfc2991; 
    &rfc2993; 
    &rfc3021; 
    &rfc3069; 
    &rfc3077; 
    &rfc3338; 
    &rfc3550; 
    &rfc3552; 
    &rfc3618; 
    &rfc3775; 
    &rfc3819; 
    &rfc3927; 
    &rfc3972; 
    &rfc4007; 
    &rfc4380; 
    &rfc4423; 
    &rfc4601; 
    &rfc4786; 
    &rfc4821; 
    &rfc4890; 
    &rfc4903; 
    &rfc4948; 
    &rfc5213; 
    &rfc5218; 
    &rfc5694; 

    <reference anchor="WIRELESS"
               target="http://www.cs.dartmouth.edu/cms_file/SYS_techReport/337/TR2003-467.pdf">


        <front>
            <title>The mistaken axioms of wireless-network research
            </title>
            <author initials="D." surname="Kotz">
                <organization></organization>
                <address/>
            </author>

            <author initials="C." surname="Newport">
                <organization></organization>
                <address/>
            </author>

            <author initials="C." surname="Elliott">
                <organization></organization>
                <address/>
            </author>

            <date month="July" year="2003"/>
        </front>

        <seriesInfo name="Dartmouth College Computer Science Technical Report"
                    value="TR2003-467" />
    </reference>

    <reference anchor="NEWARCH"
               target="http://www.dtic.mil/cgi-bin/GetTRDoc?AD=ADA426770&Location=U2&doc=GetTRDoc.pdf">
        <front>
            <title>New Arch: Future Generation Internet Architecture
            </title>
            <author initials="" surname="Clark, D., et al.">
                <organization></organization>
                <address/>
            </author>

            <date month="August" year="2004"/>
        </front>

        <seriesInfo name="Air Force Research Laboratory Technical Report"
                    value="AFRL-IF-RS-TR-2004-235" />
    </reference>

</references>

<?rfc rfcedstyle="yes"?>
</back>
</rfc>
