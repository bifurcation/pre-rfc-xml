<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc rfcedstyle="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc number="7217" category="std" consensus="yes" submissionType="IETF" ipr="trust200902">
<front>
<title abbrev="Stable and Opaque IIDs with SLAAC">A Method for Generating Semantically Opaque Interface Identifiers with&nbsp;IPv6&nbsp;Stateless&nbsp;Address&nbsp;Autoconfiguration&nbsp;(SLAAC)</title>
    <author fullname="Fernando Gont" initials="F." surname="Gont">
      <organization abbrev="SI6 Networks / UTN-FRH">SI6 Networks / UTN-FRH</organization>

      <address>
        <postal>
          <street>Evaristo Carriego 2644</street>

          <code>1706</code>

          <city>Haedo</city>

          <region>Provincia de Buenos Aires</region>

          <country>Argentina</country>
        </postal>

        <phone>+54 11 4650 8472</phone>

        <email>fgont@si6networks.com</email>

        <uri>http://www.si6networks.com</uri>
      </address>
    </author>
<date month="April" year="2014" />
<area>Internet</area>
<workgroup>IPv6 maintenance Working Group (6man)</workgroup>

<keyword>addressing</keyword>
<keyword>privacy</keyword>
<keyword>security</keyword>
<keyword>tracking</keyword>
<keyword>scanning</keyword>

    <abstract>
    <t>
This document specifies a method for generating IPv6 Interface Identifiers to
be used with IPv6 Stateless Address Autoconfiguration (SLAAC), such that an IPv6 address configured using this method is stable within each subnet, but the corresponding Interface Identifier changes when the host moves from one network to another. This
method is meant to be an alternative to generating Interface Identifiers based
on hardware addresses (e.g., IEEE LAN Media Access Control (MAC) addresses), such that the benefits of stable addresses can be achieved without sacrificing the security and privacy of users. The method specified in this document applies to all prefixes a host may be employing, including link-local, global, and unique-local prefixes (and their corresponding addresses).
    </t>
    </abstract>
  </front>

  <middle>
  
  
<section title="Introduction" anchor="intro">
<t><xref target="RFC4862"/> specifies Stateless Address
  Autoconfiguration (SLAAC) for IPv6 <xref target="RFC2460"/>, which
  typically results in hosts configuring one or more "stable"
  addresses composed of a network prefix advertised by a local router,
  and an Interface Identifier (IID) that typically embeds a hardware
  address (e.g., an IEEE LAN MAC address)
  <xref target="RFC4291"/>. Cryptographically Generated Addresses
  (CGAs) <xref target="RFC3972"/> are yet another method for
  generating Interface Identifiers; CGAs bind a public signature key to an IPv6 address in the SEcure Neighbor Discovery (SEND) <xref target="RFC3971"/> protocol.</t>

<t>Generally, the traditional SLAAC addresses are thought to simplify network management, since they simplify Access Control Lists (ACLs) and logging. However, they have a number of drawbacks:
<list style="symbols">
<t>Since the resulting Interface Identifiers do not vary over time, they allow correlation of host activities within the same network, thus negatively affecting the privacy of users (see <xref target="ADDR-GEN-PRIVACY"/> and <xref target="IAB-PRIVACY"/>).</t>
<t>Since the resulting Interface Identifiers are constant across networks, the resulting IPv6 addresses can be leveraged to track and correlate the activity of a host across multiple networks (e.g., track and correlate the activities of a typical client connecting to the public Internet from different locations), thus negatively affecting the privacy of users.</t>
<t>Since embedding the underlying link-layer address in the Interface Identifier will result in specific address patterns, such patterns may be leveraged by attackers to reduce the search space when performing address-scanning attacks <xref target="IPV6-RECON"/>. For example, the IPv6 addresses of all hosts manufactured by the same vendor (within a given time frame) will likely contain the same IEEE Organizationally Unique Identifier (OUI) in the Interface Identifier.</t>
<t>Embedding the underlying hardware address in the Interface Identifier leaks device-specific information that could be leveraged to launch device-specific attacks.
</t>
<t>Embedding the underlying link-layer address in the Interface Identifier means that replacement of the underlying interface hardware will result in a change of the IPv6 address(es) assigned to that interface.</t>
</list>

<xref target="ADDR-GEN-PRIVACY"/> provides additional details regarding how the aforementioned vulnerabilities could be exploited and the extent to which the method discussed in this document mitigates them.
</t>
<t>
The "Privacy Extensions for Stateless Address Autoconfiguration in IPv6" <xref target="RFC4941"/> (henceforth referred to as "temporary addresses") were introduced to complicate the task of eavesdroppers and other information collectors (e.g., IPv6 addresses in web server logs or email headers, etc.) to correlate the activities of a host, and basically result in temporary (and random) Interface Identifiers. These temporary addresses are generated in addition to the traditional IPv6 addresses based on IEEE LAN MAC addresses, with the temporary addresses being employed for "outgoing communications", and the traditional SLAAC addresses being employed for "server" functions (i.e., receiving incoming connections). 
</t>
<t>
It should be noted that temporary addresses can be challenging in a number of areas. For example, from a network-management point of view, they tend to increase the complexity of event logging, troubleshooting, enforcement of access controls, and quality of service, etc. As a result, some organizations disable the use of temporary addresses even at the expense of reduced privacy <xref target="BROERSMA"/>. Temporary addresses may also result in increased implementation complexity, which might not be possible or desirable in some implementations (e.g., some embedded devices).
</t>
<t>In scenarios in which temporary addresses are deliberately not used (possibly for any of the aforementioned reasons), all a host is left with is the stable addresses that have typically been generated from the underlying hardware addresses. In such scenarios, it may still be desirable to have addresses that mitigate address-scanning attacks and that, at the very least, do not reveal the host's identity when roaming from one network to another -- without complicating the operation of the corresponding networks.
</t>

<t>However, even with temporary addresses in place, a number of issues remain to be mitigated. Namely,
<list style="symbols">
<t>since temporary addresses <xref target="RFC4941"/> do not eliminate the use of fixed identifiers for server-like functions, they only partially mitigate host-tracking and activity correlation across networks (see <xref target="ADDR-GEN-PRIVACY"/> for some example attacks that are still possible with temporary addresses).</t>
<t>since temporary addresses <xref target="RFC4941"/> do not replace the traditional SLAAC addresses, an attacker can still leverage patterns in SLAAC addresses to greatly reduce the search space for "alive" nodes <xref target="GONT-DEEPSEC2011"/> <xref target="CPNI-IPV6"/> <xref target="IPV6-RECON"/>.</t>
</list>
Hence, there is a motivation to improve the properties of "stable"
addresses regardless of whether or not temporary addresses are employed.
</t>


<t>This document specifies a method to generate Interface Identifiers
  that are stable for each network interface within each
  subnet, but that change as a host moves from one network to
  another. Thus, this method enables keeping the "stability" properties of the Interface Identifiers specified in <xref target="RFC4291"/>, while still mitigating address-scanning attacks and preventing correlation of the activities of a host as it moves from one network to another.</t>
</section>

<section title="Terminology" anchor="terminology">
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
   NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   <xref target="RFC2119"/>.</t>
</section>

<section title="Relationship to Other Standards" anchor="relationship">
<t>The method specified in this document is orthogonal to the use of temporary addresses <xref target="RFC4941"/>, since it is meant to improve the security and privacy properties of the stable addresses that are employed along with the aforementioned temporary addresses. In scenarios in which temporary addresses are employed, implementation of the mechanism described in this document (in replacement of stable addresses based on, e.g., IEEE LAN MAC addresses) will mitigate address-scanning attacks and also mitigate the remaining vectors for correlating host activities based on the host's constant (i.e., stable across networks) Interface Identifiers. On the other hand, for hosts that currently disable temporary addresses <xref target="RFC4941"/>, implementation of this mechanism would mitigate the host-tracking and address-scanning issues discussed in <xref target="intro"/>.</t> 


<t>While the method specified in this document is meant to be used with SLAAC, this does not preclude this algorithm from being used with other address configuration mechanisms, such as DHCPv6 <xref target="RFC3315"/> or manual address configuration.</t>

</section>

<section title="Design Goals">
<t>This document specifies a method for generating Interface Identifiers to be used with IPv6 SLAAC, with the following goals:

<list style="symbols">
<t>The resulting Interface Identifiers remain stable for each prefix used with SLAAC within each subnet for the same network interface. That is, the algorithm generates the same Interface Identifier when configuring an address (for the same interface) belonging to the same prefix within the same subnet.
</t>
<t>The resulting Interface Identifiers must change when addresses are
  configured for different prefixes. That is, if different
  autoconfiguration prefixes are used to configure addresses for the
  same network interface card, the resulting Interface Identifiers
  must be (statistically) different. This means that, given two
  addresses produced by the method specified in this document, it must
  be difficult for an attacker to tell whether the addresses have been
  generated by the same host.</t>

<t>It must be difficult for an outsider to predict the Interface Identifiers that will be generated by the algorithm, even with knowledge of the Interface Identifiers generated for configuring other addresses.
</t>
<t>Depending on the specific implementation approach (see
  <xref target="specification"/> and <xref target="interface-ids"/>),
  the resulting Interface Identifiers may be independent of the
  underlying hardware (e.g., IEEE LAN MAC address). For example, this means that replacing a Network Interface Card (NIC) or adding links dynamically to a Link Aggregation Group (LAG) will not have the (generally undesirable) effect of changing the IPv6 addresses used for that network interface.</t>

<t>The method specified in this document is meant to be an alternative
  to producing IPv6 addresses based on hardware addresses (e.g., IEEE LAN MAC addresses, as specified in <xref target="RFC2464"/>). That is, this document does not formally obsolete or deprecate any of the existing algorithms to generate Interface Identifiers. It is meant to be employed for all of the stable (i.e., non-temporary) IPv6 addresses configured with SLAAC for a given interface, including global, link-local, and unique-local IPv6 addresses.
</t>
</list>
</t>
<t>We note that this method is incrementally deployable, since it does
  not pose any interoperability implications when deployed on networks
  where other nodes do not implement or employ it. Additionally, we
  note that this document does not update or modify IPv6 Stateless
  Address Autoconfiguration (SLAAC) <xref target="RFC4862"/> itself,
  but rather it only specifies an alternative algorithm to generate Interface Identifiers. Therefore, the usual address lifetime properties (as specified in the corresponding Prefix Information Options) apply when IPv6 addresses are generated as a result of employing the algorithm specified in this document with SLAAC <xref target="RFC4862"/>.  Additionally, from the point of view of renumbering, we note that these addresses behave like the traditional IPv6 addresses (that embed a hardware address) resulting from SLAAC <xref target="RFC4862"/>.</t>
</section>


    <section title="Algorithm Specification" anchor="specification">

	<t>IPv6 implementations conforming to this specification MUST
	generate Interface Identifiers using the algorithm specified
	in this section as a replacement for any other algorithms for generating "stable" addresses with SLAAC (such as those specified in <xref target="RFC2464"/>, <xref target="RFC2467"/>, and <xref target="RFC2470"/>). However, implementations conforming to this specification MAY employ the algorithm specified in <xref target="RFC4941"/> to generate temporary addresses in addition to the addresses generated with the algorithm specified in this document. The method specified in this document MUST be employed for generating the Interface Identifiers with SLAAC for all the stable addresses, including IPv6 global, link-local, and unique-local addresses.
</t>

<t>Implementations conforming to this specification SHOULD provide the means for a system administrator to enable or disable the use of this algorithm for generating Interface Identifiers. </t> 

<t>Unless otherwise noted, all of the parameters included in the expression below MUST be included when generating an Interface Identifier.

<list style="numbers">
<t>
Compute a random (but stable) identifier with the expression:
<vspace blankLines="1" />
RID = F(Prefix, Net_Iface, Network_ID, DAD_Counter, secret_key)
<vspace blankLines="1" />
Where:
<list style="hanging">
<t hangText="RID:">
<vspace blankLines="0" />Random (but stable) Identifier</t>
<t hangText="F():">
<vspace blankLines="0" />A pseudorandom function (PRF) that MUST NOT be computable from the outside (without knowledge of the secret key). F() MUST also be difficult to reverse, such that it resists attempts to obtain the secret_key, even when given samples of the output of F() and knowledge
or control of the other input parameters. F() SHOULD produce an output of at least 64 bits. F() could be implemented as a cryptographic hash of the concatenation of each of the function parameters. SHA-1 <xref target="FIPS-SHS"/> and SHA-256 are two possible options for F(). Note: MD5 <xref target="RFC1321"/> is considered unacceptable for F() <xref target="RFC6151"/>.</t>
<t hangText="Prefix:">
<vspace blankLines="0" />The prefix to be used for SLAAC, as learned from an ICMPv6 Router Advertisement message, or the link-local IPv6 unicast prefix <xref target="RFC4291"/>.</t>
<t hangText="Net_Iface:">
<vspace blankLines="0" />An implementation-dependent stable identifier associated with the network interface for which the RID is being generated. An implementation MAY provide a configuration option to select the source of the identifier to be used for the Net_Iface parameter. A discussion of possible sources for this value (along with the corresponding trade-offs) can be found in <xref target="interface-ids"/>.</t>
<t hangText="Network_ID:">
<vspace blankLines="0" />Some network-specific data that identifies
the subnet to which this interface is attached -- for example, the IEEE 802.11 Service Set Identifier (SSID) corresponding to the network to which this interface is associated. Additionally, Simple DNA <xref target="RFC6059"/> describes ideas that could be leveraged to generate a Network_ID parameter. This parameter is OPTIONAL.</t>
<t hangText="DAD_Counter:">
<vspace blankLines="0" />A counter that is employed to resolve Duplicate Address Detection (DAD) conflicts. It MUST be initialized to 0, and incremented by 1 for each new tentative address that is configured as a result of a DAD conflict. Implementations that record DAD_Counter in non-volatile memory for each {Prefix, Net_Iface, Network_ID} tuple MUST initialize DAD_Counter to the recorded value if such an entry exists in non-volatile memory. See <xref target="dad-conflicts"/> for additional details.</t>
<t hangText="secret_key:">
<vspace blankLines="0" />A secret key that is not known by the
 attacker. The secret key SHOULD be of at least 128 bits. It MUST be initialized to a pseudo-random number
 (see <xref target="RFC4086"/> for randomness requirements for
 security) when the operating system is installed or when the IPv6
 protocol stack is "bootstrapped" for the first time.


 An implementation MAY provide the means for the system administrator to display and change the secret key.
</t>
</list>
</t>

<t>The Interface Identifier is finally obtained by taking as many bits from the RID value (computed in the previous step) as necessary, starting from the least significant bit.
<list style="hanging">
<t>We note that <xref target="RFC4291"/> requires that the Interface
  IDs of all unicast addresses (except those that start with the
  binary value 000) be 64 bits long. However, the method discussed in this document could be employed for generating Interface IDs of any arbitrary length, albeit at the expense of reduced entropy (when employing Interface IDs smaller than 64 bits).</t>
</list>
The resulting Interface Identifier SHOULD be compared against the reserved IPv6 Interface Identifiers <xref target="RFC5453"/> <xref target="IANA-RESERVED-IID"/> and against those Interface Identifiers already employed in an address of the same network interface and the same network prefix. In the event that an unacceptable identifier has been generated, this situation SHOULD be handled in the same way as the case of duplicate addresses (see <xref target="dad-conflicts"/>).
</t>
</list>
</t>

<t>This document does not require the use of any specific PRF for the function F() above, since the choice of such PRF is usually a trade-off between a number of properties (processing requirements, ease of implementation, possible intellectual property rights, etc.), and since the best possible choice for F() might be different for different types of devices (e.g., embedded systems vs. regular servers) and might possibly change over time.</t>


<t>Including the SLAAC prefix in the PRF computation causes the Interface Identifier to vary across each prefix (link-local, global, etc.) employed by the host and, consequently, also across networks. This mitigates the correlation of activities of multihomed hosts (since each of the corresponding addresses will typically employ a different prefix), host-tracking (since the network prefix will change as the host moves from one network to another), and any other attacks that benefit from predictable Interface Identifiers (such as IPv6 address-scanning attacks).
</t>

<t>The Net_Iface is a value that identifies the network interface for which an IPv6 address is being generated. The following properties are required for the Net_Iface parameter:
<list style="symbols">
<t>It MUST be constant across system bootstrap sequences and other network events (e.g., bringing another interface up or down).</t>
<t>It MUST be different for each network interface simultaneously in use.</t>
</list>

Since the stability of the addresses generated with this method relies on the stability of all arguments of F(), it is key that the Net_Iface parameter be constant across system bootstrap sequences and other network events. Additionally, the Net_Iface parameter must uniquely identify an interface within the host, such that two interfaces connecting to the same network do not result in duplicate addresses. Different types of operating systems might benefit from different stability properties of the Net_Iface parameter. For example, a client-oriented operating system might want to employ Net_Iface identifiers that are attached to the NIC, such that a removable NIC always gets the same IPv6 address, irrespective of the system communications port to which it is attached. On the other hand, a server-oriented operating system might prefer Net_Iface identifiers that are attached to system slots/ports, such that replacement of a NIC does not result in an IPv6 address change. <xref target="interface-ids"/> discusses possible sources for the Net_Iface along with their pros and cons.
</t>

<t>Including the optional Network_ID parameter when computing the RID value above causes the algorithm to produce a different Interface Identifier when connecting to different networks, even when configuring addresses belonging to the same prefix. This means that a host would employ a different Interface Identifier as it moves from one network to another even for IPv6 link-local addresses or Unique Local Addresses (ULAs) <xref target="RFC4193"/>. In those scenarios where the Network_ID is unknown to the attacker, including this parameter might help mitigate attacks where a victim host connects to the same subnet as the attacker and the attacker tries to learn the Interface Identifier used by the victim host for a remote network (see <xref target="sec-cons"/> for further details).
</t>

<t>The DAD_Counter parameter provides the means to intentionally cause this algorithm to produce different IPv6 addresses (all other parameters being the same). This could be necessary to resolve DAD conflicts, as discussed in detail in <xref target="dad-conflicts"/>.
</t>

   <t>Note that the result of F() in the algorithm above is no more
   secure than the secret key.  If an attacker is aware of the PRF
   that is being used by the victim (which we should expect), and the
   attacker can obtain enough material (i.e., addresses configured by
   the victim), the attacker may simply search the entire secret-key
   space to find matches. To protect against this, key lengths of at least 128 bits
   should be adequate. The secret key is initialized at system
   installation time to a pseudorandom number, thus allowing this
   mechanism to be enabled and used automatically, without user
   intervention. 

Providing a mechanism to display and change the
   secret_key would allow an administrator to cause a new/replacement system (with the same implementation of this specification) to generate the same IPv6 addresses as the system being replaced. We note that since the privacy of the scheme specified in this document relies on the secrecy of the secret_key parameter, implementations should constrain access to the secret_key parameter to the extent practicable (e.g., require superuser privileges to access it). Furthermore, in order to prevent leakages of the secret_key parameter, it should not be used for any purposes other than being a parameter to the scheme specified in this document.</t>

<t>We note that all of the bits in the resulting Interface IDs are
  treated as "opaque" bits <xref target="RFC7136"/>. For
  example, the universal/local bit of Modified EUI-64 format
  identifiers is treated as any other bit of such an identifier. In theory, this might result in IPv6 address collisions and DAD failures that would otherwise not be encountered. However, this is not deemed as a likely issue because of the following considerations:

<list style="symbols">
<t>The interface IDs of all addresses (except those of addresses 
  that start with the binary value 000) are 64 bits long. Since the method specified in this document results in random Interface IDs, the probability of DAD failures is very small.
</t>
<t>Real-world data indicates that MAC address reuse is far more common than assumed <xref target="HD-MOORE"/>. This means that even IPv6 addresses that employ (allegedly) unique identifiers (such as IEEE LAN MAC addresses) might result in DAD failures and, hence, implementations should be prepared to gracefully handle such occurrences. Additionally, some virtualization technologies already employ hardware addresses that are randomly selected, and, hence, cannot be guaranteed to be unique <xref target="IPV6-RECON"/>.</t>
<t>Since some popular and widely deployed operating systems (such as Microsoft Windows) do not embed hardware addresses in the Interface IDs of their stable addresses, reliance on such unique identifiers is reduced in the deployed world (fewer deployed systems rely on them for the avoidance of address collisions).</t>
</list>
</t>

<t>
Finally, we note that since different implementations are likely to use different values for the secret_key parameter, and may also employ different PRFs for F() and different sources for the Net_Iface parameter, the addresses generated by this scheme should not expected to be stable across different operating-system installations. For example, a host that is dual-boot or that is reinstalled may result in different IPv6 addresses for each operating system and/or installation.</t>
</section>


<section title="Resolving DAD Conflicts" anchor="dad-conflicts">
<t>If, as a result of performing DAD <xref target="RFC4862"/>, a host finds that the tentative address generated with the algorithm specified in <xref target="specification"/> is a duplicate address, it SHOULD resolve the address conflict by trying a new tentative address as follows:
<list style="symbols">
<t>DAD_Counter is incremented by 1.</t>
<t>A new Interface Identifier is generated with the algorithm specified in <xref target="specification"/>, using the incremented DAD_Counter value.
</t>
</list>
</t>
<t>Hosts SHOULD introduce a random delay between 0 and IDGEN_DELAY seconds (see <xref target="specified-constants"/>) before trying a new tentative address, to avoid lockstep behavior of multiple hosts.</t>

<t>This procedure may be repeated a number of times until the address conflict is resolved. Hosts SHOULD try at least IDGEN_RETRIES (see <xref target="specified-constants"/>) tentative addresses if DAD fails for successive generated addresses, in the hopes of resolving the address conflict. We also note that hosts MUST limit the number of tentative addresses that are tried (rather than indefinitely try a new tentative address until the conflict is resolved).</t>

<t>In those unlikely scenarios in which duplicate addresses are detected and the order in which the conflicting hosts configure their addresses varies (e.g., because they may be bootstrapped in different orders), the algorithm specified in this section for resolving DAD conflicts could lead to addresses that are not stable within the same subnet. In order to mitigate this potential problem, hosts MAY record the DAD_Counter value employed for a specific {Prefix, Net_Iface, Network_ID} tuple in non-volatile memory, such that the same DAD_Counter value is employed when configuring an address for the same Prefix and subnet at any other point in time. We note that the use of non-volatile memory is OPTIONAL, and hosts that do not implement this feature are still compliant to this protocol specification.
</t>

<t>In the event that a DAD conflict cannot be solved (possibly after trying a number of different addresses), address configuration would fail. In those scenarios, hosts MUST NOT automatically fall back to employing other algorithms for generating Interface Identifiers.</t>

</section>

	<section title="Specified Constants" anchor="specified-constants">
<t>This document specifies the following constant:
<list style="hanging">
<t hangText="IDGEN_RETRIES:">
<vspace blankLines="0" />defaults to 3.</t>
</list>
</t>
<t>
<list style="hanging">
<t hangText="IDGEN_DELAY:">
<vspace blankLines="0" />defaults to 1 second.</t>
</list>
</t>
</section>

    <section title="Security Considerations" anchor="sec-cons">

	<t>This document specifies an algorithm for generating Interface Identifiers to be used with IPv6 Stateless Address Autoconfiguration (SLAAC), as an alternative to e.g., Interface Identifiers that embed hardware addresses (such as those specified in <xref target="RFC2464"/>, <xref target="RFC2467"/>, and <xref target="RFC2470"/>). When compared to such identifiers, the identifiers specified in this document have a number of advantages:

<list style="symbols">
<t>They prevent trivial host-tracking based on the IPv6 address, since when a host moves from one network to another the network prefix used for autoconfiguration and/or the Network ID (e.g., IEEE 802.11 SSID) will typically change; hence, the resulting Interface Identifier will also change (see <xref target="ADDR-GEN-PRIVACY"/>).</t>
<t>They mitigate address-scanning techniques that leverage predictable Interface Identifiers (e.g., known Organizationally Unique Identifiers) <xref target="IPV6-RECON"/>.
</t>
<t>They may result in IPv6 addresses that are independent of the underlying hardware (i.e., the resulting IPv6 addresses do not change if a network interface card is replaced) if an appropriate source for Net_Iface (see <xref target="specification"/>) is employed.</t>
<t>They prevent the information leakage produced by embedding hardware addresses in the Interface Identifier (which could be exploited to launch device-specific attacks).</t>
<t>Since the method specified in this document will result in different Interface Identifiers for each configured address, knowledge or leakage of the Interface Identifier employed for one stable address will not negatively affect the security/privacy of other stable addresses configured for other prefixes (whether at the same time or at some other point in time).</t>
</list>
</t>

<t>We note that while some probing techniques (such as the use of
  ICMPv6 Echo Request and ICMPv6 Echo Response packets) could be
  mitigated by a personal firewall at the target host, for other
  probing vectors, such as listening to ICMPv6 "Destination
  Unreachable, Address Unreachable" (Type 1, Code 3) error messages
  that refer to the target addresses <xref target="IPV6-RECON"/>, there is nothing a host can do (e.g., a personal firewall at the target host would not be able to mitigate this probing technique). Hence, the method specified in this document is still of value for hosts that employ personal firewalls.</t>

<t>In scenarios in which an attacker can connect to the same subnet as a victim host, the attacker might be able to learn the Interface Identifier employed by the victim host for an arbitrary prefix by simply sending a forged Router Advertisement <xref target="RFC4861"/> for that prefix, and subsequently learning the corresponding address configured by the victim host (either listening to the Duplicate Address Detection packets or to any other traffic that employs the newly configured address). We note that a number of factors might limit the ability of an attacker to successfully perform such an attack:
<list style="symbols">
<t>First-Hop security mechanisms such as Router Advertisement Guard (RA-Guard) <xref target="RFC6105"/> <xref target="RFC7113"/> could prevent the forged Router Advertisement from reaching the victim host.</t>
<t>If the victim implementation includes the (optional) Network_ID parameter for computing F() (see <xref target="specification"/>), and the Network_ID employed by the victim for a remote network is unknown to the attacker, the Interface Identifier learned by the attacker would differ from the one used by the victim when connecting to the legitimate network.</t>
</list>

In any case, we note that at the point in which this kind of attack becomes a concern, a host should consider employing SEND <xref target="RFC3971"/> to prevent an attacker from illegitimately claiming authority for a network prefix.
</t>

<t>We note that this algorithm is meant to be an alternative to Interface Identifiers such as those specified in <xref target="RFC2464"/>, but it is not meant as an alternative to temporary Interface Identifiers (such as those specified in <xref target="RFC4941"/>). Clearly, temporary addresses may help to mitigate the correlation of activities of a host within the same network, and they may also reduce the attack exposure window (since temporary addresses are short-lived when compared to the addresses generated with the method specified in this document). We note that the implementation of this specification would still benefit those hosts employing temporary addresses, since it would mitigate host-tracking vectors still present when such addresses are used (see <xref target="ADDR-GEN-PRIVACY"/>) and would also mitigate address-scanning techniques that leverage patterns in IPv6 addresses that embed IEEE LAN MAC addresses. Finally, we note that the method described in this document addresses some of the privacy concerns arising from the use of IPv6 addresses that embed IEEE LAN MAC addresses, without the use of temporary addresses, thus possibly offering an interesting trade-off for those scenarios in which the use of temporary addresses is not feasible.
</t>


    </section>

    <section title="Acknowledgements">
<t>The algorithm specified in this document has been inspired by Steven Bellovin's work (<xref target="RFC1948"/>) in the area of TCP sequence numbers.</t>


<t>The author would like to thank (in alphabetical order) Mikael
  Abrahamsson, Ran Atkinson, Karl Auer, Steven Bellovin, Matthias
  Bethke, Ben Campbell, Brian Carpenter, Tassos Chatzithomaoglou, Tim
  Chown, Alissa Cooper, Dominik Elsbroek, Stephen Farrell, Eric Gray,
  Brian Haberman, Bob Hinden, Christian Huitema, Ray Hunter, Jouni
  Korhonen, Suresh Krishnan, Eliot Lear, Jong-Hyouk Lee, Andrew
  McGregor, Thomas Narten, Simon Perreault, Tom Petch, Michael
  Richardson, Vincent Roca, Mark Smith, Hannes Frederic Sowa, Martin
  Stiemerling, Dave Thaler, Ole Troan, Lloyd Wood, James Woodyatt, and
  He Xuan, for providing valuable comments on earlier versions of this document.</t>

<t>Hannes Frederic Sowa produced a reference implementation of this specification for the Linux kernel.</t>

<t>Finally, the author wishes to thank Nelida Garcia and Guillermo Gont for their love and support.</t>

    </section>


  </middle>




  <back>
  <references title='Normative References'>
	<?rfc include="reference.RFC.2460" ?>
	<?rfc include="reference.RFC.2119" ?>
	<?rfc include="reference.RFC.3315" ?>
	<?rfc include="reference.RFC.3971" ?>
	<?rfc include="reference.RFC.3972" ?>
	<?rfc include="reference.RFC.4086" ?>
	<?rfc include="reference.RFC.4122" ?>
	<?rfc include="reference.RFC.4193" ?>
	<?rfc include="reference.RFC.4291" ?>
	<?rfc include="reference.RFC.4861" ?>
	<?rfc include="reference.RFC.4862" ?>
	<?rfc include="reference.RFC.4941" ?>
	<?rfc include="reference.RFC.5453" ?>
	<?rfc include="reference.RFC.7136" ?>
  </references>

  <references title='Informative References'>
	<?rfc include="reference.RFC.1321" ?>
	<?rfc include="reference.RFC.1948" ?>
	<?rfc include="reference.RFC.2464" ?>
	<?rfc include="reference.RFC.2467" ?>
	<?rfc include="reference.RFC.2470" ?>
	<?rfc include="reference.RFC.3493" ?>
	<?rfc include="reference.RFC.3542" ?>
	<?rfc include="reference.RFC.6059" ?>
	<?rfc include="reference.RFC.6105" ?>
	<?rfc include="reference.RFC.6151" ?>
	<?rfc include="reference.RFC.7113" ?>

<!-- draft-ietf-opsec-ipv6-host-scanning - I-D Exists -->
<reference anchor='IPV6-RECON'>
<front>
<title>Network Reconnaissance in IPv6 Networks</title>

<author initials='F' surname='Gont' fullname='Fernando Gont'>
    <organization />
</author>

<author initials='T' surname='Chown' fullname='Tim Chown'>
    <organization />
</author>

<date month='January' day='23' year='2014' />

<abstract><t>IPv6 offers a much larger address space than that of its IPv4 counterpart.  The standard /64 IPv6 subnets can (in theory) accommodate approximately 1.844 * 10^19 hosts, thus resulting in a much lower host density (#hosts/#addresses) than is typical in IPv4 networks, where a site typically has 65,000 or less unique addresses. As a result, it is widely assumed that it would take a tremendous effort to perform address scanning attacks against IPv6 networks, and therefore brute-force IPv6 address scanning attacks have been considered unfeasible.  This document updates RFC 5157 by providing further analysis on how traditional address scanning techniques apply to IPv6 networks, and exploring some additional techniques that can be employed for IPv6 network reconnaissance.  In doing so, this document formally obsoletes RFC 5157.</t></abstract>

</front>

<seriesInfo name="Work" value="in Progress"/>
</reference>


<!-- draft-ietf-6man-ipv6-address-generation-privacy - I-D Exists -->
<reference anchor='ADDR-GEN-PRIVACY'>
<front>
<title>Privacy Considerations for IPv6 Address Generation Mechanisms</title>

<author initials='A' surname='Cooper' fullname='Alissa Cooper'>
    <organization />
</author>

<author initials='F' surname='Gont' fullname='Fernando Gont'>
    <organization />
</author>

<author initials='D' surname='Thaler' fullname='Dave Thaler'>
    <organization />
</author>

<date month='February' day='14' year='2014' />

<abstract><t>This document discusses privacy and security considerations for several IPv6 address generation mechanisms, both standardized and non-standardized.  It evaluates how different mechanisms mitigate different threats and the trade-offs that implementors, developers, and users face in choosing different addresses or address generation mechanisms.</t></abstract>

</front>

<seriesInfo name="Work" value="in Progress"/>
</reference>


    <reference anchor="HD-MOORE" target="https://speakerdeck.com/hdm/derbycon-2012-the-wild-west">
  <front>
  <title abbrev="The Wild West">The Wild West</title>
  <author initials="HD" surname="Moore" fullname="HD Moore">
  </author>
  <date year="2012" month="September" day="25-29"/>
  </front>
		<seriesInfo name="Louisville, Kentucky," value="U.S.A"/>
		<seriesInfo name="DerbyCon" value="2012"/>
  </reference>

	<reference anchor="IANA-RESERVED-IID" target="http://www.iana.org/assignments/ipv6-interface-ids">
		<front>
			<title>Reserved IPv6 Interface Identifiers</title>
			<author>
				<organization>IANA</organization>
			</author>
			<date/>
		</front>
	</reference>

  	<reference anchor="GONT-DEEPSEC2011" target="http://www.si6networks.com/presentations/deepsec2011/fgont-deepsec2011-ipv6-security.pdf">
		<front>
			<title>Results of a Security Assessment of the Internet Protocol version 6 (IPv6)</title>
<author
        fullname="Fernando Gont"
        initials="F"
        surname="Gont">

        <organization abbrev="SI6 Networks">SI6 Networks</organization>
    </author>  
  <date year="2011" month="November"/>
		</front>
		<seriesInfo name="DEEPSEC 2011 Conference," value="Vienna, Austria"/>
	</reference>

 	<reference anchor="BROERSMA" target="http://www.ipv6.org.au/10ipv6summit/talks/Ron_Broersma.pdf">
		<front>
			<title>IPv6 Everywhere: Living with a Fully IPv6-enabled environment</title>
<author
        fullname="Ron Broersma"
        initials="R."
        surname="Broersma">

        <organization abbrev="DREN">Defense Research and Engineering Network</organization>
    </author>  
  <date year="2010" month="October"/>
		</front>
		<seriesInfo name="" value="Australian IPv6 Summit 2010, Melbourne, VIC Australia"/>
	</reference>

 	<reference anchor="IAB-PRIVACY" target="http://www.iab.org/wp-content/IAB-uploads/2011/07/IPv6-addresses-privacy-review.txt">
		<front>
			<title>Privacy and IPv6 Addresses</title>
    <author>
		<organization>IAB</organization>
    </author>  
  <date year="2011" month="July"/>
		</front>
	</reference>

	
    <reference anchor="CPNI-IPV6">
  <front>
  <title abbrev="Security Assessment of the Internet Protocol version 6 (IPv6)">Security Assessment of the Internet Protocol version 6 (IPv6)</title>
  <author initials="F.G." surname="Gont" fullname="F. Gont">
				<organization>Centre for the Protection of National Infrastructure</organization>
  </author>
  <date month="" year="(available on request)"/>
  </front>
		<seriesInfo name="" value="UK Centre for the Protection of National Infrastructure"/>
  </reference>

	<reference anchor="FIPS-SHS" target="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">
		<front>
			<title>Secure Hash Standard (SHS)</title>

    <author>
		<organization>NIST</organization>
    </author>  

			<date month="March" year="2012"/>
		</front>
		<seriesInfo name="FIPS Publication" value="180-4"/>
	</reference>

</references>

<section title="Possible Sources for the Net_Iface Parameter" anchor="interface-ids">
<t>The following subsections describe a number of possible sources for the Net_Iface parameter employed by the F() function in <xref target="specification"/>. The choice of a specific source for this value represents a number of trade-offs, which may vary from one implementation to another.
</t>
<section title="Interface Index">
<t>The Interface Index <xref target="RFC3493"/> <xref target="RFC3542"/> of an interface uniquely identifies that interface within the node. However, these identifiers might or might not have the stability properties required for the Net_Iface value employed by this method. For example, the Interface Index might change upon removal or installation of a network interface (typically one with a smaller value for the Interface Index, when such a naming scheme is used) or when network interfaces happen to be initialized in a different order. We note that some implementations are known to provide configuration knobs to set the Interface Index for a given interface. Such configuration knobs could be employed to prevent the Interface Index from changing (e.g., as a result of the removal of a network interface).
</t>
</section>

<section title="Interface Name">
<t>The Interface Name (e.g., "eth0", "em0", etc.) tends to be more stable than the underlying Interface Index, since such stability is required or desired when interface names are employed in network configuration (firewall rules, etc.). The stability properties of Interface Names depend on implementation details, such as what is the namespace used for Interface Names. For example, "generic" interface names such as "eth0" or "wlan0" will generally be invariant with respect to network interface card replacements. On the other hand, vendor-dependent interface names such as "rtk0" or the like will generally change when a network interface card is replaced with one from a different vendor.
</t>
<t>We note that Interface Names might still change when network interfaces are added or removed once the system has been bootstrapped (for example, consider USB-based network interface cards that might be added or removed once the system has been bootstrapped).
</t>
</section>

<section title="Link-Layer Addresses">
<t>Link-layer addresses typically provide for unique identifiers for network interfaces; although, for obvious reasons, they generally change when a network interface card is replaced. In scenarios in which neither Interface Indexes nor Interface Names have the stability properties specified in <xref target="specification"/> for Net_Iface, an implementation might want to employ the link-layer address of the interface for the Net_Iface parameter, albeit at the expense of making the corresponding IPv6 addresses dependent on the underlying network interface card (i.e., the corresponding IPv6 addresses would typically change upon replacement of the underlying network interface card).
</t>

</section>


<section title="Logical Network Service Identity">
<t>Host operating systems with a conception of logical network service identity, distinct from network interface identity or index, may keep a Universally Unique Identifier (UUID) <xref target="RFC4122"/> or similar identifier with the stability properties appropriate for use as the Net_Iface parameter.
</t>

</section>
</section>

  </back>
</rfc>
