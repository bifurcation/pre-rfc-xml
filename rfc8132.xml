<?xml version="1.0" encoding="US-ASCII"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="no"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc number="8132"
     ipr="trust200902" 
     submissionType="IETF"
     consensus="yes"
     category="std">

  <front>

    <title abbrev="CoAP FETCH PATCH">PATCH and FETCH Methods for the Constrained Application Protocol (CoAP)</title>

    <author initials="P." surname="van der Stok" fullname="Peter van der Stok">
      <organization>Consultant</organization>
      <address>
        <email>consultancy@vanderstok.org</email>
      </address>
    </author>
    <author initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </author>
    <author initials="A." surname="Sehgal" fullname="Anuj Sehgal">
      <organization>NAVOMI, Inc.</organization>
      <address>
        <email>anuj.sehgal@navomi.com</email>
      </address>
    </author>

    <date year="2017" month="March"/>

    <area>Applications</area>
    <workgroup>core</workgroup>
    <keyword>CoAP</keyword>

    <abstract>


<t>The methods defined in RFC 7252 for the Constrained Application Protocol (CoAP)
only allow access to a complete resource, not to parts of a resource. In case of resources
with larger or complex data, or in situations where resource continuity is
required, replacing or requesting the whole resource is undesirable. Several
applications using CoAP need to access parts of the resources.</t>

<t>This specification defines the new CoAP methods, FETCH, PATCH, and
iPATCH, which are used to access and update parts of a resource.</t>



    </abstract>


  </front>

  <middle>


<section anchor="intro" title="Introduction">

<t>Similar to HTTP, the GET method defined in
<xref target="RFC7252"/> for the Constrained Application Protocol (CoAP) only allows
the specification of a URI and request
parameters in CoAP options, not the transfer of a request payload
detailing the request.  This leads some applications to use POST
where a cacheable, idempotent, safe request is actually desired.</t>

<t>Again, similar to the original specification of HTTP,
the PUT method defined in <xref target="RFC7252"/> only allows a complete
resource to be replaced. This also leads
applications to use POST where a cacheable, possibly idempotent
request is actually desired.</t>

<t>The present specification adds new CoAP methods: FETCH, to perform the
equivalent of a GET with a request body; and the twin methods, PATCH and iPATCH, to
modify parts of a CoAP resource.</t>

<section anchor="intro-fetch" title="FETCH">

<t>The CoAP GET method <xref target="RFC7252"/> is used to obtain the representation of
a resource, where the resource is specified by a URI and additional
request parameters can also shape the representation.  This
has been modeled after the HTTP GET operation and the REST model in
general.</t>

<t>In HTTP, a resource is often used to search for information, and
existing systems varyingly use the HTTP GET and POST methods to
perform a search.  Often, a POST method is used solely so
that a larger set of parameters to the search can be supplied in the
request body than can comfortably be transferred in the URI with a GET request.
<xref target="HTTP-SEARCH"/> proposes a SEARCH method that is similar to
GET in most properties but enables sending a request body, as is done with
POST.
The FETCH method defined in the present specification is inspired by
<xref target="HTTP-SEARCH"/>, which
updates the definition and semantics of the HTTP SEARCH request
method previously defined by <xref target="RFC5323"/>.  However, there is no intention
to limit FETCH to search-type operations, and the resulting
properties may not be the same as those of HTTP SEARCH.</t>

<t>A major problem with GET is that the information that controls the
request needs to be bundled up in some unspecified way into the URI.
Using the request body for this information has a number of
advantages:</t>

<t><list style="symbols">
  <t>The client can specify a media type (and a content coding) that
 enables the server to unambiguously interpret the request
parameters in the context of that media type.  Also, the request
body is not limited by the character set limitations of URIs, which
enables a more natural (and more efficient) representation of
certain domain-specific parameters.</t>
  <t>The request parameters are not limited by the maximum size of the
URI.  In HTTP, that is a problem, as the practical limit for this
size varies.  In CoAP, another problem is that the block-wise
transfer is not available for transferring large URI options in
multiple rounds.</t>
</list></t>

<t>As an alternative to using GET, many implementations make use of the
POST method to perform extended requests (even if they are
semantically idempotent, safe, and even cacheable) to be able to pass
along the input parameters within the request payload as opposed to
using the request URI.</t>

<t>The FETCH method provides a solution that spans the gap between the
use of GET and POST.  As with POST, the input to the FETCH operation
is passed along within the payload of the request rather than as part
of the request URI.  Unlike POST, however, the semantics of the FETCH
method are more specifically defined.</t>

</section>
<section anchor="intro-patch" title="PATCH and iPATCH">

<t>PATCH is also specified for HTTP in <xref target="RFC5789"/>. Most of the
motivation for PATCH described in <xref target="RFC5789"/> also applies
here. iPATCH is the idempotent version of PATCH.</t> 

<t>The PUT method exists to overwrite a resource with completely
new contents and cannot be used to perform partial changes.
When using PUT for partial changes, proxies and caches, and
even clients and servers, may get confused as to the result of
the operation.
PATCH was not adopted in an early design stage of CoAP;
however, it has become necessary with the arrival of
applications that require partial updates to resources
(e.g., <xref target="COAP-MGMNT"/>). Using PATCH
avoids transferring all data associated with a resource in
case of modifications, thereby not burdening the constrained
communication medium.</t>

<t>This document relies on knowledge of the PATCH specification
for HTTP <xref target="RFC5789"/>. This document provides
extracts from <xref target="RFC5789"/> to make independent
reading possible.</t>

</section>
<section anchor="requirements-language" title="Requirements Language">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
"SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY",
and "OPTIONAL" in this document are to be interpreted as
described in <xref target="RFC2119"/>.</t>

</section>

<section anchor="terminology-and-acronyms" title="Terminology and Acronyms">

<t>This document uses terminology defined in <xref target="RFC5789"/> and <xref target="RFC7252"/>.</t>

<t>Specifically, it uses the terms "safe" and "idempotent" as defined in Section 5.1 of <xref target="RFC7252"/>.
(Further discussion of safe and idempotent methods can now be found in Sections
4.2.1 and 4.2.2 of <xref target="RFC7231"/>, respectively; the implications of idempotence of
methods on server implementations are also discussed in Section 4.5 of
<xref target="RFC7252"/>.)</t>

</section>
</section>
<section anchor="fetch" title="FETCH Method">

<t>The CoAP FETCH method is used to obtain a representation of a
resource, specified by a number of request parameters. Unlike the CoAP GET
method, which requests that a server return a representation of the
resource identified by the effective request URI (as defined by <xref target="RFC7252"/>), the FETCH method is used by a client to ask the server to
produce a representation as described by the request parameters (including
the request options and the payload) based on the resource specified
by the effective request URI.  The payload returned in response to a
FETCH cannot be assumed to be a complete representation of the
resource identified by the effective request URI, i.e., it cannot be
used by a cache as a payload to be returned by a GET request.</t>

<t>Together with the request options, the body of the request (which may
be constructed from multiple payloads using the block protocol
<xref target="RFC7959"/>) defines the request parameters.
With the
FETCH method, implementations may submit a request body of any media type that is
defined with the semantics of selecting information from
a resource in such a FETCH request; it is outside the scope of this document how
information about media types admissible for the specific resource is obtained by the client
(although we can hint that form relations <xref target="CORE-APP"/>
might be a preferred way).
It is RECOMMENDED that any discovery method that allows a client to
find out that the server supports FETCH also
provides information regarding what FETCH payload media types are applicable.</t>

<t>FETCH requests are both safe and idempotent with regards to the
resource identified by the request URI.  That is, the performance of
a FETCH is not intended to alter the state of the targeted resource.
(However, while processing a FETCH request, a server can be expected
to allocate computing and memory resources or even create additional
server resources through which the response to the search can be
retrieved.)</t>

<t>A successful response to a FETCH request is expected to provide some
indication as to the final disposition of the requested operation.
If a successful response includes a body payload, the payload is expected to
describe the results of the FETCH operation.</t>

<t>Depending on the response code as defined by <xref target="RFC7252"/>, the response
to a FETCH request is cacheable; the request body is part of the
cache key.  Specifically, 2.05 (Content) response codes (the
responses for which are cacheable) are a typical way to respond to a
FETCH request.  (Note that this aspect differs markedly from
<xref target="HTTP-SEARCH"/> and also that caches that cannot use
the request payload as part of the cache key will not be able to
cache responses to FETCH requests at all.)  The Max-Age option in the
response has equivalent semantics to its use in a GET.</t>

<t>The semantics of the FETCH method change to a "conditional FETCH" if
the request message includes an If-Match or If-None-Match option
<xref target="RFC7252"/>.  A conditional FETCH requests that the query be
performed only under the circumstances described by the conditional
option(s).  It is important to note, however, that such conditions
are evaluated against the state of the target resource itself as
opposed to the results of the FETCH operation.</t>

<section anchor="fetch-response" title="Response Codes">

<t>FETCH for CoAP adopts the response codes as specified in
Sections 5.9 and 12.1.2 of <xref target="RFC7252"/> as well as the additional
response codes mentioned in <xref target="fetch-errors"/>.</t>

</section>
<section anchor="fetch-errors" title="Error Handling">

<t>A FETCH request may fail under certain known conditions.
Beyond the conditions already defined in <xref target="RFC7252"/> for GET, noteworthy ones are:</t>

<t><list style="hanging">
  <t hangText='Malformed FETCH payload:'>
  If a server
determines that the payload provided with a FETCH request is
not properly formatted, it can return a 4.00 (Bad Request)
CoAP error. The definition of a malformed payload depends
upon the CoAP Content-Format specified with the request.</t>
  <t hangText='Unsupported FETCH payload:'>
  In case a client
sends a payload that is inappropriate for the resource
identified by the Request-URI, the server can return a 4.15
(Unsupported Content-Format) CoAP error. The server can
determine if the payload is supported by checking the CoAP
Content-Format specified with the request.</t>
  <t hangText='Unprocessable request:'>
  This situation occurs
when the payload of a FETCH request is determined to be valid
(i.e., well-formed and supported) but the server is
unable to or is incapable of processing the request. The server
can return a 4.22 (Unprocessable Entity) CoAP error. In
situations when the server has
insufficient computing resources to
complete the request successfully, it can return a 4.13 (Request Entity
Too Large) CoAP error (see also below).

If there are more specific errors that provide additional
insight into the problem, then those should be used.</t>
  <t hangText='Request too large:'>
  If the payload of the FETCH
request is larger than a CoAP server can process, then it
can return the 4.13 (Request Entity Too Large) CoAP
error.</t>
</list></t>

<t>It is possible that other error situations not mentioned
here are encountered by a CoAP server while processing the
FETCH request. In these situations, other appropriate CoAP response codes can
also be returned.
</t>

</section>
<section anchor="fetch-option" title="Option Numbers">

<t>FETCH for CoAP adopts the option numbers as specified in
Sections 5.10 and 12.2 of <xref target="RFC7252"/>.</t>

<t>Generally, options defined for GET act in an analogous way for FETCH.
Two specific cases are called out in the rest of this section.</t>

<section anchor="fetch-format" title="The Content-Format Option">

<t>A FETCH request MUST include a Content-Format option (see Section
5.10.3 of <xref target="RFC7252"/>) to specify the
media type and content coding of the request body.  
(Typically, the media type will have
been specifically designed to
specify details for a selection or a search on a resource.)</t>

</section>
<section anchor="fetch-etag" title="The ETag Option">

<t>The ETag option on a FETCH result has the same semantics as defined in
Section 5.10.6 of <xref target="RFC7252"/>.  In particular, its use as a response
option describes the "tagged representation", which for FETCH is the
same as the "selected representation".  The FETCH payload is input to
that selection process and therefore needs to be part of the cache
key.  Similarly, the use of ETag as a request option can elicit a 2.03 (Valid)
response if the representation associated with the ETag would still be
selected by the FETCH request (including its payload).</t>

</section>
</section>
<section anchor="fetch-observe" title="Working with Observe">

<t>The Observe option <xref target="RFC7641"/> can be used with a FETCH request as it
can be used with a GET request.</t>

</section>
<section anchor="fetch-block" title="Working with Block">

<t>
The Block1 option <xref target="RFC7959"/> can be used with a FETCH
request as it would be used with a POST request; the Block2 option
can then be used as it would with GET or POST.</t>

</section>
<section anchor="fetch-discuss" title="Building FETCH Requests">

<t>One property of FETCH that may be non-obvious is that a FETCH request
cannot be generated from a link alone; the client also needs a way to 
generate the request payload.  Again, form relations
<xref target="CORE-APP"/> may be able to fill parts of this gap.</t>

</section>
<section anchor="fetch-example" title="A Simple Example for FETCH">

<t>The FETCH method needs a media type for its payload (as expressed by
the Content-Format request option) that specifies the search query in
similar detail as is shown for the PATCH payload in the PATCH
example in <xref target="example"/>. (<xref target="HTTP-SEARCH"/> invents a
<spanx style="verb">text/query</spanx> format based on some hypothetical SQL dialect for its
examples.)</t>

<t>The example below illustrates retrieval of a subset of a JSON <xref target="RFC7159"/> object
(the same object as used in <xref target="example"/>).  Using a hypothetical media type
<spanx style="verb">application/example-map-keys+json</spanx> (with a Content-Format ID of
NNN, which is not defined as this is just an example), the client specifies
the items in
the object that it wants: it supplies a JSON array that gives the map keys
for these items.  A resource located at &lt;coap://www.example.com/object&gt;
can be represented by a JSON document that we will consider as the
target of the FETCH. The client wants to learn the contents of the
single map key <spanx style="verb">foo</spanx> within this target:</t>

<figure title="FETCH Example: JSON Document Returned by GET"><artwork><![CDATA[
{
  "x-coord": 256,
  "y-coord": 45,
  "foo": ["bar","baz"]
}
]]></artwork></figure>

<t>The example FETCH request specifies a single top-level member desired
by giving its map key as the sole element of the <spanx style="verb">example-map-keys</spanx>
payload:</t>

<figure title="FETCH Example: Request"><artwork><![CDATA[
FETCH CoAP://www.example.com/object
Content-Format: NNN (application/example-map-keys+json)
Accept: application/json
[
  "foo"
]
]]></artwork></figure>

<t>The server returns a subset document with just the selected member:</t>

<figure title="FETCH Example: Response with Subset JSON Document"><artwork><![CDATA[
2.05 Content
Content-Format: 50 (application/json)
{
  "foo": ["bar","baz"]
}
]]></artwork></figure>

<t>By the logic of this example, the requester could have entered more
than one map key into the request payload array and would have
received a more complete subset of the top-level JSON object that is
representing the resource.</t>

</section>
</section>
<section anchor="patch" title="PATCH and iPATCH Methods">

<t>The PATCH and iPATCH methods request that a set of changes described in
the request payload be applied to the target resource of the
request.  The set of changes is represented in a format
identified by a media type.  If the Request-URI does not point
to an existing resource, the server MAY create a new resource
with that URI, depending on the PATCH document type (whether
it can logically modify a null resource) and permissions, as well as other
conditions such as the degree of control the server gives clients in
creating new entries in its URI space (see also <xref target="errors"/>).
Creation of a new resource would result in a 2.01 (Created)
response code dependent on the PATCH document type.</t>

<t>Restrictions to a PATCH or iPATCH request can be made by including the If-Match
or If-None-Match options in the request (see Sections 5.10.8.1
and 5.10.8.2 of <xref target="RFC7252"/>).  If the resource
could not be created or modified, then an appropriate error
response code SHOULD be sent.</t>

<t>The difference between the PUT and PATCH requests is documented in <xref target="RFC5789"/>.
When a request is intended to effect a partial update of a given resource, clients
cannot use PUT while supplying just the update, but they might be able to use PATCH or iPATCH.</t>

<t>The PATCH method is "not safe" and "not idempotent", as is the HTTP PATCH
method specified in <xref target="RFC5789"/>.</t>

<t>The iPATCH method is not safe but idempotent, as with the CoAP PUT method
specified in Section 5.8.3 of <xref target="RFC7252"/>.</t>

<t>A client can mark a request as idempotent by using the iPATCH method
instead of the PATCH method.  This is the only difference between the
two.  The indication of idempotence may enable the server to keep less
state about the interaction; some constrained servers may only
implement the iPATCH variant for this reason.</t>

<t>PATCH and iPATCH are both atomic.
The server MUST apply the entire set of changes atomically and
never provide a partially modified representation to a
concurrently executed GET request. Given the constrained
nature of the servers, most servers will only execute CoAP
requests consecutively, thus preventing a concurrent partial
overlapping of request modifications. In other words,
modifications MUST NOT be applied to the server state when an
error occurs or when only a partial execution is possible on the resources present
in the server.</t>

<t>The atomicity applies to a single server. When a PATCH or iPATCH request is
multicast to a set of servers, each server can either execute all required
modifications or not. It is not required that all servers execute all modifications
or none. An Atomic Commit protocol that provides multiple server atomicity
is out of scope.</t>

<t>
A PATCH or iPATCH response can invalidate a cache in a similar manner to the
PUT response. For the successful (2.xx) response codes, PATCH or iPATCH have the following
caching behavior:
</t>

<t><list style="symbols">
  <t>A 2.01 (Created) response invalidates any cache entry for
the resource indicated by the Location-* options; the
payload is a representation of the action result.</t>
  <t>A 2.04 (Changed) response invalidates any cache entry
for the target resource; the payload is a representation of
the action result.</t>
</list></t>

<t>There is no guarantee that a resource can be modified with
PATCH or iPATCH.
Servers MUST ensure that a received PATCH
body is appropriate for the type of resource identified by
the target resource of the request.</t>

<t>It is RECOMMENDED that any discovery method that allows a client to
find out that the server supports one of PATCH and iPATCH also
provide information regarding what PATCH payload media types are applicable and
which of the two methods are implemented by the server for each of
these media types.</t>

<t>Servers that do not rely on the idempotence of iPATCH can easily
support both PATCH and iPATCH, and it is RECOMMENDED they do so.
This is inexpensive to do, as, for iPATCH, there is no requirement on
the server to check that the client's intention that the request be
idempotent is fulfilled (although there is diagnostic value in that
check, so a less-constrained implementation may want to perform it).</t>

<section anchor="example" title="Simple Examples for PATCH and iPATCH">

<t>The example is taken over from <xref target="RFC6902"/>,
which specifies a JSON notation for PATCH operations. A
resource located at &lt;coap://www.example.com/object&gt; contains a target
JSON document.</t>

<figure><artwork align="left"><![CDATA[
JSON document original state:
    {
      "x-coord": 256,
      "y-coord": 45,
      "foo": ["bar","baz"]
    }

REQ: iPATCH CoAP://www.example.com/object
Content-Format: 51 (application/json-patch+json)
    [
      { "op":"replace", "path":"x-coord", "value":45}
    ]

RET: CoAP 2.04 Changed

JSON document final state:
    {
      "x-coord": 45,
      "y-coord": 45,
      "foo": ["bar","baz"]
    }
]]></artwork></figure>

<t>This example illustrates use of an idempotent modification to the
x-coord member of the existing resource "object".
The 2.04 (Changed) response code conforms with the CoAP
PUT method.</t>

<t>The same example using the Content-Format application/merge-patch+json from
<xref target="RFC7396"/> looks like the following:</t>

<figure><artwork align="left"><![CDATA[
JSON document original state:
    {
      "x-coord": 256,
      "y-coord": 45,
      "foo": ["bar","baz"]
    }

REQ: iPATCH CoAP://www.example.com/object
Content-Format: 52 (application/merge-patch+json)
     { "x-coord":45}

RET: CoAP 2.04 Changed

JSON document final state:
    {
      "x-coord": 45,
      "y-coord": 45,
      "foo": ["bar","baz"]
    }
]]></artwork></figure>

<t>The examples show the use of the iPATCH method, but the use of the PATCH
method would have led to the same result. Below, a non-idempotent modification
is shown. Because the action is non-idempotent, iPATCH returns an error,
while PATCH executes the action.</t>

<figure><artwork align="left"><![CDATA[
JSON document original state:
    {
      "x-coord": 256,
      "y-coord": 45,
      "foo": ["bar","baz"]
    }

REQ: iPATCH CoAP://www.example.com/object
Content-Format: 51 (application/json-patch+json)
    [
      { "op":"add","path":"foo/1","value":"bar"}
    ]
RET: CoAP 4.00 Bad Request
Diagnostic payload: Patch format not idempotent

JSON document final state is unchanged

REQ: PATCH CoAP://www.example.com/object
Content-Format: 51 (application/json-patch+json)
    [
      { "op":"add","path":"foo/1","value":"bar"}
    ]
RET: CoAP 2.04 Changed

JSON document final state:
    {
      "x-coord": 45,
      "y-coord": 45,
      "foo": ["bar","bar","baz"]
    }
]]></artwork></figure>

</section>
<section anchor="response" title="Response Codes">

<t>PATCH and iPATCH for CoAP adopt the response codes as specified in
Sections 5.9 and 12.1.2 of <xref target="RFC7252"/> and add 4.09 (Conflict) and 4.22
(Unprocessable Entity) with the semantics specified in <xref target="errors"/> of
the present specification.</t>

</section>
<section anchor="option" title="Option Numbers">

<t>PATCH and iPATCH for CoAP adopt the option numbers as specified in
Sections 5.10 and 12.2 of <xref target="RFC7252"/>.</t>

</section>
<section anchor="errors" title="Error Handling">

<t>A PATCH or iPATCH request may fail under certain known conditions. These
situations should be dealt with as expressed below.</t>

<t><list style="hanging">
  <t hangText='Malformed PATCH or iPATCH payload:'>
  If a server
determines that the payload provided with a PATCH or iPATCH request is
not properly formatted, it can return a 4.00 (Bad Request)
CoAP error. The definition of a malformed payload depends
upon the CoAP Content-Format specified with the request.</t>
  <t hangText='Unsupported PATCH or iPATCH payload:'>
  In case a client
sends a payload that is inappropriate for the resource
identified by the Request-URI, the server can return a 4.15
(Unsupported Content-Format) CoAP error. The server can
determine if the payload is supported by checking the CoAP
Content-Format specified with the request.</t>
  <t hangText='Unprocessable request:'>
  This situation occurs
when the payload of a PATCH request is determined to be valid
(i.e., well-formed and supported) but the server is
unable to or is incapable of processing the request. The server
can return a 4.22 (Unprocessable Entity) CoAP error. More
specific scenarios might include situations such as:

      <list style="symbols">
        <t>the server has insufficient computing resources to
complete the request successfully -- 4.13 (Request Entity
Too Large) CoAP response code (see below); or</t>
        <t>the resource specified in the request becomes invalid
by applying the payload -- 4.09 (Conflict) CoAP
response code (see "Conflicting state" below)).</t>
      </list>

In case there are more specific errors that provide additional
insight into the problem, then those should be used.</t>
  <t hangText='Resource not found:'>
  The 4.04 (Not Found) error
should be returned if the payload of a PATCH request
cannot be applied to a non-existent resource.</t>
  <t hangText='Failed precondition:'>
  In case the client uses
the conditional If-Match or If-None-Match option to define a
precondition for the PATCH request, and that precondition
fails, then the server can return the 4.12 (Precondition
Failed) CoAP error.</t>
  <t hangText='Request too large:'>
  If the payload of the PATCH
request is larger than a CoAP server can process, then it
can return the 4.13 (Request Entity Too Large) CoAP
error.</t>
  <t hangText='Conflicting state:'>
  If the modification specified by a PATCH or iPATCH request causes
the resource to enter an inconsistent state that the server cannot resolve,
the server can return
the 4.09 (Conflict) CoAP response.   The server
SHOULD generate a payload that includes enough information for a user
to recognize the source of the conflict.
The server MAY return the actual resource state to provide the client with
the means to create a new consistent resource state. Such a situation might
be
encountered when a structural modification is applied to a
configuration data store but the structures being modified do not
exist.</t>
  <t hangText='Concurrent modification:'>
  Resource-constrained
devices might need to process requests in the order they are
received. In case requests are received concurrently to
modify the same resource but they cannot be queued, the
server can return a 5.03 (Service Unavailable) CoAP response code.</t>
  <t hangText='Conflict handling failure:'>
  If the modification implies the reservation of resources or the wait time for
conditions to become true leads to a too-long request execution time, the server can return a 5.03
(Service Unavailable) response code.</t>
</list></t>

<t>It is possible that other error situations not mentioned
here are encountered by a CoAP server while processing the
PATCH request. In these situations, other appropriate CoAP
status codes can also be returned.</t>

</section>
</section>
<section anchor="the-new-set-of-coap-methods" title="The New Set of CoAP Methods">

<t>Adding three new methods to CoAP's existing four may seem like a major
change.  However, FETCH and the two PATCH variants fit well into
the REST paradigm and have been anticipated on the HTTP side.

Adding both a non-idempotent and an idempotent PATCH variant
allows interoperability with HTTP's PATCH method to be kept and
allows the use/indication of an idempotent PATCH when that is possible,
which saves significant effort on the server side.</t>

<t>Interestingly, the three new methods fit into the old table of methods
with a surprising similarity in the idempotence and safety attributes:</t>

<texttable>
      <ttcol align='left'>Code</ttcol>
      <ttcol align='left'>Name</ttcol>
      <ttcol align='left'>Code</ttcol>
      <ttcol align='left'>Name</ttcol>
      <ttcol align='left'>safe</ttcol>
      <ttcol align='left'>idempotent</ttcol>
      <c>0.01</c>
      <c>GET</c>
      <c>0.05</c>
      <c>FETCH</c>
      <c>yes</c>
      <c>yes</c>
      <c>0.02</c>
      <c>POST</c>
      <c>0.06</c>
      <c>PATCH</c>
      <c>no</c>
      <c>no</c>
      <c>0.03</c>
      <c>PUT</c>
      <c>0.07</c>
      <c>iPATCH</c>
      <c>no</c>
      <c>yes</c>
      <c>0.04</c>
      <c>DELETE</c>
      <c>&#160;</c>
      <c>&#160;</c>
      <c>no</c>
      <c>yes</c>
</texttable>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>This section analyzes the possible threats to the CoAP FETCH and PATCH or iPATCH
methods.  It is meant to inform protocol and application
developers about the security limitations of CoAP FETCH and PATCH or iPATCH as described in this document.</t>

<t>The FETCH method is subject to the same general security
considerations as all CoAP methods as described in Section 11 of <xref target="RFC7252"/>.
Specifically, the security considerations for FETCH are closest to
those of GET, except that the FETCH request carries a payload that may
need additional protection.
The payload of a FETCH request may reveal more detailed information
about the specific portions of a resource of interest to the
requester than a GET request for the entire resource would; this may
mean that confidentiality protection of the request by Datagram Transport
Layer Security (DTLS) or other means is needed for FETCH where it wouldn't be needed for GET.</t>

<t>The PATCH and iPATCH methods are subject to the same general security
considerations as all CoAP methods as described in Section 11 of <xref target="RFC7252"/>.
The specific security considerations for PATCH or iPATCH are nearly
identical to the security considerations for PUT <xref target="RFC7252"/>; the
security considerations of Section 5 of <xref target="RFC5789"/> also apply to
PATCH and iPATCH.
Specifically, there is likely to be a need for authorizing requests
(possibly through access control and/or
authentication) and for ensuring that data is not corrupted through
transport errors or through accidental overwrites.
The mechanisms used for PUT can be used for PATCH or iPATCH as well.</t>

<t>The new methods defined in the present specification are secured
following the CoAP recommendations for the existing methods as
specified in Section 9 of <xref target="RFC7252"/>.  When additional security
techniques are standardized for CoAP (e.g., Object Security), these techniques
are then also available for securing the new methods.</t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>IANA has added the following entries to the subregistry "CoAP Method
Codes":</t>

<texttable>
      <ttcol align='left'>Code</ttcol>
      <ttcol align='left'>Name</ttcol>
      <ttcol align='left'>Reference</ttcol>
      <c>0.05</c>
      <c>FETCH</c>
      <c>RFC 8132</c>
      <c>0.06</c>
      <c>PATCH</c>
      <c>RFC 8132</c>
      <c>0.07</c>
      <c>iPATCH</c>
      <c>RFC 8132</c>
</texttable>

<t>The FETCH method is idempotent and safe, and it returns the same
response codes that GET can return, plus 4.13 (Request Entity Too
Large), 4.15 (Unsupported Content-Format), and 4.22 (Unprocessable
Entity) with the semantics specified in <xref target="fetch-errors"/>.</t>

<t>The PATCH method is neither idempotent nor safe.  It returns the same
response codes that POST can return, plus 4.09 (Conflict) and 4.22
(Unprocessable Entity) with the semantics specified in <xref target="errors"/>.</t>

<t>The iPATCH method is identical to the PATCH method, except that it is
idempotent.</t>

<t>IANA has added the following code to the subregistry "CoAP
Response Codes":</t>

<texttable>
      <ttcol align='left'>Code</ttcol>
      <ttcol align='left'>Name</ttcol>
      <ttcol align='left'>Reference</ttcol>
      <c>4.09</c>
      <c>Conflict</c>
      <c>RFC 8132</c>
      <c>4.22</c>
      <c>Unprocessable Entity</c>
      <c>RFC 8132</c>
</texttable>

<t>IANA has added entries to the subregistry "CoAP
Content-Formats":</t>

<texttable>
      <ttcol align='left'>Media Type</ttcol>
      <ttcol align='left'>Content Coding</ttcol>
      <ttcol align='left'>ID</ttcol>
      <ttcol align='left'>Reference</ttcol>
      <c>application/json-patch+json</c>
      <c>identity</c>
      <c>51</c>
      <c><xref target="RFC6902"/></c>
      <c>application/merge-patch+json</c>
      <c>identity</c>
      <c>52</c>
      <c><xref target="RFC7396"/></c>
</texttable>
</section>

  </middle>

  <back>

    <references title='Normative References'>

<reference  anchor='RFC2119' target='http://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>

<reference  anchor='RFC5789' target='http://www.rfc-editor.org/info/rfc5789'>
<front>
<title>PATCH Method for HTTP</title>
<author initials='L.' surname='Dusseault' fullname='L. Dusseault'><organization /></author>
<author initials='J.' surname='Snell' fullname='J. Snell'><organization /></author>
<date year='2010' month='March' />
<abstract><t>Several applications extending the Hypertext Transfer Protocol (HTTP) require a feature to do partial resource modification.  The existing HTTP PUT method only allows a complete replacement of a document. This proposal adds a new HTTP method, PATCH, to modify an existing HTTP resource.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5789'/>
<seriesInfo name='DOI' value='10.17487/RFC5789'/>
</reference>

<reference  anchor='RFC7231' target='http://www.rfc-editor.org/info/rfc7231'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract>
</front>
<seriesInfo name='RFC' value='7231'/>
<seriesInfo name='DOI' value='10.17487/RFC7231'/>
</reference>

<reference  anchor='RFC7252' target='http://www.rfc-editor.org/info/rfc7252'>
<front>
<title>The Constrained Application Protocol (CoAP)</title>
<author initials='Z.' surname='Shelby' fullname='Z. Shelby'><organization /></author>
<author initials='K.' surname='Hartke' fullname='K. Hartke'><organization /></author>
<author initials='C.' surname='Bormann' fullname='C. Bormann'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Constrained Application Protocol (CoAP) is a specialized web transfer protocol for use with constrained nodes and constrained (e.g., low-power, lossy) networks.  The nodes often have 8-bit microcontrollers with small amounts of ROM and RAM, while constrained networks such as IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs) often have high packet error rates and a typical throughput of 10s of kbit/s.  The protocol is designed for machine- to-machine (M2M) applications such as smart energy and building automation.</t><t>CoAP provides a request/response interaction model between application endpoints, supports built-in discovery of services and resources, and includes key concepts of the Web such as URIs and Internet media types.  CoAP is designed to easily interface with HTTP for integration with the Web while meeting specialized requirements such as multicast support, very low overhead, and simplicity for constrained environments.</t></abstract>
</front>
<seriesInfo name='RFC' value='7252'/>
<seriesInfo name='DOI' value='10.17487/RFC7252'/>
</reference>



<reference  anchor='RFC7641' target='http://www.rfc-editor.org/info/rfc7641'>
<front>
<title>Observing Resources in the Constrained Application Protocol (CoAP)</title>
<author initials='K.' surname='Hartke' fullname='K. Hartke'><organization /></author>
<date year='2015' month='September' />
<abstract><t>The Constrained Application Protocol (CoAP) is a RESTful application protocol for constrained nodes and networks.  The state of a resource on a CoAP server can change over time.  This document specifies a simple protocol extension for CoAP that enables CoAP clients to &quot;observe&quot; resources, i.e., to retrieve a representation of a resource and keep this representation updated by the server over a period of time.  The protocol follows a best-effort approach for sending new representations to clients and provides eventual consistency between the state observed by each client and the actual resource state at the server.</t></abstract>
</front>
<seriesInfo name='RFC' value='7641'/>
<seriesInfo name='DOI' value='10.17487/RFC7641'/>
</reference>



<reference  anchor='RFC7959' target='http://www.rfc-editor.org/info/rfc7959'>
<front>
<title>Block-Wise Transfers in the Constrained Application Protocol (CoAP)</title>
<author initials='C.' surname='Bormann' fullname='C. Bormann'><organization /></author>
<author initials='Z.' surname='Shelby' fullname='Z. Shelby' role='editor'><organization /></author>
<date year='2016' month='August' />
<abstract><t>The Constrained Application Protocol (CoAP) is a RESTful transfer protocol for constrained nodes and networks.  Basic CoAP messages work well for small payloads from sensors and actuators; however, applications will need to transfer larger payloads occasionally -- for instance, for firmware updates.  In contrast to HTTP, where TCP does the grunt work of segmenting and resequencing, CoAP is based on datagram transports such as UDP or Datagram Transport Layer Security (DTLS).  These transports only offer fragmentation, which is even more problematic in constrained nodes and networks, limiting the maximum size of resource representations that can practically be transferred.</t><t>Instead of relying on IP fragmentation, this specification extends basic CoAP with a pair of &quot;Block&quot; options for transferring multiple blocks of information from a resource representation in multiple request-response pairs.  In many important cases, the Block options enable a server to be truly stateless: the server can handle each block transfer separately, with no need for a connection setup or other server-side memory of previous block transfers.  Essentially, the Block options provide a minimal way to transfer larger representations in a block-wise fashion.</t><t>A CoAP implementation that does not support these options generally is limited in the size of the representations that can be exchanged, so there is an expectation that the Block options will be widely used in CoAP implementations.  Therefore, this specification updates RFC 7252.</t></abstract>
</front>
<seriesInfo name='RFC' value='7959'/>
<seriesInfo name='DOI' value='10.17487/RFC7959'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor='RFC5323' target='http://www.rfc-editor.org/info/rfc5323'>
<front>
<title>Web Distributed Authoring and Versioning (WebDAV) SEARCH</title>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<author initials='S.' surname='Reddy' fullname='S. Reddy'><organization /></author>
<author initials='J.' surname='Davis' fullname='J. Davis'><organization /></author>
<author initials='A.' surname='Babich' fullname='A. Babich'><organization /></author>
<date year='2008' month='November' />
<abstract><t>This document specifies a set of methods, headers, and properties composing Web Distributed Authoring and Versioning (WebDAV) SEARCH, an application of the HTTP/1.1 protocol to efficiently search for DAV resources based upon a set of client-supplied criteria.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5323'/>
<seriesInfo name='DOI' value='10.17487/RFC5323'/>
</reference>



<reference  anchor='RFC6902' target='http://www.rfc-editor.org/info/rfc6902'>
<front>
<title>JavaScript Object Notation (JSON) Patch</title>
<author initials='P.' surname='Bryan' fullname='P. Bryan' role='editor'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<date year='2013' month='April' />
<abstract><t>JSON Patch defines a JSON document structure for expressing a sequence of operations to apply to a JavaScript Object Notation (JSON) document; it is suitable for use with the HTTP PATCH method. The &quot;application/json-patch+json&quot; media type is used to identify such patch documents.</t></abstract>
</front>
<seriesInfo name='RFC' value='6902'/>
<seriesInfo name='DOI' value='10.17487/RFC6902'/>
</reference>



<reference  anchor='RFC7159' target='http://www.rfc-editor.org/info/rfc7159'>
<front>
<title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
<author initials='T.' surname='Bray' fullname='T. Bray' role='editor'><organization /></author>
<date year='2014' month='March' />
<abstract><t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t><t>This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t></abstract>
</front>
<seriesInfo name='RFC' value='7159'/>
<seriesInfo name='DOI' value='10.17487/RFC7159'/>
</reference>



<reference  anchor='RFC7396' target='http://www.rfc-editor.org/info/rfc7396'>
<front>
<title>JSON Merge Patch</title>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'><organization /></author>
<author initials='J.' surname='Snell' fullname='J. Snell'><organization /></author>
<date year='2014' month='October' />
<abstract><t>This specification defines the JSON merge patch format and processing rules.  The merge patch format is primarily intended for use with the HTTP PATCH method as a means of describing a set of modifications to a target resource's content.</t></abstract>
</front>
<seriesInfo name='RFC' value='7396'/>
<seriesInfo name='DOI' value='10.17487/RFC7396'/>
</reference>

<!-- draft-vanderstok-core-comi-10: I-D Replaced with draft-ietf-core-comi-00 -->

<reference anchor='COAP-MGMNT'>
<front>
<title>CoAP Management Interface</title>

<author initials='P' surname='Stok' fullname='Peter Van der Stok'>
    <organization />
</author>

<author initials='A' surname='Bierman' fullname='Andy Bierman'>
    <organization />
</author>

<author initials='M' surname='Veillette' fullname='Michel Veillette'>
    <organization />
</author>

<author initials='A' surname='Pelov' fullname='Alexander Pelov'>
    <organization />
</author>

<date month='January' year='2017' />

<abstract><t>This document describes a network management interface for constrained devices and networks, called CoAP Management Interface (CoMI).  The Constrained Application Protocol (CoAP) is used to access data resources specified in YANG, or SMIv2 converted to YANG. CoMI uses the YANG to CBOR mapping and converts YANG identifier strings to numeric identifiers for payload size reduction.  CoMI extends the set of YANG based protocols, NETCONF and RESTCONF, with the capability to manage constrained devices and networks.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-ietf-core-comi-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-core-comi-00.txt' />
<format type='PDF'
        target='http://www.ietf.org/internet-drafts/draft-ietf-core-comi-00.pdf' />
</reference>

<!-- draft-hartke-core-apps-05: I-D updated to draft-hartke-core-apps-07 -->

<reference anchor='CORE-APP'>
<front>
<title>CoRE Application Descriptions</title>

<author initials='K' surname='Hartke' fullname='Klaus Hartke'>
    <organization />
</author>

<date month='February' day='12' year='2017' />

<abstract><t>The interfaces of RESTful, hypermedia-driven Web applications consist of reusable components such as Internet media types and link relation types.  This document proposes CoRE Application Descriptions, a convention for application designers to describe the programmable interfaces of their applications in a structured way so that other parties can easily develop interoperable clients and servers or reuse the components in their own applications.</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-hartke-core-apps-07' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-hartke-core-apps-07.txt' />
</reference>

<!-- draft-snell-search-method-00: I-D Expired -->

<reference anchor='HTTP-SEARCH'>
<front>
<title>HTTP SEARCH Method</title>

<author initials='J' surname='Reschke' fullname='Julian Reschke'>
    <organization />
</author>

<author initials='A' surname='Malhotra' fullname='Ashok Malhotra'>
    <organization />
</author>

<author initials='J' surname='Snell' fullname='James Snell'>
    <organization />
</author>

<date month='April' year='2015' />

<abstract><t>This specification updates the definition and semantics of the HTTP SEARCH request method previously defined by [RFC5323].</t></abstract>

</front>

<seriesInfo name='Work in Progress,' value='draft-snell-search-method-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-snell-search-method-00.txt' />
</reference>




    </references>


<section numbered="no" anchor="acknowledgements" title="Acknowledgements">

<t>Klaus Hartke has pointed out some essential differences between CoAP and
HTTP concerning PATCH and found a number of problems in an earlier draft version
of <xref target="fetch"/>. We are grateful for discussions with Christian Amsuss,
Andy Bierman, Timothy Carey, Paul
Duffy, Matthias Kovatsch, Michel Veillette, Michael Verschoor, Thomas Watteyne,
and Gengyu Wei.  Christian Groves provided detailed
comments during the Working Group Last Call, and Christer Holmberg's
Gen-ART review provided some further editorial improvement.
Further Last Call reviews were provided by Sheng Jiang and Phillip
Hallam-Baker.
As usual, the IESG had some very good reviews, and we would like to
specifically call out those by Alexey Melnikov (responsible AD) and
Alissa Cooper.</t>

<!--  LocalWords:  atomicity iPATCH idempotence cacheable varyingly
 -->
<!--  LocalWords:  idempotency Unprocessable
 -->

</section>


  </back>
</rfc>

